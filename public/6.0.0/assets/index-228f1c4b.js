var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
const main$B = "";
const LogLevelData = {
  info: {
    capt: "INFO"
  },
  warn: {
    capt: "WARN"
  },
  error: {
    capt: "ERRR"
  },
  critical: {
    capt: "CRIT"
  }
};
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["info"] = 0] = "info";
  LogLevel2[LogLevel2["warn"] = 1] = "warn";
  LogLevel2[LogLevel2["error"] = 2] = "error";
  LogLevel2[LogLevel2["critical"] = 3] = "critical";
  return LogLevel2;
})(LogLevel || {});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u3 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d3 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
      return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
    } }, m3 = function(t3, e3, n3) {
      var r3 = String(t3);
      return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
    }, v2 = { s: m3, z: function(t3) {
      var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
      return (e3 <= 0 ? "+" : "-") + m3(r3, 2, "0") + ":" + m3(i3, 2, "0");
    }, m: function t3(e3, n3) {
      if (e3.date() < n3.date())
        return -t3(n3, e3);
      var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c2), s3 = n3 - i3 < 0, u4 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
      return +(-(r3 + (n3 - i3) / (s3 ? i3 - u4 : u4 - i3)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c2, y: h2, w: o2, d: a2, D: d3, h: u3, m: s2, s: i2, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g2 = "en", D2 = {};
    D2[g2] = M2;
    var p2 = "$isDayjsObject", S2 = function(t3) {
      return t3 instanceof _2 || !(!t3 || !t3[p2]);
    }, w2 = function t3(e3, n3, r3) {
      var i3;
      if (!e3)
        return g2;
      if ("string" == typeof e3) {
        var s3 = e3.toLowerCase();
        D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
        var u4 = e3.split("-");
        if (!i3 && u4.length > 1)
          return t3(u4[0]);
      } else {
        var a3 = e3.name;
        D2[a3] = e3, i3 = a3;
      }
      return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
    }, O2 = function(t3, e3) {
      if (S2(t3))
        return t3.clone();
      var n3 = "object" == typeof e3 ? e3 : {};
      return n3.date = t3, n3.args = arguments, new _2(n3);
    }, b2 = v2;
    b2.l = w2, b2.i = S2, b2.w = function(t3, e3) {
      return O2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _2 = function() {
      function M3(t3) {
        this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
      }
      var m4 = M3.prototype;
      return m4.parse = function(t3) {
        this.$d = function(t4) {
          var e3 = t4.date, n3 = t4.utc;
          if (null === e3)
            return /* @__PURE__ */ new Date(NaN);
          if (b2.u(e3))
            return /* @__PURE__ */ new Date();
          if (e3 instanceof Date)
            return new Date(e3);
          if ("string" == typeof e3 && !/Z$/i.test(e3)) {
            var r3 = e3.match($2);
            if (r3) {
              var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
            }
          }
          return new Date(e3);
        }(t3), this.init();
      }, m4.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m4.$utils = function() {
        return b2;
      }, m4.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m4.isSame = function(t3, e3) {
        var n3 = O2(t3);
        return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
      }, m4.isAfter = function(t3, e3) {
        return O2(t3) < this.startOf(e3);
      }, m4.isBefore = function(t3, e3) {
        return this.endOf(e3) < O2(t3);
      }, m4.$g = function(t3, e3, n3) {
        return b2.u(t3) ? this[e3] : this.set(n3, t3);
      }, m4.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m4.valueOf = function() {
        return this.$d.getTime();
      }, m4.startOf = function(t3, e3) {
        var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = function(t4, e4) {
          var i3 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
          return r3 ? i3 : i3.endOf(a2);
        }, $3 = function(t4, e4) {
          return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
        }, y3 = this.$W, M4 = this.$M, m5 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
        switch (f3) {
          case h2:
            return r3 ? l3(1, 0) : l3(31, 11);
          case c2:
            return r3 ? l3(1, M4) : l3(0, M4 + 1);
          case o2:
            var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
            return l3(r3 ? m5 - D3 : m5 + (6 - D3), M4);
          case a2:
          case d3:
            return $3(v3 + "Hours", 0);
          case u3:
            return $3(v3 + "Minutes", 1);
          case s2:
            return $3(v3 + "Seconds", 2);
          case i2:
            return $3(v3 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m4.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m4.$set = function(t3, e3) {
        var n3, o3 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f3 + "Date", n3[d3] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u3] = f3 + "Hours", n3[s2] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $3 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === c2 || o3 === h2) {
          var y3 = this.clone().set(d3, 1);
          y3.$d[l3]($3), y3.init(), this.$d = y3.set(d3, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          l3 && this.$d[l3]($3);
        return this.init(), this;
      }, m4.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m4.get = function(t3) {
        return this[b2.p(t3)]();
      }, m4.add = function(r3, f3) {
        var d4, l3 = this;
        r3 = Number(r3);
        var $3 = b2.p(f3), y3 = function(t3) {
          var e3 = O2(l3);
          return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
        };
        if ($3 === c2)
          return this.set(c2, this.$M + r3);
        if ($3 === h2)
          return this.set(h2, this.$y + r3);
        if ($3 === a2)
          return y3(1);
        if ($3 === o2)
          return y3(7);
        var M4 = (d4 = {}, d4[s2] = e2, d4[u3] = n2, d4[i2] = t2, d4)[$3] || 1, m5 = this.$d.getTime() + r3 * M4;
        return b2.w(m5, this);
      }, m4.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m4.format = function(t3) {
        var e3 = this, n3 = this.$locale();
        if (!this.isValid())
          return n3.invalidDate || l2;
        var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b2.z(this), s3 = this.$H, u4 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i4, s4) {
          return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s4);
        }, d4 = function(t4) {
          return b2.s(s3 % 12 || 12, t4, "0");
        }, $3 = f3 || function(t4, e4, n4) {
          var r4 = t4 < 12 ? "AM" : "PM";
          return n4 ? r4.toLowerCase() : r4;
        };
        return r3.replace(y2, function(t4, r4) {
          return r4 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e3.$y).slice(-2);
              case "YYYY":
                return b2.s(e3.$y, 4, "0");
              case "M":
                return a3 + 1;
              case "MM":
                return b2.s(a3 + 1, 2, "0");
              case "MMM":
                return h3(n3.monthsShort, a3, c3, 3);
              case "MMMM":
                return h3(c3, a3);
              case "D":
                return e3.$D;
              case "DD":
                return b2.s(e3.$D, 2, "0");
              case "d":
                return String(e3.$W);
              case "dd":
                return h3(n3.weekdaysMin, e3.$W, o3, 2);
              case "ddd":
                return h3(n3.weekdaysShort, e3.$W, o3, 3);
              case "dddd":
                return o3[e3.$W];
              case "H":
                return String(s3);
              case "HH":
                return b2.s(s3, 2, "0");
              case "h":
                return d4(1);
              case "hh":
                return d4(2);
              case "a":
                return $3(s3, u4, true);
              case "A":
                return $3(s3, u4, false);
              case "m":
                return String(u4);
              case "mm":
                return b2.s(u4, 2, "0");
              case "s":
                return String(e3.$s);
              case "ss":
                return b2.s(e3.$s, 2, "0");
              case "SSS":
                return b2.s(e3.$ms, 3, "0");
              case "Z":
                return i3;
            }
            return null;
          }(t4) || i3.replace(":", "");
        });
      }, m4.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m4.diff = function(r3, d4, l3) {
        var $3, y3 = this, M4 = b2.p(d4), m5 = O2(r3), v3 = (m5.utcOffset() - this.utcOffset()) * e2, g3 = this - m5, D3 = function() {
          return b2.m(y3, m5);
        };
        switch (M4) {
          case h2:
            $3 = D3() / 12;
            break;
          case c2:
            $3 = D3();
            break;
          case f2:
            $3 = D3() / 3;
            break;
          case o2:
            $3 = (g3 - v3) / 6048e5;
            break;
          case a2:
            $3 = (g3 - v3) / 864e5;
            break;
          case u3:
            $3 = g3 / n2;
            break;
          case s2:
            $3 = g3 / e2;
            break;
          case i2:
            $3 = g3 / t2;
            break;
          default:
            $3 = g3;
        }
        return l3 ? $3 : b2.a($3);
      }, m4.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m4.$locale = function() {
        return D2[this.$L];
      }, m4.locale = function(t3, e3) {
        if (!t3)
          return this.$L;
        var n3 = this.clone(), r3 = w2(t3, e3, true);
        return r3 && (n3.$L = r3), n3;
      }, m4.clone = function() {
        return b2.w(this.$d, this);
      }, m4.toDate = function() {
        return new Date(this.valueOf());
      }, m4.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m4.toISOString = function() {
        return this.$d.toISOString();
      }, m4.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), k2 = _2.prototype;
    return O2.prototype = k2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u3], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d3]].forEach(function(t3) {
      k2[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), O2.extend = function(t3, e3) {
      return t3.$i || (t3(e3, _2, O2), t3.$i = true), O2;
    }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t3) {
      return O2(1e3 * t3);
    }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
function noop$1() {
}
function assign(tar, src) {
  for (const k2 in src)
    tar[k2] = src[k2];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || a2 && typeof a2 === "object" || typeof a2 === "function";
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop$1;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_2) => value = _2)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i2 = 0; i2 < len; i2 += 1) {
        merged[i2] = $$scope.dirty[i2] | lets[i2];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i2 = 0; i2 < length; i2++) {
      dirty[i2] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k2 in props)
    if (k2[0] !== "$")
      result[k2] = props[k2];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k2 in props)
    if (!keys.has(k2) && k2[0] !== "$")
      rest[k2] = props[k2];
  return rest;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$1;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i2 = 0; i2 < iterations.length; i2 += 1) {
    if (iterations[i2])
      iterations[i2].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data2) {
  return document.createTextNode(data2);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options2) {
  node.addEventListener(event, handler, options2);
  return () => node.removeEventListener(event, handler, options2);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data2) {
  data2 = "" + data2;
  if (text2.data === data2)
    return;
  text2.data = /** @type {string} */
  data2;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key2, value, important) {
  if (value == null) {
    node.style.removeProperty(key2);
  } else {
    node.style.setProperty(key2, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i2 = 0; i2 < select.options.length; i2 += 1) {
    const option = select.options[i2];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
class HtmlTag {
  constructor(is_svg = false) {
    /**
     * @private
     * @default false
     */
    __publicField(this, "is_svg", false);
    /** parent for creating node */
    __publicField(this, "e");
    /** html tag nodes */
    __publicField(this, "n");
    /** target */
    __publicField(this, "t");
    /** anchor */
    __publicField(this, "a");
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target.nodeName
        );
      else
        this.e = element(
          /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? "TEMPLATE" : target.nodeName
        );
      this.t = target.tagName !== "TEMPLATE" ? target : (
        /** @type {HTMLTemplateElement} */
        target.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i2 = 0; i2 < this.n.length; i2 += 1) {
      insert(this.t, this.n[i2], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
}
function construct_svelte_component(component, props) {
  return new component(props);
}
let current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key2, context) {
  get_current_component().$$.context.set(key2, context);
  return context;
}
function getContext(key2) {
  return get_current_component().$$.context.get(key2);
}
const dirty_components = [];
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e2) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e2;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c2) => fns.indexOf(c2) === -1 ? filtered.push(c2) : targets.push(c2));
  targets.forEach((c2) => c2());
  render_callbacks = filtered;
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block2, local) {
  if (block2 && block2.i) {
    outroing.delete(block2);
    block2.i(local);
  }
}
function transition_out(block2, local, detach2, callback) {
  if (block2 && block2.o) {
    if (outroing.has(block2))
      return;
    outroing.add(block2);
    outros.c.push(() => {
      outroing.delete(block2);
      if (callback) {
        if (detach2)
          block2.d(1);
        callback();
      }
    });
    block2.o(local);
  } else if (callback) {
    callback();
  }
}
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i2 = levels.length;
  while (i2--) {
    const o2 = levels[i2];
    const n2 = updates[i2];
    if (n2) {
      for (const key2 in o2) {
        if (!(key2 in n2))
          to_null_out[key2] = 1;
      }
      for (const key2 in n2) {
        if (!accounted_for[key2]) {
          update2[key2] = n2[key2];
          accounted_for[key2] = 1;
        }
      }
      levels[i2] = n2;
    } else {
      for (const key2 in o2) {
        accounted_for[key2] = 1;
      }
    }
  }
  for (const key2 in to_null_out) {
    if (!(key2 in update2))
      update2[key2] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
function bind$1(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block2) {
  block2 && block2.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init$1(component, options2, instance2, create_fragment2, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop$1,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options2.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options2.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options2.props || {}, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
      if (!$$.skip_bound && $$.bound[i2])
        $$.bound[i2](value);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options2.target) {
    if (options2.hydrate) {
      const nodes = children(options2.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options2.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options2.target, options2.anchor);
    flush();
  }
  set_current_component(parent_component);
}
class SvelteComponent {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop$1;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop$1;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
}
const PUBLIC_VERSION = "4";
const subscriber_queue = [];
function writable(value, start2 = noop$1) {
  let stop2;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop2) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop$1) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop2 = start2(set, update2) || noop$1;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop2) {
        stop2();
        stop2 = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
async function getMode() {
  Log("branding", "Attempting to retrieve mode from /mode");
  try {
    const mode = await (await fetch("./mode")).text();
    ARCOS_MODE = mode.trim();
  } catch {
    ARCOS_MODE = "release";
  }
}
let ARCOS_MODE = "release";
function Store$1(initial) {
  const store = writable(initial);
  return { ...store, get: () => get_store_value(store) };
}
const LogStack = Store$1([]);
function pushToStack(source) {
  LogStack.update((v2) => {
    const previous = v2[v2.length - 1];
    if (previous == source)
      return v2;
    v2.push(source);
    return v2;
  });
  return LogStack.get().length;
}
function compileStackString() {
  const stack = LogStack.get().reverse();
  let str = "";
  for (const source of stack) {
    if (source == "ArcOS")
      continue;
    str += `  at [ArcOS] ${source}
`;
  }
  return str;
}
const LogStore = Store$1([]);
const CurrentLogItem = writable({
  level: LogLevel.info,
  source: "Console",
  msg: "Idle"
});
CurrentLogItem.subscribe((v2) => {
  if (ARCOS_MODE != "development")
    return;
  document.title = `ArcOS | ${v2.source} - ${v2.msg}`;
});
function Log(source, msg, level = LogLevel.info) {
  const data2 = { source, msg, level };
  data2.timestamp = (/* @__PURE__ */ new Date()).getTime();
  const levelCaption = LogLevelData[LogLevel[data2.level]].capt;
  const timestamp = dayjs(data2.timestamp || 0).format("HH:mm:ss.mmm");
  LogStore.update((currentLog) => {
    currentLog.push(data2);
    CurrentLogItem.set(data2);
    return currentLog;
  });
  pushToStack(source);
  console.log(`ArcOS: ${timestamp} [${levelCaption}] ${data2.source}: ${data2.msg}`);
}
function collectLogsBySource(reverse = false) {
  let logs = get_store_value(LogStore);
  if (reverse)
    logs = logs.reverse();
  let sources = [];
  let items = {};
  for (const log of logs) {
    if (!sources.includes(log.source)) {
      sources.push(log.source);
    }
    items[log.source] = Array.prototype.concat(items[log.source] || [], [log]);
  }
  return items;
}
function compileStringLog() {
  const result = [];
  const logs = get_store_value(LogStore);
  for (const log of logs) {
    const caption = LogLevelData[LogLevel[log.level]].capt;
    const time = dayjs(log.timestamp || 0).format("HH:mm:ss.mmm");
    result.push(`${time} [${caption}] ${log.source}: ${log.msg}`);
  }
  return result;
}
const LOG_BANS = ["expected prop", "unknown prop"];
function checkLogString(str) {
  for (const item of LOG_BANS) {
    if (str.includes(item))
      return false;
  }
  return true;
}
function setLoggingHooks() {
  Log("console/hooks", "Setting logging hooks");
  console.warn = (content, ...a2) => {
    if (!checkLogString(content))
      return;
    const joined = a2.join(" ");
    Log("console/hooks", `${content}${joined}`, LogLevel.warn);
  };
  console.error = (content, ...args) => {
    const joinedArgs = args.join(" ");
    Log("console/hooks", `${content}${joinedArgs}`, LogLevel.warn);
  };
}
class Cache {
  constructor(id, initial) {
    __publicField(this, "_data");
    __publicField(this, "id");
    this.id = id;
    if (initial)
      this.set(initial);
  }
  set(data2) {
    this._data = data2;
  }
  get() {
    return this._data;
  }
  clear() {
    this.set(null);
  }
}
const defaultUserData = {
  sh: {
    taskbar: {
      centered: false,
      labels: false,
      pos: "",
      docked: false,
      colored: false,
      isLauncher: false,
      clockSecs: false,
      clockDate: false,
      clock12hr: false,
      accentedStart: false
    },
    window: {
      bigtb: true,
      lefttb: false,
      buttons: "default",
      centertb: false
    },
    desktop: {
      wallpaper: "img04",
      icons: true,
      theme: "dark",
      sharp: false,
      accent: "a8dadc",
      pinnedApps: [],
      pinnedFiles: [],
      pinnedFolders: [],
      noCustomCursor: false,
      noIconGrid: false,
      lockIcons: false
    },
    start: {
      small: true,
      noGroups: false
    },
    anim: true,
    noGlass: false,
    noQuickSettings: false,
    compactContext: false,
    showHiddenApps: false,
    securityNoPassword: false,
    elevationDisabled: false
  },
  disabledApps: [],
  autoLoads: [],
  autoRun: [],
  askPresist: true,
  acc: {
    admin: false,
    enabled: true,
    profilePicture: 3
  },
  volume: {
    level: 1,
    muted: false
  },
  appdata: {
    experiments: {},
    ArcShell: {},
    QlorbApp: {},
    LightsOff: {},
    FileManager: {},
    ArcTerm: {},
    SettingsApp: {},
    AppInfo: {},
    LoggerApp: {},
    ErrorDialog: {},
    ProcessManager: {},
    SecureContext: {},
    ServiceInfo: {},
    ExitApp: {},
    TextEditor: {},
    LoadSaveDialog: {},
    desktopWallpaper: {}
  }
};
const UserName = Store$1();
const UserDataStore = Store$1(defaultUserData);
const UserToken = Store$1();
const UserCache = new Cache("UserCache", {});
function isDisabled(id) {
  const userdata = UserDataStore.get();
  return userdata.disabledApps.includes(id);
}
const sleep = (m3 = 0) => new Promise((r2) => setTimeout(r2, m3));
const Plural = (s2, x2) => `${s2}${x2 == 1 ? "" : "s"}`;
function CountInstances(input, search2) {
  return input.split(search2).length;
}
function RuntimeGlobalDispatches(runtime) {
  return {
    "minimize-all": () => runtime.minimize()
  };
}
function RuntimeScopedDispatches(runtime) {
  return {
    minimize: () => runtime.minimize(),
    maximize: () => runtime.maximize(),
    restore: () => runtime.restore(),
    "open-file": (file) => runtime.handleOpenFile(file),
    "snapping-disable": () => {
      runtime.appMutator.update((v2) => {
        v2.state.snapping = false;
        return v2;
      });
    },
    "snapping-set": (state) => {
      runtime.appMutator.update((v2) => {
        v2.state.snapState = state;
        v2.state.snapping = true;
        return v2;
      });
    }
  };
}
const KnownGlobalDispatchers = [
  "fs-flush",
  "services-flush",
  "desktop-show",
  "desktop-hide",
  "elevation-accept",
  "elevation-reject",
  "minimize-all",
  "message-flush",
  "rate-limit"
];
const DispatchCaptions = {
  "fs-flush": "Refresh all filesystem-dependent components",
  "services-flush": "Refresh all service-dependent components",
  "desktop-show": "Fade-in the desktop - used by auth management",
  "desktop-hide": "Fade-out the desktop - used by auth management",
  "elevation-accept": "Accept elevation for the specified elevation PID",
  "elevation-reject": "Reject elevation for the specified elevation PID",
  "minimize-all": "Minimize all opened windows",
  "message-flush": "Refresh all messaging-dependent components (MNS handled)",
  "rate-limit": "Triggers the RLNS to inform the user of a rate limit"
};
class GlobalDispatcher {
  constructor() {
    __publicField(this, "subscribers", {});
    this.Log("Creating new GlobalDispatcher");
  }
  Log(text2, level) {
    Log("process/dispatch/global", `GlobalDispatcher: ${text2}`, level);
  }
  subscribe(event, callback) {
    const id = Math.floor(Math.random() * 1e6);
    if (!this.subscribers[event])
      this.subscribers[event] = {};
    if (this.subscribers[event][id])
      return this.subscribe(event, callback);
    this.Log(`Subscribing on ID ${id} to event ${event}`);
    if (!this.subscribers[event])
      this.subscribers[event] = { [id]: callback };
    else
      this.subscribers[event][id] = callback;
    if (!KnownGlobalDispatchers.includes(event))
      this.Log(
        `Subscribing to unknown event ${event} on Global Dispatch. Don't do that.`,
        LogLevel.warn
      );
    return id;
  }
  unsubscribeId(event, id) {
    this.Log(`Unsubscribing ID ${id} of event ${event}`);
    delete this.subscribers[event][id];
  }
  discardEvent(event) {
    this.Log(`Discarding event ${event}`);
    delete this.subscribers[event];
  }
  dispatch(caller, data2) {
    this.Log(`Dispatching ${caller}`);
    const callers = this.subscribers[caller];
    if (!callers)
      return;
    const callbacks = [...Object.values(callers)];
    for (const callback of callbacks) {
      callback(data2);
    }
    if (!KnownGlobalDispatchers.includes(caller))
      this.Log(
        `Dispatching unknown event ${caller} over Global Dispatch. Don't do that.`,
        LogLevel.warn
      );
  }
}
const GlobalDispatch = new GlobalDispatcher();
const focusedPid = Store$1(0);
class AppRuntime {
  constructor(appData, appMutator, process) {
    __publicField(this, "app");
    __publicField(this, "PAGES", []);
    __publicField(this, "CurrentPage", Store$1(""));
    __publicField(this, "pid");
    __publicField(this, "openedFile", Store$1());
    __publicField(this, "APP_NAME", "");
    this.appMutator = appMutator;
    this.process = process;
    if (!appData.id) {
      this.Log(`Can't create AppRuntime without valid app ID`, "constructor", LogLevel.error);
      return;
    }
    this.APP_NAME = appData.metadata.name;
    this.app = appData;
    this.setPid(process.pid);
    this._subscribeToDispatch();
  }
  Log(message, fn = "<anonymous>", level = LogLevel.info) {
    Log(`${this.app.id}Runtime`, `${fn}: ${message}`, level);
  }
  switchPage(page) {
    this.Log(`Switching page to ${page}`, "switchPage");
    if (!this.PAGES.includes(page)) {
      this.Log(`Page ${page} doesn't exist!`, "switchPage", LogLevel.error);
      return false;
    }
    this.CurrentPage.set(page);
    this.onSwitchPage();
    return true;
  }
  onSwitchPage() {
    this.Log("Page changed!", "onSwitchPage");
  }
  setPid(pid) {
    this.Log(`Setting PID to ${pid}`, "setPid");
    this.pid = pid;
  }
  async closeApp() {
    const parent = this.process.parentPid;
    const result = await this.process.handler.kill(this.pid, true);
    if (result == "success" && parent)
      focusedPid.set(parent);
    return this;
  }
  minimize() {
    this.appMutator.update((v2) => {
      if (v2.metadata.core)
        return v2;
      v2.state.minimized = true;
      return v2;
    });
  }
  maximize() {
    this.appMutator.update((v2) => {
      if (v2.metadata.core || v2.state.snapping)
        return v2;
      v2.state.maximized = true;
      v2.state.minimized = false;
      return v2;
    });
  }
  restore() {
    this.appMutator.update((v2) => {
      if (v2.metadata.core)
        return v2;
      v2.state.maximized = false;
      return v2;
    });
  }
  _subscribeToDispatch() {
    const globals = RuntimeGlobalDispatches(this);
    const scoped = RuntimeScopedDispatches(this);
    for (const event in globals) {
      GlobalDispatch.subscribe(event, () => globals[event]());
    }
    for (const event in scoped) {
      this.process.handler.dispatch.subscribe(
        this.pid,
        event,
        (data2) => scoped[event](data2)
      );
    }
  }
  handleOpenFile(path) {
    this.openedFile.set(path);
  }
  loadAltMenu(...menu) {
    this.appMutator.update((v2) => {
      v2.altMenu = menu;
      return v2;
    });
  }
  setWindowTitle(text2, afterAppName = false) {
    this.appMutator.update((v2) => {
      v2.metadata.name = afterAppName ? `${this.APP_NAME} - ${text2}` : text2;
      return v2;
    });
  }
  setWindowIcon(path) {
    this.appMutator.update((v2) => {
      v2.metadata.icon = path;
      return v2;
    });
  }
}
class ProcessDispatcher {
  constructor(handler) {
    __publicField(this, "subscribers", {});
    this.handler = handler;
    this.Log("Creating new ProcessDispatcher");
  }
  Log(text2, level) {
    Log("process/dispatch", `ProcessDispatcher[${this.handler.id}]: ${text2}`, level);
  }
  subscribe(pid, event, callback) {
    if (!this.subscribers[pid])
      this.subscribers[pid] = { [event]: [] };
    if (!this.subscribers[pid][event])
      this.subscribers[pid][event] = [callback];
    else
      this.subscribers[pid][event].push(callback);
  }
  unsubscribe(pid) {
    this.Log(`Unsubscribing all of PID ${pid}`);
    delete this.subscribers[pid];
  }
  dispatchToApp(id, caller, data2) {
    this.Log(`Dispatching ${caller} to app ${id}`);
    const pids = this.handler.getAppPids(id);
    for (const pid of pids) {
      const pidSubscribers = this.subscribers[pid];
      if (!pidSubscribers || !pidSubscribers[caller])
        continue;
      const callers = pidSubscribers[caller];
      for (const event of callers) {
        event(data2);
      }
    }
  }
  dispatchToPid(pid, caller, data2) {
    this.Log(`Dispatching ${caller} to PID ${pid}`);
    const pidSubscribers = this.subscribers[pid];
    if (!pidSubscribers || !pidSubscribers[caller])
      return;
    const callers = pidSubscribers[caller];
    for (const event of callers) {
      event(data2);
    }
  }
}
class Process {
  constructor(handler, pid, name, app, args = []) {
    __publicField(this, "_disposed", false);
    __publicField(this, "_paused", false);
    __publicField(this, "_pausedError", "Not executing code in paused process");
    __publicField(this, "_criticalProcess", false);
    __publicField(this, "app", null);
    __publicField(this, "mutator", Store$1(null));
    __publicField(this, "parentPid", null);
    __publicField(this, "args", []);
    __publicField(this, "accelerator");
    this.handler = handler;
    this.pid = pid;
    this.name = name;
    this.app = app;
    this.args = args;
    if (this.app) {
      this.accelerator = new AcceleratorHandler(this);
      this.mutator.set(app);
    }
  }
  setParentPid(pid) {
    if (!this.handler.isPid(pid) || this.parentPid)
      return false;
    this.parentPid = pid;
  }
  Log(text2, level) {
    Log("process/instance", `ProcessHandler[${this.handler.id}][${this.name}]: ${text2}`, level);
  }
  start() {
  }
  stop() {
    return true;
  }
  pauseCheck() {
    if (this._disposed)
      return true;
    if (this._paused)
      this.Log(this._pausedError, LogLevel.error);
    return this._paused;
  }
  pause() {
    this.Log(`Pausing ${this.pid}`);
    if (this._paused) {
      this.Log(`Attempted to pause already paused process`, LogLevel.warn);
      return;
    }
    this._paused = true;
  }
  resume() {
    this.Log(`Resuming ${this.pid}`);
    if (!this._paused) {
      this.Log(`Attempted to resume unpaused process`, LogLevel.warn);
      return;
    }
    this._paused = false;
  }
  hasIdAsSubprocess(id) {
    const subprocesses = [...this.handler.getSubProcesses(this.pid)];
    for (const [_2, process] of subprocesses) {
      if (process._disposed)
        continue;
      if (process.app && process.app.id == id)
        return true;
    }
    return false;
  }
}
const PROCESS_LIMIT = 150;
class ProcessHandler {
  constructor(id) {
    __publicField(this, "processes", Store$1(/* @__PURE__ */ new Map([])));
    __publicField(this, "closedPids", Store$1([]));
    __publicField(this, "dispatch");
    this.id = id;
    this.Log(`Created Process Handler for ${id}`);
    this.dispatch = new ProcessDispatcher(this);
  }
  Log(text2, level) {
    Log("process/handler", `ProcessHandler[${this.id}]: ${text2}`, level);
  }
  // ### SECTION SPAWN ###
  async spawn({
    proc,
    name,
    parentPid,
    app,
    args
  }) {
    this.Log(`Spawning process ${proc.name} (isApp = ${!!app})`);
    if (app && isDisabled(app.id)) {
      this.Log(`Not spawning disabled application ${app.id}!`, LogLevel.error);
      return "err_disabled";
    }
    const aboveLimit = this.checkProcessLimit(!!app);
    const procs = this.processes.get();
    const pid = Math.floor(Math.random() * 1e6);
    if (aboveLimit)
      return "err_aboveLimit";
    if (procs.has(pid))
      return await this.spawn({ proc, name, parentPid, app, args });
    const instance2 = new proc(this, pid, name, app, args);
    if (parentPid)
      instance2.setParentPid(parentPid);
    procs.set(pid, instance2);
    this.processes.set(procs);
    await this.handleProcess(pid);
    return instance2;
  }
  async handleProcess(pid) {
    this.Log(`(internal) Handling process with PID ${pid} `);
    const procs = this.processes.get();
    if (!procs.has(pid))
      return false;
    const proc = procs.get(pid);
    if (proc._disposed)
      return false;
    if (proc.start)
      proc.start();
  }
  // ### END SECTION SPAWN ###
  // ### SECTION KILL ###
  async kill(pid, elevated) {
    this.Log(`Killing process with PID ${pid}`);
    const procs = this.processes.get();
    const proc = procs.get(pid);
    if (proc && proc._disposed)
      return "err_disposed";
    if (!procs.has(pid))
      return "err_noExist";
    if (!elevated)
      return "err_elevation";
    if (proc._criticalProcess)
      return "err_criticalProcess";
    if (proc.stop) {
      const cancelStop = !await proc.stop();
      if (cancelStop)
        return "err_killCancel";
    }
    await this._killSubProcesses(pid);
    await this._close(pid);
    this.dispatch.unsubscribe(pid);
    proc._disposed = true;
    procs.set(pid, proc);
    this.processes.set(procs);
    return "success";
  }
  async _killSubProcesses(pid) {
    const procs = this.getSubProcesses(pid);
    if (!procs.size)
      return;
    for (const [pid2, proc] of procs) {
      if (proc._disposed)
        continue;
      this.kill(pid2, true);
    }
  }
  async _close(pid) {
    this.Log(`(internal) Closing process with PID ${pid} `);
    const proc = this.getProcess(pid);
    if (!proc)
      return false;
    this.closedPids.update((v2) => {
      if (v2.includes(pid))
        return v2;
      v2.push(pid);
      return v2;
    });
    await sleep(proc.app ? 300 : 0);
    return true;
  }
  // ### END SECTION KILL ###
  // ### SECTION GETTERS ###
  getProcess(pid) {
    const procs = this.processes.get();
    if (!procs.has(pid))
      return null;
    const proc = procs.get(pid);
    return proc._disposed ? null : proc;
  }
  getSubProcesses(pPid) {
    const result = /* @__PURE__ */ new Map([]);
    if (!this.isPid(pPid))
      return result;
    const procs = this.processes.get();
    for (const [pid, proc] of procs) {
      if (proc.parentPid != pPid)
        continue;
      result.set(pid, proc);
    }
    return result;
  }
  getOverlayProcesses(pPid) {
    const children2 = this.getSubProcesses(pPid);
    const result = /* @__PURE__ */ new Map([]);
    for (const [pid, proc] of children2) {
      if (proc.parentPid != pPid || !proc.app || !proc.app.isOverlay)
        continue;
      result.set(pid, proc);
    }
    return result;
  }
  getAppPids(id) {
    const procs = this.processes.get();
    const result = [];
    for (const [pid, proc] of procs) {
      if (proc.app && proc.app.id == id && !this.isClosed(pid)) {
        result.push(pid);
      }
    }
    return result;
  }
  // ### END SECTION GETTERS ###
  // ### SECTION CHECKS ###
  isPid(pid, opened = false) {
    const procs = this.processes.get();
    const closed = this.closedPids.get();
    if (opened)
      return procs.has(pid) && !closed.includes(pid);
    return procs.has(pid) || closed.includes(pid);
  }
  isClosed(pid) {
    const closed = this.closedPids.get();
    return closed.includes(pid);
  }
  checkProcessLimit(isApp) {
    const apps = [...this.processes.get()].filter((a2) => !a2[1]._disposed && a2[1].app).length;
    const above = apps >= PROCESS_LIMIT && isApp;
    if (above)
      this.Log(
        `WARNING: Running app count is above ${PROCESS_LIMIT}, not spawning additional apps!`,
        LogLevel.critical
      );
    return above;
  }
  // ### END SECTION CHECKS ###
}
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
const main$A = "";
const ProcessStack = new ProcessHandler("Stack");
const colors = "red,orange,yellow,green,aqua,blue,purple".split(",");
function parseFlags(args) {
  const regex = /(?:--(?<nl>[a-z\-]+)(?:="(?<vl>.*?)"|(?:=(?<vs>.*?)(?: |$))|)|-(?<ns>[a-zA-Z]))/gm;
  const matches = [];
  let match;
  while (match = regex.exec(args)) {
    matches.push(match);
  }
  const result = {};
  const arglist = matches.map((match2) => {
    const name = match2.groups.nl || match2.groups.ns;
    const value = match2.groups.vl || match2.groups.vs || true;
    return { name, value };
  });
  for (const arg of arglist) {
    result[arg.name] = arg.value;
  }
  return result;
}
const Default$1 = {
  keyword: "default",
  async exec(cmd, argv, term) {
    if (!cmd || !term || !term.std || !term.std.verbose)
      return;
    if (!cmd.trim().replaceAll(" ", ""))
      return;
    const scriptPath = await term.scripts.detectScript(term.path, cmd);
    if (!scriptPath && term && term.std) {
      return term.std.Error(`${cmd}: command not found`);
    }
    await term.scripts.runScriptFile(scriptPath);
  },
  description: "Default command"
};
class ArcTermCommandHandler {
  constructor(term) {
    __publicField(this, "term");
    Log(`ArcTerm ${term.referenceId}`, `Creating new ArcTermCommandHandler`);
    this.term = term;
  }
  async evaluate(cmd, args, isScript = false, provider) {
    Log(`ArcTerm ${this.term.referenceId}`, `cmd.evaluate: ${cmd}`);
    const argStr = args.join(" ");
    if (cmd.startsWith("#"))
      return;
    const command = this.getCommand(cmd, provider);
    if (isScript && command.keyword == "default")
      return false;
    if (this.term.input && this.term.input.current)
      this.term.input.current.disabled = true;
    if (!this.requiredFlagsSpecified(command, argStr)) {
      this.term.std.Error(`${cmd}: missing required parameters. Type [help ${cmd}] for usage.`);
      if (this.term.std.verbose && !isScript)
        this.term.std.writeLine("\n");
      this.term.input.unlock();
      return false;
    }
    const result = await command.exec(cmd, args, this.term, parseFlags(argStr));
    if (this.term.std.verbose && !isScript)
      this.term.std.writeLine("\n");
    if (!isScript)
      this.term.input.unlock();
    if (result == false)
      return false;
    if (!this.term.std || !this.term.input)
      return true;
    return command.keyword != "default";
  }
  getCommand(command, provider) {
    const commandLower = command.toLowerCase();
    const commands = provider ? provider : this.term.commands;
    for (const command2 of commands) {
      const lower = command2.keyword.toLowerCase();
      if (lower == commandLower)
        return command2;
    }
    return Default$1;
  }
  compileFlagStr(command) {
    const flags = command.flags || [];
    let result = `${command.keyword} `;
    if (!flags.length)
      return result;
    for (const flag of flags) {
      const prefix = "--";
      const name = `[${flag.keyword}]${flag.required ? "" : "?"}`;
      const needsValue = !!flag.value;
      const q2 = needsValue && flag.value.type == "string" ? '"' : "";
      const suffix = needsValue ? `=${q2}[${flag.value.name}]${q2}` : "";
      result += `${prefix}${name}${suffix} `;
    }
    return `${result} ${command.syntax || ""}`;
  }
  compileHelpSwitches(command) {
    const flags = command.flags || [];
    let result = `
`;
    if (!flags.length)
      return result;
    for (const flag of flags) {
      const prefix = "--";
      const name = `[${flag.keyword}]${flag.required ? "" : "?"}`.padEnd(20, " ");
      const description = `${flag.description} ${flag.required ? "" : "(Optional)"}`;
      result += `${prefix}${name}${description}
`;
    }
    return result;
  }
  requiredFlagsSpecified(command, args) {
    if (!command.flags)
      return true;
    const flags = parseFlags(args);
    for (const flag of command.flags) {
      const value = flags[flag.keyword];
      const required = flag.required;
      const valueObject = flag.value;
      if (required && (!value || typeof value != (valueObject ? "string" : "boolean")))
        return false;
    }
    return true;
  }
}
function tryJsonConvert(content) {
  try {
    return JSON.parse(content);
  } catch {
    return content;
  }
}
async function blobToText(blob) {
  return await blob.text();
}
function textToBlob(text2, type = "text/plain") {
  return new Blob([text2], { type });
}
function arrayToBlob(buffer, type = "text/plain") {
  return new Blob([new Uint8Array(buffer)], {
    type
  });
}
function toBase64(input) {
  try {
    return btoa(input);
  } catch {
    Log(`base64`, `Couldn't convert ${input.length} bytes to Base64.`, LogLevel.error);
    return input;
  }
}
function fromBase64(input) {
  try {
    return atob(input);
  } catch {
    Log(`base64`, `Couldn't convert ${input.length} bytes to string.`, LogLevel.error);
    return input;
  }
}
const SafeModeBg = "" + new URL("safemode-83f166d5.png", import.meta.url).href;
const SafeModeStyle = `
--accent: #FFBB00 !important;
--accent-transparent: #FFBB0044 !important;
--accent-light: #FFBB00 !important;
--accent-lighter: #FFBB00 !important;
--accent-dark: #444 !important;
--accent-darkest: #000 !important;
--accent-light-transparent: #FFBB0077 !important;
--accent-light-invert: #000000 !important;
--wallpaper: url(${SafeModeBg});`;
const SafeMode = Store$1(false);
const contextData = Store$1();
const validContexMenuTags = [
  "button",
  "div",
  "span",
  "p",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "img"
];
const SEP_ITEM = { sep: true };
class NotificationProcess extends Process {
  constructor(handler, pid, name, app, args) {
    super(handler, pid, name, app, args);
    __publicField(this, "_pausedError", "Unable to handle notifications: I'm paused");
    __publicField(this, "_timeout");
    __publicField(this, "current", Store$1());
    __publicField(this, "store", Store$1(/* @__PURE__ */ new Map([])));
    setNotificationProc(this);
  }
  async send(data2) {
    if (this.pauseCheck())
      return;
    this.Log(`Sending: ${data2.title}`);
    clearTimeout(this._timeout);
    const notifications = this.store.get();
    const id = `${Math.floor(Math.random() * 1e9)}`;
    data2.timestamp = (/* @__PURE__ */ new Date()).getTime();
    notifications.set(id, data2);
    await sleep();
    this.store.set(notifications);
    this.current.set(id);
    if (!data2.timeout)
      return id;
    this._timeout = setTimeout(() => {
      this.current.set(null);
    }, data2.timeout);
    return id;
  }
  close() {
    if (this.pauseCheck())
      return;
    this.current.set(null);
  }
  stop() {
    this._paused = true;
    this.close();
    this.store.set(null);
    return true;
  }
  deleteNotification(id) {
    if (this.pauseCheck())
      return;
    const notifications = this.store.get();
    notifications.delete(id);
    this.store.set(notifications);
    if (this.current.get() == id)
      this.close();
  }
}
const NotificationService = {
  name: "Notification Service",
  description: "Handles sending, deleting and managing notifications.",
  process: NotificationProcess,
  initialState: "started",
  startCondition: () => PrimaryState.current.get().key == "desktop" && !SafeMode.get()
};
let notifProc = null;
function procCheck() {
  if (!notifProc)
    Log(
      `notif/interact`,
      `Can't handle notifications without a NotificationService to interact with.`,
      LogLevel.error
    );
  return !!notifProc;
}
const getNotificationStore = () => notifProc ? notifProc.store : null;
const getNotifCurrentStore = () => notifProc ? notifProc.current : null;
function setNotificationProc(proc) {
  Log(`notif/interact`, `Setting notification process to ${proc.pid}`);
  if (!proc)
    return Log("notif/interact", "Can't set NotifProc to invalid process!", LogLevel.error);
  notifProc = proc;
}
async function sendNotification(data2) {
  if (!procCheck())
    return;
  return await notifProc.send(data2);
}
function closeNotification() {
  if (!procCheck())
    return;
  notifProc.close();
}
function deleteNotification(id) {
  if (!procCheck())
    return;
  notifProc.deleteNotification(id);
}
function clearNotifications() {
  if (!procCheck())
    return;
  notifProc.store.set(/* @__PURE__ */ new Map([]));
}
function isNotificationServiceActive() {
  return notifProc && !notifProc._disposed && !notifProc._paused;
}
const Endpoints = {
  FsDirCreate: "/fs/dir/create",
  // v1,
  FsDirectory: "/fs/dir/get",
  // v1
  FsFileGet: "/fs/file/get",
  // v1
  FsFileWrite: "/fs/file/write",
  // v1
  FsQuota: "/fs/quota",
  // v1
  FsTree: "/fs/tree",
  // vq
  FsRm: "/fs/rm",
  // v1
  FsCp: "/fs/cp",
  // v1
  FsRename: "/fs/rename",
  // v1
  MetaData: "/v2/",
  NewUsers: "/v2/users/",
  Token: "/v2/token/",
  UserData: "/v2/users/me",
  Users: "/users/get",
  // v1
  UserRename: "/user/rename",
  // v1
  UserChangePassword: "/user/changepswd",
  // v1
  LogoffToken: "/logoff",
  // v1
  MessagesSend: "/messages/send",
  MessagesReply: "/messages/reply",
  MessagesThread: "/messages/thread",
  MessagesList: "/messages/list",
  MessagesGet: "/messages/get",
  MessagesDelete: "/messages/delete"
};
function isStoredEndpoint(endpoint) {
  const store = Object.values(Endpoints);
  return store.includes(endpoint);
}
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString: toString$1 } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache) => (thing) => {
  const str = toString$1.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray: isArray$2 } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString$2 = typeOfTest("string");
const isFunction$1 = typeOfTest("function");
const isNumber$2 = typeOfTest("number");
const isObject$2 = (thing) => thing !== null && typeof thing === "object";
const isBoolean$2 = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$2(val) && isFunction$1(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$2(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key2;
    for (i2 = 0; i2 < len; i2++) {
      key2 = keys[i2];
      fn.call(null, obj[key2], key2, obj);
    }
  }
}
function findKey(obj, key2) {
  key2 = key2.toLowerCase();
  const keys = Object.keys(obj);
  let i2 = keys.length;
  let _key;
  while (i2-- > 0) {
    _key = keys[i2];
    if (key2 === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key2) => {
    const targetKey = caseless && findKey(result, key2) || key2;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray$2(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key2) => {
    if (thisArg && isFunction$1(val)) {
      a2[key2] = bind(val, thisArg);
    } else {
      a2[key2] = val;
    }
  }, { allOwnKeys });
  return a2;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray$2(thing))
    return thing;
  let i2 = thing.length;
  if (!isNumber$2(i2))
    return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m3, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction$1(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray$2(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$1(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject$2(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray$2(source) ? [] : {};
        forEach(source, (value, key2) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key2] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$2(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
const utils$1 = {
  isArray: isArray$2,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$2,
  isNumber: isNumber$2,
  isBoolean: isBoolean$2,
  isObject: isObject$2,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key2) {
  return utils$1.endsWith(key2, "[]") ? key2.slice(0, -2) : key2;
}
function renderKey(path, key2, dots) {
  if (!path)
    return key2;
  return path.concat(key2).map(function each(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options2) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options2 = utils$1.toFlatObject(options2, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options2.metaTokens;
  const visitor = options2.visitor || defaultVisitor;
  const dots = options2.dots;
  const indexes = options2.indexes;
  const _Blob = options2.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key2, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils$1.endsWith(key2, "{}")) {
        key2 = metaTokens ? key2 : key2.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key2, "[]")) && (arr = utils$1.toArray(value))) {
        key2 = removeBrackets(key2);
        arr.forEach(function each(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key2], index, dots) : indexes === null ? key2 : key2 + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key2, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$1.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils$1.forEach(value, function each(el, key2) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1.isString(key2) ? key2.trim() : key2,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key2) : [key2]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options2) {
  this._pairs = [];
  params && toFormData(params, this, options2);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append2(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options2) {
  if (!params) {
    return url;
  }
  const _encode = options2 && options2.encode || encode;
  const serializeFn = options2 && options2.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options2);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options2).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options2) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options2 ? options2.synchronous : false,
      runWhen: options2 ? options2.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data2, options2) {
  return toFormData(data2, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key2, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key2, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options2));
}
function parsePropPath(name) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i2;
  const len = keys.length;
  let key2;
  for (i2 = 0; i2 < len; i2++) {
    key2 = keys[i2];
    obj[key2] = arr[key2];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data2, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data2);
    if (isObjectPayload && utils$1.isHTMLForm(data2)) {
      data2 = new FormData(data2);
    }
    const isFormData2 = utils$1.isFormData(data2);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data2)) : data2;
    }
    if (utils$1.isArrayBuffer(data2) || utils$1.isBuffer(data2) || utils$1.isStream(data2) || utils$1.isFile(data2) || utils$1.isBlob(data2)) {
      return data2;
    }
    if (utils$1.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$1.isURLSearchParams(data2)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data2.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data2, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data2)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data2 } : data2,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    const transitional2 = this.transitional || defaults$1.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data2 && utils$1.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data2);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data2;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status2) {
    return status2 >= 200 && status2 < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults$1.headers[method] = {};
});
const defaults$2 = defaults$1;
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key2;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i2 = line.indexOf(":");
    key2 = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
      return;
    }
    if (key2 === "set-cookie") {
      if (parsed[key2]) {
        parsed[key2].push(val);
      } else {
        parsed[key2] = [val];
      }
    } else {
      parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header2) {
  return header2 && String(header2).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header2, filter2, isHeaderNameFilter) {
  if (utils$1.isFunction(filter2)) {
    return filter2.call(this, value, header2);
  }
  if (isHeaderNameFilter) {
    value = header2;
  }
  if (!utils$1.isString(value))
    return;
  if (utils$1.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$1.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header2) {
  return header2.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header2) {
  const accessorName = utils$1.toCamelCase(" " + header2);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header2, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header2, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key2 = utils$1.findKey(self2, lHeader);
      if (!key2 || self2[key2] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key2] !== false) {
        self2[key2 || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header2) || header2 instanceof this.constructor) {
      setHeaders(header2, valueOrRewrite);
    } else if (utils$1.isString(header2) && (header2 = header2.trim()) && !isValidHeaderName(header2)) {
      setHeaders(parseHeaders(header2), valueOrRewrite);
    } else {
      header2 != null && setHeader(valueOrRewrite, header2, rewrite);
    }
    return this;
  }
  get(header2, parser) {
    header2 = normalizeHeader(header2);
    if (header2) {
      const key2 = utils$1.findKey(this, header2);
      if (key2) {
        const value = this[key2];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key2);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header2, matcher) {
    header2 = normalizeHeader(header2);
    if (header2) {
      const key2 = utils$1.findKey(this, header2);
      return !!(key2 && this[key2] !== void 0 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
    }
    return false;
  }
  delete(header2, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key2 = utils$1.findKey(self2, _header);
        if (key2 && (!matcher || matchHeaderValue(self2, self2[key2], key2, matcher))) {
          delete self2[key2];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header2)) {
      header2.forEach(deleteHeader);
    } else {
      deleteHeader(header2);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i2 = keys.length;
    let deleted = false;
    while (i2--) {
      const key2 = keys[i2];
      if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
        delete this[key2];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value, header2) => {
      const key2 = utils$1.findKey(headers, header2);
      if (key2) {
        self2[key2] = normalizeValue(value);
        delete self2[header2];
        return;
      }
      const normalized = format2 ? formatHeader(header2) : String(header2).trim();
      if (normalized !== header2) {
        delete self2[header2];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value, header2) => {
      value != null && value !== false && (obj[header2] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header2, value]) => header2 + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header2) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header2) ? header2.forEach(defineAccessor) : defineAccessor(header2);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key2) => {
  let mapped = key2[0].toUpperCase() + key2.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config = this || defaults$2;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data2 = context.data;
  utils$1.forEach(fns, function transform(fn) {
    data2 = fn.call(config, data2, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data2;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain2, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path) && cookie.push("path=" + path);
      utils$1.isString(domain2) && cookie.push("domain=" + domain2);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data2 = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2
    };
    data2[isDownloadStream ? "download" : "upload"] = true;
    listener(data2);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    let { responseType, withXSRFToken } = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils$1.isFormData(requestData)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err2) {
        reject(err2);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
        request.setRequestHeader(key2, val);
      });
    }
    if (!utils$1.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol2 = parseProtocol(fullPath);
    if (protocol2 && platform.protocols.indexOf(protocol2) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol2 + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i2 = 0; i2 < length; i2++) {
      nameOrAdapter = adapters2[i2];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i2] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$2.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, caseless) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(a2, b2, caseless);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const VERSION = "1.6.8";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options2, schema, allowUnknown) {
  if (typeof options2 !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options2);
  let i2 = keys.length;
  while (i2-- > 0) {
    const opt = keys[i2];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options2[opt];
      const result = value === void 0 || validator2(value, opt, options2);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err2) {
      if (err2 instanceof Error) {
        let dummy2;
        Error.captureStackTrace ? Error.captureStackTrace(dummy2 = {}) : dummy2 = new Error();
        const stack = dummy2.stack ? dummy2.stack.replace(/^.+\n/, "") : "";
        if (!err2.stack) {
          err2.stack = stack;
        } else if (stack && !String(err2.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
          err2.stack += "\n" + stack;
        }
      }
      throw err2;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data2, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data2
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key2, value]) => {
  HttpStatusCode[value] = key2;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance2 = bind(Axios$1.prototype.request, context);
  utils$1.extend(instance2, Axios$1.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance2, context, null, { allOwnKeys: true });
  instance2.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance2;
}
const axios = createInstance(defaults$2);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
var extendStatics = function(e2, t2) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
    e3.__proto__ = t3;
  } || function(e3, t3) {
    for (var n2 in t3)
      Object.prototype.hasOwnProperty.call(t3, n2) && (e3[n2] = t3[n2]);
  }, extendStatics(e2, t2);
};
function __extends(e2, t2) {
  if ("function" != typeof t2 && null !== t2)
    throw new TypeError("Class extends value " + String(t2) + " is not a constructor or null");
  function __() {
    this.constructor = e2;
  }
  extendStatics(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (__.prototype = t2.prototype, new __());
}
var __assign = function() {
  return __assign = Object.assign || function __assign2(e2) {
    for (var t2, n2 = 1, i2 = arguments.length; n2 < i2; n2++)
      for (var o2 in t2 = arguments[n2])
        Object.prototype.hasOwnProperty.call(t2, o2) && (e2[o2] = t2[o2]);
    return e2;
  }, __assign.apply(this, arguments);
};
function __awaiter(e2, t2, n2, i2) {
  return new (n2 || (n2 = Promise))(function(o2, r2) {
    function fulfilled(e3) {
      try {
        step(i2.next(e3));
      } catch (e4) {
        r2(e4);
      }
    }
    function rejected(e3) {
      try {
        step(i2.throw(e3));
      } catch (e4) {
        r2(e4);
      }
    }
    function step(e3) {
      e3.done ? o2(e3.value) : function adopt(e4) {
        return e4 instanceof n2 ? e4 : new n2(function(t3) {
          t3(e4);
        });
      }(e3.value).then(fulfilled, rejected);
    }
    step((i2 = i2.apply(e2, t2 || [])).next());
  });
}
function __generator(e2, t2) {
  var n2, i2, o2, r2, s2 = { label: 0, sent: function() {
    if (1 & o2[0])
      throw o2[1];
    return o2[1];
  }, trys: [], ops: [] };
  return r2 = { next: verb(0), throw: verb(1), return: verb(2) }, "function" == typeof Symbol && (r2[Symbol.iterator] = function() {
    return this;
  }), r2;
  function verb(a2) {
    return function(c2) {
      return function step(a3) {
        if (n2)
          throw new TypeError("Generator is already executing.");
        for (; r2 && (r2 = 0, a3[0] && (s2 = 0)), s2; )
          try {
            if (n2 = 1, i2 && (o2 = 2 & a3[0] ? i2.return : a3[0] ? i2.throw || ((o2 = i2.return) && o2.call(i2), 0) : i2.next) && !(o2 = o2.call(i2, a3[1])).done)
              return o2;
            switch (i2 = 0, o2 && (a3 = [2 & a3[0], o2.value]), a3[0]) {
              case 0:
              case 1:
                o2 = a3;
                break;
              case 4:
                return s2.label++, { value: a3[1], done: false };
              case 5:
                s2.label++, i2 = a3[1], a3 = [0];
                continue;
              case 7:
                a3 = s2.ops.pop(), s2.trys.pop();
                continue;
              default:
                if (!(o2 = s2.trys, (o2 = o2.length > 0 && o2[o2.length - 1]) || 6 !== a3[0] && 2 !== a3[0])) {
                  s2 = 0;
                  continue;
                }
                if (3 === a3[0] && (!o2 || a3[1] > o2[0] && a3[1] < o2[3])) {
                  s2.label = a3[1];
                  break;
                }
                if (6 === a3[0] && s2.label < o2[1]) {
                  s2.label = o2[1], o2 = a3;
                  break;
                }
                if (o2 && s2.label < o2[2]) {
                  s2.label = o2[2], s2.ops.push(a3);
                  break;
                }
                o2[2] && s2.ops.pop(), s2.trys.pop();
                continue;
            }
            a3 = t2.call(e2, s2);
          } catch (e3) {
            a3 = [6, e3], i2 = 0;
          } finally {
            n2 = o2 = 0;
          }
        if (5 & a3[0])
          throw a3[1];
        return { value: a3[0] ? a3[1] : void 0, done: true };
      }([a2, c2]);
    };
  }
}
var e$2, t$2 = function(e2) {
  function ClientResponseError(t2) {
    var n2, i2, o2, r2, s2 = this;
    return (s2 = e2.call(this, "ClientResponseError") || this).url = "", s2.status = 0, s2.response = {}, s2.isAbort = false, s2.originalError = null, Object.setPrototypeOf(s2, ClientResponseError.prototype), null !== t2 && "object" == typeof t2 && (s2.url = "string" == typeof t2.url ? t2.url : "", s2.status = "number" == typeof t2.status ? t2.status : 0, s2.isAbort = !!t2.isAbort, s2.originalError = t2.originalError, null !== t2.response && "object" == typeof t2.response ? s2.response = t2.response : null !== t2.data && "object" == typeof t2.data ? s2.response = t2.data : s2.response = {}), s2.originalError || t2 instanceof ClientResponseError || (s2.originalError = t2), "undefined" != typeof DOMException && t2 instanceof DOMException && (s2.isAbort = true), s2.name = "ClientResponseError " + s2.status, s2.message = null === (n2 = s2.response) || void 0 === n2 ? void 0 : n2.message, s2.message || (s2.isAbort ? s2.message = "The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation." : (null === (r2 = null === (o2 = null === (i2 = s2.originalError) || void 0 === i2 ? void 0 : i2.cause) || void 0 === o2 ? void 0 : o2.message) || void 0 === r2 ? void 0 : r2.includes("ECONNREFUSED ::1")) ? s2.message = "Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21)." : s2.message = "Something went wrong while processing your request."), s2;
  }
  return __extends(ClientResponseError, e2), Object.defineProperty(ClientResponseError.prototype, "data", { get: function() {
    return this.response;
  }, enumerable: false, configurable: true }), ClientResponseError.prototype.toJSON = function() {
    return __assign({}, this);
  }, ClientResponseError;
}(Error), n$2 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function cookieSerialize(e2, t2, i2) {
  var o2 = Object.assign({}, i2 || {}), r2 = o2.encode || defaultEncode;
  if (!n$2.test(e2))
    throw new TypeError("argument name is invalid");
  var s2 = r2(t2);
  if (s2 && !n$2.test(s2))
    throw new TypeError("argument val is invalid");
  var a2 = e2 + "=" + s2;
  if (null != o2.maxAge) {
    var c2 = o2.maxAge - 0;
    if (isNaN(c2) || !isFinite(c2))
      throw new TypeError("option maxAge is invalid");
    a2 += "; Max-Age=" + Math.floor(c2);
  }
  if (o2.domain) {
    if (!n$2.test(o2.domain))
      throw new TypeError("option domain is invalid");
    a2 += "; Domain=" + o2.domain;
  }
  if (o2.path) {
    if (!n$2.test(o2.path))
      throw new TypeError("option path is invalid");
    a2 += "; Path=" + o2.path;
  }
  if (o2.expires) {
    if (!function isDate2(e3) {
      return "[object Date]" === Object.prototype.toString.call(e3) || e3 instanceof Date;
    }(o2.expires) || isNaN(o2.expires.valueOf()))
      throw new TypeError("option expires is invalid");
    a2 += "; Expires=" + o2.expires.toUTCString();
  }
  if (o2.httpOnly && (a2 += "; HttpOnly"), o2.secure && (a2 += "; Secure"), o2.priority)
    switch ("string" == typeof o2.priority ? o2.priority.toLowerCase() : o2.priority) {
      case "low":
        a2 += "; Priority=Low";
        break;
      case "medium":
        a2 += "; Priority=Medium";
        break;
      case "high":
        a2 += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  if (o2.sameSite)
    switch ("string" == typeof o2.sameSite ? o2.sameSite.toLowerCase() : o2.sameSite) {
      case true:
        a2 += "; SameSite=Strict";
        break;
      case "lax":
        a2 += "; SameSite=Lax";
        break;
      case "strict":
        a2 += "; SameSite=Strict";
        break;
      case "none":
        a2 += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  return a2;
}
function defaultDecode(e2) {
  return -1 !== e2.indexOf("%") ? decodeURIComponent(e2) : e2;
}
function defaultEncode(e2) {
  return encodeURIComponent(e2);
}
function getTokenPayload(t2) {
  if (t2)
    try {
      var n2 = decodeURIComponent(e$2(t2.split(".")[1]).split("").map(function(e2) {
        return "%" + ("00" + e2.charCodeAt(0).toString(16)).slice(-2);
      }).join(""));
      return JSON.parse(n2) || {};
    } catch (e2) {
    }
  return {};
}
function isTokenExpired(e2, t2) {
  void 0 === t2 && (t2 = 0);
  var n2 = getTokenPayload(e2);
  return !(Object.keys(n2).length > 0 && (!n2.exp || n2.exp - t2 > Date.now() / 1e3));
}
e$2 = "function" == typeof atob ? atob : function(e2) {
  var t2 = String(e2).replace(/=+$/, "");
  if (t2.length % 4 == 1)
    throw new Error("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var n2, i2, o2 = 0, r2 = 0, s2 = ""; i2 = t2.charAt(r2++); ~i2 && (n2 = o2 % 4 ? 64 * n2 + i2 : i2, o2++ % 4) ? s2 += String.fromCharCode(255 & n2 >> (-2 * o2 & 6)) : 0)
    i2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(i2);
  return s2;
};
var i$2 = function() {
  function BaseModel(e2) {
    void 0 === e2 && (e2 = {}), this.$load(e2 || {});
  }
  return BaseModel.prototype.load = function(e2) {
    return this.$load(e2);
  }, BaseModel.prototype.$load = function(e2) {
    for (var t2 = 0, n2 = Object.entries(e2); t2 < n2.length; t2++) {
      var i2 = n2[t2], o2 = i2[0], r2 = i2[1];
      this[o2] = r2;
    }
    this.id = void 0 !== e2.id ? e2.id : "", this.created = void 0 !== e2.created ? e2.created : "", this.updated = void 0 !== e2.updated ? e2.updated : "";
  }, Object.defineProperty(BaseModel.prototype, "$isNew", { get: function() {
    return !this.id;
  }, enumerable: false, configurable: true }), BaseModel.prototype.clone = function() {
    return this.$clone();
  }, BaseModel.prototype.$clone = function() {
    var e2 = "function" == typeof structuredClone ? structuredClone(this) : JSON.parse(JSON.stringify(this));
    return new this.constructor(e2);
  }, BaseModel.prototype.export = function() {
    return this.$export();
  }, BaseModel.prototype.$export = function() {
    return "function" == typeof structuredClone ? structuredClone(this) : Object.assign({}, this);
  }, BaseModel;
}(), o$2 = function(e2) {
  function Record() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(Record, e2), Record.prototype.$load = function(t2) {
    e2.prototype.$load.call(this, t2), this.collectionId = "string" == typeof t2.collectionId ? t2.collectionId : "", this.collectionName = "string" == typeof t2.collectionName ? t2.collectionName : "", this._loadExpand(t2.expand);
  }, Record.prototype._loadExpand = function(e3) {
    for (var t2 in e3 = e3 || {}, this.expand = {}, e3)
      Array.isArray(e3[t2]) ? this.expand[t2] = e3[t2].map(function(e4) {
        return new Record(e4 || {});
      }) : this.expand[t2] = new Record(e3[t2] || {});
  }, Record;
}(i$2), r$2 = function(e2) {
  function Admin() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(Admin, e2), Admin.prototype.$load = function(t2) {
    e2.prototype.$load.call(this, t2), this.avatar = "number" == typeof t2.avatar ? t2.avatar : 0, this.email = "string" == typeof t2.email ? t2.email : "";
  }, Admin;
}(i$2), s$2 = "pb_auth", a$2 = function() {
  function BaseAuthStore() {
    this.baseToken = "", this.baseModel = null, this._onChangeCallbacks = [];
  }
  return Object.defineProperty(BaseAuthStore.prototype, "token", { get: function() {
    return this.baseToken;
  }, enumerable: false, configurable: true }), Object.defineProperty(BaseAuthStore.prototype, "model", { get: function() {
    return this.baseModel;
  }, enumerable: false, configurable: true }), Object.defineProperty(BaseAuthStore.prototype, "isValid", { get: function() {
    return !isTokenExpired(this.token);
  }, enumerable: false, configurable: true }), BaseAuthStore.prototype.save = function(e2, t2) {
    this.baseToken = e2 || "", this.baseModel = null !== t2 && "object" == typeof t2 ? void 0 !== t2.collectionId ? new o$2(t2) : new r$2(t2) : null, this.triggerChange();
  }, BaseAuthStore.prototype.clear = function() {
    this.baseToken = "", this.baseModel = null, this.triggerChange();
  }, BaseAuthStore.prototype.loadFromCookie = function(e2, t2) {
    void 0 === t2 && (t2 = s$2);
    var n2 = function cookieParse(e3, t3) {
      var n3 = {};
      if ("string" != typeof e3)
        return n3;
      for (var i3 = Object.assign({}, t3 || {}).decode || defaultDecode, o2 = 0; o2 < e3.length; ) {
        var r2 = e3.indexOf("=", o2);
        if (-1 === r2)
          break;
        var s2 = e3.indexOf(";", o2);
        if (-1 === s2)
          s2 = e3.length;
        else if (s2 < r2) {
          o2 = e3.lastIndexOf(";", r2 - 1) + 1;
          continue;
        }
        var a2 = e3.slice(o2, r2).trim();
        if (void 0 === n3[a2]) {
          var c2 = e3.slice(r2 + 1, s2).trim();
          34 === c2.charCodeAt(0) && (c2 = c2.slice(1, -1));
          try {
            n3[a2] = i3(c2);
          } catch (e4) {
            n3[a2] = c2;
          }
        }
        o2 = s2 + 1;
      }
      return n3;
    }(e2 || "")[t2] || "", i2 = {};
    try {
      (null === typeof (i2 = JSON.parse(n2)) || "object" != typeof i2 || Array.isArray(i2)) && (i2 = {});
    } catch (e3) {
    }
    this.save(i2.token || "", i2.model || null);
  }, BaseAuthStore.prototype.exportToCookie = function(e2, t2) {
    var n2, i2, r2;
    void 0 === t2 && (t2 = s$2);
    var a2 = { secure: true, sameSite: true, httpOnly: true, path: "/" }, c2 = getTokenPayload(this.token);
    (null == c2 ? void 0 : c2.exp) ? a2.expires = new Date(1e3 * c2.exp) : a2.expires = /* @__PURE__ */ new Date("1970-01-01"), e2 = Object.assign({}, a2, e2);
    var u3 = { token: this.token, model: (null === (n2 = this.model) || void 0 === n2 ? void 0 : n2.export()) || null }, l2 = cookieSerialize(t2, JSON.stringify(u3), e2), d3 = "undefined" != typeof Blob ? new Blob([l2]).size : l2.length;
    return u3.model && d3 > 4096 && (u3.model = { id: null === (i2 = null == u3 ? void 0 : u3.model) || void 0 === i2 ? void 0 : i2.id, email: null === (r2 = null == u3 ? void 0 : u3.model) || void 0 === r2 ? void 0 : r2.email }, this.model instanceof o$2 && (u3.model.username = this.model.username, u3.model.verified = this.model.verified, u3.model.collectionId = this.model.collectionId), l2 = cookieSerialize(t2, JSON.stringify(u3), e2)), l2;
  }, BaseAuthStore.prototype.onChange = function(e2, t2) {
    var n2 = this;
    return void 0 === t2 && (t2 = false), this._onChangeCallbacks.push(e2), t2 && e2(this.token, this.model), function() {
      for (var t3 = n2._onChangeCallbacks.length - 1; t3 >= 0; t3--)
        if (n2._onChangeCallbacks[t3] == e2)
          return delete n2._onChangeCallbacks[t3], void n2._onChangeCallbacks.splice(t3, 1);
    };
  }, BaseAuthStore.prototype.triggerChange = function() {
    for (var e2 = 0, t2 = this._onChangeCallbacks; e2 < t2.length; e2++) {
      var n2 = t2[e2];
      n2 && n2(this.token, this.model);
    }
  }, BaseAuthStore;
}(), c$1 = function(e2) {
  function LocalAuthStore(t2) {
    void 0 === t2 && (t2 = "pocketbase_auth");
    var n2 = e2.call(this) || this;
    return n2.storageFallback = {}, n2.storageKey = t2, n2;
  }
  return __extends(LocalAuthStore, e2), Object.defineProperty(LocalAuthStore.prototype, "token", { get: function() {
    return (this._storageGet(this.storageKey) || {}).token || "";
  }, enumerable: false, configurable: true }), Object.defineProperty(LocalAuthStore.prototype, "model", { get: function() {
    var e3, t2 = this._storageGet(this.storageKey) || {};
    return null === t2 || "object" != typeof t2 || null === t2.model || "object" != typeof t2.model ? null : void 0 === (null === (e3 = t2.model) || void 0 === e3 ? void 0 : e3.collectionId) ? new r$2(t2.model) : new o$2(t2.model);
  }, enumerable: false, configurable: true }), LocalAuthStore.prototype.save = function(t2, n2) {
    this._storageSet(this.storageKey, { token: t2, model: n2 }), e2.prototype.save.call(this, t2, n2);
  }, LocalAuthStore.prototype.clear = function() {
    this._storageRemove(this.storageKey), e2.prototype.clear.call(this);
  }, LocalAuthStore.prototype._storageGet = function(e3) {
    if ("undefined" != typeof window && (null === window || void 0 === window ? void 0 : window.localStorage)) {
      var t2 = window.localStorage.getItem(e3) || "";
      try {
        return JSON.parse(t2);
      } catch (e4) {
        return t2;
      }
    }
    return this.storageFallback[e3];
  }, LocalAuthStore.prototype._storageSet = function(e3, t2) {
    if ("undefined" != typeof window && (null === window || void 0 === window ? void 0 : window.localStorage)) {
      var n2 = t2;
      "string" != typeof t2 && (n2 = JSON.stringify(t2)), window.localStorage.setItem(e3, n2);
    } else
      this.storageFallback[e3] = t2;
  }, LocalAuthStore.prototype._storageRemove = function(e3) {
    var t2;
    "undefined" != typeof window && (null === window || void 0 === window ? void 0 : window.localStorage) && (null === (t2 = window.localStorage) || void 0 === t2 || t2.removeItem(e3)), delete this.storageFallback[e3];
  }, LocalAuthStore;
}(a$2), u$1 = function u(e2) {
  this.client = e2;
}, l$1 = function(e2) {
  function SettingsService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(SettingsService, e2), SettingsService.prototype.getAll = function(e3) {
    return void 0 === e3 && (e3 = {}), this.client.send("/api/settings", { method: "GET", params: e3 }).then(function(e4) {
      return e4 || {};
    });
  }, SettingsService.prototype.update = function(e3, t2) {
    return void 0 === e3 && (e3 = {}), void 0 === t2 && (t2 = {}), this.client.send("/api/settings", { method: "PATCH", params: t2, body: e3 }).then(function(e4) {
      return e4 || {};
    });
  }, SettingsService.prototype.testS3 = function(e3, t2) {
    void 0 === e3 && (e3 = "storage"), void 0 === t2 && (t2 = {});
    var n2 = { filesystem: e3 };
    return this.client.send("/api/settings/test/s3", { method: "POST", params: t2, body: n2 }).then(function() {
      return true;
    });
  }, SettingsService.prototype.testEmail = function(e3, t2, n2) {
    void 0 === n2 && (n2 = {});
    var i2 = { email: e3, template: t2 };
    return this.client.send("/api/settings/test/email", { method: "POST", params: n2, body: i2 }).then(function() {
      return true;
    });
  }, SettingsService.prototype.generateAppleClientSecret = function(e3, t2, n2, i2, o2, r2, s2) {
    return void 0 === r2 && (r2 = {}), void 0 === s2 && (s2 = {}), r2 = Object.assign({ clientId: e3, teamId: t2, keyId: n2, privateKey: i2, duration: o2 }, r2), this.client.send("/api/settings/apple/generate-client-secret", { method: "POST", params: s2, body: r2 });
  }, SettingsService;
}(u$1), d$2 = function d(e2, t2, n2, i2, o2) {
  this.page = e2 > 0 ? e2 : 1, this.perPage = t2 >= 0 ? t2 : 0, this.totalItems = n2 >= 0 ? n2 : 0, this.totalPages = i2 >= 0 ? i2 : 0, this.items = o2 || [];
}, h$1 = function(e2) {
  function CrudService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(CrudService, e2), CrudService.prototype.getFullList = function(e3, t2) {
    if ("number" == typeof e3)
      return this._getFullList(this.baseCrudPath, e3, t2);
    var n2 = Object.assign({}, e3, t2);
    return this._getFullList(this.baseCrudPath, n2.batch || 200, n2);
  }, CrudService.prototype.getList = function(e3, t2, n2) {
    return void 0 === e3 && (e3 = 1), void 0 === t2 && (t2 = 30), void 0 === n2 && (n2 = {}), this._getList(this.baseCrudPath, e3, t2, n2);
  }, CrudService.prototype.getFirstListItem = function(e3, t2) {
    return void 0 === t2 && (t2 = {}), this._getFirstListItem(this.baseCrudPath, e3, t2);
  }, CrudService.prototype.getOne = function(e3, t2) {
    return void 0 === t2 && (t2 = {}), this._getOne(this.baseCrudPath, e3, t2);
  }, CrudService.prototype.create = function(e3, t2) {
    return void 0 === e3 && (e3 = {}), void 0 === t2 && (t2 = {}), this._create(this.baseCrudPath, e3, t2);
  }, CrudService.prototype.update = function(e3, t2, n2) {
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), this._update(this.baseCrudPath, e3, t2, n2);
  }, CrudService.prototype.delete = function(e3, t2) {
    return void 0 === t2 && (t2 = {}), this._delete(this.baseCrudPath, e3, t2);
  }, CrudService;
}(function(e2) {
  function BaseCrudService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(BaseCrudService, e2), BaseCrudService.prototype._getFullList = function(e3, t2, n2) {
    var i2 = this;
    void 0 === t2 && (t2 = 200), void 0 === n2 && (n2 = {});
    var o2 = [], request = function(r2) {
      return __awaiter(i2, void 0, void 0, function() {
        return __generator(this, function(i3) {
          return [2, this._getList(e3, r2, t2 || 200, n2).then(function(e4) {
            var t3 = e4, n3 = t3.items, i4 = t3.totalItems;
            return o2 = o2.concat(n3), n3.length && i4 > o2.length ? request(r2 + 1) : o2;
          })];
        });
      });
    };
    return request(1);
  }, BaseCrudService.prototype._getList = function(e3, t2, n2, i2) {
    var o2 = this;
    return void 0 === t2 && (t2 = 1), void 0 === n2 && (n2 = 30), void 0 === i2 && (i2 = {}), i2 = Object.assign({ page: t2, perPage: n2 }, i2), this.client.send(e3, { method: "GET", params: i2 }).then(function(e4) {
      var t3 = [];
      if (null == e4 ? void 0 : e4.items) {
        e4.items = e4.items || [];
        for (var n3 = 0, i3 = e4.items; n3 < i3.length; n3++) {
          var r2 = i3[n3];
          t3.push(o2.decode(r2));
        }
      }
      return new d$2((null == e4 ? void 0 : e4.page) || 1, (null == e4 ? void 0 : e4.perPage) || 0, (null == e4 ? void 0 : e4.totalItems) || 0, (null == e4 ? void 0 : e4.totalPages) || 0, t3);
    });
  }, BaseCrudService.prototype._getOne = function(e3, t2, n2) {
    var i2 = this;
    return void 0 === n2 && (n2 = {}), this.client.send(e3 + "/" + encodeURIComponent(t2), { method: "GET", params: n2 }).then(function(e4) {
      return i2.decode(e4);
    });
  }, BaseCrudService.prototype._getFirstListItem = function(e3, n2, i2) {
    return void 0 === i2 && (i2 = {}), i2 = Object.assign({ filter: n2, $cancelKey: "one_by_filter_" + e3 + "_" + n2 }, i2), this._getList(e3, 1, 1, i2).then(function(e4) {
      var n3;
      if (!(null === (n3 = null == e4 ? void 0 : e4.items) || void 0 === n3 ? void 0 : n3.length))
        throw new t$2({ status: 404, data: { code: 404, message: "The requested resource wasn't found.", data: {} } });
      return e4.items[0];
    });
  }, BaseCrudService.prototype._create = function(e3, t2, n2) {
    var i2 = this;
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), this.client.send(e3, { method: "POST", params: n2, body: t2 }).then(function(e4) {
      return i2.decode(e4);
    });
  }, BaseCrudService.prototype._update = function(e3, t2, n2, i2) {
    var o2 = this;
    return void 0 === n2 && (n2 = {}), void 0 === i2 && (i2 = {}), this.client.send(e3 + "/" + encodeURIComponent(t2), { method: "PATCH", params: i2, body: n2 }).then(function(e4) {
      return o2.decode(e4);
    });
  }, BaseCrudService.prototype._delete = function(e3, t2, n2) {
    return void 0 === n2 && (n2 = {}), this.client.send(e3 + "/" + encodeURIComponent(t2), { method: "DELETE", params: n2 }).then(function() {
      return true;
    });
  }, BaseCrudService;
}(u$1)), p$1 = function(e2) {
  function AdminService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(AdminService, e2), AdminService.prototype.decode = function(e3) {
    return new r$2(e3);
  }, Object.defineProperty(AdminService.prototype, "baseCrudPath", { get: function() {
    return "/api/admins";
  }, enumerable: false, configurable: true }), AdminService.prototype.update = function(t2, n2, i2) {
    var o2 = this;
    return void 0 === n2 && (n2 = {}), void 0 === i2 && (i2 = {}), e2.prototype.update.call(this, t2, n2, i2).then(function(e3) {
      var t3, n3;
      return o2.client.authStore.model && void 0 === (null === (t3 = o2.client.authStore.model) || void 0 === t3 ? void 0 : t3.collectionId) && (null === (n3 = o2.client.authStore.model) || void 0 === n3 ? void 0 : n3.id) === (null == e3 ? void 0 : e3.id) && o2.client.authStore.save(o2.client.authStore.token, e3), e3;
    });
  }, AdminService.prototype.delete = function(t2, n2) {
    var i2 = this;
    return void 0 === n2 && (n2 = {}), e2.prototype.delete.call(this, t2, n2).then(function(e3) {
      var n3, o2;
      return e3 && i2.client.authStore.model && void 0 === (null === (n3 = i2.client.authStore.model) || void 0 === n3 ? void 0 : n3.collectionId) && (null === (o2 = i2.client.authStore.model) || void 0 === o2 ? void 0 : o2.id) === t2 && i2.client.authStore.clear(), e3;
    });
  }, AdminService.prototype.authResponse = function(e3) {
    var t2 = this.decode((null == e3 ? void 0 : e3.admin) || {});
    return (null == e3 ? void 0 : e3.token) && (null == e3 ? void 0 : e3.admin) && this.client.authStore.save(e3.token, t2), Object.assign({}, e3, { token: (null == e3 ? void 0 : e3.token) || "", admin: t2 });
  }, AdminService.prototype.authWithPassword = function(e3, t2, n2, i2) {
    return void 0 === n2 && (n2 = {}), void 0 === i2 && (i2 = {}), n2 = Object.assign({ identity: e3, password: t2 }, n2), this.client.send(this.baseCrudPath + "/auth-with-password", { method: "POST", params: i2, body: n2 }).then(this.authResponse.bind(this));
  }, AdminService.prototype.authRefresh = function(e3, t2) {
    return void 0 === e3 && (e3 = {}), void 0 === t2 && (t2 = {}), this.client.send(this.baseCrudPath + "/auth-refresh", { method: "POST", params: t2, body: e3 }).then(this.authResponse.bind(this));
  }, AdminService.prototype.requestPasswordReset = function(e3, t2, n2) {
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), t2 = Object.assign({ email: e3 }, t2), this.client.send(this.baseCrudPath + "/request-password-reset", { method: "POST", params: n2, body: t2 }).then(function() {
      return true;
    });
  }, AdminService.prototype.confirmPasswordReset = function(e3, t2, n2, i2, o2) {
    return void 0 === i2 && (i2 = {}), void 0 === o2 && (o2 = {}), i2 = Object.assign({ token: e3, password: t2, passwordConfirm: n2 }, i2), this.client.send(this.baseCrudPath + "/confirm-password-reset", { method: "POST", params: o2, body: i2 }).then(function() {
      return true;
    });
  }, AdminService;
}(h$1), v$1 = function(e2) {
  function ExternalAuth() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(ExternalAuth, e2), ExternalAuth.prototype.$load = function(t2) {
    e2.prototype.$load.call(this, t2), this.recordId = "string" == typeof t2.recordId ? t2.recordId : "", this.collectionId = "string" == typeof t2.collectionId ? t2.collectionId : "", this.provider = "string" == typeof t2.provider ? t2.provider : "", this.providerId = "string" == typeof t2.providerId ? t2.providerId : "";
  }, ExternalAuth;
}(i$2), f$1 = function(e2) {
  function RecordService(t2, n2) {
    var i2 = e2.call(this, t2) || this;
    return i2.collectionIdOrName = n2, i2;
  }
  return __extends(RecordService, e2), RecordService.prototype.decode = function(e3) {
    return new o$2(e3);
  }, Object.defineProperty(RecordService.prototype, "baseCrudPath", { get: function() {
    return this.baseCollectionPath + "/records";
  }, enumerable: false, configurable: true }), Object.defineProperty(RecordService.prototype, "baseCollectionPath", { get: function() {
    return "/api/collections/" + encodeURIComponent(this.collectionIdOrName);
  }, enumerable: false, configurable: true }), RecordService.prototype.subscribeOne = function(e3, t2) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(n2) {
        return console.warn("PocketBase: subscribeOne(recordId, callback) is deprecated. Please replace it with subscribe(recordId, callback)."), [2, this.client.realtime.subscribe(this.collectionIdOrName + "/" + e3, t2)];
      });
    });
  }, RecordService.prototype.subscribe = function(e3, t2) {
    return __awaiter(this, void 0, void 0, function() {
      var n2;
      return __generator(this, function(i2) {
        if ("function" == typeof e3)
          return console.warn("PocketBase: subscribe(callback) is deprecated. Please replace it with subscribe('*', callback)."), [2, this.client.realtime.subscribe(this.collectionIdOrName, e3)];
        if (!t2)
          throw new Error("Missing subscription callback.");
        if ("" === e3)
          throw new Error("Missing topic.");
        return n2 = this.collectionIdOrName, "*" !== e3 && (n2 += "/" + e3), [2, this.client.realtime.subscribe(n2, t2)];
      });
    });
  }, RecordService.prototype.unsubscribe = function(e3) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(t2) {
        return "*" === e3 ? [2, this.client.realtime.unsubscribe(this.collectionIdOrName)] : e3 ? [2, this.client.realtime.unsubscribe(this.collectionIdOrName + "/" + e3)] : [2, this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName)];
      });
    });
  }, RecordService.prototype.getFullList = function(t2, n2) {
    if ("number" == typeof t2)
      return e2.prototype.getFullList.call(this, t2, n2);
    var i2 = Object.assign({}, t2, n2);
    return e2.prototype.getFullList.call(this, i2);
  }, RecordService.prototype.getList = function(t2, n2, i2) {
    return void 0 === t2 && (t2 = 1), void 0 === n2 && (n2 = 30), void 0 === i2 && (i2 = {}), e2.prototype.getList.call(this, t2, n2, i2);
  }, RecordService.prototype.getFirstListItem = function(t2, n2) {
    return void 0 === n2 && (n2 = {}), e2.prototype.getFirstListItem.call(this, t2, n2);
  }, RecordService.prototype.getOne = function(t2, n2) {
    return void 0 === n2 && (n2 = {}), e2.prototype.getOne.call(this, t2, n2);
  }, RecordService.prototype.create = function(t2, n2) {
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), e2.prototype.create.call(this, t2, n2);
  }, RecordService.prototype.update = function(t2, n2, i2) {
    var o2 = this;
    return void 0 === n2 && (n2 = {}), void 0 === i2 && (i2 = {}), e2.prototype.update.call(this, t2, n2, i2).then(function(e3) {
      var t3, n3, i3;
      return (null === (t3 = o2.client.authStore.model) || void 0 === t3 ? void 0 : t3.id) !== (null == e3 ? void 0 : e3.id) || (null === (n3 = o2.client.authStore.model) || void 0 === n3 ? void 0 : n3.collectionId) !== o2.collectionIdOrName && (null === (i3 = o2.client.authStore.model) || void 0 === i3 ? void 0 : i3.collectionName) !== o2.collectionIdOrName || o2.client.authStore.save(o2.client.authStore.token, e3), e3;
    });
  }, RecordService.prototype.delete = function(t2, n2) {
    var i2 = this;
    return void 0 === n2 && (n2 = {}), e2.prototype.delete.call(this, t2, n2).then(function(e3) {
      var n3, o2, r2;
      return !e3 || (null === (n3 = i2.client.authStore.model) || void 0 === n3 ? void 0 : n3.id) !== t2 || (null === (o2 = i2.client.authStore.model) || void 0 === o2 ? void 0 : o2.collectionId) !== i2.collectionIdOrName && (null === (r2 = i2.client.authStore.model) || void 0 === r2 ? void 0 : r2.collectionName) !== i2.collectionIdOrName || i2.client.authStore.clear(), e3;
    });
  }, RecordService.prototype.authResponse = function(e3) {
    var t2 = this.decode((null == e3 ? void 0 : e3.record) || {});
    return this.client.authStore.save(null == e3 ? void 0 : e3.token, t2), Object.assign({}, e3, { token: (null == e3 ? void 0 : e3.token) || "", record: t2 });
  }, RecordService.prototype.listAuthMethods = function(e3) {
    return void 0 === e3 && (e3 = {}), this.client.send(this.baseCollectionPath + "/auth-methods", { method: "GET", params: e3 }).then(function(e4) {
      return Object.assign({}, e4, { usernamePassword: !!(null == e4 ? void 0 : e4.usernamePassword), emailPassword: !!(null == e4 ? void 0 : e4.emailPassword), authProviders: Array.isArray(null == e4 ? void 0 : e4.authProviders) ? null == e4 ? void 0 : e4.authProviders : [] });
    });
  }, RecordService.prototype.authWithPassword = function(e3, t2, n2, i2) {
    var o2 = this;
    return void 0 === n2 && (n2 = {}), void 0 === i2 && (i2 = {}), n2 = Object.assign({ identity: e3, password: t2 }, n2), this.client.send(this.baseCollectionPath + "/auth-with-password", { method: "POST", params: i2, body: n2 }).then(function(e4) {
      return o2.authResponse(e4);
    });
  }, RecordService.prototype.authWithOAuth2Code = function(e3, t2, n2, i2, o2, r2, s2) {
    var a2 = this;
    return void 0 === o2 && (o2 = {}), void 0 === r2 && (r2 = {}), void 0 === s2 && (s2 = {}), r2 = Object.assign({ provider: e3, code: t2, codeVerifier: n2, redirectUrl: i2, createData: o2 }, r2), this.client.send(this.baseCollectionPath + "/auth-with-oauth2", { method: "POST", params: s2, body: r2 }).then(function(e4) {
      return a2.authResponse(e4);
    });
  }, RecordService.prototype.authWithOAuth2 = function() {
    for (var e3 = [], n2 = 0; n2 < arguments.length; n2++)
      e3[n2] = arguments[n2];
    return __awaiter(this, void 0, void 0, function() {
      var n3, i2, o2, r2, s2 = this;
      return __generator(this, function(a2) {
        switch (a2.label) {
          case 0:
            return e3.length > 1 || "string" == typeof (null == e3 ? void 0 : e3[0]) ? (console.warn("PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration."), [2, this.authWithOAuth2Code((null == e3 ? void 0 : e3[0]) || "", (null == e3 ? void 0 : e3[1]) || "", (null == e3 ? void 0 : e3[2]) || "", (null == e3 ? void 0 : e3[3]) || "", (null == e3 ? void 0 : e3[4]) || {}, (null == e3 ? void 0 : e3[5]) || {}, (null == e3 ? void 0 : e3[6]) || {})]) : (n3 = (null == e3 ? void 0 : e3[0]) || {}, [4, this.listAuthMethods()]);
          case 1:
            if (i2 = a2.sent(), !(o2 = i2.authProviders.find(function(e4) {
              return e4.name === n3.provider;
            })))
              throw new t$2(new Error('Missing or invalid provider "'.concat(n3.provider, '".')));
            return r2 = this.client.buildUrl("/api/oauth2-redirect"), [2, new Promise(function(e4, i3) {
              return __awaiter(s2, void 0, void 0, function() {
                var s3, a3, c2, u3, l2, d3 = this;
                return __generator(this, function(h2) {
                  switch (h2.label) {
                    case 0:
                      return h2.trys.push([0, 3, , 4]), [4, this.client.realtime.subscribe("@oauth2", function(a4) {
                        return __awaiter(d3, void 0, void 0, function() {
                          var c3, u4, l3;
                          return __generator(this, function(d4) {
                            switch (d4.label) {
                              case 0:
                                c3 = this.client.realtime.clientId, d4.label = 1;
                              case 1:
                                if (d4.trys.push([1, 3, , 4]), s3(), !a4.state || c3 !== a4.state)
                                  throw new Error("State parameters don't match.");
                                return [4, this.authWithOAuth2Code(o2.name, a4.code, o2.codeVerifier, r2, n3.createData, n3.body, n3.query)];
                              case 2:
                                return u4 = d4.sent(), e4(u4), [3, 4];
                              case 3:
                                return l3 = d4.sent(), i3(new t$2(l3)), [3, 4];
                              case 4:
                                return [2];
                            }
                          });
                        });
                      })];
                    case 1:
                      return s3 = h2.sent(), a3 = { state: this.client.realtime.clientId }, (null === (l2 = n3.scopes) || void 0 === l2 ? void 0 : l2.length) && (a3.scope = n3.scopes.join(" ")), c2 = this._replaceQueryParams(o2.authUrl + r2, a3), [4, n3.urlCallback ? n3.urlCallback(c2) : this._defaultUrlCallback(c2)];
                    case 2:
                      return h2.sent(), [3, 4];
                    case 3:
                      return u3 = h2.sent(), i3(new t$2(u3)), [3, 4];
                    case 4:
                      return [2];
                  }
                });
              });
            })];
        }
      });
    });
  }, RecordService.prototype.authRefresh = function(e3, t2) {
    var n2 = this;
    return void 0 === e3 && (e3 = {}), void 0 === t2 && (t2 = {}), this.client.send(this.baseCollectionPath + "/auth-refresh", { method: "POST", params: t2, body: e3 }).then(function(e4) {
      return n2.authResponse(e4);
    });
  }, RecordService.prototype.requestPasswordReset = function(e3, t2, n2) {
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), t2 = Object.assign({ email: e3 }, t2), this.client.send(this.baseCollectionPath + "/request-password-reset", { method: "POST", params: n2, body: t2 }).then(function() {
      return true;
    });
  }, RecordService.prototype.confirmPasswordReset = function(e3, t2, n2, i2, o2) {
    return void 0 === i2 && (i2 = {}), void 0 === o2 && (o2 = {}), i2 = Object.assign({ token: e3, password: t2, passwordConfirm: n2 }, i2), this.client.send(this.baseCollectionPath + "/confirm-password-reset", { method: "POST", params: o2, body: i2 }).then(function() {
      return true;
    });
  }, RecordService.prototype.requestVerification = function(e3, t2, n2) {
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), t2 = Object.assign({ email: e3 }, t2), this.client.send(this.baseCollectionPath + "/request-verification", { method: "POST", params: n2, body: t2 }).then(function() {
      return true;
    });
  }, RecordService.prototype.confirmVerification = function(e3, t2, n2) {
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), t2 = Object.assign({ token: e3 }, t2), this.client.send(this.baseCollectionPath + "/confirm-verification", { method: "POST", params: n2, body: t2 }).then(function() {
      return true;
    });
  }, RecordService.prototype.requestEmailChange = function(e3, t2, n2) {
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), t2 = Object.assign({ newEmail: e3 }, t2), this.client.send(this.baseCollectionPath + "/request-email-change", { method: "POST", params: n2, body: t2 }).then(function() {
      return true;
    });
  }, RecordService.prototype.confirmEmailChange = function(e3, t2, n2, i2) {
    return void 0 === n2 && (n2 = {}), void 0 === i2 && (i2 = {}), n2 = Object.assign({ token: e3, password: t2 }, n2), this.client.send(this.baseCollectionPath + "/confirm-email-change", { method: "POST", params: i2, body: n2 }).then(function() {
      return true;
    });
  }, RecordService.prototype.listExternalAuths = function(e3, t2) {
    return void 0 === t2 && (t2 = {}), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e3) + "/external-auths", { method: "GET", params: t2 }).then(function(e4) {
      var t3 = [];
      if (Array.isArray(e4))
        for (var n2 = 0, i2 = e4; n2 < i2.length; n2++) {
          var o2 = i2[n2];
          t3.push(new v$1(o2));
        }
      return t3;
    });
  }, RecordService.prototype.unlinkExternalAuth = function(e3, t2, n2) {
    return void 0 === n2 && (n2 = {}), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e3) + "/external-auths/" + encodeURIComponent(t2), { method: "DELETE", params: n2 }).then(function() {
      return true;
    });
  }, RecordService.prototype._replaceQueryParams = function(e3, t2) {
    void 0 === t2 && (t2 = {});
    var n2 = e3, i2 = "";
    e3.indexOf("?") >= 0 && (n2 = e3.substring(0, e3.indexOf("?")), i2 = e3.substring(e3.indexOf("?") + 1));
    for (var o2 = {}, r2 = 0, s2 = i2.split("&"); r2 < s2.length; r2++) {
      var a2 = s2[r2];
      if ("" != a2) {
        var c2 = a2.split("=");
        o2[decodeURIComponent(c2[0].replace(/\+/g, " "))] = decodeURIComponent((c2[1] || "").replace(/\+/g, " "));
      }
    }
    for (var u3 in t2)
      t2.hasOwnProperty(u3) && (null == t2[u3] ? delete o2[u3] : o2[u3] = t2[u3]);
    for (var u3 in i2 = "", o2)
      o2.hasOwnProperty(u3) && ("" != i2 && (i2 += "&"), i2 += encodeURIComponent(u3.replace(/%20/g, "+")) + "=" + encodeURIComponent(o2[u3].replace(/%20/g, "+")));
    return "" != i2 ? n2 + "?" + i2 : n2;
  }, RecordService.prototype._defaultUrlCallback = function(e3) {
    if ("undefined" == typeof window || !(null === window || void 0 === window ? void 0 : window.open))
      throw new t$2(new Error("Not in a browser context - please pass a custom urlCallback function."));
    var n2 = 1024, i2 = 768, o2 = window.innerWidth, r2 = window.innerHeight, s2 = o2 / 2 - (n2 = n2 > o2 ? o2 : n2) / 2, a2 = r2 / 2 - (i2 = i2 > r2 ? r2 : i2) / 2;
    window.open(e3, "oauth2-popup", "width=" + n2 + ",height=" + i2 + ",top=" + a2 + ",left=" + s2 + ",resizable,menubar=no");
  }, RecordService;
}(h$1), m$1 = function m(e2) {
  void 0 === e2 && (e2 = {}), this.id = void 0 !== e2.id ? e2.id : "", this.name = void 0 !== e2.name ? e2.name : "", this.type = void 0 !== e2.type ? e2.type : "text", this.system = !!e2.system, this.required = !!e2.required, this.options = "object" == typeof e2.options && null !== e2.options ? e2.options : {};
}, b$1 = function(e2) {
  function Collection() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(Collection, e2), Collection.prototype.$load = function(t2) {
    e2.prototype.$load.call(this, t2), this.system = !!t2.system, this.name = "string" == typeof t2.name ? t2.name : "", this.type = "string" == typeof t2.type ? t2.type : "base", this.options = void 0 !== t2.options && null !== t2.options ? t2.options : {}, this.indexes = Array.isArray(t2.indexes) ? t2.indexes : [], this.listRule = "string" == typeof t2.listRule ? t2.listRule : null, this.viewRule = "string" == typeof t2.viewRule ? t2.viewRule : null, this.createRule = "string" == typeof t2.createRule ? t2.createRule : null, this.updateRule = "string" == typeof t2.updateRule ? t2.updateRule : null, this.deleteRule = "string" == typeof t2.deleteRule ? t2.deleteRule : null, t2.schema = Array.isArray(t2.schema) ? t2.schema : [], this.schema = [];
    for (var n2 = 0, i2 = t2.schema; n2 < i2.length; n2++) {
      var o2 = i2[n2];
      this.schema.push(new m$1(o2));
    }
  }, Object.defineProperty(Collection.prototype, "isBase", { get: function() {
    return this.$isBase;
  }, enumerable: false, configurable: true }), Object.defineProperty(Collection.prototype, "$isBase", { get: function() {
    return "base" === this.type;
  }, enumerable: false, configurable: true }), Object.defineProperty(Collection.prototype, "isAuth", { get: function() {
    return this.$isAuth;
  }, enumerable: false, configurable: true }), Object.defineProperty(Collection.prototype, "$isAuth", { get: function() {
    return "auth" === this.type;
  }, enumerable: false, configurable: true }), Object.defineProperty(Collection.prototype, "isView", { get: function() {
    return this.$isView;
  }, enumerable: false, configurable: true }), Object.defineProperty(Collection.prototype, "$isView", { get: function() {
    return "view" === this.type;
  }, enumerable: false, configurable: true }), Collection;
}(i$2), y$1 = function(e2) {
  function CollectionService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(CollectionService, e2), CollectionService.prototype.decode = function(e3) {
    return new b$1(e3);
  }, Object.defineProperty(CollectionService.prototype, "baseCrudPath", { get: function() {
    return "/api/collections";
  }, enumerable: false, configurable: true }), CollectionService.prototype.import = function(e3, t2, n2) {
    return void 0 === t2 && (t2 = false), void 0 === n2 && (n2 = {}), __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(i2) {
        return [2, this.client.send(this.baseCrudPath + "/import", { method: "PUT", params: n2, body: { collections: e3, deleteMissing: t2 } }).then(function() {
          return true;
        })];
      });
    });
  }, CollectionService;
}(h$1), g$1 = function(e2) {
  function LogRequest() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(LogRequest, e2), LogRequest.prototype.$load = function(t2) {
    e2.prototype.$load.call(this, t2), t2.remoteIp = t2.remoteIp || t2.ip, this.url = "string" == typeof t2.url ? t2.url : "", this.method = "string" == typeof t2.method ? t2.method : "GET", this.status = "number" == typeof t2.status ? t2.status : 200, this.auth = "string" == typeof t2.auth ? t2.auth : "guest", this.remoteIp = "string" == typeof t2.remoteIp ? t2.remoteIp : "", this.userIp = "string" == typeof t2.userIp ? t2.userIp : "", this.referer = "string" == typeof t2.referer ? t2.referer : "", this.userAgent = "string" == typeof t2.userAgent ? t2.userAgent : "", this.meta = "object" == typeof t2.meta && null !== t2.meta ? t2.meta : {};
  }, LogRequest;
}(i$2), S$1 = function(e2) {
  function LogService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(LogService, e2), LogService.prototype.getRequestsList = function(e3, t2, n2) {
    return void 0 === e3 && (e3 = 1), void 0 === t2 && (t2 = 30), void 0 === n2 && (n2 = {}), n2 = Object.assign({ page: e3, perPage: t2 }, n2), this.client.send("/api/logs/requests", { method: "GET", params: n2 }).then(function(e4) {
      var t3 = [];
      if (null == e4 ? void 0 : e4.items) {
        e4.items = (null == e4 ? void 0 : e4.items) || [];
        for (var n3 = 0, i2 = e4.items; n3 < i2.length; n3++) {
          var o2 = i2[n3];
          t3.push(new g$1(o2));
        }
      }
      return new d$2((null == e4 ? void 0 : e4.page) || 1, (null == e4 ? void 0 : e4.perPage) || 0, (null == e4 ? void 0 : e4.totalItems) || 0, (null == e4 ? void 0 : e4.totalPages) || 0, t3);
    });
  }, LogService.prototype.getRequest = function(e3, t2) {
    return void 0 === t2 && (t2 = {}), this.client.send("/api/logs/requests/" + encodeURIComponent(e3), { method: "GET", params: t2 }).then(function(e4) {
      return new g$1(e4);
    });
  }, LogService.prototype.getRequestsStats = function(e3) {
    return void 0 === e3 && (e3 = {}), this.client.send("/api/logs/requests/stats", { method: "GET", params: e3 }).then(function(e4) {
      return e4;
    });
  }, LogService;
}(u$1), w$1 = function(e2) {
  function RealtimeService() {
    var t2 = null !== e2 && e2.apply(this, arguments) || this;
    return t2.clientId = "", t2.eventSource = null, t2.subscriptions = {}, t2.lastSentTopics = [], t2.maxConnectTimeout = 15e3, t2.reconnectAttempts = 0, t2.maxReconnectAttempts = 1 / 0, t2.predefinedReconnectIntervals = [200, 300, 500, 1e3, 1200, 1500, 2e3], t2.pendingConnects = [], t2;
  }
  return __extends(RealtimeService, e2), Object.defineProperty(RealtimeService.prototype, "isConnected", { get: function() {
    return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;
  }, enumerable: false, configurable: true }), RealtimeService.prototype.subscribe = function(e3, t2) {
    var n2;
    return __awaiter(this, void 0, void 0, function() {
      var i2, o2 = this;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (!e3)
              throw new Error("topic must be set.");
            return i2 = function(e4) {
              var n3, i3 = e4;
              try {
                n3 = JSON.parse(null == i3 ? void 0 : i3.data);
              } catch (e5) {
              }
              t2(n3 || {});
            }, this.subscriptions[e3] || (this.subscriptions[e3] = []), this.subscriptions[e3].push(i2), this.isConnected ? [3, 2] : [4, this.connect()];
          case 1:
            return r2.sent(), [3, 5];
          case 2:
            return 1 !== this.subscriptions[e3].length ? [3, 4] : [4, this.submitSubscriptions()];
          case 3:
            return r2.sent(), [3, 5];
          case 4:
            null === (n2 = this.eventSource) || void 0 === n2 || n2.addEventListener(e3, i2), r2.label = 5;
          case 5:
            return [2, function() {
              return __awaiter(o2, void 0, void 0, function() {
                return __generator(this, function(t3) {
                  return [2, this.unsubscribeByTopicAndListener(e3, i2)];
                });
              });
            }];
        }
      });
    });
  }, RealtimeService.prototype.unsubscribe = function(e3) {
    var t2;
    return __awaiter(this, void 0, void 0, function() {
      var n2, i2, o2;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (!this.hasSubscriptionListeners(e3))
              return [2];
            if (e3) {
              for (n2 = 0, i2 = this.subscriptions[e3]; n2 < i2.length; n2++)
                o2 = i2[n2], null === (t2 = this.eventSource) || void 0 === t2 || t2.removeEventListener(e3, o2);
              delete this.subscriptions[e3];
            } else
              this.subscriptions = {};
            return this.hasSubscriptionListeners() ? [3, 1] : (this.disconnect(), [3, 3]);
          case 1:
            return this.hasSubscriptionListeners(e3) ? [3, 3] : [4, this.submitSubscriptions()];
          case 2:
            r2.sent(), r2.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, RealtimeService.prototype.unsubscribeByPrefix = function(e3) {
    var t2;
    return __awaiter(this, void 0, void 0, function() {
      var n2, i2, o2, r2, s2;
      return __generator(this, function(a2) {
        switch (a2.label) {
          case 0:
            for (i2 in n2 = false, this.subscriptions)
              if (i2.startsWith(e3)) {
                for (n2 = true, o2 = 0, r2 = this.subscriptions[i2]; o2 < r2.length; o2++)
                  s2 = r2[o2], null === (t2 = this.eventSource) || void 0 === t2 || t2.removeEventListener(i2, s2);
                delete this.subscriptions[i2];
              }
            return n2 ? this.hasSubscriptionListeners() ? [4, this.submitSubscriptions()] : [3, 2] : [2];
          case 1:
            return a2.sent(), [3, 3];
          case 2:
            this.disconnect(), a2.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, RealtimeService.prototype.unsubscribeByTopicAndListener = function(e3, t2) {
    var n2;
    return __awaiter(this, void 0, void 0, function() {
      var i2, o2;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (!Array.isArray(this.subscriptions[e3]) || !this.subscriptions[e3].length)
              return [2];
            for (i2 = false, o2 = this.subscriptions[e3].length - 1; o2 >= 0; o2--)
              this.subscriptions[e3][o2] === t2 && (i2 = true, delete this.subscriptions[e3][o2], this.subscriptions[e3].splice(o2, 1), null === (n2 = this.eventSource) || void 0 === n2 || n2.removeEventListener(e3, t2));
            return i2 ? (this.subscriptions[e3].length || delete this.subscriptions[e3], this.hasSubscriptionListeners() ? [3, 1] : (this.disconnect(), [3, 3])) : [2];
          case 1:
            return this.hasSubscriptionListeners(e3) ? [3, 3] : [4, this.submitSubscriptions()];
          case 2:
            r2.sent(), r2.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, RealtimeService.prototype.hasSubscriptionListeners = function(e3) {
    var t2, n2;
    if (this.subscriptions = this.subscriptions || {}, e3)
      return !!(null === (t2 = this.subscriptions[e3]) || void 0 === t2 ? void 0 : t2.length);
    for (var i2 in this.subscriptions)
      if (null === (n2 = this.subscriptions[i2]) || void 0 === n2 ? void 0 : n2.length)
        return true;
    return false;
  }, RealtimeService.prototype.submitSubscriptions = function() {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(e3) {
        return this.clientId ? (this.addAllSubscriptionListeners(), this.lastSentTopics = this.getNonEmptySubscriptionTopics(), [2, this.client.send("/api/realtime", { method: "POST", body: { clientId: this.clientId, subscriptions: this.lastSentTopics }, params: { $cancelKey: this.getSubscriptionsCancelKey() } }).catch(function(e4) {
          if (!(null == e4 ? void 0 : e4.isAbort))
            throw e4;
        })]) : [2];
      });
    });
  }, RealtimeService.prototype.getSubscriptionsCancelKey = function() {
    return "realtime_" + this.clientId;
  }, RealtimeService.prototype.getNonEmptySubscriptionTopics = function() {
    var e3 = [];
    for (var t2 in this.subscriptions)
      this.subscriptions[t2].length && e3.push(t2);
    return e3;
  }, RealtimeService.prototype.addAllSubscriptionListeners = function() {
    if (this.eventSource)
      for (var e3 in this.removeAllSubscriptionListeners(), this.subscriptions)
        for (var t2 = 0, n2 = this.subscriptions[e3]; t2 < n2.length; t2++) {
          var i2 = n2[t2];
          this.eventSource.addEventListener(e3, i2);
        }
  }, RealtimeService.prototype.removeAllSubscriptionListeners = function() {
    if (this.eventSource)
      for (var e3 in this.subscriptions)
        for (var t2 = 0, n2 = this.subscriptions[e3]; t2 < n2.length; t2++) {
          var i2 = n2[t2];
          this.eventSource.removeEventListener(e3, i2);
        }
  }, RealtimeService.prototype.connect = function() {
    return __awaiter(this, void 0, void 0, function() {
      var e3 = this;
      return __generator(this, function(t2) {
        return this.reconnectAttempts > 0 ? [2] : [2, new Promise(function(t3, n2) {
          e3.pendingConnects.push({ resolve: t3, reject: n2 }), e3.pendingConnects.length > 1 || e3.initConnect();
        })];
      });
    });
  }, RealtimeService.prototype.initConnect = function() {
    var e3 = this;
    this.disconnect(true), clearTimeout(this.connectTimeoutId), this.connectTimeoutId = setTimeout(function() {
      e3.connectErrorHandler(new Error("EventSource connect took too long."));
    }, this.maxConnectTimeout), this.eventSource = new EventSource(this.client.buildUrl("/api/realtime")), this.eventSource.onerror = function(t2) {
      e3.connectErrorHandler(new Error("Failed to establish realtime connection."));
    }, this.eventSource.addEventListener("PB_CONNECT", function(t2) {
      var n2 = t2;
      e3.clientId = null == n2 ? void 0 : n2.lastEventId, e3.submitSubscriptions().then(function() {
        return __awaiter(e3, void 0, void 0, function() {
          var e4;
          return __generator(this, function(t3) {
            switch (t3.label) {
              case 0:
                e4 = 3, t3.label = 1;
              case 1:
                return this.hasUnsentSubscriptions() && e4 > 0 ? (e4--, [4, this.submitSubscriptions()]) : [3, 3];
              case 2:
                return t3.sent(), [3, 1];
              case 3:
                return [2];
            }
          });
        });
      }).then(function() {
        for (var t3 = 0, n3 = e3.pendingConnects; t3 < n3.length; t3++) {
          n3[t3].resolve();
        }
        e3.pendingConnects = [], e3.reconnectAttempts = 0, clearTimeout(e3.reconnectTimeoutId), clearTimeout(e3.connectTimeoutId);
      }).catch(function(t3) {
        e3.clientId = "", e3.connectErrorHandler(t3);
      });
    });
  }, RealtimeService.prototype.hasUnsentSubscriptions = function() {
    var e3 = this.getNonEmptySubscriptionTopics();
    if (e3.length != this.lastSentTopics.length)
      return true;
    for (var t2 = 0, n2 = e3; t2 < n2.length; t2++) {
      var i2 = n2[t2];
      if (!this.lastSentTopics.includes(i2))
        return true;
    }
    return false;
  }, RealtimeService.prototype.connectErrorHandler = function(e3) {
    var n2 = this;
    if (clearTimeout(this.connectTimeoutId), clearTimeout(this.reconnectTimeoutId), !this.clientId && !this.reconnectAttempts || this.reconnectAttempts > this.maxReconnectAttempts) {
      for (var i2 = 0, o2 = this.pendingConnects; i2 < o2.length; i2++) {
        o2[i2].reject(new t$2(e3));
      }
      return this.pendingConnects = [], void this.disconnect();
    }
    this.disconnect(true);
    var r2 = this.predefinedReconnectIntervals[this.reconnectAttempts] || this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length - 1];
    this.reconnectAttempts++, this.reconnectTimeoutId = setTimeout(function() {
      n2.initConnect();
    }, r2);
  }, RealtimeService.prototype.disconnect = function(e3) {
    var t2;
    if (void 0 === e3 && (e3 = false), clearTimeout(this.connectTimeoutId), clearTimeout(this.reconnectTimeoutId), this.removeAllSubscriptionListeners(), this.client.cancelRequest(this.getSubscriptionsCancelKey()), null === (t2 = this.eventSource) || void 0 === t2 || t2.close(), this.eventSource = null, this.clientId = "", !e3) {
      this.reconnectAttempts = 0;
      for (var n2 = 0, i2 = this.pendingConnects; n2 < i2.length; n2++) {
        i2[n2].resolve();
      }
      this.pendingConnects = [];
    }
  }, RealtimeService;
}(u$1), C$1 = function(e2) {
  function HealthService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(HealthService, e2), HealthService.prototype.check = function(e3) {
    return void 0 === e3 && (e3 = {}), this.client.send("/api/health", { method: "GET", params: e3 });
  }, HealthService;
}(u$1), _$1 = function(e2) {
  function FileService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(FileService, e2), FileService.prototype.getUrl = function(e3, t2, n2) {
    void 0 === n2 && (n2 = {});
    var i2 = [];
    i2.push("api"), i2.push("files"), i2.push(encodeURIComponent(e3.collectionId || e3.collectionName)), i2.push(encodeURIComponent(e3.id)), i2.push(encodeURIComponent(t2));
    var o2 = this.client.buildUrl(i2.join("/"));
    if (Object.keys(n2).length) {
      var r2 = new URLSearchParams(n2);
      o2 += (o2.includes("?") ? "&" : "?") + r2;
    }
    return o2;
  }, FileService.prototype.getToken = function(e3) {
    return void 0 === e3 && (e3 = {}), this.client.send("/api/files/token", { method: "POST", params: e3 }).then(function(e4) {
      return (null == e4 ? void 0 : e4.token) || "";
    });
  }, FileService;
}(u$1), R$1 = function(e2) {
  function BackupService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(BackupService, e2), BackupService.prototype.getFullList = function(e3) {
    return void 0 === e3 && (e3 = {}), this.client.send("/api/backups", { method: "GET", params: e3 });
  }, BackupService.prototype.create = function(e3, t2) {
    void 0 === t2 && (t2 = {});
    var n2 = { name: e3 };
    return this.client.send("/api/backups", { method: "POST", params: t2, body: n2 }).then(function() {
      return true;
    });
  }, BackupService.prototype.delete = function(e3, t2) {
    return void 0 === t2 && (t2 = {}), this.client.send("/api/backups/".concat(encodeURIComponent(e3)), { method: "DELETE", params: t2 }).then(function() {
      return true;
    });
  }, BackupService.prototype.restore = function(e3, t2) {
    return void 0 === t2 && (t2 = {}), this.client.send("/api/backups/".concat(encodeURIComponent(e3), "/restore"), { method: "POST", params: t2 }).then(function() {
      return true;
    });
  }, BackupService.prototype.getDownloadUrl = function(e3, t2) {
    return this.client.buildUrl("/api/backups/".concat(encodeURIComponent(t2), "?token=").concat(encodeURIComponent(e3)));
  }, BackupService;
}(u$1), O$1 = function() {
  function Client(e2, t2, n2) {
    void 0 === e2 && (e2 = "/"), void 0 === n2 && (n2 = "en-US"), this.cancelControllers = {}, this.recordServices = {}, this.enableAutoCancellation = true, this.baseUrl = e2, this.lang = n2, this.authStore = t2 || new c$1(), this.admins = new p$1(this), this.collections = new y$1(this), this.files = new _$1(this), this.logs = new S$1(this), this.settings = new l$1(this), this.realtime = new w$1(this), this.health = new C$1(this), this.backups = new R$1(this);
  }
  return Client.prototype.collection = function(e2) {
    return this.recordServices[e2] || (this.recordServices[e2] = new f$1(this, e2)), this.recordServices[e2];
  }, Client.prototype.autoCancellation = function(e2) {
    return this.enableAutoCancellation = !!e2, this;
  }, Client.prototype.cancelRequest = function(e2) {
    return this.cancelControllers[e2] && (this.cancelControllers[e2].abort(), delete this.cancelControllers[e2]), this;
  }, Client.prototype.cancelAllRequests = function() {
    for (var e2 in this.cancelControllers)
      this.cancelControllers[e2].abort();
    return this.cancelControllers = {}, this;
  }, Client.prototype.send = function(e2, n2) {
    var i2, o2, r2, s2, a2, c2, u3, l2;
    return __awaiter(this, void 0, void 0, function() {
      var d3, h2, p2, v2, f2, m3, b2, y2, g2, S2 = this;
      return __generator(this, function(w2) {
        switch (w2.label) {
          case 0:
            return d3 = Object.assign({ method: "GET" }, n2), this.isFormData(d3.body) || (d3.body && "string" != typeof d3.body && (d3.body = JSON.stringify(d3.body)), void 0 === (null === (i2 = null == d3 ? void 0 : d3.headers) || void 0 === i2 ? void 0 : i2["Content-Type"]) && (d3.headers = Object.assign({}, d3.headers, { "Content-Type": "application/json" }))), void 0 === (null === (o2 = null == d3 ? void 0 : d3.headers) || void 0 === o2 ? void 0 : o2["Accept-Language"]) && (d3.headers = Object.assign({}, d3.headers, { "Accept-Language": this.lang })), (null === (r2 = this.authStore) || void 0 === r2 ? void 0 : r2.token) && void 0 === (null === (s2 = null == d3 ? void 0 : d3.headers) || void 0 === s2 ? void 0 : s2.Authorization) && (d3.headers = Object.assign({}, d3.headers, { Authorization: this.authStore.token })), this.enableAutoCancellation && false !== (null === (a2 = d3.params) || void 0 === a2 ? void 0 : a2.$autoCancel) && (h2 = (null === (c2 = d3.params) || void 0 === c2 ? void 0 : c2.$cancelKey) || (d3.method || "GET") + e2, this.cancelRequest(h2), p2 = new AbortController(), this.cancelControllers[h2] = p2, d3.signal = p2.signal), null === (u3 = d3.params) || void 0 === u3 || delete u3.$autoCancel, null === (l2 = d3.params) || void 0 === l2 || delete l2.$cancelKey, v2 = this.buildUrl(e2), void 0 !== d3.params && ((f2 = this.serializeQueryParams(d3.params)) && (v2 += (v2.includes("?") ? "&" : "?") + f2), delete d3.params), this.beforeSend ? (y2 = (b2 = Object).assign, g2 = [{}], [4, this.beforeSend(v2, d3)]) : [3, 2];
          case 1:
            void 0 !== (m3 = y2.apply(b2, g2.concat([w2.sent()]))).url || void 0 !== m3.options ? (v2 = m3.url || v2, d3 = m3.options || d3) : Object.keys(m3).length && (d3 = m3, (null === console || void 0 === console ? void 0 : console.warn) && console.warn("Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`.")), w2.label = 2;
          case 2:
            return [2, fetch(v2, d3).then(function(e3) {
              return __awaiter(S2, void 0, void 0, function() {
                var n3;
                return __generator(this, function(i3) {
                  switch (i3.label) {
                    case 0:
                      n3 = {}, i3.label = 1;
                    case 1:
                      return i3.trys.push([1, 3, , 4]), [4, e3.json()];
                    case 2:
                      return n3 = i3.sent(), [3, 4];
                    case 3:
                      return i3.sent(), [3, 4];
                    case 4:
                      return this.afterSend ? [4, this.afterSend(e3, n3)] : [3, 6];
                    case 5:
                      n3 = i3.sent(), i3.label = 6;
                    case 6:
                      if (e3.status >= 400)
                        throw new t$2({ url: e3.url, status: e3.status, data: n3 });
                      return [2, n3];
                  }
                });
              });
            }).catch(function(e3) {
              throw new t$2(e3);
            })];
        }
      });
    });
  }, Client.prototype.getFileUrl = function(e2, t2, n2) {
    return void 0 === n2 && (n2 = {}), this.files.getUrl(e2, t2, n2);
  }, Client.prototype.buildUrl = function(e2) {
    var t2, n2 = this.baseUrl;
    return "undefined" == typeof window || !window.location || n2.startsWith("https://") || n2.startsWith("http://") || (n2 = (null === (t2 = window.location.origin) || void 0 === t2 ? void 0 : t2.endsWith("/")) ? window.location.origin.substring(0, window.location.origin.length - 1) : window.location.origin || "", this.baseUrl.startsWith("/") || (n2 += window.location.pathname || "/", n2 += n2.endsWith("/") ? "" : "/"), n2 += this.baseUrl), e2 && (n2 += n2.endsWith("/") ? "" : "/", n2 += e2.startsWith("/") ? e2.substring(1) : e2), n2;
  }, Client.prototype.isFormData = function(e2) {
    return e2 && ("FormData" === e2.constructor.name || "undefined" != typeof FormData && e2 instanceof FormData);
  }, Client.prototype.serializeQueryParams = function(e2) {
    var t2 = [];
    for (var n2 in e2)
      if (null !== e2[n2]) {
        var i2 = e2[n2], o2 = encodeURIComponent(n2);
        if (Array.isArray(i2))
          for (var r2 = 0, s2 = i2; r2 < s2.length; r2++) {
            var a2 = s2[r2];
            t2.push(o2 + "=" + encodeURIComponent(a2));
          }
        else
          i2 instanceof Date ? t2.push(o2 + "=" + encodeURIComponent(i2.toISOString())) : null !== typeof i2 && "object" == typeof i2 ? t2.push(o2 + "=" + encodeURIComponent(JSON.stringify(i2))) : t2.push(o2 + "=" + encodeURIComponent(i2));
      }
    return t2.join("&");
  }, Client;
}();
const defaultReportOptions = {
  includeApi: true,
  includeUserData: false,
  title: "Auto-generated report",
  body: "No user-input was provided when generating this report."
};
const CrashReport = Store$1();
const CRASHING = Store$1(false);
const CRASH_BLACKLIST = [
  "NotAllowedError",
  "NotSupportedError",
  "AbortError",
  "AxiosError",
  "ClientResponseError"
];
const ArcOSVersion = "6.0.0";
const minArcAPI = 2;
let ARCOS_BUILD = "unknown";
async function getBuild() {
  Log("branding/build", "Attempting to retrieve git hash from /build");
  try {
    const req = await (await fetch("./build")).text();
    const str = req.split("\n")[0].trim();
    ARCOS_BUILD = str.startsWith("<!") ? "unknown" : str;
  } catch {
    ARCOS_BUILD = "unknown";
  }
}
let DESKTOP_MODE;
async function getDesktopMode() {
  Log("metadata/desktop", "Attempting to retrieve desktop mode from /desktop");
  try {
    const req = await (await fetch("./desktop")).text();
    DESKTOP_MODE = req.startsWith("desktop") ? "desktop" : "browser";
  } catch {
    DESKTOP_MODE = "browser";
  }
}
const isDesktop = () => DESKTOP_MODE == "desktop";
function getServer() {
  Log("server/multi", "Getting any available server");
  const server = localStorage.getItem("arcos-current-server");
  if (!server) {
    const servers = getAllServers();
    if (!servers.length) {
      return null;
    }
    const server2 = servers[servers.length - 1];
    setServer(server2);
    return server2;
  }
  return localStorage.getItem("arcos-current-server");
}
function getAllServers() {
  Log("server/multi", "Getting saved servers from arcos-servers");
  if (!localStorage.getItem("arcos-servers"))
    return [];
  return JSON.parse(localStorage.getItem("arcos-servers"));
}
function addServer(server, makeDefault = true) {
  Log("server/multi", `Adding server ${server}`);
  const servers = getAllServers();
  if (!servers.includes(server))
    servers.push(server);
  localStorage.setItem("arcos-servers", JSON.stringify(servers));
  if (makeDefault)
    setServer(server);
}
function removeServer(server) {
  Log("server/multi", `Removing server ${server}`);
  const servers = getAllServers();
  if (!servers.includes(server))
    return false;
  servers.splice(servers.indexOf(server), 1);
  localStorage.setItem("arcos-servers", JSON.stringify(servers));
  return true;
}
function setServer(server) {
  Log("server/multi", `Setting preferred server to ${server}`);
  localStorage.setItem("arcos-current-server", server);
  localStorage.removeItem("arcos-remembered-token");
}
function getAppPreference(id, key2) {
  const udata = UserDataStore.get();
  if (!udata.appdata || !udata.appdata[id])
    return void 0;
  return udata.appdata[id][key2];
}
function setAppPreference(id, key2, value) {
  Log("server/user/pref", `Setting ${key2} in ${id} to type ${typeof value}...`);
  UserDataStore.update((udata) => {
    if (!udata.appdata)
      return udata;
    if (!udata.appdata[id])
      udata.appdata[id] = {};
    udata.appdata[id][key2] = value;
    return udata;
  });
  return true;
}
const ConnectedServer = Store$1(null);
const TEST_MODES = [
  [true, 443],
  [false, 3333],
  [true, 80],
  [false, 80],
  [true, 3333]
];
function ttlFetch(url, init2, ms = 3e3) {
  Log("util/ttlFetch", url);
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      reject(new Error("TIMEOUT"));
    }, ms);
    fetch(url, init2).then((value) => {
      clearTimeout(timer);
      resolve(value);
    }).catch((reason) => {
      clearTimeout(timer);
      reject(reason);
    });
  });
}
function testingServerLog(server) {
  Log(
    "server/test",
    `Testing ${server.host} on port ${server.port} (secure = ${server.secure})`,
    LogLevel.warn
  );
}
function validResponseLog(server) {
  Log(
    "server/test",
    `Got valid response from ${server.host} on port ${server.port} (secure = ${server.secure})`
  );
}
function invalidResponseLog(server) {
  Log(
    "server/test",
    `Didn't get valid response from ${server.host} on port ${server.port} (secure = ${server.secure})`,
    LogLevel.error
  );
}
function connectFailureLog(host) {
  Log(
    "server/test",
    `Unable to connect to server ${host}: none of the modes match.`,
    LogLevel.critical
  );
}
async function testConnection(host, authCode = "", set = true) {
  Log("server/test", `Attempting to connect to ${host}`);
  for (const [secure, port] of TEST_MODES) {
    const server = {
      secure,
      port,
      host,
      authCode
    };
    testingServerLog(server);
    const url = getServerUrl(Endpoints.MetaData, {}, server);
    try {
      const response = await ttlFetch(url, {}, 1e4);
      if (response.status !== 200)
        continue;
      validResponseLog(server);
      const meta = await response.json();
      server.meta = meta;
      if (set)
        ConnectedServer.set(server);
      return server;
    } catch {
      invalidResponseLog(server);
      continue;
    }
  }
  connectFailureLog(host);
  return false;
}
function setAuthcode(server, code) {
  Log("server/authcode", `Adding authcode to ${server}`);
  let authCodes = localStorage.getItem("arcos-authcodes");
  if (!authCodes)
    authCodes = "{}";
  authCodes = JSON.parse(authCodes);
  authCodes[server] = code;
  localStorage.setItem("arcos-authcodes", JSON.stringify(authCodes));
}
function getAuthcode(server) {
  Log("server/authcode", `Getting authcode for ${server}`);
  let authCodes = localStorage.getItem("arcos-authcodes");
  if (!authCodes)
    authCodes = "{}";
  authCodes = JSON.parse(authCodes);
  return authCodes[server];
}
function removeApiSensitive(str) {
  const api2 = getServer();
  const ac = getAuthcode(api2);
  str = str.replaceAll(api2, "<api>");
  if (ac && ac.length)
    str = str.replaceAll(ac, "<ac>");
  return str;
}
const pb = new O$1("https://pb.arcapi.nl/");
async function sendReport(options2 = defaultReportOptions) {
  const report = createReport(options2);
  const id = (await pb.collection("bugrep").create(report, { br: "true" })).id;
  if (report.author)
    saveReportToUser(id);
  return id;
}
function createReport(options2 = defaultReportOptions) {
  const rnd = () => Math.floor(Math.random() * 1e6);
  const x2 = {
    author: UserName.get(),
    title: options2.title,
    body: options2.body || "No body",
    version: ArcOSVersion,
    log: removeApiSensitive(compileStringLog().join("\n")),
    userdata: options2.includeUserData ? UserDataStore.get() : null,
    api: options2.includeApi ? getServer() : null,
    issueid: `${rnd()}-${rnd()}-${rnd()}-${rnd()}`,
    resolved: false,
    closed: false,
    desktop: isDesktop(),
    mode_file: ARCOS_MODE,
    useragent: navigator.userAgent,
    frontend: isDesktop() ? "<desktop>" : location.host,
    location,
    metaenv: { "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false },
    created_at: "",
    modified_at: ""
  };
  return x2;
}
async function getReport(id) {
  if (!id)
    return null;
  try {
    return await pb.collection("bugrep").getOne(id, { $autoCancel: false, br: "true" });
  } catch {
    return null;
  }
}
function saveReportToUser(id) {
  const reports = getAppPreference("Reporting", "reports") || [];
  reports.push({ id, timestamp: (/* @__PURE__ */ new Date()).getTime() });
  setAppPreference("Reporting", "reports", reports);
}
function manualCrash(source, reason, stack) {
  if (CRASHING.get())
    return Log(
      "bugrep/crash/window",
      "Crash prevented because another crash is already in progress!",
      LogLevel.warn
    );
  Log("ArcOS", `------(#! [ SYSTEM IS CRASHING ] !#)------`, LogLevel.error);
  const options2 = {
    includeUserData: false,
    includeApi: true,
    title: reason,
    body: `Source: ${source}
${stack || compileStackString()}`
  };
  const report = createReport(options2);
  CrashReport.set(report);
  Log(`bugrep/crash`, `Error: ${source}: ${reason}`, LogLevel.error);
  CRASHING.set(true);
  PrimaryState.navigate("crash");
  sendReport(options2);
}
function getServerUrl(path, params, server) {
  if (!isStoredEndpoint(path)) {
    manualCrash(
      "src/ts/server/util.ts",
      "getServerUrl: The path must be part of the Endpoints store."
    );
    return null;
  }
  server || (server = ConnectedServer.get());
  if (!server)
    return null;
  const protocol2 = server.secure ? "https" : "http";
  const hostname = server.host || ConnectedServer.get();
  const port = server.port || 3333;
  if (!hostname)
    return null;
  const paramStr = compileParams({
    ...params || {},
    ac: server.authCode || ""
  });
  return `${protocol2}://${hostname}:${port}${path}${paramStr}`;
}
function compileParams(params) {
  let result = "?";
  const entries = Object.entries(params);
  for (const [key2, value] of entries) {
    result += `${key2}=${value}&`;
  }
  return result;
}
function makeTokenOptions(token, additional) {
  return {
    headers: {
      Authorization: `Bearer ${token}`
    },
    ...additional
  };
}
function sortFiles(dir) {
  if (!dir)
    return [];
  return dir.sort((a2, b2) => a2.filename.toLowerCase() > b2.filename.toLowerCase() ? 1 : -1);
}
function sortDirectories(dir) {
  if (!dir)
    return [];
  return dir.sort((a2, b2) => a2.name.toLowerCase() > b2.name.toLowerCase() ? 1 : -1);
}
async function readDirectory(path) {
  Log("server/fs/dir", `Reading directory ${path}`);
  const base64 = toBase64(path);
  if (base64 == path)
    return null;
  const url = getServerUrl(Endpoints.FsDirectory, { path: base64 });
  const token = UserToken.get();
  if (!url || !token)
    return null;
  try {
    const response = await axios$1.get(url, makeTokenOptions(token));
    if (response.status !== 200)
      return null;
    const data2 = response.data.data;
    data2.directories = sortDirectories(data2.directories);
    data2.files = sortFiles(data2.files);
    return data2;
  } catch {
    return null;
  }
}
async function createDirectory(path) {
  Log("server/fs/dir", `Creating directory ${path}`);
  const base64 = toBase64(path);
  if (base64 == path)
    return null;
  const url = getServerUrl(Endpoints.FsDirCreate, { path: base64 });
  const token = UserToken.get();
  if (!url || !token)
    return false;
  try {
    const response = await axios$1.get(url, makeTokenOptions(token));
    GlobalDispatch.dispatch("fs-flush");
    return response.status === 200;
  } catch {
    return false;
  }
}
function getParentDirectory(p2) {
  Log("server/fs/dir", `Getting parent directory of ${p2}`);
  const split = p2.split("/");
  if (p2 == "./")
    return p2;
  if (!split.length)
    return p2;
  if (split.length == 1)
    return "./";
  split.splice(-1);
  const newPath = split.join("/");
  return newPath;
}
function pathToFriendlyName(path) {
  if (!path)
    return path;
  if (path === "./" || path === ".")
    return "Home";
  return getFilenameFromPath(path);
}
function pathToFriendlyPath(path) {
  if (!path)
    return path;
  if (path === "./" || path === ".")
    return "Home";
  return path.replace("./", "");
}
function parseFilename(path) {
  const split = path.split("/");
  return split[split.length - 1];
}
function parseExtension(path) {
  const split = path.split(".");
  return `.${split[split.length - 1]}`.toLowerCase();
}
async function readFile(path) {
  Log("server/fs/file", `Reading file ${path}`);
  const base64 = toBase64(path);
  if (base64 == path)
    return null;
  const url = getServerUrl(Endpoints.FsFileGet, {
    path: base64
  });
  const token = UserToken.get();
  if (path.startsWith("@client/"))
    return await readClientFile(path);
  if (!url || !token)
    return null;
  const partial = await getPartialFile(path);
  if (!partial)
    return null;
  try {
    const contents = await axios$1.get(url, makeTokenOptions(token, { responseType: "blob" }));
    const file = {
      name: partial.filename,
      path,
      data: contents.data,
      mime: partial.mime
    };
    return file;
  } catch {
    return null;
  }
}
async function readClientFile(path) {
  if (!path.startsWith("@client/"))
    return null;
  const data2 = {
    name: pathToFriendlyName(path),
    path,
    data: null,
    mime: null
  };
  try {
    const clientUrl = path.replace("@client/", "./");
    const response = await axios$1.get(clientUrl, { responseType: "blob" });
    if (response.status !== 200)
      return null;
    data2.mime = response.headers["content-type"] || "text/plain";
    data2.data = response.data;
    return data2;
  } catch {
    return null;
  }
}
async function getPartialFile(path) {
  Log("server/fs/file", `Getting partial file of ${path}`);
  if (path.startsWith("@client")) {
    return {
      scopedPath: path,
      filename: parseFilename(path),
      mime: "text/plain",
      dateCreated: (/* @__PURE__ */ new Date()).getTime(),
      dateModified: (/* @__PURE__ */ new Date()).getTime()
    };
  }
  const parent = getParentDirectory(path);
  const dir = await readDirectory(parent);
  const filename = getFilenameFromPath(path);
  if (!dir)
    return null;
  return dir.files.filter((f2) => f2.filename == filename)[0];
}
async function writeFile(path, blob, dispatch = true, onUploadProgress) {
  if (!path)
    return null;
  if (path.startsWith("@client")) {
    Log(
      "server/fs/file",
      `Not attempting to write to client file "${path}" as it is read-only!`,
      LogLevel.warn
    );
    return true;
  }
  Log("server/fs/file", `Writing ${blob.size} bytes to ${path}`);
  const base64 = toBase64(path);
  if (base64 == path)
    return null;
  const url = getServerUrl(Endpoints.FsFileWrite, { path: base64 });
  const token = UserToken.get();
  if (!url)
    return null;
  try {
    const response = await axios$1.post(url, blob, makeTokenOptions(token, { onUploadProgress }));
    if (dispatch)
      GlobalDispatch.dispatch("fs-flush");
    return response.status === 200;
  } catch {
    return false;
  }
}
function getFilenameFromPath(path) {
  const split = path.split("/");
  return split[split.length - 1];
}
class ArcTermConfig {
  constructor(e2, t2) {
    __publicField(this, "env");
    __publicField(this, "term");
    __publicField(this, "configPath", "./arcterm.conf");
    __publicField(this, "configKeys", [
      "prompt",
      "greeting",
      "logo",
      "promptColor",
      "gooseBumps",
      "textOnlyElevate"
    ]);
    Log(`ArcTerm ${t2.referenceId}`, `Creating new ArcTermConfig`);
    this.env = e2;
    this.term = t2;
  }
  getConfig() {
    const obj = {};
    for (const key2 of this.configKeys) {
      obj[key2] = this.env[key2];
    }
    return obj;
  }
  loadConfig(json) {
    for (const key2 of this.configKeys) {
      const exists = this.env[key2] != null && json;
      const isType = typeof this.env[key2] == typeof json[key2];
      if (exists && isType)
        this.env[key2] = json[key2];
    }
  }
  async loadConfigFile() {
    if (!UserDataStore.get())
      return;
    Log(`ArcTerm ${this.term.referenceId}`, `config.loadConfigFile: Getting ${this.configPath}`);
    const file = await readFile(this.configPath);
    if (!file)
      return this.writeConfig();
    const d3 = await blobToText(file.data);
    const json = tryJsonConvert(d3);
    if (typeof json !== "object")
      return this.writeConfig();
    this.loadConfig(json);
  }
  async writeConfig() {
    Log(`ArcTerm ${this.term.referenceId}`, `config.writeConfig: Writing ${this.configPath}`);
    if (!UserToken.get())
      return false;
    const data2 = {};
    for (const key2 of this.configKeys) {
      if (key2 != "gooseBumps" || typeof this.env[key2] === "boolean" && this.env[key2] == true)
        data2[key2] = this.env[key2];
    }
    const blob = new Blob([JSON.stringify(data2, null, 2)], {
      type: "application/json"
    });
    return await writeFile(this.configPath, blob);
  }
}
class ArcTermEnv {
  constructor(term) {
    __publicField(this, "config");
    __publicField(this, "prompt", "[$username]: [~/$pwd] $ ");
    __publicField(this, "promptColor", "green");
    __publicField(this, "greeting", `ArcTerm & ArcOS v$version

Licensed under GPLv3. Created by the ArcOS team.`);
    __publicField(this, "logo", true);
    __publicField(this, "gooseBumps", false);
    __publicField(this, "textOnlyElevate", false);
    Log(`ArcTerm ${term.referenceId}`, `Creating new ArcTermEnv`, LogLevel.info);
    this.config = new ArcTermConfig(this, term);
  }
}
class ArcTermHistory {
  constructor(term) {
    __publicField(this, "term");
    __publicField(this, "store", Store$1([]));
    __publicField(this, "index", 0);
    Log(`ArcTerm ${term.referenceId}`, `Creating new ArcTermHistory`);
    this.term = term;
  }
  changeIndexRelatively(mod) {
    this.index += mod;
    const store = this.store.get();
    if (this.index < 0 && mod < 0) {
      this.index = 0;
    }
    if (this.index > store.length - 1 && mod > 0) {
      this.index = store.length;
      return "";
    }
    return store[this.index] || "";
  }
  getCurrentIndexItem() {
    return this.store[this.index] || "";
  }
  append(command, index = this.index) {
    if (!command)
      return;
    const store = this.store.get();
    store.splice(index + 1, 0, command);
    this.store.set(store);
    this.index = this.index + 1 >= store.length - 1 ? store.length : this.index + 1;
    return index;
  }
  clear() {
    this.store.set([]);
    this.index = 0;
  }
}
class ArcTermInput {
  constructor(T2) {
    __publicField(this, "lockInput", false);
    __publicField(this, "target");
    __publicField(this, "env");
    __publicField(this, "term");
    __publicField(this, "current");
    Log(`ArcTerm ${T2.referenceId}`, `Creating new ArcTermInput`);
    this.target = T2.target;
    this.env = T2.env;
    this.term = T2;
    this.commandLoop();
  }
  commandLoop() {
    Log(`ArcTerm ${this.term.referenceId}`, `input.commandLoop: Starting command loop`);
    setInterval(() => {
      if (this.lockInput)
        return;
      this.lock();
      const prompt = this.createPrompt();
      if (!prompt)
        return;
      this.target.append(prompt);
    }, 10);
  }
  lock() {
    this.lockInput = true;
  }
  unlock() {
    this.lockInput = false;
  }
  getPrompt() {
    return this.term.vars.replace(this.env.prompt);
  }
  createPrompt() {
    Log(`ArcTerm ${this.term.referenceId}`, `input.createPrompt`);
    if (this.current)
      this.current.disabled = true;
    if (!this.term.std)
      return;
    const wrap = document.createElement("div");
    const inner = document.createElement("div");
    const input = document.createElement("input");
    wrap.className = "prompt";
    if (this.term.std.verbose)
      this.term.std.writeColor(this.getPrompt(), this.env.promptColor, "white", true, wrap);
    input.id = `input#${Math.floor(Math.random() * 1e9)}`;
    input.spellcheck = false;
    input.addEventListener("keydown", (e2) => this.processInputEvent(e2, input));
    this.current = input;
    inner.className = "inner";
    inner.append(input);
    wrap.append(inner);
    setTimeout(() => {
      this.term.std.focusInput();
    });
    return wrap;
  }
  async processInputEvent(e2, input) {
    if (!e2 || !input)
      return;
    const split = input.value.split("&&");
    const key2 = e2.key.toLowerCase();
    switch (key2) {
      case "enter":
        this.term.history.append(input.value);
        this.processCommands(split);
        break;
      case "arrowup":
        input.value = this.term.history.changeIndexRelatively(-1);
        await sleep(0);
        input.setSelectionRange(input.value.length, input.value.length);
        return;
      case "arrowdown":
        input.value = this.term.history.changeIndexRelatively(1);
        await sleep(0);
        input.setSelectionRange(input.value.length, input.value.length);
        return;
    }
  }
  async processCommands(lines, file = "") {
    await sleep();
    for (const line of lines) {
      const str = this.term.vars.replace(line.trim());
      const args = str.split(" ");
      const cmd = args[0];
      if (cmd.trim() == "exit" && file)
        return false;
      if (cmd.startsWith("#") || !cmd)
        continue;
      args.shift();
      const success = await this.term.commandHandler.evaluate(cmd, args, !!file);
      if (!success) {
        return false;
      }
      this.lock();
      await sleep();
    }
    this.unlock();
    return true;
  }
}
class ArcTermScripts {
  constructor(term) {
    __publicField(this, "term");
    __publicField(this, "buffer", {});
    Log(`ArcTerm ${term.referenceId}`, `Creating new ArcTermScripts`);
    this.term = term;
  }
  async detectScript(directory, cmd) {
    Log(
      `ArcTerm ${this.term.referenceId}`,
      `scripts.detectScript: Detecting ${cmd} in ${directory}`
    );
    const dir = await readDirectory(directory);
    if (!dir)
      return null;
    const files = dir.files;
    for (const file of files) {
      const name = file.filename.toLowerCase();
      const path = file.scopedPath;
      if (name == `${cmd}.arcterm` && await this.isScriptFile(path))
        return path;
    }
  }
  async isScriptFile(path) {
    const file = await readFile(path);
    if (!file)
      return false;
    this.buffer[path] = file;
    const d3 = await blobToText(file.data);
    const split = d3.split("\n");
    return split[0].startsWith("#!arcterm");
  }
  async runScriptFile(path) {
    Log(`ArcTerm ${this.term.referenceId}`, `scripts.runScriptFile: running ${path}`);
    const contents = this.buffer[path] || await readFile(path);
    if (!contents)
      return Log(
        `ArcTerm ${this.term.referenceId}`,
        `scripts.runScriptFile: Error reading file ${path}`,
        LogLevel.error
      );
    const d3 = this.term.sect.parse(await blobToText(contents.data));
    const parts = d3.split("\n").filter((l2) => !!l2);
    await this.term.input.processCommands(parts, path);
  }
}
class ArcTermSections {
  constructor(term) {
    __publicField(this, "term");
    __publicField(this, "_sections", {});
    Log(`ArcTerm ${term.referenceId}`, `Creating new ArcTermSections`);
    this.term = term;
  }
  parse(text2) {
    Log(
      `ArcTerm ${this.term.referenceId}`,
      `sect.parse: Parsing sections from ${text2.length} bytes`
    );
    const input = `${text2}`;
    const regex = /sect \((?<name>\w+)\) {\n(?<cmds>.*?)\n}/gs;
    let match;
    while ((match = regex.exec(input)) !== null) {
      const group = match.groups;
      if (!group)
        continue;
      if (this._sections[group.name])
        Log(
          `ArcTerm ${this.term.referenceId}`,
          `sect.parse: Overwriting ${group.name}`,
          LogLevel.warn
        );
      const commands = group.cmds.split("\n").map((a2) => a2.trim());
      text2 = text2.replace(match[0], "");
      this._sections[group.name] = commands;
    }
    return text2;
  }
  get(name) {
    return this._sections[name] || false;
  }
}
class ArcTermStdSelect {
  constructor(std, color, target = std.target) {
    __publicField(this, "std");
    __publicField(this, "_sent", writable(false));
    __publicField(this, "_options", []);
    __publicField(this, "_index", 0);
    __publicField(this, "_elements", []);
    __publicField(this, "_color");
    this.target = target;
    Log(`ArcTerm ${std.term.referenceId}`, `Creating new ArcTermStdSelect`, LogLevel.info);
    this._color = color || "blue";
    this.std = std;
  }
  getStr(index, string) {
    const current = index == this._index;
    const sent = get_store_value(this._sent) && current;
    const prefix = current ? "> [" : "  ";
    const suffix = `${current ? "]" : ""}${sent ? " <" : ""}`;
    return `${prefix}${index + 1}. ${string}${suffix}`;
  }
  draw() {
    for (let i2 = 0; i2 < this._elements.length; i2++) {
      const element2 = this._elements[i2];
      this.std.updateColor(element2, this.getStr(i2, this._options[i2]), this._color, "gray");
    }
  }
  keyDown(e2) {
    this.std.term.app;
    if (!e2.key || get_store_value(this._sent))
      return;
    const key2 = e2.key.toLowerCase();
    const min = 0;
    const max = this._options.length - 1;
    switch (key2) {
      case "arrowup":
        this._index--;
        if (this._index < min)
          this._index = min;
        break;
      case "arrowdown":
        this._index++;
        if (this._index > max)
          this._index = max;
        break;
      case "escape":
        this._index = min;
      case "enter":
        document.removeEventListener("keydown", this.keyDown);
        this._sent.set(true);
    }
    this.draw();
  }
  async create(options2) {
    if (get_store_value(this._sent))
      return 0;
    await sleep(10);
    this._index = 0;
    this._options = options2;
    for (let i2 = 0; i2 < options2.length; i2++) {
      const str = this.getStr(i2, this._options[i2]);
      const element2 = this.std.writeColor(str, this._color, "gray", false, this.target);
      this._elements.push(element2);
    }
    document.addEventListener("keydown", (e2) => this.keyDown(e2));
    return new Promise((resolve) => {
      this._sent.subscribe((v2) => v2 && resolve(this._index));
    });
  }
}
class ArcTermStd {
  constructor(parent) {
    __publicField(this, "target");
    __publicField(this, "app");
    __publicField(this, "term");
    __publicField(this, "env");
    __publicField(this, "verbose", true);
    Log(`ArcTerm ${parent.referenceId}`, `Creating new ArcTermStd`);
    this.target = parent.target;
    this.app = parent.app;
    this.term = parent;
    this.env = parent.env;
  }
  write(str, target = this.target) {
    const el = this.writeLine(str, true, target);
    return el;
  }
  writeLine(str, inline2 = false, target = this.target) {
    const el = document.createElement("div");
    el.className = "part";
    if (inline2)
      el.className += " inline";
    el.innerText = str;
    target.appendChild(el);
    this.focusTarget();
    return el;
  }
  writeHTML(str, inline2 = false, target = this.target) {
    const el = document.createElement("div");
    el.className = "part";
    if (inline2)
      el.className += " inline";
    el.innerHTML = str;
    target.appendChild(el);
    this.focusTarget();
    return el;
  }
  writeSeparator(length) {
    this.writeLine(``.padEnd(length, "-"));
  }
  writeColor(str, pri, sec = "white", inline2 = false, target = this.target) {
    const parts = str.split(/(\[[^\]]*\])/);
    const out = document.createElement("div");
    out.className = `part `;
    if (inline2)
      out.className += " inline";
    for (const part of parts) {
      const element2 = document.createElement("span");
      const isPart = part.startsWith("[") && part.endsWith("]");
      const content = part.replaceAll("[", "").replaceAll("]", "");
      element2.className = `clr-${isPart ? pri : sec}`;
      element2.innerText = content;
      out.append(element2);
    }
    target.append(out);
    this.focusTarget();
    return out;
  }
  writeImage(src, height) {
    const el = document.createElement("img");
    el.className = "image";
    el.style.height = `${height}em`;
    el.src = src;
    this.target.append(el);
    this.focusTarget();
  }
  update(el, str) {
    if (!el)
      return false;
    el.innerText = "";
    this.write(str, this.target);
  }
  updateColor(el, str, pri, sec = "white") {
    if (!el)
      return false;
    el.innerText = "";
    this.writeColor(str, pri, sec, false, el);
  }
  Error(context) {
    Log(
      `ArcTerm ${this.term.referenceId}`,
      `std.Error: ${context.replaceAll("\n", "\\n")}`,
      LogLevel.error
    );
    if (!this.verbose)
      return;
    this.writeColor(`[Error]: ${context}`, "red");
  }
  Warning(context) {
    Log(
      `ArcTerm ${this.term.referenceId}`,
      `std.Warning: ${context.replaceAll("\n", "\\n")}`,
      LogLevel.warn
    );
    if (!this.verbose)
      return;
    this.writeColor(`[Warning]: ${context}`, "orange");
  }
  Info(context) {
    Log(
      `std.ArcTerm ${this.term.referenceId}`,
      `Info: ${context.replaceAll("\n", "\\n")}`,
      LogLevel.info
    );
    if (!this.verbose)
      return;
    this.writeColor(`[Info]: ${context}`, "blue");
  }
  async read(prefix, suffix, max, pswd = false, value = "", target = this.target) {
    if (!this.target)
      return "asdf";
    Log(`ArcTerm ${this.term.referenceId}`, `std.read: ${prefix}${suffix}`, LogLevel.info);
    const current = this.term.input.current;
    const commit = writable(false);
    const wrapper = document.createElement("div");
    const input = document.createElement("input");
    if (pswd)
      input.type = "password";
    input.style.width = `${max * 8.41}px`;
    input.maxLength = max;
    input.value = value;
    wrapper.className = "userinput";
    wrapper.append(prefix, input, suffix);
    target.append(wrapper);
    this.term.input.current = input;
    await sleep(10);
    this.focusInput();
    input.addEventListener("keydown", (e2) => {
      if (!e2.key)
        return;
      const key2 = e2.key.toLowerCase();
      if (key2 != "enter")
        return;
      input.disabled = true;
      commit.set(true);
    });
    return new Promise((resolve) => {
      commit.subscribe((v2) => {
        if (!v2)
          return;
        this.term.input.current = current;
        resolve(input.value);
      });
    });
  }
  initTarget() {
    this.target.innerText = "";
    const trigger = document.createElement("div");
    trigger.className = "click-trigger";
    this.target.addEventListener("click", () => this.focusInput());
    this.target.append(trigger);
  }
  focusInput() {
    if (!this.term || !this.term.input || !this.term.input.current)
      return;
    this.term.input.current.focus();
    this.focusTarget();
  }
  focusTarget() {
    if (!this.target)
      return;
    this.target.scrollTo(0, this.target.scrollHeight);
  }
  clear() {
    this.initTarget();
  }
  async select(options2, color, target = this.target) {
    const select = new ArcTermStdSelect(this, color, target);
    return await select.create(options2);
  }
}
function ArcTermIntro(term) {
  if (!term.env.logo)
    return;
  const x2 = [
    "   [_]         _____            ",
    "  [/_\\]  _ _ _|_   _|__ _ _ _ __ ",
    " [/ _ \\]| '_/ _|| |/ -_) '_| '  \\",
    "[/_/ \\_\\]_| \\__||_|\\___|_| |_|_|_|"
  ];
  for (const line of x2) {
    term.std.writeColor(line, "blue");
  }
  term.std.writeLine("\n");
}
class ArcTermUtil {
  constructor(t2) {
    __publicField(this, "term");
    __publicField(this, "reference", "");
    this.setReference();
    Log(`ArcTerm ${this.reference}`, `Creating new ArcTermUtil`);
    this.term = t2;
  }
  getReference() {
    Log(`ArcTerm ${this.reference}`, this.reference);
    return this.reference;
  }
  setReference() {
    const rnd = () => Math.floor(Math.random() * 1e6);
    this.reference = `${rnd()}-${rnd()}-${rnd()}-${rnd()}`;
  }
  flushAccent() {
    if (this.term.app)
      return;
    this.term.target.setAttribute(
      "style",
      `--terminal-accent: var(--clr-${this.term.env.promptColor}-fg);`
    );
  }
  intro() {
    if (!this.term || !this.term.std)
      return;
    ArcTermIntro(this.term);
    const out = this.term.vars.replace(this.term.env.greeting);
    this.term.std.writeColor(`${out}

`, this.term.env.promptColor);
  }
}
function getArcTermStore(term) {
  Log(`ArcTerm ${term.referenceId}`, "Creating new ArcTermVariableStore");
  return {
    prompt: {
      get: () => term.env.prompt,
      set: async (v2) => {
        term.env.prompt = v2;
        await term.env.config.writeConfig();
      },
      canDelete: false,
      readOnly: false
    },
    server: {
      get: () => getServer(),
      readOnly: true,
      canDelete: false
    },
    username: {
      get: () => UserName.get(),
      readOnly: true,
      canDelete: false
    },
    version: {
      get: () => ArcOSVersion,
      readOnly: true,
      canDelete: false
    },
    pwd: {
      get: () => (term.path || "./").replace("./", ""),
      set: async (v2) => {
        const dir = await readDirectory(v2);
        if (!dir)
          return term.std.Error(`pwd: Directory doesn't exist, falling back.`);
        term.path = v2;
      },
      canDelete: false,
      readOnly: false
    },
    color: {
      get: () => term.env.promptColor,
      set: async (v2) => {
        if (!colors.includes(v2))
          return term.std.Error("color is invalid, falling back.");
        term.env.promptColor = v2;
        await term.env.config.writeConfig();
        term.util.flushAccent();
      },
      canDelete: false,
      readOnly: false
    },
    ref: {
      get: () => term.referenceId,
      readOnly: true,
      canDelete: false
    },
    pid: {
      get: () => `${term.pid}`,
      readOnly: true,
      canDelete: false
    },
    $: {
      get: () => `ArcTerm ${term.referenceId}`,
      readOnly: true,
      canDelete: false
    },
    rand: {
      get: () => `${Math.floor(Math.random() * 1e6)}`,
      readOnly: true,
      canDelete: false
    }
  };
}
class ArcTermVariables {
  constructor(t2) {
    __publicField(this, "term");
    __publicField(this, "store", {});
    Log(`ArcTerm ${t2.referenceId}`, "Creating new ArcTermVariables");
    this.term = t2;
    this.store = getArcTermStore(this.term);
  }
  async getAll() {
    const result = {};
    const entries = Object.entries(this.store);
    for (const [key2, variable] of entries) {
      const value = this.get(key2);
      const ro = variable.readOnly;
      result[key2] = { value, readOnly: ro };
    }
    return result;
  }
  get(key2) {
    if (!this.store[key2])
      return key2;
    return this.store[key2].get();
  }
  async set(key2, value) {
    Log(`ArcTerm ${this.term.referenceId}`, `var.set: setting "${key2}" to "${value}"`);
    if (!this.store[key2]) {
      const variable2 = {
        get: () => variable2.value,
        set: (v2) => variable2.value = v2,
        readOnly: false,
        canDelete: true,
        value
      };
      this.store[key2] = variable2;
      return true;
    }
    if (this.store[key2].readOnly)
      return false;
    const variable = this.store[key2];
    if (!variable)
      return false;
    await variable.set(value);
    return true;
  }
  async delete(key2) {
    Log(`ArcTerm ${this.term.referenceId}`, `var.delete: deleting "${key2}"`);
    if (!this.store[key2] || this.store[key2].readOnly)
      return false;
    await this.set(key2, "");
    return true;
  }
  replace(str) {
    const variables = this.parseInlineNames(str);
    if (!variables.length)
      return str;
    for (const variable of variables) {
      const part = `$${variable}`;
      const value = this.get(variable);
      str = str.replace(part, value == variable && part ? part : value);
    }
    return str;
  }
  parseInlineNames(str) {
    const regex = /\$([a-zA-Z_][a-zA-Z0-9_]*|\$)/g;
    const matches = [];
    let match;
    while (match = regex.exec(str)) {
      matches.push(match[1]);
    }
    return matches;
  }
}
class ArcTerm {
  constructor(target, store, app, pid, callback) {
    __publicField(this, "target");
    __publicField(this, "commands");
    __publicField(this, "app");
    __publicField(this, "std");
    __publicField(this, "util");
    __publicField(this, "env");
    __publicField(this, "vars");
    __publicField(this, "input");
    __publicField(this, "path");
    __publicField(this, "scripts");
    __publicField(this, "sect");
    __publicField(this, "history");
    __publicField(this, "commandHandler");
    __publicField(this, "referenceId");
    __publicField(this, "onload");
    this.pid = pid;
    this.target = target;
    this.commands = store;
    this.app = app;
    this.onload = callback;
    this.initialize();
  }
  async initialize() {
    this.util = new ArcTermUtil(this);
    this.referenceId = this.util.getReference();
    Log(`ArcTerm ${this.referenceId}`, `Initializing new ArcTerm`);
    if (!this.target)
      throw new Error("Can't initialize ArcTerm without a valid target");
    this.target.innerText = "";
    this.target.removeAttribute("style");
    this.path = "./";
    this.history = new ArcTermHistory(this);
    this.commandHandler = new ArcTermCommandHandler(this);
    this.env = new ArcTermEnv(this);
    this.vars = new ArcTermVariables(this);
    this.scripts = new ArcTermScripts(this);
    this.sect = new ArcTermSections(this);
    await sleep(50);
    this.std = new ArcTermStd(this);
    this.input = new ArcTermInput(this);
    this.input.lock();
    if (this.onload)
      await this.onload(this);
    await this.env.config.loadConfigFile();
    if (!this.pid)
      return this.intro();
    const proc = ProcessStack.getProcess(this.pid);
    const args = proc.args;
    if (!args[0] || !Array.isArray(args[0]))
      return this.intro();
    this.std.clear();
    await this.input.processCommands(args[0]);
    this.input.unlock();
  }
  intro() {
    this.util.flushAccent();
    this.input.unlock();
    this.util.intro();
    if (this.env.gooseBumps)
      this.std.Warning("GooseBumps 👀\n\n");
  }
  dispose() {
    Log(`ArcTerm ${this.referenceId}`, "Disposing");
    if (!this.target)
      return;
    this.std.clear();
    this.std = null;
    this.env = null;
    this.input.lock();
    this.input = null;
  }
  async reload() {
    Log(`ArcTerm ${this.referenceId}`, "Reloading");
    this.dispose();
    await sleep();
    await this.initialize();
  }
}
const sizeUnits = ["bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
function formatBytes(bytes) {
  let l2 = 0, n2 = bytes;
  while (n2 >= 1024 && ++l2) {
    n2 = n2 / 1024;
  }
  return n2.toFixed(n2 < 10 && l2 > 0 ? 1 : 0) + " " + sizeUnits[l2];
}
const AccountIcon = "" + new URL("account-381cfd3c.svg", import.meta.url).href;
const AppsIcon = "" + new URL("apps-40e412f0.svg", import.meta.url).href;
const ArcFindIcon = "" + new URL("arcfind-605851f5.svg", import.meta.url).href;
const BookIcon = "" + new URL("book-56212100.svg", import.meta.url).href;
const BugReportIcon = "" + new URL("bugreports-44ee9b60.svg", import.meta.url).href;
const ComponentIcon = "" + new URL("component-2eec2b07.svg", import.meta.url).href;
const ConnectIcon = "" + new URL("connect-63827d9f.svg", import.meta.url).href;
const DesktopIcon$1 = "" + new URL("desktop-a534dc16.svg", import.meta.url).href;
const firefox = "" + new URL("firefox-ac949acd.png", import.meta.url).href;
const FlagIcon = "" + new URL("flag-80e46659.svg", import.meta.url).href;
const GlobeIcon = "" + new URL("globe-44ffb86a.svg", import.meta.url).href;
const HomeIcon = "" + new URL("home-12b7686e.svg", import.meta.url).href;
const info = "" + new URL("info-8e0d83af.svg", import.meta.url).href;
const KeyboardIcon = "" + new URL("keyboard-ff43ac1a.svg", import.meta.url).href;
const memory = "" + new URL("memory-448cc3a3.svg", import.meta.url).href;
const ModeIcon = "" + new URL("mode-06260fff.svg", import.meta.url).href;
const PasswordIcon = "" + new URL("password-003e44ca.svg", import.meta.url).href;
const PersonalizationIcon = "" + new URL("personalization-24a3f1c4.svg", import.meta.url).href;
const SaveIcon = "" + new URL("save-ad720c82.svg", import.meta.url).href;
const SecureIcon = "" + new URL("secure-4a80d8b5.svg", import.meta.url).href;
const SecurityHighIcon = "" + new URL("security-high-39bbc6f9.svg", import.meta.url).href;
const SecurityLowIcon = "" + new URL("security-low-6b6d0d2c.svg", import.meta.url).href;
const SecurityMediumIcon = "" + new URL("secure-4a80d8b5.svg", import.meta.url).href;
const settings = "" + new URL("settings-c01ae5e7.svg", import.meta.url).href;
const SpinnerIcon = "" + new URL("spinner-a610f1d3.svg", import.meta.url).href;
const startmenu = "" + new URL("startmenu-19b8d201.svg", import.meta.url).href;
const TaskbarIcon = "" + new URL("taskbar-544769e3.svg", import.meta.url).href;
const ThemesIcon = "" + new URL("themes-06cf73a3.svg", import.meta.url).href;
const TrashIcon = "" + new URL("trash-aaf1e2ea.svg", import.meta.url).href;
const UpdateIcon = "" + new URL("update-97d232d4.svg", import.meta.url).href;
const UploadIcon = "" + new URL("upload-5ec58175.svg", import.meta.url).href;
const WaveIcon = "" + new URL("wave-5c639866.svg", import.meta.url).href;
const WindowSettingsIcon = "" + new URL("serviceinfo-2b866135.svg", import.meta.url).href;
const windowsnap = "" + new URL("windowsnap-3bc20aa1.svg", import.meta.url).href;
const General = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AccountIcon,
  AppsIcon,
  ArcFindIcon,
  BookIcon,
  BugReportIcon,
  ComponentIcon,
  ConnectIcon,
  DesktopIcon: DesktopIcon$1,
  FirefoxIcon: firefox,
  FlagIcon,
  GlobeIcon,
  HomeIcon,
  InfoIcon: info,
  KeyboardIcon,
  MemoryIcon: memory,
  ModeIcon,
  PasswordIcon,
  PersonalizationIcon,
  SaveIcon,
  SecureIcon,
  SecurityHighIcon,
  SecurityLowIcon,
  SecurityMediumIcon,
  SettingsIcon: settings,
  SpinnerIcon,
  StartMenuIcon: startmenu,
  TaskbarIcon,
  ThemesIcon,
  TrashIcon,
  UpdateIcon,
  UploadIcon,
  WaveIcon,
  WindowSettingsIcon,
  WindowSnapIcon: windowsnap
}, Symbol.toStringTag, { value: "Module" }));
const ShutdownIcon = "" + new URL("exit-501170e1.svg", import.meta.url).href;
const LockIcon = "" + new URL("lock-8b597bff.svg", import.meta.url).href;
const LogoutIcon = "" + new URL("logout-f0a34c70.svg", import.meta.url).href;
const RestartIcon = "" + new URL("restart-64583c17.svg", import.meta.url).href;
const Power = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LockIcon,
  LogoutIcon,
  RestartIcon,
  ShutdownIcon
}, Symbol.toStringTag, { value: "Module" }));
const TrayPopup_svelte_svelte_type_style_lang = "";
function create_fragment$5C(ctx) {
  let div2;
  let div0;
  let button0;
  let t0;
  let button0_disabled_value;
  let t1;
  let p0;
  let t3;
  let div1;
  let button1;
  let t4;
  let button1_disabled_value;
  let t5;
  let p1;
  let t7;
  let div4;
  let img;
  let img_src_value;
  let t8;
  let div3;
  let t9;
  let span;
  let t10_value = (
    /*$user*/
    ctx[0].sh.bypassElevation ? "At risk" : (
      /*$user*/
      ctx[0].sh.elevationDisabled ? "In lockdown" : (
        /*$user*/
        ctx[0].sh.securityNoPassword ? "Mildly insecure" : "All is good"
      )
    )
  );
  let t10;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      button0 = element("button");
      t0 = text("vpn_key");
      t1 = space();
      p0 = element("p");
      p0.textContent = "Password";
      t3 = space();
      div1 = element("div");
      button1 = element("button");
      t4 = text("lock");
      t5 = space();
      p1 = element("p");
      p1.textContent = "Lockdown";
      t7 = space();
      div4 = element("div");
      img = element("img");
      t8 = space();
      div3 = element("div");
      t9 = space();
      span = element("span");
      t10 = text(t10_value);
      button0.disabled = button0_disabled_value = /*$user*/
      ctx[0].sh.elevationDisabled || /*$user*/
      ctx[0].sh.bypassElevation;
      attr(button0, "class", "material-icons-round svelte-177chng");
      toggle_class(button0, "suggested", !/*$user*/
      ctx[0].sh.securityNoPassword);
      attr(p0, "class", "caption svelte-177chng");
      attr(div0, "class", "setting svelte-177chng");
      toggle_class(
        div0,
        "disabled",
        /*$user*/
        ctx[0].sh.elevationDisabled || /*$user*/
        ctx[0].sh.bypassElevation
      );
      button1.disabled = button1_disabled_value = /*$user*/
      ctx[0].sh.bypassElevation;
      attr(button1, "class", "material-icons-round svelte-177chng");
      toggle_class(
        button1,
        "suggested",
        /*$user*/
        ctx[0].sh.elevationDisabled
      );
      attr(p1, "class", "caption svelte-177chng");
      attr(div1, "class", "setting svelte-177chng");
      toggle_class(
        div1,
        "disabled",
        /*$user*/
        ctx[0].sh.bypassElevation
      );
      attr(div2, "class", "top svelte-177chng");
      if (!src_url_equal(img.src, img_src_value = /*$user*/
      ctx[0].sh.bypassElevation ? SecurityHighIcon : (
        /*$user*/
        ctx[0].sh.elevationDisabled ? LockIcon : (
          /*$user*/
          ctx[0].sh.securityNoPassword ? SecurityMediumIcon : SecurityLowIcon
        )
      )))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(div3, "class", "sep svelte-177chng");
      attr(div4, "class", "bottom svelte-177chng");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, button0);
      append(button0, t0);
      append(div0, t1);
      append(div0, p0);
      append(div2, t3);
      append(div2, div1);
      append(div1, button1);
      append(button1, t4);
      append(div1, t5);
      append(div1, p1);
      insert(target, t7, anchor);
      insert(target, div4, anchor);
      append(div4, img);
      append(div4, t8);
      append(div4, div3);
      append(div4, t9);
      append(div4, span);
      append(span, t10);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[1]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$user*/
      1 && button0_disabled_value !== (button0_disabled_value = /*$user*/
      ctx2[0].sh.elevationDisabled || /*$user*/
      ctx2[0].sh.bypassElevation)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*$user*/
      1) {
        toggle_class(button0, "suggested", !/*$user*/
        ctx2[0].sh.securityNoPassword);
      }
      if (dirty & /*$user*/
      1) {
        toggle_class(
          div0,
          "disabled",
          /*$user*/
          ctx2[0].sh.elevationDisabled || /*$user*/
          ctx2[0].sh.bypassElevation
        );
      }
      if (dirty & /*$user*/
      1 && button1_disabled_value !== (button1_disabled_value = /*$user*/
      ctx2[0].sh.bypassElevation)) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*$user*/
      1) {
        toggle_class(
          button1,
          "suggested",
          /*$user*/
          ctx2[0].sh.elevationDisabled
        );
      }
      if (dirty & /*$user*/
      1) {
        toggle_class(
          div1,
          "disabled",
          /*$user*/
          ctx2[0].sh.bypassElevation
        );
      }
      if (dirty & /*$user*/
      1 && !src_url_equal(img.src, img_src_value = /*$user*/
      ctx2[0].sh.bypassElevation ? SecurityHighIcon : (
        /*$user*/
        ctx2[0].sh.elevationDisabled ? LockIcon : (
          /*$user*/
          ctx2[0].sh.securityNoPassword ? SecurityMediumIcon : SecurityLowIcon
        )
      ))) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*$user*/
      1 && t10_value !== (t10_value = /*$user*/
      ctx2[0].sh.bypassElevation ? "At risk" : (
        /*$user*/
        ctx2[0].sh.elevationDisabled ? "In lockdown" : (
          /*$user*/
          ctx2[0].sh.securityNoPassword ? "Mildly insecure" : "All is good"
        )
      )))
        set_data(t10, t10_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t7);
        detach(div4);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$57($$self, $$props, $$invalidate) {
  let $user;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(0, $user = $$value));
  const click_handler = () => set_store_value(UserDataStore, $user.sh.securityNoPassword = !$user.sh.securityNoPassword, $user);
  const click_handler_1 = () => set_store_value(UserDataStore, $user.sh.elevationDisabled = !$user.sh.elevationDisabled, $user);
  return [$user, click_handler, click_handler_1];
}
let TrayPopup$1 = class TrayPopup extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$57, create_fragment$5C, safe_not_equal, {});
  }
};
const trayIcons = Store$1([]);
function createTrayIcon(data2) {
  if (trayExists(data2.identifier))
    return false;
  const icons = trayIcons.get();
  icons.push(data2);
  trayIcons.set(icons);
}
function disposeTrayIcon(identifier) {
  const icons = trayIcons.get();
  for (let i2 = 0; i2 < icons.length; i2++) {
    if (icons[i2].identifier == identifier)
      icons.splice(i2, 1);
  }
  trayIcons.set(icons);
}
function trayExists(identifier) {
  const icons = trayIcons.get();
  for (const icon of icons) {
    if (icon.identifier == identifier)
      return true;
  }
  return false;
}
const main$z = "";
const KnownAcceleratorKeys = [
  "alt",
  "shift",
  "ctrl",
  "esc",
  "up",
  "down",
  "left",
  "right",
  "space",
  "del",
  ..."0123456789".split(""),
  ..."abcdefghijklmnopqrstuvwxyz".split(""),
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "f10",
  "f11",
  "f12",
  "/",
  "enter"
];
function splitAcceleratorString(accelerator) {
  const result = [];
  const split = accelerator.split("+");
  for (let i2 = 0; i2 < split.length; i2++) {
    const segment = split[i2];
    if (!KnownAcceleratorKeys.includes(segment))
      continue;
    result.push(segment);
    if (i2 + 1 != split.length)
      result.push("+");
  }
  return result;
}
const appGroups = {
  internal: {
    name: "%internal%",
    // Hidden applications only called programmatically
    id: "internal",
    index: 0
  },
  coreApps: {
    name: "Core Apps",
    // `App.metadata.core` enabled apps (wallpaper, shell)
    id: "coreApps",
    index: 1
  },
  utilities: {
    name: "Utilities",
    // Everyday office utilities
    id: "utilities",
    index: 2
  },
  entertainment: {
    name: "Entertainment",
    // Games, media player, etc
    id: "entertainment",
    index: 3
  },
  communication: {
    name: "Communication",
    // Communication with other people (messaging)
    id: "communication",
    index: 4
  },
  support: {
    name: "Help and Support",
    // Tools used for help and support
    id: "support",
    index: 5
  },
  systemTools: {
    name: "System Tools",
    // Tools used to manage ArcOS
    id: "systemTools",
    index: 6
  }
};
const appLibrary = Store$1(/* @__PURE__ */ new Map([]));
const maxZIndex = Store$1(1e3);
let Runtime$m = class Runtime extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    // S<R<id, R<accelerator, description>>>
    __publicField(this, "store", Store$1());
    process.accelerator.store.push({
      key: "escape",
      action() {
        if (app.isOverlay)
          process.handler.kill(process.pid, true);
      }
    });
    appLibrary.subscribe((v2) => this.populate(v2));
  }
  populate(v2) {
    const store = [];
    for (const [_2, app] of [...v2]) {
      if (!app.acceleratorDescriptions)
        continue;
      const strings = Object.keys(app.acceleratorDescriptions);
      let shortcuts = [];
      for (const string of strings) {
        shortcuts.push([splitAcceleratorString(string), app.acceleratorDescriptions[string]]);
      }
      store.push([app.metadata.name, shortcuts]);
    }
    this.store.set(store);
  }
};
function get_each_context$V(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2][0];
  child_ctx[4] = list2[i2][1];
  return child_ctx;
}
function get_each_context_1$8(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list2[i2][0];
  child_ctx[8] = list2[i2][1];
  return child_ctx;
}
function get_each_context_2$2(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list2[i2];
  return child_ctx;
}
function create_if_block$23(ctx) {
  let div0;
  let t3;
  let div1;
  let each_value = ensure_array_like(
    /*$store*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$V(get_each_context$V(ctx, each_value, i2));
  }
  return {
    c() {
      div0 = element("div");
      div0.innerHTML = `<h1>Keyboard Shortcuts</h1> <p>Get more work done faster with these handy shortcuts!</p>`;
      t3 = space();
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div0, "class", "header");
      attr(div1, "class", "shortcuts");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$store*/
      1) {
        each_value = ensure_array_like(
          /*$store*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$V(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$V(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div1, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t3);
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block$C(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "+";
      attr(span, "class", "plus");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1$H(ctx) {
  let div;
  let t_value = (
    /*key*/
    ctx[11] + ""
  );
  let t2;
  let div_class_value;
  return {
    c() {
      div = element("div");
      t2 = text(t_value);
      attr(div, "class", div_class_value = "key key-" + /*key*/
      ctx[11]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$store*/
      1 && t_value !== (t_value = /*key*/
      ctx2[11] + ""))
        set_data(t2, t_value);
      if (dirty & /*$store*/
      1 && div_class_value !== (div_class_value = "key key-" + /*key*/
      ctx2[11])) {
        attr(div, "class", div_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block_2$2(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*key*/
      ctx2[11] !== "+"
    )
      return create_if_block_1$H;
    return create_else_block$C;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_each_block_1$8(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let t1_value = (
    /*description*/
    ctx[8] + ""
  );
  let t1;
  let t2;
  let each_value_2 = ensure_array_like(
    /*keys*/
    ctx[7]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i2));
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      attr(div0, "class", "keys");
      attr(div1, "class", "description");
      attr(div2, "class", "shortcut");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div2, t0);
      append(div2, div1);
      append(div1, t1);
      append(div2, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$store*/
      1) {
        each_value_2 = ensure_array_like(
          /*keys*/
          ctx2[7]
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$2(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_2$2(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div0, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
      if (dirty & /*$store*/
      1 && t1_value !== (t1_value = /*description*/
      ctx2[8] + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$V(ctx) {
  let div1;
  let h1;
  let t0_value = (
    /*name*/
    ctx[3] + ""
  );
  let t0;
  let t1;
  let div0;
  let t2;
  let each_value_1 = ensure_array_like(
    /*shortcuts*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$8(get_each_context_1$8(ctx, each_value_1, i2));
  }
  return {
    c() {
      div1 = element("div");
      h1 = element("h1");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      attr(h1, "class", "name");
      attr(div0, "class", "app-shortcuts");
      attr(div1, "class", "app");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, h1);
      append(h1, t0);
      append(div1, t1);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$store*/
      1 && t0_value !== (t0_value = /*name*/
      ctx2[3] + ""))
        set_data(t0, t0_value);
      if (dirty & /*$store*/
      1) {
        each_value_1 = ensure_array_like(
          /*shortcuts*/
          ctx2[4]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$8(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$8(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div0, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$5B(ctx) {
  let if_block_anchor;
  let if_block = (
    /*$store*/
    ctx[0] && create_if_block$23(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*$store*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$23(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$56($$self, $$props, $$invalidate) {
  let $store;
  let { runtime } = $$props;
  const { store } = runtime;
  component_subscribe($$self, store, (value) => $$invalidate(0, $store = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [$store, store, runtime];
}
let App$u = class App extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$56, create_fragment$5B, safe_not_equal, { runtime: 2 });
  }
};
const KeyboardShortcuts = {
  metadata: {
    name: "Keyboard Shortcuts",
    description: "View the keyboard shortcuts in ArcOS",
    author: "The ArcOS Team",
    version: "1.0.0",
    icon: KeyboardIcon,
    hidden: true,
    dependendsOn: ["ArcShell"]
  },
  runtime: Runtime$m,
  content: App$u,
  id: "KeyboardShortcuts",
  size: { w: 1e3, h: 750 },
  minSize: { w: 1e3, h: 750 },
  maxSize: { w: 1e3, h: 750 },
  pos: { x: 60, y: 60 },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: {
    minimize: true,
    maximize: true,
    close: true
  },
  singleInstance: true,
  loadCondition: () => !SafeMode.get()
};
const AppInfoIcon = "" + new URL("appinfo-494c7560.svg", import.meta.url).href;
const ArcTermIcon = "" + new URL("arcterm-916a412e.svg", import.meta.url).href;
const DefaultIcon = "" + new URL("default-76b955a2.svg", import.meta.url).href;
const DonutIcon = "" + new URL("donut-041054d9.png", import.meta.url).href;
const FileManagerIcon = "" + new URL("filemanager-a2c40334.svg", import.meta.url).href;
const IconLibraryIcon = "" + new URL("iconlibrary-9cb9e970.svg", import.meta.url).href;
const ImageViewerIcon = "" + new URL("imageviewer-5fae1359.svg", import.meta.url).href;
const LightsOffIcon = "" + new URL("lightsoff-6a76b910.svg", import.meta.url).href;
const LoggerIcon = "" + new URL("logger-f7d8f69c.svg", import.meta.url).href;
const MediaPlayerIcon = "" + new URL("mediaplayer-5ba36683.svg", import.meta.url).href;
const MessagingIcon = "" + new URL("messaging-3ada0813.svg", import.meta.url).href;
const ProcessManagerIcon = "" + new URL("processmanager-8c47a0ba.svg", import.meta.url).href;
const QlorbIcon = "" + new URL("qlorb-d442097b.svg", import.meta.url).href;
const ServiceInfoIcon = "" + new URL("serviceinfo-2b866135.svg", import.meta.url).href;
const SettingsIcon = "" + new URL("settings-c01ae5e7.svg", import.meta.url).href;
const TextEditorIcon = "" + new URL("texteditor-4b8a05d6.svg", import.meta.url).href;
const CalculatorIcon = "" + new URL("calculator-a55e0dfc.svg", import.meta.url).href;
const Apps$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AppInfoIcon,
  ArcTermIcon,
  CalculatorIcon,
  DefaultIcon,
  DonutIcon,
  FileManagerIcon,
  IconLibraryIcon,
  ImageViewerIcon,
  LightsOffIcon,
  LoggerIcon,
  MediaPlayerIcon,
  MessagingIcon,
  ProcessManagerIcon,
  QlorbIcon,
  ServiceInfoIcon,
  SettingsIcon,
  TextEditorIcon
}, Symbol.toStringTag, { value: "Module" }));
function create_fragment$5A(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", div_class_value = "info-block " + /*className*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*className*/
      1 && div_class_value !== (div_class_value = "info-block " + /*className*/
      ctx2[0])) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$55($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { className = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(0, className = $$props2.className);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [className, $$scope, slots];
}
class InfoBlock extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$55, create_fragment$5A, safe_not_equal, { className: 0 });
  }
}
function create_fragment$5z(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", div_class_value = "row " + /*className*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*className*/
      1 && div_class_value !== (div_class_value = "row " + /*className*/
      ctx2[0])) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$54($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { className = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(0, className = $$props2.className);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [className, $$scope, slots];
}
class InfoRow extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$54, create_fragment$5z, safe_not_equal, { className: 0 });
  }
}
var ElevationLevel = /* @__PURE__ */ ((ElevationLevel2) => {
  ElevationLevel2[ElevationLevel2["low"] = 0] = "low";
  ElevationLevel2[ElevationLevel2["medium"] = 1] = "medium";
  ElevationLevel2[ElevationLevel2["high"] = 2] = "high";
  return ElevationLevel2;
})(ElevationLevel || {});
function ElevatedAppLaunchData(app) {
  return {
    what: "ArcOS needs your permission to open the following application:",
    image: app.metadata.icon,
    title: app.metadata.name,
    description: app.metadata.author,
    level: ElevationLevel.low
  };
}
function ChangeDisabledStateData(id) {
  return {
    what: "ArcOS needs your permission to perform the following action:",
    image: ModeIcon,
    title: "Change Disabled State",
    description: `Of ${id}`,
    level: ElevationLevel.high
  };
}
function ElevationKillProcess(proc) {
  return {
    what: "ArcOS needs your permission to kill the following process:",
    image: ShutdownIcon,
    title: proc.name,
    description: `PID ${proc.pid}`,
    level: ElevationLevel.medium
  };
}
function ElevationKillAppProcesses(id) {
  return {
    what: "ArcOS needs your permission to kill processes of the following app:",
    image: ShutdownIcon,
    title: id,
    description: `From the Library`,
    level: ElevationLevel.medium
  };
}
function ElevationChangeServiceState(service) {
  return {
    what: "ArcOS needs your permission to change the state of the following service:",
    image: WindowSettingsIcon,
    title: service.name,
    description: service.description,
    level: ElevationLevel.high
  };
}
function ElevationChangePassword() {
  return {
    what: "You need permission from yourself to change your password:",
    image: PasswordIcon,
    title: `Change Password`,
    description: `Of ${UserName.get()}`,
    level: ElevationLevel.high
  };
}
function ElevationChangeUsername() {
  return {
    what: "You need permission from yourself to change your username:",
    image: AccountIcon,
    title: `Change Username`,
    description: `Of ${UserName.get()}`,
    level: ElevationLevel.high
  };
}
function ElevationChangeUserData() {
  return {
    what: "ArcOS needs your permission to make changes to your user data:",
    image: AccountIcon,
    title: `Change User Data`,
    description: `Of ${UserName.get()}`,
    level: ElevationLevel.high
  };
}
function ElevationEnableBypass() {
  return {
    what: "ArcOS needs your permission to disable elevation entirely. Are you insane?",
    image: SecurityHighIcon,
    title: `Disable elevation`,
    description: "We do NOT recommend this",
    level: ElevationLevel.high
  };
}
const ElevationLevelIcons = {
  [ElevationLevel.low]: SecurityLowIcon,
  [ElevationLevel.medium]: SecurityMediumIcon,
  [ElevationLevel.high]: SecurityHighIcon
};
async function killAllAppInstances(id, fromSystem = false) {
  Log("process/kill", `Killing all instances of ${id}`);
  const pids = ProcessStack.getAppPids(id);
  const elevated = fromSystem || await GetUserElevation(ElevationKillAppProcesses(id), ProcessStack);
  if (!elevated)
    return false;
  for (const pid of pids) {
    ProcessStack.kill(pid, elevated);
  }
  return true;
}
async function killAllApps(fromSystem = false) {
  const library = appLibrary.get();
  for (const [id] of library) {
    await killAllAppInstances(id, fromSystem);
  }
}
const ErrorIcon = "" + new URL("error-f8493c45.svg", import.meta.url).href;
const InfoIcon = "" + new URL("information-298ca586.svg", import.meta.url).href;
const QuestionIcon = "" + new URL("question-f471e451.svg", import.meta.url).href;
const WarningIcon = "" + new URL("warning-ff1a36ed.svg", import.meta.url).href;
const Dialog$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ErrorIcon,
  InfoIcon,
  QuestionIcon,
  WarningIcon
}, Symbol.toStringTag, { value: "Module" }));
const main$y = "";
let Runtime$l = class Runtime2 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    function stop2() {
      process.handler.kill(process.pid, true);
      sendNotification({
        title: "Can't open Error",
        message: `No valid data was specified to use in the dialog. Aborting.`,
        image: WarningIcon,
        timeout: 3e3
      });
    }
    const data2 = process.args[0];
    if (!data2) {
      stop2();
      return;
    }
    mutator.update((v2) => {
      v2.metadata.name = data2.title;
      v2.metadata.icon = data2.image || WarningIcon;
      v2.maxSize.w = data2.component && !data2.shrunk ? 500 : 400;
      return v2;
    });
    process.accelerator.store.push({
      key: "escape",
      action: () => this.defaultAction()
    });
  }
  async defaultAction() {
    const data2 = this.process.args[0];
    const suggested = data2.buttons.filter((a2) => !a2.suggested)[0] || data2.buttons[0];
    await suggested.action();
    focusedPid.set(this.process.parentPid);
    this.process.handler.kill(this.process.pid, true);
  }
};
function get_each_context$U(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list2[i2];
  return child_ctx;
}
function create_if_block$22(ctx) {
  let div1;
  let t0;
  let div0;
  let h3;
  let t1_value = (
    /*data*/
    ctx[0].title + ""
  );
  let t1;
  let t2;
  let p2;
  let current_block_type_index;
  let if_block1;
  let t3;
  let div3;
  let div2;
  let current;
  let if_block0 = (
    /*data*/
    ctx[0].image && create_if_block_2$g(ctx)
  );
  const if_block_creators = [create_if_block_1$G, create_else_block$B];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*data*/
      ctx2[0].component
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let each_value = ensure_array_like(
    /*data*/
    ctx[0].buttons
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$U(get_each_context$U(ctx, each_value, i2));
  }
  return {
    c() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      h3 = element("h3");
      t1 = text(t1_value);
      t2 = space();
      p2 = element("p");
      if_block1.c();
      t3 = space();
      div3 = element("div");
      div2 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(h3, "class", "error-title");
      attr(p2, "class", "error-message");
      attr(div0, "class", "content");
      attr(div1, "class", "top");
      toggle_class(
        div1,
        "shrunk",
        /*data*/
        ctx[0].shrunk
      );
      attr(div2, "class", "buttons");
      attr(div3, "class", "bottom");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div0, h3);
      append(h3, t1);
      append(div0, t2);
      append(div0, p2);
      if_blocks[current_block_type_index].m(p2, null);
      insert(target, t3, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div2, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*data*/
        ctx2[0].image
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$g(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((!current || dirty & /*data*/
      1) && t1_value !== (t1_value = /*data*/
      ctx2[0].title + ""))
        set_data(t1, t1_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(p2, null);
      }
      if (!current || dirty & /*data*/
      1) {
        toggle_class(
          div1,
          "shrunk",
          /*data*/
          ctx2[0].shrunk
        );
      }
      if (dirty & /*disabled, data, e*/
      7) {
        each_value = ensure_array_like(
          /*data*/
          ctx2[0].buttons
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$U(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$U(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div2, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t3);
        detach(div3);
      }
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_2$g(ctx) {
  let div;
  let img;
  let img_src_value;
  return {
    c() {
      div = element("div");
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*data*/
      ctx[0].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(div, "class", "error-image");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && !src_url_equal(img.src, img_src_value = /*data*/
      ctx2[0].image)) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_else_block$B(ctx) {
  let html_tag;
  let raw_value = (
    /*data*/
    (ctx[0].message || "$error.message") + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && raw_value !== (raw_value = /*data*/
      (ctx2[0].message || "$error.message") + ""))
        html_tag.p(raw_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_if_block_1$G(ctx) {
  let div;
  let switch_instance;
  let updating_disabled;
  let current;
  function switch_instance_disabled_binding(value) {
    ctx[4](value);
  }
  var switch_value = (
    /*data*/
    ctx[0].component
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = { error: (
      /*data*/
      ctx2[0]
    ) };
    if (
      /*disabled*/
      ctx2[1] !== void 0
    ) {
      switch_instance_props.disabled = /*disabled*/
      ctx2[1];
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    binding_callbacks.push(() => bind$1(switch_instance, "disabled", switch_instance_disabled_binding));
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "class", "component");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && switch_value !== (switch_value = /*data*/
      ctx2[0].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          binding_callbacks.push(() => bind$1(switch_instance, "disabled", switch_instance_disabled_binding));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*data*/
        1)
          switch_instance_changes.error = /*data*/
          ctx2[0];
        if (!updating_disabled && dirty & /*disabled*/
        2) {
          updating_disabled = true;
          switch_instance_changes.disabled = /*disabled*/
          ctx2[1];
          add_flush_callback(() => updating_disabled = false);
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_each_block$U(ctx) {
  let button_1;
  let t0_value = (
    /*button*/
    ctx[7].caption + ""
  );
  let t0;
  let t1;
  let button_1_disabled_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[5](
        /*button*/
        ctx[7]
      )
    );
  }
  return {
    c() {
      button_1 = element("button");
      t0 = text(t0_value);
      t1 = space();
      button_1.disabled = button_1_disabled_value = /*disabled*/
      ctx[1] && /*button*/
      ctx[7].suggested;
      toggle_class(
        button_1,
        "suggested",
        /*button*/
        ctx[7].suggested
      );
    },
    m(target, anchor) {
      insert(target, button_1, anchor);
      append(button_1, t0);
      append(button_1, t1);
      if (!mounted) {
        dispose = listen(button_1, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*data*/
      1 && t0_value !== (t0_value = /*button*/
      ctx[7].caption + ""))
        set_data(t0, t0_value);
      if (dirty & /*disabled, data*/
      3 && button_1_disabled_value !== (button_1_disabled_value = /*disabled*/
      ctx[1] && /*button*/
      ctx[7].suggested)) {
        button_1.disabled = button_1_disabled_value;
      }
      if (dirty & /*data*/
      1) {
        toggle_class(
          button_1,
          "suggested",
          /*button*/
          ctx[7].suggested
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button_1);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$5y(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*data*/
    ctx[0] && create_if_block$22(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*data*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*data*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$22(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$53($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let data2 = null;
  let disabled = false;
  onMount(() => {
    $$invalidate(0, data2 = runtime.process.args[0]);
  });
  function e2(cb) {
    cb();
    closeThis();
  }
  function closeThis() {
    focusedPid.set(runtime.process.parentPid);
    runtime.process.handler.kill(runtime.process.pid, true);
  }
  function switch_instance_disabled_binding(value) {
    disabled = value;
    $$invalidate(1, disabled);
  }
  const click_handler = (button) => e2(button.action);
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [data2, disabled, e2, runtime, switch_instance_disabled_binding, click_handler];
}
let App$t = class App2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$53, create_fragment$5y, safe_not_equal, { runtime: 3 });
  }
};
const ErrorDialog = {
  metadata: {
    name: "Error",
    description: "How are you seeing this?",
    author: "ArcOS Team",
    version: "1.0.0",
    icon: WarningIcon,
    appGroup: "internal",
    hidden: true
  },
  runtime: Runtime$l,
  content: App$t,
  id: "ErrorDialog",
  size: { w: NaN, h: NaN },
  minSize: { w: NaN, h: 120 },
  maxSize: { w: 700, h: NaN },
  pos: { x: 60, y: 60 },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: {
    minimize: false,
    maximize: false,
    close: false
  }
};
const v646973636F72640A = "" + new URL("646973636F72640A-8f4d3150.mp3", import.meta.url).href;
const dialogError = "" + new URL("Error-35b4aff9.wav", import.meta.url).href;
const dialogInfo = "" + new URL("Info-ccd624fe.wav", import.meta.url).href;
const notification = "" + new URL("Notification-2d6e0e95.wav", import.meta.url).href;
const dialogWarning = "" + new URL("Warning-ab00a839.wav", import.meta.url).href;
const click = "" + new URL("click-b83fa858.wav", import.meta.url).href;
const systemLogoff = "" + new URL("logoff-62e8a4e4.wav", import.meta.url).href;
const systemLogon = "" + new URL("logon-aa2b9d46.wav", import.meta.url).href;
const mwomp = "" + new URL("mwomp-71d2eb2a.mp3", import.meta.url).href;
const ArcSounds = {
  "arcos.dialog.error": dialogError,
  "arcos.dialog.warning": dialogWarning,
  "arcos.dialog.info": dialogInfo,
  "arcos.notification": notification,
  "arcos.system.logon": systemLogon,
  "arcos.system.logoff": systemLogoff,
  "arcos.click": click,
  "arcos.mwomp": mwomp,
  "646973636F72640A": v646973636F72640A
};
class SoundBus {
  constructor(store) {
    __publicField(this, "store", {});
    __publicField(this, "_bus", {});
    if (!store) {
      Log("soundbus", `Can't create SoundBus without valid store.`, LogLevel.error);
      return;
    }
    this.store = store;
  }
  playSound(id, volume = 1) {
    if (!this.store[id])
      return false;
    Log("soundbus", `Playing sound ${id} from store`);
    if (SafeMode.get())
      return;
    const element2 = document.createElement("audio");
    element2.src = this.store[id];
    element2.volume = volume;
    element2.autoplay = true;
    if (!this._bus[id])
      this._bus[id] = [];
    this._bus[id].push(element2);
    element2.onended = () => setTimeout(() => {
      delete this._bus[id];
    }, 1e3);
    return true;
  }
  stopSound(id) {
    Log("soundbus", `Stopping ${id}`);
    if (!this._bus[id])
      return false;
    const bus = this._bus[id];
    for (const player of bus) {
      player.src = null;
      player.currentTime = -1;
      player.pause();
    }
    return true;
  }
  getStore() {
    return Object.entries(this.store);
  }
  loadExternal(source, play2 = false) {
    const uuid = `${Math.floor(Math.random() * 1e9)}`;
    this.store[uuid] = source;
    if (play2)
      this.playSound(uuid);
  }
}
const ArcSoundBus = new SoundBus(ArcSounds);
async function createErrorDialog(options2, parentPid, overlay) {
  class DialogProcess extends Process {
    constructor(handler, pid, name, app2, args = []) {
      super(handler, pid, name, app2, args);
      this.setParentPid(pid);
    }
  }
  const app = getAppById(null, { ...ErrorDialog, isOverlay: overlay });
  const process = await ProcessStack.spawn({
    proc: DialogProcess,
    parentPid,
    name: `error#${parentPid}`,
    args: [options2],
    app
  });
  if (typeof process == "string")
    return null;
  if (options2.sound)
    ArcSoundBus.playSound(options2.sound);
  return process.pid;
}
async function GetConfirmation(options2, parentPid, overlay) {
  return new Promise((resolve) => {
    createErrorDialog(
      {
        ...options2,
        buttons: [
          {
            caption: "No",
            action() {
              resolve(false);
            }
          },
          {
            caption: "Yes",
            action() {
              resolve(true);
            },
            suggested: true
          }
        ]
      },
      parentPid,
      overlay
    );
  });
}
function create_fragment$5x(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.innerHTML = `The Load Condition is a condition that must be met for the application to be loaded into the
  Library.<br/><br/>
  If the Load Condition doesn&#39;t match, the load process is aborted, and the Library is unaffected.`;
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
class LoadCondition extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$5x, safe_not_equal, {});
  }
}
function create_fragment$5w(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.innerHTML = `The Single Instance property specifies if you can open only one instance of any given application
  at once, or multiple.<br/><br/>
  If Single Instance is enabled, and a second instance is spawned, it will stop the spawn and focus the
  first instance instead.`;
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
class SingleInstance extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$5w, safe_not_equal, {});
  }
}
class AppInfoRuntime extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "_targetApp", Store$1());
    __publicField(this, "_targetId", Store$1());
    function stop2(arg2) {
      process.handler.kill(process.pid, true);
      const suffix = arg2 ? ` App "${arg2}" could not be found.` : "";
      sendNotification({
        title: "Can't open App Info",
        message: `App Info was opened without a valid App ID to pull the information from.${suffix}`,
        image: AppInfoIcon
        /* timeout: 3000, */
      });
    }
    const arg = process.args[0];
    if (!arg || typeof arg !== "string") {
      stop2();
      this.Log(
        "Not opening AppInfo without an ID to pull data from",
        "constructor",
        LogLevel.error
      );
      return;
    }
    const targetApp = getAppById(arg);
    if (!targetApp) {
      stop2(arg);
      this.Log(
        "Not opening AppInfo without a valid app-ID to pull data from.",
        "constructor",
        LogLevel.error
      );
      return;
    }
    this.setWindowTitle(`Information about ${targetApp.metadata.name}`);
    this._targetId.set(arg);
    this._targetApp.set(targetApp);
  }
  loadConditionDialog() {
    createErrorDialog(
      {
        title: "Load Condition",
        component: LoadCondition,
        buttons: [{ caption: "Understood", action() {
        }, suggested: true }],
        image: AppInfoIcon,
        sound: "arcos.dialog.info"
      },
      this.process.pid,
      true
    );
  }
  singleInstanceDialog() {
    createErrorDialog(
      {
        title: "Single Instance",
        component: SingleInstance,
        buttons: [{ caption: "Understood", action() {
        }, suggested: true }],
        image: AppInfoIcon,
        sound: "arcos.dialog.info"
      },
      this.process.pid,
      true
    );
  }
}
function create_default_slot_1$l(ctx) {
  let p2;
  let t0;
  let t1;
  let button0;
  let t2;
  let t3;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      p2 = element("p");
      t0 = text(
        /*id*/
        ctx[0]
      );
      t1 = space();
      button0 = element("button");
      t2 = text("Kill all");
      t3 = space();
      button1 = element("button");
      button1.textContent = "Close";
      attr(p2, "class", "id");
      button0.disabled = /*disabled*/
      ctx[1];
      attr(button1, "class", "suggested");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      append(p2, t0);
      insert(target, t1, anchor);
      insert(target, button0, anchor);
      append(button0, t2);
      insert(target, t3, anchor);
      insert(target, button1, anchor);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*killAll*/
            ctx[2]
          ),
          listen(
            button1,
            "click",
            /*close*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*id*/
      1)
        set_data(
          t0,
          /*id*/
          ctx2[0]
        );
      if (dirty & /*disabled*/
      2) {
        button0.disabled = /*disabled*/
        ctx2[1];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(p2);
        detach(t1);
        detach(button0);
        detach(t3);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$C(ctx) {
  let inforow;
  let current;
  inforow = new InfoRow({
    props: {
      $$slots: { default: [create_default_slot_1$l] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(inforow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inforow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inforow_changes = {};
      if (dirty & /*$$scope, disabled, id*/
      35) {
        inforow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inforow.$set(inforow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inforow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inforow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inforow, detaching);
    }
  };
}
function create_fragment$5v(ctx) {
  let infoblock;
  let current;
  infoblock = new InfoBlock({
    props: {
      className: "actions",
      $$slots: { default: [create_default_slot$C] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(infoblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(infoblock, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const infoblock_changes = {};
      if (dirty & /*$$scope, disabled, id*/
      35) {
        infoblock_changes.$$scope = { dirty, ctx: ctx2 };
      }
      infoblock.$set(infoblock_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(infoblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(infoblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(infoblock, detaching);
    }
  };
}
function instance$52($$self, $$props, $$invalidate) {
  let { id } = $$props;
  let { runtime } = $$props;
  let disabled = false;
  UserDataStore.subscribe(() => $$invalidate(1, disabled = isDisabled(id)));
  function killAll() {
    killAllAppInstances(id);
  }
  function close() {
    runtime.process.handler.kill(runtime.process.pid, true);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("runtime" in $$props2)
      $$invalidate(4, runtime = $$props2.runtime);
  };
  return [id, disabled, killAll, close, runtime];
}
let Actions$7 = class Actions extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$52, create_fragment$5v, safe_not_equal, { id: 0, runtime: 4 });
  }
};
async function disableApp(id) {
  const userdata = UserDataStore.get();
  if (userdata.disabledApps.includes(id))
    return false;
  const elevated = await GetUserElevation(ChangeDisabledStateData(id), ProcessStack);
  if (!elevated)
    return false;
  await killAllAppInstances(id, true);
  userdata.disabledApps.push(id);
  UserDataStore.set(userdata);
  return true;
}
async function enableApp(id) {
  const userdata = UserDataStore.get();
  const index = userdata.disabledApps.indexOf(id);
  if (!userdata.disabledApps.includes(id))
    return false;
  const elevated = await GetUserElevation(ChangeDisabledStateData(id), ProcessStack);
  if (!elevated)
    return false;
  userdata.disabledApps.splice(index, 1);
  UserDataStore.set(userdata);
  return true;
}
function create_if_block$21(ctx) {
  let img;
  let img_src_value;
  let img_title_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = WarningIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(img, "class", "disabled");
      attr(img, "title", img_title_value = /*target*/
      ctx[0].metadata.name + " is disabled!");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*target*/
      1 && img_title_value !== (img_title_value = /*target*/
      ctx2[0].metadata.name + " is disabled!")) {
        attr(img, "title", img_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_fragment$5u(ctx) {
  let div3;
  let div1;
  let img;
  let img_src_value;
  let t0;
  let div0;
  let p0;
  let span;
  let t1_value = (
    /*target*/
    ctx[0].metadata.name + ""
  );
  let t1;
  let t2;
  let t3;
  let p1;
  let t4_value = (
    /*target*/
    ctx[0].metadata.author + ""
  );
  let t4;
  let t5;
  let div2;
  let button0;
  let t6_value = (
    /*disabled*/
    ctx[1] ? "Enable" : "Disable"
  );
  let t6;
  let t7;
  let button1;
  let t8;
  let mounted;
  let dispose;
  let if_block = (
    /*disabled*/
    ctx[1] && create_if_block$21(ctx)
  );
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      img = element("img");
      t0 = space();
      div0 = element("div");
      p0 = element("p");
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      p1 = element("p");
      t4 = text(t4_value);
      t5 = space();
      div2 = element("div");
      button0 = element("button");
      t6 = text(t6_value);
      t7 = space();
      button1 = element("button");
      t8 = text("launch");
      if (!src_url_equal(img.src, img_src_value = /*target*/
      ctx[0].metadata.icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(p0, "class", "name");
      attr(p1, "class", "author");
      attr(div0, "class", "base-info");
      attr(div1, "class", "left");
      attr(button0, "class", "disable");
      toggle_class(
        button0,
        "disabled",
        /*disabled*/
        ctx[1]
      );
      attr(button1, "class", "material-icons-round");
      button1.disabled = /*disabled*/
      ctx[1];
      attr(div2, "class", "right");
      attr(div3, "class", "header");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, img);
      append(div1, t0);
      append(div1, div0);
      append(div0, p0);
      append(p0, span);
      append(span, t1);
      append(p0, t2);
      if (if_block)
        if_block.m(p0, null);
      append(div0, t3);
      append(div0, p1);
      append(p1, t4);
      append(div3, t5);
      append(div3, div2);
      append(div2, button0);
      append(button0, t6);
      append(div2, t7);
      append(div2, button1);
      append(button1, t8);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*toggleDisable*/
            ctx[3]
          ),
          listen(
            button1,
            "click",
            /*launch*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*target*/
      1 && !src_url_equal(img.src, img_src_value = /*target*/
      ctx2[0].metadata.icon)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*target*/
      1 && t1_value !== (t1_value = /*target*/
      ctx2[0].metadata.name + ""))
        set_data(t1, t1_value);
      if (
        /*disabled*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$21(ctx2);
          if_block.c();
          if_block.m(p0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*target*/
      1 && t4_value !== (t4_value = /*target*/
      ctx2[0].metadata.author + ""))
        set_data(t4, t4_value);
      if (dirty & /*disabled*/
      2 && t6_value !== (t6_value = /*disabled*/
      ctx2[1] ? "Enable" : "Disable"))
        set_data(t6, t6_value);
      if (dirty & /*disabled*/
      2) {
        toggle_class(
          button0,
          "disabled",
          /*disabled*/
          ctx2[1]
        );
      }
      if (dirty & /*disabled*/
      2) {
        button1.disabled = /*disabled*/
        ctx2[1];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$51($$self, $$props, $$invalidate) {
  let { target } = $$props;
  let { id } = $$props;
  let disabled = false;
  UserDataStore.subscribe(() => $$invalidate(1, disabled = isDisabled(id)));
  function launch() {
    spawnApp(id);
  }
  function toggleDisable() {
    if (isDisabled(id))
      enableApp(id);
    else
      disableApp(id);
  }
  $$self.$$set = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
    if ("id" in $$props2)
      $$invalidate(4, id = $$props2.id);
  };
  return [target, disabled, launch, toggleDisable, id];
}
let Header$c = class Header extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$51, create_fragment$5u, safe_not_equal, { target: 0, id: 4 });
  }
};
function create_if_block$20(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "help";
      attr(button, "class", "help material-icons-round");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*help*/
            ctx[1]
          ))
            ctx[1].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$5t(ctx) {
  let div;
  let p0;
  let t0;
  let t1;
  let t2;
  let p1;
  let div_class_value;
  let current;
  let if_block = (
    /*help*/
    ctx[1] && create_if_block$20(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      div = element("div");
      p0 = element("p");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      p1 = element("p");
      if (default_slot)
        default_slot.c();
      attr(p0, "class", "title");
      attr(p1, "class", "value");
      attr(div, "class", div_class_value = "segment " + /*className*/
      ctx[3]);
      toggle_class(
        div,
        "right",
        /*right*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p0);
      append(p0, t0);
      append(p0, t1);
      if (if_block)
        if_block.m(p0, null);
      append(div, t2);
      append(div, p1);
      if (default_slot) {
        default_slot.m(p1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*title*/
      1)
        set_data(
          t0,
          /*title*/
          ctx2[0]
        );
      if (
        /*help*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$20(ctx2);
          if_block.c();
          if_block.m(p0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*className*/
      8 && div_class_value !== (div_class_value = "segment " + /*className*/
      ctx2[3])) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*className, right*/
      12) {
        toggle_class(
          div,
          "right",
          /*right*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$50($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  let { help = null } = $$props;
  let { right = false } = $$props;
  let { className = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("help" in $$props2)
      $$invalidate(1, help = $$props2.help);
    if ("right" in $$props2)
      $$invalidate(2, right = $$props2.right);
    if ("className" in $$props2)
      $$invalidate(3, className = $$props2.className);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [title, help, right, className, $$scope, slots];
}
class Segment extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$50, create_fragment$5t, safe_not_equal, {
      title: 0,
      help: 1,
      right: 2,
      className: 3
    });
  }
}
function create_default_slot_12$1(ctx) {
  let t0_value = (
    /*target*/
    (ctx[0].size.w || "FIT") + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*target*/
    (ctx[0].size.h || "FIT") + ""
  );
  let t2;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text("x");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*target*/
      1 && t0_value !== (t0_value = /*target*/
      (ctx2[0].size.w || "FIT") + ""))
        set_data(t0, t0_value);
      if (dirty & /*target*/
      1 && t2_value !== (t2_value = /*target*/
      (ctx2[0].size.h || "FIT") + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_default_slot_11$2(ctx) {
  let t0_value = (
    /*target*/
    (ctx[0].minSize.w || "FIT") + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*target*/
    (ctx[0].minSize.h || "FIT") + ""
  );
  let t2;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text("x");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*target*/
      1 && t0_value !== (t0_value = /*target*/
      (ctx2[0].minSize.w || "FIT") + ""))
        set_data(t0, t0_value);
      if (dirty & /*target*/
      1 && t2_value !== (t2_value = /*target*/
      (ctx2[0].minSize.h || "FIT") + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_default_slot_10$2(ctx) {
  let t0_value = (
    /*target*/
    (ctx[0].maxSize.w || "FIT") + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*target*/
    (ctx[0].maxSize.h || "FIT") + ""
  );
  let t2;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text("x");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*target*/
      1 && t0_value !== (t0_value = /*target*/
      (ctx2[0].maxSize.w || "FIT") + ""))
        set_data(t0, t0_value);
      if (dirty & /*target*/
      1 && t2_value !== (t2_value = /*target*/
      (ctx2[0].maxSize.h || "FIT") + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_default_slot_9$3(ctx) {
  let div;
  let button0;
  let t0;
  let button0_disabled_value;
  let t1;
  let button1;
  let t2;
  let button1_disabled_value;
  let t3;
  let button2;
  let t4;
  let button2_disabled_value;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text("minimize");
      t1 = space();
      button1 = element("button");
      t2 = text("crop_square");
      t3 = space();
      button2 = element("button");
      t4 = text("close");
      attr(button0, "class", "min material-icons-round titlebar-control reset");
      button0.disabled = button0_disabled_value = !/*target*/
      ctx[0].controls.minimize;
      attr(button1, "class", "max material-icons-round titlebar-control reset");
      button1.disabled = button1_disabled_value = !/*target*/
      ctx[0].controls.maximize;
      attr(button2, "class", "close material-icons-round titlebar-control reset");
      button2.disabled = button2_disabled_value = !/*target*/
      ctx[0].controls.close;
      attr(div, "class", "controls");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      append(div, t3);
      append(div, button2);
      append(button2, t4);
    },
    p(ctx2, dirty) {
      if (dirty & /*target*/
      1 && button0_disabled_value !== (button0_disabled_value = !/*target*/
      ctx2[0].controls.minimize)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*target*/
      1 && button1_disabled_value !== (button1_disabled_value = !/*target*/
      ctx2[0].controls.maximize)) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*target*/
      1 && button2_disabled_value !== (button2_disabled_value = !/*target*/
      ctx2[0].controls.close)) {
        button2.disabled = button2_disabled_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_default_slot_8$4(ctx) {
  let segment0;
  let t0;
  let segment1;
  let t1;
  let segment2;
  let t2;
  let segment3;
  let current;
  segment0 = new Segment({
    props: {
      title: "Size",
      $$slots: { default: [create_default_slot_12$1] },
      $$scope: { ctx }
    }
  });
  segment1 = new Segment({
    props: {
      title: "Minimal Size",
      $$slots: { default: [create_default_slot_11$2] },
      $$scope: { ctx }
    }
  });
  segment2 = new Segment({
    props: {
      title: "Maximal Size",
      $$slots: { default: [create_default_slot_10$2] },
      $$scope: { ctx }
    }
  });
  segment3 = new Segment({
    props: {
      title: "Controls",
      right: true,
      $$slots: { default: [create_default_slot_9$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(segment0.$$.fragment);
      t0 = space();
      create_component(segment1.$$.fragment);
      t1 = space();
      create_component(segment2.$$.fragment);
      t2 = space();
      create_component(segment3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(segment0, target, anchor);
      insert(target, t0, anchor);
      mount_component(segment1, target, anchor);
      insert(target, t1, anchor);
      mount_component(segment2, target, anchor);
      insert(target, t2, anchor);
      mount_component(segment3, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const segment0_changes = {};
      if (dirty & /*$$scope, target*/
      17) {
        segment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment0.$set(segment0_changes);
      const segment1_changes = {};
      if (dirty & /*$$scope, target*/
      17) {
        segment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment1.$set(segment1_changes);
      const segment2_changes = {};
      if (dirty & /*$$scope, target*/
      17) {
        segment2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment2.$set(segment2_changes);
      const segment3_changes = {};
      if (dirty & /*$$scope, target*/
      17) {
        segment3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment3.$set(segment3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(segment0.$$.fragment, local);
      transition_in(segment1.$$.fragment, local);
      transition_in(segment2.$$.fragment, local);
      transition_in(segment3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(segment0.$$.fragment, local);
      transition_out(segment1.$$.fragment, local);
      transition_out(segment2.$$.fragment, local);
      transition_out(segment3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(segment0, detaching);
      destroy_component(segment1, detaching);
      destroy_component(segment2, detaching);
      destroy_component(segment3, detaching);
    }
  };
}
function create_default_slot_7$4(ctx) {
  let t0_value = (
    /*target*/
    ctx[0].pos.x + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*target*/
    ctx[0].pos.y + ""
  );
  let t2;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(", ");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*target*/
      1 && t0_value !== (t0_value = /*target*/
      ctx2[0].pos.x + ""))
        set_data(t0, t0_value);
      if (dirty & /*target*/
      1 && t2_value !== (t2_value = /*target*/
      ctx2[0].pos.y + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_default_slot_6$5(ctx) {
  let t_value = (
    /*target*/
    ctx[0].sideload ? "Sideloaded" : "Built-in"
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*target*/
      1 && t_value !== (t_value = /*target*/
      ctx2[0].sideload ? "Sideloaded" : "Built-in"))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_5$5(ctx) {
  let t_value = (
    /*target*/
    ctx[0].metadata.core ? "Yes" : "No"
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*target*/
      1 && t_value !== (t_value = /*target*/
      ctx2[0].metadata.core ? "Yes" : "No"))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_4$6(ctx) {
  let t_value = (
    /*target*/
    ctx[0].singleInstance ? "Yes" : "No"
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*target*/
      1 && t_value !== (t_value = /*target*/
      ctx2[0].singleInstance ? "Yes" : "No"))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_3$d(ctx) {
  let segment0;
  let t0;
  let segment1;
  let t1;
  let segment2;
  let t2;
  let segment3;
  let current;
  segment0 = new Segment({
    props: {
      title: "Initial Position",
      $$slots: { default: [create_default_slot_7$4] },
      $$scope: { ctx }
    }
  });
  segment1 = new Segment({
    props: {
      title: "Type",
      $$slots: { default: [create_default_slot_6$5] },
      $$scope: { ctx }
    }
  });
  segment2 = new Segment({
    props: {
      title: "Core",
      $$slots: { default: [create_default_slot_5$5] },
      $$scope: { ctx }
    }
  });
  segment3 = new Segment({
    props: {
      title: "Single Instance",
      help: (
        /*singleInstanceHelp*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_4$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(segment0.$$.fragment);
      t0 = space();
      create_component(segment1.$$.fragment);
      t1 = space();
      create_component(segment2.$$.fragment);
      t2 = space();
      create_component(segment3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(segment0, target, anchor);
      insert(target, t0, anchor);
      mount_component(segment1, target, anchor);
      insert(target, t1, anchor);
      mount_component(segment2, target, anchor);
      insert(target, t2, anchor);
      mount_component(segment3, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const segment0_changes = {};
      if (dirty & /*$$scope, target*/
      17) {
        segment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment0.$set(segment0_changes);
      const segment1_changes = {};
      if (dirty & /*$$scope, target*/
      17) {
        segment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment1.$set(segment1_changes);
      const segment2_changes = {};
      if (dirty & /*$$scope, target*/
      17) {
        segment2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment2.$set(segment2_changes);
      const segment3_changes = {};
      if (dirty & /*$$scope, target*/
      17) {
        segment3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment3.$set(segment3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(segment0.$$.fragment, local);
      transition_in(segment1.$$.fragment, local);
      transition_in(segment2.$$.fragment, local);
      transition_in(segment3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(segment0.$$.fragment, local);
      transition_out(segment1.$$.fragment, local);
      transition_out(segment2.$$.fragment, local);
      transition_out(segment3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(segment0, detaching);
      destroy_component(segment1, detaching);
      destroy_component(segment2, detaching);
      destroy_component(segment3, detaching);
    }
  };
}
function create_if_block$1$(ctx) {
  let inforow;
  let current;
  inforow = new InfoRow({
    props: {
      $$slots: { default: [create_default_slot_1$k] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(inforow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inforow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inforow_changes = {};
      if (dirty & /*$$scope, target*/
      17) {
        inforow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inforow.$set(inforow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inforow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inforow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inforow, detaching);
    }
  };
}
function create_default_slot_2$i(ctx) {
  let code;
  let t_value = (
    /*target*/
    ctx[0].loadCondition + ""
  );
  let t2;
  return {
    c() {
      code = element("code");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, code, anchor);
      append(code, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*target*/
      1 && t_value !== (t_value = /*target*/
      ctx2[0].loadCondition + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(code);
      }
    }
  };
}
function create_default_slot_1$k(ctx) {
  let segment;
  let current;
  segment = new Segment({
    props: {
      title: "Load Condition",
      help: (
        /*loadConditionHelp*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_2$i] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(segment.$$.fragment);
    },
    m(target, anchor) {
      mount_component(segment, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const segment_changes = {};
      if (dirty & /*$$scope, target*/
      17) {
        segment_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment.$set(segment_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(segment.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(segment.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(segment, detaching);
    }
  };
}
function create_default_slot$B(ctx) {
  let inforow0;
  let t0;
  let inforow1;
  let t1;
  let if_block_anchor;
  let current;
  inforow0 = new InfoRow({
    props: {
      $$slots: { default: [create_default_slot_8$4] },
      $$scope: { ctx }
    }
  });
  inforow1 = new InfoRow({
    props: {
      $$slots: { default: [create_default_slot_3$d] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*target*/
    ctx[0].loadCondition && create_if_block$1$(ctx)
  );
  return {
    c() {
      create_component(inforow0.$$.fragment);
      t0 = space();
      create_component(inforow1.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(inforow0, target, anchor);
      insert(target, t0, anchor);
      mount_component(inforow1, target, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inforow0_changes = {};
      if (dirty & /*$$scope, target*/
      17) {
        inforow0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inforow0.$set(inforow0_changes);
      const inforow1_changes = {};
      if (dirty & /*$$scope, target*/
      17) {
        inforow1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inforow1.$set(inforow1_changes);
      if (
        /*target*/
        ctx2[0].loadCondition
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*target*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1$(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(inforow0.$$.fragment, local);
      transition_in(inforow1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(inforow0.$$.fragment, local);
      transition_out(inforow1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block_anchor);
      }
      destroy_component(inforow0, detaching);
      destroy_component(inforow1, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$5s(ctx) {
  let infoblock;
  let current;
  infoblock = new InfoBlock({
    props: {
      $$slots: { default: [create_default_slot$B] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(infoblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(infoblock, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const infoblock_changes = {};
      if (dirty & /*$$scope, target*/
      17) {
        infoblock_changes.$$scope = { dirty, ctx: ctx2 };
      }
      infoblock.$set(infoblock_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(infoblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(infoblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(infoblock, detaching);
    }
  };
}
function instance$4$($$self, $$props, $$invalidate) {
  let { target } = $$props;
  let { runtime } = $$props;
  function singleInstanceHelp() {
    runtime.singleInstanceDialog();
  }
  function loadConditionHelp() {
    runtime.loadConditionDialog();
  }
  $$self.$$set = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [target, singleInstanceHelp, loadConditionHelp, runtime];
}
let IndepthInfo$1 = class IndepthInfo extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4$, create_fragment$5s, safe_not_equal, { target: 0, runtime: 3 });
  }
};
function create_default_slot_3$c(ctx) {
  let t0;
  let t1;
  return {
    c() {
      t0 = text(
        /*count*/
        ctx[1]
      );
      t1 = text(" instance(s)");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*count*/
      2)
        set_data(
          t0,
          /*count*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_default_slot_2$h(ctx) {
  let t_value = (
    /*pid*/
    (ctx[0] < 0 ? "None" : (
      /*pid*/
      ctx[0]
    )) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*pid*/
      1 && t_value !== (t_value = /*pid*/
      (ctx2[0] < 0 ? "None" : (
        /*pid*/
        ctx2[0]
      )) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$j(ctx) {
  let segment0;
  let t0;
  let segment1;
  let t1;
  let button;
  let current;
  let mounted;
  let dispose;
  segment0 = new Segment({
    props: {
      title: "Processes",
      $$slots: { default: [create_default_slot_3$c] },
      $$scope: { ctx }
    }
  });
  segment1 = new Segment({
    props: {
      title: "First PID",
      $$slots: { default: [create_default_slot_2$h] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(segment0.$$.fragment);
      t0 = space();
      create_component(segment1.$$.fragment);
      t1 = space();
      button = element("button");
      button.textContent = "Processes";
      attr(button, "class", "action");
    },
    m(target, anchor) {
      mount_component(segment0, target, anchor);
      insert(target, t0, anchor);
      mount_component(segment1, target, anchor);
      insert(target, t1, anchor);
      insert(target, button, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*procMan*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const segment0_changes = {};
      if (dirty & /*$$scope, count*/
      34) {
        segment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment0.$set(segment0_changes);
      const segment1_changes = {};
      if (dirty & /*$$scope, pid*/
      33) {
        segment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment1.$set(segment1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(segment0.$$.fragment, local);
      transition_in(segment1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(segment0.$$.fragment, local);
      transition_out(segment1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(button);
      }
      destroy_component(segment0, detaching);
      destroy_component(segment1, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$A(ctx) {
  let inforow;
  let current;
  inforow = new InfoRow({
    props: {
      $$slots: { default: [create_default_slot_1$j] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(inforow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inforow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inforow_changes = {};
      if (dirty & /*$$scope, pid, count*/
      35) {
        inforow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inforow.$set(inforow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inforow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inforow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inforow, detaching);
    }
  };
}
function create_fragment$5r(ctx) {
  let infoblock;
  let current;
  infoblock = new InfoBlock({
    props: {
      $$slots: { default: [create_default_slot$A] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(infoblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(infoblock, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const infoblock_changes = {};
      if (dirty & /*$$scope, pid, count*/
      35) {
        infoblock_changes.$$scope = { dirty, ctx: ctx2 };
      }
      infoblock.$set(infoblock_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(infoblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(infoblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(infoblock, detaching);
    }
  };
}
function instance$4_($$self, $$props, $$invalidate) {
  let { id } = $$props;
  let pid = -1;
  let count = 0;
  function update2() {
    const pids = ProcessStack.getAppPids(id);
    $$invalidate(1, count = pids.length);
    $$invalidate(0, pid = pids.length ? pids[0] : -1);
  }
  function procMan() {
    spawnApp("ProcessManager");
  }
  ProcessStack.processes.subscribe(update2);
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(3, id = $$props2.id);
  };
  return [pid, count, procMan, id];
}
let ProcessInfo$1 = class ProcessInfo extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4_, create_fragment$5r, safe_not_equal, { id: 3 });
  }
};
const main$x = "";
function create_if_block$1_(ctx) {
  let header2;
  let t0;
  let indepthinfo;
  let t1;
  let processinfo;
  let t2;
  let actions;
  let current;
  header2 = new Header$c({
    props: {
      target: (
        /*$target*/
        ctx[2]
      ),
      id: (
        /*$id*/
        ctx[1]
      )
    }
  });
  indepthinfo = new IndepthInfo$1({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      target: (
        /*$target*/
        ctx[2]
      )
    }
  });
  processinfo = new ProcessInfo$1({ props: { id: (
    /*$id*/
    ctx[1]
  ) } });
  actions = new Actions$7({
    props: {
      id: (
        /*$id*/
        ctx[1]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(header2.$$.fragment);
      t0 = space();
      create_component(indepthinfo.$$.fragment);
      t1 = space();
      create_component(processinfo.$$.fragment);
      t2 = space();
      create_component(actions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(header2, target, anchor);
      insert(target, t0, anchor);
      mount_component(indepthinfo, target, anchor);
      insert(target, t1, anchor);
      mount_component(processinfo, target, anchor);
      insert(target, t2, anchor);
      mount_component(actions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty & /*$target*/
      4)
        header_changes.target = /*$target*/
        ctx2[2];
      if (dirty & /*$id*/
      2)
        header_changes.id = /*$id*/
        ctx2[1];
      header2.$set(header_changes);
      const indepthinfo_changes = {};
      if (dirty & /*runtime*/
      1)
        indepthinfo_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*$target*/
      4)
        indepthinfo_changes.target = /*$target*/
        ctx2[2];
      indepthinfo.$set(indepthinfo_changes);
      const processinfo_changes = {};
      if (dirty & /*$id*/
      2)
        processinfo_changes.id = /*$id*/
        ctx2[1];
      processinfo.$set(processinfo_changes);
      const actions_changes = {};
      if (dirty & /*$id*/
      2)
        actions_changes.id = /*$id*/
        ctx2[1];
      if (dirty & /*runtime*/
      1)
        actions_changes.runtime = /*runtime*/
        ctx2[0];
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(indepthinfo.$$.fragment, local);
      transition_in(processinfo.$$.fragment, local);
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(indepthinfo.$$.fragment, local);
      transition_out(processinfo.$$.fragment, local);
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(header2, detaching);
      destroy_component(indepthinfo, detaching);
      destroy_component(processinfo, detaching);
      destroy_component(actions, detaching);
    }
  };
}
function create_fragment$5q(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$id*/
    ctx[1] && /*$target*/
    ctx[2] && create_if_block$1_(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$id*/
        ctx2[1] && /*$target*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$id, $target*/
          6) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1_(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$4Z($$self, $$props, $$invalidate) {
  let $id;
  let $target;
  let { runtime } = $$props;
  const { _targetApp: target, _targetId: id } = runtime;
  component_subscribe($$self, target, (value) => $$invalidate(2, $target = value));
  component_subscribe($$self, id, (value) => $$invalidate(1, $id = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, $id, $target, target, id];
}
let App$s = class App3 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4Z, create_fragment$5q, safe_not_equal, { runtime: 0 });
  }
};
const AppInfo = {
  metadata: {
    name: "App Info",
    description: "View information about an app",
    author: "The ArcOS Team",
    version: "2.0.0",
    appGroup: "internal",
    icon: AppInfoIcon,
    hidden: true
  },
  runtime: AppInfoRuntime,
  content: App$s,
  id: "AppInfo",
  size: { w: 500, h: NaN },
  minSize: { w: 500, h: 450 },
  maxSize: { w: 500, h: 460 },
  pos: { x: 120, y: 60 },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: {
    minimize: true,
    maximize: false,
    close: true
  },
  glass: true
};
function isArray$1(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
const INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString2(value) {
  return value == null ? "" : baseToString(value);
}
function isString$1(value) {
  return typeof value === "string";
}
function isNumber$1(value) {
  return typeof value === "number";
}
function isBoolean$1(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject$1(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject$1(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key2) => `Invalid value for key ${key2}`;
const PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
const INVALID_KEY_WEIGHT_VALUE = (key2) => `Property 'weight' in key '${key2}' must be a positive integer`;
const hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key2) => {
      let obj = createKey(key2);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key2) => {
      key2.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(key2) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString$1(key2) || isArray$1(key2)) {
    src = key2;
    path = createKeyPath(key2);
    id = createKeyId(key2);
  } else {
    if (!hasOwn.call(key2, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key2.name;
    src = name;
    if (hasOwn.call(key2, "weight")) {
      weight = key2.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key2.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key2) {
  return isArray$1(key2) ? key2 : key2.split(".");
}
function createKeyId(key2) {
  return isArray$1(key2) ? key2.join(".") : key2;
}
function get(obj, path) {
  let list2 = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list2.push(obj2);
    } else {
      let key2 = path2[index];
      const value = obj2[key2];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString$1(value) || isNumber$1(value) || isBoolean$1(value))) {
        list2.push(toString2(value));
      } else if (isArray$1(value)) {
        arr = true;
        for (let i2 = 0, len = value.length; i2 < len; i2 += 1) {
          deepGet(value[i2], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString$1(path) ? path.split(".") : path, 0);
  return arr ? list2 : list2[0];
}
const MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
const BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a2, b2) => a2.score === b2.score ? a2.idx < b2.idx ? -1 : 1 : a2.score < b2.score ? -1 : 1
};
const FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
const AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config$1 = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
const SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m3 = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n2 = parseFloat(Math.round(norm2 * m3) / m3);
      cache.set(numTokens, n2);
      return n2;
    },
    clear() {
      cache.clear();
    }
  };
}
class FuseIndex {
  constructor({
    getFn = Config$1.getFn,
    fieldNormWeight = Config$1.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key2, idx) => {
      this._keysMap[key2.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString$1(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString$1(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i2 = idx, len = this.size(); i2 < len; i2 += 1) {
      this.records[i2].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key2, keyIndex) => {
      let value = key2.getFn ? key2.getFn(doc) : this.getFn(doc, key2.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray$1(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString$1(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray$1(value2)) {
            value2.forEach((item, k2) => {
              stack.push({
                nestedArrIndex: k2,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString$1(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function createIndex(keys, docs, { getFn = Config$1.getFn, fieldNormWeight = Config$1.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data2, { getFn = Config$1.getFn, fieldNormWeight = Config$1.fieldNormWeight } = {}) {
  const { keys, records } = data2;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config$1.distance,
  ignoreLocation = Config$1.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config$1.minMatchCharLength) {
  let indices = [];
  let start2 = -1;
  let end = -1;
  let i2 = 0;
  for (let len = matchmask.length; i2 < len; i2 += 1) {
    let match = matchmask[i2];
    if (match && start2 === -1) {
      start2 = i2;
    } else if (!match && start2 !== -1) {
      end = i2 - 1;
      if (end - start2 + 1 >= minMatchCharLength) {
        indices.push([start2, end]);
      }
      start2 = -1;
    }
  }
  if (matchmask[i2 - 1] && i2 - start2 >= minMatchCharLength) {
    indices.push([start2, i2 - 1]);
  }
  return indices;
}
const MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location: location2 = Config$1.location,
  distance = Config$1.distance,
  threshold = Config$1.threshold,
  findAllMatches = Config$1.findAllMatches,
  minMatchCharLength = Config$1.minMatchCharLength,
  includeMatches = Config$1.includeMatches,
  ignoreLocation = Config$1.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location2, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i2 = 0;
      while (i2 < patternLen) {
        matchMask[index + i2] = 1;
        i2 += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i2 = 0; i2 < patternLen; i2 += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i2,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start2 = Math.max(1, expectedLocation - binMid + 1);
    let finish2 = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish2 + 2);
    bitArr[finish2 + 1] = (1 << i2) - 1;
    for (let j2 = finish2; j2 >= start2; j2 -= 1) {
      let currentLocation = j2 - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j2] = (bitArr[j2 + 1] << 1 | 1) & charMatch;
      if (i2) {
        bitArr[j2] |= (lastBitArr[j2 + 1] | lastBitArr[j2]) << 1 | 1 | lastBitArr[j2 + 1];
      }
      if (bitArr[j2] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i2,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start2 = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i2 + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i2 = 0, len = pattern.length; i2 < len; i2 += 1) {
    const char = pattern.charAt(i2);
    mask[char] = (mask[char] || 0) | 1 << len - i2 - 1;
  }
  return mask;
}
class BitapSearch {
  constructor(pattern, {
    location: location2 = Config$1.location,
    threshold = Config$1.threshold,
    distance = Config$1.distance,
    includeMatches = Config$1.includeMatches,
    findAllMatches = Config$1.findAllMatches,
    minMatchCharLength = Config$1.minMatchCharLength,
    isCaseSensitive = Config$1.isCaseSensitive,
    ignoreLocation = Config$1.ignoreLocation
  } = {}) {
    this.options = {
      location: location2,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i2 = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i2 < end) {
        addChunk(this.pattern.substr(i2, MAX_BITS), i2);
        i2 += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location: location2,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location2 + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}
class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
}
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index = text2.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class FuzzyMatch extends BaseMatch {
  constructor(pattern, {
    location: location2 = Config$1.location,
    threshold = Config$1.threshold,
    distance = Config$1.distance,
    includeMatches = Config$1.includeMatches,
    findAllMatches = Config$1.findAllMatches,
    minMatchCharLength = Config$1.minMatchCharLength,
    isCaseSensitive = Config$1.isCaseSensitive,
    ignoreLocation = Config$1.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location: location2,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
}
class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location2 = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text2.indexOf(this.pattern, location2)) > -1) {
      location2 = index + patternLen;
      indices.push([index, location2 - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
const searchersLen = searchers.length;
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = "|";
function parseQuery(pattern, options2 = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i2 = 0, len = query.length; i2 < len; i2 += 1) {
      const queryItem = query[i2];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options2));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options2));
          break;
        }
      }
    }
    return results;
  });
}
const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
  constructor(pattern, {
    isCaseSensitive = Config$1.isCaseSensitive,
    includeMatches = Config$1.includeMatches,
    minMatchCharLength = Config$1.minMatchCharLength,
    ignoreLocation = Config$1.ignoreLocation,
    findAllMatches = Config$1.findAllMatches,
    location: location2 = Config$1.location,
    threshold = Config$1.threshold,
    distance = Config$1.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location: location2,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_2, options2) {
    return options2.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i2 = 0, qLen = query.length; i2 < qLen; i2 += 1) {
      const searchers2 = query[i2];
      allIndices.length = 0;
      numMatches = 0;
      for (let j2 = 0, pLen = searchers2.length; j2 < pLen; j2 += 1) {
        const searcher = searchers2[j2];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
}
const registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options2) {
  for (let i2 = 0, len = registeredSearchers.length; i2 < len; i2 += 1) {
    let searcherClass = registeredSearchers[i2];
    if (searcherClass.condition(pattern, options2)) {
      return new searcherClass(pattern, options2);
    }
  }
  return new BitapSearch(pattern, options2);
}
const LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
const KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
const isPath = (query) => !!query[KeyType.PATH];
const isLeaf = (query) => !isArray$1(query) && isObject$1(query) && !isExpression(query);
const convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key2) => ({
    [key2]: query[key2]
  }))
});
function parse(query, options2, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key2 = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key2];
      if (!isString$1(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key2));
      }
      const obj = {
        keyId: createKeyId(key2),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options2);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key2) => {
      const value = query2[key2];
      if (isArray$1(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config$1.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key: key2, norm: norm2, score }) => {
      const weight = key2 ? key2.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data2) {
  const matches = result.matches;
  data2.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data2.matches.push(obj);
  });
}
function transformScore(result, data2) {
  data2.score = result.score;
}
function format(results, docs, {
  includeMatches = Config$1.includeMatches,
  includeScore = Config$1.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data2 = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data2);
      });
    }
    return data2;
  });
}
class Fuse {
  constructor(docs, options2 = {}, index) {
    this.options = { ...Config$1, ...options2 };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i2 = 0, len = this._docs.length; i2 < len; i2 += 1) {
      const doc = this._docs[i2];
      if (predicate(doc, i2)) {
        this.removeAt(i2);
        i2 -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString$1(query) ? isString$1(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber$1(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i2 = 0, len = node.children.length; i2 < len; i2 += 1) {
        const child = node.children[i2];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key2, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key: key2,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key: key2, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray$1(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key: key2,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key: key2, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
}
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config$1;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}
async function LogoffToken() {
  Log("server/user/logoff", "Logging off User Token...");
  const url = getServerUrl(Endpoints.LogoffToken);
  const token = UserToken.get();
  if (!url || !token)
    return false;
  try {
    const response = await axios$1.get(url, makeTokenOptions(token));
    if (response.status !== 200)
      return false;
    UserToken.set(null);
    return true;
  } catch {
    return true;
  }
}
const DefaultService = {
  name: "Unknown",
  description: "This service isn't known to ArcOS",
  process: null
};
async function stopService(id, fromSystem = false) {
  Log("service/interact", `Attempting to stop ${id}`);
  const managerPid = ServiceManagerPid.get();
  const manager = ProcessStack.getProcess(managerPid);
  if (!managerPid || !manager)
    return "err_noManager";
  return await manager.stopService(id, fromSystem);
}
async function startService(id, fromSystem = false) {
  Log("service/interact", `Attempting to start ${id}`);
  const managerPid = ServiceManagerPid.get();
  const manager = ProcessStack.getProcess(managerPid);
  if (!managerPid || !manager)
    return "err_noManager";
  return await manager.startService(id, fromSystem);
}
async function restartService(id, fromSystem = false) {
  Log("service/interact", `Attempting to restart ${id}`);
  const managerPid = ServiceManagerPid.get();
  const manager = ProcessStack.getProcess(managerPid);
  if (!managerPid || !manager)
    return "err_noManager";
  return await manager.restartService(id, fromSystem);
}
function getService(id) {
  const managerPid = ServiceManagerPid.get();
  const manager = ProcessStack.getProcess(managerPid);
  if (!managerPid || !manager)
    return DefaultService;
  const services = manager.Services.get();
  return services.has(id) ? services.get(id) : DefaultService;
}
function getAllServices() {
  const managerPid = ServiceManagerPid.get();
  const manager = ProcessStack.getProcess(managerPid);
  if (!managerPid || !manager)
    return null;
  const services = manager.Services.get();
  return services;
}
function isServiceRunning(id) {
  const managerPid = ServiceManagerPid.get();
  const manager = ProcessStack.getProcess(managerPid);
  if (!managerPid || !manager)
    return false;
  const services = manager.Services.get();
  return services.has(id) ? !!services.get(id).pid : false;
}
async function startInitialServices() {
  const managerPid = ServiceManagerPid.get();
  const manager = ProcessStack.getProcess(managerPid);
  if (!managerPid || !manager)
    return;
  manager.initialRun();
}
async function logout() {
  Log("Desktop/ts/power", `Resetting data to default stores and logging out ${UserName.get()}...`);
  GlobalDispatch.dispatch("desktop-hide");
  await sleep(400);
  await killAllApps(true);
  appLibrary.set(/* @__PURE__ */ new Map([]));
  const services = getAllServices();
  for (const [id] of services) {
    await stopService(id, true);
  }
  await LogoffToken();
  UserDataStore.set(defaultUserData);
  localStorage.removeItem("arcos-remembered-token");
  UserCache.clear();
  ProcessStack.processes.set(/* @__PURE__ */ new Map([]));
  PrimaryState.navigate("logoff");
}
async function shutdown() {
  GlobalDispatch.dispatch("desktop-hide");
  await sleep(400);
  await LogoffToken();
  Log("Desktop/ts/power", `Shutting down from ${UserName.get()}...`);
  PrimaryState.navigate("shutdown");
}
async function restart$3() {
  GlobalDispatch.dispatch("desktop-hide");
  await sleep(400);
  await LogoffToken();
  Log("Desktop/ts/power", `Restarting from ${UserName.get()}...`);
  PrimaryState.navigate("restart");
}
function isPopulatable(app, includeOverlays) {
  const userdata = UserDataStore.get();
  if (!userdata)
    return false;
  const showHidden = userdata.sh.showHiddenApps || includeOverlays;
  return !app.metadata.core && !app.isOverlay && !app.metadata.hidden || showHidden;
}
function isOpened(id) {
  return ProcessStack.getAppPids(id).length > 0;
}
function compileSearchableApps() {
  const result = [];
  const library = appLibrary.get();
  for (const [id, app] of [...library]) {
    if (!isPopulatable(app))
      continue;
    result.push({
      caption: app.metadata.name,
      description: app.metadata.description,
      image: app.metadata.icon,
      action: () => {
        spawnApp(id);
      }
    });
  }
  return result;
}
const ArcAppMimeIcon = "" + new URL("application-arcapp-cf286af8.svg", import.meta.url).href;
const ArcThemeMimeIcon = "" + new URL("application-arctheme-df73f527.svg", import.meta.url).href;
const DefaultMimeIcon = "" + new URL("file-2b467055.svg", import.meta.url).href;
const JsonMimeIcon = "" + new URL("application-json-3bf91bc0.svg", import.meta.url).href;
const PdfMimeIcon = "" + new URL("application-pdf-f44eab59.svg", import.meta.url).href;
const SvgMimeIcon = "" + new URL("application-svg-30509a2b.svg", import.meta.url).href;
const CompressMimeIcon = "" + new URL("application-x-compress-62f4387d.svg", import.meta.url).href;
const JavascriptMimeIcon = "" + new URL("application-x-javascript-b4078b12.svg", import.meta.url).href;
const XmlMimeIcon = "" + new URL("application-xml-141cdbce.svg", import.meta.url).href;
const ArcTermMimeIcon = "" + new URL("arcterm-conf-e77b5fb1.svg", import.meta.url).href;
const AudioMimeIcon = "" + new URL("audio-x-generic-b1d42166.svg", import.meta.url).href;
const ImageMimeIcon = "" + new URL("image-x-generic-30331f62.svg", import.meta.url).href;
const TextMimeIcon = "" + new URL("text-plain-5f9e7041.svg", import.meta.url).href;
const MarkdownMimeIcon = "" + new URL("text-x-markdown-7b099247.svg", import.meta.url).href;
const UnknownFileIcon = "" + new URL("unknown-file-09396436.svg", import.meta.url).href;
const VideoMimeIcon = "" + new URL("video-generic-a7552175.svg", import.meta.url).href;
const WebpageMimeIcon = "" + new URL("webpage-8f8741ed.svg", import.meta.url).href;
const Mimetypes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArcAppMimeIcon,
  ArcTermMimeIcon,
  ArcThemeMimeIcon,
  AudioMimeIcon,
  CompressMimeIcon,
  DefaultMimeIcon,
  ImageMimeIcon,
  JavascriptMimeIcon,
  JsonMimeIcon,
  MarkdownMimeIcon,
  PdfMimeIcon,
  SvgMimeIcon,
  TextMimeIcon,
  UnknownFileIcon,
  VideoMimeIcon,
  WebpageMimeIcon,
  XmlMimeIcon
}, Symbol.toStringTag, { value: "Module" }));
const MimeTypeIcons = {
  // <icon, .ext>
  [ArcAppMimeIcon]: [".appmod"],
  [JsonMimeIcon]: [".json"],
  [PdfMimeIcon]: [".pdf"],
  [SvgMimeIcon]: [".svg"],
  [CompressMimeIcon]: [".zip", ".tar.xz", ".7z", ".rar"],
  [AudioMimeIcon]: [".mp3", ".opus", ".wav", ".m4a", ".flac"],
  [ImageMimeIcon]: [".png", ".jpg", ".gif", ".webp", ".ico", ".bmp", ".tif", ".tiff", ".jpeg"],
  [TextMimeIcon]: [".txt"],
  [ArcTermMimeIcon]: ["arcterm.conf", ".arcterm"],
  [ArcThemeMimeIcon]: [".arctheme"],
  [MarkdownMimeIcon]: [".md"],
  [VideoMimeIcon]: [".mp4", ".mkv", ".mov", ".avi"],
  [WebpageMimeIcon]: [".html", ".htm"],
  [JavascriptMimeIcon]: [".js", ".ts", ".d.ts", ".mjs"],
  [XmlMimeIcon]: [".xml"],
  [UnknownFileIcon]: [".$new"]
};
function getMimeIcon(filename) {
  filename = filename.toLowerCase();
  for (const icon in MimeTypeIcons) {
    const extensions = MimeTypeIcons[icon];
    for (const extension of extensions) {
      if (filename.endsWith(extension))
        return icon;
    }
  }
  return DefaultMimeIcon;
}
let Runtime$k = class Runtime3 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "File", Store$1());
    __publicField(this, "showAll", Store$1(false));
    __publicField(this, "compatibles", Store$1([]));
    __publicField(this, "selected", Store$1(""));
    const args = process.args;
    if (!args.length || !args[0] || typeof args[0] !== "object") {
      this.closeApp();
      return;
    }
    const file = args[0];
    const compatibles = getCompatibleHandlers(file.scopedPath, false);
    this.File.set(file);
    this.compatibles.set(compatibles);
    if (!compatibles.length)
      this.showAll.set(true);
  }
  Go(handler) {
    const fileHandler = handler || getHandlerByName(this.selected.get());
    if (!fileHandler)
      return;
    fileHandler.handler(this.File.get());
    return this.closeApp();
  }
};
function create_fragment$5p(ctx) {
  let div2;
  let div0;
  let button0;
  let t1;
  let button1;
  let t3;
  let div1;
  let button2;
  let t5;
  let button3;
  let t6;
  let button3_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "Compatible";
      t1 = space();
      button1 = element("button");
      button1.textContent = "All";
      t3 = space();
      div1 = element("div");
      button2 = element("button");
      button2.textContent = "Cancel";
      t5 = space();
      button3 = element("button");
      t6 = text("Open");
      toggle_class(button0, "suggested", !/*$showAll*/
      ctx[1]);
      toggle_class(
        button1,
        "suggested",
        /*$showAll*/
        ctx[1]
      );
      attr(div0, "class", "mode");
      attr(button3, "class", "suggested");
      button3.disabled = button3_disabled_value = !/*$selected*/
      ctx[2];
      attr(div1, "class", "confirm");
      attr(div2, "class", "bottom");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, button0);
      append(div0, t1);
      append(div0, button1);
      append(div2, t3);
      append(div2, div1);
      append(div1, button2);
      append(div1, t5);
      append(div1, button3);
      append(button3, t6);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*showCompatible*/
            ctx[5]
          ),
          listen(
            button1,
            "click",
            /*showAllItems*/
            ctx[6]
          ),
          listen(
            button2,
            "click",
            /*click_handler*/
            ctx[7]
          ),
          listen(
            button3,
            "click",
            /*click_handler_1*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$showAll*/
      2) {
        toggle_class(button0, "suggested", !/*$showAll*/
        ctx2[1]);
      }
      if (dirty & /*$showAll*/
      2) {
        toggle_class(
          button1,
          "suggested",
          /*$showAll*/
          ctx2[1]
        );
      }
      if (dirty & /*$selected*/
      4 && button3_disabled_value !== (button3_disabled_value = !/*$selected*/
      ctx2[2])) {
        button3.disabled = button3_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4Y($$self, $$props, $$invalidate) {
  let $showAll;
  let $selected;
  let { runtime } = $$props;
  const { showAll, selected } = runtime;
  component_subscribe($$self, showAll, (value) => $$invalidate(1, $showAll = value));
  component_subscribe($$self, selected, (value) => $$invalidate(2, $selected = value));
  function showCompatible() {
    set_store_value(showAll, $showAll = false, $showAll);
  }
  function showAllItems() {
    set_store_value(showAll, $showAll = true, $showAll);
  }
  const click_handler = () => runtime.closeApp();
  const click_handler_1 = () => runtime.Go();
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [
    runtime,
    $showAll,
    $selected,
    showAll,
    selected,
    showCompatible,
    showAllItems,
    click_handler,
    click_handler_1
  ];
}
let Bottom$4 = class Bottom extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4Y, create_fragment$5p, safe_not_equal, { runtime: 0 });
  }
};
async function openFileWithApp(id, file) {
  const app = getAppById(id);
  if (!app)
    return false;
  return await spawnApp(id, 0, [file.scopedPath]);
}
const ImageViewerHandler = {
  extensions: MimeTypeIcons[ImageMimeIcon],
  name: "View Image",
  image: ImageMimeIcon,
  description: "Open the image in Image Viewer",
  handler(file) {
    openFileWithApp("ImageViewer", file);
  }
};
const MarkDownViewerHandler = {
  extensions: [".md"],
  name: "View Markdown",
  image: MarkdownMimeIcon,
  description: "Open this file in Markdown Viewer",
  handler(file) {
    openFileWithApp("MarkDownViewer", file);
  }
};
const MediaPlayerHandler = {
  name: "Play Media",
  description: "Open this file in Media Player",
  extensions: [...MimeTypeIcons[AudioMimeIcon], ...MimeTypeIcons[VideoMimeIcon]],
  image: MediaPlayerIcon,
  handler(file) {
    openFileWithApp("MediaPlayer", file);
  }
};
const TextEditorHandler = {
  extensions: [".txt", ".conf", ".json", ".text", ".arcterm"],
  name: "Text Editor",
  image: TextEditorIcon,
  description: "Open the file in the Text Editor",
  handler(file) {
    openFileWithApp("TextEditor", file);
  }
};
const DownloadIcon = "" + new URL("download-b660f3b9.svg", import.meta.url).href;
const FileIcon = "" + new URL("file-2b467055.svg", import.meta.url).href;
const ArcTermFolderIcon = "" + new URL("folder-arcterm-a7d998e6.svg", import.meta.url).href;
const DocumentsFolderIcon = "" + new URL("folder-documents-50b0d688.svg", import.meta.url).href;
const ThemeFolderIcon = "" + new URL("folder-themes-7ff40f81.svg", import.meta.url).href;
const WallpapersFolderIcon = "" + new URL("folder-wallpapers-61b65ef5.svg", import.meta.url).href;
const FolderIcon = "" + new URL("folder-d3e8cceb.svg", import.meta.url).href;
const save = "" + new URL("save-ad720c82.svg", import.meta.url).href;
const sd = "" + new URL("sd-a5e72fd3.svg", import.meta.url).href;
const Filesystem = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArcTermFolderIcon,
  DocumentsFolderIcon,
  DownloadIcon,
  FileIcon,
  FolderIcon,
  SaveIcon: save,
  SdIcon: sd,
  ThemeFolderIcon,
  WallpapersFolderIcon
}, Symbol.toStringTag, { value: "Module" }));
function DownloadFile(file) {
  if (!file || !file.data)
    return;
  const blob = file.data;
  const url = URL.createObjectURL(blob);
  const anchor = document.createElement("a");
  anchor.href = url;
  anchor.download = file.name;
  anchor.target = "_blank";
  anchor.click();
  anchor.remove();
}
const DownloadHandler = {
  extensions: ["*.*"],
  name: "Download File",
  description: "Download this file to your local machine.",
  image: DownloadIcon,
  async handler(file) {
    const arcfile = await readFile(file.scopedPath);
    DownloadFile(arcfile);
  }
};
const BuiltinThemes = {
  arcDark: {
    author: "ArcOS Team",
    version: "2.1",
    name: "ArcOS Dark",
    anim: true,
    noGlass: false,
    sharp: false,
    theme: "dark",
    wallpaper: "img04",
    taskbarCentered: false,
    taskbarLabels: false,
    taskbarPosition: "",
    docked: false,
    accent: "008DFF",
    smallStart: true,
    titleButtons: "default",
    titlebarLarge: true,
    titlebarLeft: false,
    taskbarColored: true,
    titlebarCentered: false,
    isLauncher: false,
    loginBackground: "img15"
  },
  arcLight: {
    author: "ArcOS Team",
    version: "2.1",
    name: "ArcOS Light",
    anim: true,
    noGlass: false,
    sharp: false,
    theme: "light",
    wallpaper: "img05",
    taskbarCentered: false,
    taskbarLabels: false,
    taskbarPosition: "",
    docked: false,
    accent: "008DFF",
    smallStart: true,
    titleButtons: "default",
    titlebarLarge: false,
    titlebarLeft: false,
    taskbarColored: true,
    titlebarCentered: false,
    isLauncher: false,
    loginBackground: "img15"
  },
  theHague: {
    author: "Aron Wagener",
    version: "1.0",
    name: "The Hague",
    anim: true,
    noGlass: false,
    sharp: false,
    theme: "dark",
    wallpaper: "img13",
    taskbarCentered: false,
    taskbarLabels: true,
    taskbarPosition: "",
    docked: true,
    accent: "00AA00",
    smallStart: false,
    titleButtons: "default",
    titlebarLarge: true,
    titlebarLeft: false,
    taskbarColored: false,
    titlebarCentered: false,
    isLauncher: false,
    loginBackground: "img15"
  },
  wacky: {
    author: "Izaak Kuipers",
    version: "1.0",
    name: "Wacky",
    anim: true,
    noGlass: false,
    sharp: false,
    theme: "dark",
    wallpaper: "img03",
    taskbarCentered: true,
    taskbarLabels: true,
    taskbarPosition: "vertical",
    docked: false,
    accent: "FFAA00",
    smallStart: true,
    titleButtons: "og",
    titlebarLarge: true,
    titlebarLeft: true,
    taskbarColored: false,
    titlebarCentered: false,
    isLauncher: false,
    loginBackground: "img15"
  },
  performance: {
    author: "ArcOS Team",
    version: "1.0",
    name: "Optimal Performance",
    anim: false,
    noGlass: true,
    sharp: true,
    theme: "dark",
    wallpaper: "img0",
    taskbarCentered: false,
    taskbarLabels: false,
    taskbarPosition: "",
    docked: true,
    accent: "FFFFFF",
    smallStart: true,
    titleButtons: "default",
    titlebarLarge: false,
    titlebarLeft: false,
    taskbarColored: false,
    titlebarCentered: false,
    isLauncher: false,
    loginBackground: "img15"
  },
  wandelbos: {
    version: "1.0",
    name: "Wandelbos",
    author: "Izaak",
    anim: true,
    noGlass: false,
    sharp: false,
    theme: "dark",
    wallpaper: "img08",
    accent: "91F5AD",
    docked: true,
    taskbarCentered: false,
    taskbarLabels: false,
    taskbarPosition: "",
    smallStart: true,
    titleButtons: "default",
    titlebarLarge: false,
    titlebarLeft: false,
    taskbarColored: true,
    titlebarCentered: false,
    isLauncher: false,
    loginBackground: "img15"
  },
  scheveningen: {
    version: "1.0",
    name: "Scheveningen",
    author: "Izaak & keesvv",
    anim: true,
    noGlass: false,
    sharp: false,
    theme: "dark",
    wallpaper: "img14",
    accent: "264653",
    docked: true,
    taskbarCentered: false,
    taskbarLabels: false,
    taskbarPosition: "",
    smallStart: true,
    titleButtons: "default",
    titlebarLarge: false,
    titlebarLeft: false,
    taskbarColored: true,
    titlebarCentered: false,
    isLauncher: false,
    loginBackground: "img15"
  }
};
const UserThemeKeys = [
  "anim",
  "noGlass",
  "sharp",
  "theme",
  "wallpaper",
  "accent",
  "docked",
  "taskbarCentered",
  "taskbarLabels",
  "taskbarPosition",
  "taskbarColored",
  "smallStart",
  "titleButtons",
  "titlebarLarge",
  "titlebarLeft"
];
function loadTheme(context) {
  const verifier = verifyTheme(context);
  if (verifier !== "themeIsValid") {
    Log("themes", `Not loading invalid theme! Missing ${verifier}`, LogLevel.error);
    return false;
  }
  UserDataStore.update((udata) => {
    udata.sh.anim = !!context.anim;
    udata.sh.noGlass = !!context.noGlass;
    udata.sh.desktop.sharp = !!context.sharp;
    udata.sh.desktop.theme = context.theme;
    udata.sh.desktop.wallpaper = context.wallpaper;
    udata.sh.desktop.accent = context.accent;
    udata.sh.taskbar.docked = !!context.docked;
    udata.sh.taskbar.centered = !!context.taskbarCentered;
    udata.sh.taskbar.labels = !!context.taskbarLabels;
    udata.sh.taskbar.pos = context.taskbarPosition;
    udata.sh.start.small = !!context.smallStart;
    udata.sh.window.buttons = context.titleButtons;
    udata.sh.window.bigtb = !!context.titlebarLarge;
    udata.sh.window.lefttb = !!context.titlebarLeft;
    udata.sh.taskbar.colored = !!context.taskbarColored;
    udata.sh.window.centertb = !!context.titlebarCentered;
    udata.sh.taskbar.isLauncher = !!context.isLauncher;
    if (context.loginBackground)
      udata.acc.loginBackground = context.loginBackground;
    return udata;
  });
  return true;
}
function saveCurrentTheme(name) {
  const id = `${Math.floor(Math.random() * 1e6)}`;
  UserDataStore.update((udata) => {
    const context = {
      version: "1.0",
      name,
      author: UserName.get(),
      anim: udata.sh.anim,
      noGlass: udata.sh.noGlass,
      sharp: udata.sh.desktop.sharp,
      theme: udata.sh.desktop.theme,
      wallpaper: udata.sh.desktop.wallpaper,
      loginBackground: udata.acc.loginBackground || "img15",
      accent: udata.sh.desktop.accent,
      docked: udata.sh.taskbar.docked,
      taskbarCentered: udata.sh.taskbar.centered,
      taskbarLabels: udata.sh.taskbar.labels,
      taskbarPosition: udata.sh.taskbar.pos,
      smallStart: udata.sh.start.small,
      titleButtons: udata.sh.window.buttons,
      titlebarLarge: udata.sh.window.bigtb,
      titlebarLeft: udata.sh.window.lefttb,
      taskbarColored: udata.sh.taskbar.colored,
      titlebarCentered: udata.sh.window.centertb,
      isLauncher: udata.sh.taskbar.isLauncher
    };
    if (!udata.sh.userThemes)
      udata.sh.userThemes = {};
    udata.sh.userThemes[id] = context;
    return udata;
  });
}
function deleteCustomTheme(id) {
  Log("themes", `Deleting UserTheme "${id}"`);
  UserDataStore.update((udata) => {
    if (!udata.sh.userThemes || !udata.sh.userThemes[id])
      return udata;
    delete udata.sh.userThemes[id];
    return udata;
  });
  return true;
}
function verifyTheme(json) {
  const keys = Object.keys(json);
  for (const key2 of UserThemeKeys) {
    if (!keys.includes(key2))
      return key2;
  }
  return "themeIsValid";
}
function applyUserTheme(id) {
  Log("themes", `Applying UserTheme "${id}"`);
  if (!id)
    return;
  const udata = UserDataStore.get();
  const themes = udata.sh.userThemes;
  if (!themes || !themes[id])
    return false;
  loadTheme(themes[id]);
  return true;
}
function applySystemTheme(id) {
  Log("themes", `Applying Built-in theme "${id}"`);
  if (!id || !BuiltinThemes[id])
    return;
  loadTheme(BuiltinThemes[id]);
  return true;
}
const ThemeHandler = {
  extensions: [".arctheme"],
  name: "Apply Theme",
  image: ThemesIcon,
  description: "Apply this ArcOS theme",
  async handler(file) {
    const arcfile = await readFile(file.scopedPath);
    if (!arcfile)
      return;
    const content = await arcfile.data.text();
    const json = tryJsonConvert(content);
    if (!json || typeof json !== "object")
      return;
    loadTheme(json);
  }
};
const FileHandlers = [
  TextEditorHandler,
  MarkDownViewerHandler,
  ImageViewerHandler,
  MediaPlayerHandler,
  ThemeHandler,
  DownloadHandler
];
function create_fragment$5o(ctx) {
  let button;
  let img;
  let img_src_value;
  let t0;
  let div;
  let p0;
  let t1_value = (
    /*handler*/
    ctx[0].name + ""
  );
  let t1;
  let t2;
  let p1;
  let t3_value = (
    /*handler*/
    ctx[0].description + ""
  );
  let t3;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      div = element("div");
      p0 = element("p");
      t1 = text(t1_value);
      t2 = space();
      p1 = element("p");
      t3 = text(t3_value);
      if (!src_url_equal(img.src, img_src_value = /*handler*/
      ctx[0].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(p0, "class", "name");
      attr(p1, "class", "description");
      attr(div, "class", "context");
      attr(button, "class", "handler");
      toggle_class(
        button,
        "selected",
        /*$selected*/
        ctx[1] == /*handler*/
        ctx[0].name
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, div);
      append(div, p0);
      append(p0, t1);
      append(div, t2);
      append(div, p1);
      append(p1, t3);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*select*/
            ctx[4]
          ),
          listen(
            button,
            "dblclick",
            /*open*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*handler*/
      1 && !src_url_equal(img.src, img_src_value = /*handler*/
      ctx2[0].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*handler*/
      1 && t1_value !== (t1_value = /*handler*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*handler*/
      1 && t3_value !== (t3_value = /*handler*/
      ctx2[0].description + ""))
        set_data(t3, t3_value);
      if (dirty & /*$selected, handler*/
      3) {
        toggle_class(
          button,
          "selected",
          /*$selected*/
          ctx2[1] == /*handler*/
          ctx2[0].name
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4X($$self, $$props, $$invalidate) {
  let $selected;
  let { handler } = $$props;
  let { runtime } = $$props;
  const { selected } = runtime;
  component_subscribe($$self, selected, (value) => $$invalidate(1, $selected = value));
  function open() {
    runtime.Go(handler);
  }
  function select() {
    set_store_value(selected, $selected = handler.name, $selected);
  }
  $$self.$$set = ($$props2) => {
    if ("handler" in $$props2)
      $$invalidate(0, handler = $$props2.handler);
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
  };
  return [handler, $selected, selected, open, select, runtime];
}
class Handler extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4X, create_fragment$5o, safe_not_equal, { handler: 0, runtime: 5 });
  }
}
function get_each_context$T(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list2[i2];
  return child_ctx;
}
function create_each_block$T(ctx) {
  let handler_1;
  let current;
  handler_1 = new Handler({
    props: {
      handler: (
        /*handler*/
        ctx[6]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(handler_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(handler_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const handler_1_changes = {};
      if (dirty & /*$showAll, $compatibles*/
      6)
        handler_1_changes.handler = /*handler*/
        ctx2[6];
      if (dirty & /*runtime*/
      1)
        handler_1_changes.runtime = /*runtime*/
        ctx2[0];
      handler_1.$set(handler_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(handler_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(handler_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(handler_1, detaching);
    }
  };
}
function create_if_block$1Z(ctx) {
  let div;
  let p2;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      p2 = element("p");
      p2.textContent = "Couldn't find any compatible handlers!";
      t1 = space();
      button = element("button");
      button.textContent = "Show All";
      attr(button, "class", "link show-all");
      attr(div, "class", "no-results");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p2);
      append(div, t1);
      append(div, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$5n(ctx) {
  let div;
  let t2;
  let current;
  let each_value = ensure_array_like(
    /*$showAll*/
    ctx[1] ? FileHandlers : (
      /*$compatibles*/
      ctx[2]
    )
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$T(get_each_context$T(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = !/*$showAll*/
  ctx[1] && !/*$compatibles*/
  ctx[2].length && create_if_block$1Z(ctx);
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "handlers");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      append(div, t2);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$showAll, $compatibles, runtime*/
      7) {
        each_value = ensure_array_like(
          /*$showAll*/
          ctx2[1] ? FileHandlers : (
            /*$compatibles*/
            ctx2[2]
          )
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$T(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$T(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, t2);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!/*$showAll*/
      ctx2[1] && !/*$compatibles*/
      ctx2[2].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1Z(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$4W($$self, $$props, $$invalidate) {
  let $showAll;
  let $compatibles;
  let { runtime } = $$props;
  const { showAll, compatibles } = runtime;
  component_subscribe($$self, showAll, (value) => $$invalidate(1, $showAll = value));
  component_subscribe($$self, compatibles, (value) => $$invalidate(2, $compatibles = value));
  const click_handler = () => set_store_value(showAll, $showAll = true, $showAll);
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, $showAll, $compatibles, showAll, compatibles, click_handler];
}
class Handlers extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4W, create_fragment$5n, safe_not_equal, { runtime: 0 });
  }
}
const main$w = "";
function create_if_block$1Y(ctx) {
  let div1;
  let div0;
  let h1;
  let t0;
  let t1_value = (
    /*$File*/
    ctx[2].filename + ""
  );
  let t1;
  let t2;
  let p2;
  let img;
  let img_src_value;
  let t3;
  let span;
  let t4;
  let t5_value = pathToFriendlyPath(
    /*$File*/
    ctx[2].scopedPath
  ) + "";
  let t5;
  let t6;
  let handlers;
  let t7;
  let bottom;
  let current;
  handlers = new Handlers({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  bottom = new Bottom$4({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      h1 = element("h1");
      t0 = text("Select an item to open ");
      t1 = text(t1_value);
      t2 = space();
      p2 = element("p");
      img = element("img");
      t3 = space();
      span = element("span");
      t4 = text("Home/");
      t5 = text(t5_value);
      t6 = space();
      create_component(handlers.$$.fragment);
      t7 = space();
      create_component(bottom.$$.fragment);
      if (!src_url_equal(img.src, img_src_value = /*icon*/
      ctx[1]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(div0, "class", "header");
      attr(div1, "class", "top");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, h1);
      append(h1, t0);
      append(h1, t1);
      append(div0, t2);
      append(div0, p2);
      append(p2, img);
      append(p2, t3);
      append(p2, span);
      append(span, t4);
      append(span, t5);
      append(div1, t6);
      mount_component(handlers, div1, null);
      insert(target, t7, anchor);
      mount_component(bottom, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*$File*/
      4) && t1_value !== (t1_value = /*$File*/
      ctx2[2].filename + ""))
        set_data(t1, t1_value);
      if (!current || dirty & /*icon*/
      2 && !src_url_equal(img.src, img_src_value = /*icon*/
      ctx2[1])) {
        attr(img, "src", img_src_value);
      }
      if ((!current || dirty & /*$File*/
      4) && t5_value !== (t5_value = pathToFriendlyPath(
        /*$File*/
        ctx2[2].scopedPath
      ) + ""))
        set_data(t5, t5_value);
      const handlers_changes = {};
      if (dirty & /*runtime*/
      1)
        handlers_changes.runtime = /*runtime*/
        ctx2[0];
      handlers.$set(handlers_changes);
      const bottom_changes = {};
      if (dirty & /*runtime*/
      1)
        bottom_changes.runtime = /*runtime*/
        ctx2[0];
      bottom.$set(bottom_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(handlers.$$.fragment, local);
      transition_in(bottom.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(handlers.$$.fragment, local);
      transition_out(bottom.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t7);
      }
      destroy_component(handlers);
      destroy_component(bottom, detaching);
    }
  };
}
function create_fragment$5m(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$File*/
    ctx[2] && create_if_block$1Y(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$File*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$File*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1Y(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$4V($$self, $$props, $$invalidate) {
  let $File;
  let { runtime } = $$props;
  const { File } = runtime;
  component_subscribe($$self, File, (value) => $$invalidate(2, $File = value));
  let icon = DefaultMimeIcon;
  onMount(() => {
    File.subscribe((v2) => v2 && $$invalidate(1, icon = getMimeIcon(v2.filename)));
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, icon, $File, File];
}
let App$r = class App4 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4V, create_fragment$5m, safe_not_equal, { runtime: 0 });
  }
};
const OpenWith$1 = {
  metadata: {
    name: "Open With",
    description: "Allows you to choose with what to open a file",
    author: "The ArcOS Team",
    version: "3.0.0",
    icon: ComponentIcon,
    appGroup: "internal",
    hidden: true
  },
  runtime: Runtime$k,
  content: App$r,
  id: "OpenWith",
  size: { w: 450, h: NaN },
  minSize: { w: 450, h: 500 },
  maxSize: { w: 450, h: 540 },
  pos: { x: 200, y: 100 },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: {
    minimize: false,
    maximize: false,
    close: true
  },
  isOverlay: true,
  glass: true,
  loadCondition: () => !SafeMode.get()
};
function ShellArcFind(process) {
  const opened = process.hasIdAsSubprocess("ArcFind");
  const elevating = isOpened("SecureContext");
  if (opened || elevating)
    return;
  spawnOverlay(getAppById("ArcFind"), process.pid, [], true);
}
function ShellProcessManager(process) {
  const opened = process.hasIdAsSubprocess("ProcessManager");
  const elevating = isOpened("SecureContext");
  if (opened || elevating)
    return;
  spawnOverlay(getAppById("ProcessManager"), process.pid, [], true);
}
function ShellKeyboardShortcuts(process) {
  const opened = process.hasIdAsSubprocess("KeyboardShortcuts");
  const elevating = isOpened("SecureContext");
  if (opened || elevating)
    return;
  spawnOverlay(getAppById("KeyboardShortcuts"), process.pid, [], true);
}
const ShellPid = () => ProcessStack.getAppPids("ArcShell")[0] || 0;
async function OpenFile(file, parentPid = ShellPid()) {
  const handlers = getCompatibleHandlers(file.scopedPath, false);
  if (!handlers.length) {
    if (!parentPid)
      return;
    noCompatibleHandlers(file, parentPid);
    return;
  }
  return await handlers[0].handler(file);
}
function getCompatibleHandlers(path, wildcards = true) {
  const extension = parseExtension(path);
  const handlers = FileHandlers.filter(
    (h2) => h2.extensions.includes(extension) || wildcards && h2.extensions.includes("*.*")
  );
  return handlers;
}
function getHandlerByName(name) {
  const handlers = FileHandlers.filter((h2) => h2.name == name);
  return handlers[0];
}
async function OpenWith(file, parentPid, bypassAuto = false) {
  const compatibles = getCompatibleHandlers(file.scopedPath, false);
  if (compatibles.length == 1 && !bypassAuto) {
    OpenFile(file);
    return "success";
  }
  const proc = await spawnOverlay(OpenWith$1, parentPid, [file]);
  if (typeof proc === "string")
    return proc;
  return "success";
}
function noCompatibleHandlers(file, parentPid) {
  createErrorDialog(
    {
      title: `Unknown file type`,
      message: `ArcOS doesn't have any compatible file handlers to open ${file.filename}. Do you want to select from a list of all handlers instead?`,
      buttons: [
        {
          caption: "Cancel",
          action() {
          }
        },
        {
          caption: "Open With...",
          action() {
            OpenWith(file, parentPid);
          },
          suggested: true
        }
      ],
      image: UnknownFileIcon,
      sound: "arcos.dialog.warning"
    },
    parentPid,
    true
  );
}
async function GetFilesystemTree() {
  const url = getServerUrl(Endpoints.FsTree);
  const token = UserToken.get();
  if (!url || !token)
    return [];
  try {
    const response = await axios$1.get(url, makeTokenOptions(token));
    if (response.status !== 200)
      return [];
    return response.data.data;
  } catch {
    return [];
  }
}
let FILE_CACHE = [];
GlobalDispatch.subscribe("fs-flush", () => FILE_CACHE = []);
async function compileSearchableFiles() {
  if (FILE_CACHE.length && FILE_CACHE[0])
    return FILE_CACHE;
  const files = await GetFilesystemTree();
  const result = [];
  for (const file of files) {
    result.push({
      caption: file.filename,
      action: async () => {
        OpenFile(file);
      },
      description: `Home/${pathToFriendlyPath(file.scopedPath)}`,
      image: getMimeIcon(file.filename)
    });
  }
  FILE_CACHE = result;
  return result;
}
async function OpenSettingsPage(page) {
  const pid = ProcessStack.getAppPids("SettingsApp")[0];
  if (!pid)
    spawnApp("SettingsApp", 0, [page]);
  ProcessStack.dispatch.dispatchToPid(pid, "change-page", page);
  focusedPid.set(pid);
}
class OverlayRuntime extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
  }
}
async function getUserData(token) {
  Log("server/user/data", "Getting UserData using <token>");
  const bearer = token || UserToken.get();
  const url = getServerUrl(Endpoints.UserData);
  if (!bearer || !url)
    return;
  try {
    const response = await axios$1.get(url, makeTokenOptions(bearer));
    if (response.status !== 200)
      return null;
    return response.data.properties;
  } catch {
    return null;
  }
}
async function setUserData(data2) {
  Log("server/user/data", "Committing UserData using <token>");
  const token = UserToken.get();
  const url = getServerUrl(Endpoints.UserData);
  if (!token || !url)
    return;
  try {
    const response = await axios$1.put(url, data2, makeTokenOptions(token));
    return response.status === 200;
  } catch {
    return null;
  }
}
async function Authenticate(username, password, save2 = true) {
  Log("server/user/auth", `Attempting to authenticate "${username}"`);
  const url = getServerUrl(Endpoints.Token);
  const formData = new FormData();
  if (!url)
    return false;
  formData.set("username", username);
  formData.set("password", password);
  try {
    const response = await axios$1.post(url, formData, {
      headers: { "Content-Type": "multipart/form-data" }
    });
    if (response.status !== 200)
      return false;
    const token = response.data.access_token;
    const userdata = await getUserData(token);
    if (!userdata)
      return false;
    UserDataStore.set(userdata);
    UserName.set(username);
    UserToken.set(token);
    if (save2)
      setRememberedToken(username, password);
    return true;
  } catch {
    return false;
  }
}
async function doRememberedAuth() {
  Log("server/user/auth", "Attempting authentication using arcos-remembered-token");
  const token = localStorage.getItem("arcos-remembered-token");
  if (!token)
    return false;
  const [username, password] = fromBase64(token).split(":");
  return await Authenticate(username, password);
}
async function setRememberedToken(username, password) {
  Log("server/user/auth", `Setting arcos-remembered-token to user ${username}`);
  const joined = `${username}:${password}`;
  const token = toBase64(joined);
  if (token == joined)
    return null;
  localStorage.setItem("arcos-remembered-token", token);
  return token;
}
async function changeUsername(oldName, newName) {
  Log("server/user/mutate/name", `Changing username from ${oldName} to ${newName}`);
  const base64 = toBase64(newName);
  if (base64 == newName)
    return false;
  const url = getServerUrl(Endpoints.UserRename, { newname: base64 });
  const token = UserToken.get();
  if (!url || !token)
    return false;
  try {
    const response = await axios$1.get(url, makeTokenOptions(token));
    const remembered = localStorage.getItem("arcos-remembered-token");
    if (!remembered)
      return response.status === 200;
    const password = fromBase64(remembered).split(":")[1];
    setRememberedToken(newName, password);
    UserName.set(newName);
    return response.status === 200;
  } catch {
    return false;
  }
}
async function changePassword(username, oldPassword, newPassword, confirm) {
  Log("server/user/mutate/password", `Changing password for user ${username}`);
  const newBase64 = toBase64(newPassword);
  if (newBase64 == newPassword)
    return false;
  const url = getServerUrl(Endpoints.UserChangePassword, { new: newBase64 });
  if (newPassword != confirm || !url)
    return false;
  const token = toBase64(`${username}:${oldPassword}`);
  try {
    const response = await axios$1.get(url, { headers: { Authorization: `Basic ${token}` } });
    if (response.status !== 200)
      return false;
    setRememberedToken(username, newPassword);
    return true;
  } catch {
    return false;
  }
}
async function createUser(username, password) {
  Log("server/user/mutate", `Creating user "${username}"`);
  const url = getServerUrl(Endpoints.NewUsers);
  if (!url)
    return false;
  try {
    const req = await axios$1.post(url, { username, password });
    return req.status === 200;
  } catch {
    return false;
  }
}
async function deleteSelf(token) {
  Log("server/user/mutate", `Goodbye cruel world, I'm deleting my own account...`, LogLevel.warn);
  const url = getServerUrl(Endpoints.UserData);
  if (!url)
    return false;
  try {
    const response = await axios$1.delete(url, makeTokenOptions(token));
    return response.status === 200;
  } catch {
    return false;
  }
}
function create_fragment$5l(ctx) {
  let div4;
  let div2;
  let div0;
  let img_1;
  let img_1_src_value;
  let t0;
  let div1;
  let t1;
  let div3;
  let button0;
  let t3;
  let button1;
  let t4;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      img_1 = element("img");
      t0 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      div3 = element("div");
      button0 = element("button");
      button0.textContent = "Cancel";
      t3 = space();
      button1 = element("button");
      t4 = text("Confirm");
      if (!src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx[0]))
        attr(img_1, "src", img_1_src_value);
      attr(img_1, "alt", "");
      attr(div0, "class", "image");
      attr(div1, "class", "changer-content");
      attr(div2, "class", "top");
      attr(button0, "class", "cancel");
      attr(button1, "class", "confirm suggested");
      button1.disabled = /*disabled*/
      ctx[3];
      attr(div3, "class", "buttons");
      attr(div4, "class", "value-changer");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, img_1);
      append(div2, t0);
      append(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append(div4, t1);
      append(div4, div3);
      append(div3, button0);
      append(div3, t3);
      append(div3, button1);
      append(button1, t4);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(
              /*cancel*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(
              /*confirm*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (!current || dirty & /*img*/
      1 && !src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx[0])) {
        attr(img_1, "src", img_1_src_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*disabled*/
      8) {
        button1.disabled = /*disabled*/
        ctx[3];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4U($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { img } = $$props;
  let { cancel } = $$props;
  let { confirm } = $$props;
  let { disabled = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("img" in $$props2)
      $$invalidate(0, img = $$props2.img);
    if ("cancel" in $$props2)
      $$invalidate(1, cancel = $$props2.cancel);
    if ("confirm" in $$props2)
      $$invalidate(2, confirm = $$props2.confirm);
    if ("disabled" in $$props2)
      $$invalidate(3, disabled = $$props2.disabled);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [img, cancel, confirm, disabled, $$scope, slots];
}
class ValueChanger extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4U, create_fragment$5l, safe_not_equal, {
      img: 0,
      cancel: 1,
      confirm: 2,
      disabled: 3
    });
  }
}
function create_default_slot$z(ctx) {
  let h3;
  let t1;
  let p2;
  let t3;
  let input0;
  let t4;
  let input1;
  let t5;
  let input2;
  let mounted;
  let dispose;
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "Change your password";
      t1 = space();
      p2 = element("p");
      p2.textContent = "Fill out the following fields to change your password:";
      t3 = space();
      input0 = element("input");
      t4 = space();
      input1 = element("input");
      t5 = space();
      input2 = element("input");
      attr(input0, "type", "password");
      attr(input0, "placeholder", "Current password");
      attr(input1, "type", "password");
      attr(input1, "placeholder", "New password");
      attr(input2, "type", "password");
      attr(input2, "placeholder", "Confirm new password");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      insert(target, p2, anchor);
      insert(target, t3, anchor);
      insert(target, input0, anchor);
      set_input_value(
        input0,
        /*oldPassword*/
        ctx[0]
      );
      insert(target, t4, anchor);
      insert(target, input1, anchor);
      set_input_value(
        input1,
        /*newPassword*/
        ctx[1]
      );
      insert(target, t5, anchor);
      insert(target, input2, anchor);
      set_input_value(
        input2,
        /*confirmPassword*/
        ctx[2]
      );
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[6]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[7]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*oldPassword*/
      1 && input0.value !== /*oldPassword*/
      ctx2[0]) {
        set_input_value(
          input0,
          /*oldPassword*/
          ctx2[0]
        );
      }
      if (dirty & /*newPassword*/
      2 && input1.value !== /*newPassword*/
      ctx2[1]) {
        set_input_value(
          input1,
          /*newPassword*/
          ctx2[1]
        );
      }
      if (dirty & /*confirmPassword*/
      4 && input2.value !== /*confirmPassword*/
      ctx2[2]) {
        set_input_value(
          input2,
          /*confirmPassword*/
          ctx2[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t1);
        detach(p2);
        detach(t3);
        detach(input0);
        detach(t4);
        detach(input1);
        detach(t5);
        detach(input2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$5k(ctx) {
  let valuechanger;
  let current;
  valuechanger = new ValueChanger({
    props: {
      img: PasswordIcon,
      cancel: (
        /*cancel*/
        ctx[3]
      ),
      confirm: (
        /*confirm*/
        ctx[4]
      ),
      disabled: !/*oldPassword*/
      ctx[0] || !/*newPassword*/
      ctx[1] || /*newPassword*/
      ctx[1] != /*confirmPassword*/
      ctx[2],
      $$slots: { default: [create_default_slot$z] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(valuechanger.$$.fragment);
    },
    m(target, anchor) {
      mount_component(valuechanger, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const valuechanger_changes = {};
      if (dirty & /*oldPassword, newPassword, confirmPassword*/
      7)
        valuechanger_changes.disabled = !/*oldPassword*/
        ctx2[0] || !/*newPassword*/
        ctx2[1] || /*newPassword*/
        ctx2[1] != /*confirmPassword*/
        ctx2[2];
      if (dirty & /*$$scope, confirmPassword, newPassword, oldPassword*/
      1031) {
        valuechanger_changes.$$scope = { dirty, ctx: ctx2 };
      }
      valuechanger.$set(valuechanger_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(valuechanger.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(valuechanger.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(valuechanger, detaching);
    }
  };
}
function instance$4T($$self, $$props, $$invalidate) {
  let $UserName;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(9, $UserName = $$value));
  let oldPassword;
  let newPassword;
  let confirmPassword;
  let { runtime } = $$props;
  function cancel() {
    ProcessStack.kill(runtime.pid, true);
  }
  async function confirm() {
    const elevation = await GetUserElevation(ElevationChangePassword(), ProcessStack);
    if (!elevation)
      return cancel();
    const changed = await changePassword($UserName, oldPassword, newPassword, confirmPassword);
    if (!changed) {
      createErrorDialog(
        {
          title: "Change failed",
          message: "An error occured while changing your password. Please try again later. If the problem keeps happening, please submit a bug report.",
          buttons: [
            {
              caption: "Okay",
              action() {
              },
              suggested: true
            }
          ],
          image: PasswordIcon,
          sound: "arcos.dialog.error"
        },
        runtime.process.parentPid,
        true
      );
      return;
    }
    createErrorDialog(
      {
        title: "Password changed!",
        message: `Your ArcOS password has been updated successfully. You will have to log in again on other devices, as their login information is now invalid.`,
        buttons: [
          {
            caption: "Great!",
            action: cancel,
            suggested: true
          }
        ],
        image: PasswordIcon,
        sound: "arcos.dialog.info"
      },
      runtime.process.parentPid,
      true
    );
    cancel();
  }
  function input0_input_handler() {
    oldPassword = this.value;
    $$invalidate(0, oldPassword);
  }
  function input1_input_handler() {
    newPassword = this.value;
    $$invalidate(1, newPassword);
  }
  function input2_input_handler() {
    confirmPassword = this.value;
    $$invalidate(2, confirmPassword);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
  };
  return [
    oldPassword,
    newPassword,
    confirmPassword,
    cancel,
    confirm,
    runtime,
    input0_input_handler,
    input1_input_handler,
    input2_input_handler
  ];
}
let ChangePassword$1 = class ChangePassword extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4T, create_fragment$5k, safe_not_equal, { runtime: 5 });
  }
};
const ChangePassword2 = {
  metadata: {
    name: "Change Password",
    description: "Change your ArcOS Password",
    author: "ArcOS Team",
    version: "1.0.0",
    icon: PasswordIcon
  },
  runtime: OverlayRuntime,
  size: { w: 430, h: 265 },
  minSize: { w: 430, h: 265 },
  maxSize: { w: 430, h: 265 },
  id: "ChangePassword",
  pos: {
    x: 0,
    y: 0
  },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: { minimize: false, maximize: false, close: false },
  content: ChangePassword$1
};
function create_default_slot$y(ctx) {
  let h3;
  let t1;
  let p2;
  let t3;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "Change Username";
      t1 = space();
      p2 = element("p");
      p2.textContent = "Enter a new username for your account:";
      t3 = space();
      input = element("input");
      attr(input, "type", "text");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      insert(target, p2, anchor);
      insert(target, t3, anchor);
      insert(target, input, anchor);
      set_input_value(
        input,
        /*newUsername*/
        ctx[0]
      );
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*newUsername*/
      1 && input.value !== /*newUsername*/
      ctx2[0]) {
        set_input_value(
          input,
          /*newUsername*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t1);
        detach(p2);
        detach(t3);
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$5j(ctx) {
  let valuechanger;
  let current;
  valuechanger = new ValueChanger({
    props: {
      img: AccountIcon,
      cancel: (
        /*cancel*/
        ctx[2]
      ),
      confirm: (
        /*confirm*/
        ctx[3]
      ),
      disabled: !/*newUsername*/
      ctx[0] || /*$UserName*/
      ctx[1] == /*newUsername*/
      ctx[0],
      $$slots: { default: [create_default_slot$y] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(valuechanger.$$.fragment);
    },
    m(target, anchor) {
      mount_component(valuechanger, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const valuechanger_changes = {};
      if (dirty & /*newUsername, $UserName*/
      3)
        valuechanger_changes.disabled = !/*newUsername*/
        ctx2[0] || /*$UserName*/
        ctx2[1] == /*newUsername*/
        ctx2[0];
      if (dirty & /*$$scope, newUsername*/
      65) {
        valuechanger_changes.$$scope = { dirty, ctx: ctx2 };
      }
      valuechanger.$set(valuechanger_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(valuechanger.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(valuechanger.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(valuechanger, detaching);
    }
  };
}
function instance$4S($$self, $$props, $$invalidate) {
  let $UserName;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(1, $UserName = $$value));
  let { runtime } = $$props;
  let newUsername;
  function cancel() {
    ProcessStack.kill(runtime.pid, true);
  }
  async function confirm() {
    const elevation = await GetUserElevation(ElevationChangeUsername(), ProcessStack);
    if (!elevation)
      return cancel();
    const changed = await changeUsername($UserName, newUsername);
    if (!changed) {
      createErrorDialog(
        {
          title: "Change failed",
          message: "An error occured while changing your username. Please try again later. If the problem keeps happening, please submit a bug report.",
          buttons: [
            {
              caption: "Okay",
              action() {
              },
              suggested: true
            }
          ],
          image: WarningIcon,
          sound: "arcos.dialog.error"
        },
        runtime.process.parentPid,
        true
      );
      return;
    }
    createErrorDialog(
      {
        title: "Username changed!",
        message: `Your ArcOS username has been updated successfully. You will have to log in again on other devices, as their login information is now invalid.`,
        buttons: [
          {
            caption: "Great!",
            action: cancel,
            suggested: true
          }
        ],
        image: AccountIcon,
        sound: "arcos.dialog.info"
      },
      runtime.process.parentPid,
      true
    );
    cancel();
  }
  function input_input_handler() {
    newUsername = this.value;
    $$invalidate(0, newUsername);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(4, runtime = $$props2.runtime);
  };
  return [newUsername, $UserName, cancel, confirm, runtime, input_input_handler];
}
let ChangeUsername$1 = class ChangeUsername extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4S, create_fragment$5j, safe_not_equal, { runtime: 4 });
  }
};
const ChangeUsername2 = {
  metadata: {
    name: "Change Username",
    description: "Change your ArcOS Username",
    author: "ArcOS Team",
    version: "1.0.0",
    icon: AccountIcon
  },
  runtime: OverlayRuntime,
  size: { w: 350, h: 182 },
  minSize: { w: 350, h: 182 },
  maxSize: { w: 350, h: 182 },
  id: "ChangeUsername",
  pos: {
    x: 0,
    y: 0
  },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: { minimize: false, maximize: false, close: false },
  content: ChangeUsername$1
};
function create_default_slot$x(ctx) {
  let h3;
  let t1;
  let p2;
  let t3;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "Custom Login Background";
      t1 = space();
      p2 = element("p");
      p2.textContent = "Enter the URL to any image you like:";
      t3 = space();
      input = element("input");
      attr(input, "type", "url");
      attr(input, "placeholder", "https://example.com/image.png");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      insert(target, p2, anchor);
      insert(target, t3, anchor);
      insert(target, input, anchor);
      set_input_value(
        input,
        /*background*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[6]
          ),
          listen(
            input,
            "input",
            /*check*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*background*/
      1 && input.value !== /*background*/
      ctx2[0]) {
        set_input_value(
          input,
          /*background*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t1);
        detach(p2);
        detach(t3);
        detach(input);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$5i(ctx) {
  let valuechanger;
  let current;
  valuechanger = new ValueChanger({
    props: {
      img: (
        /*valid*/
        ctx[1] ? (
          /*background*/
          ctx[0]
        ) : PasswordIcon
      ),
      cancel: (
        /*cancel*/
        ctx[4]
      ),
      confirm: (
        /*apply*/
        ctx[3]
      ),
      disabled: !/*valid*/
      ctx[1],
      $$slots: { default: [create_default_slot$x] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(valuechanger.$$.fragment);
    },
    m(target, anchor) {
      mount_component(valuechanger, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const valuechanger_changes = {};
      if (dirty & /*valid, background*/
      3)
        valuechanger_changes.img = /*valid*/
        ctx2[1] ? (
          /*background*/
          ctx2[0]
        ) : PasswordIcon;
      if (dirty & /*valid*/
      2)
        valuechanger_changes.disabled = !/*valid*/
        ctx2[1];
      if (dirty & /*$$scope, background*/
      257) {
        valuechanger_changes.$$scope = { dirty, ctx: ctx2 };
      }
      valuechanger.$set(valuechanger_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(valuechanger.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(valuechanger.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(valuechanger, detaching);
    }
  };
}
async function checkImage$2(url) {
  const img = new Image();
  img.src = url;
  return new Promise((resolve) => {
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
  });
}
function instance$4R($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(7, $UserDataStore = $$value));
  let background = "";
  let valid = false;
  let { runtime } = $$props;
  async function check() {
    const v2 = await checkImage$2(background);
    $$invalidate(1, valid = v2);
  }
  function apply() {
    set_store_value(UserDataStore, $UserDataStore.acc.loginBackground = background, $UserDataStore);
    cancel();
  }
  function cancel() {
    ProcessStack.kill(runtime.pid, true);
  }
  UserDataStore.subscribe((v2) => {
    const current = v2.acc.loginBackground;
    if (typeof current != "string" || !current.startsWith("http"))
      return;
    $$invalidate(0, background = current);
    check();
  });
  function input_input_handler() {
    background = this.value;
    $$invalidate(0, background);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
  };
  return [background, valid, check, apply, cancel, runtime, input_input_handler];
}
let CustomLoginBackground$1 = class CustomLoginBackground extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4R, create_fragment$5i, safe_not_equal, { runtime: 5 });
  }
};
const CustomLoginBackground2 = {
  metadata: {
    name: "Custom Login Background",
    description: "Change your login background to something beautiful.",
    author: "ArcOS Team",
    version: "2.0.0",
    icon: PasswordIcon
  },
  runtime: OverlayRuntime,
  size: { w: 350, h: 182 },
  minSize: { w: 350, h: 182 },
  maxSize: { w: 350, h: 182 },
  id: "CustomWallpaper",
  pos: {
    x: 0,
    y: 0
  },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: { minimize: false, maximize: false, close: false },
  content: CustomLoginBackground$1
};
const pfp1 = "" + new URL("1-abd0e4d2.png", import.meta.url).href;
const pfp10 = "" + new URL("10-bc298d8e.png", import.meta.url).href;
const pfp11 = "" + new URL("11-7e3b447d.png", import.meta.url).href;
const pfp12 = "" + new URL("12-cddffff0.png", import.meta.url).href;
const pfp13 = "" + new URL("13-c6cc9c6e.png", import.meta.url).href;
const pfp14 = "" + new URL("14-f371aca2.png", import.meta.url).href;
const pfp15 = "" + new URL("15-62abb556.png", import.meta.url).href;
const pfp16 = "" + new URL("16-bfd35187.png", import.meta.url).href;
const pfp17 = "" + new URL("17-d76c4138.png", import.meta.url).href;
const pfp18 = "" + new URL("18-4187b279.png", import.meta.url).href;
const pfp19 = "" + new URL("19-82c3e540.png", import.meta.url).href;
const pfp2 = "" + new URL("2-3be2af07.png", import.meta.url).href;
const pfp20 = "" + new URL("20-4094bc0d.png", import.meta.url).href;
const pfp21 = "" + new URL("21-1140c466.png", import.meta.url).href;
const pfp22 = "" + new URL("22-2a85a0b7.png", import.meta.url).href;
const pfp23 = "" + new URL("23-bec699f8.png", import.meta.url).href;
const pfp24 = "" + new URL("24-7182acda.png", import.meta.url).href;
const pfp25 = "" + new URL("25-454a10ef.png", import.meta.url).href;
const pfp26 = "" + new URL("26-f359a51b.png", import.meta.url).href;
const pfp27 = "" + new URL("27-eef5a6f5.png", import.meta.url).href;
const pfp28 = "" + new URL("28-539e77a7.png", import.meta.url).href;
const pfp29 = "" + new URL("29-2fd56672.png", import.meta.url).href;
const pfp3 = "" + new URL("3-af39cd3b.png", import.meta.url).href;
const pfp4 = "" + new URL("4-d81322cf.png", import.meta.url).href;
const pfp5 = "" + new URL("5-fa473ce6.png", import.meta.url).href;
const pfp6 = "" + new URL("6-aeac688d.png", import.meta.url).href;
const pfp7 = "" + new URL("7-f8348565.png", import.meta.url).href;
const pfp8 = "" + new URL("8-57290d72.png", import.meta.url).href;
const pfp9 = "" + new URL("9-4c15a884.png", import.meta.url).href;
const def = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIAAgMAAACJFjxpAAAADFBMVEXFxcX////p6enW1tbAmiBwAAAFiElEQVR4AezAgQAAAACAoP2pF6kAAAAAAAAAAAAAAIDbu2MkvY0jiuMWWQoUmI50BB+BgRTpCAz4G6C8CJDrC3AEXGKPoMTlYA/gAJfwETawI8cuBs5Nk2KtvfiLW+gLfK9m+r3X82G653+JP/zjF8afP1S//y+An4/i51//AsB4aH+/QPD6EQAY/zwZwN8BAP50bh786KP4+VT+3fs4/noigEc+jnHeJrzxX+NWMDDh4g8+EXcnLcC9T8U5S/CdT8bcUeBEIrwBOiI8ki7Ba5+NrePgWUy89/nYyxQ8Iw3f+pWY4h1gb3eAW7sDTPEOsLc7wK1TIeDuDB+I/OA1QOUHv/dFsZQkhKkh4QlEfOULYz2nGj2/Nn1LmwR/86VxlCoAW6kCsHRGANx1RgCMo5Qh2EsZgrXNQZZShp5Liv7Il8eIc5C91EHY2hxk6bwYmNscZIReDBwtCdhbErC1JGBpScBcOgFMLQsZMQs5Whayd+UQsLYsZGlZyNyykKllISNmIUfAwifw8NXvTojAjGFrdYi11SGWVoeYWx1i6lmQCiEjFkKOVgjZ+xxIhZCtFULWHkCqxCw9gNQKmP9vNHzipdEPrRcxtVbAeDkAvve0iM2QozVD9hfjhp4YP/UrkJYDbD2AtBxgfSkAvvHEeNcDSAsilgtAWxIy91J8AXgZAJ5e33+4tuACcAG4AFwALgBXRXQB6AFcB5MXAuA6nl9/0Vx/011/1V5/1/dfTPJvRtdnu/zL6beeFO/7r+fXBYbrEkt/j+i6ytXfpuvvE/ZXOnsA/a3a/l5xf7O6v1t+Xe/vOyz6HpO8yyboM8o7rfJes77bru83THk48p7TvOs27zvOO6/73vO++z7l4cgnMPQzKPopHC0N9noSSz6LJp/Gk88jyicy5TOp6qlc+VyyfDJbPpuuns6XzyfMJzTmMyrrKZ35nNJ8Ums+q7af1tvPK+4nNodEnPKp3fnc8npyez67/qVP7+/fL8hfcMjfsOhf8cjfMclfcnn9+BkOnLECP8Q58OYeyJ40eoyF6Ee/En/JHlP6mIlRVXprF4BxtAvArV0AxtEuALd2ARhHuwDc2gVgHPX/hFv9fMBddjIGeKg/WCxlCsI46u+Ga5mCcJd+sIG9UkGAW32ZbApFAHhod4Bb3eo04h3god0BbiUHYApVCNjbHeBW+QDAXT4a7qg7r7e214057vg0QhkEHkoSwq0kIdydXw4/Q3H8hjYJ3vL0WConBJhCHQaOToeBrU0BljYFmEoVgHGUKgAPnREAt84IgLuqFgAYSUEOAHszDwuAtSkHAZhLGYIpdCLgKGUIHtocZG1zkLmUIRhxDnJU1RDA1uYga5uDzKUOwhTnIEfnxcDe5iBrcyQAYGlzkKkUYhhxDrKXQgxbSwLWUohhbknA1JKAEZOAvSUBW0sC1pYEzC0JmFoSMMJyCDhaFrK3JGDtyiFgaVnI3LKQqWUhI2YhR8tC9paFrC0LWVoWMrcsZGpZyIhZyNGykL2rSIGtlQHWVgZYWhlgbmWAqZUBRiwDHK0MsLcywNbKAGsOoNUhllaHmFsdYmp1iBHrEEerQ+w5gFYI2VodYm11iKXVIeYcQCuETK0QMmIh5MgBtELI3gohWyuErDmAVolZWiFkzgG0SszUKjGjfj6gVmKOVonZcwCtFbB9HQC+ozWDbz1bvGu9iKW1AuYcQOtFTLEX1GbIaFegN0OOHEBrhuw5gNYM2XIArRuz5gDacoB3bTnAEktxXQ4wfw0AvveM8b4tiJjSJOwLIsbXsAKeNeKCiOO3D+AVbUl0AfjGs8ZPbUnIdgFoa1LWC0BblfMuB9AeC1j6gqQE0J9LmC8AOYD2ZMb7i4bt2ZTpWoHfPoB7Tj2fXzT8N1X41vkq/QHOAAAAAElFTkSuQmCC";
const ProfilePictures = {
  pfp1,
  pfp2,
  pfp3,
  pfp4,
  pfp5,
  pfp6,
  pfp7,
  pfp8,
  pfp9,
  pfp10,
  pfp11,
  pfp12,
  pfp13,
  pfp14,
  pfp15,
  pfp16,
  pfp17,
  pfp18,
  pfp19,
  pfp20,
  pfp21,
  pfp22,
  pfp23,
  pfp24,
  pfp25,
  pfp26,
  pfp27,
  pfp28,
  pfp29,
  def
};
function getProfilePicture(id) {
  if (typeof id == "number")
    return ProfilePictures[`pfp${id}`] || def;
  return id.toString();
}
async function applyCustomPfp(url) {
  UserDataStore.update((udata) => {
    udata.acc.profilePicture = url;
    return udata;
  });
}
function create_default_slot$w(ctx) {
  let h3;
  let t1;
  let p2;
  let t3;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "Custom Profile Picture";
      t1 = space();
      p2 = element("p");
      p2.textContent = "Enter the URL to any image you like:";
      t3 = space();
      input = element("input");
      attr(input, "type", "url");
      attr(input, "placeholder", "https://example.com/image.png");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      insert(target, p2, anchor);
      insert(target, t3, anchor);
      insert(target, input, anchor);
      set_input_value(
        input,
        /*img*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[6]
          ),
          listen(
            input,
            "input",
            /*check*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*img*/
      1 && input.value !== /*img*/
      ctx2[0]) {
        set_input_value(
          input,
          /*img*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t1);
        detach(p2);
        detach(t3);
        detach(input);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$5h(ctx) {
  let valuechanger;
  let current;
  valuechanger = new ValueChanger({
    props: {
      img: (
        /*valid*/
        ctx[1] ? (
          /*img*/
          ctx[0]
        ) : ProfilePictures.def
      ),
      cancel: (
        /*cancel*/
        ctx[4]
      ),
      confirm: (
        /*apply*/
        ctx[3]
      ),
      disabled: !/*valid*/
      ctx[1],
      $$slots: { default: [create_default_slot$w] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(valuechanger.$$.fragment);
    },
    m(target, anchor) {
      mount_component(valuechanger, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const valuechanger_changes = {};
      if (dirty & /*valid, img*/
      3)
        valuechanger_changes.img = /*valid*/
        ctx2[1] ? (
          /*img*/
          ctx2[0]
        ) : ProfilePictures.def;
      if (dirty & /*valid*/
      2)
        valuechanger_changes.disabled = !/*valid*/
        ctx2[1];
      if (dirty & /*$$scope, img*/
      129) {
        valuechanger_changes.$$scope = { dirty, ctx: ctx2 };
      }
      valuechanger.$set(valuechanger_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(valuechanger.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(valuechanger.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(valuechanger, detaching);
    }
  };
}
async function checkImage$1(url) {
  const img = new Image();
  img.src = url;
  return new Promise((resolve) => {
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
  });
}
function instance$4Q($$self, $$props, $$invalidate) {
  let img = "";
  let valid = false;
  let { runtime } = $$props;
  async function check() {
    const v2 = await checkImage$1(img);
    $$invalidate(1, valid = v2);
  }
  function apply() {
    applyCustomPfp(img);
    ProcessStack.kill(runtime.pid, true);
  }
  function cancel() {
    ProcessStack.kill(runtime.pid, true);
  }
  UserDataStore.subscribe((v2) => {
    if (typeof v2.acc.profilePicture == "string")
      $$invalidate(0, img = v2.acc.profilePicture);
    check();
  });
  function input_input_handler() {
    img = this.value;
    $$invalidate(0, img);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
  };
  return [img, valid, check, apply, cancel, runtime, input_input_handler];
}
let CustomProfilePicture$1 = class CustomProfilePicture extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4Q, create_fragment$5h, safe_not_equal, { runtime: 5 });
  }
};
const CustomProfilePicture2 = {
  metadata: {
    name: "Custom Profile Picture",
    description: "Change your profile picture to something custom",
    author: "ArcOS Team",
    version: "2.0.0",
    icon: PersonalizationIcon
  },
  runtime: OverlayRuntime,
  size: { w: 350, h: 182 },
  minSize: { w: 350, h: 182 },
  maxSize: { w: 350, h: 182 },
  id: "CustomProfilePicture",
  pos: {
    x: 0,
    y: 0
  },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: { minimize: false, maximize: false, close: false },
  content: CustomProfilePicture$1
};
function create_default_slot$v(ctx) {
  let h3;
  let t1;
  let p2;
  let t3;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "Custom Wallpaper";
      t1 = space();
      p2 = element("p");
      p2.textContent = "Enter the URL to any wallpaper you like:";
      t3 = space();
      input = element("input");
      attr(input, "type", "url");
      attr(input, "placeholder", "https://example.com/image.png");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      insert(target, p2, anchor);
      insert(target, t3, anchor);
      insert(target, input, anchor);
      set_input_value(
        input,
        /*wallpaper*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[6]
          ),
          listen(
            input,
            "input",
            /*check*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*wallpaper*/
      1 && input.value !== /*wallpaper*/
      ctx2[0]) {
        set_input_value(
          input,
          /*wallpaper*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t1);
        detach(p2);
        detach(t3);
        detach(input);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$5g(ctx) {
  let valuechanger;
  let current;
  valuechanger = new ValueChanger({
    props: {
      img: (
        /*valid*/
        ctx[1] ? (
          /*wallpaper*/
          ctx[0]
        ) : DesktopIcon$1
      ),
      cancel: (
        /*cancel*/
        ctx[4]
      ),
      confirm: (
        /*apply*/
        ctx[3]
      ),
      disabled: !/*valid*/
      ctx[1],
      $$slots: { default: [create_default_slot$v] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(valuechanger.$$.fragment);
    },
    m(target, anchor) {
      mount_component(valuechanger, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const valuechanger_changes = {};
      if (dirty & /*valid, wallpaper*/
      3)
        valuechanger_changes.img = /*valid*/
        ctx2[1] ? (
          /*wallpaper*/
          ctx2[0]
        ) : DesktopIcon$1;
      if (dirty & /*valid*/
      2)
        valuechanger_changes.disabled = !/*valid*/
        ctx2[1];
      if (dirty & /*$$scope, wallpaper*/
      257) {
        valuechanger_changes.$$scope = { dirty, ctx: ctx2 };
      }
      valuechanger.$set(valuechanger_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(valuechanger.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(valuechanger.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(valuechanger, detaching);
    }
  };
}
async function checkImage(url) {
  const img = new Image();
  img.src = url;
  return new Promise((resolve) => {
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
  });
}
function instance$4P($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(7, $UserDataStore = $$value));
  let wallpaper = "";
  let valid = false;
  let { runtime } = $$props;
  async function check() {
    const v2 = await checkImage(wallpaper);
    $$invalidate(1, valid = v2);
  }
  function apply() {
    set_store_value(UserDataStore, $UserDataStore.sh.desktop.wallpaper = wallpaper, $UserDataStore);
    cancel();
  }
  function cancel() {
    ProcessStack.kill(runtime.pid, true);
  }
  UserDataStore.subscribe((v2) => {
    const current = v2.sh.desktop.wallpaper;
    if (typeof current != "string" || !current.startsWith("http"))
      return;
    $$invalidate(0, wallpaper = current);
    check();
  });
  function input_input_handler() {
    wallpaper = this.value;
    $$invalidate(0, wallpaper);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
  };
  return [wallpaper, valid, check, apply, cancel, runtime, input_input_handler];
}
let CustomWallpaper$1 = class CustomWallpaper extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4P, create_fragment$5g, safe_not_equal, { runtime: 5 });
  }
};
const CustomWallpaper2 = {
  metadata: {
    name: "Custom Wallpaper",
    description: "Change your desktop wallpaper to something beautiful.",
    author: "ArcOS Team",
    version: "2.0.0",
    icon: DesktopIcon$1
  },
  runtime: OverlayRuntime,
  size: { w: 350, h: 182 },
  minSize: { w: 350, h: 182 },
  maxSize: { w: 350, h: 182 },
  id: "CustomWallpaper",
  pos: {
    x: 0,
    y: 0
  },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: { minimize: false, maximize: false, close: false },
  content: CustomWallpaper$1
};
const img0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABIAAAAKICAIAAACHSRZaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAiSSURBVHhe7cEBDQAAAMKg909tDjcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALhTAzCGAAGNmWH9AAAAAElFTkSuQmCC";
const img01 = "" + new URL("img01-a6458b53.jpeg", import.meta.url).href;
const img02 = "" + new URL("img02-b03be002.png", import.meta.url).href;
const img03 = "" + new URL("img03-87b2d378.png", import.meta.url).href;
const img04 = "" + new URL("img04-9d473c5a.png", import.meta.url).href;
const img05 = "" + new URL("img05-3c6c1958.png", import.meta.url).href;
const img06 = "" + new URL("img06-e2fa3f96.jpg", import.meta.url).href;
const img07 = "" + new URL("img07-788d74d9.jpg", import.meta.url).href;
const img08 = "" + new URL("img08-feb75f17.jpg", import.meta.url).href;
const img12 = "" + new URL("img12-c9a4396e.png", import.meta.url).href;
const img13 = "" + new URL("img13-0a31c489.png", import.meta.url).href;
const img14 = "" + new URL("img14-54c8328b.jpg", import.meta.url).href;
const img15 = "" + new URL("img15-ddfd765d.jpg", import.meta.url).href;
const img16 = "" + new URL("img16-f0145d13.jpg", import.meta.url).href;
const img17 = "" + new URL("img17-ebfd7073.jpg", import.meta.url).href;
const img18 = "" + new URL("img18-b02e721d.jpg", import.meta.url).href;
const img19 = "" + new URL("img19-ed01403f.png", import.meta.url).href;
const img20 = "" + new URL("img20-bfa396d5.jpg", import.meta.url).href;
const img21 = "" + new URL("img21-28e5e7c5.jpg", import.meta.url).href;
const img22 = "" + new URL("img22-6a722732.png", import.meta.url).href;
const img23 = "" + new URL("img23-88193330.png", import.meta.url).href;
const img24 = "" + new URL("img24-9bad1e4d.jpg", import.meta.url).href;
const img25 = "" + new URL("img25-46cff1cd.jpg", import.meta.url).href;
const img26 = "" + new URL("img26-59eb83ad.jpg", import.meta.url).href;
const img27 = "" + new URL("img27-9359e713.jpg", import.meta.url).href;
const img28 = "" + new URL("img28-4e3146f5.jpg", import.meta.url).href;
const img29 = "" + new URL("img29-2379f145.png", import.meta.url).href;
const img30 = "" + new URL("img30-a0578971.jpg", import.meta.url).href;
const img31 = "" + new URL("img31-b479b3e7.jpg", import.meta.url).href;
const img0Thumb = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALIAAABkBAMAAADQw3dpAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAADUExURQAAAKd6PdoAAAAJcEhZcwAADsIAAA7CARUoSoAAAAAfSURBVGje7cEBDQAAAMKg909tDwcEAAAAAAAAAAD3aiMoAAHai5ZrAAAAAElFTkSuQmCC";
const img01Thumb = "" + new URL("img01-ab9df476.jpeg", import.meta.url).href;
const img02Thumb = "" + new URL("img02-4ae7a37e.png", import.meta.url).href;
const img03Thumb = "" + new URL("img03-1d95cb84.png", import.meta.url).href;
const img04Thumb = "" + new URL("img04-9e8acc1d.png", import.meta.url).href;
const img05Thumb = "" + new URL("img05-2cb5f1e3.png", import.meta.url).href;
const img06Thumb = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBoRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAARAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDUuMC4xMgAA/9sAQwACAQEBAQECAQEBAgICAgIEAwICAgIFBAQDBAYFBgYGBQYGBgcJCAYHCQcGBggLCAkKCgoKCgYICwwLCgwJCgoK/9sAQwECAgICAgIFAwMFCgcGBwoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK/8AAEQgAZACyAwESAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A/BuND0qSFP4jX6ionkykSRpgYqWJMnpWsYmUpEkKY5NSxrnpWsYmMpEkMZJqaGPjFapGEpEkSccVLEuPmrSMTGUh8adsVLDHmtIxOeUiWJNozUka7j0rSMTGUiS3j7kVNGmOK0jEylIfEm41LCmBnFaKJjKRJGn8IqWFO9aRiYSkSwpgVJGuTgVpGJzykSQxk81NGmBxWkUYykPjXJqWFB1xWkYmUpEkSdsVLDGT2rWMTGUiWFMDOKkjXJ4rWMTCUySCP1qVFwMCtYxOeUh8SbjU0KbRWiRlKQ+Ne1Swp/Ea1jExlIkiTAxipoUyc4rSMTGUiSFO+KljX2rRRMJSJIkzUsaY4rSMTCUh8SbjUsKYGSK0jEwlId5fvTsH0q+VEcx8ixripIUya/JoxP6DlIkiTAqWNcmtoxMZSJYI6miTA6VokYykSRJ2qSNcDPrWkYnPKRJGuTUkMdaRiYykSRrgVLChZs4rSMTGUiWCPAyalRe1axiYykPhQnmpol2itFExlIfGuTipYI60jEwlIliXAqWJNxrRRMJSJII6kjXjFaqJjKRJGuTUsSY5xVxiYykSRJzipYI61jExlIkjTA4qaJNxzitYxOeUySFMDOKkRf4a1jExlIkhTccmpY0wK0jExlIfGhJxU0KYGSK0jExlIkjXsKlhjzWkYmMpEkKYFSxoT2rRIwlIkhXvipY05xWkYmEpD4UzU0S4Ga1jExlIeiZO0VLbx9yK0SMZSHeV/s1Jg+lXymfMfIcaYGKkiTJr8njE/oOUiWCPuRU0SY5rVIwlIkij5xUsaYGK0jEwlIdEmT0qaFMDOK0jEwlIkRf4akgjLHNaqJlKRLCm0dKljXJ6VoomMpEkMdSxpgYFaJGMpD4kyamhjxWiiYSkSRpgYqSFCTnFaKJhKRLCmOTUqgAc9q0SMpSNjwN4S1Dxt4ns/Denod9xKA7D+Fe59v8APWvoL9jr4YwaBaf8J7rtt/pNxj7Ojryq9v8APrSybLM04yxzwmWS5KMXapXavGP92C+1P52W7a0OHP8AO8r4NwCxWYLnqyV6dFO0pecnryx82tdkm9DyP4yfCK/+FHiCCxlDNbXUO6KT5uGHVfmAPvyK+nf2iPBmmfFfwVJFE0Zu4F32sy46j3+v9a9fiHg7NuC6axVOtLF4T7ba/eU/71k3zQ7tax7W1PD4Y45yvjSo8LXorC4r7Cv7lTyTaXLPsn8XR30Xx1GmBtqwbS4tbiS0u4jHNFIUkQ/wsOorhw9SliaUatKScXqmj2sRCpQqOnUVmt0xYk2jNSRpk4rqijklIkgTuRUsa8VoomMpEkSZNSxJgcVpGJjKRJGnNSwx98VrGJjKRJEgHFTRJk4rRIwlIkiXHOKkjXJ6VpGJhKRJClSou0YrVRMZSHxJubpU0Ee0ZrRIxlIkjXtU0MdaRiYykAU4+9U1Xysz5j5BgjxU0ScY9a/KEj+g5SJIk71JGnYVpGJzykSQoSc4qaJdozWiiYykORcnaKmgj7mtFExlIkiTAwKliTca0UTGUiWFO9SIv8NaKJjKRJCmTmpoUwK0UTnlIeidqlgjrRRMZSJIkwM1LGuTWiRjKR1Pwi8Dt408Vxw3Cn7Ha4mvJMdgeF+pNbXwa8Y6d4etLzRry5igkubhZVd8guAuMbiccdccHr17Yf2TiM5xkcPUqqnh7Xm07Tn/AHY9lbd/JGdfN6eT4OVelSdSu9Ipp8kf7z7vsvy3PX/iZ8VF+HXgRodEdY764X7NpqL/AMszjmTHoo5+uB3rwnxv4suPGWvvqbu32eJfKskPZM/e+rHn6YHavua2d0sBgY5dlMVTpRVrx00/u+vWW738z4PC8O1MwxzzLOJOpUk72lr6c3Sy6RWi2fY9N/Zs+Kdxb6fL8O9YvHkMW6bTZJnLMVJy8eT1IJ3D2J9K8l0y5vNMvYdSsJvLnt5BJDJ6MP6dj7Gscnz7FZXH2T96k/s9vNfqtn5M6M84dwebS9tFKNVbSXW2yfp0e681t6J8ePB8Vtqo8aaVF+5uW8u9VR9yTs34/wA6b4i+I+n6z4Qmtw8bS6hb7PsrgsUbPt0wRwen16V87mOT0cBjljMoklSqP36Tdkr7ypro+8du3Y97K84xGMwbwebxbq017lW127bRn38pff3fCwpgZqZFPQV2xiYykPhTJzUsaYGBWiiYykSRJk5xU0KYrVRMZSJIkxUsKZ5rRRMJSHxpgVLEmTWkYmEpEkKd6lRf4RWiiYykSQoWbOKmiTaMYrRRMZSJI154HSpYY60UTGUh8a4FSwpuOa0SMZSFEXH3an2L6VfKzHmPkKJeNxFSRrk8CvyhRP6DlIkhj9akjXAxitFExlIkiTc2Kmgj2jNaKJlKRJGnG2pIUJNaJGMpEsKYGcVLGmTgVoomEpD4EzU0SYGa1UTCUh8aZOKmgjxzWiiYSkSRrgYqSJcnpWiiYykSQpjnFSxJ2rSMTKUiSGPPBFTRpgcVrGJhKQ+NMnipoUxzWsYnPKQ9FwMVLChJ3GtUjGUiSKML2qSNMnFaRiZSkSQp/EamjTsK0UTGUiSFCT0qaGPitIxMJSJIkPapIl74rRRMJSJI07VJChzWkYmEpEkSYGSKlRcnaK0SMZSJII8nJqaJOMYrVRMpSHxJnnFTQpjmtIxMJSJET+ECpII8nNaJGEpE0KYGcVIi5OK1jExlIAH9amEfH3avlMuY+QoY++KlRf4RX5Oon9BykPhTc2anhTaK0UTGUh8a54qWGOtEjGUiSJMCpIlyc1pGJjKRLBHUsaYGK1jE55SJIk3GpoUwM4rSMTGUh8a9sVLCmTWiiYykSRJgVJElaRiYykSwR+tSomBitIxMZSJIkyc4qWJdozW0YnPKQ9F/hFSwp3NaJGMpEkS4FSxJuNaRiYykSQpgZxUsa5PStIxMZSJIY/Wpokx2rVIxlIfEhPFTRLgZxVqJzykPjXPFSwpWsYmMpEka7RmpIk3N0rVIxlIkgjxyamjT+HH1rSMTGUiSFM9qmiXAya0jExlIfGmTtqWCPua0UTGUiSNdoqWNcmtIxOeUiSCPPWpY0wMVtGJjKQcelTBDV2M+Y+QYAC3NFfkkT+hpFlBz0orSJjIsxjC8UVpExkWoFAorSJzy3LEQG6itImMi0g5xRWq2MZFiMACiriYyLUAFFbRMZFiEZOaK1ic8iwo5xRWsTBlqMY7UVcTKRYhHyZorWJjItW6gmitImMi1EoOKK0ic8iwg5orSOxhLYsRgBeKK0iYy3LVuBjOKK0iZSLEABorSJjIsoOaK1jsYS2LUYwuRRWkTCRZgAorZGMixGBnHvRWiMZE+xfSirMz/2Q==";
const img07Thumb = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBoRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAARAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDUuMC4xMgAA/9sAQwACAQEBAQECAQEBAgICAgIEAwICAgIFBAQDBAYFBgYGBQYGBgcJCAYHCQcGBggLCAkKCgoKCgYICwwLCgwJCgoK/9sAQwECAgICAgIFAwMFCgcGBwoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK/8AAEQgAZACyAwESAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A+x7iT3qvcSV/VSR/LDZFPJ71XupccZrRIhyK91L71XuJPeqIuQzyVXnkqkiCK4k96gmkqgI55MDrVa6l96pIzILmXNV5pPeqAiuJNo5NVrmXJ61SRLkQ3ElV55PeqJIp5KgnkzxVpWIbIppO+aguZatIzuV7mWq9xIT3qhEM8mBnNV7mXJ61SRLZDPIfWq88lUSQ3EnbNQTye9VYTZFPJUE8lUQQ3EuOc1WuZe1UkS2QzyZOc1BcSY4qibkFzLmq88nvVJGZHPJmq88mB1qiWyK4k96r3EhrQkinkqtdS4HWgBDOM9aqlzVcpHMfpFPJgZqtdTds18mkfW8xBcy+9V7iT3qiGyGeT3qvPJ71SRBHPIfWoJpPeqE2RXEmKq3MtXYghuJcnrUEz980wIbmXAqtcyknrVJEtkNxJ71Xnk96okink96gmfnrVpWM2yOeTAqtcy+9WkZ3ILmX3qvPJVAQ3Eu0VXuJcnNUkS2Qzye9V7iT3qiSG4lqCeSqSJbIp5PeoJ5PeqJIbmXA61WuZcnrVpEtkM8nfNV7mUdM0yGyG4l96gnk96tKxBFNJ3qCeTHeqsS2Q3EnvVe4lqySK4k96q3UvbNNITZDcy5OSarTy1ZAhk9qrmTnpQB+kFzLVeeSvkz6pyIZ5KgnkqkiSKeTNQTyY5qiWyK5lwKq3MvvV2JIZ5MnrUE8mBkmmBDdS4GM1WuJeetWkQ2QzyVXnkppCbI55KrzSd60M3IjuJMDrVW5l96pIzIbmWqt3cRwxtNM4VVUlmPQAd6oDifjx8U2+GPhD7TpiRzatqEwttJt5OjzN/Ef9lRlj7CvGda8aJ8V/itceOZ33aXpRa00GJvutg/PPj/aI49gCOteBhpZpxdj5YDJpclODtVxDV4w7xpr7dT52j1Z9DXp5Xwnl8cwzmPPUkr0sOnaU+0pv7EPVXfRPY7j4HfF/wAVeINVuvAfxNnt21iOL7TZ3FvC0a3EPRhtYAhlPX2INcD4+vLxbiy8a+HXC6ro8wmtyDjzV/ijPswyPxrqzTI874GisRKvLGYP7cmv3tL+80m+en3trHtbU5MqzrJeOW8PGhHB4xfBFP8Ad1V/Km0uWfZPSXe+30FcSVh+EPGOmeOvC9n4q0iTMN3CG2nqjfxIfQg8GvVwuIw+LoRrUZKUZK6a1TR5OJw9fCVpUa0XGUXZp6NM0J5PeoLiWuhHOQXMvHWq9xLk9a0JbIZ5MDrVe5loM2yG4lqCeStEiSKaTvUFxJimkS2Q3EvvVeeSrJIriXAzVW6lzxmqSJbILiWoJ5aokhuJKrzyZ70Bcb5ntUJl/wBqqsTzH6PTyVBPIfWvlEj6oimkqC4kwOtVYlshuZeMZqtcy1ZJDNJk1BcS4Gc0AQXMvYVXnk96tEXIZ5PeoJ5PeqSJbIp5PeoJpMc1Zm5EVxJgVVuZatIghuJCTiq9xJgZpgeP/ta/FB/D/huP4eaLeGO/1pW+0yRt81vaD77exbO0e7Z7Vwv7aHhrxhN4qs/E+jeGri4sTZLFcXdrHvYOGJCkDnHOemMmvnc4wOPzTFQwjqeyw1r1Gnac9fgi+if2nvbRH02SYvL8tws8Z7P2uJTtCL+CP9+S6tPZf8OZPwg0KXxdrdt4b02Py7WFQZ2j6RxD/HoK9W+APw6f4f8AgWGXU4salqCrNeeqDHyp+A/WvrsLXp4HAwwWXwVKlFWSWmnl69Xu3r5v5PGUqmOx8sZjpe0qyd23rb9NOiWi28lyfx58MDwncx67pUG2xuMI6r0ikA/kR+tem+MvD9h4t8PXXh/UV/d3EZXd3RuzD3B5rbC42vg48sdYfy/5dvTZ/ic+IwuHxUlKekltLr8/891+B4h+z/8AEGPwx4tk8IXU+3T9ZmL2uekF1jJX2DgZ/wB4H1rkfBPgfx7ZfF2LQm8PTTR6dqCG8naPEaorZEgY8Z7jGa+L/suWVZqq+UtKhUl+8ovaLe86f8rv8UduqtsfbyzGlm2UulmqvXpx/d1VvJLaE/5vKW/fu/pq5l7ZqvcSZJOa+uPi7kNxJgVXuJKdrkNkNxJ71BO/vVkkU0lQXEnvVJENkNxJ71Xnk96oRDcy4HWq1zLk1SRLkQTye9QXEnvVEkNxL71Xmk96aQmRTyYqCeT3q0iGxpk/2qgMhz96q5SeY/R+aTvmoLiTFfJJH1jZBcy1XuJST1qySGaTvmoLmXA60AQXMue9V55PetDMhnk96gnk96pIlsinkz3qCeTAqjNyIbmX3qtcy+9WkSQzyZOar3EuBTAhuZcmq88nvWhmQ3DgjBFV7iSnYCGeT3qGeSrIbIZ5Peq9zLiqSEQ3EgBOB16+9V5pO+aozbIbiXA61XuJfemkS2Qzye9QzSVZJDPJioLiSqUTO5DcSe9V7iWqAgupcDGarXMuTnNUkS2Qzye9QXEtUSQ3EvvVeaTvVJE3Ip5KguJKpIlshuJPeoLiT3rQzE8z2qqZ+elAuZH6QXMvvVeeTJr5M+tIZpO5qvcy9qaQmyG4lyetV55KsghnkqCeQ+tUkS5EU0maguJMDFUZuRDcze9VrmUmtCSGeTvmq9zLgYppXE2Q3EuTVeeSrIIbiT3qvPJk1SQEU8nvUE8mKoi5FPJVa5lwMVSRLZDcS5PWq88mOaoi5Dcy9qr3EpqkiGyGeSoZpPeqJuQzyY71XuJPeqSIIp5Kr3EuBmqAgupe1VriXnrVpENkM8nvUFxJjvTEQ3EmT1qvNJVJEuRHPJVe4l96tIhyIZ5Kr3EuB1qyCG6l96q3EuaCLiGX3NQGTn71VyiP0imY4zRXyJ9gULljnOaK0MylOxzRVRCRTnJzRVGL+Eo3THmitESUJmNFAFC4Y9c0VoZlOcnpRQBRmY0VoTIpzscUU0SULhjmirMyjcu1FBMilOx6UVoSU5ycdaKozKM7GiqAo3bHpmiqiTIz52NFUSUZ2NFVEllOdjRVElOdjRWhmULpj60UEyKFwxorRElcs2etFAH/2Q==";
const img08Thumb = "" + new URL("img08-a999f7c4.jpg", import.meta.url).href;
const img12Thumb = "" + new URL("img12-c7f2765f.png", import.meta.url).href;
const img13Thumb = "" + new URL("img13-de7d6069.png", import.meta.url).href;
const img14Thumb = "" + new URL("img14-f10d2a84.jpg", import.meta.url).href;
const img15Thumb = "" + new URL("img15-291de86d.jpg", import.meta.url).href;
const img16Thumb = "" + new URL("img16-9ca9deb0.jpg", import.meta.url).href;
const img17Thumb = "" + new URL("img17-66d4c80e.jpg", import.meta.url).href;
const img18Thumb = "" + new URL("img18-8bd5610a.jpg", import.meta.url).href;
const img19Thumb = "" + new URL("img19-3be39264.png", import.meta.url).href;
const img20Thumb = "" + new URL("img20-2b524f8f.jpg", import.meta.url).href;
const img21Thumb = "" + new URL("img21-a4374b4b.jpg", import.meta.url).href;
const img22Thumb = "" + new URL("img22-317ccfee.png", import.meta.url).href;
const img23Thumb = "" + new URL("img23-8395fe9d.png", import.meta.url).href;
const img24Thumb = "" + new URL("img24-954f4894.jpg", import.meta.url).href;
const img25Thumb = "" + new URL("img25-19da1485.jpg", import.meta.url).href;
const img26Thumb = "" + new URL("img26-7e9c06d5.jpg", import.meta.url).href;
const img27Thumb = "" + new URL("img27-4401a5a3.jpg", import.meta.url).href;
const img28Thumb = "" + new URL("img28-c5f1cd4d.jpg", import.meta.url).href;
const img29Thumb = "" + new URL("img29-6872af71.png", import.meta.url).href;
const img30Thumb = "" + new URL("img30-4f1863e1.jpg", import.meta.url).href;
const img31Thumb = "" + new URL("img31-037136dd.jpg", import.meta.url).href;
const Wallpapers = {
  /**ArcOS Team */
  img04: {
    url: img04,
    thumb: img04Thumb,
    author: "Izaak Kuipers",
    name: "ArcOS Dark",
    builtin: true
  },
  img05: {
    url: img05,
    thumb: img05Thumb,
    author: "Izaak Kuipers",
    name: "ArcOS Light",
    builtin: true
  },
  img03: {
    url: img03,
    thumb: img03Thumb,
    author: "Izaak Kuipers",
    name: "Stealth Gradient",
    builtin: true
  },
  img12: {
    url: img12,
    thumb: img12Thumb,
    author: "Izaak Kuipers",
    name: "Gradiented Waves",
    builtin: true
  },
  /**SWHFotografie */
  img08: {
    url: img08,
    thumb: img08Thumb,
    author: "SWHFotografie",
    name: "Wandelbos",
    source: "Wandelbos, The Netherlands",
    builtin: true
  },
  /** Eversiege */
  img21: {
    url: img21,
    thumb: img21Thumb,
    author: "Eversiege",
    name: "Flippin' Trees",
    builtin: true
  },
  /**Nik Nikovsky */
  img24: {
    url: img24,
    thumb: img24Thumb,
    author: "Nik Nikovsky",
    name: "Camp Forest",
    source: "Radków, Poland",
    builtin: true
  },
  img25: {
    url: img25,
    thumb: img25Thumb,
    author: "Nik Nikovsky",
    name: "Horses",
    source: "Radków, Poland",
    builtin: true
  },
  img26: {
    url: img26,
    thumb: img26Thumb,
    author: "Nik Nikovsky",
    name: "Glorified Duck",
    source: "Radków, Poland",
    builtin: true
  },
  /**SWHFotografie */
  img13: {
    url: img13,
    thumb: img13Thumb,
    author: "SWHFotografie",
    name: "Agga",
    source: "The Hague, The Netherlands",
    builtin: true
  },
  img18: {
    url: img18,
    thumb: img18Thumb,
    author: "SWHFotografie",
    name: "Wilhelmina Sunset",
    source: "Wilheminakanaal, Tilburg, The Netherlands",
    builtin: true
  },
  img20: {
    url: img20,
    thumb: img20Thumb,
    author: "SWHFotografie",
    name: "Stars and Milkyway",
    builtin: true
  },
  /**Matteo Scaringi */
  img15: {
    url: img15,
    thumb: img15Thumb,
    author: "Matteo Scaringi",
    name: "Corfu",
    source: "Corfu, Greece",
    builtin: true
  },
  img19: {
    url: img19,
    thumb: img19Thumb,
    author: "Matteo Scaringi",
    name: "Long Exposure",
    source: "Slijpe, West-Flanders, Belgium",
    builtin: true
  },
  img27: {
    url: img27,
    thumb: img27Thumb,
    author: "Matteo Scaringi",
    name: "Evening Neighborhood",
    builtin: true
  },
  /**Kees van Voorthuizen */
  img14: {
    url: img14,
    thumb: img14Thumb,
    author: "Kees van Voorthuizen",
    name: "Scheveningen",
    builtin: true
  },
  img01: {
    url: img01,
    thumb: img01Thumb,
    author: "Kees van Voorthuizen",
    name: "Mykonos Seaside",
    source: "Mykonos, Greece",
    builtin: true
  },
  img02: {
    url: img02,
    thumb: img02Thumb,
    author: "Kees van Voorthuizen",
    name: "Sunset in Mykonos",
    source: "Mykonos, Greece",
    builtin: true
  },
  /**Saw Ramsson */
  img22: {
    url: img22,
    thumb: img22Thumb,
    author: "Saw Ramsson",
    name: "Evening Lakeside",
    builtin: true
  },
  img23: {
    url: img23,
    thumb: img23Thumb,
    author: "Saw Ramsson",
    name: "Sunny Lake",
    builtin: true
  },
  /**Blocky (Cy) */
  img17: {
    url: img17,
    thumb: img17Thumb,
    author: "Blocky (Cy)",
    name: "Sunset Sky",
    source: "Fairfield Bay, US",
    builtin: true
  },
  img28: {
    url: img28,
    thumb: img28Thumb,
    author: "Blocky (Cy)",
    name: "Florida Beach",
    source: "Florida",
    builtin: true
  },
  /**Matteo Scaringi */
  img16: {
    url: img16,
    thumb: img16Thumb,
    author: "Matteo Scaringi, Izaak Kuipers",
    name: "Login Background - Blurred",
    source: "Corfu, Greece",
    builtin: true
  },
  /**Computer Clan */
  img29: {
    url: img29,
    thumb: img29Thumb,
    author: "Computer Clan",
    name: "Connections",
    builtin: true
  },
  img30: {
    url: img30,
    thumb: img30Thumb,
    author: "Computer Clan",
    name: "Blades",
    builtin: true
  },
  img31: {
    url: img31,
    thumb: img31Thumb,
    author: "Computer Clan",
    name: "Flaming Peddles",
    builtin: true
  },
  /**Izaak Kuipers */
  img06: {
    url: img06,
    thumb: img06Thumb,
    author: "Izaak Kuipers",
    name: "ArcOS Beta Dark",
    builtin: true
  },
  img07: {
    url: img07,
    thumb: img07Thumb,
    author: "Izaak Kuipers",
    name: "ArcOS Beta Light",
    builtin: true
  },
  img0: { url: img0, thumb: img0Thumb, author: "The Void", name: "Blank", builtin: true }
};
const getters = [
  ["@local:", async (id) => await wallpaperFromFS(fromBase64(id.replace("@local:", "")))],
  ["img", (id) => Wallpapers[id] || Wallpapers["img04"]]
];
async function getWallpaper(id, override) {
  if (!id)
    return Wallpapers[override || "img04"];
  if (id.startsWith("http"))
    return { author: "The Web", name: "From the Internet", url: id, thumb: id };
  for (const [prefix, getter] of getters) {
    if (id.startsWith(prefix))
      return await getter(id);
  }
  return Wallpapers[override || "img04"];
}
async function wallpaperFromFS(path) {
  Log("wallpaper", `Reading FS wallpaper from path "${path}"...`, LogLevel.info);
  const file = await readFile(path);
  if (!file) {
    Log("wallpaper", `Unable to get wallpaper "${path}" from ArcFS`, LogLevel.error);
    return Wallpapers["img04"];
  }
  const url = URL.createObjectURL(file.data);
  return { url, thumb: url, author: UserName.get(), name: file.name, source: "" };
}
function create_if_block$1X(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$5f(ctx) {
  let div;
  let div_class_value;
  let current;
  let if_block = !/*noDecorations*/
  ctx[0] && create_if_block$1X(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", div_class_value = "theme-preview theme-" + /*$UserDataStore*/
      ctx[3].sh.desktop.theme);
      set_style(
        div,
        "--bg",
        /*isLogin*/
        ctx[1] ? `url(${/*loginBg*/
        ctx[2]})` : "var(--wallpaper)"
      );
      toggle_class(
        div,
        "sharp",
        /*$UserDataStore*/
        ctx[3].sh.desktop.sharp
      );
      toggle_class(div, "noani", !/*$UserDataStore*/
      ctx[3].sh.anim);
      toggle_class(
        div,
        "noglass",
        /*$UserDataStore*/
        ctx[3].sh.noGlass
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*noDecorations*/
      ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*noDecorations*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1X(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*$UserDataStore*/
      8 && div_class_value !== (div_class_value = "theme-preview theme-" + /*$UserDataStore*/
      ctx2[3].sh.desktop.theme)) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*isLogin, loginBg*/
      6) {
        set_style(
          div,
          "--bg",
          /*isLogin*/
          ctx2[1] ? `url(${/*loginBg*/
          ctx2[2]})` : "var(--wallpaper)"
        );
      }
      if (!current || dirty & /*$UserDataStore, $UserDataStore*/
      8) {
        toggle_class(
          div,
          "sharp",
          /*$UserDataStore*/
          ctx2[3].sh.desktop.sharp
        );
      }
      if (!current || dirty & /*$UserDataStore, $UserDataStore*/
      8) {
        toggle_class(div, "noani", !/*$UserDataStore*/
        ctx2[3].sh.anim);
      }
      if (!current || dirty & /*$UserDataStore, $UserDataStore*/
      8) {
        toggle_class(
          div,
          "noglass",
          /*$UserDataStore*/
          ctx2[3].sh.noGlass
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$4O($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(3, $UserDataStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { noDecorations = false } = $$props;
  let { isLogin = false } = $$props;
  let loginBg = "";
  UserDataStore.subscribe(async (v2) => {
    $$invalidate(2, loginBg = (await getWallpaper(v2.acc.loginBackground, "img15")).url);
  });
  $$self.$$set = ($$props2) => {
    if ("noDecorations" in $$props2)
      $$invalidate(0, noDecorations = $$props2.noDecorations);
    if ("isLogin" in $$props2)
      $$invalidate(1, isLogin = $$props2.isLogin);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [noDecorations, isLogin, loginBg, $UserDataStore, $$scope, slots];
}
class ThemePreview extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4O, create_fragment$5f, safe_not_equal, { noDecorations: 0, isLogin: 1 });
  }
}
function create_fragment$5e(ctx) {
  let div3;
  let t2;
  let div4;
  return {
    c() {
      div3 = element("div");
      div3.innerHTML = `<div class="fake-header"></div> <div class="fake-text"></div> <div class="fake-button"></div>`;
      t2 = space();
      div4 = element("div");
      attr(div3, "class", "fake-window");
      attr(div4, "class", "fake-taskbar");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      insert(target, t2, anchor);
      insert(target, div4, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div3);
        detach(t2);
        detach(div4);
      }
    }
  };
}
let Desktop$1 = class Desktop extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$5e, safe_not_equal, {});
  }
};
function create_default_slot$u(ctx) {
  let desktop;
  let current;
  desktop = new Desktop$1({});
  return {
    c() {
      create_component(desktop.$$.fragment);
    },
    m(target, anchor) {
      mount_component(desktop, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(desktop.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(desktop.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(desktop, detaching);
    }
  };
}
function create_fragment$5d(ctx) {
  let themepreview;
  let t0;
  let div0;
  let t4;
  let input;
  let t5;
  let div1;
  let button0;
  let t7;
  let button1;
  let t8;
  let button1_disabled_value;
  let current;
  let mounted;
  let dispose;
  themepreview = new ThemePreview({
    props: {
      $$slots: { default: [create_default_slot$u] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(themepreview.$$.fragment);
      t0 = space();
      div0 = element("div");
      div0.innerHTML = `<h2>Save Theme</h2> <p>What a nice theme! Enter a fitting name for it:</p>`;
      t4 = space();
      input = element("input");
      t5 = space();
      div1 = element("div");
      button0 = element("button");
      button0.textContent = "Cancel";
      t7 = space();
      button1 = element("button");
      t8 = text("Save");
      attr(div0, "class", "header");
      attr(input, "type", "text");
      attr(button1, "class", "suggested");
      button1.disabled = button1_disabled_value = !/*themeName*/
      ctx[0];
      attr(div1, "class", "buttons");
    },
    m(target, anchor) {
      mount_component(themepreview, target, anchor);
      insert(target, t0, anchor);
      insert(target, div0, anchor);
      insert(target, t4, anchor);
      insert(target, input, anchor);
      set_input_value(
        input,
        /*themeName*/
        ctx[0]
      );
      insert(target, t5, anchor);
      insert(target, div1, anchor);
      append(div1, button0);
      append(div1, t7);
      append(div1, button1);
      append(button1, t8);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[4]
          ),
          listen(
            button0,
            "click",
            /*cancel*/
            ctx[2]
          ),
          listen(
            button1,
            "click",
            /*save*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const themepreview_changes = {};
      if (dirty & /*$$scope*/
      32) {
        themepreview_changes.$$scope = { dirty, ctx: ctx2 };
      }
      themepreview.$set(themepreview_changes);
      if (dirty & /*themeName*/
      1 && input.value !== /*themeName*/
      ctx2[0]) {
        set_input_value(
          input,
          /*themeName*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*themeName*/
      1 && button1_disabled_value !== (button1_disabled_value = !/*themeName*/
      ctx2[0])) {
        button1.disabled = button1_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(themepreview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(themepreview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div0);
        detach(t4);
        detach(input);
        detach(t5);
        detach(div1);
      }
      destroy_component(themepreview, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4N($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let themeName = "";
  function save2() {
    saveCurrentTheme(themeName);
    cancel();
  }
  function cancel() {
    ProcessStack.kill(runtime.pid, true);
  }
  function input_input_handler() {
    themeName = this.value;
    $$invalidate(0, themeName);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [themeName, save2, cancel, runtime, input_input_handler];
}
let SaveTheme$1 = class SaveTheme extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4N, create_fragment$5d, safe_not_equal, { runtime: 3 });
  }
};
const SaveTheme2 = {
  metadata: {
    name: "Save Theme",
    description: "Save your beautiful theme to your account",
    author: "ArcOS Team",
    version: "2.0.0",
    icon: SaveIcon
  },
  runtime: OverlayRuntime,
  size: { w: 350, h: 380 },
  minSize: { w: 350, h: 380 },
  maxSize: { w: 350, h: 380 },
  id: "SaveTheme",
  pos: {
    x: 0,
    y: 0
  },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: { minimize: false, maximize: false, close: false },
  content: SaveTheme$1
};
const SettingsOverlays = {
  ChangeUsername: ChangeUsername2,
  ChangePassword: ChangePassword2,
  CustomProfilePicture: CustomProfilePicture2,
  SaveTheme: SaveTheme2,
  CustomWallpaper: CustomWallpaper2,
  CustomLoginBackground: CustomLoginBackground2,
  AppInfo
};
const development = "" + new URL("devIcon-567f5f60.svg", import.meta.url).href;
const esr = "" + new URL("esr-9b05be30.png", import.meta.url).href;
const GlowingLogo$1 = "" + new URL("glowing-480658ca.png", import.meta.url).href;
const rc = "" + new URL("rc-d6342559.png", import.meta.url).href;
const ReleaseLogo = "" + new URL("systemIcon-dccbf8eb.svg", import.meta.url).href;
const unstable = "" + new URL("unstIcon-118758aa.png", import.meta.url).href;
const Branding = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DevelopmentLogo: development,
  EsrLogo: esr,
  GlowingLogo: GlowingLogo$1,
  RcLogo: rc,
  ReleaseLogo,
  UnstableLogo: unstable
}, Symbol.toStringTag, { value: "Module" }));
const MODES = { release: ReleaseLogo, development, unstable, rc, esr };
const Logo = (m3) => MODES[m3 || ARCOS_MODE] || ReleaseLogo;
const GlowingLogo_svelte_svelte_type_style_lang = "";
function create_fragment$5c(ctx) {
  let img;
  let img_src_value;
  let img_class_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = Logo()))
        attr(img, "src", img_src_value);
      attr(img, "alt", ARCOS_MODE);
      attr(img, "class", img_class_value = null_to_empty(
        /*className*/
        ctx[0]
      ) + " svelte-jedqd");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*className*/
      1 && img_class_value !== (img_class_value = null_to_empty(
        /*className*/
        ctx2[0]
      ) + " svelte-jedqd")) {
        attr(img, "class", img_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function instance$4M($$self, $$props, $$invalidate) {
  let { className = "glowing-logo" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(0, className = $$props2.className);
  };
  return [className];
}
class GlowingLogo extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4M, create_fragment$5c, safe_not_equal, { className: 0 });
  }
}
async function GetHelp(article) {
  const helpPid = ProcessStack.getAppPids("HelpSupport")[0];
  if (!helpPid) {
    await spawnApp("HelpSupport", 0, [article]);
    return;
  }
  ProcessStack.dispatch.dispatchToPid(helpPid, "change-article", article);
  focusedPid.set(helpPid);
}
const HelpArticles = {
  home: `@client/help/Home.md`,
  settings: `@client/help/Settings.md`,
  settingsAccount: `@client/help/Settings/account.md`,
  settingsAccountProfile: `@client/help/Settings/account/changeprofile.md`,
  settingsAccountCredentials: `@client/help/Settings/account/credentials.md`,
  settingsAccountDelete: `@client/help/Settings/account/delete.md`,
  settingsThemes: `@client/help/Settings/themes.md`,
  settingsThemesStyle: `@client/help/Settings/themes/style.md`,
  settingsThemesApply: `@client/help/Settings/themes/apply.md`,
  settingsThemesSave: `@client/help/Settings/themes/save.md`,
  settingsThemesDelete: `@client/help/Settings/themes/delete.md`,
  settingsWallpaper: `@client/help/Settings/wallpaper.md`,
  settingsWallpaperApply: `@client/help/Settings/wallpaper/apply.md`,
  settingsWallpaperUpload: `@client/help/Settings/wallpaper/upload.md`,
  settingsWallpaperUrl: `@client/help/Settings/wallpaper/url.md`,
  settingsLogin: `@client/help/Settings/login.md`,
  settingsLoginApply: `@client/help/Settings/login/apply.md`,
  settingsLoginUrl: `@client/help/Settings/login/url.md`,
  settingsLoginReset: `@client/help/Settings/login/reset.md`,
  settingsVisuals: `@client/help/Settings/visuals.md`,
  settingsShell: `@client/help/Settings/shell.md`,
  settingsWindows: `@client/help/Settings/windows.md`,
  settingsApps: `@client/help/Settings/apps.md`,
  contact: `@client/help/Contact.md`,
  debug: `@client/help/Debug.md`,
  qlorb: `@client/help/Qlorb.md`,
  processManager: `@client/help/ProcessManager.md`,
  processManagerProcesses: `@client/help/ProcessManager.md`,
  processManagerServices: `@client/help/ProcessManager/services.md`,
  processManagerSecurity: `@client/help/ProcessManager/security.md`,
  fileManager: `@client/help/FileManager.md`,
  fileManagerSystemFolders: `@client/help/FileManager/SystemFolders.md`,
  fileManagerCreateFileFolder: `@client/help/FileManager/CreateFileFolder.md`,
  fileManagerUploading: `@client/help/FileManager/Uploading.md`,
  fileManagerOpening: `@client/help/FileManager/Opening.md`,
  logging: `@client/help/Logging.md`,
  loggingLevels: `@client/help/Logging/Levels.md`,
  lightsOff: `@client/help/LightsOff.md`,
  markdownViewer: `@client/help/MarkDownViewer.md`,
  imageViewer: `@client/help/ImageViewer.md`,
  mediaPlayer: `@client/help/MediaPlayer.md`,
  writer: `@client/help/Writer.md`,
  $unfinished: `@client/help/$unfinished.md`
};
function create_fragment$5b(ctx) {
  let glowinglogo;
  let t0;
  let h1;
  let t3;
  let p0;
  let t4;
  let br0;
  let br1;
  let t5;
  let button0;
  let t7;
  let t8;
  let p1;
  let t9;
  let t10;
  let t11;
  let t12;
  let t13;
  let t14;
  let t15;
  let button1;
  let current;
  let mounted;
  let dispose;
  glowinglogo = new GlowingLogo({ props: { className: "logo" } });
  return {
    c() {
      create_component(glowinglogo.$$.fragment);
      t0 = space();
      h1 = element("h1");
      h1.innerHTML = `ArcOS <span class="colored">v6</span>`;
      t3 = space();
      p0 = element("p");
      t4 = text("Thank you for using ArcOS! We're constantly working on improving it to give you the best\n  experience possible. Curious who works on ArcOS? Go ahead and visit our Frontend GitHub page, we\n  list our contributors there.\n  ");
      br0 = element("br");
      br1 = element("br");
      t5 = text("\n  Want to contact us?\n  ");
      button0 = element("button");
      button0.textContent = "Do so here";
      t7 = text(".");
      t8 = space();
      p1 = element("p");
      t9 = text("v");
      t10 = text(ArcOSVersion);
      t11 = text("-");
      t12 = text(ARCOS_MODE);
      t13 = space();
      t14 = text(ARCOS_BUILD);
      t15 = text(" - ");
      button1 = element("button");
      button1.textContent = "License";
      attr(button0, "class", "link");
      attr(button1, "class", "link");
      attr(p1, "class", "version");
    },
    m(target, anchor) {
      mount_component(glowinglogo, target, anchor);
      insert(target, t0, anchor);
      insert(target, h1, anchor);
      insert(target, t3, anchor);
      insert(target, p0, anchor);
      append(p0, t4);
      append(p0, br0);
      append(p0, br1);
      append(p0, t5);
      append(p0, button0);
      append(p0, t7);
      insert(target, t8, anchor);
      insert(target, p1, anchor);
      append(p1, t9);
      append(p1, t10);
      append(p1, t11);
      append(p1, t12);
      append(p1, t13);
      append(p1, t14);
      append(p1, t15);
      append(p1, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*contact*/
            ctx[0]
          ),
          listen(
            button1,
            "click",
            /*license*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(glowinglogo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(glowinglogo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(h1);
        detach(t3);
        detach(p0);
        detach(t8);
        detach(p1);
      }
      destroy_component(glowinglogo, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4L($$self) {
  function contact() {
    GetHelp(HelpArticles.contact);
  }
  async function license() {
    const partial = await getPartialFile("@client/README.md");
    openFileWithApp("MarkDownViewer", partial);
  }
  return [contact, license];
}
class About extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4L, create_fragment$5b, safe_not_equal, {});
  }
}
const WindowSnappingIcons = {
  left: "arrow_backward",
  right: "arrow_forward",
  $1: "",
  top: "arrow_upward",
  bottom: "arrow_downward",
  $2: "",
  "top-left": "north_west",
  "top-right": "north_east",
  $3: "",
  "bottom-left": "south_west",
  "bottom-right": "south_east"
};
const WindowSnappingStates = {
  left: "Left",
  right: "Right",
  $1: "",
  top: "Top",
  bottom: "Bottom",
  $2: "",
  "top-left": "Top Left",
  "top-right": "Top Right",
  $3: "",
  "bottom-left": "Bottom Left",
  "bottom-right": "Bottom Right"
};
function CompileSnappingContextOption() {
  const root = {
    caption: "Window Snapping",
    icon: "center_focus_weak",
    disabled: (window2) => !!window2.isOverlay || !window2.controls.maximize,
    subItems: [
      {
        caption: "None",
        icon: "close",
        action(window2) {
          ProcessStack.dispatch.dispatchToPid(window2.pid, "snapping-disable");
        }
      },
      SEP_ITEM
    ]
  };
  for (const state in WindowSnappingStates) {
    const caption = WindowSnappingStates[state];
    if (state.startsWith("$")) {
      root.subItems.push(SEP_ITEM);
      continue;
    }
    root.subItems.push({
      caption,
      icon: WindowSnappingIcons[state],
      action(window2) {
        ProcessStack.dispatch.dispatchToPid(window2.pid, "snapping-set", state);
      }
    });
  }
  return root;
}
const BaseAppContext = {
  titlebar: [
    {
      caption: "App Info",
      icon: "info_outline",
      action(window2) {
        const AppInfo2 = getAppById("AppInfo");
        spawnOverlay(AppInfo2, window2.pid, [window2.id]);
      }
    },
    {
      caption: "Get Help",
      icon: "question_mark",
      disabled: (window2) => !window2.helpArticle,
      action(window2) {
        GetHelp(window2.helpArticle);
      }
    },
    SEP_ITEM,
    {
      caption: "Minimize",
      icon: "minimize",
      disabled: (window2) => !window2.controls.minimize || window2.state.minimized,
      action: (window2) => {
        ProcessStack.dispatch.dispatchToPid(window2.pid, "minimize");
      }
    },
    {
      caption: "Maximize",
      icon: "crop_square",
      disabled: (window2) => !window2.controls.maximize,
      action: (window2) => {
        ProcessStack.dispatch.dispatchToPid(window2.pid, "maximize");
      }
    },
    SEP_ITEM,
    CompileSnappingContextOption(),
    SEP_ITEM,
    {
      caption: "Close",
      image: ShutdownIcon,
      disabled: (window2) => window2.metadata.core,
      action: (window2) => {
        ProcessStack.kill(window2.pid, true);
      }
    }
  ]
};
function getAppById(id, override) {
  const library = appLibrary.get();
  if (!library.has(id) && !override)
    return null;
  const app = override || library.get(id);
  const runtime = app.runtime;
  const content = app.content;
  const loadCondition = app.loadCondition;
  const spawnCondition = app.spawnCondition;
  const contextMenu = { ...app.contextMenu, ...BaseAppContext };
  const accelerators = app.accelerators;
  const isolated = JSON.parse(JSON.stringify(app));
  return {
    ...isolated,
    runtime,
    content,
    loadCondition,
    spawnCondition,
    contextMenu,
    accelerators
  };
}
async function spawnApp(id, parent, args, processHandler = ProcessStack, data2 = null) {
  Log("apps/spawn", `Spawning app with ID ${id} on handler ${processHandler.id}`);
  class AppProcess extends Process {
    constructor(handler, pid, name, app2, args2 = []) {
      super(handler, pid, name, app2, args2);
      this.setParentPid(parent);
    }
  }
  const app = data2 || getAppById(id);
  const closedPids = processHandler.closedPids.get();
  const instances = processHandler.getAppPids(id).filter((p2) => !closedPids.includes(p2));
  if (!app)
    return "err_noExist";
  if (app.singleInstance && instances.length) {
    focusedPid.set(instances[0]);
    Log(
      "apps/spawn",
      `Not spawning as ${id} is SingleInstance, focussing opened instance instead.`,
      LogLevel.warn
    );
    return instances[0];
  }
  if (app.elevated) {
    const elevated = await GetUserElevation(ElevatedAppLaunchData(app), ProcessStack);
    if (!elevated)
      return "err_elevation";
  }
  if (app.spawnCondition) {
    const canSpawn = await app.spawnCondition();
    if (!canSpawn)
      return "err_spawnCondition";
  }
  const proc = await processHandler.spawn({
    proc: AppProcess,
    name: `app#${id}`,
    app,
    args
  });
  if (typeof proc == "string")
    return proc;
  return proc.pid;
}
async function spawnOverlay(app, parent, args, noShade, processHandler = ProcessStack) {
  if (!app)
    return;
  Log("apps/spawn", `Spawning overlay with ID ${app.id} on handler ${processHandler.id}`);
  app = getAppById(null, { ...app, isOverlay: true, noOverlayShade: noShade });
  if (app.elevated) {
    const elevated = await GetUserElevation(ElevatedAppLaunchData(app), ProcessStack);
    if (!elevated)
      return "err_elevation";
  }
  if (!processHandler.isPid(parent))
    return "err_parentNoExist";
  class OverlayProcess extends Process {
    constructor(handler, pid, name, app2, args2 = []) {
      super(handler, pid, name, app2, args2);
      this.setParentPid(parent);
    }
  }
  return await processHandler.spawn({ proc: OverlayProcess, name: `overlay#${app.id}`, app, args });
}
let Runtime$j = class Runtime4 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "state");
    this.state = new StateHandler(app.id, SettingsStore(), "account");
    process.handler.dispatch.subscribe(process.pid, "change-page", (page) => {
      this.state.navigate(page);
    });
    const args = process.args;
    if (!args.length || typeof args[0] != "string")
      return;
    this.state.navigate(args[0]);
  }
  showOverlay(id, args = []) {
    this.Log(`Showing overlay ${id} (${args.length} arguments)`, "showOverlay");
    const overlay = SettingsOverlays[id];
    if (!overlay) {
      this.Log(
        `Can't show non-existent overlay ${id}. This is a bug.`,
        "showOverlay",
        LogLevel.error
      );
      return false;
    }
    spawnOverlay(overlay, this.process.pid, args);
  }
};
const ProfilePicture_svelte_svelte_type_style_lang = "";
function create_fragment$5a(ctx) {
  let div;
  let div_class_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = "pfprenderer " + /*className*/
      ctx[2] + " pfp svelte-r0qoi");
      set_style(div, "background-image", "url('" + /*src*/
      (ctx[0] || /*url*/
      ctx[3]) + "')");
      set_style(
        div,
        "--h",
        /*height*/
        ctx[1] + "px"
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*className*/
      4 && div_class_value !== (div_class_value = "pfprenderer " + /*className*/
      ctx2[2] + " pfp svelte-r0qoi")) {
        attr(div, "class", div_class_value);
      }
      if (dirty & /*src, url*/
      9) {
        set_style(div, "background-image", "url('" + /*src*/
        (ctx2[0] || /*url*/
        ctx2[3]) + "')");
      }
      if (dirty & /*height*/
      2) {
        set_style(
          div,
          "--h",
          /*height*/
          ctx2[1] + "px"
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$4K($$self, $$props, $$invalidate) {
  let { fallback = "" } = $$props;
  let { src = fallback || "" } = $$props;
  let { height } = $$props;
  let { className = "" } = $$props;
  let url = "";
  UserDataStore.subscribe((v2) => {
    if (!v2 || src)
      return $$invalidate(3, url = src);
    $$invalidate(3, url = fallback || getProfilePicture(v2.acc.profilePicture));
  });
  $$self.$$set = ($$props2) => {
    if ("fallback" in $$props2)
      $$invalidate(4, fallback = $$props2.fallback);
    if ("src" in $$props2)
      $$invalidate(0, src = $$props2.src);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
  };
  return [src, height, className, url, fallback];
}
class ProfilePicture extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4K, create_fragment$5a, safe_not_equal, {
      fallback: 4,
      src: 0,
      height: 1,
      className: 2
    });
  }
}
function create_fragment$59(ctx) {
  let button;
  let profilepicture;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: { height: 40, src: (
      /*pfp*/
      ctx[0]
    ) }
  });
  return {
    c() {
      button = element("button");
      create_component(profilepicture.$$.fragment);
      attr(button, "class", "picture-option");
      toggle_class(
        button,
        "selected",
        /*$UserDataStore*/
        ctx[2].acc.profilePicture == /*i*/
        ctx[1] + 1
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(profilepicture, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*apply*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      1)
        profilepicture_changes.src = /*pfp*/
        ctx2[0];
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*$UserDataStore, i*/
      6) {
        toggle_class(
          button,
          "selected",
          /*$UserDataStore*/
          ctx2[2].acc.profilePicture == /*i*/
          ctx2[1] + 1
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(profilepicture);
      mounted = false;
      dispose();
    }
  };
}
function instance$4J($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(2, $UserDataStore = $$value));
  let { pfp } = $$props;
  let { i: i2 } = $$props;
  function apply() {
    set_store_value(UserDataStore, $UserDataStore.acc.profilePicture = i2 + 1, $UserDataStore);
  }
  $$self.$$set = ($$props2) => {
    if ("pfp" in $$props2)
      $$invalidate(0, pfp = $$props2.pfp);
    if ("i" in $$props2)
      $$invalidate(1, i2 = $$props2.i);
  };
  return [pfp, i2, $UserDataStore, apply];
}
class PictureOption extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4J, create_fragment$59, safe_not_equal, { pfp: 0, i: 1 });
  }
}
function get_each_context$S(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  child_ctx[6] = i2;
  return child_ctx;
}
function create_each_block$S(ctx) {
  let pictureoption;
  let current;
  pictureoption = new PictureOption({
    props: { pfp: (
      /*pfp*/
      ctx[4]
    ), i: (
      /*i*/
      ctx[6]
    ) }
  });
  return {
    c() {
      create_component(pictureoption.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pictureoption, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(pictureoption.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pictureoption.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pictureoption, detaching);
    }
  };
}
function create_fragment$58(ctx) {
  let div0;
  let t0;
  let div1;
  let button0;
  let t2;
  let button1;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(Object.values(ProfilePictures));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$S(get_each_context$S(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      div1 = element("div");
      button0 = element("button");
      button0.textContent = "Custom...";
      t2 = space();
      button1 = element("button");
      button1.textContent = "Done";
      attr(div0, "class", "profile-pictures");
      attr(button1, "class", "suggested");
      attr(div1, "class", "actions");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      append(div1, button0);
      append(div1, t2);
      append(div1, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*custom*/
            ctx[1]
          ),
          listen(
            button1,
            "click",
            /*done*/
            ctx[0]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Object*/
      0) {
        each_value = ensure_array_like(Object.values(ProfilePictures));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$S(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$S(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4I($$self, $$props, $$invalidate) {
  let { editing } = $$props;
  let { runtime } = $$props;
  function done() {
    $$invalidate(2, editing = false);
  }
  function custom() {
    $$invalidate(2, editing = false);
    runtime.showOverlay("CustomProfilePicture");
  }
  $$self.$$set = ($$props2) => {
    if ("editing" in $$props2)
      $$invalidate(2, editing = $$props2.editing);
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [done, custom, editing, runtime];
}
class ChangeProfilePicture extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4I, create_fragment$58, safe_not_equal, { editing: 2, runtime: 3 });
  }
}
function create_fragment$57(ctx) {
  let div4;
  let div1;
  let div0;
  let p0;
  let t1;
  let p1;
  let t2;
  let t3;
  let button0;
  let t5;
  let div3;
  let div2;
  let t9;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      p0 = element("p");
      p0.textContent = "What's your name?";
      t1 = space();
      p1 = element("p");
      t2 = text(
        /*$UserName*/
        ctx[0]
      );
      t3 = space();
      button0 = element("button");
      button0.textContent = "edit";
      t5 = space();
      div3 = element("div");
      div2 = element("div");
      div2.innerHTML = `<p class="caption">Your password</p> <p class="value">••••••••••••••••••</p>`;
      t9 = space();
      button1 = element("button");
      button1.textContent = "edit";
      attr(p0, "class", "caption");
      attr(p1, "class", "value");
      attr(button0, "class", "edit material-icons-round");
      attr(div1, "class", "credential username");
      attr(div1, "data-contextmenu", "account-username");
      attr(button1, "class", "edit material-icons-round");
      attr(div3, "class", "credential password");
      attr(div3, "data-contextmenu", "account-password");
      attr(div4, "class", "credentials");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div1);
      append(div1, div0);
      append(div0, p0);
      append(div0, t1);
      append(div0, p1);
      append(p1, t2);
      append(div1, t3);
      append(div1, button0);
      append(div4, t5);
      append(div4, div3);
      append(div3, div2);
      append(div3, t9);
      append(div3, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*changeUsername*/
            ctx[1]
          ),
          listen(
            button1,
            "click",
            /*changePassword*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$UserName*/
      1)
        set_data(
          t2,
          /*$UserName*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4H($$self, $$props, $$invalidate) {
  let $UserName;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(0, $UserName = $$value));
  let { runtime } = $$props;
  function changeUsername2() {
    runtime.showOverlay("ChangeUsername");
  }
  function changePassword2() {
    runtime.showOverlay("ChangePassword");
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [$UserName, changeUsername2, changePassword2, runtime];
}
class Credentials extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4H, create_fragment$57, safe_not_equal, { runtime: 3 });
  }
}
function create_fragment$56(ctx) {
  let p2;
  let t4;
  let input_1;
  let mounted;
  let dispose;
  return {
    c() {
      p2 = element("p");
      p2.innerHTML = `Are you sure you want to delete your ArcOS account? This will delete any and all user data
  associated with this account. These changes cannot be reverted!<br/><br/>
  Type <code>I want to delete my account</code> to continue.`;
      t4 = space();
      input_1 = element("input");
      attr(input_1, "type", "text");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      insert(target, t4, anchor);
      insert(target, input_1, anchor);
      set_input_value(
        input_1,
        /*input*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen(
            input_1,
            "keydown",
            /*update*/
            ctx[1]
          ),
          listen(
            input_1,
            "keyup",
            /*update*/
            ctx[1]
          ),
          listen(
            input_1,
            "input",
            /*update*/
            ctx[1]
          ),
          listen(
            input_1,
            "input",
            /*input_1_input_handler*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*input*/
      1 && input_1.value !== /*input*/
      ctx2[0]) {
        set_input_value(
          input_1,
          /*input*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
        detach(t4);
        detach(input_1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4G($$self, $$props, $$invalidate) {
  let { disabled } = $$props;
  let input = "";
  onMount(() => {
    $$invalidate(2, disabled = true);
  });
  function update2() {
    $$invalidate(2, disabled = input != "I want to delete my account");
  }
  function input_1_input_handler() {
    input = this.value;
    $$invalidate(0, input);
  }
  $$self.$$set = ($$props2) => {
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
  };
  return [input, update2, disabled, input_1_input_handler];
}
class Dialog extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4G, create_fragment$56, safe_not_equal, { disabled: 2 });
  }
}
function create_fragment$55(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Delete account...";
      attr(button, "class", "delete");
      attr(button, "data-contextmenu", "account-delete");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*deleteAccount*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4F($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  function deleteAccount() {
    createErrorDialog(
      {
        title: "Delete ArcOS Account",
        component: Dialog,
        image: TrashIcon,
        buttons: [
          {
            caption: "Back to safety",
            action() {
            }
          },
          {
            caption: "Delete account",
            async action() {
              await deleteSelf(UserToken.get());
              localStorage.removeItem("arcos-remembered-token");
              restart$3();
            },
            suggested: true
          }
        ],
        sound: "arcos.dialog.warning"
      },
      runtime.pid,
      true
    );
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [deleteAccount, runtime];
}
class DeleteButton extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4F, create_fragment$55, safe_not_equal, { runtime: 1 });
  }
}
function create_fragment$54(ctx) {
  let div;
  let profilepicture;
  let t0;
  let button;
  let t1_value = (
    /*editing*/
    ctx[0] ? "close" : "edit"
  );
  let t1;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({ props: { height: 128 } });
  return {
    c() {
      div = element("div");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      button = element("button");
      t1 = text(t1_value);
      attr(button, "class", "edit-button material-icons-round");
      attr(div, "class", "pfp-wrapper");
      attr(div, "data-contextmenu", "account-pfp");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(profilepicture, div, null);
      append(div, t0);
      append(div, button);
      append(button, t1);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggle*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*editing*/
      1) && t1_value !== (t1_value = /*editing*/
      ctx2[0] ? "close" : "edit"))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(profilepicture);
      mounted = false;
      dispose();
    }
  };
}
function instance$4E($$self, $$props, $$invalidate) {
  let { editing } = $$props;
  function toggle() {
    $$invalidate(0, editing = !editing);
  }
  $$self.$$set = ($$props2) => {
    if ("editing" in $$props2)
      $$invalidate(0, editing = $$props2.editing);
  };
  return [editing, toggle];
}
class Profile extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4E, create_fragment$54, safe_not_equal, { editing: 0 });
  }
}
function create_else_block$A(ctx) {
  let changeprofilepicture;
  let updating_editing;
  let current;
  function changeprofilepicture_editing_binding(value) {
    ctx[3](value);
  }
  let changeprofilepicture_props = { runtime: (
    /*runtime*/
    ctx[0]
  ) };
  if (
    /*editing*/
    ctx[1] !== void 0
  ) {
    changeprofilepicture_props.editing = /*editing*/
    ctx[1];
  }
  changeprofilepicture = new ChangeProfilePicture({ props: changeprofilepicture_props });
  binding_callbacks.push(() => bind$1(changeprofilepicture, "editing", changeprofilepicture_editing_binding));
  return {
    c() {
      create_component(changeprofilepicture.$$.fragment);
    },
    m(target, anchor) {
      mount_component(changeprofilepicture, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const changeprofilepicture_changes = {};
      if (dirty & /*runtime*/
      1)
        changeprofilepicture_changes.runtime = /*runtime*/
        ctx2[0];
      if (!updating_editing && dirty & /*editing*/
      2) {
        updating_editing = true;
        changeprofilepicture_changes.editing = /*editing*/
        ctx2[1];
        add_flush_callback(() => updating_editing = false);
      }
      changeprofilepicture.$set(changeprofilepicture_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(changeprofilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(changeprofilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(changeprofilepicture, detaching);
    }
  };
}
function create_if_block$1W(ctx) {
  let profile;
  let updating_editing;
  let t0;
  let credentials;
  let t1;
  let deletebutton;
  let current;
  function profile_editing_binding(value) {
    ctx[2](value);
  }
  let profile_props = {};
  if (
    /*editing*/
    ctx[1] !== void 0
  ) {
    profile_props.editing = /*editing*/
    ctx[1];
  }
  profile = new Profile({ props: profile_props });
  binding_callbacks.push(() => bind$1(profile, "editing", profile_editing_binding));
  credentials = new Credentials({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  deletebutton = new DeleteButton({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(profile.$$.fragment);
      t0 = space();
      create_component(credentials.$$.fragment);
      t1 = space();
      create_component(deletebutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(profile, target, anchor);
      insert(target, t0, anchor);
      mount_component(credentials, target, anchor);
      insert(target, t1, anchor);
      mount_component(deletebutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const profile_changes = {};
      if (!updating_editing && dirty & /*editing*/
      2) {
        updating_editing = true;
        profile_changes.editing = /*editing*/
        ctx2[1];
        add_flush_callback(() => updating_editing = false);
      }
      profile.$set(profile_changes);
      const credentials_changes = {};
      if (dirty & /*runtime*/
      1)
        credentials_changes.runtime = /*runtime*/
        ctx2[0];
      credentials.$set(credentials_changes);
      const deletebutton_changes = {};
      if (dirty & /*runtime*/
      1)
        deletebutton_changes.runtime = /*runtime*/
        ctx2[0];
      deletebutton.$set(deletebutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(profile.$$.fragment, local);
      transition_in(credentials.$$.fragment, local);
      transition_in(deletebutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profile.$$.fragment, local);
      transition_out(credentials.$$.fragment, local);
      transition_out(deletebutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(profile, detaching);
      destroy_component(credentials, detaching);
      destroy_component(deletebutton, detaching);
    }
  };
}
function create_fragment$53(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1W, create_else_block$A];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*editing*/
    ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$4D($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let editing = false;
  function profile_editing_binding(value) {
    editing = value;
    $$invalidate(1, editing);
  }
  function changeprofilepicture_editing_binding(value) {
    editing = value;
    $$invalidate(1, editing);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [
    runtime,
    editing,
    profile_editing_binding,
    changeprofilepicture_editing_binding
  ];
}
class Account extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4D, create_fragment$53, safe_not_equal, { runtime: 0 });
  }
}
function create_fragment$52(ctx) {
  let div1;
  let p0;
  let t0_value = (
    /*$appLibrary*/
    ctx[0].size + ""
  );
  let t0;
  let t1;
  let t2;
  let div0;
  let p1;
  let t4;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      p0 = element("p");
      t0 = text(t0_value);
      t1 = text(" loaded applications");
      t2 = space();
      div0 = element("div");
      p1 = element("p");
      p1.textContent = "Show hidden applications";
      t4 = space();
      input = element("input");
      attr(p0, "class", "app-count");
      attr(input, "type", "checkbox");
      attr(div0, "class", "right");
      attr(div1, "class", "bottom");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, p0);
      append(p0, t0);
      append(p0, t1);
      append(div1, t2);
      append(div1, div0);
      append(div0, p1);
      append(div0, t4);
      append(div0, input);
      input.checked = /*$UserDataStore*/
      ctx[1].sh.showHiddenApps;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$appLibrary*/
      1 && t0_value !== (t0_value = /*$appLibrary*/
      ctx2[0].size + ""))
        set_data(t0, t0_value);
      if (dirty & /*$UserDataStore*/
      2) {
        input.checked = /*$UserDataStore*/
        ctx2[1].sh.showHiddenApps;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4C($$self, $$props, $$invalidate) {
  let $appLibrary;
  let $UserDataStore;
  component_subscribe($$self, appLibrary, ($$value) => $$invalidate(0, $appLibrary = $$value));
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(1, $UserDataStore = $$value));
  function input_change_handler() {
    $UserDataStore.sh.showHiddenApps = this.checked;
    UserDataStore.set($UserDataStore);
  }
  return [$appLibrary, $UserDataStore, input_change_handler];
}
let Bottom$3 = class Bottom2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4C, create_fragment$52, safe_not_equal, {});
  }
};
function create_fragment$51(ctx) {
  let div;
  let span;
  let t1;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = "search";
      t1 = space();
      input = element("input");
      attr(span, "class", "material-icons-round icon");
      attr(input, "type", "text");
      attr(input, "placeholder", "Search");
      attr(div, "class", "search-field");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t1);
      append(div, input);
      set_input_value(
        input,
        /*$query*/
        ctx[1]
      );
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$query*/
      2 && input.value !== /*$query*/
      ctx2[1]) {
        set_input_value(
          input,
          /*$query*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4B($$self, $$props, $$invalidate) {
  let $query, $$unsubscribe_query = noop$1, $$subscribe_query = () => ($$unsubscribe_query(), $$unsubscribe_query = subscribe(query, ($$value) => $$invalidate(1, $query = $$value)), query);
  $$self.$$.on_destroy.push(() => $$unsubscribe_query());
  let { query } = $$props;
  $$subscribe_query();
  function input_input_handler() {
    $query = this.value;
    query.set($query);
  }
  $$self.$$set = ($$props2) => {
    if ("query" in $$props2)
      $$subscribe_query($$invalidate(0, query = $$props2.query));
  };
  return [query, $query, input_input_handler];
}
let Search$1 = class Search extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4B, create_fragment$51, safe_not_equal, { query: 0 });
  }
};
function get_each_context$R(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2][0];
  child_ctx[4] = list2[i2][1];
  return child_ctx;
}
function create_each_block$R(ctx) {
  let button;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[2](
        /*mode*/
        ctx[3]
      )
    );
  }
  return {
    c() {
      button = element("button");
      button.textContent = `${/*caption*/
      ctx[4]} `;
      attr(button, "class", "mode");
      toggle_class(
        button,
        "selected",
        /*view*/
        ctx[0] == /*mode*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*view, Object, MODES*/
      3) {
        toggle_class(
          button,
          "selected",
          /*view*/
          ctx[0] == /*mode*/
          ctx[3]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$50(ctx) {
  let div;
  let each_value = ensure_array_like(Object.entries(
    /*MODES*/
    ctx[1]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$R(get_each_context$R(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "view-modes");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*view, Object, MODES*/
      3) {
        each_value = ensure_array_like(Object.entries(
          /*MODES*/
          ctx2[1]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$R(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$R(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$4A($$self, $$props, $$invalidate) {
  let { view } = $$props;
  const MODES2 = {
    all: "All",
    user: "User",
    system: "Components"
  };
  const click_handler = (mode) => $$invalidate(0, view = mode);
  $$self.$$set = ($$props2) => {
    if ("view" in $$props2)
      $$invalidate(0, view = $$props2.view);
  };
  return [view, MODES2, click_handler];
}
class View extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4A, create_fragment$50, safe_not_equal, { view: 0 });
  }
}
function create_fragment$4$(ctx) {
  let div1;
  let view_1;
  let updating_view;
  let t0;
  let div0;
  let t1;
  let search2;
  let updating_query;
  let current;
  function view_1_view_binding(value) {
    ctx[2](value);
  }
  let view_1_props = {};
  if (
    /*view*/
    ctx[1] !== void 0
  ) {
    view_1_props.view = /*view*/
    ctx[1];
  }
  view_1 = new View({ props: view_1_props });
  binding_callbacks.push(() => bind$1(view_1, "view", view_1_view_binding));
  function search_query_binding(value) {
    ctx[3](value);
  }
  let search_props = {};
  if (
    /*query*/
    ctx[0] !== void 0
  ) {
    search_props.query = /*query*/
    ctx[0];
  }
  search2 = new Search$1({ props: search_props });
  binding_callbacks.push(() => bind$1(search2, "query", search_query_binding));
  return {
    c() {
      div1 = element("div");
      create_component(view_1.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = space();
      create_component(search2.$$.fragment);
      attr(div0, "class", "sep");
      attr(div1, "class", "filter");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(view_1, div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div1, t1);
      mount_component(search2, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const view_1_changes = {};
      if (!updating_view && dirty & /*view*/
      2) {
        updating_view = true;
        view_1_changes.view = /*view*/
        ctx2[1];
        add_flush_callback(() => updating_view = false);
      }
      view_1.$set(view_1_changes);
      const search_changes = {};
      if (!updating_query && dirty & /*query*/
      1) {
        updating_query = true;
        search_changes.query = /*query*/
        ctx2[0];
        add_flush_callback(() => updating_query = false);
      }
      search2.$set(search_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(view_1.$$.fragment, local);
      transition_in(search2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(view_1.$$.fragment, local);
      transition_out(search2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(view_1);
      destroy_component(search2);
    }
  };
}
function instance$4z($$self, $$props, $$invalidate) {
  let { query } = $$props;
  let { view } = $$props;
  function view_1_view_binding(value) {
    view = value;
    $$invalidate(1, view);
  }
  function search_query_binding(value) {
    query = value;
    $$invalidate(0, query);
  }
  $$self.$$set = ($$props2) => {
    if ("query" in $$props2)
      $$invalidate(0, query = $$props2.query);
    if ("view" in $$props2)
      $$invalidate(1, view = $$props2.view);
  };
  return [query, view, view_1_view_binding, search_query_binding];
}
let Filter$1 = class Filter extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4z, create_fragment$4$, safe_not_equal, { query: 0, view: 1 });
  }
};
function create_if_block$1V(ctx) {
  let button;
  let img;
  let img_src_value;
  let t0;
  let div;
  let p0;
  let t1_value = (
    /*app*/
    ctx[1].metadata.name + ""
  );
  let t1;
  let p0_title_value;
  let t2;
  let p1;
  let t3_value = (
    /*app*/
    ctx[1].metadata.description + ""
  );
  let t3;
  let t4;
  let t5_value = (
    /*app*/
    ctx[1].metadata.version + ""
  );
  let t5;
  let p1_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      div = element("div");
      p0 = element("p");
      t1 = text(t1_value);
      t2 = space();
      p1 = element("p");
      t3 = text(t3_value);
      t4 = text(" - v");
      t5 = text(t5_value);
      if (!src_url_equal(img.src, img_src_value = /*app*/
      ctx[1].metadata.icon))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*id*/
        ctx[0]
      );
      attr(p0, "class", "name");
      attr(p0, "title", p0_title_value = /*app*/
      ctx[1].metadata.name);
      attr(p1, "class", "author");
      attr(p1, "title", p1_title_value = /*app*/
      ctx[1].metadata.description);
      attr(button, "class", "app");
      toggle_class(
        button,
        "disabled",
        /*disabled*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, div);
      append(div, p0);
      append(p0, t1);
      append(div, t2);
      append(div, p1);
      append(p1, t3);
      append(p1, t4);
      append(p1, t5);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*showDetails*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*app*/
      2 && !src_url_equal(img.src, img_src_value = /*app*/
      ctx2[1].metadata.icon)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*id*/
      1) {
        attr(
          img,
          "alt",
          /*id*/
          ctx2[0]
        );
      }
      if (dirty & /*app*/
      2 && t1_value !== (t1_value = /*app*/
      ctx2[1].metadata.name + ""))
        set_data(t1, t1_value);
      if (dirty & /*app*/
      2 && p0_title_value !== (p0_title_value = /*app*/
      ctx2[1].metadata.name)) {
        attr(p0, "title", p0_title_value);
      }
      if (dirty & /*app*/
      2 && t3_value !== (t3_value = /*app*/
      ctx2[1].metadata.description + ""))
        set_data(t3, t3_value);
      if (dirty & /*app*/
      2 && t5_value !== (t5_value = /*app*/
      ctx2[1].metadata.version + ""))
        set_data(t5, t5_value);
      if (dirty & /*app*/
      2 && p1_title_value !== (p1_title_value = /*app*/
      ctx2[1].metadata.description)) {
        attr(p1, "title", p1_title_value);
      }
      if (dirty & /*disabled*/
      8) {
        toggle_class(
          button,
          "disabled",
          /*disabled*/
          ctx2[3]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4_(ctx) {
  let if_block_anchor;
  let if_block = (
    /*view*/
    (ctx[2] == "all" || /*view*/
    ctx[2] == "user" && !/*app*/
    ctx[1].metadata.hidden || /*view*/
    ctx[2] == "system" && /*app*/
    ctx[1].metadata.hidden) && create_if_block$1V(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*view*/
        ctx2[2] == "all" || /*view*/
        ctx2[2] == "user" && !/*app*/
        ctx2[1].metadata.hidden || /*view*/
        ctx2[2] == "system" && /*app*/
        ctx2[1].metadata.hidden
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1V(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$4y($$self, $$props, $$invalidate) {
  let { id } = $$props;
  let { app } = $$props;
  let { runtime } = $$props;
  let { view } = $$props;
  let disabled = false;
  UserDataStore.subscribe(() => {
    $$invalidate(3, disabled = isDisabled(id));
  });
  function showDetails() {
    runtime.showOverlay("AppInfo", [id]);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
    if ("view" in $$props2)
      $$invalidate(2, view = $$props2.view);
  };
  return [id, app, view, disabled, showDetails, runtime];
}
let App$q = class App5 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4y, create_fragment$4_, safe_not_equal, { id: 0, app: 1, runtime: 5, view: 2 });
  }
};
function get_each_context$Q(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list2[i2][0];
  child_ctx[10] = list2[i2][1];
  return child_ctx;
}
function create_if_block$1U(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like([.../*$appLibrary*/
  ctx[6]]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$Q(get_each_context$Q(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "apps-grid");
      attr(div, "data-contextmenu", "apps-grid");
      toggle_class(
        div,
        "list",
        /*$UserDataStore*/
        ctx[5].appdata["SettingsApp"] && /*$UserDataStore*/
        ctx[5].appdata["SettingsApp"].list
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*runtime, $appLibrary, view, filtering, filterResult*/
      93) {
        each_value = ensure_array_like([.../*$appLibrary*/
        ctx2[6]]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$Q(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$Q(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*$UserDataStore*/
      32) {
        toggle_class(
          div,
          "list",
          /*$UserDataStore*/
          ctx2[5].appdata["SettingsApp"] && /*$UserDataStore*/
          ctx2[5].appdata["SettingsApp"].list
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_1$F(ctx) {
  let app_1;
  let current;
  app_1 = new App$q({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      id: (
        /*id*/
        ctx[9]
      ),
      app: (
        /*app*/
        ctx[10]
      ),
      view: (
        /*view*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(app_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(app_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const app_1_changes = {};
      if (dirty & /*runtime*/
      1)
        app_1_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*$appLibrary*/
      64)
        app_1_changes.id = /*id*/
        ctx2[9];
      if (dirty & /*$appLibrary*/
      64)
        app_1_changes.app = /*app*/
        ctx2[10];
      if (dirty & /*view*/
      4)
        app_1_changes.view = /*view*/
        ctx2[2];
      app_1.$set(app_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(app_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(app_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(app_1, detaching);
    }
  };
}
function create_each_block$Q(ctx) {
  let show_if = !/*filtering*/
  ctx[4] || /*filterResult*/
  ctx[3].includes(
    /*id*/
    ctx[9]
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_1$F(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*filtering, filterResult, $appLibrary*/
      88)
        show_if = !/*filtering*/
        ctx2[4] || /*filterResult*/
        ctx2[3].includes(
          /*id*/
          ctx2[9]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*filtering, filterResult, $appLibrary*/
          88) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$F(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$4Z(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$UserDataStore*/
    ctx[5] && create_if_block$1U(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$UserDataStore*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$UserDataStore*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1U(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$4x($$self, $$props, $$invalidate) {
  let $query, $$unsubscribe_query = noop$1, $$subscribe_query = () => ($$unsubscribe_query(), $$unsubscribe_query = subscribe(query, ($$value) => $$invalidate(7, $query = $$value)), query);
  let $UserDataStore;
  let $appLibrary;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(5, $UserDataStore = $$value));
  component_subscribe($$self, appLibrary, ($$value) => $$invalidate(6, $appLibrary = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_query());
  let { runtime } = $$props;
  let { query } = $$props;
  $$subscribe_query();
  let { view } = $$props;
  let filterResult = [];
  let filtering = false;
  function filter2() {
    $$invalidate(3, filterResult = []);
    if (!$query) {
      $$invalidate(4, filtering = false);
      return;
    }
    $$invalidate(4, filtering = true);
    const library = appLibrary.get();
    const items = [];
    for (const [id, app] of library) {
      items.push({
        id,
        name: app.metadata.name,
        author: app.metadata.author
      });
    }
    const options2 = {
      includeScore: true,
      keys: ["id", "name", "author"],
      isCaseSensitive: false,
      threshold: 0.2
    };
    const fuse = new Fuse(items, options2);
    const results = fuse.search($query);
    for (const result of results) {
      filterResult.push(result.item.id);
    }
  }
  onMount(() => {
    query.subscribe(filter2);
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("query" in $$props2)
      $$subscribe_query($$invalidate(1, query = $$props2.query));
    if ("view" in $$props2)
      $$invalidate(2, view = $$props2.view);
  };
  return [runtime, query, view, filterResult, filtering, $UserDataStore, $appLibrary];
}
class Grid extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4x, create_fragment$4Z, safe_not_equal, { runtime: 0, query: 1, view: 2 });
  }
}
function create_fragment$4Y(ctx) {
  let filter2;
  let updating_view;
  let t0;
  let grid;
  let t1;
  let bottom;
  let current;
  function filter_view_binding(value) {
    ctx[3](value);
  }
  let filter_props = { query: (
    /*query*/
    ctx[2]
  ) };
  if (
    /*view*/
    ctx[1] !== void 0
  ) {
    filter_props.view = /*view*/
    ctx[1];
  }
  filter2 = new Filter$1({ props: filter_props });
  binding_callbacks.push(() => bind$1(filter2, "view", filter_view_binding));
  grid = new Grid({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      query: (
        /*query*/
        ctx[2]
      ),
      view: (
        /*view*/
        ctx[1]
      )
    }
  });
  bottom = new Bottom$3({});
  return {
    c() {
      create_component(filter2.$$.fragment);
      t0 = space();
      create_component(grid.$$.fragment);
      t1 = space();
      create_component(bottom.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filter2, target, anchor);
      insert(target, t0, anchor);
      mount_component(grid, target, anchor);
      insert(target, t1, anchor);
      mount_component(bottom, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const filter_changes = {};
      if (!updating_view && dirty & /*view*/
      2) {
        updating_view = true;
        filter_changes.view = /*view*/
        ctx2[1];
        add_flush_callback(() => updating_view = false);
      }
      filter2.$set(filter_changes);
      const grid_changes = {};
      if (dirty & /*runtime*/
      1)
        grid_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*view*/
      2)
        grid_changes.view = /*view*/
        ctx2[1];
      grid.$set(grid_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(filter2.$$.fragment, local);
      transition_in(grid.$$.fragment, local);
      transition_in(bottom.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filter2.$$.fragment, local);
      transition_out(grid.$$.fragment, local);
      transition_out(bottom.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(filter2, detaching);
      destroy_component(grid, detaching);
      destroy_component(bottom, detaching);
    }
  };
}
function instance$4w($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let query = Store$1("");
  let view = "all";
  function filter_view_binding(value) {
    view = value;
    $$invalidate(1, view);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, view, query, filter_view_binding];
}
class Apps extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4w, create_fragment$4Y, safe_not_equal, { runtime: 0 });
  }
}
function create_fragment$4X(ctx) {
  let button;
  let img;
  let img_src_value;
  let button_class_value;
  let button_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*wallpaper*/
      ctx[1].thumb))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*id*/
        ctx[0]
      );
      attr(button, "class", button_class_value = "theme-option wallpaper-" + /*id*/
      ctx[0]);
      attr(button, "title", button_title_value = /*wallpaper*/
      ctx[1].name + " by " + /*wallpaper*/
      ctx[1].author);
      toggle_class(
        button,
        "selected",
        /*$UserDataStore*/
        ctx[2].acc.loginBackground === /*id*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*select*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*wallpaper*/
      2 && !src_url_equal(img.src, img_src_value = /*wallpaper*/
      ctx2[1].thumb)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*id*/
      1) {
        attr(
          img,
          "alt",
          /*id*/
          ctx2[0]
        );
      }
      if (dirty & /*id*/
      1 && button_class_value !== (button_class_value = "theme-option wallpaper-" + /*id*/
      ctx2[0])) {
        attr(button, "class", button_class_value);
      }
      if (dirty & /*wallpaper*/
      2 && button_title_value !== (button_title_value = /*wallpaper*/
      ctx2[1].name + " by " + /*wallpaper*/
      ctx2[1].author)) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*id, $UserDataStore, id*/
      5) {
        toggle_class(
          button,
          "selected",
          /*$UserDataStore*/
          ctx2[2].acc.loginBackground === /*id*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4v($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(2, $UserDataStore = $$value));
  let { id } = $$props;
  let { wallpaper } = $$props;
  function select() {
    set_store_value(UserDataStore, $UserDataStore.acc.loginBackground = id, $UserDataStore);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("wallpaper" in $$props2)
      $$invalidate(1, wallpaper = $$props2.wallpaper);
  };
  return [id, wallpaper, $UserDataStore, select];
}
class ImageOption extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4v, create_fragment$4X, safe_not_equal, { id: 0, wallpaper: 1 });
  }
}
function get_each_context$P(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list2[i2][0];
  child_ctx[1] = list2[i2][1];
  return child_ctx;
}
function create_each_block$P(ctx) {
  let imageoption;
  let current;
  imageoption = new ImageOption({
    props: {
      id: (
        /*id*/
        ctx[0]
      ),
      wallpaper: (
        /*wallpaper*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(imageoption.$$.fragment);
    },
    m(target, anchor) {
      mount_component(imageoption, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(imageoption.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(imageoption.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(imageoption, detaching);
    }
  };
}
function create_fragment$4W(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(Object.entries(Wallpapers));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$P(get_each_context$P(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "theme-selector");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Object*/
      0) {
        each_value = ensure_array_like(Object.entries(Wallpapers));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$P(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$P(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
class ImageSelector extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$4W, safe_not_equal, {});
  }
}
function create_fragment$4V(ctx) {
  let div;
  let profilepicture;
  let t0;
  let p2;
  let t1;
  let current;
  profilepicture = new ProfilePicture({ props: { height: 40 } });
  return {
    c() {
      div = element("div");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      p2 = element("p");
      t1 = text(
        /*$UserName*/
        ctx[0]
      );
      attr(p2, "class", "name");
      attr(div, "class", "fake-login");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(profilepicture, div, null);
      append(div, t0);
      append(div, p2);
      append(p2, t1);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$UserName*/
      1)
        set_data(
          t1,
          /*$UserName*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(profilepicture);
    }
  };
}
function instance$4u($$self, $$props, $$invalidate) {
  let $UserName;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(0, $UserName = $$value));
  return [$UserName];
}
let Login$2 = class Login extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4u, create_fragment$4V, safe_not_equal, {});
  }
};
function create_if_block$1T(ctx) {
  let div6;
  let themepreview;
  let t0;
  let div5;
  let div1;
  let div0;
  let p0;
  let t2;
  let p1;
  let t3_value = (
    /*wallpaper*/
    ctx[0].name + ""
  );
  let t3;
  let t4;
  let div3;
  let div2;
  let p2;
  let t6;
  let p3;
  let t7_value = (
    /*wallpaper*/
    ctx[0].author + ""
  );
  let t7;
  let t8;
  let div4;
  let button0;
  let t10;
  let button1;
  let current;
  let mounted;
  let dispose;
  themepreview = new ThemePreview({
    props: {
      isLogin: true,
      $$slots: { default: [create_default_slot$t] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div6 = element("div");
      create_component(themepreview.$$.fragment);
      t0 = space();
      div5 = element("div");
      div1 = element("div");
      div0 = element("div");
      p0 = element("p");
      p0.textContent = "Name";
      t2 = space();
      p1 = element("p");
      t3 = text(t3_value);
      t4 = space();
      div3 = element("div");
      div2 = element("div");
      p2 = element("p");
      p2.textContent = "Author";
      t6 = space();
      p3 = element("p");
      t7 = text(t7_value);
      t8 = space();
      div4 = element("div");
      button0 = element("button");
      button0.textContent = "travel_explore";
      t10 = space();
      button1 = element("button");
      button1.textContent = "restart_alt";
      attr(p0, "class", "name");
      attr(p1, "class", "value");
      attr(div0, "class", "text");
      attr(div1, "class", "common-option");
      attr(p2, "class", "name");
      attr(p3, "class", "value");
      attr(div2, "class", "text");
      attr(div3, "class", "common-option");
      attr(button0, "class", "button material-icons-round");
      attr(button0, "title", "Login Background from URL");
      attr(button1, "class", "button material-icons-round");
      attr(button1, "title", "Use the default wallpaper");
      attr(div4, "class", "buttons");
      attr(div5, "class", "common");
      attr(div6, "class", "theme-overview");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      mount_component(themepreview, div6, null);
      append(div6, t0);
      append(div6, div5);
      append(div5, div1);
      append(div1, div0);
      append(div0, p0);
      append(div0, t2);
      append(div0, p1);
      append(p1, t3);
      append(div5, t4);
      append(div5, div3);
      append(div3, div2);
      append(div2, p2);
      append(div2, t6);
      append(div2, p3);
      append(p3, t7);
      append(div5, t8);
      append(div5, div4);
      append(div4, button0);
      append(div4, t10);
      append(div4, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*custom*/
            ctx[1]
          ),
          listen(
            button1,
            "click",
            /*reset*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const themepreview_changes = {};
      if (dirty & /*$$scope*/
      32) {
        themepreview_changes.$$scope = { dirty, ctx: ctx2 };
      }
      themepreview.$set(themepreview_changes);
      if ((!current || dirty & /*wallpaper*/
      1) && t3_value !== (t3_value = /*wallpaper*/
      ctx2[0].name + ""))
        set_data(t3, t3_value);
      if ((!current || dirty & /*wallpaper*/
      1) && t7_value !== (t7_value = /*wallpaper*/
      ctx2[0].author + ""))
        set_data(t7, t7_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(themepreview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(themepreview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      destroy_component(themepreview);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$t(ctx) {
  let login;
  let current;
  login = new Login$2({});
  return {
    c() {
      create_component(login.$$.fragment);
    },
    m(target, anchor) {
      mount_component(login, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(login.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(login.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(login, detaching);
    }
  };
}
function create_fragment$4U(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*wallpaper*/
    ctx[0] && create_if_block$1T(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*wallpaper*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*wallpaper*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1T(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$4t($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(4, $UserDataStore = $$value));
  let { runtime } = $$props;
  let wallpaper;
  UserDataStore.subscribe(async (v2) => {
    $$invalidate(0, wallpaper = await getWallpaper(v2.acc.loginBackground, "img15"));
  });
  function custom() {
    runtime.showOverlay("CustomLoginBackground");
  }
  function reset() {
    createErrorDialog(
      {
        title: "Reset login background?",
        message: "Are you sure you want to reset the login background? This will turn the login back to the factory default wallpaper.",
        buttons: [
          {
            caption: "No",
            action() {
            }
          },
          {
            caption: "Yes",
            action() {
              set_store_value(UserDataStore, $UserDataStore.acc.loginBackground = null, $UserDataStore);
            },
            suggested: true
          }
        ],
        image: QuestionIcon,
        sound: "arcos.dialog.warning"
      },
      runtime.pid,
      true
    );
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [wallpaper, custom, reset, runtime];
}
let Overview$1 = class Overview extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4t, create_fragment$4U, safe_not_equal, { runtime: 3 });
  }
};
function create_fragment$4T(ctx) {
  let overview;
  let t2;
  let imageselector;
  let current;
  overview = new Overview$1({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  imageselector = new ImageSelector({});
  return {
    c() {
      create_component(overview.$$.fragment);
      t2 = space();
      create_component(imageselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overview, target, anchor);
      insert(target, t2, anchor);
      mount_component(imageselector, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const overview_changes = {};
      if (dirty & /*runtime*/
      1)
        overview_changes.runtime = /*runtime*/
        ctx2[0];
      overview.$set(overview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(overview.$$.fragment, local);
      transition_in(imageselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overview.$$.fragment, local);
      transition_out(imageselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(overview, detaching);
      destroy_component(imageselector, detaching);
    }
  };
}
function instance$4s($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime];
}
let Login$1 = class Login2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4s, create_fragment$4T, safe_not_equal, { runtime: 0 });
  }
};
const SettingsOption_svelte_svelte_type_style_lang = "";
function create_fragment$4S(ctx) {
  let div2;
  let div0;
  let h3;
  let t0;
  let t1;
  let p2;
  let t2;
  let div1;
  let div2_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      h3 = element("h3");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      p2 = element("p");
      t2 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      attr(h3, "class", "header svelte-apc53m");
      toggle_class(
        h3,
        "asterisk",
        /*asterisk*/
        ctx[2]
      );
      attr(p2, "class", "context");
      attr(div1, "class", "option-input");
      attr(div2, "class", div2_class_value = "settings-option " + /*className*/
      ctx[3] + " svelte-apc53m");
      toggle_class(
        div2,
        "disabled",
        /*disabled*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, h3);
      append(h3, t0);
      append(div0, t1);
      append(div0, p2);
      p2.innerHTML = /*context*/
      ctx[1];
      append(div2, t2);
      append(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*title*/
      1)
        set_data(
          t0,
          /*title*/
          ctx2[0]
        );
      if (!current || dirty & /*asterisk*/
      4) {
        toggle_class(
          h3,
          "asterisk",
          /*asterisk*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*context*/
      2)
        p2.innerHTML = /*context*/
        ctx2[1];
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*className*/
      8 && div2_class_value !== (div2_class_value = "settings-option " + /*className*/
      ctx2[3] + " svelte-apc53m")) {
        attr(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*className, disabled*/
      24) {
        toggle_class(
          div2,
          "disabled",
          /*disabled*/
          ctx2[4]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$4r($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  let { context } = $$props;
  let { asterisk = false } = $$props;
  let { className = "" } = $$props;
  let { disabled = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("context" in $$props2)
      $$invalidate(1, context = $$props2.context);
    if ("asterisk" in $$props2)
      $$invalidate(2, asterisk = $$props2.asterisk);
    if ("className" in $$props2)
      $$invalidate(3, className = $$props2.className);
    if ("disabled" in $$props2)
      $$invalidate(4, disabled = $$props2.disabled);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [title, context, asterisk, className, disabled, $$scope, slots];
}
class SettingsOption extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4r, create_fragment$4S, safe_not_equal, {
      title: 0,
      context: 1,
      asterisk: 2,
      className: 3,
      disabled: 4
    });
  }
}
const TaskbarPosition_svelte_svelte_type_style_lang = "";
function get_each_context$O(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  return child_ctx;
}
function create_if_block$1S(ctx) {
  let div;
  let each_value = ensure_array_like(Object.entries(
    /*options*/
    ctx[2]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$O(get_each_context$O(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "taskbarpos svelte-1stc4vk");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, options, disabled, $UserDataStore*/
      7) {
        each_value = ensure_array_like(Object.entries(
          /*options*/
          ctx2[2]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$O(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$O(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$O(ctx) {
  let button;
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[3](
        /*opt*/
        ctx[4]
      )
    );
  }
  return {
    c() {
      button = element("button");
      t2 = text("vertical_align_bottom\n      ");
      attr(button, "class", "pos " + /*opt*/
      ctx[4][1] + " material-icons-round svelte-1stc4vk");
      button.disabled = /*disabled*/
      ctx[0];
      toggle_class(
        button,
        "selected",
        /*$UserDataStore*/
        ctx[1].sh.taskbar.pos == /*opt*/
        ctx[4][0]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*disabled*/
      1) {
        button.disabled = /*disabled*/
        ctx[0];
      }
      if (dirty & /*$UserDataStore, Object, options*/
      6) {
        toggle_class(
          button,
          "selected",
          /*$UserDataStore*/
          ctx[1].sh.taskbar.pos == /*opt*/
          ctx[4][0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4R(ctx) {
  let if_block_anchor;
  let if_block = (
    /*$UserDataStore*/
    ctx[1] && create_if_block$1S(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*$UserDataStore*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1S(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$4q($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(1, $UserDataStore = $$value));
  let { disabled = false } = $$props;
  const options2 = {
    vertical: "left",
    "": "bottom",
    "vertical-right": "right",
    top: "top"
  };
  const click_handler = (opt) => set_store_value(UserDataStore, $UserDataStore.sh.taskbar.pos = opt[0], $UserDataStore);
  $$self.$$set = ($$props2) => {
    if ("disabled" in $$props2)
      $$invalidate(0, disabled = $$props2.disabled);
  };
  return [disabled, $UserDataStore, options2, click_handler];
}
class TaskbarPosition extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4q, create_fragment$4R, safe_not_equal, { disabled: 0 });
  }
}
function create_default_slot_6$4(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.taskbar.centered;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.taskbar.centered;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_5$4(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.taskbar.labels;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_1*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.taskbar.labels;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_4$5(ctx) {
  let taskbarposition;
  let current;
  taskbarposition = new TaskbarPosition({});
  return {
    c() {
      create_component(taskbarposition.$$.fragment);
    },
    m(target, anchor) {
      mount_component(taskbarposition, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(taskbarposition.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taskbarposition.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(taskbarposition, detaching);
    }
  };
}
function create_default_slot_3$b(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.taskbar.accentedStart;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_2*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.taskbar.accentedStart;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$g(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.start.noGroups;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_3*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.start.noGroups;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$i(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.taskbar.docked;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_4*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.taskbar.docked;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$s(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.compactContext;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_5*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.compactContext;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4Q(ctx) {
  let settingsoption0;
  let t0;
  let settingsoption1;
  let t1;
  let settingsoption2;
  let t2;
  let settingsoption3;
  let t3;
  let hr;
  let t4;
  let settingsoption4;
  let t5;
  let settingsoption5;
  let t6;
  let settingsoption6;
  let current;
  settingsoption0 = new SettingsOption({
    props: {
      title: "Center taskbar buttons",
      context: "Centers the taskbar app buttons",
      $$slots: { default: [create_default_slot_6$4] },
      $$scope: { ctx }
    }
  });
  settingsoption1 = new SettingsOption({
    props: {
      title: "Taskbar app labels",
      context: "Display app names on the taskbar",
      $$slots: { default: [create_default_slot_5$4] },
      $$scope: { ctx }
    }
  });
  settingsoption2 = new SettingsOption({
    props: {
      title: "Taskbar position",
      context: "Where do you want the taskbar?",
      $$slots: { default: [create_default_slot_4$5] },
      $$scope: { ctx }
    }
  });
  settingsoption3 = new SettingsOption({
    props: {
      title: "Accented start button",
      context: "Match the Start logo with your accent color",
      $$slots: { default: [create_default_slot_3$b] },
      $$scope: { ctx }
    }
  });
  settingsoption4 = new SettingsOption({
    props: {
      title: "Don't group start",
      context: "Disable the start menu app grouping",
      $$slots: { default: [create_default_slot_2$g] },
      $$scope: { ctx }
    }
  });
  settingsoption5 = new SettingsOption({
    props: {
      title: "Dock shell",
      context: "Dock the taskbar and action center",
      $$slots: { default: [create_default_slot_1$i] },
      $$scope: { ctx }
    }
  });
  settingsoption6 = new SettingsOption({
    props: {
      title: "Compact context menu",
      context: "Make the context menu more compact",
      $$slots: { default: [create_default_slot$s] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingsoption0.$$.fragment);
      t0 = space();
      create_component(settingsoption1.$$.fragment);
      t1 = space();
      create_component(settingsoption2.$$.fragment);
      t2 = space();
      create_component(settingsoption3.$$.fragment);
      t3 = space();
      hr = element("hr");
      t4 = space();
      create_component(settingsoption4.$$.fragment);
      t5 = space();
      create_component(settingsoption5.$$.fragment);
      t6 = space();
      create_component(settingsoption6.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingsoption0, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingsoption1, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingsoption2, target, anchor);
      insert(target, t2, anchor);
      mount_component(settingsoption3, target, anchor);
      insert(target, t3, anchor);
      insert(target, hr, anchor);
      insert(target, t4, anchor);
      mount_component(settingsoption4, target, anchor);
      insert(target, t5, anchor);
      mount_component(settingsoption5, target, anchor);
      insert(target, t6, anchor);
      mount_component(settingsoption6, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const settingsoption0_changes = {};
      if (dirty & /*$$scope, $UserDataStore*/
      129) {
        settingsoption0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption0.$set(settingsoption0_changes);
      const settingsoption1_changes = {};
      if (dirty & /*$$scope, $UserDataStore*/
      129) {
        settingsoption1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption1.$set(settingsoption1_changes);
      const settingsoption2_changes = {};
      if (dirty & /*$$scope*/
      128) {
        settingsoption2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption2.$set(settingsoption2_changes);
      const settingsoption3_changes = {};
      if (dirty & /*$$scope, $UserDataStore*/
      129) {
        settingsoption3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption3.$set(settingsoption3_changes);
      const settingsoption4_changes = {};
      if (dirty & /*$$scope, $UserDataStore*/
      129) {
        settingsoption4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption4.$set(settingsoption4_changes);
      const settingsoption5_changes = {};
      if (dirty & /*$$scope, $UserDataStore*/
      129) {
        settingsoption5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption5.$set(settingsoption5_changes);
      const settingsoption6_changes = {};
      if (dirty & /*$$scope, $UserDataStore*/
      129) {
        settingsoption6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption6.$set(settingsoption6_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingsoption0.$$.fragment, local);
      transition_in(settingsoption1.$$.fragment, local);
      transition_in(settingsoption2.$$.fragment, local);
      transition_in(settingsoption3.$$.fragment, local);
      transition_in(settingsoption4.$$.fragment, local);
      transition_in(settingsoption5.$$.fragment, local);
      transition_in(settingsoption6.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingsoption0.$$.fragment, local);
      transition_out(settingsoption1.$$.fragment, local);
      transition_out(settingsoption2.$$.fragment, local);
      transition_out(settingsoption3.$$.fragment, local);
      transition_out(settingsoption4.$$.fragment, local);
      transition_out(settingsoption5.$$.fragment, local);
      transition_out(settingsoption6.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(hr);
        detach(t4);
        detach(t5);
        detach(t6);
      }
      destroy_component(settingsoption0, detaching);
      destroy_component(settingsoption1, detaching);
      destroy_component(settingsoption2, detaching);
      destroy_component(settingsoption3, detaching);
      destroy_component(settingsoption4, detaching);
      destroy_component(settingsoption5, detaching);
      destroy_component(settingsoption6, detaching);
    }
  };
}
function instance$4p($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(0, $UserDataStore = $$value));
  function input_change_handler() {
    $UserDataStore.sh.taskbar.centered = this.checked;
    UserDataStore.set($UserDataStore);
  }
  function input_change_handler_1() {
    $UserDataStore.sh.taskbar.labels = this.checked;
    UserDataStore.set($UserDataStore);
  }
  function input_change_handler_2() {
    $UserDataStore.sh.taskbar.accentedStart = this.checked;
    UserDataStore.set($UserDataStore);
  }
  function input_change_handler_3() {
    $UserDataStore.sh.start.noGroups = this.checked;
    UserDataStore.set($UserDataStore);
  }
  function input_change_handler_4() {
    $UserDataStore.sh.taskbar.docked = this.checked;
    UserDataStore.set($UserDataStore);
  }
  function input_change_handler_5() {
    $UserDataStore.sh.compactContext = this.checked;
    UserDataStore.set($UserDataStore);
  }
  return [
    $UserDataStore,
    input_change_handler,
    input_change_handler_1,
    input_change_handler_2,
    input_change_handler_3,
    input_change_handler_4,
    input_change_handler_5
  ];
}
class Shell extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4p, create_fragment$4Q, safe_not_equal, {});
  }
}
function create_fragment$4P(ctx) {
  let div;
  let button;
  let t2;
  let input;
  let input_value_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      t2 = space();
      input = element("input");
      attr(button, "class", "accent-circle");
      set_style(button, "background-color", "#" + /*hex*/
      ctx[0]);
      attr(input, "type", "color");
      attr(input, "class", "picker no-display");
      input.value = input_value_value = "#" + /*hex*/
      ctx[0];
      attr(div, "class", "right");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(div, t2);
      append(div, input);
      ctx[4](input);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*openPicker*/
            ctx[2]
          ),
          listen(
            input,
            "input",
            /*pickerInput*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*hex*/
      1) {
        set_style(button, "background-color", "#" + /*hex*/
        ctx2[0]);
      }
      if (dirty & /*hex*/
      1 && input_value_value !== (input_value_value = "#" + /*hex*/
      ctx2[0])) {
        input.value = input_value_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[4](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4o($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(5, $UserDataStore = $$value));
  let hex = "70D6FF";
  let picker;
  function openPicker() {
    picker.click();
  }
  UserDataStore.subscribe((v2) => {
    if (v2.sh.desktop.accent !== hex)
      $$invalidate(0, hex = v2.sh.desktop.accent);
  });
  function pickerInput() {
    $$invalidate(0, hex = picker.value.replace("#", "").toUpperCase());
    set_store_value(UserDataStore, $UserDataStore.sh.desktop.accent = hex, $UserDataStore);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      picker = $$value;
      $$invalidate(1, picker);
    });
  }
  return [hex, picker, openPicker, pickerInput, input_binding];
}
class AccentColor extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4o, create_fragment$4P, safe_not_equal, {});
  }
}
function create_default_slot$r(ctx) {
  let desktop;
  let current;
  desktop = new Desktop$1({});
  return {
    c() {
      create_component(desktop.$$.fragment);
    },
    m(target, anchor) {
      mount_component(desktop, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(desktop.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(desktop.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(desktop, detaching);
    }
  };
}
function create_fragment$4O(ctx) {
  let div5;
  let themepreview;
  let t0;
  let div4;
  let div1;
  let div0;
  let p0;
  let t2;
  let p1;
  let t3;
  let t4_value = (
    /*$UserDataStore*/
    ctx[0].sh.desktop.accent + ""
  );
  let t4;
  let t5;
  let accentcolor;
  let t6;
  let div3;
  let div2;
  let p2;
  let t8;
  let p3;
  let select;
  let option0;
  let option1;
  let option2;
  let option3;
  let option4;
  let option5;
  let t15;
  let button;
  let current;
  let mounted;
  let dispose;
  themepreview = new ThemePreview({
    props: {
      $$slots: { default: [create_default_slot$r] },
      $$scope: { ctx }
    }
  });
  accentcolor = new AccentColor({});
  return {
    c() {
      div5 = element("div");
      create_component(themepreview.$$.fragment);
      t0 = space();
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      p0 = element("p");
      p0.textContent = "Accent";
      t2 = space();
      p1 = element("p");
      t3 = text("#");
      t4 = text(t4_value);
      t5 = space();
      create_component(accentcolor.$$.fragment);
      t6 = space();
      div3 = element("div");
      div2 = element("div");
      p2 = element("p");
      p2.textContent = "Visual Style";
      t8 = space();
      p3 = element("p");
      select = element("select");
      option0 = element("option");
      option0.textContent = "Darkmode";
      option1 = element("option");
      option1.textContent = "Lightmode";
      option2 = element("option");
      option2.textContent = "Amoled";
      option3 = element("option");
      option3.textContent = "Amber Monochrome";
      option4 = element("option");
      option4.textContent = "Science Fiction";
      option5 = element("option");
      option5.textContent = "High contrast";
      t15 = space();
      button = element("button");
      button.textContent = "Save Theme...";
      attr(p0, "class", "name");
      attr(p1, "class", "value");
      attr(div0, "class", "text");
      attr(div1, "class", "common-option accent");
      attr(div1, "data-contextmenu", "themes-accent");
      attr(p2, "class", "name");
      option0.__value = "dark";
      set_input_value(option0, option0.__value);
      option1.__value = "light";
      set_input_value(option1, option1.__value);
      option2.__value = "amoled";
      set_input_value(option2, option2.__value);
      option3.__value = "amber";
      set_input_value(option3, option3.__value);
      option4.__value = "scifi";
      set_input_value(option4, option4.__value);
      option5.__value = "hc";
      set_input_value(option5, option5.__value);
      attr(select, "class", "flat");
      if (
        /*$UserDataStore*/
        ctx[0].sh.desktop.theme === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[4].call(select)
        ));
      attr(p3, "class", "value");
      attr(div2, "class", "text");
      attr(div3, "class", "common-option style");
      attr(div3, "data-contextmenu", "themes-accent");
      attr(button, "data-contextmenu", "themes-save");
      attr(button, "class", "save-theme");
      attr(div4, "class", "common");
      attr(div5, "class", "theme-overview");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      mount_component(themepreview, div5, null);
      append(div5, t0);
      append(div5, div4);
      append(div4, div1);
      append(div1, div0);
      append(div0, p0);
      append(div0, t2);
      append(div0, p1);
      append(p1, t3);
      append(p1, t4);
      append(div1, t5);
      mount_component(accentcolor, div1, null);
      append(div4, t6);
      append(div4, div3);
      append(div3, div2);
      append(div2, p2);
      append(div2, t8);
      append(div2, p3);
      append(p3, select);
      append(select, option0);
      append(select, option1);
      append(select, option2);
      append(select, option3);
      append(select, option4);
      append(select, option5);
      select_option(
        select,
        /*$UserDataStore*/
        ctx[0].sh.desktop.theme,
        true
      );
      append(div4, t15);
      append(div4, button);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[4]
          ),
          listen(
            button,
            "click",
            /*saveTheme*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const themepreview_changes = {};
      if (dirty & /*$$scope*/
      64) {
        themepreview_changes.$$scope = { dirty, ctx: ctx2 };
      }
      themepreview.$set(themepreview_changes);
      if ((!current || dirty & /*$UserDataStore*/
      1) && t4_value !== (t4_value = /*$UserDataStore*/
      ctx2[0].sh.desktop.accent + ""))
        set_data(t4, t4_value);
      if (dirty & /*$UserDataStore*/
      1) {
        select_option(
          select,
          /*$UserDataStore*/
          ctx2[0].sh.desktop.theme
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(themepreview.$$.fragment, local);
      transition_in(accentcolor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(themepreview.$$.fragment, local);
      transition_out(accentcolor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      destroy_component(themepreview);
      destroy_component(accentcolor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4n($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(0, $UserDataStore = $$value));
  let { handler } = $$props;
  let { runtime } = $$props;
  function saveTheme() {
    runtime.showOverlay("SaveTheme");
  }
  function select_change_handler() {
    $UserDataStore.sh.desktop.theme = select_value(this);
    UserDataStore.set($UserDataStore);
  }
  $$self.$$set = ($$props2) => {
    if ("handler" in $$props2)
      $$invalidate(2, handler = $$props2.handler);
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [$UserDataStore, saveTheme, handler, runtime, select_change_handler];
}
class ThemeOverview extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4n, create_fragment$4O, safe_not_equal, { handler: 2, runtime: 3 });
  }
}
function create_fragment$4N(ctx) {
  let button;
  let img;
  let img_src_value;
  let img_alt_value;
  let t2;
  let div1;
  let button_class_value;
  let button_title_value;
  let button_data_contextmenu_value;
  let button_data_theme_value;
  let button_data_name_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t2 = space();
      div1 = element("div");
      div1.innerHTML = `<div class="fake-button"></div>`;
      if (!src_url_equal(img.src, img_src_value = /*wallpaper*/
      ctx[3]))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*theme*/
      ctx[0].name);
      attr(div1, "class", "fake-window shell-colored");
      toggle_class(
        div1,
        "colored",
        /*theme*/
        ctx[0].taskbarColored
      );
      attr(button, "class", button_class_value = "theme-option theme-" + /*theme*/
      ctx[0].theme);
      set_style(button, "--accent", "#" + /*theme*/
      ctx[0].accent);
      attr(button, "title", button_title_value = /*theme*/
      ctx[0].name + " by " + /*theme*/
      ctx[0].author + " (version " + /*theme*/
      ctx[0].version + ")");
      attr(button, "data-contextmenu", button_data_contextmenu_value = /*user*/
      ctx[2] ? "user-theme" : "system-theme");
      attr(
        button,
        "data-id",
        /*id*/
        ctx[1]
      );
      attr(button, "data-theme", button_data_theme_value = JSON.stringify(
        /*theme*/
        ctx[0]
      ));
      attr(button, "data-name", button_data_name_value = /*theme*/
      ctx[0].name);
      toggle_class(
        button,
        "sharp",
        /*theme*/
        ctx[0].sharp
      );
      toggle_class(button, "noani", !/*theme*/
      ctx[0].anim);
      toggle_class(
        button,
        "noglass",
        /*theme*/
        ctx[0].noGlass
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t2);
      append(button, div1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*apply*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*wallpaper*/
      8 && !src_url_equal(img.src, img_src_value = /*wallpaper*/
      ctx2[3])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*theme*/
      1 && img_alt_value !== (img_alt_value = /*theme*/
      ctx2[0].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*theme*/
      1) {
        toggle_class(
          div1,
          "colored",
          /*theme*/
          ctx2[0].taskbarColored
        );
      }
      if (dirty & /*theme*/
      1 && button_class_value !== (button_class_value = "theme-option theme-" + /*theme*/
      ctx2[0].theme)) {
        attr(button, "class", button_class_value);
      }
      if (dirty & /*theme*/
      1) {
        set_style(button, "--accent", "#" + /*theme*/
        ctx2[0].accent);
      }
      if (dirty & /*theme*/
      1 && button_title_value !== (button_title_value = /*theme*/
      ctx2[0].name + " by " + /*theme*/
      ctx2[0].author + " (version " + /*theme*/
      ctx2[0].version + ")")) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*user*/
      4 && button_data_contextmenu_value !== (button_data_contextmenu_value = /*user*/
      ctx2[2] ? "user-theme" : "system-theme")) {
        attr(button, "data-contextmenu", button_data_contextmenu_value);
      }
      if (dirty & /*id*/
      2) {
        attr(
          button,
          "data-id",
          /*id*/
          ctx2[1]
        );
      }
      if (dirty & /*theme*/
      1 && button_data_theme_value !== (button_data_theme_value = JSON.stringify(
        /*theme*/
        ctx2[0]
      ))) {
        attr(button, "data-theme", button_data_theme_value);
      }
      if (dirty & /*theme*/
      1 && button_data_name_value !== (button_data_name_value = /*theme*/
      ctx2[0].name)) {
        attr(button, "data-name", button_data_name_value);
      }
      if (dirty & /*theme, theme*/
      1) {
        toggle_class(
          button,
          "sharp",
          /*theme*/
          ctx2[0].sharp
        );
      }
      if (dirty & /*theme, theme*/
      1) {
        toggle_class(button, "noani", !/*theme*/
        ctx2[0].anim);
      }
      if (dirty & /*theme, theme*/
      1) {
        toggle_class(
          button,
          "noglass",
          /*theme*/
          ctx2[0].noGlass
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4m($$self, $$props, $$invalidate) {
  let { theme } = $$props;
  let { id = "" } = $$props;
  let { user = false } = $$props;
  let wallpaper = "";
  onMount(async () => {
    const data2 = await getWallpaper(theme.wallpaper);
    $$invalidate(3, wallpaper = data2.builtin ? data2.thumb : data2.url);
  });
  function apply() {
    loadTheme(theme);
  }
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("user" in $$props2)
      $$invalidate(2, user = $$props2.user);
  };
  return [theme, id, user, wallpaper, apply];
}
class ThemeOption extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4m, create_fragment$4N, safe_not_equal, { theme: 0, id: 1, user: 2 });
  }
}
function get_each_context$N(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function get_each_context_1$7(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list2[i2][0];
  child_ctx[3] = list2[i2][1];
  return child_ctx;
}
function create_each_block_1$7(ctx) {
  let themeoption;
  let current;
  themeoption = new ThemeOption({
    props: {
      theme: (
        /*theme*/
        ctx[3]
      ),
      id: (
        /*id*/
        ctx[6]
      )
    }
  });
  return {
    c() {
      create_component(themeoption.$$.fragment);
    },
    m(target, anchor) {
      mount_component(themeoption, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(themeoption.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(themeoption.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(themeoption, detaching);
    }
  };
}
function create_if_block$1R(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(Object.entries(
    /*$UserDataStore*/
    ctx[1].sh.userThemes
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$N(get_each_context$N(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, $UserDataStore*/
      2) {
        each_value = ensure_array_like(Object.entries(
          /*$UserDataStore*/
          ctx2[1].sh.userThemes
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$N(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$N(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$N(ctx) {
  let themeoption;
  let current;
  themeoption = new ThemeOption({
    props: {
      theme: (
        /*theme*/
        ctx[3][1]
      ),
      id: (
        /*theme*/
        ctx[3][0]
      ),
      user: true
    }
  });
  return {
    c() {
      create_component(themeoption.$$.fragment);
    },
    m(target, anchor) {
      mount_component(themeoption, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const themeoption_changes = {};
      if (dirty & /*$UserDataStore*/
      2)
        themeoption_changes.theme = /*theme*/
        ctx2[3][1];
      if (dirty & /*$UserDataStore*/
      2)
        themeoption_changes.id = /*theme*/
        ctx2[3][0];
      themeoption.$set(themeoption_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(themeoption.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(themeoption.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(themeoption, detaching);
    }
  };
}
function create_fragment$4M(ctx) {
  let div;
  let t2;
  let current;
  let each_value_1 = ensure_array_like(Object.entries(BuiltinThemes));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$7(get_each_context_1$7(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = !/*reload*/
  ctx[0] && /*$UserDataStore*/
  ctx[1].sh.userThemes && create_if_block$1R(ctx);
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "theme-selector");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      append(div, t2);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Object*/
      0) {
        each_value_1 = ensure_array_like(Object.entries(BuiltinThemes));
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$7(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$7(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, t2);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!/*reload*/
      ctx2[0] && /*$UserDataStore*/
      ctx2[1].sh.userThemes) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*reload, $UserDataStore*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1R(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$4l($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(1, $UserDataStore = $$value));
  let oldlength = 0;
  let reload = false;
  UserDataStore.subscribe((v2) => {
    if (!v2 || !v2.sh || !v2.sh.userThemes)
      return;
    const freshEntries = Object.entries(v2.sh.userThemes);
    if (oldlength == freshEntries.length)
      return;
    oldlength = freshEntries.length;
    $$invalidate(0, reload = true);
    setTimeout(() => {
      $$invalidate(0, reload = false);
    });
  });
  return [reload, $UserDataStore];
}
class ThemeSelector extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4l, create_fragment$4M, safe_not_equal, {});
  }
}
function create_fragment$4L(ctx) {
  let themeoverview;
  let t2;
  let themeselector;
  let current;
  themeoverview = new ThemeOverview({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      handler: (
        /*handler*/
        ctx[1]
      )
    }
  });
  themeselector = new ThemeSelector({});
  return {
    c() {
      create_component(themeoverview.$$.fragment);
      t2 = space();
      create_component(themeselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(themeoverview, target, anchor);
      insert(target, t2, anchor);
      mount_component(themeselector, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const themeoverview_changes = {};
      if (dirty & /*runtime*/
      1)
        themeoverview_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*handler*/
      2)
        themeoverview_changes.handler = /*handler*/
        ctx2[1];
      themeoverview.$set(themeoverview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(themeoverview.$$.fragment, local);
      transition_in(themeselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(themeoverview.$$.fragment, local);
      transition_out(themeselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(themeoverview, detaching);
      destroy_component(themeselector, detaching);
    }
  };
}
function instance$4k($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { handler } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("handler" in $$props2)
      $$invalidate(1, handler = $$props2.handler);
  };
  return [runtime, handler];
}
class Themes extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4k, create_fragment$4L, safe_not_equal, { runtime: 0, handler: 1 });
  }
}
function create_default_slot_4$4(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.anim;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.anim;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_3$a(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.noGlass;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_1*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.noGlass;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$f(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.desktop.sharp;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_2*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.desktop.sharp;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$h(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.desktop.noCustomCursor;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_3*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.desktop.noCustomCursor;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$q(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.taskbar.colored;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_4*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.taskbar.colored;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4K(ctx) {
  let settingsoption0;
  let t0;
  let settingsoption1;
  let t1;
  let settingsoption2;
  let t2;
  let settingsoption3;
  let t3;
  let hr;
  let t4;
  let settingsoption4;
  let current;
  settingsoption0 = new SettingsOption({
    props: {
      title: "Animations",
      context: "Display animations on windows and elements",
      $$slots: { default: [create_default_slot_4$4] },
      $$scope: { ctx }
    }
  });
  settingsoption1 = new SettingsOption({
    props: {
      title: "No glass",
      context: "Disable transparency and glass effects",
      $$slots: { default: [create_default_slot_3$a] },
      $$scope: { ctx }
    }
  });
  settingsoption2 = new SettingsOption({
    props: {
      title: "Sharp corners",
      context: "Remove all rounded corners",
      $$slots: { default: [create_default_slot_2$f] },
      $$scope: { ctx }
    }
  });
  settingsoption3 = new SettingsOption({
    props: {
      title: "No custom cursors",
      context: "Disable the ArcOS custom cursors",
      $$slots: { default: [create_default_slot_1$h] },
      $$scope: { ctx }
    }
  });
  settingsoption4 = new SettingsOption({
    props: {
      title: "Broad accent colors",
      context: "Display accent colors on windows and the shell",
      $$slots: { default: [create_default_slot$q] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingsoption0.$$.fragment);
      t0 = space();
      create_component(settingsoption1.$$.fragment);
      t1 = space();
      create_component(settingsoption2.$$.fragment);
      t2 = space();
      create_component(settingsoption3.$$.fragment);
      t3 = space();
      hr = element("hr");
      t4 = space();
      create_component(settingsoption4.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingsoption0, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingsoption1, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingsoption2, target, anchor);
      insert(target, t2, anchor);
      mount_component(settingsoption3, target, anchor);
      insert(target, t3, anchor);
      insert(target, hr, anchor);
      insert(target, t4, anchor);
      mount_component(settingsoption4, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const settingsoption0_changes = {};
      if (dirty & /*$$scope, $UserDataStore*/
      65) {
        settingsoption0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption0.$set(settingsoption0_changes);
      const settingsoption1_changes = {};
      if (dirty & /*$$scope, $UserDataStore*/
      65) {
        settingsoption1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption1.$set(settingsoption1_changes);
      const settingsoption2_changes = {};
      if (dirty & /*$$scope, $UserDataStore*/
      65) {
        settingsoption2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption2.$set(settingsoption2_changes);
      const settingsoption3_changes = {};
      if (dirty & /*$$scope, $UserDataStore*/
      65) {
        settingsoption3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption3.$set(settingsoption3_changes);
      const settingsoption4_changes = {};
      if (dirty & /*$$scope, $UserDataStore*/
      65) {
        settingsoption4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption4.$set(settingsoption4_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingsoption0.$$.fragment, local);
      transition_in(settingsoption1.$$.fragment, local);
      transition_in(settingsoption2.$$.fragment, local);
      transition_in(settingsoption3.$$.fragment, local);
      transition_in(settingsoption4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingsoption0.$$.fragment, local);
      transition_out(settingsoption1.$$.fragment, local);
      transition_out(settingsoption2.$$.fragment, local);
      transition_out(settingsoption3.$$.fragment, local);
      transition_out(settingsoption4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(hr);
        detach(t4);
      }
      destroy_component(settingsoption0, detaching);
      destroy_component(settingsoption1, detaching);
      destroy_component(settingsoption2, detaching);
      destroy_component(settingsoption3, detaching);
      destroy_component(settingsoption4, detaching);
    }
  };
}
function instance$4j($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(0, $UserDataStore = $$value));
  function input_change_handler() {
    $UserDataStore.sh.anim = this.checked;
    UserDataStore.set($UserDataStore);
  }
  function input_change_handler_1() {
    $UserDataStore.sh.noGlass = this.checked;
    UserDataStore.set($UserDataStore);
  }
  function input_change_handler_2() {
    $UserDataStore.sh.desktop.sharp = this.checked;
    UserDataStore.set($UserDataStore);
  }
  function input_change_handler_3() {
    $UserDataStore.sh.desktop.noCustomCursor = this.checked;
    UserDataStore.set($UserDataStore);
  }
  function input_change_handler_4() {
    $UserDataStore.sh.taskbar.colored = this.checked;
    UserDataStore.set($UserDataStore);
  }
  return [
    $UserDataStore,
    input_change_handler,
    input_change_handler_1,
    input_change_handler_2,
    input_change_handler_3,
    input_change_handler_4
  ];
}
class Visuals extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4j, create_fragment$4K, safe_not_equal, {});
  }
}
function create_fragment$4J(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = SpinnerIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "spinner");
      set_style(
        img,
        "height",
        /*height*/
        ctx[0] + "px"
      );
      attr(img, "class", "spinner-svg");
      toggle_class(
        img,
        "hide",
        /*stopped*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*height*/
      1) {
        set_style(
          img,
          "height",
          /*height*/
          ctx2[0] + "px"
        );
      }
      if (dirty & /*stopped*/
      2) {
        toggle_class(
          img,
          "hide",
          /*stopped*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function instance$4i($$self, $$props, $$invalidate) {
  let { height } = $$props;
  let { stopped = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("height" in $$props2)
      $$invalidate(0, height = $$props2.height);
    if ("stopped" in $$props2)
      $$invalidate(1, stopped = $$props2.stopped);
  };
  return [height, stopped];
}
class Spinner extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4i, create_fragment$4J, safe_not_equal, { height: 0, stopped: 1 });
  }
}
async function FileProgress(initialData, parentPid, noShade = true) {
  const progress = Store$1(initialData);
  if (!parentPid) {
    const process = await spawnApp("FsProgress", 0, [progress]);
    if (typeof process == "string")
      return null;
  } else {
    const process = await spawnOverlay(getAppById("FsProgress"), parentPid, [progress], noShade);
    if (typeof process == "string")
      return null;
  }
  const mutateMax = (mutator) => progress.update((v2) => {
    v2.max += mutator;
    return v2;
  });
  const mutDone = (mutator) => progress.update((v2) => {
    v2.done += mutator;
    return v2;
  });
  const setMax = (value) => progress.update((v2) => {
    v2.max = value;
    return v2;
  });
  const setDone = (value) => progress.update((v2) => {
    v2.done = value;
    return v2;
  });
  const updateCaption = (caption) => progress.update((v2) => {
    v2.caption = caption;
    return v2;
  });
  const updSub = (subtitle) => progress.update((v2) => {
    v2.subtitle = subtitle;
    return v2;
  });
  const setWait = (waiting) => progress.update((v2) => {
    v2.waiting = waiting;
    return v2;
  });
  const setWork = (working) => progress.update((v2) => {
    v2.working = working;
    return v2;
  });
  const mutErr = (mutator) => progress.update((v2) => {
    v2.errors += mutator;
    return v2;
  });
  const setErrors = (value) => progress.update((v2) => {
    v2.errors = value;
    return v2;
  });
  return {
    progress,
    mutateMax,
    mutDone,
    updateCaption,
    updSub,
    setMax,
    setDone,
    setWait,
    setWork,
    mutErr,
    setErrors
  };
}
async function directUploadProgressy(path, multi = false, pid, accept) {
  if (path.endsWith("/"))
    path.slice(0, -1);
  const uploader = document.createElement("input");
  uploader.type = "file";
  uploader.accept = accept;
  uploader.multiple = multi;
  const target = Store$1();
  uploader.onchange = async () => {
    const files = uploader.files;
    if (!files.length)
      target.set(path);
    if (!multi) {
      const file = uploader.files[0];
      target.set(await fileUploadProgressy(file, path, pid));
      return;
    }
    await multipleFileUploadProgressy(uploader.files, path, pid);
    target.set(path);
  };
  uploader.click();
  return new Promise((resolve) => {
    target.subscribe((v2) => {
      if (!v2)
        return;
      resolve(v2);
    });
  });
}
async function fileUploadProgressy(file, dir, pid, noShade = false) {
  Log("server/fs/upload/progress", `Uploading ${file.name} to ${dir}`);
  const { setMax, setDone, mutErr } = await FileProgress(
    {
      type: "size",
      caption: `Uploading ${file.name}`,
      subtitle: `To ${dir}`,
      max: file.size,
      done: 0,
      icon: UploadIcon,
      working: true,
      waiting: false,
      errors: 0
    },
    pid,
    noShade
  );
  const content = arrayToBlob(await file.arrayBuffer());
  const path = `${dir}/${file.name}`.split("//").join("/");
  const valid = await writeFile(path, content, false, (p2) => {
    setDone(p2.loaded);
    setMax(p2.total);
  });
  if (!valid)
    mutErr(1);
  GlobalDispatch.dispatch("fs-flush");
  if (!valid)
    return "";
  return path;
}
async function multipleFileUploadProgressy(files, dir, pid, noShade = false) {
  Log("server/fs/upload", `Uploading ${files.length} files to ${dir}`);
  let total = 0;
  for (const file of files) {
    total += file.size;
  }
  const { updSub, mutDone, setWork, setWait, mutErr } = await FileProgress(
    {
      type: "size",
      caption: `Uploading ${files.length} ${Plural("file", files.length)} to ${pathToFriendlyName(dir)}`,
      subtitle: `To ${dir}`,
      max: total + 100,
      done: 0,
      icon: UploadIcon,
      working: false,
      waiting: true,
      errors: 0
    },
    pid,
    noShade
  );
  for (let i2 = 0; i2 < files.length; i2++) {
    const file = files[i2];
    const content = arrayToBlob(await file.arrayBuffer());
    const path = `${dir}/${file.name}`.replaceAll("//", "/");
    updSub(`(${i2 + 1} / ${files.length}) ${file.name}`);
    setWait(false);
    setWork(true);
    const written = await writeFile(path, content, false, (p2) => {
      mutDone(p2.bytes);
    });
    if (!written)
      mutErr(1);
    setWork(false);
    setWait(true);
    await sleep(55);
  }
  mutDone(200);
  GlobalDispatch.dispatch("fs-flush");
  return true;
}
async function directSingleUpload(path, multi = false, pid, accept) {
  if (path.endsWith("/"))
    path.slice(0, -1);
  const uploader = document.createElement("input");
  uploader.type = "file";
  uploader.accept = accept;
  uploader.multiple = multi;
  const target = Store$1();
  uploader.onchange = async () => {
    const files = uploader.files;
    if (!files.length)
      target.set("");
    if (!multi) {
      const file = uploader.files[0];
      target.set(await fileUploadProgressy(file, path, pid));
      return;
    }
    await multipleFileUploadProgressy(uploader.files, path, pid);
    target.set(path);
  };
  uploader.click();
  return new Promise((resolve) => {
    target.subscribe((v2) => {
      if (!v2)
        return;
      resolve(v2);
    });
  });
}
function create_else_block$z(ctx) {
  let div;
  let spinner;
  let current;
  spinner = new Spinner({ props: { height: 32 } });
  return {
    c() {
      div = element("div");
      create_component(spinner.$$.fragment);
      attr(div, "class", "center-flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(spinner, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(spinner);
    }
  };
}
function create_if_block$1Q(ctx) {
  let themepreview;
  let t0;
  let div5;
  let div1;
  let div0;
  let p0;
  let t2;
  let p1;
  let t3_value = (
    /*wallpaper*/
    ctx[0].name + ""
  );
  let t3;
  let p1_title_value;
  let t4;
  let div3;
  let div2;
  let p2;
  let t6;
  let p3;
  let t7_value = (
    /*wallpaper*/
    ctx[0].author + ""
  );
  let t7;
  let t8;
  let div4;
  let button0;
  let t10;
  let button1;
  let current;
  let mounted;
  let dispose;
  themepreview = new ThemePreview({
    props: {
      $$slots: { default: [create_default_slot$p] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(themepreview.$$.fragment);
      t0 = space();
      div5 = element("div");
      div1 = element("div");
      div0 = element("div");
      p0 = element("p");
      p0.textContent = "Name";
      t2 = space();
      p1 = element("p");
      t3 = text(t3_value);
      t4 = space();
      div3 = element("div");
      div2 = element("div");
      p2 = element("p");
      p2.textContent = "Author";
      t6 = space();
      p3 = element("p");
      t7 = text(t7_value);
      t8 = space();
      div4 = element("div");
      button0 = element("button");
      button0.textContent = "upload";
      t10 = space();
      button1 = element("button");
      button1.textContent = "travel_explore";
      attr(p0, "class", "name");
      attr(p1, "class", "value");
      attr(p1, "title", p1_title_value = /*wallpaper*/
      ctx[0].name);
      attr(div0, "class", "text");
      attr(div1, "class", "common-option");
      attr(p2, "class", "name");
      attr(p3, "class", "value");
      attr(div2, "class", "text");
      attr(div3, "class", "common-option");
      attr(button0, "class", "button material-icons-round");
      attr(button0, "title", "Upload a wallpaper");
      attr(button1, "class", "button material-icons-round");
      attr(button1, "title", "Wallpaper from URL");
      attr(div4, "class", "buttons");
      attr(div5, "class", "common");
    },
    m(target, anchor) {
      mount_component(themepreview, target, anchor);
      insert(target, t0, anchor);
      insert(target, div5, anchor);
      append(div5, div1);
      append(div1, div0);
      append(div0, p0);
      append(div0, t2);
      append(div0, p1);
      append(p1, t3);
      append(div5, t4);
      append(div5, div3);
      append(div3, div2);
      append(div2, p2);
      append(div2, t6);
      append(div2, p3);
      append(p3, t7);
      append(div5, t8);
      append(div5, div4);
      append(div4, button0);
      append(div4, t10);
      append(div4, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*upload*/
            ctx[1]
          ),
          listen(
            button1,
            "click",
            /*custom*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const themepreview_changes = {};
      if (dirty & /*$$scope*/
      32) {
        themepreview_changes.$$scope = { dirty, ctx: ctx2 };
      }
      themepreview.$set(themepreview_changes);
      if ((!current || dirty & /*wallpaper*/
      1) && t3_value !== (t3_value = /*wallpaper*/
      ctx2[0].name + ""))
        set_data(t3, t3_value);
      if (!current || dirty & /*wallpaper*/
      1 && p1_title_value !== (p1_title_value = /*wallpaper*/
      ctx2[0].name)) {
        attr(p1, "title", p1_title_value);
      }
      if ((!current || dirty & /*wallpaper*/
      1) && t7_value !== (t7_value = /*wallpaper*/
      ctx2[0].author + ""))
        set_data(t7, t7_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(themepreview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(themepreview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div5);
      }
      destroy_component(themepreview, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$p(ctx) {
  let desktop;
  let current;
  desktop = new Desktop$1({});
  return {
    c() {
      create_component(desktop.$$.fragment);
    },
    m(target, anchor) {
      mount_component(desktop, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(desktop.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(desktop.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(desktop, detaching);
    }
  };
}
function create_fragment$4I(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$1Q, create_else_block$z];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*wallpaper*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "theme-overview");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$4h($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(4, $UserDataStore = $$value));
  let { runtime } = $$props;
  let wallpaper;
  UserDataStore.subscribe(async (v2) => {
    $$invalidate(0, wallpaper = await getWallpaper(v2.sh.desktop.wallpaper));
  });
  async function upload() {
    await createDirectory("./Wallpapers");
    const path = await directSingleUpload("./Wallpapers", false, 0, "image/png, image/jpeg, image/gif, image/svg+xml");
    const base64 = toBase64(path);
    if (base64 == path)
      return;
    set_store_value(UserDataStore, $UserDataStore.sh.desktop.wallpaper = `@local:${base64}`, $UserDataStore);
  }
  function custom() {
    runtime.showOverlay("CustomWallpaper");
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [wallpaper, upload, custom, runtime];
}
class Overview2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4h, create_fragment$4I, safe_not_equal, { runtime: 3 });
  }
}
function create_fragment$4H(ctx) {
  let button;
  let img;
  let img_src_value;
  let button_class_value;
  let button_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*wallpaper*/
      ctx[1].thumb))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*id*/
        ctx[0]
      );
      attr(button, "class", button_class_value = "theme-option wallpaper-" + /*id*/
      ctx[0]);
      attr(button, "title", button_title_value = /*wallpaper*/
      ctx[1].name + " by " + /*wallpaper*/
      ctx[1].author);
      toggle_class(
        button,
        "selected",
        /*$UserDataStore*/
        ctx[2].sh.desktop.wallpaper === /*id*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*select*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*wallpaper*/
      2 && !src_url_equal(img.src, img_src_value = /*wallpaper*/
      ctx2[1].thumb)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*id*/
      1) {
        attr(
          img,
          "alt",
          /*id*/
          ctx2[0]
        );
      }
      if (dirty & /*id*/
      1 && button_class_value !== (button_class_value = "theme-option wallpaper-" + /*id*/
      ctx2[0])) {
        attr(button, "class", button_class_value);
      }
      if (dirty & /*wallpaper*/
      2 && button_title_value !== (button_title_value = /*wallpaper*/
      ctx2[1].name + " by " + /*wallpaper*/
      ctx2[1].author)) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*id, $UserDataStore, id*/
      5) {
        toggle_class(
          button,
          "selected",
          /*$UserDataStore*/
          ctx2[2].sh.desktop.wallpaper === /*id*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4g($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(2, $UserDataStore = $$value));
  let { id } = $$props;
  let { wallpaper } = $$props;
  function select() {
    set_store_value(UserDataStore, $UserDataStore.sh.desktop.wallpaper = id, $UserDataStore);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("wallpaper" in $$props2)
      $$invalidate(1, wallpaper = $$props2.wallpaper);
  };
  return [id, wallpaper, $UserDataStore, select];
}
class WallpaperOption extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4g, create_fragment$4H, safe_not_equal, { id: 0, wallpaper: 1 });
  }
}
function get_each_context$M(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list2[i2][0];
  child_ctx[1] = list2[i2][1];
  return child_ctx;
}
function create_each_block$M(ctx) {
  let wallpaperoption;
  let current;
  wallpaperoption = new WallpaperOption({
    props: {
      id: (
        /*id*/
        ctx[0]
      ),
      wallpaper: (
        /*wallpaper*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(wallpaperoption.$$.fragment);
    },
    m(target, anchor) {
      mount_component(wallpaperoption, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(wallpaperoption.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(wallpaperoption.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(wallpaperoption, detaching);
    }
  };
}
function create_fragment$4G(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(Object.entries(Wallpapers));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$M(get_each_context$M(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "theme-selector");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Object*/
      0) {
        each_value = ensure_array_like(Object.entries(Wallpapers));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$M(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$M(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
class WallpaperSelector extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$4G, safe_not_equal, {});
  }
}
function create_fragment$4F(ctx) {
  let overview;
  let t2;
  let wallpaperselector;
  let current;
  overview = new Overview2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  wallpaperselector = new WallpaperSelector({});
  return {
    c() {
      create_component(overview.$$.fragment);
      t2 = space();
      create_component(wallpaperselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overview, target, anchor);
      insert(target, t2, anchor);
      mount_component(wallpaperselector, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const overview_changes = {};
      if (dirty & /*runtime*/
      1)
        overview_changes.runtime = /*runtime*/
        ctx2[0];
      overview.$set(overview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(overview.$$.fragment, local);
      transition_in(wallpaperselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overview.$$.fragment, local);
      transition_out(wallpaperselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(overview, detaching);
      destroy_component(wallpaperselector, detaching);
    }
  };
}
function instance$4f($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime];
}
class Wallpaper extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4f, create_fragment$4F, safe_not_equal, { runtime: 0 });
  }
}
function create_if_block$1P(ctx) {
  let div;
  let t2;
  let if_block0 = (
    /*$app*/
    ctx[1].helpArticle && create_if_block_2$f(ctx)
  );
  let if_block1 = (
    /*$app*/
    ctx[1].controls.maximize && /*$app*/
    ctx[1].state.snapping && create_if_block_1$E(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      attr(div, "class", "titlebar-button-group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t2);
      if (if_block1)
        if_block1.m(div, null);
    },
    p(ctx2, dirty) {
      if (
        /*$app*/
        ctx2[1].helpArticle
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$f(ctx2);
          if_block0.c();
          if_block0.m(div, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*$app*/
        ctx2[1].controls.maximize && /*$app*/
        ctx2[1].state.snapping
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$E(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_2$f(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "question_mark";
      attr(button, "class", "material-icons-round reset");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*help*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$E(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "south_west";
      attr(button, "class", "material-icons-round reset");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*unsnap*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4E(ctx) {
  let t0;
  let div;
  let button0;
  let t1;
  let button0_disabled_value;
  let t2;
  let button1;
  let t3;
  let button1_disabled_value;
  let t4;
  let button2;
  let t5;
  let button2_disabled_value;
  let mounted;
  let dispose;
  let if_block = (
    /*$app*/
    (ctx[1].helpArticle || /*$app*/
    ctx[1].controls.maximize && /*$app*/
    ctx[1].state.snapping) && create_if_block$1P(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      div = element("div");
      button0 = element("button");
      t1 = text("minimize");
      t2 = space();
      button1 = element("button");
      t3 = text("crop_square");
      t4 = space();
      button2 = element("button");
      t5 = text("close");
      attr(button0, "class", "material-icons-round reset");
      button0.disabled = button0_disabled_value = !/*$app*/
      ctx[1].controls.minimize;
      attr(button1, "class", "material-icons-round reset");
      button1.disabled = button1_disabled_value = !/*$app*/
      ctx[1].controls.maximize || /*$app*/
      ctx[1].state.snapping;
      attr(button2, "class", "close material-icons-round reset");
      button2.disabled = button2_disabled_value = !/*$app*/
      ctx[1].controls.close;
      attr(div, "class", "titlebar-button-group");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t1);
      append(div, t2);
      append(div, button1);
      append(button1, t3);
      append(div, t4);
      append(div, button2);
      append(button2, t5);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*minimize*/
            ctx[2]
          ),
          listen(
            button1,
            "click",
            /*maximize*/
            ctx[3]
          ),
          listen(
            button2,
            "click",
            /*close*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*$app*/
        ctx2[1].helpArticle || /*$app*/
        ctx2[1].controls.maximize && /*$app*/
        ctx2[1].state.snapping
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1P(ctx2);
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*$app*/
      2 && button0_disabled_value !== (button0_disabled_value = !/*$app*/
      ctx2[1].controls.minimize)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*$app*/
      2 && button1_disabled_value !== (button1_disabled_value = !/*$app*/
      ctx2[1].controls.maximize || /*$app*/
      ctx2[1].state.snapping)) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*$app*/
      2 && button2_disabled_value !== (button2_disabled_value = !/*$app*/
      ctx2[1].controls.close)) {
        button2.disabled = button2_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4e($$self, $$props, $$invalidate) {
  let $app, $$unsubscribe_app = noop$1, $$subscribe_app = () => ($$unsubscribe_app(), $$unsubscribe_app = subscribe(app, ($$value) => $$invalidate(1, $app = $$value)), app);
  $$self.$$.on_destroy.push(() => $$unsubscribe_app());
  let { app } = $$props;
  $$subscribe_app();
  let { pid } = $$props;
  function minimize() {
    set_store_value(app, $app.state.minimized = !$app.state.minimized, $app);
  }
  function maximize() {
    set_store_value(app, $app.state.maximized = !$app.state.maximized, $app);
  }
  function close() {
    ProcessStack.kill(pid, true);
  }
  function unsnap() {
    set_store_value(app, $app.state.snapping = false, $app);
  }
  function help() {
    GetHelp($app.helpArticle);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$subscribe_app($$invalidate(0, app = $$props2.app));
    if ("pid" in $$props2)
      $$invalidate(7, pid = $$props2.pid);
  };
  return [app, $app, minimize, maximize, close, unsnap, help, pid];
}
class Aero extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4e, create_fragment$4E, safe_not_equal, { app: 0, pid: 7 });
  }
}
function create_if_block_1$D(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "question_mark";
      attr(button, "class", "help material-icons-round titlebar-control reset");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*help*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1O(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "south_west";
      attr(button, "class", "unsnap material-icons-round titlebar-control reset");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*unsnap*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4D(ctx) {
  let t0;
  let t1;
  let button0;
  let t2;
  let button0_disabled_value;
  let t3;
  let button1;
  let t4;
  let button1_disabled_value;
  let t5;
  let button2;
  let t6;
  let button2_disabled_value;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$app*/
    ctx[1].helpArticle && create_if_block_1$D(ctx)
  );
  let if_block1 = (
    /*$app*/
    ctx[1].controls.maximize && /*$app*/
    ctx[1].state.snapping && create_if_block$1O(ctx)
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      button0 = element("button");
      t2 = text("minimize");
      t3 = space();
      button1 = element("button");
      t4 = text("crop_square");
      t5 = space();
      button2 = element("button");
      t6 = text("close");
      attr(button0, "class", "min material-icons-round titlebar-control reset");
      button0.disabled = button0_disabled_value = !/*$app*/
      ctx[1].controls.minimize;
      attr(button1, "class", "max material-icons-round titlebar-control reset");
      button1.disabled = button1_disabled_value = !/*$app*/
      ctx[1].controls.maximize || /*$app*/
      ctx[1].state.snapping;
      attr(button2, "class", "close material-icons-round titlebar-control reset");
      button2.disabled = button2_disabled_value = !/*$app*/
      ctx[1].controls.close;
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      insert(target, button0, anchor);
      append(button0, t2);
      insert(target, t3, anchor);
      insert(target, button1, anchor);
      append(button1, t4);
      insert(target, t5, anchor);
      insert(target, button2, anchor);
      append(button2, t6);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*minimize*/
            ctx[2]
          ),
          listen(
            button1,
            "click",
            /*maximize*/
            ctx[3]
          ),
          listen(
            button2,
            "click",
            /*close*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*$app*/
        ctx2[1].helpArticle
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$D(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*$app*/
        ctx2[1].controls.maximize && /*$app*/
        ctx2[1].state.snapping
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$1O(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*$app*/
      2 && button0_disabled_value !== (button0_disabled_value = !/*$app*/
      ctx2[1].controls.minimize)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*$app*/
      2 && button1_disabled_value !== (button1_disabled_value = !/*$app*/
      ctx2[1].controls.maximize || /*$app*/
      ctx2[1].state.snapping)) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*$app*/
      2 && button2_disabled_value !== (button2_disabled_value = !/*$app*/
      ctx2[1].controls.close)) {
        button2.disabled = button2_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(button0);
        detach(t3);
        detach(button1);
        detach(t5);
        detach(button2);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4d($$self, $$props, $$invalidate) {
  let $app, $$unsubscribe_app = noop$1, $$subscribe_app = () => ($$unsubscribe_app(), $$unsubscribe_app = subscribe(app, ($$value) => $$invalidate(1, $app = $$value)), app);
  $$self.$$.on_destroy.push(() => $$unsubscribe_app());
  let { app } = $$props;
  $$subscribe_app();
  let { pid } = $$props;
  function minimize() {
    set_store_value(app, $app.state.minimized = !$app.state.minimized, $app);
  }
  function maximize() {
    set_store_value(app, $app.state.maximized = !$app.state.maximized, $app);
  }
  function close() {
    ProcessStack.kill(pid, true);
  }
  function unsnap() {
    set_store_value(app, $app.state.snapping = false, $app);
  }
  function help() {
    GetHelp($app.helpArticle);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$subscribe_app($$invalidate(0, app = $$props2.app));
    if ("pid" in $$props2)
      $$invalidate(7, pid = $$props2.pid);
  };
  return [app, $app, minimize, maximize, close, unsnap, help, pid];
}
class Default extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4d, create_fragment$4D, safe_not_equal, { app: 0, pid: 7 });
  }
}
const OG_svelte_svelte_type_style_lang = "";
function create_fragment$4C(ctx) {
  let button0;
  let t0;
  let button0_disabled_value;
  let t1;
  let button1;
  let t2;
  let button1_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      t0 = text("🗕");
      t1 = space();
      button1 = element("button");
      t2 = text("✖");
      attr(button0, "class", "reset svelte-1fi2g4s");
      button0.disabled = button0_disabled_value = !/*$app*/
      ctx[1].controls.minimize;
      attr(button1, "class", "reset close svelte-1fi2g4s");
      button1.disabled = button1_disabled_value = !/*$app*/
      ctx[1].controls.close;
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      append(button0, t0);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      append(button1, t2);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*minimize*/
            ctx[2]
          ),
          listen(
            button1,
            "click",
            /*close*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$app*/
      2 && button0_disabled_value !== (button0_disabled_value = !/*$app*/
      ctx2[1].controls.minimize)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*$app*/
      2 && button1_disabled_value !== (button1_disabled_value = !/*$app*/
      ctx2[1].controls.close)) {
        button1.disabled = button1_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t1);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4c($$self, $$props, $$invalidate) {
  let $app, $$unsubscribe_app = noop$1, $$subscribe_app = () => ($$unsubscribe_app(), $$unsubscribe_app = subscribe(app, ($$value) => $$invalidate(1, $app = $$value)), app);
  $$self.$$.on_destroy.push(() => $$unsubscribe_app());
  let { app } = $$props;
  $$subscribe_app();
  let { pid } = $$props;
  function minimize() {
    set_store_value(app, $app.state.minimized = true, $app);
  }
  function close() {
    ProcessStack.kill(pid, true);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$subscribe_app($$invalidate(0, app = $$props2.app));
    if ("pid" in $$props2)
      $$invalidate(4, pid = $$props2.pid);
  };
  return [app, $app, minimize, close, pid];
}
class OG extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4c, create_fragment$4C, safe_not_equal, { app: 0, pid: 4 });
  }
}
function create_fragment$4B(ctx) {
  let button0;
  let button0_disabled_value;
  let t0;
  let button1;
  let button1_disabled_value;
  let t1;
  let button2;
  let button2_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      t0 = space();
      button1 = element("button");
      t1 = space();
      button2 = element("button");
      attr(button0, "class", "traffic-cls reset");
      button0.disabled = button0_disabled_value = !/*$app*/
      ctx[1].controls.close;
      attr(button1, "class", "traffic-min reset");
      button1.disabled = button1_disabled_value = !/*$app*/
      ctx[1].controls.minimize;
      attr(button2, "class", "traffic-max reset");
      button2.disabled = button2_disabled_value = !/*$app*/
      ctx[1].controls.maximize;
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      insert(target, t0, anchor);
      insert(target, button1, anchor);
      insert(target, t1, anchor);
      insert(target, button2, anchor);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*cls*/
            ctx[2]
          ),
          listen(
            button1,
            "click",
            /*min*/
            ctx[3]
          ),
          listen(
            button2,
            "click",
            /*max*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$app*/
      2 && button0_disabled_value !== (button0_disabled_value = !/*$app*/
      ctx2[1].controls.close)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*$app*/
      2 && button1_disabled_value !== (button1_disabled_value = !/*$app*/
      ctx2[1].controls.minimize)) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*$app*/
      2 && button2_disabled_value !== (button2_disabled_value = !/*$app*/
      ctx2[1].controls.maximize)) {
        button2.disabled = button2_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t0);
        detach(button1);
        detach(t1);
        detach(button2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4b($$self, $$props, $$invalidate) {
  let $app, $$unsubscribe_app = noop$1, $$subscribe_app = () => ($$unsubscribe_app(), $$unsubscribe_app = subscribe(app, ($$value) => $$invalidate(1, $app = $$value)), app);
  $$self.$$.on_destroy.push(() => $$unsubscribe_app());
  let { app } = $$props;
  $$subscribe_app();
  let { pid } = $$props;
  function cls() {
    ProcessStack.kill(pid, true);
  }
  function min() {
    set_store_value(app, $app.state.minimized = true, $app);
  }
  function max() {
    set_store_value(app, $app.state.maximized = !$app.state.maximized, $app);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$subscribe_app($$invalidate(0, app = $$props2.app));
    if ("pid" in $$props2)
      $$invalidate(5, pid = $$props2.pid);
  };
  return [app, $app, cls, min, max, pid];
}
class Traffic extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4b, create_fragment$4B, safe_not_equal, { app: 0, pid: 5 });
  }
}
const TitlebarButtons = {
  default: {
    caption: "Default",
    author: "ArcOS",
    content: Default
  },
  traffic: {
    caption: "Traffic Lights",
    author: "Apple",
    content: Traffic
  },
  og: {
    caption: "O.G.",
    author: "WebOSv3",
    content: OG
  },
  win7: {
    caption: "Windows 7",
    author: "Microsoft",
    content: Aero
  }
};
function get_each_context$L(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2][0];
  child_ctx[6] = list2[i2][1];
  return child_ctx;
}
function create_default_slot_3$9(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.window.bigtb;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore, Object*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.window.bigtb;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$e(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.window.lefttb;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_1*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore, Object*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.window.lefttb;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$g(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.window.centertb;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_2*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore, Object*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.window.centertb;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$L(ctx) {
  let option;
  let t0_value = (
    /*data*/
    ctx[6].author + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*data*/
    ctx[6].caption + ""
  );
  let t2;
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = text(" - ");
      t2 = text(t2_value);
      option.__value = /*id*/
      ctx[5];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
      append(option, t2);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_default_slot$o(ctx) {
  let select;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(Object.entries(TitlebarButtons));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$L(get_each_context$L(ctx, each_value, i2));
  }
  return {
    c() {
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (
        /*$UserDataStore*/
        ctx[0].sh.window.buttons === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[4].call(select)
        ));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(
        select,
        /*$UserDataStore*/
        ctx[0].sh.window.buttons,
        true
      );
      if (!mounted) {
        dispose = listen(
          select,
          "change",
          /*select_change_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*Object*/
      0) {
        each_value = ensure_array_like(Object.entries(TitlebarButtons));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$L(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$L(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$UserDataStore, Object*/
      1) {
        select_option(
          select,
          /*$UserDataStore*/
          ctx2[0].sh.window.buttons
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4A(ctx) {
  let settingsoption0;
  let t0;
  let settingsoption1;
  let t1;
  let settingsoption2;
  let t2;
  let settingsoption3;
  let current;
  settingsoption0 = new SettingsOption({
    props: {
      title: "Large titlebar",
      context: "Make the titlebars larger",
      $$slots: { default: [create_default_slot_3$9] },
      $$scope: { ctx }
    }
  });
  settingsoption1 = new SettingsOption({
    props: {
      title: "Left titlebar buttons",
      context: "Swap the titlebar and window controls",
      $$slots: { default: [create_default_slot_2$e] },
      $$scope: { ctx }
    }
  });
  settingsoption2 = new SettingsOption({
    props: {
      title: "Center window title",
      context: "Put the window title in the center of the titlebar",
      $$slots: { default: [create_default_slot_1$g] },
      $$scope: { ctx }
    }
  });
  settingsoption3 = new SettingsOption({
    props: {
      title: "Titlebar buttons",
      context: "What titlebar buttons do you want?",
      $$slots: { default: [create_default_slot$o] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingsoption0.$$.fragment);
      t0 = space();
      create_component(settingsoption1.$$.fragment);
      t1 = space();
      create_component(settingsoption2.$$.fragment);
      t2 = space();
      create_component(settingsoption3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingsoption0, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingsoption1, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingsoption2, target, anchor);
      insert(target, t2, anchor);
      mount_component(settingsoption3, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const settingsoption0_changes = {};
      if (dirty & /*$$scope, $UserDataStore*/
      513) {
        settingsoption0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption0.$set(settingsoption0_changes);
      const settingsoption1_changes = {};
      if (dirty & /*$$scope, $UserDataStore*/
      513) {
        settingsoption1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption1.$set(settingsoption1_changes);
      const settingsoption2_changes = {};
      if (dirty & /*$$scope, $UserDataStore*/
      513) {
        settingsoption2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption2.$set(settingsoption2_changes);
      const settingsoption3_changes = {};
      if (dirty & /*$$scope, $UserDataStore*/
      513) {
        settingsoption3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption3.$set(settingsoption3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingsoption0.$$.fragment, local);
      transition_in(settingsoption1.$$.fragment, local);
      transition_in(settingsoption2.$$.fragment, local);
      transition_in(settingsoption3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingsoption0.$$.fragment, local);
      transition_out(settingsoption1.$$.fragment, local);
      transition_out(settingsoption2.$$.fragment, local);
      transition_out(settingsoption3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(settingsoption0, detaching);
      destroy_component(settingsoption1, detaching);
      destroy_component(settingsoption2, detaching);
      destroy_component(settingsoption3, detaching);
    }
  };
}
function instance$4a($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(0, $UserDataStore = $$value));
  function input_change_handler() {
    $UserDataStore.sh.window.bigtb = this.checked;
    UserDataStore.set($UserDataStore);
  }
  function input_change_handler_1() {
    $UserDataStore.sh.window.lefttb = this.checked;
    UserDataStore.set($UserDataStore);
  }
  function input_change_handler_2() {
    $UserDataStore.sh.window.centertb = this.checked;
    UserDataStore.set($UserDataStore);
  }
  function select_change_handler() {
    $UserDataStore.sh.window.buttons = select_value(this);
    UserDataStore.set($UserDataStore);
  }
  return [
    $UserDataStore,
    input_change_handler,
    input_change_handler_1,
    input_change_handler_2,
    select_change_handler
  ];
}
class Windows extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4a, create_fragment$4A, safe_not_equal, {});
  }
}
async function getUsers() {
  Log("server/user/get", "Getting users");
  const cache = UserCache.get();
  if (cache && Object.entries(cache).length)
    return cache;
  const url = getServerUrl(Endpoints.Users);
  if (!url)
    return {};
  const response = await axios$1.get(url);
  if (response.status !== 200)
    return {};
  const userList = response.data.data;
  const allUsers2 = {};
  for (const user of userList) {
    allUsers2[user.username] = user;
  }
  UserCache.set(allUsers2);
  return allUsers2;
}
async function getUserList() {
  const url = getServerUrl(Endpoints.Users);
  if (!url)
    return [];
  const response = await axios$1.get(url);
  if (response.status !== 200)
    return [];
  const userList = response.data.data;
  return userList;
}
const WATCHERS$1 = [];
class LoginStateWatcher {
  constructor(handler) {
    this.handler = handler;
    Log("Login/ts/watch", `Created new LoginStateWatcher for handler ${handler.id}`);
    handler.current.subscribe((v2) => this.trigger(v2));
  }
  watch(event) {
    const id = this.handler.id;
    Log("state/watch", `LoginStateWatcher.watch ${id}: Adding watcher: ${event.toString()}`);
    WATCHERS$1.push(event);
    event(this.handler.current.get());
  }
  async trigger(state) {
    const id = this.handler.id;
    for (const watcher of WATCHERS$1) {
      Log(
        "states/watch",
        `LoginStateWatcher.trigger ${id}: Triggering watcher: state changing to ${state.key}`
      );
      await watcher(state);
    }
  }
}
class LoginStateHandler {
  constructor(id, store, startState, runtime) {
    __publicField(this, "current", Store$1());
    __publicField(this, "watcher");
    __publicField(this, "store");
    __publicField(this, "startState");
    __publicField(this, "id");
    this.runtime = runtime;
    this.id = id;
    this.store = store;
    this.startState = startState;
    Log(
      "states",
      `Created LoginStateHandler "${id}" with ${store.size} states (starts at ${startState})`
    );
    this.watcher = new LoginStateWatcher(this);
  }
  navigate(stateKey) {
    Log("states", `LoginStateHandler.navigate[${this.id}]: Navigating to "${stateKey}"`);
    const has = this.store.has(stateKey);
    if (!has)
      Log(
        "states",
        `LoginStateHandler.navigate[${this.id}]: No such state ${stateKey}, falling back to ${this.startState}`,
        LogLevel.warn
      );
    const state = this.store.get(has ? stateKey : this.startState);
    if (state.onload)
      state.onload(this.runtime);
    document.title = `ArcOS | ${state.name}`;
    this.current.set(state);
    this.runtime.updateLoginBackground();
    return true;
  }
}
const pfpCache = {};
async function getUserPfp(username, fallback = "", store) {
  const server = ConnectedServer.get();
  if (!server)
    return fallback || ProfilePictures.def;
  if (pfpCache[username])
    return getProfilePicture(pfpCache[username]);
  const users = store || await getUsers();
  const user = users[username];
  if (!user)
    return fallback || ProfilePictures.def;
  pfpCache[username] = getProfilePicture(users[username].acc.profilePicture);
  return pfpCache[username];
}
function create_fragment$4z(ctx) {
  let profilepicture;
  let t0;
  let h1;
  let t1_value = (!/*username*/
  ctx[2] || /*username*/
  ctx[2] == "ArcOS" ? (
    /*override*/
    ctx[0]
  ) : (
    /*username*/
    ctx[2]
  )) + "";
  let t1;
  let current;
  profilepicture = new ProfilePicture({
    props: {
      src: (
        /*pfp*/
        ctx[1]
      ),
      height: 151,
      fallback: Logo()
    }
  });
  return {
    c() {
      create_component(profilepicture.$$.fragment);
      t0 = space();
      h1 = element("h1");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      mount_component(profilepicture, target, anchor);
      insert(target, t0, anchor);
      insert(target, h1, anchor);
      append(h1, t1);
      current = true;
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      2)
        profilepicture_changes.src = /*pfp*/
        ctx2[1];
      profilepicture.$set(profilepicture_changes);
      if ((!current || dirty & /*username, override*/
      5) && t1_value !== (t1_value = (!/*username*/
      ctx2[2] || /*username*/
      ctx2[2] == "ArcOS" ? (
        /*override*/
        ctx2[0]
      ) : (
        /*username*/
        ctx2[2]
      )) + ""))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(h1);
      }
      destroy_component(profilepicture, detaching);
    }
  };
}
function instance$49($$self, $$props, $$invalidate) {
  let $UserCache;
  let { runtime } = $$props;
  let { override = "" } = $$props;
  let pfp = "";
  let username = "ArcOS";
  const { UserName: UserName2, UserCache: UserCache2 } = runtime;
  component_subscribe($$self, UserCache2, (value) => $$invalidate(5, $UserCache = value));
  UserName2.subscribe(async (v2) => {
    $$invalidate(2, username = v2);
    $$invalidate(1, pfp = await getUserPfp(v2, Logo(), $UserCache));
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(4, runtime = $$props2.runtime);
    if ("override" in $$props2)
      $$invalidate(0, override = $$props2.override);
  };
  return [override, pfp, username, UserCache2, runtime];
}
class UserHeader extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$49, create_fragment$4z, safe_not_equal, { runtime: 4, override: 0 });
  }
}
function create_fragment$4y(ctx) {
  let h3;
  let spinner;
  let span;
  let t2;
  let current;
  spinner = new Spinner({ props: { height: 25 } });
  return {
    c() {
      h3 = element("h3");
      create_component(spinner.$$.fragment);
      span = element("span");
      t2 = text(
        /*caption*/
        ctx[0]
      );
      attr(h3, "class", "welcome-spinner");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      mount_component(spinner, h3, null);
      append(h3, span);
      append(span, t2);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*caption*/
      1)
        set_data(
          t2,
          /*caption*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
      }
      destroy_component(spinner);
    }
  };
}
function instance$48($$self, $$props, $$invalidate) {
  let { caption = "Welcome" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("caption" in $$props2)
      $$invalidate(0, caption = $$props2.caption);
  };
  return [caption];
}
class WelcomeSpinner extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$48, create_fragment$4y, safe_not_equal, { caption: 0 });
  }
}
function create_fragment$4x(ctx) {
  let div;
  let userheader;
  let t2;
  let welcomespinner;
  let current;
  userheader = new UserHeader({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  welcomespinner = new WelcomeSpinner({ props: { caption: (
    /*caption*/
    ctx[1]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(userheader.$$.fragment);
      t2 = space();
      create_component(welcomespinner.$$.fragment);
      attr(div, "class", "login-loading");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(userheader, div, null);
      append(div, t2);
      mount_component(welcomespinner, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const userheader_changes = {};
      if (dirty & /*runtime*/
      1)
        userheader_changes.runtime = /*runtime*/
        ctx2[0];
      userheader.$set(userheader_changes);
      const welcomespinner_changes = {};
      if (dirty & /*caption*/
      2)
        welcomespinner_changes.caption = /*caption*/
        ctx2[1];
      welcomespinner.$set(welcomespinner_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(userheader.$$.fragment, local);
      transition_in(welcomespinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(userheader.$$.fragment, local);
      transition_out(welcomespinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(userheader);
      destroy_component(welcomespinner);
    }
  };
}
function instance$47($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { caption } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("caption" in $$props2)
      $$invalidate(1, caption = $$props2.caption);
  };
  return [runtime, caption];
}
let Loading$2 = class Loading extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$47, create_fragment$4x, safe_not_equal, { runtime: 0, caption: 1 });
  }
};
function create_else_block$y(ctx) {
  let div;
  let spinner;
  let t0;
  let span;
  let t1;
  let current;
  spinner = new Spinner({ props: { height: 30 } });
  return {
    c() {
      div = element("div");
      create_component(spinner.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(
        /*$caption*/
        ctx[2]
      );
      attr(div, "class", "login-full");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(spinner, div, null);
      append(div, t0);
      append(div, span);
      append(span, t1);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*$caption*/
      4)
        set_data(
          t1,
          /*$caption*/
          ctx2[2]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(spinner);
    }
  };
}
function create_if_block$1N(ctx) {
  let loading;
  let current;
  loading = new Loading$2({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      caption: (
        /*$caption*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(loading.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const loading_changes = {};
      if (dirty & /*runtime*/
      1)
        loading_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*$caption*/
      4)
        loading_changes.caption = /*$caption*/
        ctx2[2];
      loading.$set(loading_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading, detaching);
    }
  };
}
function create_fragment$4w(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1N, create_else_block$y];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*full*/
    ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$46($$self, $$props, $$invalidate) {
  let $caption;
  let { runtime } = $$props;
  let { key: key2 = "" } = $$props;
  let full = false;
  let caption = writable("");
  component_subscribe($$self, caption, (value) => $$invalidate(2, $caption = value));
  const CAPTIONS = {
    logoff: "Goodbye!",
    restart: "Restarting",
    shutdown: "Shutting down",
    autologin: "Welcome"
  };
  CurrentLogItem.subscribe((v2) => {
    set_store_value(
      caption,
      $caption = ARCOS_MODE == "development" ? v2.msg : CAPTIONS[key2 || "autologin"],
      $caption
    );
  });
  onMount(() => {
    const username = get_store_value(runtime.UserName);
    $$invalidate(1, full = !username || username == "ArcOS");
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("key" in $$props2)
      $$invalidate(4, key2 = $$props2.key);
  };
  return [runtime, full, $caption, caption, key2];
}
class AutoLogin extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$46, create_fragment$4w, safe_not_equal, { runtime: 0, key: 4 });
  }
}
function create_fragment$4v(ctx) {
  let button0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      button0.textContent = "Show Picker";
      t1 = space();
      button1 = element("button");
      button1.textContent = "Create account";
      attr(button0, "class", "normal switchuser");
      attr(button1, "class", "normal link createaccount");
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*switchUser*/
            ctx[1]
          ),
          listen(
            button1,
            "click",
            /*register*/
            ctx[0]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t1);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$45($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  async function register2() {
    runtime.setUser(null);
    await sleep();
    runtime.stateHandler.navigate("newuserauth");
  }
  async function switchUser() {
    runtime.setUser(null);
    await sleep();
    runtime.stateHandler.navigate("selector");
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [register2, switchUser, runtime];
}
let Actions$6 = class Actions2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$45, create_fragment$4v, safe_not_equal, { runtime: 2 });
  }
};
function create_fragment$4u(ctx) {
  let p2;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "The username or password is incorrect.";
      t1 = space();
      button = element("button");
      button.textContent = "Try again";
      attr(p2, "class", "incorrect");
      attr(button, "class", "normal switchuser");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      insert(target, t1, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
        detach(t1);
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$44($$self, $$props, $$invalidate) {
  let { errored } = $$props;
  const click_handler = () => $$invalidate(0, errored = false);
  $$self.$$set = ($$props2) => {
    if ("errored" in $$props2)
      $$invalidate(0, errored = $$props2.errored);
  };
  return [errored, click_handler];
}
let Incorrect$1 = class Incorrect extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$44, create_fragment$4u, safe_not_equal, { errored: 0 });
  }
};
function create_else_block_1$4(ctx) {
  let welcomespinner;
  let current;
  welcomespinner = new WelcomeSpinner({});
  return {
    c() {
      create_component(welcomespinner.$$.fragment);
    },
    m(target, anchor) {
      mount_component(welcomespinner, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(welcomespinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(welcomespinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(welcomespinner, detaching);
    }
  };
}
function create_if_block$1M(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$C, create_else_block$x];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (!/*errored*/
    ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$x(ctx) {
  let incorrect;
  let updating_errored;
  let current;
  function incorrect_errored_binding(value) {
    ctx[10](value);
  }
  let incorrect_props = {};
  if (
    /*errored*/
    ctx[3] !== void 0
  ) {
    incorrect_props.errored = /*errored*/
    ctx[3];
  }
  incorrect = new Incorrect$1({ props: incorrect_props });
  binding_callbacks.push(() => bind$1(incorrect, "errored", incorrect_errored_binding));
  return {
    c() {
      create_component(incorrect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(incorrect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const incorrect_changes = {};
      if (!updating_errored && dirty & /*errored*/
      8) {
        updating_errored = true;
        incorrect_changes.errored = /*errored*/
        ctx2[3];
        add_flush_callback(() => updating_errored = false);
      }
      incorrect.$set(incorrect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(incorrect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(incorrect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(incorrect, detaching);
    }
  };
}
function create_if_block_1$C(ctx) {
  let div0;
  let input0;
  let t0;
  let div1;
  let input1;
  let t1;
  let button;
  let t2;
  let button_disabled_value;
  let t3;
  let actions;
  let current;
  let mounted;
  let dispose;
  actions = new Actions$6({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div0 = element("div");
      input0 = element("input");
      t0 = space();
      div1 = element("div");
      input1 = element("input");
      t1 = space();
      button = element("button");
      t2 = text("arrow_forward_ios");
      t3 = space();
      create_component(actions.$$.fragment);
      attr(input0, "type", "text");
      input0.disabled = /*loading*/
      ctx[1];
      attr(input0, "placeholder", "Username");
      attr(div0, "class", "field-wrapper");
      attr(input1, "type", "password");
      input1.disabled = /*loading*/
      ctx[1];
      attr(input1, "placeholder", "Password");
      attr(button, "class", "material-icons-round continue");
      button.disabled = button_disabled_value = !/*password*/
      ctx[4];
      attr(div1, "class", "field-wrapper continue");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, input0);
      set_input_value(
        input0,
        /*username*/
        ctx[2]
      );
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      append(div1, input1);
      set_input_value(
        input1,
        /*password*/
        ctx[4]
      );
      append(div1, t1);
      append(div1, button);
      append(button, t2);
      insert(target, t3, anchor);
      mount_component(actions, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "keydown",
            /*keydown*/
            ctx[7]
          ),
          listen(
            input0,
            "keyup",
            /*setUsername*/
            ctx[6]
          ),
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[8]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[9]
          ),
          listen(
            input1,
            "keydown",
            /*keydown*/
            ctx[7]
          ),
          listen(
            button,
            "click",
            /*login*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*loading*/
      2) {
        input0.disabled = /*loading*/
        ctx2[1];
      }
      if (dirty & /*username*/
      4 && input0.value !== /*username*/
      ctx2[2]) {
        set_input_value(
          input0,
          /*username*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*loading*/
      2) {
        input1.disabled = /*loading*/
        ctx2[1];
      }
      if (dirty & /*password*/
      16 && input1.value !== /*password*/
      ctx2[4]) {
        set_input_value(
          input1,
          /*password*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*password*/
      16 && button_disabled_value !== (button_disabled_value = !/*password*/
      ctx2[4])) {
        button.disabled = button_disabled_value;
      }
      const actions_changes = {};
      if (dirty & /*runtime*/
      1)
        actions_changes.runtime = /*runtime*/
        ctx2[0];
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div1);
        detach(t3);
      }
      destroy_component(actions, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$4t(ctx) {
  let div;
  let userheader;
  let t2;
  let current_block_type_index;
  let if_block;
  let current;
  userheader = new UserHeader({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      override: "Login"
    }
  });
  const if_block_creators = [create_if_block$1M, create_else_block_1$4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*loading*/
    ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      create_component(userheader.$$.fragment);
      t2 = space();
      if_block.c();
      attr(div, "class", "login-loading");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(userheader, div, null);
      append(div, t2);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const userheader_changes = {};
      if (dirty & /*runtime*/
      1)
        userheader_changes.runtime = /*runtime*/
        ctx2[0];
      userheader.$set(userheader_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(userheader.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(userheader.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(userheader);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$43($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let loading = false;
  let username = get_store_value(runtime.UserName);
  let errored = false;
  let password = "";
  async function login() {
    $$invalidate(1, loading = true);
    const username2 = get_store_value(runtime.UserName);
    const userdata = await runtime.Authenticate(username2, password);
    if (!userdata) {
      $$invalidate(1, loading = false);
      $$invalidate(3, errored = true);
      return;
    }
    await runtime.proceed(username2);
  }
  function setUsername() {
    runtime.UserName.set(username);
  }
  function keydown(e2) {
    if (e2.key == "Enter")
      login();
  }
  function input0_input_handler() {
    username = this.value;
    $$invalidate(2, username);
  }
  function input1_input_handler() {
    password = this.value;
    $$invalidate(4, password);
  }
  function incorrect_errored_binding(value) {
    errored = value;
    $$invalidate(3, errored);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [
    runtime,
    loading,
    username,
    errored,
    password,
    login,
    setUsername,
    keydown,
    input0_input_handler,
    input1_input_handler,
    incorrect_errored_binding
  ];
}
class ExistingUser extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$43, create_fragment$4t, safe_not_equal, { runtime: 0 });
  }
}
function create_fragment$4s(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "I have an account";
      attr(button, "class", "normal link createaccount");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*existing*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$42($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  async function existing() {
    runtime.setUser(null);
    await sleep();
    runtime.stateHandler.navigate("existinguserauth");
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [existing, runtime];
}
let Actions$5 = class Actions3 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$42, create_fragment$4s, safe_not_equal, { runtime: 1 });
  }
};
function create_fragment$4r(ctx) {
  let div;
  let input;
  let t0;
  let button;
  let t1;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      button = element("button");
      t1 = text("arrow_forward_ios");
      attr(input, "type", "password");
      attr(input, "placeholder", "Confirm Password");
      input.disabled = /*loading*/
      ctx[0];
      attr(button, "class", "material-icons-round continue");
      button.disabled = button_disabled_value = /*loading*/
      ctx[0] || !/*username*/
      ctx[1] || !/*password*/
      ctx[2] || !/*confirm*/
      ctx[3] || /*password*/
      ctx[2] !== /*confirm*/
      ctx[3];
      attr(div, "class", "field-wrapper continue");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(
        input,
        /*confirm*/
        ctx[3]
      );
      append(div, t0);
      append(div, button);
      append(button, t1);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[8]
          ),
          listen(
            input,
            "keydown",
            /*keydown*/
            ctx[5]
          ),
          listen(
            button,
            "click",
            /*createAccount*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*loading*/
      1) {
        input.disabled = /*loading*/
        ctx2[0];
      }
      if (dirty & /*confirm*/
      8 && input.value !== /*confirm*/
      ctx2[3]) {
        set_input_value(
          input,
          /*confirm*/
          ctx2[3]
        );
      }
      if (dirty & /*loading, username, password, confirm*/
      15 && button_disabled_value !== (button_disabled_value = /*loading*/
      ctx2[0] || !/*username*/
      ctx2[1] || !/*password*/
      ctx2[2] || !/*confirm*/
      ctx2[3] || /*password*/
      ctx2[2] !== /*confirm*/
      ctx2[3])) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$41($$self, $$props, $$invalidate) {
  let { username } = $$props;
  let { password } = $$props;
  let { loading } = $$props;
  let { errored } = $$props;
  let { runtime } = $$props;
  let confirm = "";
  async function createAccount() {
    $$invalidate(0, loading = true);
    const created = await createUser(username, password);
    if (!created) {
      $$invalidate(6, errored = true);
      $$invalidate(0, loading = false);
      return false;
    }
    await Authenticate(username, password);
    runtime.proceed(username);
    return false;
  }
  function keydown(e2) {
    if (e2.key == "Enter")
      createAccount();
  }
  function input_input_handler() {
    confirm = this.value;
    $$invalidate(3, confirm);
  }
  $$self.$$set = ($$props2) => {
    if ("username" in $$props2)
      $$invalidate(1, username = $$props2.username);
    if ("password" in $$props2)
      $$invalidate(2, password = $$props2.password);
    if ("loading" in $$props2)
      $$invalidate(0, loading = $$props2.loading);
    if ("errored" in $$props2)
      $$invalidate(6, errored = $$props2.errored);
    if ("runtime" in $$props2)
      $$invalidate(7, runtime = $$props2.runtime);
  };
  return [
    loading,
    username,
    password,
    confirm,
    createAccount,
    keydown,
    errored,
    runtime,
    input_input_handler
  ];
}
let Confirm$1 = class Confirm extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$41, create_fragment$4r, safe_not_equal, {
      username: 1,
      password: 2,
      loading: 0,
      errored: 6,
      runtime: 7
    });
  }
};
function create_fragment$4q(ctx) {
  let p2;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "The user already exists.";
      t1 = space();
      button = element("button");
      button.textContent = "Okay";
      attr(p2, "class", "incorrect");
      attr(button, "class", "normal switchuser");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      insert(target, t1, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
        detach(t1);
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$40($$self, $$props, $$invalidate) {
  let { errored } = $$props;
  const click_handler = () => $$invalidate(0, errored = false);
  $$self.$$set = ($$props2) => {
    if ("errored" in $$props2)
      $$invalidate(0, errored = $$props2.errored);
  };
  return [errored, click_handler];
}
class Incorrect2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$40, create_fragment$4q, safe_not_equal, { errored: 0 });
  }
}
function create_fragment$4p(ctx) {
  let input0;
  let t2;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      input0 = element("input");
      t2 = space();
      input1 = element("input");
      attr(input0, "type", "text");
      attr(input0, "placeholder", "Username");
      attr(input0, "class", "field");
      attr(input1, "type", "password");
      attr(input1, "placeholder", "Password");
      attr(input1, "class", "field");
      input1.disabled = /*loading*/
      ctx[2];
    },
    m(target, anchor) {
      insert(target, input0, anchor);
      set_input_value(
        input0,
        /*username*/
        ctx[0]
      );
      insert(target, t2, anchor);
      insert(target, input1, anchor);
      set_input_value(
        input1,
        /*password*/
        ctx[1]
      );
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[3]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*username*/
      1 && input0.value !== /*username*/
      ctx2[0]) {
        set_input_value(
          input0,
          /*username*/
          ctx2[0]
        );
      }
      if (dirty & /*loading*/
      4) {
        input1.disabled = /*loading*/
        ctx2[2];
      }
      if (dirty & /*password*/
      2 && input1.value !== /*password*/
      ctx2[1]) {
        set_input_value(
          input1,
          /*password*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(input0);
        detach(t2);
        detach(input1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3$($$self, $$props, $$invalidate) {
  let { username = "" } = $$props;
  let { password = "" } = $$props;
  let { loading } = $$props;
  function input0_input_handler() {
    username = this.value;
    $$invalidate(0, username);
  }
  function input1_input_handler() {
    password = this.value;
    $$invalidate(1, password);
  }
  $$self.$$set = ($$props2) => {
    if ("username" in $$props2)
      $$invalidate(0, username = $$props2.username);
    if ("password" in $$props2)
      $$invalidate(1, password = $$props2.password);
    if ("loading" in $$props2)
      $$invalidate(2, loading = $$props2.loading);
  };
  return [username, password, loading, input0_input_handler, input1_input_handler];
}
class UserPassword extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3$, create_fragment$4p, safe_not_equal, { username: 0, password: 1, loading: 2 });
  }
}
function create_else_block_1$3(ctx) {
  let welcomespinner;
  let current;
  welcomespinner = new WelcomeSpinner({});
  return {
    c() {
      create_component(welcomespinner.$$.fragment);
    },
    m(target, anchor) {
      mount_component(welcomespinner, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(welcomespinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(welcomespinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(welcomespinner, detaching);
    }
  };
}
function create_if_block$1L(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$B, create_else_block$w];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (!/*errored*/
    ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$w(ctx) {
  let incorrect;
  let updating_errored;
  let current;
  function incorrect_errored_binding(value) {
    ctx[10](value);
  }
  let incorrect_props = {};
  if (
    /*errored*/
    ctx[2] !== void 0
  ) {
    incorrect_props.errored = /*errored*/
    ctx[2];
  }
  incorrect = new Incorrect2({ props: incorrect_props });
  binding_callbacks.push(() => bind$1(incorrect, "errored", incorrect_errored_binding));
  return {
    c() {
      create_component(incorrect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(incorrect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const incorrect_changes = {};
      if (!updating_errored && dirty & /*errored*/
      4) {
        updating_errored = true;
        incorrect_changes.errored = /*errored*/
        ctx2[2];
        add_flush_callback(() => updating_errored = false);
      }
      incorrect.$set(incorrect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(incorrect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(incorrect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(incorrect, detaching);
    }
  };
}
function create_if_block_1$B(ctx) {
  let userpassword;
  let updating_username;
  let updating_password;
  let t0;
  let confirm;
  let updating_loading;
  let updating_errored;
  let t1;
  let actions;
  let current;
  function userpassword_username_binding(value) {
    ctx[6](value);
  }
  function userpassword_password_binding(value) {
    ctx[7](value);
  }
  let userpassword_props = { loading: (
    /*loading*/
    ctx[1]
  ) };
  if (
    /*$username*/
    ctx[4] !== void 0
  ) {
    userpassword_props.username = /*$username*/
    ctx[4];
  }
  if (
    /*password*/
    ctx[3] !== void 0
  ) {
    userpassword_props.password = /*password*/
    ctx[3];
  }
  userpassword = new UserPassword({ props: userpassword_props });
  binding_callbacks.push(() => bind$1(userpassword, "username", userpassword_username_binding));
  binding_callbacks.push(() => bind$1(userpassword, "password", userpassword_password_binding));
  function confirm_loading_binding(value) {
    ctx[8](value);
  }
  function confirm_errored_binding(value) {
    ctx[9](value);
  }
  let confirm_props = {
    username: (
      /*$username*/
      ctx[4]
    ),
    password: (
      /*password*/
      ctx[3]
    ),
    runtime: (
      /*runtime*/
      ctx[0]
    )
  };
  if (
    /*loading*/
    ctx[1] !== void 0
  ) {
    confirm_props.loading = /*loading*/
    ctx[1];
  }
  if (
    /*errored*/
    ctx[2] !== void 0
  ) {
    confirm_props.errored = /*errored*/
    ctx[2];
  }
  confirm = new Confirm$1({ props: confirm_props });
  binding_callbacks.push(() => bind$1(confirm, "loading", confirm_loading_binding));
  binding_callbacks.push(() => bind$1(confirm, "errored", confirm_errored_binding));
  actions = new Actions$5({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(userpassword.$$.fragment);
      t0 = space();
      create_component(confirm.$$.fragment);
      t1 = space();
      create_component(actions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(userpassword, target, anchor);
      insert(target, t0, anchor);
      mount_component(confirm, target, anchor);
      insert(target, t1, anchor);
      mount_component(actions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const userpassword_changes = {};
      if (dirty & /*loading*/
      2)
        userpassword_changes.loading = /*loading*/
        ctx2[1];
      if (!updating_username && dirty & /*$username*/
      16) {
        updating_username = true;
        userpassword_changes.username = /*$username*/
        ctx2[4];
        add_flush_callback(() => updating_username = false);
      }
      if (!updating_password && dirty & /*password*/
      8) {
        updating_password = true;
        userpassword_changes.password = /*password*/
        ctx2[3];
        add_flush_callback(() => updating_password = false);
      }
      userpassword.$set(userpassword_changes);
      const confirm_changes = {};
      if (dirty & /*$username*/
      16)
        confirm_changes.username = /*$username*/
        ctx2[4];
      if (dirty & /*password*/
      8)
        confirm_changes.password = /*password*/
        ctx2[3];
      if (dirty & /*runtime*/
      1)
        confirm_changes.runtime = /*runtime*/
        ctx2[0];
      if (!updating_loading && dirty & /*loading*/
      2) {
        updating_loading = true;
        confirm_changes.loading = /*loading*/
        ctx2[1];
        add_flush_callback(() => updating_loading = false);
      }
      if (!updating_errored && dirty & /*errored*/
      4) {
        updating_errored = true;
        confirm_changes.errored = /*errored*/
        ctx2[2];
        add_flush_callback(() => updating_errored = false);
      }
      confirm.$set(confirm_changes);
      const actions_changes = {};
      if (dirty & /*runtime*/
      1)
        actions_changes.runtime = /*runtime*/
        ctx2[0];
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(userpassword.$$.fragment, local);
      transition_in(confirm.$$.fragment, local);
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(userpassword.$$.fragment, local);
      transition_out(confirm.$$.fragment, local);
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(userpassword, detaching);
      destroy_component(confirm, detaching);
      destroy_component(actions, detaching);
    }
  };
}
function create_fragment$4o(ctx) {
  let div;
  let userheader;
  let t2;
  let current_block_type_index;
  let if_block;
  let current;
  userheader = new UserHeader({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      override: "New User"
    }
  });
  const if_block_creators = [create_if_block$1L, create_else_block_1$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*loading*/
    ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      create_component(userheader.$$.fragment);
      t2 = space();
      if_block.c();
      attr(div, "class", "login-loading");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(userheader, div, null);
      append(div, t2);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const userheader_changes = {};
      if (dirty & /*runtime*/
      1)
        userheader_changes.runtime = /*runtime*/
        ctx2[0];
      userheader.$set(userheader_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(userheader.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(userheader.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(userheader);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$3_($$self, $$props, $$invalidate) {
  let $username;
  let { runtime } = $$props;
  let loading = false;
  let errored = false;
  let username = writable("");
  component_subscribe($$self, username, (value) => $$invalidate(4, $username = value));
  let password = "";
  function userpassword_username_binding(value) {
    $username = value;
    username.set($username);
  }
  function userpassword_password_binding(value) {
    password = value;
    $$invalidate(3, password);
  }
  function confirm_loading_binding(value) {
    loading = value;
    $$invalidate(1, loading);
  }
  function confirm_errored_binding(value) {
    errored = value;
    $$invalidate(2, errored);
  }
  function incorrect_errored_binding(value) {
    errored = value;
    $$invalidate(2, errored);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [
    runtime,
    loading,
    errored,
    password,
    $username,
    username,
    userpassword_username_binding,
    userpassword_password_binding,
    confirm_loading_binding,
    confirm_errored_binding,
    incorrect_errored_binding
  ];
}
class NewUser extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3_, create_fragment$4o, safe_not_equal, { runtime: 0 });
  }
}
function create_if_block$1K(ctx) {
  let button;
  let profilepicture;
  let t0;
  let p2;
  let span;
  let t1;
  let t2;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*pfp*/
      ctx[2]
    ), height: 50 }
  });
  let if_block = (
    /*data*/
    ctx[0].acc.v6 && create_if_block_1$A(ctx)
  );
  return {
    c() {
      button = element("button");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      p2 = element("p");
      span = element("span");
      t1 = text(
        /*name*/
        ctx[1]
      );
      t2 = space();
      if (if_block)
        if_block.c();
      attr(p2, "class", "username");
      attr(button, "class", "user");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(profilepicture, button, null);
      append(button, t0);
      append(button, p2);
      append(p2, span);
      append(span, t1);
      append(p2, t2);
      if (if_block)
        if_block.m(p2, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*go*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      4)
        profilepicture_changes.src = /*pfp*/
        ctx2[2];
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*name*/
      2)
        set_data(
          t1,
          /*name*/
          ctx2[1]
        );
      if (
        /*data*/
        ctx2[0].acc.v6
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$A(ctx2);
          if_block.c();
          if_block.m(p2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(profilepicture);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$A(ctx) {
  let img;
  let img_src_value;
  let img_title_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = UpdateIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(img, "class", "v6");
      attr(img, "title", img_title_value = /*name*/
      ctx[1] + " is a v6 user!");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*name*/
      2 && img_title_value !== (img_title_value = /*name*/
      ctx2[1] + " is a v6 user!")) {
        attr(img, "title", img_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_fragment$4n(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*data*/
    ctx[0].acc.enabled && create_if_block$1K(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*data*/
        ctx2[0].acc.enabled
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*data*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1K(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$3Z($$self, $$props, $$invalidate) {
  let pfp = "";
  let { runtime } = $$props;
  let { data: data2 } = $$props;
  let { name } = $$props;
  async function go() {
    runtime.setUser(name);
    runtime.stateHandler.navigate("existinguserauth");
  }
  onMount(() => {
    $$invalidate(2, pfp = getProfilePicture(data2.acc.profilePicture));
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(4, runtime = $$props2.runtime);
    if ("data" in $$props2)
      $$invalidate(0, data2 = $$props2.data);
    if ("name" in $$props2)
      $$invalidate(1, name = $$props2.name);
  };
  return [data2, name, pfp, go, runtime];
}
let User$1 = class User extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3Z, create_fragment$4n, safe_not_equal, { runtime: 4, data: 0, name: 1 });
  }
};
function get_each_context$K(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  return child_ctx;
}
function create_if_block$1J(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(Object.keys(
    /*users*/
    ctx[1]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$K(get_each_context$K(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*runtime, users, Object*/
      3) {
        each_value = ensure_array_like(Object.keys(
          /*users*/
          ctx2[1]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$K(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$K(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$K(ctx) {
  let user;
  let current;
  user = new User$1({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      data: (
        /*users*/
        ctx[1][
          /*username*/
          ctx[4]
        ]
      ),
      name: (
        /*username*/
        ctx[4]
      )
    }
  });
  return {
    c() {
      create_component(user.$$.fragment);
    },
    m(target, anchor) {
      mount_component(user, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const user_changes = {};
      if (dirty & /*runtime*/
      1)
        user_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*users*/
      2)
        user_changes.data = /*users*/
        ctx2[1][
          /*username*/
          ctx2[4]
        ];
      if (dirty & /*users*/
      2)
        user_changes.name = /*username*/
        ctx2[4];
      user.$set(user_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(user.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(user.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(user, detaching);
    }
  };
}
function create_fragment$4m(ctx) {
  let div1;
  let div0;
  let t0;
  let button;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*users*/
    ctx[1] && create_if_block$1J(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      button = element("button");
      button.textContent = "Create Account";
      attr(div0, "class", "users");
      attr(button, "class", "register normal");
      attr(div1, "class", "login-selector");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div1, t0);
      append(div1, button);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*register*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*users*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*users*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1J(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$3Y($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  const { UserCache: UserCache2 } = runtime;
  let users;
  onMount(async () => {
    UserCache2.subscribe((v2) => v2 && $$invalidate(1, users = v2));
    UserCache2.set(await getUsers());
  });
  async function register2() {
    runtime.setUser(null);
    await sleep();
    runtime.stateHandler.navigate("newuserauth");
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, users, register2];
}
let Selector$1 = class Selector extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3Y, create_fragment$4m, safe_not_equal, { runtime: 0 });
  }
};
const LoginStates = /* @__PURE__ */ new Map([
  [
    "autologin",
    {
      name: "Auto Login",
      content: AutoLogin,
      attribs: {
        topbar: false,
        darken: true,
        className: "center-flex"
      },
      key: "autologin"
    }
  ],
  [
    "existinguserauth",
    {
      name: "Existing User Login",
      content: ExistingUser,
      attribs: {
        topbar: false,
        darken: true,
        className: "center-flex"
      },
      key: "existinguserauth"
    }
  ],
  [
    "newuserauth",
    {
      name: "New User",
      content: NewUser,
      attribs: {
        topbar: false,
        darken: true,
        className: "center-flex"
      },
      key: "newuserauth"
    }
  ],
  [
    "selector",
    {
      name: "Selector",
      content: Selector$1,
      attribs: {
        topbar: true,
        darken: false,
        className: "center-flex"
      },
      key: "selector"
    }
  ],
  [
    "shutdown",
    {
      name: "Shutdown",
      content: AutoLogin,
      attribs: {
        topbar: false,
        darken: true,
        className: "center-flex"
      },
      key: "shutdown",
      onload() {
        setTimeout(() => {
          PrimaryState.navigate("turnedoff");
        }, 2e3);
      }
    }
  ],
  [
    "restart",
    {
      name: "Restart",
      content: AutoLogin,
      attribs: {
        topbar: false,
        darken: true,
        className: "center-flex"
      },
      key: "restart",
      onload() {
        setTimeout(() => {
          location.reload();
        }, 2e3);
      }
    }
  ],
  [
    "logoff",
    {
      name: "Logoff",
      content: AutoLogin,
      attribs: {
        topbar: false,
        darken: true,
        className: "center-flex"
      },
      key: "logoff",
      async onload(runtime) {
        await sleep(2e3);
        runtime.stateHandler.navigate("selector");
      }
    }
  ]
]);
class Login3 {
  constructor(initialState, doOnMount = true) {
    __publicField(this, "UserName", Store$1());
    __publicField(this, "UserCache", Store$1());
    __publicField(this, "userBackground", Store$1("img15"));
    __publicField(this, "stateHandler");
    __publicField(this, "wallpapered", ["autologin", "existinguserauth", "logoff", "restart", "shutdown"]);
    Log("Login", `Creating new login class`);
    this.stateHandler = new LoginStateHandler("Login", LoginStates, initialState, this);
    this.UserCache.subscribe(() => this.updateLoginBackground());
    this.UserName.subscribe(() => this.updateLoginBackground());
    if (doOnMount)
      this.onMount();
  }
  async onMount() {
    const allUsers2 = await getUsers();
    const remembered = localStorage.getItem("arcos-remembered-token");
    const loginState = this.stateHandler.current.get();
    const currentApi = ConnectedServer.get();
    const isFreshApi = !Object.keys(allUsers2).length && !remembered;
    const stateIsIncoming = loginState ? loginState.key != "shutdown" && loginState.key != "restart" : true;
    this.UserCache.set(allUsers2);
    Log("Login", `isFreshApi=${isFreshApi} StateIsIncoming=${stateIsIncoming}`);
    if (isFreshApi) {
      if (!currentApi)
        return PrimaryState.navigate("fts");
      return this.stateHandler.navigate("newuserauth");
    }
    if (!loginState)
      this.stateHandler.navigate(remembered ? "autologin" : "existinguserauth");
    if (!remembered || !stateIsIncoming)
      return;
    const [username, password] = fromBase64(remembered).split(":");
    this.setUser(username);
    const userdata = await this.Authenticate(username, password);
    if (!userdata) {
      this.stateHandler.navigate("existinguserauth");
      localStorage.removeItem("arcos-remembered-token");
      return;
    }
    this.proceed(username);
  }
  updateLoginBackground(v2) {
    Log("Login", "Updating login background");
    const current = this.stateHandler.current.get();
    console.log(current);
    if (current && !this.wallpapered.includes(current.key)) {
      console.log("RESETTINGS");
      this.userBackground.set("img15");
      return;
    }
    v2 = v2 || get_store_value(this.UserCache);
    if (!v2)
      return this.userBackground.set("img15");
    const username = get_store_value(this.UserName);
    const user = v2[username];
    if (!user || !user.acc || !user.acc.loginBackground)
      return this.userBackground.set("img15");
    this.userBackground.set(user.acc.loginBackground);
  }
  async Authenticate(username, password) {
    Log("Login", `Authenticating as "${username}"`);
    const userdata = await Authenticate(username, password);
    if (!userdata)
      return false;
    this.setUser(username);
    return userdata;
  }
  async proceed(username, userdata, delay = 1500) {
    Log("Login", `Proceeding to desktop after ${delay / 1e3} seconds`);
    if (userdata)
      UserDataStore.set(userdata);
    this.UserName.set(username);
    this.setUser(username);
    await sleep(delay);
    PrimaryState.navigate("desktop");
  }
  setUser(username) {
    Log("Login", `Setting user to ${username}`);
    this.UserName.set(username);
    this.updateLoginBackground();
  }
}
function SettingsStore() {
  return /* @__PURE__ */ new Map([
    [
      "account",
      {
        key: "account",
        name: "Your Account",
        content: Account,
        attribs: {
          hidden: true
        },
        image: AccountIcon
      }
    ],
    [
      "themes",
      {
        key: "themes",
        name: "Themes",
        content: Themes,
        attribs: {},
        image: ThemesIcon,
        className: "safemode-hidden"
      }
    ],
    [
      "wallpaper",
      {
        key: "wallpaper",
        name: "Wallpaper",
        content: Wallpaper,
        attribs: {},
        image: DesktopIcon$1,
        className: "safemode-hidden"
      }
    ],
    [
      "login",
      {
        key: "login",
        name: "Login Background",
        content: Login$1,
        attribs: {},
        image: PasswordIcon,
        className: "safemode-hidden"
      }
    ],
    [
      "visuals",
      {
        key: "visuals",
        name: "Visuals",
        content: Visuals,
        attribs: { separator: true },
        image: PersonalizationIcon,
        className: "safemode-hidden"
      }
    ],
    [
      "shell",
      {
        key: "shell",
        name: "Shell",
        content: Shell,
        attribs: {},
        image: TaskbarIcon,
        className: "safemode-hidden"
      }
    ],
    [
      "windows",
      {
        key: "windows",
        name: "Windows",
        content: Windows,
        attribs: {},
        image: WindowSettingsIcon,
        className: "safemode-hidden"
      }
    ],
    [
      "apps",
      {
        key: "apps",
        name: "Apps",
        content: Apps,
        attribs: { separator: true },
        image: AppsIcon
      }
    ],
    [
      "about",
      {
        key: "about",
        name: "About ArcOS",
        content: About,
        attribs: {},
        image: Logo()
      }
    ]
  ]);
}
function compileSearchableSettingsPages() {
  const result = [];
  const pages = SettingsStore();
  for (const [id, page] of pages) {
    result.push({
      image: page.image,
      caption: page.name,
      description: "Settings Page",
      action: () => {
        OpenSettingsPage(id);
      }
    });
  }
  return result;
}
const searchProviders = [
  compileSearchableApps,
  compileSearchableSettingsPages,
  compileSearchableFiles
];
const powerOptions = [
  {
    caption: "Shutdown",
    description: "Leave the desktop and turn off ArcOS",
    action: shutdown,
    image: ShutdownIcon
  },
  {
    caption: "Restart",
    description: "Leave the desktop and reload ArcOS",
    action: () => restart$3(),
    image: ShutdownIcon
  }
];
async function getSearchItems() {
  let result = [...powerOptions];
  for (let i2 = 0; i2 < searchProviders.length; i2++) {
    result.push(...await searchProviders[i2]());
  }
  return result;
}
async function Search2(query) {
  const items = await getSearchItems();
  const options2 = {
    includeScore: true,
    keys: ["caption", "description"]
  };
  const fuse = new Fuse(items, options2);
  const result = fuse.search(query);
  return result;
}
let Runtime$i = class Runtime5 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "Query", Store$1(""));
    __publicField(this, "Tree", Store$1([]));
    __publicField(this, "Results", Store$1([]));
    __publicField(this, "SelectionIndex", Store$1(0));
    process.accelerator.store.push({
      key: "escape",
      action() {
        process.handler.kill(process.pid, true);
      }
    });
    this._init();
  }
  async _init() {
    this.Tree.set(await GetFilesystemTree());
    this.Query.subscribe(async (v2) => {
      const results = await Search2(v2);
      this.Results.set(results.map((r2) => r2.item));
    });
  }
  async Trigger(result) {
    await result.action(result);
    this.closeApp();
  }
  async Submit() {
    const results = this.Results.get();
    const index = this.SelectionIndex.get();
    if (!results.length)
      return;
    this.Query.set("");
    this.Trigger(results[index == -1 ? 0 : index]);
  }
  MutateIndex(e2) {
    const key2 = e2.key.toLowerCase();
    const results = this.Results.get();
    let index = this.SelectionIndex.get();
    if (!results.length)
      return index = -1;
    if (key2 == "enter")
      return this.Submit();
    let length = results.length - 1;
    switch (key2) {
      case "arrowup":
        index--;
        if (index < 0)
          index = length;
        break;
      case "arrowdown":
        index++;
        if (index > length)
          index = 0;
        break;
    }
    this.SelectionIndex.set(index);
  }
};
const main$v = "";
function create_if_block$1I(ctx) {
  let p2;
  let t_value = (
    /*result*/
    ctx[0].description + ""
  );
  let t2;
  return {
    c() {
      p2 = element("p");
      t2 = text(t_value);
      attr(p2, "class", "description");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      append(p2, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*result*/
      1 && t_value !== (t_value = /*result*/
      ctx2[0].description + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_fragment$4l(ctx) {
  let button;
  let img;
  let img_src_value;
  let t0;
  let div;
  let p2;
  let t1_value = (
    /*result*/
    ctx[0].caption + ""
  );
  let t1;
  let t2;
  let mounted;
  let dispose;
  let if_block = (
    /*result*/
    ctx[0].description && create_if_block$1I(ctx)
  );
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      div = element("div");
      p2 = element("p");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      if (!src_url_equal(img.src, img_src_value = /*result*/
      ctx[0].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(p2, "class", "caption");
      attr(div, "class", "context");
      attr(button, "class", "result");
      toggle_class(
        button,
        "selected",
        /*index*/
        ctx[2] == /*$SelectionIndex*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, div);
      append(div, p2);
      append(p2, t1);
      append(div, t2);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*result*/
      1 && !src_url_equal(img.src, img_src_value = /*result*/
      ctx2[0].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*result*/
      1 && t1_value !== (t1_value = /*result*/
      ctx2[0].caption + ""))
        set_data(t1, t1_value);
      if (
        /*result*/
        ctx2[0].description
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1I(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*index, $SelectionIndex*/
      12) {
        toggle_class(
          button,
          "selected",
          /*index*/
          ctx2[2] == /*$SelectionIndex*/
          ctx2[3]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$3X($$self, $$props, $$invalidate) {
  let $SelectionIndex;
  let { result } = $$props;
  let { runtime } = $$props;
  let { index } = $$props;
  const { SelectionIndex } = runtime;
  component_subscribe($$self, SelectionIndex, (value) => $$invalidate(3, $SelectionIndex = value));
  const click_handler = () => runtime.Trigger(result);
  $$self.$$set = ($$props2) => {
    if ("result" in $$props2)
      $$invalidate(0, result = $$props2.result);
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
    if ("index" in $$props2)
      $$invalidate(2, index = $$props2.index);
  };
  return [result, runtime, index, $SelectionIndex, SelectionIndex, click_handler];
}
class Result extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3X, create_fragment$4l, safe_not_equal, { result: 0, runtime: 1, index: 2 });
  }
}
function get_each_context$J(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list2[i2];
  child_ctx[11] = i2;
  return child_ctx;
}
function create_each_block$J(ctx) {
  let result_1;
  let current;
  result_1 = new Result({
    props: {
      result: (
        /*result*/
        ctx[9]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      index: (
        /*index*/
        ctx[11]
      )
    }
  });
  return {
    c() {
      create_component(result_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(result_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const result_1_changes = {};
      if (dirty & /*$Results*/
      8)
        result_1_changes.result = /*result*/
        ctx2[9];
      if (dirty & /*runtime*/
      1)
        result_1_changes.runtime = /*runtime*/
        ctx2[0];
      result_1.$set(result_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(result_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(result_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(result_1, detaching);
    }
  };
}
function create_fragment$4k(ctx) {
  let div0;
  let span;
  let t1;
  let input_1;
  let t2;
  let div1;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*$Results*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$J(get_each_context$J(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div0 = element("div");
      span = element("span");
      span.textContent = "search";
      t1 = space();
      input_1 = element("input");
      t2 = space();
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(span, "class", "material-icons-round");
      attr(input_1, "type", "text");
      attr(input_1, "placeholder", "Search settings, files and apps");
      attr(div0, "class", "search-bar");
      attr(div1, "class", "results");
      toggle_class(
        div1,
        "show",
        /*$Results*/
        ctx[3].length
      );
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, span);
      append(div0, t1);
      append(div0, input_1);
      set_input_value(
        input_1,
        /*$Query*/
        ctx[2]
      );
      ctx[7](input_1);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input_1,
            "input",
            /*input_1_input_handler*/
            ctx[6]
          ),
          listen(
            input_1,
            "keydown",
            /*keydown_handler*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$Query*/
      4 && input_1.value !== /*$Query*/
      ctx2[2]) {
        set_input_value(
          input_1,
          /*$Query*/
          ctx2[2]
        );
      }
      if (dirty & /*$Results, runtime*/
      9) {
        each_value = ensure_array_like(
          /*$Results*/
          ctx2[3]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$J(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$J(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*$Results*/
      8) {
        toggle_class(
          div1,
          "show",
          /*$Results*/
          ctx2[3].length
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t2);
        detach(div1);
      }
      ctx[7](null);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3W($$self, $$props, $$invalidate) {
  let $Query;
  let $Results;
  let { runtime } = $$props;
  const { Query, Results } = runtime;
  component_subscribe($$self, Query, (value) => $$invalidate(2, $Query = value));
  component_subscribe($$self, Results, (value) => $$invalidate(3, $Results = value));
  let input;
  onMount(async () => {
    await sleep(100);
    input.focus();
  });
  function input_1_input_handler() {
    $Query = this.value;
    Query.set($Query);
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(1, input);
    });
  }
  const keydown_handler = (e2) => runtime.MutateIndex(e2);
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [
    runtime,
    input,
    $Query,
    $Results,
    Query,
    Results,
    input_1_input_handler,
    input_1_binding,
    keydown_handler
  ];
}
let App$p = class App6 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3W, create_fragment$4k, safe_not_equal, { runtime: 0 });
  }
};
const ArcFind = {
  metadata: {
    name: "ArcFind",
    description: "Search through ArcOS",
    author: "The ArcOS Team",
    version: "2.0.0",
    icon: ArcFindIcon,
    hidden: true,
    appGroup: "internal",
    dependendsOn: ["ArcShell"]
  },
  runtime: Runtime$i,
  content: App$p,
  id: "ArcFind",
  size: { w: 600, h: 500 },
  minSize: { w: 600, h: 500 },
  maxSize: { w: 600, h: 500 },
  pos: { x: 0, y: 0 },
  state: {
    minimized: false,
    maximized: false,
    headless: true,
    fullscreen: false,
    resizable: false
  },
  controls: {
    minimize: false,
    maximize: false,
    close: false
  },
  singleInstance: true,
  isOverlay: true,
  loadCondition: () => !SafeMode.get()
};
const AppList = {
  keyword: "applist",
  exec(cmd, argv, term, flags) {
    const all3 = flags.a || flags.all;
    const store = appLibrary.get();
    header$1(term);
    for (const [_2, app] of store) {
      if (!isPopulatable(app) && !all3)
        continue;
      output(term, app);
    }
  },
  help(term) {
    term.std.writeLine(
      "ArcOS applications are stored in the App Library. The `applist`\ncommand displays this library. Each library item has an ID\nalong with its App data.\n\nBy default, only non-hidden applications are displayed in this table.\nUse the `--all` or `-a` option to override this condition.\n "
    );
    term.std.writeColor("Example: [applist] --all", "blue");
  },
  description: "List all- or opened ArcOS apps.",
  flags: [{ keyword: "a|all" }]
};
function output(term, app) {
  const aid = app.id.padEnd(30, " ");
  const name = app.metadata.name.padEnd(30, " ");
  const version = app.metadata.version;
  term.std.writeColor(`${name}[${aid}]${version}`, "gray");
}
function header$1(term) {
  const hName = `Name`.padEnd(30, " ");
  const hId = `ID`.padEnd(30, " ");
  const hVer = `Version`;
  const head = `${hName}${hId}${hVer}`;
  term.std.writeColor(`[${head}]`, "yellow");
  term.std.writeSeparator(head.length);
}
function getCPU() {
  const cpu = {
    cores: navigator.hardwareConcurrency || 4
  };
  return cpu;
}
const GPU_VENDOR_REGEX = /(intel|nvidia|sis|amd|apple|powervr)\W? (.+)/i;
const GPU_RENDERER_REGEX = /(((?:radeon|adreno|geforce|mali).+))/i;
const GPU_CLEANUP_REGEX = / ?(\(.+?\)| direct3d.+| opengl.+|\/.+$| gpu$)/gi;
function getGPU() {
  const gpu = {
    supported: "WebGLRenderingContext" in globalThis,
    active: false,
    vendor: void 0,
    model: void 0
  };
  const canvas = document.createElement("canvas");
  const gl = canvas.getContext("webgl2") || canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
  if (!gl)
    return gpu;
  gpu.active = true;
  const info2 = gl.getExtension("WEBGL_debug_renderer_info");
  gpu.vendor = gl.getParameter(info2.UNMASKED_VENDOR_WEBGL);
  const renderer = gl.getParameter(info2.UNMASKED_RENDERER_WEBGL) ?? "";
  const vendorMathes = renderer.match(GPU_VENDOR_REGEX);
  const modelMathes = renderer.match(GPU_RENDERER_REGEX);
  if (vendorMathes)
    gpu.vendor = vendorMathes[1];
  gpu.model = modelMathes ? modelMathes[1] : renderer;
  gpu.model = gpu.model.replace(GPU_CLEANUP_REGEX, "");
  return gpu;
}
function getMEM() {
  const nav = navigator;
  return { kb: (nav.deviceMemory || 1) * 1024 ** 3 };
}
const defaultNetwork = {
  downlink: 0,
  effectiveType: "0G",
  rtt: 0,
  saveData: false,
  online: false
};
function getNET() {
  const connection = navigator.connection;
  if (!connection)
    return defaultNetwork;
  return connection;
}
function getDeviceInfo() {
  return {
    gpu: getGPU(),
    cpu: getCPU(),
    mem: getMEM(),
    net: getNET()
  };
}
const ArcFetch = {
  keyword: "arcfetch",
  async exec(cmd, argv, term) {
    term.std.writeLine("\n");
    await graphic(term);
    term.std.writeLine("");
    colorBar(term);
  },
  description: "Show system information"
};
async function getItems(a2) {
  const info2 = getDeviceInfo();
  const desktop = isDesktop();
  const desktopStr = desktop ? "Desktop" : "Browser";
  const state = PrimaryState.current.get().name;
  return Object.entries({
    OS: `ArcOS ${ArcOSVersion}-${ARCOS_MODE} (${ARCOS_BUILD})`,
    Host: `${getServer()} @ rev ${minArcAPI}`,
    Username: UserName.get(),
    Mode: `${desktopStr} (state ${state})`,
    Terminal: a2.referenceId,
    CPU: `${info2.cpu.cores} cores`,
    GPU: `${info2.gpu.vendor} ${info2.gpu.model}`,
    Memory: `~ ${formatBytes(info2.mem.kb)}`
  });
}
function colorBar(term) {
  term.std.write("\n                            ");
  for (const color of colors) {
    term.std.writeColor("[██ ]", color, "white", true);
  }
}
async function graphic(term) {
  const items = await getItems(term);
  const graphicParts = [
    "           ",
    "     /\\    ",
    "    /  \\   ",
    "   / /\\ \\  ",
    "  / ____ \\ ",
    " /_/    \\_\\",
    "           ",
    "           "
  ];
  for (let i2 = 0; i2 < graphicParts.length; i2++) {
    term.std.writeColor(`  [${graphicParts[i2]}]    `, "blue", "white", true);
    if (items[i2]) {
      term.std.writeColor(
        `[${items[i2][0].padEnd(12, " ")}]: ${items[i2][1]}`,
        "purple",
        "white",
        true
      );
    }
    term.std.writeLine("");
  }
}
const ATConf = {
  keyword: "atconf",
  async exec() {
    const partial = await getPartialFile("./arcterm.conf");
    openFileWithApp("TextEditor", partial);
  },
  description: "Edit your ArcTerm configuration in the Text Editor"
};
const Base64Command = {
  keyword: "b64",
  async exec(cmd, argv, term, flags) {
    const { var: variable, input, encode: encode2, decode, silent } = flags;
    if (encode2 && decode)
      return term.std.Error("Can't both encode and decode, goof...");
    if (silent && !variable)
      return term.std.Error(
        "--silent and no --variable? That's the same as hitting Enter on an empty prompt..."
      );
    let output2;
    if (encode2)
      output2 = toBase64(input);
    if (decode)
      output2 = fromBase64(input);
    if (!encode2 && !decode)
      return term.std.Error("Don't know what to do... --encode or --decode?");
    if (variable) {
      const set = await term.vars.set(variable, output2);
      if (!set)
        return term.std.Error(`Failed to set variable [${variable}]: it might be read-only.`);
    }
    if (!silent)
      term.std.writeLine(`${input} -> ${output2}`);
  },
  description: "Encodes or decodes a Base64 string",
  flags: [
    {
      keyword: "var",
      value: {
        name: "variable",
        type: "other"
      },
      description: "Variable to write the data to"
    },
    {
      keyword: "input",
      required: true,
      value: {
        name: "string",
        type: "string"
      },
      description: "The data to encode or decode"
    },
    {
      keyword: "encode",
      description: "Specify to encode the input"
    },
    {
      keyword: "decode",
      description: "Specify to decode the input"
    },
    {
      keyword: "silent",
      description: "Hide the output (requires --var to be set)"
    }
  ]
};
const BgCommand = {
  keyword: "bgs",
  exec(cmd, argv, term) {
    const backgrounds = Wallpapers;
    const keys = Object.keys(backgrounds).sort((a2, b2) => a2 < b2 ? -1 : 1);
    for (const key2 of keys) {
      const value = backgrounds[key2];
      const keyStr = key2.padStart(6, " ");
      const nameStr = value.name.padEnd(30, " ");
      term.std.writeColor(`${keyStr}: [${nameStr}] by ${value.author}`, "purple");
    }
  },
  description: "List ArcOS Backgrounds"
};
const BugRep = {
  keyword: "bugrep",
  async exec(cmd, argv, term, flags) {
    const Regx = argv.join(" ").match(/"(.*?)"/);
    const includeUserData = !flags["no-ud"];
    const includeApi = !flags["no-api"];
    if (Regx && Regx.length > 1) {
      const text2 = term.vars.replace(Regx[1]);
      term.std.writeColor("[BugRep]: Creating bug report...\n\n[ReportOptions]\n", "yellow");
      const opt = {
        includeApi,
        includeUserData,
        title: text2
      };
      term.std.writeLine(JSON.stringify(opt, null, 2) + "\n");
      const id = await sendReport(opt);
      term.std.Info(`Created with id [${id}]. Thank you!`);
      return;
    }
    term.std.Error("Unable to submit report: syntax invalid!");
  },
  description: "Create a bug report.",
  syntax: `"<[body]>" (--[no-ud]) (--[no-api])`,
  hidden: true
};
const Cd = {
  keyword: "cd",
  async exec(cmd, argv, term) {
    const cwd = term.path.endsWith("/") ? term.path.slice(0, -1) : term.path;
    const newPath = argv.join(" ");
    const path = `${cwd}/${newPath}`;
    if (newPath == "/")
      return term.path = "./";
    const directory = await readDirectory(path);
    if (!directory) {
      return err(term, path);
    }
    const dir = directory;
    if (dir.scopedPath.includes(".."))
      return err(term, path);
    term.path = dir.scopedPath;
  },
  help(term) {
    term.std.writeColor("[NOTE]: Capitalization matters.", "yellow");
    term.std.writeColor("Example: [cd] ../Documents", "blue");
  },
  description: "Change directory",
  syntax: "[<path>]"
};
function err(t2, p2) {
  return t2.std.Error(`Can't change to "${p2}": Path not found`);
}
const Clear$1 = {
  keyword: "clear",
  exec(cmd, argv, term) {
    term.input.current = null;
    setTimeout(() => {
      term.std.clear();
      term.input.unlock();
    });
  },
  description: "Clears the screen"
};
const Colors = {
  keyword: "colors",
  exec(cmd, argv, term) {
    const str = argv.join(" ").trim() || "The quick brown fox jumps over the lazy dog.";
    const colors2 = [
      "gray",
      "white",
      "red",
      "orange",
      "yellow",
      "green",
      "aqua",
      "blue",
      "purple"
    ];
    for (const color of colors2) {
      term.std.writeColor(`${color.padEnd(10, " ")}: [${str}]`, color);
    }
  },
  description: "Print out all ArcTerm colors",
  syntax: "([sample?])",
  hidden: true
};
const Config = {
  keyword: "config",
  exec(cmd, argv, term) {
    const e2 = Object.entries(term.env.config.getConfig());
    for (const [k2, v2] of e2) {
      const str = v2.toString().replaceAll("\n", "\\n");
      const key2 = k2.padEnd(20, " ");
      if (k2 === "gooseBumps")
        continue;
      term.std.writeColor(`# [${key2}]: `, "blue", "white", true);
      term.std.write(`${str}`);
      term.std.writeLine("");
    }
  },
  description: "List configuration options"
};
const Dir = {
  keyword: "dir",
  async exec(cmd, argv, term) {
    const path = term.path;
    const dir = await readDirectory(path);
    if (argv[0])
      return specific$2(argv[0], path, term);
    all$2(dir, term);
  },
  description: "List the contents of the current directory",
  syntax: `<[path]>`
};
function all$2(dir, term) {
  const subdirs = sortDirectories(dir.directories);
  const files = sortFiles(dir.files);
  for (const dir2 of subdirs) {
    const subdir = dir2;
    term.std.writeColor(`-- --- ----, --:-- <directory> [${subdir.name}]/`, "blue");
  }
  for (const file of files) {
    const date = dayjs(file.dateModified || 0).format("DD MMM YYYY, HH:mm").padEnd(19, " ");
    const size = formatBytes(file.size || 0).padEnd(12, " ");
    term.std.writeColor(`${date}${size}[${file.filename}]`, "blue");
  }
  if (subdirs.length == 0 && files.length == 0) {
    term.std.writeLine("This folder is empty.");
  }
}
async function specific$2(path, currentPath, term) {
  if (currentPath != ".") {
    path = currentPath + "/" + path;
  }
  const dir = await readDirectory(path);
  const subdirs = sortDirectories(dir.directories);
  const files = sortFiles(dir.files);
  if (dir.scopedPath == void 0) {
    term.std.Error(`The directory doesn't exist in this path.`);
    return;
  }
  for (const dir2 of subdirs) {
    term.std.writeColor(`-- --- ----, --:-- <directory> [${dir2.name}]/`, "blue");
  }
  for (const file of files) {
    const date = dayjs(file.dateModified || 0).format("DD MMM YYYY, HH:mm").padEnd(19, " ");
    const size = formatBytes(file.size || 0).padEnd(12, " ");
    term.std.writeColor(`${date}${size}[${file.filename}]`, "blue");
  }
  if (subdirs.length == 0 && files.length == 0) {
    term.std.writeLine("This folder is empty.");
  }
}
function tryParseInt(input) {
  try {
    return parseInt(input);
  } catch {
    return null;
  }
}
const Dispatch = {
  keyword: "dispatch",
  exec(cmd, argv, term, flags) {
    const command = flags.cmd;
    const data2 = flags.data;
    const app = flags.app;
    const pid = tryParseInt(flags.pid);
    const list2 = flags.list;
    if (list2) {
      term.std.writeLine("Global dispatches known to ArcOS:");
      for (const key2 in DispatchCaptions) {
        const keyStr = key2.padEnd(25, " ");
        term.std.writeColor(`[${keyStr}] ${DispatchCaptions[key2]}`, "blue");
      }
      return;
    }
    if (!command)
      return term.std.Error("Nothing to dispatch!");
    if (!app && !pid) {
      GlobalDispatch.dispatch(command, data2);
      term.std.Info(`Dispatched [${command}] over GlobalDispatch.`);
      return;
    }
    if (app) {
      ProcessStack.dispatch.dispatchToApp(app, command, data2);
      term.std.Info(`Dispatched [${command}] to app [${app}] over ProcessDispatcher`);
    } else if (pid) {
      ProcessStack.dispatch.dispatchToPid(pid, command, data2);
      term.std.Info(`Dispatched [${command}] to process [${pid}] over ProcessDispatcher`);
    }
  },
  description: "Dispatch a global command",
  flags: [
    {
      keyword: "cmd",
      value: {
        name: "command",
        type: "string"
      },
      description: "The command to dispatch"
    },
    {
      keyword: "data",
      value: {
        name: "string",
        type: "string"
      },
      description: "Data to send in as the first argument"
    },
    {
      keyword: "app",
      value: {
        name: "id",
        type: "string"
      },
      description: "Optional app ID to dispatch to"
    },
    {
      keyword: "pid",
      value: {
        name: "pid",
        type: "number"
      },
      description: "Optional process PID to dispatch to"
    },
    {
      keyword: "list",
      description: "Display a list of available Global Dispatches"
    }
  ]
};
const Echo = {
  keyword: "echo",
  exec(cmd, argv, term) {
    const Regx = argv.join(" ").match(/"(.*?)"/);
    if (Regx && Regx.length > 1) {
      const text2 = term.vars.replace(Regx[1]);
      term.std.writeLine(text2);
      return;
    }
    term.std.Error("Unable to echo: syntax invalid!");
  },
  help(term) {
    term.std.writeColor('Example: [echo] "I <3 ArcOS!"', "blue");
  },
  description: "Echo a string.",
  syntax: `"<[string]>"`
};
const End = {
  keyword: "end",
  exec(cmd, argv, term) {
    const reason = argv.join(" ").trim();
    if (reason)
      term.std.writeLine(reason);
    return false;
  },
  description: "Quit ArcTerm"
};
const Err = {
  keyword: "err",
  async exec(cmd, argv, term) {
    term.std.writeLine("\n");
    const input = await term.std.read(
      "Are you sure you want to proceed? This WILL hang ArcOS. Y/N [",
      "]",
      1
    );
    term.std.writeLine("\n");
    if (input != "y")
      return term.std.Error("Aborted.");
    term.std.Warning("Goodbye.");
    window["document"] = fromBase64("!#");
  },
  description: "Simulate an error to be picked up by svelte:head",
  hidden: true
};
const Exec = {
  keyword: "exec",
  async exec(cmd, argv, term) {
    const path = term.path;
    const fn = argv.join(" ").trim();
    const dir = await readDirectory(path);
    for (const file of dir.files) {
      if (file.filename != fn)
        continue;
      await term.scripts.runScriptFile(file.scopedPath);
    }
  },
  help(term) {
    term.std.writeColor("[NOTE]: Capitalization matters.", "yellow");
    term.std.writeColor("Example: [exec] mwomp.txt", "blue");
  },
  description: "Execute ArcTerm commands from a file",
  syntax: "<[filename]>"
};
const Exit = {
  keyword: "exit",
  exec(cmd, argv, term) {
    if (!term.pid)
      return term.std.Error("can't close ArcTerm: no associated PID in constructor");
    ProcessStack.kill(term.pid, true);
  },
  description: "Quit ArcTerm"
};
const ExploreCommand = {
  keyword: "explore",
  description: "Open current directory in the File Manager",
  exec(cmd, argv, term) {
    spawnApp("FileManager", 0, [term.path]);
  }
};
const FindCommand = {
  keyword: "find",
  async exec(cmd, argv, term, flags) {
    const query = tryJsonConvert(argv.join(" "));
    const results = (await Search2(query.toString())).map((r2) => r2.item);
    if (!results.length)
      return term.std.Warning("ArcTerm didn't find anything! Try changing your search query.");
    results.splice(6);
    const selection = await term.std.select([
      "(Cancel)",
      ...results.map((r2) => `${r2.caption.padEnd(30, " ")} - ${r2.description || "No description"}`)
    ]);
    if (selection == 0)
      return;
    const result = results[selection - 1];
    await result.action(result);
  },
  description: "Find files, settings and apps in ArcOS"
};
const Goose = {
  keyword: "goose",
  async exec(c2, argv, term) {
    if (argv[0] != "bumps") {
      await Default$1.exec(c2, argv, term, {});
      return;
    }
    if (!term.env.gooseBumps) {
      return dummy(term);
    }
    return await gooses(term);
  },
  description: "GooseBumps 👀"
};
function dummy(term) {
  const parts = [
    "                                   ___",
    '                               ,-""   `.',
    "                             ,'  _   e )`-._",
    "                            /  ,' `-._<.===-'",
    "                           /  /",
    "                          /  ;",
    "              _          /   ;",
    ' (`._    _.-"" ""--..__,\'    |',
    ' <_  `-""                     \\',
    "  <`-                          :",
    "   (__   <__.                  ;",
    "     `-.   '-.__.      _.'    /",
    "        \\      `-.__,-'    _,'",
    "         `._    ,    /__,-'",
    `            ""._\\__,'< <____`,
    "                 | |  `----.`.",
    "                 | |        \\ `.",
    "                 ; |___      \\-``",
    "                 \\   --<",
    "                  `.`.<",
    "                    `-'"
  ];
  parts.forEach((part) => {
    term.std.writeLine(part);
  });
}
async function gooses(term) {
  term.std.Warning("Super duper secret thingy approaching! Welcome to the GooseBumps.");
  term.std.writeLine("\n");
  const options2 = {
    "(Cancel)": "$cancel",
    "Change State": "state",
    "Print Colors": "colors",
    "Dump UserData": "udd",
    "Dump Logs": "logdump",
    "Submit Test Bug Report": "bugrep",
    "View base report info": "repinfo",
    "Crash ArcOS": "err"
  };
  const cmd = Object.values(options2)[await term.std.select(Object.keys(options2), "orange")];
  if (cmd == "$cancel")
    return;
  term.std.writeLine("\n");
  const arg = (await term.std.read("Arguments: [", "]", 128)).split(" ");
  const result = await term.commandHandler.evaluate(cmd, arg, false, gooseBumpsCommands);
  return result;
}
const Goto = {
  keyword: "goto",
  async exec(cmd, argv, term) {
    const sectName = argv[0];
    const sect = term.sect.get(sectName);
    if (!sect) {
      term.std.Error(`Can't find section ${sectName}`);
      return false;
    }
    await term.input.processCommands(sect || [], `<Sect ${sectName}>`);
    return false;
  },
  description: "Goto a section"
};
function getJsonHierarchy(object, hierarchy) {
  const parts = hierarchy.split(".");
  let currentObj = object;
  for (const part of parts) {
    if (!currentObj[part])
      return null;
    currentObj = currentObj[part];
  }
  return currentObj;
}
function setJsonHierarchy(object, hierarchy, value) {
  const parts = hierarchy.split(".");
  const lastIndex = parts.length - 1;
  let currentObj = object;
  for (let i2 = 0; i2 < lastIndex; i2++) {
    const key2 = parts[i2];
    if (currentObj[key2] === void 0) {
      currentObj[key2] = {};
    }
    currentObj = currentObj[key2];
  }
  if (value === null)
    delete currentObj[parts[lastIndex]];
  else
    currentObj[parts[lastIndex]] = value;
  return getJsonHierarchy(object, hierarchy);
}
const GUD = {
  keyword: "gud",
  exec(cmd, argv, term, flags) {
    const hierarchy = argv[0];
    const udata = UserDataStore.get();
    const currentValue = hierarchy ? getJsonHierarchy(udata, hierarchy) : udata;
    if (hierarchy && hierarchy.startsWith("-"))
      return term.std.Error("Hierarchy has to be the first argument!");
    if (!currentValue && typeof currentValue === "undefined" && hierarchy)
      return term.std.Error(`Can't find [UserData.${hierarchy}]!`);
    if (flags.var && typeof flags.var === "boolean")
      return term.std.Error("Need a variable to write to!");
    term.vars.set(flags.var, currentValue);
    term.std.writeLine(JSON.stringify(currentValue, null, 2));
  },
  description: "Get a UserData parameter",
  help: (term) => {
    term.std.writeColor(`Example: [sud] sh.desktop.theme`, "blue");
  },
  flags: [
    {
      keyword: "var",
      value: {
        name: "variable",
        type: "other"
      },
      description: "Variable to write the result to"
    }
  ]
};
const Help$2 = {
  keyword: "help",
  exec(cmd, argv, term, flags) {
    if (flags.count)
      return term.std.writeColor(`ArcTerm has [${term.commands.length}] commands.`, "aqua");
    if (argv[0] && !argv[0].startsWith("--"))
      return specific$1(argv[0], term);
    all$1(term, !flags.list);
  },
  help(term) {
    term.std.writeColor("Example: [help] help", "blue");
  },
  description: "Display a list of built-in commands",
  syntax: "([command?])",
  flags: [
    {
      keyword: "count",
      description: "Show the amount of ArcTerm commands."
    },
    {
      keyword: "list",
      description: "Show a list of ArcTerm commands with their descriptions. This flag doesn't work with --count."
    }
  ]
};
function all$1(term, short) {
  const cmd = term.commands.sort((a2, b2) => {
    return b2.keyword < a2.keyword ? 1 : -1;
  });
  if (short)
    return term.std.writeColor(`[${cmd.map((c2) => c2.keyword).join("  ")}]`, "aqua");
  for (const command of cmd) {
    const a2 = command.keyword.toUpperCase().padEnd(15, " ");
    const b2 = command.description;
    term.std.writeColor(`[${a2}]${b2}`, command.hidden ? "purple" : "orange");
  }
}
function specific$1(command, term) {
  const c2 = term.commandHandler.getCommand(command);
  if (!c2 || c2.keyword == Default$1.keyword)
    return term.std.Error(`${command}: command not found.`);
  if (!c2.help) {
    term.std.writeColor(`[${c2.keyword.toUpperCase()}]: ${c2.description}`, "blue");
    term.std.writeLine("\n");
  }
  const flagStr = term.commandHandler.compileFlagStr(c2);
  const helpSwitches = term.commandHandler.compileHelpSwitches(c2);
  term.std.writeColor(`Usage: ${flagStr}
${helpSwitches}`, "blue");
  term.std.writeLine("\n");
  if (c2.help)
    return c2.help(term);
}
const History = {
  keyword: "history",
  exec(cmd, argv, term, flags) {
    if (flags.clear)
      return clear$1(term);
    const hist = term.history.store.get();
    for (let i2 = 0; i2 < hist.length; i2++) {
      const index = `${i2}`.padStart(3, "0");
      term.std.writeColor(`[${index}]: ${hist[i2]}`, "yellow");
    }
  },
  help(term) {
    term.std.writeColor("Example: [history] --clear", "blue");
  },
  description: "Show the command history",
  flags: [
    {
      keyword: "clear",
      description: "Clear the history buffer"
    }
  ]
};
function clear$1(term) {
  const len = term.history.store.get().length;
  term.history.clear();
  term.std.Info(`History cleared, ${len} items removed.`);
}
const If = {
  keyword: "if",
  async exec(cmd, argv, term) {
    const regex = /\[(?: |)\"(?<e1>.*?)\"(?: |)(?<mode>!=|==)(?: |)\"(?<e2>.*?)\"(?: |)\](?: |)(?<cmd>.+)/gm;
    const str = argv.join(" ");
    const r2 = regex.exec(str);
    if (!r2 || !r2.groups) {
      term.std.Error("Invalid statement!");
      return true;
    }
    const result = r2.groups;
    const split = result.cmd.split(" ");
    const command = split[0];
    split.shift();
    async function doIt() {
      return await term.commandHandler.evaluate(command, split, true);
    }
    if (result.mode == "!=" && result.e1 !== result.e2) {
      return await doIt();
    }
    if (result.mode == "==" && result.e1 === result.e2) {
      return await doIt();
    }
  },
  description: "Test a condition to execute some code"
};
const InDesktop = {
  keyword: "indesktop",
  async exec(cmd, argv, term) {
    const is = isDesktop();
    term.std.writeColor(
      `[STATUS]: You are ${is ? "in the Desktop app" : "in the Web version"}`,
      "aqua"
    );
  },
  description: "Check if you are in the desktop app or not"
};
const ProcessSpawnResultCaptions = {
  err_aboveLimit: "The maximum amount of processes is reached",
  err_disabled: "The Application is disabled",
  success: "The process spawned successfully"
};
const ProcessKillResultCaptions = {
  err_criticalProcess: "The process is required for ArcOS to run properly.",
  err_disposed: "The process is already killed.",
  err_elevation: "Elevation was required, but wasn't provided.",
  err_noExist: "The process doesn't exist.",
  success: "The process was killed successfully.",
  err_killCancel: "The process did not permit the kill. It might still have pending operations."
};
async function ArcTermElevate(data2, term) {
  async function _text() {
    const userdata = UserDataStore.get();
    const username = UserName.get();
    const div = document.createElement("div");
    div.className = "part box";
    term.target.append(div);
    term.std.writeLine("\n");
    term.std.writeHTML(`🔒 <b>${data2.what}</b>`, false, div);
    term.std.writeLine("\n", false, div);
    term.std.writeColor(`  [${data2.title}]`, "white", "white", false, div);
    term.std.writeColor(`  [${data2.description}]`, "gray", "white", false, div);
    term.std.writeLine("\n", false, div);
    term.std.writeLine(
      !userdata.sh.elevationDisabled ? !userdata.sh.securityNoPassword ? "➡️ To continue, type in your password, and hit [Enter]." : "➡️ To continue, hit [Enter]" : "⛔ You can't continue because elevation is disabled.",
      false,
      div
    );
    if (userdata.sh.elevationDisabled)
      return;
    term.std.writeLine("\n", false, div);
    if (userdata.sh.securityNoPassword) {
      const approve = await term.std.select(["✅ Approve this operation", "🛑 Deny"], "orange", div) == 0;
      return approve;
    } else {
      const password = await term.std.read(
        `[🔑] Enter the password for ${username}: `,
        "",
        64,
        true,
        "",
        div
      );
      const valid = await Authenticate(username, password, false);
      if (!valid)
        term.std.Error("Failed to elevate: The password is incorrect.");
      return valid;
    }
  }
  const current = PrimaryState.current.get().key;
  if (term.env.textOnlyElevate || current !== "desktop")
    return await _text();
  return await GetUserElevation(data2, ProcessStack);
}
const Kill = {
  keyword: "kill",
  async exec(cmd, argv, term) {
    const pid = tryJsonConvert(argv[0]);
    const process = ProcessStack.getProcess(pid);
    if (!pid)
      return term.std.Error("Missing process ID.");
    if (!process)
      return term.std.Error(
        ProcessStack.isPid(pid) ? ProcessKillResultCaptions.err_disposed : ProcessKillResultCaptions.err_noExist
      );
    const elevated = await ArcTermElevate(ElevationKillProcess(process), term);
    const status2 = await ProcessStack.kill(pid, elevated);
    if (status2 !== "success")
      return term.std.Error(ProcessKillResultCaptions[status2]);
    if (term && term.std)
      term.std.Info(`Success: [${pid}] has been terminated.`);
  },
  help(term) {
    term.std.writeColor("Example: [kill] 389176", "blue");
  },
  description: "Terminate a process",
  syntax: `<[pid]>`
};
const LogDump = {
  keyword: "logdump",
  async exec(cmd, argv, term) {
    const filename = `LogDump-${Math.floor(Math.random() * 1e9)}.txt`;
    term.std.writeColor(`Writing log to [${filename}]...
`, "purple");
    let str = "-- [START OF LOG] --\n";
    str += compileStringLog().join("\n");
    const b2 = new Blob([str], { type: "text/plain" });
    await writeFile(`${term.path}/${filename}`, b2);
    term.vars.set("ldout", filename);
    term.std.writeColor(`
Wrote [${str.length}] bytes.`, "purple");
  },
  description: "Dump the log to a file",
  hidden: true
};
const Logout = {
  keyword: "logout",
  exec(cmd, argv, term) {
    const currentState = PrimaryState.current.get().key;
    if (term.app && currentState == "desktop")
      return logout();
    localStorage.removeItem("arcos-remembered-token");
    UserName.set(void 0);
    term.dispose();
    setTimeout(() => {
      term.initialize();
    });
  },
  description: "Logout ArcOS"
};
const LogsCommand = {
  keyword: "logs",
  description: "Open LoggerApp at the provided log source",
  exec(cmd, argv, term, flags) {
    const source = argv.join(" ");
    spawnApp("LoggerApp", term.pid, ["all", source]);
    term.std.Info(`Opened [LoggerApp] at source [${source}]`);
  }
};
const Ls = {
  keyword: "ls",
  async exec(cmd, argv, term) {
    const path = term.path;
    const dir = await readDirectory(path);
    if (argv[0])
      return specific(argv[0], path, term);
    all2(dir, term);
  },
  description: "List the contents of the current directory",
  syntax: `<[path]>`
};
function all2(dir, term) {
  const subdirs = sortDirectories(dir.directories);
  const files = sortFiles(dir.files);
  for (const dir2 of subdirs) {
    term.std.writeColor(`[${dir2.name}  ]`, "blue");
  }
  for (const file of files) {
    term.std.writeColor(`[${file.filename}  ]`, "aqua");
  }
  if (subdirs.length == 0 && files.length == 0) {
    term.std.writeLine("This folder is empty.");
  }
}
async function specific(path, currentPath, term) {
  if (currentPath != "." && currentPath != "./") {
    path = currentPath + "/" + path;
  }
  const dir = await readDirectory(path);
  const subdirs = sortDirectories(dir.directories);
  const files = sortFiles(dir.files);
  if (dir.scopedPath == void 0) {
    term.std.Error(`The directory doesn't exist in this path.`);
    return;
  }
  for (const dir2 of subdirs) {
    term.std.writeColor(`[${dir2.name}]`, "blue");
  }
  for (const file of files) {
    term.std.writeColor(`[${file.filename}]`, "aqua");
  }
  if (subdirs.length == 0 && files.length == 0) {
    term.std.writeLine("This folder is empty.");
  }
}
const Mkdir = {
  keyword: "mkdir",
  async exec(cmd, argv, term) {
    const p2 = term.path;
    const dir = argv.join(" ");
    const name = `${p2}/${dir}`.replaceAll("//", "/");
    await createDirectory(name);
    term.std.writeLine(`Directory '${dir}' created.`);
  },
  help(term) {
    term.std.writeColor("Example: [mkdir] Private Photos", "blue");
  },
  description: "Create a directory",
  syntax: `"<[name]>"`
};
const AppSpawnResultCaptions = {
  success: "Application spawned successfully.",
  err_elevation: "Elevation is required, and it wasn't provided.",
  err_noExist: "The Application doesn't exist.",
  err_spawnCondition: "The spawn condition failed.",
  err_parentNoExist: "The parent process doesn't exist.",
  ...ProcessSpawnResultCaptions
};
const Spawn = {
  keyword: "spawn",
  async exec(cmd, argv, term) {
    const id = argv[0];
    if (!id)
      return term.std.Error("Missing process ID.");
    argv.shift();
    const args = tryJsonConvert(argv.join(" "));
    const library = appLibrary.get();
    if (!library.has(id))
      return term.std.Error(`${id}: app not found.`);
    const pid = await spawnApp(id, 0, Array.isArray(args) ? args : []);
    if (typeof pid !== "number") {
      term.std.Error(`${pid}: ${AppSpawnResultCaptions[pid]}`);
      return;
    }
    term.std.Info(`Spawned [${library.get(id).metadata.name}] on PID [${pid}]`);
    term.vars.set("openpid", `${pid}`);
  },
  help(term) {
    term.std.writeColor("[NOTE]: Capitalization matters.", "yellow");
    term.std.writeColor("Example: [spawn] ArcTerm", "blue");
  },
  description: "Open a window",
  syntax: `"<[appId]>" (...[arguments])`
};
const Pause = {
  keyword: "pause",
  async exec(cmd, argv, term, flags) {
    if (!flags.silent)
      term.std.writeLine("Press any key to continue . . .");
    await new Promise(
      (r2) => document.addEventListener("keydown", () => {
        if (term.app ? focusedPid.get() == term.pid : true)
          r2(null);
      })
    );
  },
  description: "Pause until a key is pressed",
  flags: [
    {
      keyword: "silent",
      description: "Don't display the prompt"
    }
  ]
};
const PokeCommand = {
  keyword: "poke",
  exec(cmd, argv, term, flags) {
    const { address, pid: pidStr, data: data2 } = flags;
    const pid = tryParseInt(pidStr);
    const proc = ProcessStack.getProcess(+pid);
    if (!proc || !proc.app)
      return term.std.Error(`Unknown or non-app process [${pid}].`);
    const mutator = proc.mutator.get();
    if (data2) {
      setJsonHierarchy(mutator, address, tryJsonConvert(data2));
      proc.mutator.set(mutator);
    } else {
      term.std.writeLine(JSON.stringify(getJsonHierarchy(mutator, address), null, 2));
    }
  },
  flags: [
    {
      keyword: "address",
      description: "The Appdata address to get or set",
      required: true,
      value: {
        type: "string",
        name: "hierarchy"
      }
    },
    {
      keyword: "pid",
      description: "The process PID to poke",
      required: true,
      value: {
        type: "number",
        name: "id"
      }
    },
    {
      keyword: "data",
      description: "Data to write to the address",
      value: {
        type: "other",
        name: "setter"
      }
    }
  ],
  description: "Get or set the app data of a process"
};
const defaultQuota = {
  used: 0,
  max: 0,
  free: 0,
  username: "ArcOS"
};
async function getFSQuota() {
  const username = UserName.get();
  const server = ConnectedServer.get();
  const token = UserToken.get();
  const url = getServerUrl(Endpoints.FsQuota);
  if (!server || !username || !url || !token)
    return defaultQuota;
  Log(`server/fs/quota`, `Getting FSQuota for ${username}`);
  const response = await axios$1.get(url, makeTokenOptions(token));
  if (response.status !== 200)
    return defaultQuota;
  return response.data.data;
}
const QuotaCommand = {
  keyword: "quota",
  async exec(cmd, argv, term) {
    const BAR_LENGTH = 50;
    const quota = await getFSQuota();
    const perc = 100 / quota.max * quota.used;
    const filled = perc / 2;
    const filler = "#".repeat(filled).padEnd(BAR_LENGTH, " ");
    const used = formatBytes(quota.used);
    const max = formatBytes(quota.max);
    const sub = `[${used.padEnd(BAR_LENGTH + 2 - max.length, " ") + max}]`;
    term.std.writeLine("\n");
    term.std.writeColor(`([${filler}])`, "blue");
    term.std.writeColor(sub, "gray");
  },
  description: "Display your ArcFS Quota"
};
const Read = {
  keyword: "read",
  async exec(cmd, argv, term, flags) {
    const key2 = flags.var;
    const mask = !!flags.mask;
    const prompt = flags.prompt;
    const max = tryParseInt(flags.max);
    if (!max)
      return term.std.Error("--max needs to be a positive number.");
    const value = await term.std.read(`${prompt} `, "", max || 100, mask);
    const setter = term.vars.set(key2, value);
    if (!setter)
      term.std.Error("Unable to set variable: it is read-only!");
  },
  description: "Read user input to a variable",
  flags: [
    {
      keyword: "var",
      value: {
        name: "variable",
        type: "string"
      },
      description: "The variable to write the user-specified value to",
      required: true
    },
    {
      keyword: "mask",
      description: "Masks the input value when entering"
    },
    {
      keyword: "prompt",
      value: {
        name: "text",
        type: "string"
      },
      description: "An optional prompt to display to the user"
    },
    {
      keyword: "max",
      value: {
        name: "length",
        type: "number"
      },
      description: "The maximal amount of characters the user can enter",
      required: true
    }
  ]
};
const Reload = {
  keyword: "reload",
  async exec(cmd, argv, term) {
    await term.reload();
    return false;
  },
  description: "Reload the ArcTerm configuration"
};
const RepInfo = {
  keyword: "repinfo",
  async exec(cmd, argv, term, flags) {
    const doJson = !!flags.json;
    const file = flags.file;
    const data2 = {
      ...createReport({
        body: "This is what a report sent to the Reports server may look like",
        title: "Example report",
        includeApi: true,
        includeUserData: true
      })
    };
    if (doJson) {
      const json = JSON.stringify(data2, null, 2);
      term.std.writeLine(json);
      if (file && typeof file == "string") {
        const filename = `${term.path}/${file}`;
        const blob = new Blob([json], { type: "application/json" });
        await writeFile(filename, blob);
        term.std.Info(`Written RepInfo to [${filename}]`);
      }
      return;
    }
    data2.userdata = "UserData {...}";
    data2.log = `LogStore {${LogStore.get().length}}`;
    const entries = Object.entries(data2);
    for (const [key2, value] of entries) {
      const keyStr = key2.padEnd(23, " ");
      if (value && typeof value === "object") {
        term.std.writeColor(`[${keyStr}]:`, "yellow");
        const subEntries = Object.entries(JSON.parse(JSON.stringify(value)));
        for (const [subKey, subValue] of subEntries) {
          const key22 = subKey.padEnd(18, " ");
          term.std.writeColor(` --> [${key22}]: ${subValue}`, "yellow");
        }
        continue;
      }
      term.std.writeColor(`[${key2}]: ${value}`, "yellow");
    }
  },
  description: "Display information in a bug report",
  hidden: true,
  flags: [
    {
      keyword: "json",
      description: "Display the report data as a JSON object"
    },
    {
      keyword: "file",
      value: {
        name: "filename",
        type: "string"
      },
      description: "An optional file name to save the report data to. Requires --json to be specified."
    }
  ]
};
const Reset = {
  keyword: "reset",
  async exec(cmd, argv, term) {
    term.std.writeLine(
      "Are you sure you want to reset ArcOS?\nThis will not affect any ArcAPI data.\n\n"
    );
    const confirmed = await term.std.select(["Yes, reset it", "No, abort"], "red") == 0;
    if (!confirmed)
      return term.std.Error("Reset aborted.");
    localStorage.clear();
    location.reload();
    await sleep(3e3);
  },
  description: "Reset local ArcOS instance"
};
const Restart = {
  keyword: "restart",
  exec(cmd, argv, term) {
    const state = PrimaryState.current.get().key;
    if (state == "desktop")
      return restart$3();
    term.std.writeColor("[RESTART]: Terminating NOW.", "green");
    setTimeout(() => {
      location.reload();
    }, 1e3);
  },
  description: "Restart ArcOS"
};
const Rf = {
  keyword: "rf",
  async exec(cmd, argv, term) {
    const path = term.path;
    const fn = argv.join(" ").trim();
    const dir = await readDirectory(path);
    if (!dir)
      return term.std.Error("Could not read the current directory!");
    for (const partial of dir.files) {
      if (partial.filename == fn) {
        const file = await readFile(partial.scopedPath);
        if (!file)
          return term.std.Error("Could not read the file.");
        if (!partial.mime.includes("text/"))
          return term.std.Error("Not attempting to read non-text file.");
        const d3 = await blobToText(file.data);
        term.std.writeLine(d3);
        return;
      }
    }
    term.std.Error(`The file doesn't exist on ArcFS.`);
  },
  help(term) {
    term.std.writeColor("Example: [rf] mwomp.txt", "blue");
  },
  description: "Read a file from ArcFS",
  syntax: "<[filename]>"
};
const DEFSIZE = 20;
const Ri = {
  keyword: "ri",
  async exec(cmd, argv, term, flags) {
    const file = flags.file;
    const url = flags.url;
    const size = tryParseInt(flags.size);
    term.std.writeLine("\n");
    if (file)
      return await displayFile(term, file, size || DEFSIZE);
    if (url)
      return displayUrl(term, url, size || DEFSIZE);
    term.std.Error("Missing parameters.");
  },
  help(term) {
    term.std.writeColor(`Example: [ri] --url="https://tinyurl.com/arcoslogo"`, "blue");
  },
  description: "Display image from ArcFS or URL",
  flags: [
    {
      keyword: "file",
      value: {
        name: "path",
        type: "string"
      },
      description: "The ArcFS path to read the image from. Specify if you want to read from the filesystem."
    },
    {
      keyword: "url",
      value: {
        name: "url",
        type: "string"
      },
      description: "The URL to read the image from. Specify if you want to read from a web resource."
    },
    {
      keyword: "height",
      value: {
        name: "pixels",
        type: "number"
      },
      description: "The height in pixels of the image to be displayed. Defaults to 20px."
    }
  ]
};
async function displayFile(term, fn, height) {
  const path = term.path;
  const dir = await readDirectory(path);
  for (const partial of dir.files) {
    if (partial.filename == fn) {
      const file = await readFile(partial.scopedPath);
      if (!file)
        return term.std.Error("Could not read the file.");
      const blob = file.data;
      const url = URL.createObjectURL(blob);
      term.std.writeImage(url, height);
      return;
    }
  }
}
function displayUrl(term, url, height) {
  term.std.writeImage(url, height || DEFSIZE);
}
async function deleteItem(path, dispatch = true) {
  Log("server/fs/delete", `Deleting ${path}`);
  const base64 = toBase64(path);
  if (path == base64)
    return false;
  const url = getServerUrl(Endpoints.FsRm, { path: base64 });
  const token = UserToken.get();
  if (!url || !token)
    return false;
  const response = await axios$1.get(url, makeTokenOptions(token));
  if (dispatch)
    GlobalDispatch.dispatch("fs-flush");
  return response.status === 200;
}
const Rm = {
  keyword: "rm",
  async exec(cmd, argv, term) {
    const p2 = term.path;
    const dir = argv.join(" ");
    const name = `${p2}/${dir}`.replaceAll("//", "/");
    if (!dir.trim().length)
      return term.std.Error("Missing filename");
    try {
      await deleteItem(name);
    } catch {
      term.std.Error(`Unable to delete "${dir}"`);
    }
  },
  help(term) {
    term.std.writeColor("[NOTE]: Capitalization matters.", "yellow");
    term.std.writeColor("Example: [rm] mwomp.txt", "blue");
  },
  description: "Delete a file or folder",
  syntax: `"<[name]>"`
};
const Open = {
  keyword: "open",
  async exec(cmd, argv, term) {
    const fn = argv.join(" ").trim();
    const partial = await getPartialFile(`${term.path}/${fn}`);
    if (!partial)
      return term.std.Error(`Can't find file [${fn}]!`);
    await OpenFile(partial);
    term.std.Info(`Opened [${fn}] (${partial.size} bytes)`);
  },
  help(term) {
    term.std.writeColor("[NOTE]: Capitalization matters.", "yellow");
    term.std.writeColor("Example: [open] arcterm.conf", "blue");
  },
  description: "Run a file from your ArcFS account.",
  syntax: `"<[filename]>"`
};
const Servers = {
  keyword: "servers",
  exec(cmd, argv, term) {
    const servers = getAllServers();
    term.std.writeLine("\n# | Server");
    term.std.writeSeparator(20);
    for (const server of servers) {
      const ac = getAuthcode(server);
      term.std.writeColor(`${ac ? "[#]" : " "} | ${server}`, "orange");
    }
    term.std.writeLine("\n");
    term.std.Info("Servers marked with a '[#]' indicates a protected server.");
  },
  description: "List saved servers"
};
const ServiceChangeResultCaptions = {
  err_alreadyRunning: "The service is already running.",
  err_noExist: "The service could not be found.",
  err_notRunning: "The service isn't running",
  err_spawnFailed: "The process of the service could not be started.",
  err_startCondition: "The Start Condition of the service failed.",
  err_noManager: "Could not reach Service Manager",
  err_elevation: "Elevation is necessary, but wasn't provided.",
  success: "Service started successfully."
};
const ServiceCommand = {
  keyword: "service",
  description: "Manage services from ArcTerm",
  async exec(_2, argv, term) {
    switch (argv[0]) {
      case "start":
        await start(argv, term);
        break;
      case "stop":
        await stop$1(argv, term);
        break;
      case "restart":
        await restart$2(argv, term);
        break;
      case "status":
        await status(argv, term);
        break;
      default:
        term.std.Error("Missing or invalid subcommand.");
    }
  },
  help(term) {
    term.std.writeColor("[play] - Plays the specified sound.", "aqua");
    term.std.writeColor("[stop] - Stops the current playing sound.", "aqua");
    term.std.writeColor("[list] - Lists playable sounds.\n\n", "aqua");
    term.std.writeColor("Example: [soundbus] play ...", "blue");
  },
  syntax: "SOUNDBUS <[subcommand]> <...[arguments]>"
};
async function stop$1(argv, term) {
  const service = argv[1];
  const elevated = await ArcTermElevate(ElevationChangeServiceState(getService(service)), term);
  if (!elevated)
    return;
  const status2 = await stopService(service, true);
  if (status2 != "success")
    term.std.Error(`Couldn't stop service [${service}]: ${ServiceChangeResultCaptions[status2]}`);
  else
    term.std.writeColor(`Stopped service [${service}].`, "blue");
}
async function start(argv, term) {
  const service = argv[1];
  const elevated = await ArcTermElevate(ElevationChangeServiceState(getService(service)), term);
  if (!elevated)
    return;
  const result = await startService(service, true);
  const resultCaption = ServiceChangeResultCaptions[result];
  if (result != "success") {
    term.std.Error(`Couldn't start service [${service}]: ${resultCaption}`);
    term.std.writeLine("\n");
    term.std.writeColor(`[Code: ${result}]`, "gray");
    return;
  }
  term.std.writeColor(`Started service [${service}].`, "blue");
}
async function restart$2(argv, term) {
  const service = argv[1];
  const elevated = await ArcTermElevate(ElevationChangeServiceState(getService(service)), term);
  if (!elevated)
    return;
  const status2 = await restartService(service, true);
  if (status2 !== "success")
    term.std.Error(`Couldn't restart service [${service}]: ${ServiceChangeResultCaptions[status2]}`);
  else
    term.std.writeColor(`Restarted service [${service}].`, "blue");
}
function status(argv, term) {
  term.std.writeLine("\n");
  const service = argv[1];
  const data2 = getService(service);
  if (!data2)
    return term.std.Error(`No such service [${service}]!`);
  const pid = data2.pid || 0;
  const statusText = pid ? "✔ Running" : "✖ Stopped";
  const pidString = pid ? `on PID ${pid} - handler ${ProcessStack.id}` : `- no PID`;
  const state = pid ? "started" : "stopped";
  const loadedAt = dayjs(data2.loadedAt).format("MMM D, HH:mm:ss");
  const changedAt = dayjs(data2.changedAt).format("MMM D, HH:mm:ss");
  term.std.writeColor(`[${data2.name}] - ${data2.description}`, "blue");
  term.std.writeLine("\n");
  term.std.writeColor(`Status:          [${statusText}] ${pidString}`, pid ? "green" : "red");
  term.std.writeColor(`State:           [${state}] - Changed at ${changedAt}`, "purple");
  term.std.writeColor(
    `Identifier:      [${data2.id || service}] ${!data2.id ? "(derived)" : ""}`,
    "purple"
  );
  term.std.writeColor(`Loaded At:       [${loadedAt}]`, "purple");
}
const Set$1 = {
  keyword: "set",
  async exec(cmd, argv, term) {
    const key2 = argv[0];
    const Regx = argv.join(" ").match(/"(.*?)"/);
    if (!Regx || Regx.length < 2) {
      const deleted = await term.vars.delete(key2);
      if (!deleted)
        term.std.Error(
          "Can't delete variable: deletion isn't allowed or the variable is read-only."
        );
      return;
    }
    const value = Regx[1];
    const isSet = await term.vars.set(key2, value);
    if (!isSet)
      term.std.Error("Can't update variable: the variable is readonly.");
  },
  help(term) {
    term.std.writeColor('Example: [set] color "green"', "blue");
  },
  description: "Set a variable",
  syntax: `<[key]> "<[value]>"`
};
const Shutdown = {
  keyword: "shutdown",
  async exec(cmd, argv, term) {
    const state = PrimaryState.current.get().key;
    if (state == "desktop")
      return shutdown();
    term.std.writeColor("[SHUTDOWN]: Terminating NOW.", "green");
    await sleep(1e3);
    PrimaryState.navigate("turnedoff");
  },
  description: "Log off and shut down ArcOS"
};
const SleepCommand = {
  keyword: "sleep",
  async exec(cmd, argv, term) {
    try {
      const duration = JSON.parse(argv[0]);
      if (typeof duration !== "number")
        return term.std.Error("Invalid duration.");
      await sleep(duration);
    } catch {
      term.std.Error("Failed to parse duration.");
    }
  },
  description: "wait for a given amount of milliseconds."
};
const SoundBusCommand = {
  keyword: "soundbus",
  description: "SoundBus CLI",
  exec(cmd, argv, term) {
    switch (argv[0]) {
      case "play":
        play(cmd, argv, term);
        break;
      case "stop":
        stop(cmd, argv, term);
        break;
      case "list":
        list(term);
        break;
      default:
        term.std.Error("Missing or invalid subcommand.");
    }
  },
  help(term) {
    term.std.writeColor("[play] - Plays the specified sound.", "aqua");
    term.std.writeColor("[stop] - Stops the current playing sound.", "aqua");
    term.std.writeColor("[list] - Lists playable sounds.\n\n", "aqua");
    term.std.writeColor("Example: [soundbus] play ...", "blue");
  },
  syntax: "SOUNDBUS <[subcommand]> <...[arguments]>"
};
function play(cmd, argv, term) {
  const sound = argv[1];
  const valid = ArcSoundBus.playSound(sound);
  if (!valid)
    term.std.Error(`Can't play sound [${sound}]: the sound could not be found.`);
  else
    term.std.writeColor(`Playing sound [${sound}]`, "blue");
}
function stop(cmd, argv, term) {
  const sound = argv[1];
  const valid = ArcSoundBus.stopSound(sound);
  if (!valid)
    term.std.Error(`Can't stop sound [${sound}]: the requested sound is not playing.`);
  else
    term.std.writeColor(`Stopping sound [${sound}]`, "blue");
}
function list(term) {
  const sounds = ArcSoundBus.getStore();
  for (const sound of sounds) {
    const id = sound[0].padEnd(32, " ");
    const source = sound[1];
    term.std.writeColor(`[${id}]${source}`, "blue");
  }
}
const StateCommand = {
  keyword: "state",
  exec(cmd, argv, term) {
    const state = argv.join(" ");
    if (!state) {
      const s2 = PrimaryState.current.get();
      return term.std.writeColor(`Current state: [${s2.name}] (ArcOS.state.[${s2.key}])`, "purple");
    }
    PrimaryState.navigate(state);
  },
  syntax: "<[stateId]>",
  description: "for debugging -- forcefully change the state",
  hidden: true
};
const BANNED = ["acc.enabled", "acc.admin", "devmode", "valid", "statusCode"];
const SUD = {
  keyword: "sud",
  async exec(cmd, argv, term) {
    if (!argv.length || argv.length < 2)
      return term.std.Error("Missing arguments");
    const hierarchy = argv[0];
    if (!hierarchy)
      return term.std.Error("Missing hierarchy");
    if (BANNED.join("|").includes(hierarchy))
      return term.std.Error(`Not permitted to change data of [${hierarchy}]`);
    const elevated = await ArcTermElevate(ElevationChangeUserData(), term);
    if (!elevated)
      return term.std.Error(`Elevation is required to perform this action.`);
    const udata = UserDataStore.get();
    const currentValue = getJsonHierarchy(udata, hierarchy);
    if (!currentValue && typeof currentValue === "undefined")
      return term.std.Error(`Can't find [UserData.${hierarchy}]!`);
    argv.shift();
    let newValue = argv.join(" ").trim();
    try {
      newValue = JSON.parse(newValue);
    } catch {
    }
    setJsonHierarchy(udata, hierarchy, newValue);
    UserDataStore.set(udata);
    if (term.std.verbose)
      term.std.writeColor(
        `Wrote [${newValue.toString().length} bytes] to [UserData.${hierarchy}]`,
        "blue"
      );
  },
  description: "Set UserData parameters"
};
const TasksCommand = {
  keyword: "tasks",
  exec(cmd, argv, term) {
    const procs = ProcessStack.processes.get();
    header(term);
    for (const [pid, proc] of procs) {
      if (proc._disposed)
        continue;
      const process = proc;
      term.std.writeColor(
        compile(`[${pid}]`, process.name, process.app ? process.app.metadata.name : ""),
        "blue"
      );
    }
  },
  description: "Get a list of running processes"
};
function header(term) {
  const head = compile("PID", "Process", "App Name?");
  term.std.writeLine(head);
  term.std.writeSeparator(head.length + 5);
}
function compile(first, second, third) {
  first = first.padEnd(first.includes("[") ? 17 : 15, " ");
  second = second.padEnd(25, " ");
  return first + second + third;
}
const UDD = {
  keyword: "udd",
  async exec(cmd, argv, term) {
    const filename = `./UserDump-${Math.floor(Math.random() * 1e9)}.txt`;
    term.std.writeColor(`Writing UserData to [${filename}]...
`, "purple");
    const b2 = new Blob([JSON.stringify(UserDataStore.get(), null, 2)], {
      type: "text/plain"
    });
    await writeFile(filename, b2);
    term.vars.set("uddout", filename);
  },
  description: "Dump the userdata to a file",
  hidden: true
};
const UserAdd = {
  keyword: "useradd",
  async exec(cmd, argv, term) {
    const username = await term.std.read("Username: ", "", 25);
    const password = await term.std.read("Password: ", "", 128, true);
    const confirm = await term.std.read("Confirm Password: ", "", 128, true);
    if (!username)
      return term.std.Error(`Invalid username!`);
    if (password !== confirm)
      return term.std.Error(`Can't create ${username}: passwords don't match`);
    term.std.writeLine(`
Continue creating ${username}?
`);
    const confirmCreate = await term.std.select(["Confirm creation", "Stop!"]) == 0;
    if (!confirmCreate)
      return term.std.Warning("Aborted.");
    const userdata = await createUser(username, password);
    if (!userdata)
      return term.std.Error(`Creating user ${username} failed.`);
    term.std.writeColor(`User [${username}] created successfully!`, "aqua");
  },
  description: "Create a new user"
};
const Users$1 = {
  keyword: "users",
  async exec(cmd, argv, term, flags) {
    const username = tryJsonConvert(flags.search);
    UserCache.clear();
    if (!username)
      return allUsers(term);
    return searchFor(username, await getUsers(), term);
  },
  description: "Display ArcAPI users",
  flags: [
    {
      keyword: "search",
      value: {
        name: "user",
        type: "string"
      },
      description: "A username to search for."
    }
  ]
};
async function allUsers(term) {
  const users = await getUsers();
  const entries = Object.entries(users);
  const names = Object.keys(users);
  for (const [name, user] of entries) {
    const role = user.acc.admin ? "Administrator" : "Regular user";
    const nameStr = name.padEnd(getMaxLength(names), " ");
    term.std.writeColor(`[${nameStr}]: ${role}`, "blue");
  }
}
function searchFor(username, users, term) {
  const userObject = Object.entries(users).map((a2) => ({
    ...a2[1],
    name: a2[0]
  }));
  const options2 = {
    includeScore: true,
    keys: ["name"],
    threshold: 0.3
  };
  const fuse = new Fuse(userObject, options2);
  const result = fuse.search(username);
  const names = Object.keys(users);
  for (const user of result) {
    const role = user.item.acc.admin ? "Administrator" : "Regular user";
    const name = user.item.name.padEnd(getMaxLength(names), " ");
    term.std.writeColor(`[${name}]: ${role}`, "blue");
  }
  return result;
}
function getMaxLength(users) {
  let length = 0;
  for (const user of users) {
    if (user.length > length)
      length = user.length;
  }
  return length + 2;
}
const Vars = {
  keyword: "vars",
  async exec(cmd, argv, term) {
    const variables = Object.entries(await term.vars.getAll());
    for (const [id, variable] of variables) {
      if (!variable.value)
        continue;
      const str = variable.value;
      const key2 = id.padEnd(20, " ");
      const prefix = variable.readOnly ? "#" : " ";
      term.std.writeColor(`${prefix} [${key2}]: `, "aqua", "white", true);
      term.std.write(`${str}`);
      term.std.writeLine("");
    }
  },
  description: "List the variables"
};
const Ver = {
  keyword: "ver",
  exec(cmd, argv, term) {
    term.std.writeColor(`ArcOS & ArcTerm [v${ArcOSVersion}]`, "blue");
  },
  description: "Display the version number"
};
const Verbose = {
  keyword: "verbose",
  exec(cmd, argv, term, flags) {
    const off = flags.off;
    const on = flags.on;
    if (off && on)
      return term.std.Error("Can't accept both --on and --off.");
    if (!off && !on)
      return term.std.Error("Missing --on or --off.");
    if (on)
      term.std.verbose = true;
    if (off)
      term.std.verbose = false;
  },
  description: "Set verbose mode on or off.",
  flags: [
    { keyword: "on", description: "Specify to turn on verbosity." },
    { keyword: "off", description: "Specify to turn off verbosity." }
  ]
};
const arcCommands = [
  ArcFetch,
  Cd,
  Clear$1,
  Dir,
  Dispatch,
  Echo,
  Vars,
  Exit,
  Help$2,
  History,
  Logout,
  Ls,
  Mkdir,
  Rm,
  Reload,
  Restart,
  Shutdown,
  InDesktop,
  Ver,
  Reset,
  Rf,
  Ri,
  Users$1,
  Read,
  Set$1,
  SoundBusCommand,
  Config,
  Exec,
  Verbose,
  Servers,
  If,
  Goto,
  End,
  Goose,
  UserAdd,
  SUD,
  GUD,
  SleepCommand,
  BgCommand,
  ServiceCommand,
  TasksCommand,
  Pause,
  Base64Command,
  QuotaCommand
];
const gooseBumpsCommands = [
  StateCommand,
  Colors,
  UDD,
  LogDump,
  BugRep,
  RepInfo,
  Err
];
const desktopSpecific = [
  AppList,
  ATConf,
  Kill,
  Spawn,
  LogsCommand,
  Open,
  ExploreCommand,
  PokeCommand,
  FindCommand
];
const main$u = "";
function create_fragment$4j(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "terminal-renderer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[3](div);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[3](null);
    }
  };
}
function instance$3V($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { pid } = $$props;
  let target;
  onMount(() => {
    new ArcTerm(target, [...arcCommands, ...desktopSpecific], app, pid, arcTermModeIntro);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      target = $$value;
      $$invalidate(0, target);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
    if ("pid" in $$props2)
      $$invalidate(2, pid = $$props2.pid);
  };
  return [target, app, pid, div_binding];
}
let App$o = class App7 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3V, create_fragment$4j, safe_not_equal, { app: 1, pid: 2 });
  }
};
let Runtime$h = class Runtime6 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
  }
};
const ArcTermApp = {
  metadata: {
    name: "ArcTerm",
    description: "The Terminal of ArcOS",
    author: "The ArcOS Team",
    version: ArcOSVersion,
    icon: ArcTermIcon,
    appGroup: "systemTools"
  },
  runtime: Runtime$h,
  content: App$o,
  id: "ArcTerm",
  size: { w: 640, h: 480 },
  minSize: { w: 350, h: 250 },
  maxSize: { w: NaN, h: NaN },
  pos: { x: 60, y: 60 },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: true
  },
  controls: {
    minimize: true,
    maximize: true,
    close: true
  },
  glass: true
};
let CLICKLOCKED = false;
async function createContextMenu(data2) {
  Log(
    "Desktop/ts/context",
    `Spawning Context Menu with ${data2.items.length} items at ${data2.x}, ${data2.y}`
  );
  CLICKLOCKED = true;
  contextData.set(data2);
  await sleep(10);
  CLICKLOCKED = false;
}
function closeContextMenu() {
  contextData.set(null);
}
function assignContextMenuHooks() {
  Log("Desktop/ts/context", "Assigning context menu hooks");
  document.addEventListener("click", (e2) => {
    if (CLICKLOCKED)
      return;
    const el = document.querySelector(".desktop > .context-menu");
    if (!el || e2.button != 0 || e2.composedPath().includes(el))
      return;
    contextData.set(null);
  });
  document.addEventListener("contextmenu", handleContext);
}
async function handleContext(e2) {
  const window2 = getWindowByEventTarget(e2.composedPath());
  const scope = getContexMenuScope(e2);
  if (!window2 || !scope)
    return closeContextMenu();
  const id = window2.id;
  const appData = getAppById(id);
  if (!appData)
    return closeContextMenu();
  appData.pid = tryParseInt(window2.dataset.pid);
  const contextmenu = scope.dataset.contextmenu;
  await sleep();
  const items = getContextEntry(id, contextmenu);
  createContextMenu({
    x: e2.clientX,
    y: e2.clientY,
    items,
    scope: contextmenu,
    scopeMap: scope.dataset,
    app: appData
  });
}
function composePosition(x2, y2, mW, mH) {
  const dW = window.innerWidth;
  const dH = window.innerHeight;
  let newX = x2;
  let newY = y2;
  if (newX + mW > dW)
    newX = dW - mW - 10;
  if (newY + mH > dH)
    newY = dH - mH - 10;
  if (newX < 0)
    x2 = 10;
  if (newY < 0)
    y2 = 10;
  return [newX, newY];
}
function getContextEntry(id, scope) {
  Log("Desktop/ts/context", `Getting Context Entries of ${id} in scope ${scope}`);
  const app = getAppById(id);
  if (!app || !app.contextMenu)
    return [];
  const menu = Object.entries(app.contextMenu);
  for (const [key2, items] of menu) {
    if (scope.includes(key2))
      return items;
  }
  return [];
}
function getContexMenuScope(e2) {
  const path = e2.composedPath();
  for (const element2 of path) {
    const tag = element2.tagName;
    if (!tag)
      continue;
    const contextmenu = element2.dataset.contextmenu;
    if (validContexMenuTags.includes(tag.toLowerCase()) && contextmenu) {
      return element2;
    }
  }
  return null;
}
function getWindowByEventTarget(target) {
  Log(
    "Desktop/ts/context",
    `Getting window by running through EventTarget (size ${target.length})`
  );
  for (const element2 of target) {
    const tagName = element2.tagName;
    if (!tagName)
      continue;
    if (tagName.toLowerCase() == "window")
      return element2;
  }
  return null;
}
function create_else_block$v(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "sep");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block$1H(ctx) {
  let button_1;
  let t_value = (
    /*menu*/
    ctx[0].caption + ""
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button_1 = element("button");
      t2 = text(t_value);
      attr(button_1, "class", "menu-item");
    },
    m(target, anchor) {
      insert(target, button_1, anchor);
      append(button_1, t2);
      ctx[4](button_1);
      if (!mounted) {
        dispose = listen(
          button_1,
          "click",
          /*action*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*menu*/
      1 && t_value !== (t_value = /*menu*/
      ctx2[0].caption + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(button_1);
      }
      ctx[4](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4i(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (!/*menu*/
    ctx2[0].sep)
      return create_if_block$1H;
    return create_else_block$v;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function instance$3U($$self, $$props, $$invalidate) {
  let { menu } = $$props;
  let { app } = $$props;
  let button;
  async function action() {
    if (!menu.subItems && menu.action)
      return await menu.action(app, null, null);
    const rect = button.getBoundingClientRect();
    createContextMenu({
      items: menu.subItems,
      x: rect.x,
      y: rect.y + rect.height + 5
    });
  }
  function button_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      button = $$value;
      $$invalidate(1, button);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("menu" in $$props2)
      $$invalidate(0, menu = $$props2.menu);
    if ("app" in $$props2)
      $$invalidate(3, app = $$props2.app);
  };
  return [menu, button, action, app, button_1_binding];
}
class MenuItem extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3U, create_fragment$4i, safe_not_equal, { menu: 0, app: 3 });
  }
}
function get_each_context$I(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2];
  return child_ctx;
}
function create_if_block$1G(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*$app*/
    ctx[1].altMenu
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$I(get_each_context$I(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "alt-menu");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$app*/
      2) {
        each_value = ensure_array_like(
          /*$app*/
          ctx2[1].altMenu
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$I(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$I(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$I(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      menu: (
        /*menu*/
        ctx[2]
      ),
      app: (
        /*$app*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & /*$app*/
      2)
        menuitem_changes.menu = /*menu*/
        ctx2[2];
      if (dirty & /*$app*/
      2)
        menuitem_changes.app = /*$app*/
        ctx2[1];
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_fragment$4h(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$app*/
    ctx[1].altMenu && create_if_block$1G(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$app*/
        ctx2[1].altMenu
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$app*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1G(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$3T($$self, $$props, $$invalidate) {
  let $app, $$unsubscribe_app = noop$1, $$subscribe_app = () => ($$unsubscribe_app(), $$unsubscribe_app = subscribe(app, ($$value) => $$invalidate(1, $app = $$value)), app);
  $$self.$$.on_destroy.push(() => $$unsubscribe_app());
  let { app } = $$props;
  $$subscribe_app();
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$subscribe_app($$invalidate(0, app = $$props2.app));
  };
  return [app, $app];
}
class AltMenu extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3T, create_fragment$4h, safe_not_equal, { app: 0 });
  }
}
function create_else_block$u(ctx) {
  let default_1;
  let current;
  default_1 = new Default({
    props: { pid: (
      /*pid*/
      ctx[0]
    ), app: (
      /*app*/
      ctx[1]
    ) }
  });
  return {
    c() {
      create_component(default_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(default_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const default_1_changes = {};
      if (dirty & /*pid*/
      1)
        default_1_changes.pid = /*pid*/
        ctx2[0];
      if (dirty & /*app*/
      2)
        default_1_changes.app = /*app*/
        ctx2[1];
      default_1.$set(default_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(default_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(default_1, detaching);
    }
  };
}
function create_if_block$1F(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = TitlebarButtons[
    /*$UserDataStore*/
    ctx[2].sh.window.buttons
  ].content;
  function switch_props(ctx2, dirty) {
    return {
      props: { app: (
        /*app*/
        ctx2[1]
      ), pid: (
        /*pid*/
        ctx2[0]
      ) }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore*/
      4 && switch_value !== (switch_value = TitlebarButtons[
        /*$UserDataStore*/
        ctx2[2].sh.window.buttons
      ].content)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*app*/
        2)
          switch_instance_changes.app = /*app*/
          ctx2[1];
        if (dirty & /*pid*/
        1)
          switch_instance_changes.pid = /*pid*/
          ctx2[0];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$4g(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block$1F, create_else_block$u];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$UserDataStore*/
      ctx2[2] && /*$UserDataStore*/
      ctx2[2].sh.window.buttons && TitlebarButtons[
        /*$UserDataStore*/
        ctx2[2].sh.window.buttons
      ]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", div_class_value = "controls buttons-" + /*$UserDataStore*/
      ctx[2].sh.window.buttons);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*$UserDataStore*/
      4 && div_class_value !== (div_class_value = "controls buttons-" + /*$UserDataStore*/
      ctx2[2].sh.window.buttons)) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$3S($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(2, $UserDataStore = $$value));
  let { pid } = $$props;
  let { app } = $$props;
  $$self.$$set = ($$props2) => {
    if ("pid" in $$props2)
      $$invalidate(0, pid = $$props2.pid);
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
  };
  return [pid, app, $UserDataStore];
}
let Controls$1 = class Controls extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3S, create_fragment$4g, safe_not_equal, { pid: 0, app: 1 });
  }
};
function create_if_block$1E(ctx) {
  let div2;
  let div0;
  let span;
  let t0;
  let t1;
  let altmenu;
  let t2;
  let t3;
  let div1;
  let t4;
  let controls;
  let current;
  let if_block0 = (
    /*showIcon*/
    ctx[2] && create_if_block_3$7(ctx)
  );
  let if_block1 = (
    /*showTitle*/
    ctx[3] && create_if_block_1$z(ctx)
  );
  altmenu = new AltMenu({ props: { app: (
    /*app*/
    ctx[0]
  ) } });
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  controls = new Controls$1({
    props: { app: (
      /*app*/
      ctx[0]
    ), pid: (
      /*pid*/
      ctx[1]
    ) }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      span = element("span");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      create_component(altmenu.$$.fragment);
      t2 = space();
      if (default_slot)
        default_slot.c();
      t3 = space();
      div1 = element("div");
      t4 = space();
      create_component(controls.$$.fragment);
      attr(span, "class", "title-wrapper");
      attr(div0, "class", "title");
      attr(div1, "class", "blank");
      attr(div2, "class", "titlebar");
      attr(div2, "data-contextmenu", "titlebar");
      toggle_class(
        div2,
        "left",
        /*$UserDataStore*/
        ctx[7].sh.window.lefttb
      );
      toggle_class(div2, "center", !/*noCenter*/
      ctx[5] && /*$UserDataStore*/
      (ctx[7].sh.window.centertb || /*center*/
      ctx[4]));
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, span);
      if (if_block0)
        if_block0.m(span, null);
      append(span, t0);
      if (if_block1)
        if_block1.m(span, null);
      append(div0, t1);
      mount_component(altmenu, div0, null);
      append(div0, t2);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append(div2, t3);
      append(div2, div1);
      append(div2, t4);
      mount_component(controls, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*showIcon*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$7(ctx2);
          if_block0.c();
          if_block0.m(span, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*showTitle*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$z(ctx2);
          if_block1.c();
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      const altmenu_changes = {};
      if (dirty & /*app*/
      1)
        altmenu_changes.app = /*app*/
        ctx2[0];
      altmenu.$set(altmenu_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      const controls_changes = {};
      if (dirty & /*app*/
      1)
        controls_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*pid*/
      2)
        controls_changes.pid = /*pid*/
        ctx2[1];
      controls.$set(controls_changes);
      if (!current || dirty & /*$UserDataStore*/
      128) {
        toggle_class(
          div2,
          "left",
          /*$UserDataStore*/
          ctx2[7].sh.window.lefttb
        );
      }
      if (!current || dirty & /*noCenter, $UserDataStore, center*/
      176) {
        toggle_class(div2, "center", !/*noCenter*/
        ctx2[5] && /*$UserDataStore*/
        (ctx2[7].sh.window.centertb || /*center*/
        ctx2[4]));
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(altmenu.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(controls.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(altmenu.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(controls.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_component(altmenu);
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(controls);
    }
  };
}
function create_if_block_3$7(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*$app*/
      ctx[6].metadata.icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*$app*/
      ctx[6].id);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$app*/
      64 && !src_url_equal(img.src, img_src_value = /*$app*/
      ctx2[6].metadata.icon)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*$app*/
      64 && img_alt_value !== (img_alt_value = /*$app*/
      ctx2[6].id)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_if_block_1$z(ctx) {
  let span;
  let t0_value = (
    /*$app*/
    ctx[6].metadata.name + ""
  );
  let t0;
  let t1;
  let if_block = ARCOS_MODE == "development" && create_if_block_2$e(ctx);
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      attr(span, "class", "title-text");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      if (if_block)
        if_block.m(span, null);
    },
    p(ctx2, dirty) {
      if (dirty & /*$app*/
      64 && t0_value !== (t0_value = /*$app*/
      ctx2[6].metadata.name + ""))
        set_data(t0, t0_value);
      if (ARCOS_MODE == "development")
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_2$e(ctx) {
  let t0_value = (
    /*$app*/
    ctx[6].metadata.version + ""
  );
  let t0;
  let t1;
  let t2;
  let t3;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" [");
      t2 = text(
        /*pid*/
        ctx[1]
      );
      t3 = text("]");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$app*/
      64 && t0_value !== (t0_value = /*$app*/
      ctx2[6].metadata.version + ""))
        set_data(t0, t0_value);
      if (dirty & /*pid*/
      2)
        set_data(
          t2,
          /*pid*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
      }
    }
  };
}
function create_fragment$4f(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*$app*/
  ctx[6].metadata.core && create_if_block$1E(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*$app*/
      ctx2[6].metadata.core) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$app*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1E(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$3R($$self, $$props, $$invalidate) {
  let $app, $$unsubscribe_app = noop$1, $$subscribe_app = () => ($$unsubscribe_app(), $$unsubscribe_app = subscribe(app, ($$value) => $$invalidate(6, $app = $$value)), app);
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(7, $UserDataStore = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_app());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { app } = $$props;
  $$subscribe_app();
  let { pid } = $$props;
  let { showIcon = true } = $$props;
  let { showTitle = true } = $$props;
  let { center = false } = $$props;
  let { noCenter = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$subscribe_app($$invalidate(0, app = $$props2.app));
    if ("pid" in $$props2)
      $$invalidate(1, pid = $$props2.pid);
    if ("showIcon" in $$props2)
      $$invalidate(2, showIcon = $$props2.showIcon);
    if ("showTitle" in $$props2)
      $$invalidate(3, showTitle = $$props2.showTitle);
    if ("center" in $$props2)
      $$invalidate(4, center = $$props2.center);
    if ("noCenter" in $$props2)
      $$invalidate(5, noCenter = $$props2.noCenter);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*app*/
    1)
      ;
  };
  return [
    app,
    pid,
    showIcon,
    showTitle,
    center,
    noCenter,
    $app,
    $UserDataStore,
    $$scope,
    slots
  ];
}
class Titlebar extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3R, create_fragment$4f, safe_not_equal, {
      app: 0,
      pid: 1,
      showIcon: 2,
      showTitle: 3,
      center: 4,
      noCenter: 5
    });
  }
}
function create_fragment$4e(ctx) {
  let p0;
  let t1;
  let h4;
  let t3;
  let ul;
  let li0;
  let t5;
  let li1;
  let t9;
  let li2;
  let t11;
  let li3;
  let t13;
  let li4;
  let t15;
  let p1;
  return {
    c() {
      p0 = element("p");
      p0.textContent = "In order to make bug reports useful for the ArcOS developers, we collect some required data that\n  we use to resolve the problem.";
      t1 = space();
      h4 = element("h4");
      h4.textContent = "This data includes:";
      t3 = space();
      ul = element("ul");
      li0 = element("li");
      li0.textContent = "The ArcOS Log (without API and AuthCode);";
      t5 = space();
      li1 = element("li");
      li1.textContent = `The version of ArcOS and its mode (${ARCOS_MODE.toUpperCase()} in this case);`;
      t9 = space();
      li2 = element("li");
      li2.textContent = "Your User Agent string;";
      t11 = space();
      li3 = element("li");
      li3.textContent = "The frontend URL;";
      t13 = space();
      li4 = element("li");
      li4.textContent = "and the development metadata.";
      t15 = space();
      p1 = element("p");
      p1.innerHTML = `By clicking <b>I agree</b> you acknowledge that Bug Reports may include the aforementioned
  <b>required</b> data in the report, optionally including the
  <i>ArcAPI hostname</i> and your ArcOS Account preferences.`;
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      insert(target, t1, anchor);
      insert(target, h4, anchor);
      insert(target, t3, anchor);
      insert(target, ul, anchor);
      append(ul, li0);
      append(ul, t5);
      append(ul, li1);
      append(ul, t9);
      append(ul, li2);
      append(ul, t11);
      append(ul, li3);
      append(ul, t13);
      append(ul, li4);
      insert(target, t15, anchor);
      insert(target, p1, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p0);
        detach(t1);
        detach(h4);
        detach(t3);
        detach(ul);
        detach(t15);
        detach(p1);
      }
    }
  };
}
class DataPrivacy extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$4e, safe_not_equal, {});
  }
}
class CreatorRuntime extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "Title", Store$1(""));
    __publicField(this, "Body", Store$1(""));
    __publicField(this, "IncludeUserData", Store$1(false));
    __publicField(this, "IncludeApi", Store$1(true));
    __publicField(this, "Loading", Store$1(false));
  }
  async Send() {
    const title = this.Title.get();
    const body = this.Body.get();
    if (!title || !body)
      return;
    this.Loading.set(true);
    const id = await sendReport({
      title,
      body,
      includeUserData: this.IncludeUserData.get(),
      includeApi: this.IncludeApi.get()
    });
    ProcessStack.dispatch.dispatchToPid(this.process.parentPid, "open-report", id);
    this.closeApp();
    this.Loading.set(false);
  }
  DataPrivacy() {
    createErrorDialog(
      {
        title: "Please keep in mind",
        component: DataPrivacy,
        buttons: [
          { caption: "Decline", action: () => this.closeApp() },
          { caption: "I Agree", action() {
          }, suggested: true }
        ],
        sound: "arcos.dialog.info"
      },
      this.pid,
      true
    );
  }
}
function create_fragment$4d(ctx) {
  let div7;
  let div1;
  let p0;
  let t1;
  let div0;
  let input0;
  let t2;
  let div5;
  let p1;
  let t4;
  let div4;
  let div2;
  let span0;
  let t6;
  let input1;
  let input1_disabled_value;
  let t7;
  let div3;
  let span1;
  let t9;
  let input2;
  let t10;
  let textarea;
  let t11;
  let div6;
  let mounted;
  let dispose;
  return {
    c() {
      div7 = element("div");
      div1 = element("div");
      p0 = element("p");
      p0.textContent = "Title";
      t1 = space();
      div0 = element("div");
      input0 = element("input");
      t2 = space();
      div5 = element("div");
      p1 = element("p");
      p1.textContent = "Include?";
      t4 = space();
      div4 = element("div");
      div2 = element("div");
      span0 = element("span");
      span0.textContent = "Preferences";
      t6 = space();
      input1 = element("input");
      t7 = space();
      div3 = element("div");
      span1 = element("span");
      span1.textContent = "The Server";
      t9 = space();
      input2 = element("input");
      t10 = space();
      textarea = element("textarea");
      t11 = space();
      div6 = element("div");
      div6.innerHTML = `Any information you provide in a bug report is treated as confidential and will never be shared
    to external parties. Select <b>Data Privacy</b> for more information.`;
      attr(p0, "class", "caption");
      attr(input0, "type", "text");
      attr(input0, "placeholder", "Short title to give is a summary");
      attr(div0, "class", "value");
      attr(div1, "class", "field title");
      attr(p1, "class", "caption");
      attr(input1, "type", "checkbox");
      input1.disabled = input1_disabled_value = !/*$UserName*/
      ctx[1];
      attr(div2, "class", "option");
      attr(input2, "type", "checkbox");
      input2.checked = true;
      attr(div3, "class", "option");
      attr(div4, "class", "value");
      attr(div5, "class", "field include");
      attr(textarea, "class", "body");
      attr(textarea, "placeholder", "Report Body: Provide any particular information about the bug here.");
      attr(div6, "class", "notice");
      attr(div7, "class", "fields");
    },
    m(target, anchor) {
      insert(target, div7, anchor);
      append(div7, div1);
      append(div1, p0);
      append(div1, t1);
      append(div1, div0);
      append(div0, input0);
      set_input_value(
        input0,
        /*$Title*/
        ctx[0]
      );
      append(div7, t2);
      append(div7, div5);
      append(div5, p1);
      append(div5, t4);
      append(div5, div4);
      append(div4, div2);
      append(div2, span0);
      append(div2, t6);
      append(div2, input1);
      set_input_value(
        input1,
        /*$IncludeUserData*/
        ctx[2]
      );
      append(div4, t7);
      append(div4, div3);
      append(div3, span1);
      append(div3, t9);
      append(div3, input2);
      set_input_value(
        input2,
        /*$IncludeApi*/
        ctx[3]
      );
      append(div7, t10);
      append(div7, textarea);
      set_input_value(
        textarea,
        /*$Body*/
        ctx[4]
      );
      append(div7, t11);
      append(div7, div6);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[10]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[11]
          ),
          listen(
            input2,
            "change",
            /*input2_change_handler*/
            ctx[12]
          ),
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$Title*/
      1 && input0.value !== /*$Title*/
      ctx2[0]) {
        set_input_value(
          input0,
          /*$Title*/
          ctx2[0]
        );
      }
      if (dirty & /*$UserName*/
      2 && input1_disabled_value !== (input1_disabled_value = !/*$UserName*/
      ctx2[1])) {
        input1.disabled = input1_disabled_value;
      }
      if (dirty & /*$IncludeUserData*/
      4) {
        set_input_value(
          input1,
          /*$IncludeUserData*/
          ctx2[2]
        );
      }
      if (dirty & /*$IncludeApi*/
      8) {
        set_input_value(
          input2,
          /*$IncludeApi*/
          ctx2[3]
        );
      }
      if (dirty & /*$Body*/
      16) {
        set_input_value(
          textarea,
          /*$Body*/
          ctx2[4]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div7);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3Q($$self, $$props, $$invalidate) {
  let $Title;
  let $UserName;
  let $IncludeUserData;
  let $IncludeApi;
  let $Body;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(1, $UserName = $$value));
  let { runtime } = $$props;
  const { IncludeUserData, IncludeApi, Body: Body2, Title } = runtime;
  component_subscribe($$self, IncludeUserData, (value) => $$invalidate(2, $IncludeUserData = value));
  component_subscribe($$self, IncludeApi, (value) => $$invalidate(3, $IncludeApi = value));
  component_subscribe($$self, Body2, (value) => $$invalidate(4, $Body = value));
  component_subscribe($$self, Title, (value) => $$invalidate(0, $Title = value));
  function input0_input_handler() {
    $Title = this.value;
    Title.set($Title);
  }
  function input1_change_handler() {
    $IncludeUserData = this.value;
    IncludeUserData.set($IncludeUserData);
  }
  function input2_change_handler() {
    $IncludeApi = this.value;
    IncludeApi.set($IncludeApi);
  }
  function textarea_input_handler() {
    $Body = this.value;
    Body2.set($Body);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(9, runtime = $$props2.runtime);
  };
  return [
    $Title,
    $UserName,
    $IncludeUserData,
    $IncludeApi,
    $Body,
    IncludeUserData,
    IncludeApi,
    Body2,
    Title,
    runtime,
    input0_input_handler,
    input1_change_handler,
    input2_change_handler,
    textarea_input_handler
  ];
}
class Fields extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3Q, create_fragment$4d, safe_not_equal, { runtime: 9 });
  }
}
function create_fragment$4c(ctx) {
  let div1;
  let p2;
  let t6;
  let div0;
  let button0;
  let t7;
  let t8;
  let button1;
  let t9;
  let t10;
  let button2;
  let t11;
  let button2_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      p2 = element("p");
      p2.textContent = `ArcOS ${ArcOSVersion}-${ARCOS_MODE} - ${isDesktop() ? "desktop" : "browser"}`;
      t6 = space();
      div0 = element("div");
      button0 = element("button");
      t7 = text("Data Privacy");
      t8 = space();
      button1 = element("button");
      t9 = text("Cancel");
      t10 = space();
      button2 = element("button");
      t11 = text("Submit Report");
      attr(p2, "class", "version");
      button0.disabled = /*$Loading*/
      ctx[0];
      button1.disabled = /*$Loading*/
      ctx[0];
      attr(button2, "class", "suggested");
      button2.disabled = button2_disabled_value = /*$Loading*/
      ctx[0] || !/*$Title*/
      ctx[1] || !/*$Body*/
      ctx[2];
      attr(div0, "class", "buttons");
      attr(div1, "class", "toolbar");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, p2);
      append(div1, t6);
      append(div1, div0);
      append(div0, button0);
      append(button0, t7);
      append(div0, t8);
      append(div0, button1);
      append(button1, t9);
      append(div0, t10);
      append(div0, button2);
      append(button2, t11);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*privacy*/
            ctx[6]
          ),
          listen(
            button1,
            "click",
            /*exit*/
            ctx[7]
          ),
          listen(
            button2,
            "click",
            /*send*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$Loading*/
      1) {
        button0.disabled = /*$Loading*/
        ctx2[0];
      }
      if (dirty & /*$Loading*/
      1) {
        button1.disabled = /*$Loading*/
        ctx2[0];
      }
      if (dirty & /*$Loading, $Title, $Body*/
      7 && button2_disabled_value !== (button2_disabled_value = /*$Loading*/
      ctx2[0] || !/*$Title*/
      ctx2[1] || !/*$Body*/
      ctx2[2])) {
        button2.disabled = button2_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3P($$self, $$props, $$invalidate) {
  let $Loading;
  let $Title;
  let $Body;
  let { runtime } = $$props;
  const { Loading: Loading4, Title, Body: Body2 } = runtime;
  component_subscribe($$self, Loading4, (value) => $$invalidate(0, $Loading = value));
  component_subscribe($$self, Title, (value) => $$invalidate(1, $Title = value));
  component_subscribe($$self, Body2, (value) => $$invalidate(2, $Body = value));
  function privacy() {
    runtime.DataPrivacy();
  }
  function exit() {
    runtime.closeApp();
  }
  function send() {
    runtime.Send();
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(9, runtime = $$props2.runtime);
  };
  return [$Loading, $Title, $Body, Loading4, Title, Body2, privacy, exit, send, runtime];
}
let Toolbar$7 = class Toolbar extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3P, create_fragment$4c, safe_not_equal, { runtime: 9 });
  }
};
const main$t = "";
function create_fragment$4b(ctx) {
  let fields;
  let t2;
  let toolbar;
  let current;
  fields = new Fields({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  toolbar = new Toolbar$7({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(fields.$$.fragment);
      t2 = space();
      create_component(toolbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fields, target, anchor);
      insert(target, t2, anchor);
      mount_component(toolbar, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const fields_changes = {};
      if (dirty & /*runtime*/
      1)
        fields_changes.runtime = /*runtime*/
        ctx2[0];
      fields.$set(fields_changes);
      const toolbar_changes = {};
      if (dirty & /*runtime*/
      1)
        toolbar_changes.runtime = /*runtime*/
        ctx2[0];
      toolbar.$set(toolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fields.$$.fragment, local);
      transition_in(toolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fields.$$.fragment, local);
      transition_out(toolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(fields, detaching);
      destroy_component(toolbar, detaching);
    }
  };
}
function instance$3O($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime];
}
let Creator$1 = class Creator extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3O, create_fragment$4b, safe_not_equal, { runtime: 0 });
  }
};
const Creator2 = {
  metadata: {
    name: "Submit Bug Report",
    description: "View data of a report",
    icon: BugReportIcon,
    author: "The ArcOS Team",
    version: "1.0.0"
  },
  runtime: CreatorRuntime,
  content: Creator$1,
  id: "Creator",
  size: { w: 650, h: 500 },
  minSize: { w: 650, h: 500 },
  maxSize: { w: 650, h: 500 },
  pos: { x: 150, y: 100 },
  state: {
    maximized: false,
    minimized: false,
    fullscreen: false,
    resizable: false,
    headless: false
  },
  controls: {
    minimize: false,
    maximize: false,
    close: false
  }
};
const main$s = "";
class DataViewRuntime extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "Body", Store$1(""));
    const args = process.args;
    const body = args[0];
    if (body && typeof body == "string")
      this.Body.set(body);
  }
}
function create_fragment$4a(ctx) {
  let textarea;
  let t0;
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      t0 = space();
      div = element("div");
      button = element("button");
      button.textContent = "Close";
      textarea.value = /*$Body*/
      ctx[0];
      textarea.readOnly = true;
      attr(textarea, "spellcheck", "false");
      attr(button, "class", "suggested");
      attr(div, "class", "toolbar");
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*closeThis*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$Body*/
      1) {
        textarea.value = /*$Body*/
        ctx2[0];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(textarea);
        detach(t0);
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3N($$self, $$props, $$invalidate) {
  let $Body;
  let { runtime } = $$props;
  const { Body: Body2 } = runtime;
  component_subscribe($$self, Body2, (value) => $$invalidate(0, $Body = value));
  function closeThis() {
    runtime.closeApp();
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [$Body, Body2, closeThis, runtime];
}
class DataView extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3N, create_fragment$4a, safe_not_equal, { runtime: 3 });
  }
}
const DataViewer = {
  metadata: {
    name: "Data Viewer",
    description: "View data of a report",
    icon: ComponentIcon,
    author: "The ArcOS Team",
    version: "1.0.0"
  },
  runtime: DataViewRuntime,
  content: DataView,
  id: "DataViewer",
  size: { w: 800, h: 550 },
  minSize: { w: 800, h: 550 },
  maxSize: { w: 800, h: 550 },
  pos: { x: 0, y: 0 },
  state: {
    maximized: false,
    minimized: false,
    fullscreen: false,
    resizable: false,
    headless: true
  },
  controls: {
    minimize: false,
    maximize: false,
    close: false
  },
  isOverlay: true
};
let Runtime$g = class Runtime7 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "Report", Store$1());
    __publicField(this, "Selected", Store$1());
    __publicField(this, "store", Store$1([]));
    __publicField(this, "Loading", Store$1(false));
    __publicField(this, "HasOverlay", Store$1(false));
    this.setStoreListener();
    this.update();
    if (!this.store.get().length)
      this.CreateReport();
  }
  update() {
    const reports = getAppPreference("Reporting", "reports") || [];
    this.store.set(reports.sort((a2, b2) => b2.timestamp - a2.timestamp));
    if (!this.Selected.get() && reports[0])
      this.openReport(reports[0].id);
  }
  setStoreListener() {
    UserDataStore.subscribe(() => this.update());
  }
  async openReport(id) {
    const current = this.Selected.get();
    if (current == id)
      return;
    this.Selected.set(id);
    this.Report.set(null);
    this.Loading.set(true);
    const report = await getReport(id);
    this.Loading.set(false);
    if (!report)
      return this.NotFound(id);
    this.Report.set({ ...report, id });
  }
  NotFound(id) {
    createErrorDialog(
      {
        title: "Can't find report",
        message: `It doesn't appear that the Bug Report with ID <code>${id}</code> exists on the Reports server. It might have been deleted by an ArcOS Team Member. Do you want to remove it from the list?`,
        buttons: [
          {
            caption: "Keep it",
            action() {
            }
          },
          {
            caption: "Remove from list",
            action: () => {
              this.removeReport(id);
            },
            suggested: true
          }
        ],
        image: ErrorIcon,
        sound: "arcos.dialog.error"
      },
      this.pid,
      true
    );
  }
  removeReport(id) {
    const reports = this.store.get();
    const report = this.Report.get();
    id || (id = report.id);
    if (!id)
      return;
    const result = reports.filter((report2) => report2.id != id);
    createErrorDialog(
      {
        title: "Remove report?",
        message: "Are you sure you want to remove this report from your account? This won't delete it from the Reports server if it still exists.",
        buttons: [
          { caption: "Cancel", action() {
          } },
          {
            caption: "Remove",
            action: () => {
              setAppPreference("Reporting", "reports", result);
              if (!id) {
                this.Report.set(null);
                this.Selected.set(null);
              }
            },
            suggested: true
          }
        ],
        image: WarningIcon,
        sound: "arcos.dialog.warning"
      },
      this.pid,
      true
    );
  }
  async ViewData(body) {
    if (this.HasOverlay.get())
      return;
    const proc = await spawnOverlay(DataViewer, this.pid, [body]);
    if (typeof proc === "string")
      return;
    this.HasOverlay.set(true);
    const subscriber = ProcessStack.processes.subscribe(() => {
      if (!ProcessStack.isPid(proc.pid, true)) {
        this.HasOverlay.set(false);
        subscriber();
      }
    });
  }
  async CreateReport() {
    if (this.HasOverlay.get())
      return;
    const proc = await spawnOverlay(Creator2, this.pid);
    if (typeof proc === "string")
      return;
    this.HasOverlay.set(true);
    const subscriber = ProcessStack.processes.subscribe(() => {
      if (!ProcessStack.isPid(proc.pid, true)) {
        this.HasOverlay.set(false);
        subscriber();
      }
    });
  }
};
function create_fragment$49(ctx) {
  let div;
  let img;
  let img_src_value;
  let t0;
  let h1;
  let t2;
  let p2;
  let t3;
  let code;
  let t4;
  let t5;
  return {
    c() {
      div = element("div");
      img = element("img");
      t0 = space();
      h1 = element("h1");
      h1.textContent = "Not Found";
      t2 = space();
      p2 = element("p");
      t3 = text("Report ");
      code = element("code");
      t4 = text(
        /*id*/
        ctx[0]
      );
      t5 = text(" does not exist on the Reports server!");
      if (!src_url_equal(img.src, img_src_value = ErrorIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(div, "class", "not-found");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
      append(div, t0);
      append(div, h1);
      append(div, t2);
      append(div, p2);
      append(p2, t3);
      append(p2, code);
      append(code, t4);
      append(p2, t5);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*id*/
      1)
        set_data(
          t4,
          /*id*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$3M($$self, $$props, $$invalidate) {
  let { id } = $$props;
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
  };
  return [id];
}
class NotFound extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3M, create_fragment$49, safe_not_equal, { id: 0 });
  }
}
function create_fragment$48(ctx) {
  let div5;
  let button0;
  let t0;
  let button0_disabled_value;
  let t1;
  let div0;
  let t2;
  let div1;
  let button1;
  let t3;
  let button1_disabled_value;
  let t4;
  let button2;
  let t5;
  let button2_disabled_value;
  let t6;
  let button3;
  let t7;
  let button3_disabled_value;
  let t8;
  let div2;
  let t9;
  let div3;
  let button4;
  let t10;
  let t11;
  let div4;
  let mounted;
  let dispose;
  return {
    c() {
      div5 = element("div");
      button0 = element("button");
      t0 = text("clear_all");
      t1 = space();
      div0 = element("div");
      t2 = space();
      div1 = element("div");
      button1 = element("button");
      t3 = text("message");
      t4 = space();
      button2 = element("button");
      t5 = text("info_outline");
      t6 = space();
      button3 = element("button");
      t7 = text("account_tree");
      t8 = space();
      div2 = element("div");
      t9 = space();
      div3 = element("div");
      button4 = element("button");
      t10 = text("Report Bug");
      t11 = space();
      div4 = element("div");
      attr(button0, "class", "material-icons-round");
      button0.disabled = button0_disabled_value = !/*$Selected*/
      ctx[1] || /*$HasOverlay*/
      ctx[2];
      attr(div0, "class", "sep");
      attr(button1, "class", "material-icons-round");
      button1.disabled = button1_disabled_value = !/*$Report*/
      ctx[0] || !/*$Report*/
      ctx[0].body || /*$HasOverlay*/
      ctx[2];
      attr(button2, "class", "material-icons-round");
      button2.disabled = button2_disabled_value = !/*$Report*/
      ctx[0] || !/*$Report*/
      ctx[0].log || /*$HasOverlay*/
      ctx[2];
      attr(button3, "class", "material-icons-round");
      button3.disabled = button3_disabled_value = !/*$Report*/
      ctx[0] || !/*$Report*/
      ctx[0].userdata || /*$HasOverlay*/
      ctx[2];
      attr(div1, "class", "group");
      attr(div2, "class", "sep");
      attr(button4, "class", "suggested");
      button4.disabled = /*$HasOverlay*/
      ctx[2];
      attr(div3, "class", "group");
      attr(div4, "class", "sep");
      attr(div5, "class", "toolbar");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, button0);
      append(button0, t0);
      append(div5, t1);
      append(div5, div0);
      append(div5, t2);
      append(div5, div1);
      append(div1, button1);
      append(button1, t3);
      append(div1, t4);
      append(div1, button2);
      append(button2, t5);
      append(div1, t6);
      append(div1, button3);
      append(button3, t7);
      append(div5, t8);
      append(div5, div2);
      append(div5, t9);
      append(div5, div3);
      append(div3, button4);
      append(button4, t10);
      append(div5, t11);
      append(div5, div4);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*remove*/
            ctx[6]
          ),
          listen(
            button1,
            "click",
            /*body*/
            ctx[7]
          ),
          listen(
            button2,
            "click",
            /*log*/
            ctx[8]
          ),
          listen(
            button3,
            "click",
            /*userdata*/
            ctx[9]
          ),
          listen(
            button4,
            "click",
            /*report*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$Selected, $HasOverlay*/
      6 && button0_disabled_value !== (button0_disabled_value = !/*$Selected*/
      ctx2[1] || /*$HasOverlay*/
      ctx2[2])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*$Report, $HasOverlay*/
      5 && button1_disabled_value !== (button1_disabled_value = !/*$Report*/
      ctx2[0] || !/*$Report*/
      ctx2[0].body || /*$HasOverlay*/
      ctx2[2])) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*$Report, $HasOverlay*/
      5 && button2_disabled_value !== (button2_disabled_value = !/*$Report*/
      ctx2[0] || !/*$Report*/
      ctx2[0].log || /*$HasOverlay*/
      ctx2[2])) {
        button2.disabled = button2_disabled_value;
      }
      if (dirty & /*$Report, $HasOverlay*/
      5 && button3_disabled_value !== (button3_disabled_value = !/*$Report*/
      ctx2[0] || !/*$Report*/
      ctx2[0].userdata || /*$HasOverlay*/
      ctx2[2])) {
        button3.disabled = button3_disabled_value;
      }
      if (dirty & /*$HasOverlay*/
      4) {
        button4.disabled = /*$HasOverlay*/
        ctx2[2];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3L($$self, $$props, $$invalidate) {
  let $Report;
  let $Selected;
  let $HasOverlay;
  let { runtime } = $$props;
  const { Report: Report2, Selected, HasOverlay } = runtime;
  component_subscribe($$self, Report2, (value) => $$invalidate(0, $Report = value));
  component_subscribe($$self, Selected, (value) => $$invalidate(1, $Selected = value));
  component_subscribe($$self, HasOverlay, (value) => $$invalidate(2, $HasOverlay = value));
  function remove() {
    runtime.removeReport();
  }
  function body() {
    runtime.ViewData($Report.body);
  }
  function log() {
    runtime.ViewData($Report.log);
  }
  function userdata() {
    runtime.ViewData(JSON.stringify($Report.userdata, null, 4));
  }
  function report() {
    runtime.CreateReport();
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(11, runtime = $$props2.runtime);
  };
  return [
    $Report,
    $Selected,
    $HasOverlay,
    Report2,
    Selected,
    HasOverlay,
    remove,
    body,
    log,
    userdata,
    report,
    runtime
  ];
}
let Toolbar$6 = class Toolbar2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3L, create_fragment$48, safe_not_equal, { runtime: 11 });
  }
};
const ApiReveal_svelte_svelte_type_style_lang = "";
function create_else_block$t(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block$1D(ctx) {
  let t_value = (
    /*api*/
    (ctx[0] || "(Not connected)") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*api*/
      1 && t_value !== (t_value = /*api*/
      (ctx2[0] || "(Not connected)") + ""))
        set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$47(ctx) {
  let span2;
  let span0;
  let current_block_type_index;
  let if_block;
  let t2;
  let span1;
  let current;
  const if_block_creators = [create_if_block$1D, create_else_block$t];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*api*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      if_block.c();
      t2 = space();
      span1 = element("span");
      attr(span0, "class", "api svelte-1lv4tmj");
      attr(span1, "class", "placeholder svelte-1lv4tmj");
      attr(span2, "class", "reveal svelte-1lv4tmj");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      if_blocks[current_block_type_index].m(span0, null);
      append(span2, t2);
      append(span2, span1);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(span0, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span2);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$3K($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { api: api2 = getServer() } = $$props;
  $$self.$$set = ($$props2) => {
    if ("api" in $$props2)
      $$invalidate(0, api2 = $$props2.api);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [api2, $$scope, slots];
}
class ApiReveal extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3K, create_fragment$47, safe_not_equal, { api: 0 });
  }
}
function create_default_slot_8$3(ctx) {
  let t_value = (
    /*report*/
    ctx[0].userdata ? "Yes" : "No"
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*report*/
      1 && t_value !== (t_value = /*report*/
      ctx2[0].userdata ? "Yes" : "No"))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_7$3(ctx) {
  let t_value = (
    /*report*/
    ctx[0].api ? "Yes" : "No"
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*report*/
      1 && t_value !== (t_value = /*report*/
      ctx2[0].api ? "Yes" : "No"))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_6$3(ctx) {
  let apireveal;
  let current;
  apireveal = new ApiReveal({ props: { api: (
    /*report*/
    ctx[0].id
  ) } });
  return {
    c() {
      create_component(apireveal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(apireveal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const apireveal_changes = {};
      if (dirty & /*report*/
      1)
        apireveal_changes.api = /*report*/
        ctx2[0].id;
      apireveal.$set(apireveal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(apireveal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(apireveal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(apireveal, detaching);
    }
  };
}
function create_default_slot_5$3(ctx) {
  let segment0;
  let t0;
  let segment1;
  let t1;
  let segment2;
  let current;
  segment0 = new Segment({
    props: {
      title: "Provided User Data",
      $$slots: { default: [create_default_slot_8$3] },
      $$scope: { ctx }
    }
  });
  segment1 = new Segment({
    props: {
      title: "Provided Server",
      $$slots: { default: [create_default_slot_7$3] },
      $$scope: { ctx }
    }
  });
  segment2 = new Segment({
    props: {
      title: "Report ID",
      $$slots: { default: [create_default_slot_6$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(segment0.$$.fragment);
      t0 = space();
      create_component(segment1.$$.fragment);
      t1 = space();
      create_component(segment2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(segment0, target, anchor);
      insert(target, t0, anchor);
      mount_component(segment1, target, anchor);
      insert(target, t1, anchor);
      mount_component(segment2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const segment0_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment0.$set(segment0_changes);
      const segment1_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment1.$set(segment1_changes);
      const segment2_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment2.$set(segment2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(segment0.$$.fragment, local);
      transition_in(segment1.$$.fragment, local);
      transition_in(segment2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(segment0.$$.fragment, local);
      transition_out(segment1.$$.fragment, local);
      transition_out(segment2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(segment0, detaching);
      destroy_component(segment1, detaching);
      destroy_component(segment2, detaching);
    }
  };
}
function create_default_slot_4$3(ctx) {
  let t_value = (
    /*report*/
    ctx[0].resolved ? "Yes!" : "No..."
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*report*/
      1 && t_value !== (t_value = /*report*/
      ctx2[0].resolved ? "Yes!" : "No..."))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_3$8(ctx) {
  let t_value = (
    /*report*/
    ctx[0].closed ? "Yes" : "No"
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*report*/
      1 && t_value !== (t_value = /*report*/
      ctx2[0].closed ? "Yes" : "No"))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_2$d(ctx) {
  let t_value = (
    /*report*/
    ctx[0].issueid + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*report*/
      1 && t_value !== (t_value = /*report*/
      ctx2[0].issueid + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$f(ctx) {
  let segment0;
  let t0;
  let segment1;
  let t1;
  let segment2;
  let current;
  segment0 = new Segment({
    props: {
      title: "Resolved",
      $$slots: { default: [create_default_slot_4$3] },
      $$scope: { ctx }
    }
  });
  segment1 = new Segment({
    props: {
      title: "Closed",
      $$slots: { default: [create_default_slot_3$8] },
      $$scope: { ctx }
    }
  });
  segment2 = new Segment({
    props: {
      title: "Issue ID",
      $$slots: { default: [create_default_slot_2$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(segment0.$$.fragment);
      t0 = space();
      create_component(segment1.$$.fragment);
      t1 = space();
      create_component(segment2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(segment0, target, anchor);
      insert(target, t0, anchor);
      mount_component(segment1, target, anchor);
      insert(target, t1, anchor);
      mount_component(segment2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const segment0_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment0.$set(segment0_changes);
      const segment1_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment1.$set(segment1_changes);
      const segment2_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment2.$set(segment2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(segment0.$$.fragment, local);
      transition_in(segment1.$$.fragment, local);
      transition_in(segment2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(segment0.$$.fragment, local);
      transition_out(segment1.$$.fragment, local);
      transition_out(segment2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(segment0, detaching);
      destroy_component(segment1, detaching);
      destroy_component(segment2, detaching);
    }
  };
}
function create_default_slot$n(ctx) {
  let inforow0;
  let t2;
  let inforow1;
  let current;
  inforow0 = new InfoRow({
    props: {
      $$slots: { default: [create_default_slot_5$3] },
      $$scope: { ctx }
    }
  });
  inforow1 = new InfoRow({
    props: {
      $$slots: { default: [create_default_slot_1$f] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(inforow0.$$.fragment);
      t2 = space();
      create_component(inforow1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inforow0, target, anchor);
      insert(target, t2, anchor);
      mount_component(inforow1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inforow0_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        inforow0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inforow0.$set(inforow0_changes);
      const inforow1_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        inforow1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inforow1.$set(inforow1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inforow0.$$.fragment, local);
      transition_in(inforow1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inforow0.$$.fragment, local);
      transition_out(inforow1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(inforow0, detaching);
      destroy_component(inforow1, detaching);
    }
  };
}
function create_fragment$46(ctx) {
  let infoblock;
  let current;
  infoblock = new InfoBlock({
    props: {
      $$slots: { default: [create_default_slot$n] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(infoblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(infoblock, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const infoblock_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        infoblock_changes.$$scope = { dirty, ctx: ctx2 };
      }
      infoblock.$set(infoblock_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(infoblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(infoblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(infoblock, detaching);
    }
  };
}
function instance$3J($$self, $$props, $$invalidate) {
  let { report } = $$props;
  $$self.$$set = ($$props2) => {
    if ("report" in $$props2)
      $$invalidate(0, report = $$props2.report);
  };
  return [report];
}
class AdditionalMeta extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3J, create_fragment$46, safe_not_equal, { report: 0 });
  }
}
function create_default_slot_13(ctx) {
  let t_value = (
    /*report*/
    ctx[0].author + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*report*/
      1 && t_value !== (t_value = /*report*/
      ctx2[0].author + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_12(ctx) {
  let t_value = dayjs(
    /*report*/
    ctx[0].created_at
  ).format("MMMM D YYYY") + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*report*/
      1 && t_value !== (t_value = dayjs(
        /*report*/
        ctx2[0].created_at
      ).format("MMMM D YYYY") + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_11$1(ctx) {
  let t_value = dayjs(
    /*report*/
    ctx[0].created_at
  ).format("h:mm A") + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*report*/
      1 && t_value !== (t_value = dayjs(
        /*report*/
        ctx2[0].created_at
      ).format("h:mm A") + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_10$1(ctx) {
  let t_value = (
    /*report*/
    (ctx[0].api || "Unknown") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*report*/
      1 && t_value !== (t_value = /*report*/
      (ctx2[0].api || "Unknown") + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_9$2(ctx) {
  let segment0;
  let t0;
  let segment1;
  let t1;
  let segment2;
  let t2;
  let segment3;
  let current;
  segment0 = new Segment({
    props: {
      title: "Created By",
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  segment1 = new Segment({
    props: {
      title: "Date",
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  segment2 = new Segment({
    props: {
      title: "Time",
      $$slots: { default: [create_default_slot_11$1] },
      $$scope: { ctx }
    }
  });
  segment3 = new Segment({
    props: {
      title: "Server",
      $$slots: { default: [create_default_slot_10$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(segment0.$$.fragment);
      t0 = space();
      create_component(segment1.$$.fragment);
      t1 = space();
      create_component(segment2.$$.fragment);
      t2 = space();
      create_component(segment3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(segment0, target, anchor);
      insert(target, t0, anchor);
      mount_component(segment1, target, anchor);
      insert(target, t1, anchor);
      mount_component(segment2, target, anchor);
      insert(target, t2, anchor);
      mount_component(segment3, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const segment0_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment0.$set(segment0_changes);
      const segment1_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment1.$set(segment1_changes);
      const segment2_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment2.$set(segment2_changes);
      const segment3_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment3.$set(segment3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(segment0.$$.fragment, local);
      transition_in(segment1.$$.fragment, local);
      transition_in(segment2.$$.fragment, local);
      transition_in(segment3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(segment0.$$.fragment, local);
      transition_out(segment1.$$.fragment, local);
      transition_out(segment2.$$.fragment, local);
      transition_out(segment3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(segment0, detaching);
      destroy_component(segment1, detaching);
      destroy_component(segment2, detaching);
      destroy_component(segment3, detaching);
    }
  };
}
function create_default_slot_8$2(ctx) {
  let t_value = (
    /*report*/
    (ctx[0].useragent || "No user agent provided") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*report*/
      1 && t_value !== (t_value = /*report*/
      (ctx2[0].useragent || "No user agent provided") + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_7$2(ctx) {
  let segment;
  let current;
  segment = new Segment({
    props: {
      title: "User Agent",
      $$slots: { default: [create_default_slot_8$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(segment.$$.fragment);
    },
    m(target, anchor) {
      mount_component(segment, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const segment_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment.$set(segment_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(segment.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(segment.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(segment, detaching);
    }
  };
}
function create_default_slot_6$2(ctx) {
  let t_value = (
    /*report*/
    (ctx[0].frontend || "Unknown") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*report*/
      1 && t_value !== (t_value = /*report*/
      (ctx2[0].frontend || "Unknown") + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_5$2(ctx) {
  let t_value = (
    /*report*/
    ctx[0].metaenv.MODE + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*report*/
      1 && t_value !== (t_value = /*report*/
      ctx2[0].metaenv.MODE + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_4$2(ctx) {
  let t_value = (
    /*report*/
    ctx[0].desktop ? "Yes" : "No"
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*report*/
      1 && t_value !== (t_value = /*report*/
      ctx2[0].desktop ? "Yes" : "No"))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_3$7(ctx) {
  let span;
  let t0_value = (
    /*report*/
    ctx[0].mode_file + ""
  );
  let t0;
  let t1;
  let img;
  let img_src_value;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = Logo(
        /*report*/
        ctx[0].mode_file
      )))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*report*/
      1 && t0_value !== (t0_value = /*report*/
      ctx2[0].mode_file + ""))
        set_data(t0, t0_value);
      if (dirty & /*report*/
      1 && !src_url_equal(img.src, img_src_value = Logo(
        /*report*/
        ctx2[0].mode_file
      ))) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t1);
        detach(img);
      }
    }
  };
}
function create_if_block$1C(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = WarningIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_default_slot_2$c(ctx) {
  let span;
  let t0_value = (
    /*report*/
    ctx[0].version + ""
  );
  let t0;
  let t1;
  let show_if = !/*report*/
  ctx[0].version.startsWith("6.");
  let if_block_anchor;
  let if_block = show_if && create_if_block$1C();
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*report*/
      1 && t0_value !== (t0_value = /*report*/
      ctx2[0].version + ""))
        set_data(t0, t0_value);
      if (dirty & /*report*/
      1)
        show_if = !/*report*/
        ctx2[0].version.startsWith("6.");
      if (show_if) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$1C();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t1);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_default_slot_1$e(ctx) {
  let segment0;
  let t0;
  let segment1;
  let t1;
  let segment2;
  let t2;
  let segment3;
  let t3;
  let segment4;
  let current;
  segment0 = new Segment({
    props: {
      title: "Client",
      $$slots: { default: [create_default_slot_6$2] },
      $$scope: { ctx }
    }
  });
  segment1 = new Segment({
    props: {
      title: "Vite",
      $$slots: { default: [create_default_slot_5$2] },
      $$scope: { ctx }
    }
  });
  segment2 = new Segment({
    props: {
      title: "Desktop",
      $$slots: { default: [create_default_slot_4$2] },
      $$scope: { ctx }
    }
  });
  segment3 = new Segment({
    props: {
      title: "Mode",
      className: "mode",
      $$slots: { default: [create_default_slot_3$7] },
      $$scope: { ctx }
    }
  });
  segment4 = new Segment({
    props: {
      right: true,
      title: "Version",
      className: "version",
      $$slots: { default: [create_default_slot_2$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(segment0.$$.fragment);
      t0 = space();
      create_component(segment1.$$.fragment);
      t1 = space();
      create_component(segment2.$$.fragment);
      t2 = space();
      create_component(segment3.$$.fragment);
      t3 = space();
      create_component(segment4.$$.fragment);
    },
    m(target, anchor) {
      mount_component(segment0, target, anchor);
      insert(target, t0, anchor);
      mount_component(segment1, target, anchor);
      insert(target, t1, anchor);
      mount_component(segment2, target, anchor);
      insert(target, t2, anchor);
      mount_component(segment3, target, anchor);
      insert(target, t3, anchor);
      mount_component(segment4, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const segment0_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment0.$set(segment0_changes);
      const segment1_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment1.$set(segment1_changes);
      const segment2_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment2.$set(segment2_changes);
      const segment3_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment3.$set(segment3_changes);
      const segment4_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        segment4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment4.$set(segment4_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(segment0.$$.fragment, local);
      transition_in(segment1.$$.fragment, local);
      transition_in(segment2.$$.fragment, local);
      transition_in(segment3.$$.fragment, local);
      transition_in(segment4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(segment0.$$.fragment, local);
      transition_out(segment1.$$.fragment, local);
      transition_out(segment2.$$.fragment, local);
      transition_out(segment3.$$.fragment, local);
      transition_out(segment4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
      }
      destroy_component(segment0, detaching);
      destroy_component(segment1, detaching);
      destroy_component(segment2, detaching);
      destroy_component(segment3, detaching);
      destroy_component(segment4, detaching);
    }
  };
}
function create_default_slot$m(ctx) {
  let inforow0;
  let t0;
  let inforow1;
  let t1;
  let inforow2;
  let current;
  inforow0 = new InfoRow({
    props: {
      $$slots: { default: [create_default_slot_9$2] },
      $$scope: { ctx }
    }
  });
  inforow1 = new InfoRow({
    props: {
      $$slots: { default: [create_default_slot_7$2] },
      $$scope: { ctx }
    }
  });
  inforow2 = new InfoRow({
    props: {
      $$slots: { default: [create_default_slot_1$e] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(inforow0.$$.fragment);
      t0 = space();
      create_component(inforow1.$$.fragment);
      t1 = space();
      create_component(inforow2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inforow0, target, anchor);
      insert(target, t0, anchor);
      mount_component(inforow1, target, anchor);
      insert(target, t1, anchor);
      mount_component(inforow2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inforow0_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        inforow0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inforow0.$set(inforow0_changes);
      const inforow1_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        inforow1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inforow1.$set(inforow1_changes);
      const inforow2_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        inforow2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inforow2.$set(inforow2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inforow0.$$.fragment, local);
      transition_in(inforow1.$$.fragment, local);
      transition_in(inforow2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inforow0.$$.fragment, local);
      transition_out(inforow1.$$.fragment, local);
      transition_out(inforow2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(inforow0, detaching);
      destroy_component(inforow1, detaching);
      destroy_component(inforow2, detaching);
    }
  };
}
function create_fragment$45(ctx) {
  let infoblock;
  let current;
  infoblock = new InfoBlock({
    props: {
      $$slots: { default: [create_default_slot$m] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(infoblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(infoblock, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const infoblock_changes = {};
      if (dirty & /*$$scope, report*/
      3) {
        infoblock_changes.$$scope = { dirty, ctx: ctx2 };
      }
      infoblock.$set(infoblock_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(infoblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(infoblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(infoblock, detaching);
    }
  };
}
function instance$3I($$self, $$props, $$invalidate) {
  let { report } = $$props;
  $$self.$$set = ($$props2) => {
    if ("report" in $$props2)
      $$invalidate(0, report = $$props2.report);
  };
  return [report];
}
class BaseMeta extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3I, create_fragment$45, safe_not_equal, { report: 0 });
  }
}
function create_fragment$44(ctx) {
  let div;
  let h1;
  let t0_value = (
    /*report*/
    ctx[0].title + ""
  );
  let t0;
  let t1;
  let p2;
  let t2;
  let t3_value = (
    /*report*/
    ctx[0].author + ""
  );
  let t3;
  let t4;
  let t5;
  return {
    c() {
      div = element("div");
      h1 = element("h1");
      t0 = text(t0_value);
      t1 = space();
      p2 = element("p");
      t2 = text("Submitted by ");
      t3 = text(t3_value);
      t4 = space();
      t5 = text(
        /*ts*/
        ctx[1]
      );
      attr(p2, "class", "subtitle");
      attr(div, "class", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h1);
      append(h1, t0);
      append(div, t1);
      append(div, p2);
      append(p2, t2);
      append(p2, t3);
      append(p2, t4);
      append(p2, t5);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*report*/
      1 && t0_value !== (t0_value = /*report*/
      ctx2[0].title + ""))
        set_data(t0, t0_value);
      if (dirty & /*report*/
      1 && t3_value !== (t3_value = /*report*/
      ctx2[0].author + ""))
        set_data(t3, t3_value);
      if (dirty & /*ts*/
      2)
        set_data(
          t5,
          /*ts*/
          ctx2[1]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$3H($$self, $$props, $$invalidate) {
  let { report } = $$props;
  let ts = "on 1 January 1970 at 12:00:00";
  onMount(() => {
    $$invalidate(1, ts = dayjs(report.created_at).format("[on] D MMMM YYYY [at] H:mm:ss"));
  });
  $$self.$$set = ($$props2) => {
    if ("report" in $$props2)
      $$invalidate(0, report = $$props2.report);
  };
  return [report, ts];
}
let Header$b = class Header2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3H, create_fragment$44, safe_not_equal, { report: 0 });
  }
};
function create_fragment$43(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<img src="${WarningIcon}" alt=""/> <span>This is a legacy report from ArcOS v5. These reports aren&#39;t processed anymore.</span>`;
      attr(div, "class", "legacy-notice");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
class LegacyNotice extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$43, safe_not_equal, {});
  }
}
function create_if_block$1B(ctx) {
  let legacynotice;
  let current;
  legacynotice = new LegacyNotice({});
  return {
    c() {
      create_component(legacynotice.$$.fragment);
    },
    m(target, anchor) {
      mount_component(legacynotice, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(legacynotice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(legacynotice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(legacynotice, detaching);
    }
  };
}
function create_fragment$42(ctx) {
  let header2;
  let t0;
  let basemeta;
  let t1;
  let additionalmeta;
  let t2;
  let show_if = !/*report*/
  ctx[0].version.startsWith("6.");
  let if_block_anchor;
  let current;
  header2 = new Header$b({ props: { report: (
    /*report*/
    ctx[0]
  ) } });
  basemeta = new BaseMeta({ props: { report: (
    /*report*/
    ctx[0]
  ) } });
  additionalmeta = new AdditionalMeta({ props: { report: (
    /*report*/
    ctx[0]
  ) } });
  let if_block = show_if && create_if_block$1B();
  return {
    c() {
      create_component(header2.$$.fragment);
      t0 = space();
      create_component(basemeta.$$.fragment);
      t1 = space();
      create_component(additionalmeta.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(header2, target, anchor);
      insert(target, t0, anchor);
      mount_component(basemeta, target, anchor);
      insert(target, t1, anchor);
      mount_component(additionalmeta, target, anchor);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const header_changes = {};
      if (dirty & /*report*/
      1)
        header_changes.report = /*report*/
        ctx2[0];
      header2.$set(header_changes);
      const basemeta_changes = {};
      if (dirty & /*report*/
      1)
        basemeta_changes.report = /*report*/
        ctx2[0];
      basemeta.$set(basemeta_changes);
      const additionalmeta_changes = {};
      if (dirty & /*report*/
      1)
        additionalmeta_changes.report = /*report*/
        ctx2[0];
      additionalmeta.$set(additionalmeta_changes);
      if (dirty & /*report*/
      1)
        show_if = !/*report*/
        ctx2[0].version.startsWith("6.");
      if (show_if) {
        if (if_block) {
          if (dirty & /*report*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1B();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(basemeta.$$.fragment, local);
      transition_in(additionalmeta.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(basemeta.$$.fragment, local);
      transition_out(additionalmeta.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(header2, detaching);
      destroy_component(basemeta, detaching);
      destroy_component(additionalmeta, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$3G($$self, $$props, $$invalidate) {
  let { report } = $$props;
  $$self.$$set = ($$props2) => {
    if ("report" in $$props2)
      $$invalidate(0, report = $$props2.report);
  };
  return [report];
}
class Viewer extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3G, create_fragment$42, safe_not_equal, { report: 0 });
  }
}
function create_default_slot$l(ctx) {
  let toolbar;
  let current;
  toolbar = new Toolbar$6({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(toolbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(toolbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const toolbar_changes = {};
      if (dirty & /*runtime*/
      1)
        toolbar_changes.runtime = /*runtime*/
        ctx2[0];
      toolbar.$set(toolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toolbar, detaching);
    }
  };
}
function create_else_block$s(ctx) {
  let div;
  let spinner;
  let current;
  spinner = new Spinner({ props: { height: 32 } });
  return {
    c() {
      div = element("div");
      create_component(spinner.$$.fragment);
      attr(div, "class", "loading");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(spinner, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(spinner);
    }
  };
}
function create_if_block$1A(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$y, create_if_block_2$d];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$Report*/
      ctx2[2]
    )
      return 0;
    if (
      /*$Selected*/
      ctx2[3]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function create_if_block_2$d(ctx) {
  let notfound;
  let current;
  notfound = new NotFound({ props: { id: (
    /*$Selected*/
    ctx[3]
  ) } });
  return {
    c() {
      create_component(notfound.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notfound, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notfound_changes = {};
      if (dirty & /*$Selected*/
      8)
        notfound_changes.id = /*$Selected*/
        ctx2[3];
      notfound.$set(notfound_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(notfound.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notfound.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notfound, detaching);
    }
  };
}
function create_if_block_1$y(ctx) {
  let viewer;
  let current;
  viewer = new Viewer({ props: { report: (
    /*$Report*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(viewer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewer_changes = {};
      if (dirty & /*$Report*/
      4)
        viewer_changes.report = /*$Report*/
        ctx2[2];
      viewer.$set(viewer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewer, detaching);
    }
  };
}
function create_fragment$41(ctx) {
  let div1;
  let titlebar;
  let t2;
  let div0;
  let current_block_type_index;
  let if_block;
  let current;
  titlebar = new Titlebar({
    props: {
      noCenter: true,
      pid: (
        /*runtime*/
        ctx[0].pid
      ),
      app: (
        /*runtime*/
        ctx[0].appMutator
      ),
      $$slots: { default: [create_default_slot$l] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block$1A, create_else_block$s];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*$Loading*/
    ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element("div");
      create_component(titlebar.$$.fragment);
      t2 = space();
      div0 = element("div");
      if_block.c();
      attr(div0, "class", "bottom");
      attr(div1, "class", "content");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(titlebar, div1, null);
      append(div1, t2);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const titlebar_changes = {};
      if (dirty & /*runtime*/
      1)
        titlebar_changes.pid = /*runtime*/
        ctx2[0].pid;
      if (dirty & /*runtime*/
      1)
        titlebar_changes.app = /*runtime*/
        ctx2[0].appMutator;
      if (dirty & /*$$scope, runtime*/
      129) {
        titlebar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      titlebar.$set(titlebar_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(titlebar.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(titlebar.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(titlebar);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$3F($$self, $$props, $$invalidate) {
  let $Loading;
  let $Report;
  let $Selected;
  let { runtime } = $$props;
  const { Report: Report2, Loading: Loading4, Selected } = runtime;
  component_subscribe($$self, Report2, (value) => $$invalidate(2, $Report = value));
  component_subscribe($$self, Loading4, (value) => $$invalidate(1, $Loading = value));
  component_subscribe($$self, Selected, (value) => $$invalidate(3, $Selected = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, $Loading, $Report, $Selected, Report2, Loading4, Selected];
}
let Content$4 = class Content extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3F, create_fragment$41, safe_not_equal, { runtime: 0 });
  }
};
function create_fragment$40(ctx) {
  let button;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(
        /*timestamp*/
        ctx[1]
      );
      if (!src_url_equal(img.src, img_src_value = ArcAppMimeIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      toggle_class(
        button,
        "active",
        /*$Selected*/
        ctx[2] == /*report*/
        ctx[0].id
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, span);
      append(span, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*open*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*timestamp*/
      2)
        set_data(
          t1,
          /*timestamp*/
          ctx2[1]
        );
      if (dirty & /*$Selected, report*/
      5) {
        toggle_class(
          button,
          "active",
          /*$Selected*/
          ctx2[2] == /*report*/
          ctx2[0].id
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3E($$self, $$props, $$invalidate) {
  let $Selected;
  let { runtime } = $$props;
  let { report } = $$props;
  const { Selected } = runtime;
  component_subscribe($$self, Selected, (value) => $$invalidate(2, $Selected = value));
  let timestamp;
  onMount(() => {
    $$invalidate(1, timestamp = dayjs(report.timestamp).format("D MMM YYYY, HH:mm:ss"));
  });
  function open() {
    runtime.openReport(report.id);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
    if ("report" in $$props2)
      $$invalidate(0, report = $$props2.report);
  };
  return [report, timestamp, $Selected, Selected, open, runtime];
}
class Report extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3E, create_fragment$40, safe_not_equal, { runtime: 5, report: 0 });
  }
}
function get_each_context$H(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function create_each_block$H(ctx) {
  let report_1;
  let current;
  report_1 = new Report({
    props: {
      report: (
        /*report*/
        ctx[3]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(report_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(report_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const report_1_changes = {};
      if (dirty & /*reports*/
      2)
        report_1_changes.report = /*report*/
        ctx2[3];
      if (dirty & /*runtime*/
      1)
        report_1_changes.runtime = /*runtime*/
        ctx2[0];
      report_1.$set(report_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(report_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(report_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(report_1, detaching);
    }
  };
}
function create_fragment$3$(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*reports*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$H(get_each_context$H(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "sidebar");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*reports, runtime*/
      3) {
        each_value = ensure_array_like(
          /*reports*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$H(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$H(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$3D($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  const { store } = runtime;
  let reports = [];
  store.subscribe(async (v2) => {
    if (!v2)
      return;
    $$invalidate(1, reports = []);
    await sleep();
    $$invalidate(1, reports = v2);
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, reports];
}
let Sidebar$2 = class Sidebar extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3D, create_fragment$3$, safe_not_equal, { runtime: 0 });
  }
};
const main$r = "";
function create_fragment$3_(ctx) {
  let sidebar;
  let t2;
  let content;
  let current;
  sidebar = new Sidebar$2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  content = new Content$4({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(sidebar.$$.fragment);
      t2 = space();
      create_component(content.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sidebar, target, anchor);
      insert(target, t2, anchor);
      mount_component(content, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const sidebar_changes = {};
      if (dirty & /*runtime*/
      1)
        sidebar_changes.runtime = /*runtime*/
        ctx2[0];
      sidebar.$set(sidebar_changes);
      const content_changes = {};
      if (dirty & /*runtime*/
      1)
        content_changes.runtime = /*runtime*/
        ctx2[0];
      content.$set(content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      transition_in(content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      transition_out(content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(sidebar, detaching);
      destroy_component(content, detaching);
    }
  };
}
function instance$3C($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime];
}
let App$n = class App8 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3C, create_fragment$3_, safe_not_equal, { runtime: 0 });
  }
};
const BugReports = {
  metadata: {
    name: "Bug Reports",
    description: "View and send ArcOS bug reports",
    author: "The ArcOS Team",
    version: "2.0.0",
    icon: BugReportIcon,
    appGroup: "support"
  },
  runtime: Runtime$g,
  content: App$n,
  id: "BugReports",
  size: { w: 840, h: 600 },
  minSize: { w: 840, h: 600 },
  maxSize: { w: 840, h: 600 },
  pos: { x: 100, y: 100 },
  state: {
    minimized: false,
    maximized: false,
    headless: true,
    fullscreen: false,
    resizable: false
  },
  controls: {
    minimize: true,
    maximize: false,
    close: true
  },
  glass: true,
  singleInstance: true
};
function CalculatorAccelerators(runtime) {
  return [
    ...runtime.generateKeyboardShortcuts(),
    { key: "enter", action: () => runtime.evaluate() },
    { key: "escape", action: () => runtime.Value.set("") }
  ];
}
class CalculatorStore {
  constructor() {
    __publicField(this, "AllowedKeys", [
      "+",
      "-",
      "/",
      "*",
      "7",
      "8",
      "9",
      "**",
      "4",
      "5",
      "6",
      "%",
      "1",
      "2",
      "3",
      "%%C",
      ".",
      "0",
      "00",
      "%%E"
    ]);
    __publicField(this, "Shortcuts", ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "/", "+", "-", "*"]);
    __publicField(this, "Overrides", {
      "*": "x",
      "**": "^",
      "%": "mod"
    });
    __publicField(this, "altClasses", ["+", "-", "/", "*", "**", "%", "."]);
  }
}
let Runtime$f = class Runtime8 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "Value", Store$1(""));
    __publicField(this, "Store", new CalculatorStore());
    __publicField(this, "keys", []);
    __publicField(this, "Functions", {
      "%%C": ["C", () => this.Value.set(""), "clear"],
      "%%E": ["=", () => this.evaluate(), "process"]
    });
    process.accelerator.store.push(...CalculatorAccelerators(this));
    this.keys = this.compileKeys(this.Store.AllowedKeys, this.Store.Overrides);
  }
  eval(expr) {
    try {
      return Function(`'use strict'; return (${expr})`)();
    } catch {
      return expr;
    }
  }
  // Compile keypad keys by merging allowed keys and their overrides for the Calculator UI
  compileKeys(keys, overrides) {
    const value = [];
    for (let i2 = 0; i2 < keys.length; i2++) {
      let v2 = [null, null];
      v2[0] = overrides[keys[i2]] || keys[i2];
      v2[1] = keys[i2];
      value.push(v2);
    }
    return value;
  }
  // Calculate the calculator value and set it to itself
  evaluate() {
    const value = this.Value.get();
    if (!this.isValid(value))
      return false;
    const evaluated = this.eval(value);
    this.Value.set(evaluated);
    return value;
  }
  // Tests the current value plus the new input to evaluate if it's valid.
  isValid(input) {
    if (!input || typeof input !== "string")
      return;
    if (input.startsWith("%%"))
      return false;
    for (let i2 = 0; i2 < input.length; i2++) {
      if (this.Store.AllowedKeys.includes(input[i2]))
        continue;
      return false;
    }
    return true;
  }
  // Generate a list of keyboard shortcuts from keys to pass to the Calculator AppData.
  generateKeyboardShortcuts() {
    let result = [];
    for (const shortcut of this.Store.Shortcuts) {
      result.push({
        key: shortcut,
        action: () => this.processKey(shortcut)
      });
    }
    return result;
  }
  // Processes incoming key inputs from either the window
  // or the AppShortcuts (Calculator Events)
  processKey(key2) {
    if (!this.isValid(key2))
      return false;
    const newValue = `${this.Value.get()}${key2}0`;
    if (!this.validate(newValue)) {
      return false;
    }
    this.Value.set(this.Value.get() + key2);
  }
  validate(expr) {
    const re = /(?:(?:^|[-+_*%\/])(?:\s*-?\d+(\.\d+)?(?:[eE][+-]?\d+)?\s*))+$/;
    return re.test(expr);
  }
};
function create_fragment$3Z(ctx) {
  let button;
  let t_value = (
    /*runtime*/
    ctx[0].Functions[
      /*key*/
      ctx[1][1]
    ][0] + ""
  );
  let t2;
  let button_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "class", button_class_value = /*runtime*/
      ctx[0].Functions[
        /*key*/
        ctx[1][1]
      ][2]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*runtime*/
            ctx[0].Functions[
              /*key*/
              ctx[1][0]
            ][1]
          ))
            ctx[0].Functions[
              /*key*/
              ctx[1][0]
            ][1].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*runtime, key*/
      3 && t_value !== (t_value = /*runtime*/
      ctx[0].Functions[
        /*key*/
        ctx[1][1]
      ][0] + ""))
        set_data(t2, t_value);
      if (dirty & /*runtime, key*/
      3 && button_class_value !== (button_class_value = /*runtime*/
      ctx[0].Functions[
        /*key*/
        ctx[1][1]
      ][2])) {
        attr(button, "class", button_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3B($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { key: key2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("key" in $$props2)
      $$invalidate(1, key2 = $$props2.key);
  };
  return [runtime, key2];
}
let Function$1 = class Function2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3B, create_fragment$3Z, safe_not_equal, { runtime: 0, key: 1 });
  }
};
function create_fragment$3Y(ctx) {
  let button;
  let t_value = (
    /*key*/
    ctx[1][0] + ""
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "class", "shell-colored");
      toggle_class(button, "empty", !/*key*/
      ctx[1][0]);
      toggle_class(
        button,
        "alt",
        /*runtime*/
        ctx[0].Store.altClasses.includes(
          /*key*/
          ctx[1][1]
        )
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*key*/
      2 && t_value !== (t_value = /*key*/
      ctx2[1][0] + ""))
        set_data(t2, t_value);
      if (dirty & /*key*/
      2) {
        toggle_class(button, "empty", !/*key*/
        ctx2[1][0]);
      }
      if (dirty & /*runtime, key*/
      3) {
        toggle_class(
          button,
          "alt",
          /*runtime*/
          ctx2[0].Store.altClasses.includes(
            /*key*/
            ctx2[1][1]
          )
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3A($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { key: key2 } = $$props;
  const click_handler = () => runtime.processKey(key2[1]);
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("key" in $$props2)
      $$invalidate(1, key2 = $$props2.key);
  };
  return [runtime, key2, click_handler];
}
class Key extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3A, create_fragment$3Y, safe_not_equal, { runtime: 0, key: 1 });
  }
}
const main$q = "";
function get_each_context$G(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function create_else_block$r(ctx) {
  let function_1;
  let current;
  function_1 = new Function$1({
    props: {
      key: (
        /*key*/
        ctx[3]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(function_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(function_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const function_1_changes = {};
      if (dirty & /*runtime*/
      1)
        function_1_changes.key = /*key*/
        ctx2[3];
      if (dirty & /*runtime*/
      1)
        function_1_changes.runtime = /*runtime*/
        ctx2[0];
      function_1.$set(function_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(function_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(function_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(function_1, detaching);
    }
  };
}
function create_if_block$1z(ctx) {
  let key_1;
  let current;
  key_1 = new Key({
    props: {
      key: (
        /*key*/
        ctx[3]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(key_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(key_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const key_1_changes = {};
      if (dirty & /*runtime*/
      1)
        key_1_changes.key = /*key*/
        ctx2[3];
      if (dirty & /*runtime*/
      1)
        key_1_changes.runtime = /*runtime*/
        ctx2[0];
      key_1.$set(key_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(key_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(key_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(key_1, detaching);
    }
  };
}
function create_each_block$G(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1z, create_else_block$r];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*runtime*/
    1)
      show_if = null;
    if (show_if == null)
      show_if = !!!/*key*/
      ctx2[3][0].startsWith("%%");
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_fragment$3X(ctx) {
  let input;
  let t2;
  let div;
  let current;
  let each_value = ensure_array_like(
    /*runtime*/
    ctx[0].keys
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$G(get_each_context$G(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      input = element("input");
      t2 = space();
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(input, "type", "text");
      attr(input, "class", "display");
      input.readOnly = true;
      input.value = /*$Value*/
      ctx[1];
      attr(input, "placeholder", "0");
      attr(div, "class", "keys");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$Value*/
      2 && input.value !== /*$Value*/
      ctx2[1]) {
        input.value = /*$Value*/
        ctx2[1];
      }
      if (dirty & /*runtime*/
      1) {
        each_value = ensure_array_like(
          /*runtime*/
          ctx2[0].keys
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$G(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$G(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(input);
        detach(t2);
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$3z($$self, $$props, $$invalidate) {
  let $Value;
  let { runtime } = $$props;
  const { Value } = runtime;
  component_subscribe($$self, Value, (value) => $$invalidate(1, $Value = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, $Value, Value];
}
let App$m = class App9 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3z, create_fragment$3X, safe_not_equal, { runtime: 0 });
  }
};
const CalculatorApp = {
  metadata: {
    name: "Calculator",
    description: "ArcOS Calculator",
    version: "3.0.0",
    author: "Izaak Kuipers",
    icon: CalculatorIcon,
    appGroup: "utilities"
  },
  runtime: Runtime$f,
  content: App$m,
  id: "CalculatorApp",
  size: { w: 340, h: NaN },
  pos: { x: 60, y: 60 },
  minSize: { w: 340, h: NaN },
  maxSize: { w: 340, h: NaN },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: {
    minimize: true,
    maximize: false,
    close: true
  },
  glass: true,
  loadCondition: () => !SafeMode.get()
};
const main$p = "";
let Runtime$e = class Runtime9 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "FPS", 30);
    __publicField(this, "Buffer", Store$1());
    __publicField(this, "A", 1);
    __publicField(this, "B", 1);
    setInterval(() => {
      if (this.process._paused)
        return;
      this.Tick();
    }, 1e3 / this.FPS);
  }
  async Tick() {
    const b2 = [];
    const z2 = [];
    this.A += 0.07;
    this.B += 0.03;
    let cA = Math.cos(this.A), sA = Math.sin(this.A), cB = Math.cos(this.B), sB = Math.sin(this.B);
    for (let k2 = 0; k2 < 1760; k2++) {
      b2[k2] = k2 % 80 == 79 ? "\n" : " ";
      z2[k2] = 0;
    }
    for (let j2 = 0; j2 < 6.28; j2 += 0.07) {
      let ct2 = Math.cos(j2), st2 = Math.sin(j2);
      for (let i2 = 0; i2 < 6.28; i2 += 0.02) {
        let sp = Math.sin(i2), cp = Math.cos(i2), h2 = ct2 + 2, D2 = 1 / (sp * h2 * sA + st2 * cA + 5), t2 = sp * h2 * cA - st2 * sA;
        let x2 = 0 | 40 + 30 * D2 * (cp * h2 * cB - t2 * sB), y2 = 0 | 12 + 15 * D2 * (cp * h2 * sB + t2 * cB), o2 = x2 + 80 * y2, N2 = 0 | 8 * ((st2 * sA - sp * ct2 * cA) * cB - sp * ct2 * sA - st2 * cA - cp * ct2 * sB);
        if (y2 < 22 && y2 >= 0 && x2 >= 0 && x2 < 79 && D2 > z2[o2]) {
          z2[o2] = D2;
          b2[o2] = ".,-~:;=!*#$@"[N2 > 0 ? N2 : 0];
        }
      }
    }
    this.Buffer.set(b2.join(""));
  }
};
function create_fragment$3W(ctx) {
  let pre;
  let t2;
  return {
    c() {
      pre = element("pre");
      t2 = text(
        /*$Buffer*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append(pre, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$Buffer*/
      1)
        set_data(
          t2,
          /*$Buffer*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(pre);
      }
    }
  };
}
function instance$3y($$self, $$props, $$invalidate) {
  let $Buffer;
  let { runtime } = $$props;
  const { Buffer: Buffer2 } = runtime;
  component_subscribe($$self, Buffer2, (value) => $$invalidate(0, $Buffer = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [$Buffer, Buffer2, runtime];
}
let App$l = class App10 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3y, create_fragment$3W, safe_not_equal, { runtime: 2 });
  }
};
const DonutApp = {
  metadata: {
    name: "Donut",
    description: "A spinning ASCII donut",
    version: ArcOSVersion,
    author: "Andy Sloane (ArcOS port by IzK)",
    icon: DonutIcon,
    appGroup: "entertainment"
  },
  runtime: Runtime$e,
  content: App$l,
  id: "DonutApp",
  size: { w: 640, h: NaN },
  pos: { x: 30, y: 40 },
  minSize: { w: 640, h: 460 },
  maxSize: { w: 640, h: NaN },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: {
    minimize: true,
    maximize: false,
    close: true
  },
  glass: true,
  loadCondition: () => !SafeMode.get()
};
let Runtime$d = class Runtime10 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "selected", Store$1());
    __publicField(this, "show", Store$1(false));
  }
};
let ExitActions = {
  restart: {
    action: restart$3,
    caption: "Restart",
    icon: RestartIcon
  },
  poweroff: {
    action: shutdown,
    caption: "Power Off",
    icon: ShutdownIcon
  },
  logoff: {
    action: logout,
    caption: "Logout",
    icon: LogoutIcon
  }
};
function create_fragment$3V(ctx) {
  let div;
  let button0;
  let t0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text("Confirm");
      t1 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(button0, "class", "suggested");
      button0.disabled = !/*selected*/
      ctx[0];
      attr(div, "class", "confirm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*confirm*/
            ctx[2]
          ),
          listen(
            button1,
            "click",
            /*exit*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3x($$self, $$props, $$invalidate) {
  let $show;
  let $selected;
  let { runtime } = $$props;
  const { selected, show } = runtime;
  component_subscribe($$self, selected, (value) => $$invalidate(6, $selected = value));
  component_subscribe($$self, show, (value) => $$invalidate(5, $show = value));
  function confirm() {
    if (!ExitActions[$selected])
      return;
    ExitActions[$selected].action();
    exit();
  }
  async function exit() {
    set_store_value(show, $show = false, $show);
    await sleep(200);
    ProcessStack.kill(runtime.pid, true);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(4, runtime = $$props2.runtime);
  };
  return [selected, show, confirm, exit, runtime];
}
class Confirm2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3x, create_fragment$3V, safe_not_equal, { runtime: 4 });
  }
}
function create_fragment$3U(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<h1>Exit ArcOS</h1> <p>What&#39;s your escape route?</p>`;
      attr(div, "class", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
let Header$a = class Header3 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$3U, safe_not_equal, {});
  }
};
function get_each_context$F(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2][0];
  child_ctx[5] = list2[i2][1];
  return child_ctx;
}
function create_each_block$F(ctx) {
  let button;
  let img;
  let img_src_value;
  let t0;
  let p2;
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[3](
        /*id*/
        ctx[4]
      )
    );
  }
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      p2 = element("p");
      p2.textContent = `${/*action*/
      ctx[5].caption}`;
      t2 = space();
      if (!src_url_equal(img.src, img_src_value = /*action*/
      ctx[5].icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(img, "class", "icon");
      attr(button, "class", "option");
      toggle_class(
        button,
        "selected",
        /*$selected*/
        ctx[0] == /*id*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, p2);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$selected, Object*/
      1) {
        toggle_class(
          button,
          "selected",
          /*$selected*/
          ctx[0] == /*id*/
          ctx[4]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$3T(ctx) {
  let div;
  let each_value = ensure_array_like(Object.entries(ExitActions));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$F(get_each_context$F(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "options");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$selected, Object*/
      1) {
        each_value = ensure_array_like(Object.entries(ExitActions));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$F(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$F(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$3w($$self, $$props, $$invalidate) {
  let $selected;
  let { runtime } = $$props;
  const { selected } = runtime;
  component_subscribe($$self, selected, (value) => $$invalidate(0, $selected = value));
  const click_handler = (id) => set_store_value(selected, $selected = id, $selected);
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [$selected, selected, runtime, click_handler];
}
let Options$3 = class Options extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3w, create_fragment$3T, safe_not_equal, { runtime: 2 });
  }
};
const main$o = "";
function create_fragment$3S(ctx) {
  let div0;
  let t0;
  let div1;
  let header2;
  let t1;
  let options2;
  let t2;
  let confirm;
  let current;
  header2 = new Header$a({});
  options2 = new Options$3({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  confirm = new Confirm2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      create_component(header2.$$.fragment);
      t1 = space();
      create_component(options2.$$.fragment);
      t2 = space();
      create_component(confirm.$$.fragment);
      attr(div0, "class", "bg");
      attr(div1, "class", "content");
      toggle_class(
        div1,
        "show",
        /*$show*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      mount_component(header2, div1, null);
      append(div1, t1);
      mount_component(options2, div1, null);
      append(div1, t2);
      mount_component(confirm, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const options_changes = {};
      if (dirty & /*runtime*/
      1)
        options_changes.runtime = /*runtime*/
        ctx2[0];
      options2.$set(options_changes);
      const confirm_changes = {};
      if (dirty & /*runtime*/
      1)
        confirm_changes.runtime = /*runtime*/
        ctx2[0];
      confirm.$set(confirm_changes);
      if (!current || dirty & /*$show*/
      2) {
        toggle_class(
          div1,
          "show",
          /*$show*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(options2.$$.fragment, local);
      transition_in(confirm.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(options2.$$.fragment, local);
      transition_out(confirm.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div1);
      }
      destroy_component(header2);
      destroy_component(options2);
      destroy_component(confirm);
    }
  };
}
function instance$3v($$self, $$props, $$invalidate) {
  let $show;
  let $selected;
  let { runtime } = $$props;
  const { show, selected } = runtime;
  component_subscribe($$self, show, (value) => $$invalidate(1, $show = value));
  component_subscribe($$self, selected, (value) => $$invalidate(4, $selected = value));
  onMount(async () => {
    const args = runtime.process.args;
    const ids = Object.keys(ExitActions);
    if (typeof args[0] == "string" && ids.includes(args[0])) {
      set_store_value(selected, $selected = args[0], $selected);
    }
    await sleep(200);
    set_store_value(show, $show = true, $show);
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, $show, show, selected];
}
let App$k = class App11 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3v, create_fragment$3S, safe_not_equal, { runtime: 0 });
  }
};
const ExitApp = {
  metadata: {
    name: "Exit",
    description: "The Exit menu",
    author: "The ArcOS Team",
    version: "2.0.0",
    icon: ShutdownIcon,
    hidden: true,
    appGroup: "internal"
  },
  runtime: Runtime$d,
  content: App$k,
  id: "ExitApp",
  size: { w: NaN, h: NaN },
  minSize: { w: NaN, h: NaN },
  maxSize: { w: NaN, h: NaN },
  pos: { x: 0, y: 0 },
  state: {
    minimized: false,
    maximized: false,
    headless: true,
    fullscreen: true,
    resizable: false
  },
  controls: {
    minimize: false,
    maximize: false,
    close: false
  },
  singleInstance: true,
  loadCondition: () => appLibrary.get().has("ArcShell")
};
function MultiUploadProgress(length, target) {
  return {
    type: "quantity",
    icon: FileManagerIcon,
    caption: `Moving ${length} files to ${target}`,
    subtitle: "Starting...",
    done: 0,
    max: length,
    waiting: false,
    working: false,
    errors: 0
  };
}
async function copyItem(source, destination) {
  Log(`server/fs/copy`, `Copying ${source} to ${destination}`);
  const sourceBase64 = toBase64(source);
  const targetBase64 = toBase64(destination);
  if (sourceBase64 == source || targetBase64 == destination)
    return false;
  const url = getServerUrl(Endpoints.FsCp, { path: sourceBase64, target: targetBase64 });
  const token = UserToken.get();
  if (!url || !token)
    return false;
  try {
    const response = await axios$1.get(url, makeTokenOptions(token));
    return response.status === 200;
  } catch {
    return false;
  }
}
async function renameItem(oldPath, newPath) {
  Log(`server/fs/copy`, `Renaming ${oldPath} to ${newPath}`);
  const oldBase64 = toBase64(oldPath);
  const newBase64 = toBase64(newPath);
  if (oldBase64 == oldPath || newBase64 == newPath)
    return false;
  const url = getServerUrl(Endpoints.FsRename, {
    oldpath: oldBase64,
    newpath: newBase64
  });
  const token = UserToken.get();
  if (!url || !token)
    return false;
  try {
    const response = await axios$1.get(url, makeTokenOptions(token));
    return response.status === 200;
  } catch {
    return false;
  }
}
async function renameMultipleProgressy(items, pid, noShade = false) {
  const values = Object.values(items);
  if (!values.length)
    return;
  const length = values.length;
  const target = pathToFriendlyName(values[0]);
  const { mutDone, updSub, setWork, mutErr, setWait } = await FileProgress(
    MultiUploadProgress(length, target),
    pid,
    noShade
  );
  for (const source in items) {
    const friendly = pathToFriendlyPath(source);
    const dest = items[source];
    updSub(friendly);
    setWork(true);
    setWait(false);
    const renamed = await renameItem(source, dest);
    if (!renamed)
      mutErr(1);
    mutDone(1);
    setWait(true);
    setWork(false);
    await sleep(55);
  }
}
async function copyMultipleProgressy(items, pid, noShade = true) {
  const values = Object.values(items);
  if (!values.length)
    return;
  const length = values.length;
  const target = pathToFriendlyName(values[0]);
  const { mutDone, updSub, setWork, mutErr, setWait } = await FileProgress(
    {
      type: "quantity",
      icon: FileManagerIcon,
      caption: `Copying ${length} files to ${target}`,
      subtitle: "Starting...",
      done: 0,
      max: length,
      waiting: false,
      working: false,
      errors: 0
    },
    pid,
    noShade
  );
  for (const source in items) {
    const friendly = pathToFriendlyPath(source);
    const dest = items[source];
    updSub(friendly);
    setWork(true);
    setWait(false);
    const copied = await copyItem(source, dest);
    if (!copied)
      mutErr(1);
    mutDone(1);
    setWait(true);
    setWork(false);
    await sleep(55);
  }
}
async function deleteMultipleProgressy(paths, pid, noShade = false) {
  Log("server/fs/delete", `Deleting ${paths.length} items`);
  const { mutDone, updSub, setWork, setWait, mutErr } = await FileProgress(
    {
      type: "quantity",
      icon: TrashIcon,
      caption: `Permanently deleting ${paths.length} items`,
      subtitle: "Starting...",
      done: 0,
      max: paths.length,
      working: false,
      waiting: false,
      errors: 0
    },
    pid,
    noShade
  );
  for (const path of paths) {
    const friendly = pathToFriendlyPath(path);
    setWait(false);
    setWork(true);
    updSub(friendly);
    const deleted = await deleteItem(path, false);
    if (!deleted)
      mutErr(1);
    setWork(false);
    setWait(true);
    mutDone(1);
    await sleep(55);
  }
  mutDone(1);
  GlobalDispatch.dispatch("fs-flush");
}
function FileManagerAccelerators(runtime) {
  return [
    {
      ctrl: true,
      key: "a",
      action() {
        if (runtime.renamer.get())
          return;
        runtime.selectAll();
      }
    },
    {
      key: "escape",
      action() {
        const renamer = runtime.renamer.get();
        if (!renamer)
          return runtime.selected.set([]);
        runtime.renamer.set("");
      }
    },
    {
      alt: true,
      key: "arrowup",
      action() {
        runtime.parentDir();
      }
    },
    {
      key: "delete",
      action() {
        if (runtime.renamer.get())
          return;
        runtime.deleteSelected();
      }
    },
    {
      key: "r",
      alt: true,
      action() {
        runtime.refresh();
      }
    },
    {
      key: "f2",
      action() {
        if (runtime.renamer.get())
          return;
        const selected = runtime.selected.get();
        if (selected.length !== 1)
          return;
        runtime.renamer.set(selected[0]);
      }
    },
    {
      key: "arrowdown",
      action() {
        if (runtime.renamer.get())
          return;
        runtime.selectorDown();
      }
    },
    {
      key: "arrowup",
      action() {
        if (runtime.renamer.get())
          return;
        runtime.selectorUp();
      }
    },
    {
      key: "enter",
      shift: true,
      action() {
        if (runtime.renamer.get())
          return;
        runtime.EnterKey(true);
      }
    },
    {
      key: "enter",
      action() {
        if (runtime.renamer.get())
          return;
        runtime.EnterKey();
      }
    }
  ];
}
function EditMenu$1(runtime) {
  return {
    caption: "Edit",
    subItems: [
      {
        caption: "New Folder",
        icon: "create_new_folder",
        action() {
          runtime.newFolder.set(true);
        }
      },
      SEP_ITEM,
      {
        caption: "Cut",
        icon: "content_cut",
        disabled: () => !runtime.selected.get().length,
        async action() {
          runtime.setCutFiles();
        }
      },
      {
        caption: "Copy",
        icon: "content_copy",
        disabled: () => !runtime.selected.get().length,
        async action() {
          runtime.setCopyFiles();
        }
      },
      {
        caption: "Paste",
        icon: "content_paste",
        disabled: () => !runtime.copyList.get().length && !runtime.cutList.get().length,
        async action() {
          await runtime.pasteFiles();
        }
      },
      SEP_ITEM,
      {
        caption: "Delete",
        image: TrashIcon,
        disabled: () => !runtime.selected.get().length,
        async action() {
          await runtime.deleteSelected();
        }
      },
      {
        caption: "Rename",
        icon: "mode_edit",
        disabled: () => runtime.selected.get().length !== 1,
        async action() {
          runtime.renamer.set(runtime.selected.get()[0]);
        }
      },
      SEP_ITEM,
      {
        caption: "Select All",
        icon: "select_all",
        action() {
          runtime.selectAll();
        }
      }
    ]
  };
}
function FileMenu$3(runtime) {
  return {
    caption: "File",
    subItems: [
      {
        caption: "New Window",
        icon: "add",
        action() {
          spawnApp("FileManager", 0, [runtime.path.get()]);
        }
      },
      {
        caption: "Refresh",
        icon: "refresh",
        async action() {
          await runtime.refresh();
        }
      },
      SEP_ITEM,
      {
        caption: "Upload...",
        icon: "upload",
        async action() {
          directUploadProgressy(runtime.path.get(), true, runtime.pid);
        }
      },
      {
        caption: "Download",
        icon: "download",
        disabled: () => runtime.selected.get().length !== 1,
        async action() {
          const file = await readFile(runtime.selected.get()[0]);
          DownloadFile(file);
        }
      },
      SEP_ITEM,
      {
        caption: "Exit",
        image: ShutdownIcon,
        action() {
          runtime.closeApp();
        }
      }
    ]
  };
}
const SystemFolders = [
  {
    name: "Home",
    path: "./",
    icon: HomeIcon
  },
  {
    name: "Documents",
    path: "./Documents",
    icon: DocumentsFolderIcon
  },
  {
    name: "Pictures",
    path: "./Pictures",
    icon: WallpapersFolderIcon
  },
  {
    name: "Scripts",
    path: "./Scripts",
    icon: ArcTermFolderIcon
  },
  {
    name: "Themes",
    path: "./Themes",
    icon: ThemeFolderIcon
  },
  {
    name: "Wallpapers",
    path: "./Wallpapers",
    icon: FolderIcon
  }
];
function FileManagerDispatches(runtime) {
  return {
    refresh: () => runtime.refresh(),
    "new-folder": () => runtime.newFolder.set(true),
    "change-dir": (data2) => {
      if (typeof data2 === "string")
        runtime.navigate(data2);
    },
    "context-copy": (data2) => runtime.setCopyFiles(data2 ? [data2] : null),
    "context-cut": (data2) => runtime.setCutFiles(data2 ? [data2] : null),
    "context-paste": () => runtime.pasteFiles(),
    "context-delete": async (data2) => {
      runtime.selected.set([data2]);
      await runtime.deleteSelected();
    },
    "context-rename": (data2) => runtime.renamer.set(data2)
  };
}
function GetSystemFolderIcon(path) {
  path = `./${pathToFriendlyPath(path)}`;
  const folders = SystemFolders.filter((a2) => a2.path == path);
  if (!folders.length)
    return FolderIcon;
  return folders[0].icon;
}
function GoMenu(runtime) {
  const folderItems = [];
  for (const folder of SystemFolders) {
    folderItems.push({
      caption: folder.name,
      image: folder.icon,
      async action() {
        await runtime.navigate(folder.path);
      }
    });
  }
  return {
    caption: "Go",
    subItems: [
      {
        caption: "Parent Folder",
        icon: "arrow_upward",
        async action() {
          await runtime.parentDir();
        }
      },
      SEP_ITEM,
      ...folderItems
    ]
  };
}
function ViewMenu$1() {
  return {
    caption: "View",
    subItems: [
      {
        caption: "List",
        icon: "format_list_bulleted",
        isActive: () => !UserDataStore.get().appdata.FileManager.grid,
        action() {
          UserDataStore.update((v2) => {
            v2.appdata.FileManager.grid = false;
            return v2;
          });
        }
      },
      {
        caption: "Grid",
        icon: "grid_on",
        isActive: () => UserDataStore.get().appdata.FileManager.grid,
        action() {
          UserDataStore.update((v2) => {
            v2.appdata.FileManager.grid = true;
            return v2;
          });
        }
      }
    ]
  };
}
function FileManagerAltMenu(runtime) {
  return [FileMenu$3(runtime), EditMenu$1(runtime), ViewMenu$1(), GoMenu(runtime)];
}
let Runtime$c = class Runtime11 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "path", Store$1());
    __publicField(this, "renamer", Store$1(""));
    __publicField(this, "contents", Store$1());
    __publicField(this, "selected", Store$1([]));
    __publicField(this, "cutList", Store$1([]));
    __publicField(this, "copyList", Store$1([]));
    __publicField(this, "loading", Store$1(true));
    __publicField(this, "failed", Store$1(false));
    __publicField(this, "newFolder", Store$1(false));
    __publicField(this, "starting", Store$1(true));
    __publicField(this, "quota", Store$1(defaultQuota));
    __publicField(this, "_refreshLocked", false);
    this._init();
  }
  async _init() {
    const args = this.process.args;
    const path = args[0] && typeof args[0] == "string" ? args[0] : "./";
    const selection = args[1] && typeof args[1] == "string" ? [args[1].replace("./", "")] : [];
    this.process.accelerator.store.push(...FileManagerAccelerators(this));
    await this.createSystemFolders();
    await this.navigate(path);
    this.quota.set(await getFSQuota());
    this.loadAltMenu(...FileManagerAltMenu(this));
    this.assignDispatchers();
    this.selected.set(selection);
    this.starting.set(false);
  }
  async navigate(path) {
    const cwd = this.path.get();
    if (cwd == path)
      return;
    this.path.set(path);
    await this.refresh();
    await this.checkNewfileRemains();
    this.setWindowTitle(pathToFriendlyName(path), false);
  }
  async refresh() {
    if (this._refreshLocked)
      return;
    this.contents.set(void 0);
    this.loading.set(true);
    this.failed.set(false);
    const contents = await readDirectory(this.path.get());
    this.loading.set(false);
    if (!contents) {
      this.FileNotFound();
      return false;
    }
    this.contents.set(contents);
    this.selected.set([]);
    return true;
  }
  async parentDir() {
    const current = this.path.get();
    const parent = getParentDirectory(current);
    if (parent == current || this.loading.get())
      return;
    return await this.navigate(parent);
  }
  updateSelection(e2, path) {
    if (!e2.shiftKey)
      return this.selected.set([path]);
    const selected = this.selected.get();
    if (selected.includes(path))
      selected.splice(selected.indexOf(path), 1);
    else
      selected.push(path);
    this.selected.set(selected);
    return;
  }
  FileNotFound(path = this.path.get()) {
    this.failed.set(true);
    createErrorDialog(
      {
        title: "Location not found",
        message: `Folder <code>${path}</code> does not exist on ArcFS.`,
        image: ErrorIcon,
        buttons: [
          {
            caption: "Go Home",
            action: () => {
              this.navigate("./");
            },
            suggested: true
          }
        ]
      },
      this.pid,
      true
    );
  }
  selectAll() {
    const contents = this.contents.get();
    if (!contents)
      return;
    this.selected.set([
      ...contents.files.map((f2) => f2.scopedPath),
      ...contents.directories.map((d3) => d3.scopedPath)
    ]);
  }
  lockRefresh() {
    this._refreshLocked = true;
  }
  unlockRefresh(refresh = true) {
    this._refreshLocked = false;
    if (refresh)
      this.refresh();
  }
  async deleteSelected() {
    const selected = this.selected.get();
    if (!selected.length)
      return;
    const title = selected.length > 1 ? `Delete ${selected.length} ${Plural("item", selected.length)}?` : `Delete ${pathToFriendlyName(selected[0])}?`;
    const proceed = await GetConfirmation(
      {
        title,
        message: `Are you sure you want to <b>permanently</b> delete the selected ${Plural(
          "item",
          selected.length
        )} from your account? There's no going back!`,
        image: TrashIcon
      },
      this.pid,
      true
    );
    if (!proceed)
      return;
    this.lockRefresh();
    await deleteMultipleProgressy(selected, this.pid);
    this.unlockRefresh();
  }
  async dropFiles(e2) {
    e2.preventDefault();
    this.lockRefresh();
    const target = this.path.get();
    await multipleFileUploadProgressy(e2.dataTransfer.files, target, this.pid);
    this.unlockRefresh();
  }
  assignDispatchers() {
    GlobalDispatch.subscribe("fs-flush", async () => {
      this.quota.set(await getFSQuota());
      this.refresh();
    });
    const dispatchers = FileManagerDispatches(this);
    for (const event in dispatchers) {
      const dispatcher = dispatchers[event];
      this.process.handler.dispatch.subscribe(this.pid, event, dispatcher);
    }
  }
  async createSystemFolders() {
    const contents = await readDirectory("./");
    this.lockRefresh();
    const rootDirs = contents.directories.map((a2) => `./${a2.scopedPath}`);
    for (const { path } of SystemFolders) {
      if (rootDirs.includes(path) || path == "./")
        continue;
      await createDirectory(path);
    }
    this.unlockRefresh(false);
  }
  setCopyFiles(files = this.selected.get()) {
    this.copyList.set(files);
    this.cutList.set([]);
  }
  setCutFiles(files = this.selected.get()) {
    this.cutList.set(files);
    this.copyList.set([]);
  }
  async pasteFiles(target = this.path.get()) {
    const copyList = this.copyList.get();
    const cutList = this.cutList.get();
    const copyObj = {};
    const cutObj = {};
    if (!copyList.length && !cutList.length)
      return;
    this.lockRefresh();
    for (const path of copyList) {
      copyObj[path] = target;
    }
    for (const path of cutList) {
      cutObj[path] = target;
    }
    await renameMultipleProgressy(cutObj, this.pid);
    await copyMultipleProgressy(copyObj, this.pid);
    this.copyList.set([]);
    this.cutList.set([]);
    this.unlockRefresh();
  }
  singlefySelected() {
    const selected = this.selected.get();
    if (!selected.length)
      return;
    this.selected.set([selected[selected.length - 1]]);
  }
  selectorUp() {
    this.singlefySelected();
    const selected = this.selected.get()[0];
    const dir = this.contents.get();
    const paths = [
      ...dir.directories.map((a2) => a2.scopedPath),
      ...dir.files.map((a2) => a2.scopedPath)
    ];
    const index = paths.indexOf(selected);
    if (!selected)
      this.selected.set([paths[0]]);
    this.selected.set([paths[index < 0 || index - 1 < 0 ? paths.length - 1 : index - 1]]);
  }
  selectorDown() {
    this.singlefySelected();
    const selected = this.selected.get()[0];
    const dir = this.contents.get();
    const paths = [
      ...dir.directories.map((a2) => a2.scopedPath),
      ...dir.files.map((a2) => a2.scopedPath)
    ];
    const index = paths.indexOf(selected);
    if (!selected)
      this.selected.set([paths[0]]);
    this.selected.set([paths[index < 0 || index + 1 > paths.length - 1 ? 0 : index + 1]]);
  }
  isDirectory(path) {
    const dir = this.contents.get();
    return dir.directories.map((a2) => a2.scopedPath).includes(path);
  }
  getFile(path) {
    if (this.isDirectory(path))
      return null;
    return this.contents.get().files.filter((a2) => a2.scopedPath == path)[0];
  }
  async EnterKey(alternative = false) {
    this.singlefySelected();
    const selected = this.selected.get()[0];
    if (!selected)
      return;
    const isDir = this.isDirectory(selected);
    if (isDir) {
      if (!alternative)
        await this.navigate(selected);
      else
        spawnApp("FileManager", 0, [selected]);
      return;
    }
    const file = this.getFile(selected);
    if (!file)
      return;
    if (alternative)
      OpenWith(file, this.pid, true);
    else
      await OpenFile(file);
  }
  async checkNewfileRemains() {
    const contents = this.contents.get();
    if (!contents)
      return;
    const files = contents.files.filter((a2) => a2.filename.includes("$new"));
    const renamer = this.renamer.get();
    let deletedAnything = false;
    for (const file of files) {
      if (renamer == file.scopedPath)
        continue;
      deletedAnything = await deleteItem(file.scopedPath, false);
    }
    if (deletedAnything) {
      await this.refresh();
      GlobalDispatch.dispatch("fs-flush");
    }
  }
};
function create_fragment$3R(ctx) {
  let div;
  let button0;
  let t0;
  let button0_disabled_value;
  let t1;
  let button1;
  let t2;
  let button1_disabled_value;
  let t3;
  let button2;
  let t4;
  let button2_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text("content_cut");
      t1 = space();
      button1 = element("button");
      t2 = text("content_copy");
      t3 = space();
      button2 = element("button");
      t4 = text("content_paste");
      attr(button0, "class", "material-icons-round");
      button0.disabled = button0_disabled_value = !/*$selected*/
      ctx[0].length;
      attr(button0, "title", "Cut items");
      toggle_class(
        button0,
        "suggested",
        /*$cutList*/
        ctx[1].length
      );
      attr(button1, "class", "material-icons-round");
      button1.disabled = button1_disabled_value = !/*$selected*/
      ctx[0].length;
      attr(button1, "title", "Copy items");
      toggle_class(
        button1,
        "suggested",
        /*$copyList*/
        ctx[2].length
      );
      attr(button2, "class", "material-icons-round");
      button2.disabled = button2_disabled_value = !/*$copyList*/
      ctx[2].length && !/*$cutList*/
      ctx[1].length;
      attr(button2, "title", "Paste items");
      attr(div, "class", "portion copy-paste");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      append(div, t3);
      append(div, button2);
      append(button2, t4);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*cut*/
            ctx[6]
          ),
          listen(
            button1,
            "click",
            /*copy*/
            ctx[7]
          ),
          listen(
            button2,
            "click",
            /*paste*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$selected*/
      1 && button0_disabled_value !== (button0_disabled_value = !/*$selected*/
      ctx2[0].length)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*$cutList*/
      2) {
        toggle_class(
          button0,
          "suggested",
          /*$cutList*/
          ctx2[1].length
        );
      }
      if (dirty & /*$selected*/
      1 && button1_disabled_value !== (button1_disabled_value = !/*$selected*/
      ctx2[0].length)) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*$copyList*/
      4) {
        toggle_class(
          button1,
          "suggested",
          /*$copyList*/
          ctx2[2].length
        );
      }
      if (dirty & /*$copyList, $cutList*/
      6 && button2_disabled_value !== (button2_disabled_value = !/*$copyList*/
      ctx2[2].length && !/*$cutList*/
      ctx2[1].length)) {
        button2.disabled = button2_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3u($$self, $$props, $$invalidate) {
  let $selected;
  let $cutList;
  let $copyList;
  let { runtime } = $$props;
  const { copyList, cutList, selected } = runtime;
  component_subscribe($$self, copyList, (value) => $$invalidate(2, $copyList = value));
  component_subscribe($$self, cutList, (value) => $$invalidate(1, $cutList = value));
  component_subscribe($$self, selected, (value) => $$invalidate(0, $selected = value));
  function cut() {
    runtime.setCutFiles();
  }
  function copy() {
    runtime.setCopyFiles();
  }
  function paste() {
    runtime.pasteFiles();
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(9, runtime = $$props2.runtime);
  };
  return [
    $selected,
    $cutList,
    $copyList,
    copyList,
    cutList,
    selected,
    cut,
    copy,
    paste,
    runtime
  ];
}
class CopyPaste extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3u, create_fragment$3R, safe_not_equal, { runtime: 9 });
  }
}
function create_fragment$3Q(ctx) {
  let div;
  let button0;
  let t1;
  let button1;
  let t2;
  let button1_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.textContent = "upload";
      t1 = space();
      button1 = element("button");
      t2 = text("download");
      attr(button0, "class", "material-icons-round");
      attr(button1, "class", "material-icons-round");
      button1.disabled = button1_disabled_value = /*$selected*/
      ctx[0].length !== 1;
      attr(div, "class", "portion");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*upload*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*download*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$selected*/
      1 && button1_disabled_value !== (button1_disabled_value = /*$selected*/
      ctx2[0].length !== 1)) {
        button1.disabled = button1_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3t($$self, $$props, $$invalidate) {
  let $path;
  let $selected;
  let { runtime } = $$props;
  const { selected, path } = runtime;
  component_subscribe($$self, selected, (value) => $$invalidate(0, $selected = value));
  component_subscribe($$self, path, (value) => $$invalidate(6, $path = value));
  async function download() {
    const file = await readFile($selected[0]);
    DownloadFile(file);
  }
  async function upload() {
    directUploadProgressy($path, true, runtime.pid);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
  };
  return [$selected, selected, path, download, upload, runtime];
}
class UpDownload extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3t, create_fragment$3Q, safe_not_equal, { runtime: 5 });
  }
}
function create_fragment$3P(ctx) {
  let div6;
  let div1;
  let button0;
  let t1;
  let div0;
  let t2_value = pathToFriendlyPath(
    /*$path*/
    ctx[1]
  ) + "";
  let t2;
  let t3;
  let div2;
  let t4;
  let copypaste;
  let t5;
  let div3;
  let t6;
  let div4;
  let button1;
  let t8;
  let div5;
  let t9;
  let updownload;
  let current;
  let mounted;
  let dispose;
  copypaste = new CopyPaste({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  updownload = new UpDownload({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div6 = element("div");
      div1 = element("div");
      button0 = element("button");
      button0.textContent = "arrow_upward";
      t1 = space();
      div0 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      t4 = space();
      create_component(copypaste.$$.fragment);
      t5 = space();
      div3 = element("div");
      t6 = space();
      div4 = element("div");
      button1 = element("button");
      button1.textContent = "create_new_folder";
      t8 = space();
      div5 = element("div");
      t9 = space();
      create_component(updownload.$$.fragment);
      attr(button0, "class", "material-icons-round parent");
      attr(div0, "class", "path");
      attr(div1, "class", "portion address");
      attr(div2, "class", "sep");
      attr(div3, "class", "sep");
      attr(button1, "class", "material-icons-round");
      toggle_class(
        button1,
        "suggested",
        /*$newFolder*/
        ctx[2]
      );
      attr(div4, "class", "portion");
      attr(div5, "class", "sep");
      attr(div6, "class", "address-bar");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div1);
      append(div1, button0);
      append(div1, t1);
      append(div1, div0);
      append(div0, t2);
      append(div6, t3);
      append(div6, div2);
      append(div6, t4);
      mount_component(copypaste, div6, null);
      append(div6, t5);
      append(div6, div3);
      append(div6, t6);
      append(div6, div4);
      append(div4, button1);
      append(div6, t8);
      append(div6, div5);
      append(div6, t9);
      mount_component(updownload, div6, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[5]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*$path*/
      2) && t2_value !== (t2_value = pathToFriendlyPath(
        /*$path*/
        ctx2[1]
      ) + ""))
        set_data(t2, t2_value);
      const copypaste_changes = {};
      if (dirty & /*runtime*/
      1)
        copypaste_changes.runtime = /*runtime*/
        ctx2[0];
      copypaste.$set(copypaste_changes);
      if (!current || dirty & /*$newFolder*/
      4) {
        toggle_class(
          button1,
          "suggested",
          /*$newFolder*/
          ctx2[2]
        );
      }
      const updownload_changes = {};
      if (dirty & /*runtime*/
      1)
        updownload_changes.runtime = /*runtime*/
        ctx2[0];
      updownload.$set(updownload_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(copypaste.$$.fragment, local);
      transition_in(updownload.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(copypaste.$$.fragment, local);
      transition_out(updownload.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      destroy_component(copypaste);
      destroy_component(updownload);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3s($$self, $$props, $$invalidate) {
  let $path;
  let $newFolder;
  let { runtime } = $$props;
  const { path, newFolder } = runtime;
  component_subscribe($$self, path, (value) => $$invalidate(1, $path = value));
  component_subscribe($$self, newFolder, (value) => $$invalidate(2, $newFolder = value));
  const click_handler = () => runtime.parentDir();
  const click_handler_1 = () => set_store_value(newFolder, $newFolder = true, $newFolder);
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, $path, $newFolder, path, newFolder, click_handler, click_handler_1];
}
class AddressBar extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3s, create_fragment$3P, safe_not_equal, { runtime: 0 });
  }
}
function create_fragment$3O(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<img src="${UploadIcon}" alt=""/> <p>Drop files here to upload!</p>`;
      attr(div, "class", "file-dropper");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
class Dropper extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$3O, safe_not_equal, {});
  }
}
function create_fragment$3N(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<img src="${ErrorIcon}" alt=""/>
  Folder not found!`;
      attr(div, "class", "center-flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
let Failed$1 = class Failed extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$3N, safe_not_equal, {});
  }
};
const RelativeTimeMod = {
  relativeTime: {
    future: "in %s",
    past: "%s ago",
    s: "1 sec",
    m: "1 min",
    mm: "%d min",
    h: "an hr",
    hh: "%d hrs",
    d: "1 day",
    dd: "%d days",
    M: "1 month",
    MM: "%d months",
    y: "1 yr",
    yy: "%d yrs"
  }
};
var relativeTime$1 = { exports: {} };
(function(module, exports) {
  !function(r2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    return function(r2, e2, t2) {
      r2 = r2 || {};
      var n2 = e2.prototype, o2 = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function i2(r3, e3, t3, o3) {
        return n2.fromToBase(r3, e3, t3, o3);
      }
      t2.en.relativeTime = o2, n2.fromToBase = function(e3, n3, i3, d4, u3) {
        for (var f2, a2, s2, l2 = i3.$locale().relativeTime || o2, h2 = r2.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], m3 = h2.length, c2 = 0; c2 < m3; c2 += 1) {
          var y2 = h2[c2];
          y2.d && (f2 = d4 ? t2(e3).diff(i3, y2.d, true) : i3.diff(e3, y2.d, true));
          var p2 = (r2.rounding || Math.round)(Math.abs(f2));
          if (s2 = f2 > 0, p2 <= y2.r || !y2.r) {
            p2 <= 1 && c2 > 0 && (y2 = h2[c2 - 1]);
            var v2 = l2[y2.l];
            u3 && (p2 = u3("" + p2)), a2 = "string" == typeof v2 ? v2.replace("%d", p2) : v2(p2, n3, y2.l, s2);
            break;
          }
        }
        if (n3)
          return a2;
        var M2 = s2 ? l2.future : l2.past;
        return "function" == typeof M2 ? M2(a2) : M2.replace("%s", a2);
      }, n2.to = function(r3, e3) {
        return i2(r3, e3, this, true);
      }, n2.from = function(r3, e3) {
        return i2(r3, e3, this);
      };
      var d3 = function(r3) {
        return r3.$u ? t2.utc() : t2();
      };
      n2.toNow = function(r3) {
        return this.to(d3(this), r3);
      }, n2.fromNow = function(r3) {
        return this.from(d3(this), r3);
      };
    };
  });
})(relativeTime$1);
var relativeTimeExports = relativeTime$1.exports;
const relativeTime = /* @__PURE__ */ getDefaultExportFromCjs(relativeTimeExports);
var updateLocale$1 = { exports: {} };
(function(module, exports) {
  !function(e2, n2) {
    module.exports = n2();
  }(commonjsGlobal, function() {
    return function(e2, n2, t2) {
      t2.updateLocale = function(e3, n3) {
        var o2 = t2.Ls[e3];
        if (o2)
          return (n3 ? Object.keys(n3) : []).forEach(function(e4) {
            o2[e4] = n3[e4];
          }), o2;
      };
    };
  });
})(updateLocale$1);
var updateLocaleExports = updateLocale$1.exports;
const updateLocale = /* @__PURE__ */ getDefaultExportFromCjs(updateLocaleExports);
var humanFiletypes = {};
var mime = {};
var data = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mimeData = exports.FileKind = void 0;
  var FileKind;
  (function(FileKind2) {
    FileKind2["Image"] = "image";
    FileKind2["Video"] = "video";
    FileKind2["Audio"] = "audio";
    FileKind2["Archive"] = "archive";
    FileKind2["Document"] = "document";
    FileKind2["Spreadsheet"] = "spreadsheet";
    FileKind2["Presentation"] = "presentation";
    FileKind2["Font"] = "font";
    FileKind2["Text"] = "text";
    FileKind2["Application"] = "application";
    FileKind2["Unknown"] = "unknown";
  })(FileKind = exports.FileKind || (exports.FileKind = {}));
  exports.mimeData = {
    "audio/aac": { extensions: [".aac"], label: "AAC audio", kind: FileKind.Audio },
    "application/x-abiword": {
      extensions: [".abw"],
      label: "AbiWord document",
      kind: FileKind.Document
    },
    "application/x-freearc": {
      extensions: [".arc"],
      label: "Archive document (multiple files embedded)",
      kind: FileKind.Archive
    },
    "video/x-msvideo": { extensions: [".avi"], label: "AVI: Audio Video Interleave", kind: FileKind.Video },
    "application/vnd.amazon.ebook": {
      extensions: [".azw"],
      label: "Amazon Kindle eBook format	application/vnd.amazon.ebook",
      kind: FileKind.Document
    },
    "application/octet-stream": {
      extensions: [".bin", ".exe", ".dll", ".so", ".dmg"],
      label: "Any kind of binary data",
      kind: FileKind.Application
    },
    "image/bmp": { extensions: [".bmp"], label: "Bitmap Graphics", kind: FileKind.Image },
    "application/x-bzip": { extensions: [".bz"], label: "BZip archive", kind: FileKind.Archive },
    "application/x-bzip2": { extensions: [".bz2"], label: "BZip2 archive", kind: FileKind.Archive },
    "application/x-cdf": { extensions: [".cda"], label: "CD audio", kind: FileKind.Audio },
    "application/x-csh": { extensions: [".csh"], label: "C-Shell script", kind: FileKind.Text },
    "text/css": { extensions: [".css"], label: "Cascading Style Sheets (CSS)", kind: FileKind.Text },
    "text/csv": {
      extensions: [".csv"],
      label: "Comma/column-separated values",
      kind: FileKind.Spreadsheet
    },
    "text/tsv": {
      extensions: [".tsv"],
      label: "Tab-separated values",
      kind: FileKind.Spreadsheet
    },
    "application/msword": { extensions: [".doc"], label: "Microsoft Word", kind: FileKind.Document },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      extensions: [".docx"],
      label: "Microsoft Word (OpenXML)",
      kind: FileKind.Document
    },
    "application/vnd.ms-fontobject": {
      extensions: [".eot"],
      label: "MS Embedded OpenType fonts",
      kind: FileKind.Font
    },
    "application/epub+zip": {
      extensions: [".epub"],
      label: "Electronic publication (EPUB)",
      kind: FileKind.Document
    },
    "application/gzip": { extensions: [".gz", ".gzip"], label: "GZip Compressed Archive", kind: FileKind.Archive },
    "image/gif": { extensions: [".gif"], label: "Graphics Interchange Format (GIF)", kind: FileKind.Image },
    "application/html": {
      extensions: [".htm", ".html"],
      label: ".html	HyperText Markup Language (HTML)",
      kind: FileKind.Text
    },
    "image/vnd.microsoft.icon": {
      extensions: [".ico"],
      label: "Icon format	image/vnd.microsoft.icon",
      kind: FileKind.Image
    },
    "text/calendar": { extensions: [".ics"], label: "iCalendar format", kind: FileKind.Text },
    "application/java-archive": {
      extensions: [".jar"],
      label: "Java Archive (JAR)	application/java-archive",
      kind: FileKind.Application
    },
    "image/jpeg": { extensions: [".jpeg", ".jpg"], label: "JPEG image", kind: FileKind.Image },
    "text/javascript": {
      extensions: [".js", ".mjs", ".jsx", ".ts", ".tsx"],
      label: "JavaScript",
      kind: FileKind.Text
    },
    "application/json": { extensions: [".json"], label: "JSON", kind: FileKind.Text },
    "application/ld+json": { extensions: [".jsonld"], label: "JSON-LD format	application/ld+json", kind: FileKind.Text },
    "audio/midi": {
      extensions: [".mid", ".midi"],
      label: ".midi	Musical Instrument Digital Interface (MIDI)",
      kind: FileKind.Audio
    },
    "audio/x-midi": {
      extensions: [".mid", ".midi"],
      label: ".midi	Musical Instrument Digital Interface (MIDI)",
      kind: FileKind.Audio
    },
    "audio/mpeg": { extensions: [".mp3"], label: "MP3 audio", kind: FileKind.Audio },
    "video/mp4": { extensions: [".mp4"], label: "MP4 video", kind: FileKind.Video },
    "video/mpeg": { extensions: [".mpeg"], label: "MPEG Video", kind: FileKind.Video },
    "application/vnd.apple.installer+xml": {
      extensions: [".mpkg"],
      label: "Apple Installer Package",
      kind: FileKind.Application
    },
    "application/vnd.oasis.opendocument.presentation": {
      extensions: [".odp"],
      label: "OpenDocument presentation document",
      kind: FileKind.Presentation
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      extensions: [".ods"],
      label: "OpenDocument spreadsheet document",
      kind: FileKind.Spreadsheet
    },
    "application/vnd.oasis.opendocument.text": {
      extensions: [".odt"],
      label: "OpenDocument text document",
      kind: FileKind.Document
    },
    "audio/ogg": { extensions: [".oga", ".ogg"], label: "OGG audio", kind: FileKind.Audio },
    "video/ogg": { extensions: [".ogv"], label: "OGG video", kind: FileKind.Video },
    "application/ogg": { extensions: [".ogx"], label: "OGG", kind: FileKind.Video },
    "audio/opus": { extensions: [".opus"], label: "Opus audio", kind: FileKind.Audio },
    "font/otf": { extensions: [".otf"], label: "OpenType font", kind: FileKind.Font },
    "image/png": { extensions: [".png"], label: "Portable Network Graphics", kind: FileKind.Image },
    "application/pdf": { extensions: [".pdf"], label: "Adobe Portable Document Format (PDF)", kind: FileKind.Document },
    "application/x-httpd-php": {
      extensions: [".php"],
      label: "Hypertext Preprocessor (Personal Home Page)",
      kind: FileKind.Text
    },
    "application/vnd.ms-powerpoint": { extensions: [".ppt"], label: "Microsoft PowerPoint", kind: FileKind.Presentation },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      extensions: [".pptx"],
      label: "Microsoft PowerPoint (OpenXML)",
      kind: FileKind.Presentation
    },
    "application/vnd.rar": { extensions: [".rar"], label: "RAR archive", kind: FileKind.Archive },
    "application/rtf": { extensions: [".rtf"], label: "Rich Text Format (RTF)", kind: FileKind.Document },
    "application/x-sh": { extensions: [".sh"], label: "Bourne shell script", kind: FileKind.Text },
    "image/svg+xml": { extensions: [".svg"], label: "Scalable Vector Graphics (SVG)", kind: FileKind.Image },
    "image/svg": { extensions: [".svg"], label: "Scalable Vector Graphics (SVG)", kind: FileKind.Image },
    "application/x-shockwave-flash": {
      extensions: [".swf"],
      label: "Adobe Flash document",
      kind: FileKind.Application
    },
    "application/x-tar": { extensions: [".tar"], label: "Tape Archive (TAR)	application/x-tar", kind: FileKind.Archive },
    "image/tiff": {
      extensions: [".tif"],
      label: ".tiff File Format (TIFF)",
      kind: FileKind.Image
    },
    "video/mp2t": { extensions: [".ts"], label: "MPEG transport stream", kind: FileKind.Video },
    "font/ttf": { extensions: [".ttf"], label: "TrueType Font	font/ttf", kind: FileKind.Font },
    "text/plain": { extensions: [".txt"], label: "Plain Text", kind: FileKind.Text },
    "application/vnd.visio": { extensions: [".vsd"], label: "Microsoft Visio", kind: FileKind.Image },
    "audio/wav": { extensions: [".wav"], label: "Waveform Audio Format", kind: FileKind.Audio },
    "audio/webm": { extensions: [".weba"], label: "WEBM audio", kind: FileKind.Audio },
    "video/webm": { extensions: [".webm"], label: "WEBM video", kind: FileKind.Video },
    "image/webp": { extensions: [".webp"], label: "WEBP image", kind: FileKind.Image },
    "image/heic": {
      extensions: [".heic", ".heif"],
      label: "HEIC (High-Efficiency Image Container) image",
      kind: FileKind.Image
    },
    "font/woff": { extensions: [".woff"], label: "Web Open Font Format (WOFF)", kind: FileKind.Font },
    "font/woff2": { extensions: [".woff2"], label: "Web Open Font Format (WOFF)", kind: FileKind.Font },
    "application/xhtml+xml": { extensions: [".xhtml"], label: "XHTML", kind: FileKind.Text },
    "application/vnd.ms-excel": { extensions: [".xls"], label: "Microsoft Excel", kind: FileKind.Spreadsheet },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      extensions: [".xlsx"],
      label: "Microsoft Excel (OpenXML)",
      kind: FileKind.Spreadsheet
    },
    "application/xml": {
      extensions: [".xml"],
      label: "XML",
      kind: FileKind.Text
    },
    "text/xml": {
      extensions: [".xml"],
      label: "XML",
      kind: FileKind.Text
    },
    "application/zip": { extensions: [".zip"], label: "ZIP archive", kind: FileKind.Archive },
    "video/3gpp": {
      extensions: [".3gp"],
      label: "3GPP audio/video container",
      kind: FileKind.Video
    },
    "audio/3gpp": {
      extensions: [".3gp"],
      label: "3GPP audio/video container",
      kind: FileKind.Audio
    },
    "video/3gpp2": {
      extensions: [".3g2"],
      label: "3GPP2 audio/video container",
      kind: FileKind.Video
    },
    "audio/3gpp2": {
      extensions: [".3g2"],
      label: "3GPP2 audio/video container",
      kind: FileKind.Audio
    },
    "application/x-7z-compressed": {
      extensions: [".7z"],
      label: "7-zip archive	application/x-7z-compressed",
      kind: FileKind.Archive
    }
  };
})(data);
Object.defineProperty(mime, "__esModule", { value: true });
mime.getMimeTypes = mime.fromMime = void 0;
const data_1$1 = data;
const fromMime = (input) => {
  if (!input)
    return data_1$1.FileKind.Unknown;
  const mime2 = `${input}`.toLowerCase().trim();
  const [type] = mime2.split("/");
  switch (type) {
    case "image":
      return data_1$1.FileKind.Image;
    case "video":
      return data_1$1.FileKind.Video;
    case "audio":
      return data_1$1.FileKind.Audio;
    case "font":
      return data_1$1.FileKind.Font;
  }
  const match = data_1$1.mimeData[mime2];
  if (match) {
    return match.kind;
  }
  return data_1$1.FileKind.Unknown;
};
mime.fromMime = fromMime;
const getMimeTypes = (fileType) => {
  if (!fileType)
    return [];
  const fileKind = `${fileType}`.toLowerCase().trim();
  switch (fileKind) {
    case "image":
      return getAllowedMimeTypes(data_1$1.FileKind.Image);
    case "video":
      return getAllowedMimeTypes(data_1$1.FileKind.Video);
    case "audio":
      return getAllowedMimeTypes(data_1$1.FileKind.Audio);
    case "font":
      return getAllowedMimeTypes(data_1$1.FileKind.Font);
    case "archive":
      return getAllowedMimeTypes(data_1$1.FileKind.Archive);
    case "presentation":
      return getAllowedMimeTypes(data_1$1.FileKind.Presentation);
    case "text":
      return getAllowedMimeTypes(data_1$1.FileKind.Text);
    case "spreadsheet":
      return getAllowedMimeTypes(data_1$1.FileKind.Spreadsheet);
    case "document":
      return getAllowedMimeTypes(data_1$1.FileKind.Document);
    case "application":
      return getAllowedMimeTypes(data_1$1.FileKind.Application);
  }
  return [];
};
mime.getMimeTypes = getMimeTypes;
const getAllowedMimeTypes = (fileKind) => {
  var _a;
  return (_a = Object.keys(data_1$1.mimeData)) === null || _a === void 0 ? void 0 : _a.filter((key2) => data_1$1.mimeData[key2].kind === fileKind);
};
var ext = {};
Object.defineProperty(ext, "__esModule", { value: true });
ext.getExtensions = ext.fromExtension = void 0;
const data_1 = data;
const fromExtension = (input) => {
  var _a;
  if (!input)
    return data_1.FileKind.Unknown;
  const extension = (_a = `.${input === null || input === void 0 ? void 0 : input.replace(/^\./, "")}`) === null || _a === void 0 ? void 0 : _a.toLowerCase();
  const match = Object.entries(data_1.mimeData).find(([, data2]) => {
    var _a2;
    return (_a2 = data2.extensions) === null || _a2 === void 0 ? void 0 : _a2.find((ext2) => extension.endsWith(ext2));
  });
  if (match) {
    const [, mimeData] = match;
    return mimeData.kind;
  }
  return data_1.FileKind.Unknown;
};
ext.fromExtension = fromExtension;
const getExtensions = (fileType) => {
  if (!fileType)
    return [];
  const fileKind = `${fileType}`.toLowerCase().trim();
  switch (fileKind) {
    case "image":
      return getAllowedExtensions(data_1.FileKind.Image);
    case "video":
      return getAllowedExtensions(data_1.FileKind.Video);
    case "audio":
      return getAllowedExtensions(data_1.FileKind.Audio);
    case "font":
      return getAllowedExtensions(data_1.FileKind.Font);
    case "archive":
      return getAllowedExtensions(data_1.FileKind.Archive);
    case "presentation":
      return getAllowedExtensions(data_1.FileKind.Presentation);
    case "text":
      return getAllowedExtensions(data_1.FileKind.Text);
    case "spreadsheet":
      return getAllowedExtensions(data_1.FileKind.Spreadsheet);
    case "document":
      return getAllowedExtensions(data_1.FileKind.Document);
    case "application":
      return getAllowedExtensions(data_1.FileKind.Application);
  }
  return [];
};
ext.getExtensions = getExtensions;
const getAllowedExtensions = (fileKind) => {
  return Object.values(data_1.mimeData).flatMap((mimeData) => {
    var _a;
    if (mimeData.kind === fileKind) {
      return (_a = mimeData.extensions) !== null && _a !== void 0 ? _a : [];
    }
    return [];
  });
};
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m3[k2];
    } });
  } : function(o2, m3, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m3[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m3, exports2) {
    for (var p2 in m3)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m3, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(mime, exports);
  __exportStar(ext, exports);
  __exportStar(data, exports);
})(humanFiletypes);
function create_else_block$q(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*name*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*name*/
      2)
        set_data(
          t2,
          /*name*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block$1y(ctx) {
  let form;
  let input_1;
  let mounted;
  let dispose;
  return {
    c() {
      form = element("form");
      input_1 = element("input");
      attr(input_1, "type", "text");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      append(form, input_1);
      set_input_value(
        input_1,
        /*$filename*/
        ctx[3]
      );
      ctx[11](input_1);
      if (!mounted) {
        dispose = [
          listen(
            input_1,
            "input",
            /*input_1_input_handler*/
            ctx[10]
          ),
          listen(
            form,
            "submit",
            /*rename*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$filename*/
      8 && input_1.value !== /*$filename*/
      ctx2[3]) {
        set_input_value(
          input_1,
          /*$filename*/
          ctx2[3]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(form);
      }
      ctx[11](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$3M(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (
      /*$renamer*/
      ctx2[4] == /*itempath*/
      ctx2[0]
    )
      return create_if_block$1y;
    return create_else_block$q;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "segment name");
      attr(
        div,
        "title",
        /*name*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
      if (dirty & /*name*/
      2) {
        attr(
          div,
          "title",
          /*name*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_block.d();
    }
  };
}
function instance$3r($$self, $$props, $$invalidate) {
  let $filename;
  let $renamer;
  let $path;
  let { itempath } = $$props;
  let { name } = $$props;
  let { runtime } = $$props;
  const { renamer, path } = runtime;
  component_subscribe($$self, renamer, (value) => $$invalidate(4, $renamer = value));
  component_subscribe($$self, path, (value) => $$invalidate(12, $path = value));
  let filename = Store$1();
  component_subscribe($$self, filename, (value) => $$invalidate(3, $filename = value));
  let input;
  async function rename(e2) {
    e2.preventDefault();
    await renameItem(itempath, `${$path}/${$filename}`);
    await runtime.refresh();
    set_store_value(renamer, $renamer = "", $renamer);
  }
  renamer.subscribe(async (v2) => {
    if (v2 == itempath) {
      set_store_value(filename, $filename = name.includes("$new") ? "" : name, $filename);
      await sleep(10);
      if (!input)
        return;
      input.focus();
    }
  });
  function input_1_input_handler() {
    $filename = this.value;
    filename.set($filename);
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(2, input);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("itempath" in $$props2)
      $$invalidate(0, itempath = $$props2.itempath);
    if ("name" in $$props2)
      $$invalidate(1, name = $$props2.name);
    if ("runtime" in $$props2)
      $$invalidate(9, runtime = $$props2.runtime);
  };
  return [
    itempath,
    name,
    input,
    $filename,
    $renamer,
    renamer,
    path,
    filename,
    rename,
    runtime,
    input_1_input_handler,
    input_1_binding
  ];
}
class Renamer extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3r, create_fragment$3M, safe_not_equal, { itempath: 0, name: 1, runtime: 9 });
  }
}
function create_fragment$3L(ctx) {
  let button;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let renamer_1;
  let t1;
  let div1;
  let t2;
  let t3;
  let div2;
  let t4_value = formatBytes(
    /*file*/
    ctx[1].size
  ) + "";
  let t4;
  let t5;
  let div3;
  let t6;
  let button_data_path_value;
  let current;
  let mounted;
  let dispose;
  renamer_1 = new Renamer({
    props: {
      itempath: (
        /*file*/
        ctx[1].scopedPath
      ),
      name: (
        /*file*/
        ctx[1].filename
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      button = element("button");
      div0 = element("div");
      img = element("img");
      t0 = space();
      create_component(renamer_1.$$.fragment);
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*mime*/
        ctx[3]
      );
      t3 = space();
      div2 = element("div");
      t4 = text(t4_value);
      t5 = space();
      div3 = element("div");
      t6 = text(
        /*date*/
        ctx[2]
      );
      if (!src_url_equal(img.src, img_src_value = /*icon*/
      ctx[4]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(div0, "class", "segment icon");
      attr(div1, "class", "segment type");
      attr(div2, "class", "segment size");
      attr(div3, "class", "segment modified");
      attr(button, "class", "item file");
      attr(button, "data-contextmenu", "dirviewer-file");
      attr(button, "data-path", button_data_path_value = /*file*/
      ctx[1].scopedPath);
      toggle_class(
        button,
        "cutting",
        /*$cutList*/
        ctx[6].includes(
          /*file*/
          ctx[1].scopedPath
        )
      );
      toggle_class(
        button,
        "copying",
        /*$copyList*/
        ctx[7].includes(
          /*file*/
          ctx[1].scopedPath
        )
      );
      toggle_class(
        button,
        "selected",
        /*$selected*/
        ctx[8].includes(
          /*file*/
          ctx[1].scopedPath
        )
      );
      toggle_class(
        button,
        "renaming",
        /*file*/
        ctx[1].scopedPath == /*$renamer*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div0);
      append(div0, img);
      append(button, t0);
      mount_component(renamer_1, button, null);
      append(button, t1);
      append(button, div1);
      append(div1, t2);
      append(button, t3);
      append(button, div2);
      append(div2, t4);
      append(button, t5);
      append(button, div3);
      append(div3, t6);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*select*/
            ctx[13]
          ),
          listen(
            button,
            "dblclick",
            /*open*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*icon*/
      16 && !src_url_equal(img.src, img_src_value = /*icon*/
      ctx2[4])) {
        attr(img, "src", img_src_value);
      }
      const renamer_1_changes = {};
      if (dirty & /*file*/
      2)
        renamer_1_changes.itempath = /*file*/
        ctx2[1].scopedPath;
      if (dirty & /*file*/
      2)
        renamer_1_changes.name = /*file*/
        ctx2[1].filename;
      if (dirty & /*runtime*/
      1)
        renamer_1_changes.runtime = /*runtime*/
        ctx2[0];
      renamer_1.$set(renamer_1_changes);
      if (!current || dirty & /*mime*/
      8)
        set_data(
          t2,
          /*mime*/
          ctx2[3]
        );
      if ((!current || dirty & /*file*/
      2) && t4_value !== (t4_value = formatBytes(
        /*file*/
        ctx2[1].size
      ) + ""))
        set_data(t4, t4_value);
      if (!current || dirty & /*date*/
      4)
        set_data(
          t6,
          /*date*/
          ctx2[2]
        );
      if (!current || dirty & /*file*/
      2 && button_data_path_value !== (button_data_path_value = /*file*/
      ctx2[1].scopedPath)) {
        attr(button, "data-path", button_data_path_value);
      }
      if (!current || dirty & /*$cutList, file*/
      66) {
        toggle_class(
          button,
          "cutting",
          /*$cutList*/
          ctx2[6].includes(
            /*file*/
            ctx2[1].scopedPath
          )
        );
      }
      if (!current || dirty & /*$copyList, file*/
      130) {
        toggle_class(
          button,
          "copying",
          /*$copyList*/
          ctx2[7].includes(
            /*file*/
            ctx2[1].scopedPath
          )
        );
      }
      if (!current || dirty & /*$selected, file*/
      258) {
        toggle_class(
          button,
          "selected",
          /*$selected*/
          ctx2[8].includes(
            /*file*/
            ctx2[1].scopedPath
          )
        );
      }
      if (!current || dirty & /*file, $renamer*/
      34) {
        toggle_class(
          button,
          "renaming",
          /*file*/
          ctx2[1].scopedPath == /*$renamer*/
          ctx2[5]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(renamer_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(renamer_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(renamer_1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3q($$self, $$props, $$invalidate) {
  let $renamer;
  let $cutList;
  let $copyList;
  let $selected;
  let { runtime } = $$props;
  let { file } = $$props;
  const { cutList, copyList, renamer, selected } = runtime;
  component_subscribe($$self, cutList, (value) => $$invalidate(6, $cutList = value));
  component_subscribe($$self, copyList, (value) => $$invalidate(7, $copyList = value));
  component_subscribe($$self, renamer, (value) => $$invalidate(5, $renamer = value));
  component_subscribe($$self, selected, (value) => $$invalidate(8, $selected = value));
  let date = "";
  let mime2 = "";
  let icon = "";
  onMount(() => {
    dayjs.extend(relativeTime);
    dayjs.extend(updateLocale);
    dayjs.updateLocale("en", RelativeTimeMod);
    $$invalidate(2, date = dayjs(file.dateModified).fromNow());
    const m3 = humanFiletypes.fromMime(file.mime);
    $$invalidate(3, mime2 = m3.replace(m3[0], m3[0].toUpperCase()));
    $$invalidate(4, icon = getMimeIcon(file.filename));
  });
  async function select(e2) {
    await sleep(0);
    runtime.updateSelection(e2, file.scopedPath);
  }
  function open() {
    if ($renamer == file.scopedPath)
      return;
    OpenFile(file, runtime.pid);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("file" in $$props2)
      $$invalidate(1, file = $$props2.file);
  };
  return [
    runtime,
    file,
    date,
    mime2,
    icon,
    $renamer,
    $cutList,
    $copyList,
    $selected,
    cutList,
    copyList,
    renamer,
    selected,
    select,
    open
  ];
}
let FileItem$1 = class FileItem extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3q, create_fragment$3L, safe_not_equal, { runtime: 0, file: 1 });
  }
};
function create_fragment$3K(ctx) {
  let button;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let renamer_1;
  let t1;
  let div1;
  let t3;
  let div2;
  let t5;
  let div3;
  let current;
  let mounted;
  let dispose;
  renamer_1 = new Renamer({
    props: {
      itempath: (
        /*dir*/
        ctx[1].scopedPath
      ),
      name: (
        /*dir*/
        ctx[1].name
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      button = element("button");
      div0 = element("div");
      img = element("img");
      t0 = space();
      create_component(renamer_1.$$.fragment);
      t1 = space();
      div1 = element("div");
      div1.textContent = "Folder";
      t3 = space();
      div2 = element("div");
      div2.textContent = "-";
      t5 = space();
      div3 = element("div");
      div3.textContent = "-";
      if (!src_url_equal(img.src, img_src_value = /*icon*/
      ctx[2]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(div0, "class", "segment icon");
      attr(div1, "class", "segment type");
      attr(div2, "class", "segment size");
      attr(div3, "class", "segment modified");
      attr(button, "class", "item folder");
      toggle_class(
        button,
        "cutting",
        /*$cutList*/
        ctx[4].includes(
          /*dir*/
          ctx[1].scopedPath
        )
      );
      toggle_class(
        button,
        "copying",
        /*$copyList*/
        ctx[5].includes(
          /*dir*/
          ctx[1].scopedPath
        )
      );
      toggle_class(
        button,
        "selected",
        /*$selected*/
        ctx[6].includes(
          /*dir*/
          ctx[1].scopedPath
        )
      );
      toggle_class(
        button,
        "renaming",
        /*dir*/
        ctx[1].scopedPath == /*$renamer*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div0);
      append(div0, img);
      append(button, t0);
      mount_component(renamer_1, button, null);
      append(button, t1);
      append(button, div1);
      append(button, t3);
      append(button, div2);
      append(button, t5);
      append(button, div3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*select*/
            ctx[12]
          ),
          listen(
            button,
            "dblclick",
            /*goHere*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*icon*/
      4 && !src_url_equal(img.src, img_src_value = /*icon*/
      ctx2[2])) {
        attr(img, "src", img_src_value);
      }
      const renamer_1_changes = {};
      if (dirty & /*dir*/
      2)
        renamer_1_changes.itempath = /*dir*/
        ctx2[1].scopedPath;
      if (dirty & /*dir*/
      2)
        renamer_1_changes.name = /*dir*/
        ctx2[1].name;
      if (dirty & /*runtime*/
      1)
        renamer_1_changes.runtime = /*runtime*/
        ctx2[0];
      renamer_1.$set(renamer_1_changes);
      if (!current || dirty & /*$cutList, dir*/
      18) {
        toggle_class(
          button,
          "cutting",
          /*$cutList*/
          ctx2[4].includes(
            /*dir*/
            ctx2[1].scopedPath
          )
        );
      }
      if (!current || dirty & /*$copyList, dir*/
      34) {
        toggle_class(
          button,
          "copying",
          /*$copyList*/
          ctx2[5].includes(
            /*dir*/
            ctx2[1].scopedPath
          )
        );
      }
      if (!current || dirty & /*$selected, dir*/
      66) {
        toggle_class(
          button,
          "selected",
          /*$selected*/
          ctx2[6].includes(
            /*dir*/
            ctx2[1].scopedPath
          )
        );
      }
      if (!current || dirty & /*dir, $renamer*/
      10) {
        toggle_class(
          button,
          "renaming",
          /*dir*/
          ctx2[1].scopedPath == /*$renamer*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(renamer_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(renamer_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(renamer_1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3p($$self, $$props, $$invalidate) {
  let $renamer;
  let $cutList;
  let $copyList;
  let $selected;
  let { runtime } = $$props;
  let { dir } = $$props;
  const { cutList, copyList, renamer, selected } = runtime;
  component_subscribe($$self, cutList, (value) => $$invalidate(4, $cutList = value));
  component_subscribe($$self, copyList, (value) => $$invalidate(5, $copyList = value));
  component_subscribe($$self, renamer, (value) => $$invalidate(3, $renamer = value));
  component_subscribe($$self, selected, (value) => $$invalidate(6, $selected = value));
  let icon = FolderIcon;
  onMount(() => $$invalidate(2, icon = GetSystemFolderIcon(dir.scopedPath)));
  function goHere() {
    if ($renamer == dir.scopedPath)
      return;
    runtime.navigate(dir.scopedPath);
  }
  async function select(e2) {
    await sleep(0);
    runtime.updateSelection(e2, dir.scopedPath);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("dir" in $$props2)
      $$invalidate(1, dir = $$props2.dir);
  };
  return [
    runtime,
    dir,
    icon,
    $renamer,
    $cutList,
    $copyList,
    $selected,
    cutList,
    copyList,
    renamer,
    selected,
    goHere,
    select
  ];
}
let FolderItem$1 = class FolderItem extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3p, create_fragment$3K, safe_not_equal, { runtime: 0, dir: 1 });
  }
};
function create_fragment$3J(ctx) {
  let button;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<div class="segment name">Name</div> <div class="segment type">Type</div> <div class="segment size">Size</div> <div class="segment modified">Modified</div>`;
      attr(button, "class", "item header-row");
    },
    m(target, anchor) {
      insert(target, button, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
    }
  };
}
let Header$9 = class Header4 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$3J, safe_not_equal, {});
  }
};
function create_fragment$3I(ctx) {
  let div;
  let spinner;
  let current;
  spinner = new Spinner({ props: { height: 32 } });
  return {
    c() {
      div = element("div");
      create_component(spinner.$$.fragment);
      attr(div, "class", "center-flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(spinner, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(spinner);
    }
  };
}
let Loading$1 = class Loading2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$3I, safe_not_equal, {});
  }
};
function create_fragment$3H(ctx) {
  let div1;
  let p2;
  let t1;
  let input;
  let t2;
  let div0;
  let button0;
  let t4;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      p2 = element("p");
      p2.textContent = "New folder:";
      t1 = space();
      input = element("input");
      t2 = space();
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "Create";
      t4 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(p2, "class", "label");
      attr(input, "type", "text");
      attr(button0, "class", "suggested");
      attr(div0, "class", "actions");
      attr(div1, "class", "new-folder");
      toggle_class(
        div1,
        "show",
        /*$newFolder*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, p2);
      append(div1, t1);
      append(div1, input);
      set_input_value(
        input,
        /*name*/
        ctx[0]
      );
      append(div1, t2);
      append(div1, div0);
      append(div0, button0);
      append(div0, t4);
      append(div0, button1);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[7]
          ),
          listen(
            button0,
            "click",
            /*create*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*cancel*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*name*/
      1 && input.value !== /*name*/
      ctx2[0]) {
        set_input_value(
          input,
          /*name*/
          ctx2[0]
        );
      }
      if (dirty & /*$newFolder*/
      2) {
        toggle_class(
          div1,
          "show",
          /*$newFolder*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3o($$self, $$props, $$invalidate) {
  let $newFolder;
  let $path;
  let { runtime } = $$props;
  const { newFolder, path } = runtime;
  component_subscribe($$self, newFolder, (value) => $$invalidate(1, $newFolder = value));
  component_subscribe($$self, path, (value) => $$invalidate(8, $path = value));
  let name = "";
  newFolder.subscribe((v2) => {
    if (!v2)
      $$invalidate(0, name = "");
  });
  async function create() {
    createDirectory(`${$path}/${name}`);
    cancel();
  }
  function cancel() {
    set_store_value(newFolder, $newFolder = false, $newFolder);
  }
  function input_input_handler() {
    name = this.value;
    $$invalidate(0, name);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(6, runtime = $$props2.runtime);
  };
  return [
    name,
    $newFolder,
    newFolder,
    path,
    create,
    cancel,
    runtime,
    input_input_handler
  ];
}
class NewFolder extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3o, create_fragment$3H, safe_not_equal, { runtime: 6 });
  }
}
function get_each_context$E(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list2[i2];
  return child_ctx;
}
function get_each_context_1$6(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list2[i2];
  return child_ctx;
}
function create_if_block_3$6(ctx) {
  let t0;
  let t1;
  let if_block_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*$contents*/
    ctx[5].directories
  );
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  let each_value = ensure_array_like(
    /*$contents*/
    ctx[5].files
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$E(get_each_context$E(ctx, each_value, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = !/*$contents*/
  ctx[5].files.length && !/*$contents*/
  ctx[5].directories.length && create_if_block_4$3();
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t0 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(target, anchor);
        }
      }
      insert(target, t0, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$contents, runtime*/
      33) {
        each_value_1 = ensure_array_like(
          /*$contents*/
          ctx2[5].directories
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$6(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_1$6(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(t0.parentNode, t0);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (dirty & /*$contents, runtime*/
      33) {
        each_value = ensure_array_like(
          /*$contents*/
          ctx2[5].files
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$E(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$E(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t1.parentNode, t1);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
      if (!/*$contents*/
      ctx2[5].files.length && !/*$contents*/
      ctx2[5].directories.length) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_4$3();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block_anchor);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_each_block_1$6(ctx) {
  let folderitem;
  let current;
  folderitem = new FolderItem$1({
    props: {
      dir: (
        /*dir*/
        ctx[20]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(folderitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(folderitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const folderitem_changes = {};
      if (dirty & /*$contents*/
      32)
        folderitem_changes.dir = /*dir*/
        ctx2[20];
      if (dirty & /*runtime*/
      1)
        folderitem_changes.runtime = /*runtime*/
        ctx2[0];
      folderitem.$set(folderitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(folderitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folderitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(folderitem, detaching);
    }
  };
}
function create_each_block$E(ctx) {
  let fileitem;
  let current;
  fileitem = new FileItem$1({
    props: {
      file: (
        /*file*/
        ctx[17]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(fileitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fileitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const fileitem_changes = {};
      if (dirty & /*$contents*/
      32)
        fileitem_changes.file = /*file*/
        ctx2[17];
      if (dirty & /*runtime*/
      1)
        fileitem_changes.runtime = /*runtime*/
        ctx2[0];
      fileitem.$set(fileitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fileitem, detaching);
    }
  };
}
function create_if_block_4$3(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "This folder is empty.";
      attr(p2, "class", "empty");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_if_block_2$c(ctx) {
  let failed_1;
  let current;
  failed_1 = new Failed$1({});
  return {
    c() {
      create_component(failed_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(failed_1, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(failed_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(failed_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(failed_1, detaching);
    }
  };
}
function create_if_block_1$x(ctx) {
  let loading_1;
  let current;
  loading_1 = new Loading$1({});
  return {
    c() {
      create_component(loading_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading_1, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loading_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading_1, detaching);
    }
  };
}
function create_if_block$1x(ctx) {
  let dropper;
  let current;
  dropper = new Dropper({});
  return {
    c() {
      create_component(dropper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dropper, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(dropper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dropper, detaching);
    }
  };
}
function create_fragment$3G(ctx) {
  let newfolder;
  let t0;
  let div;
  let header2;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block3_anchor;
  let current;
  let mounted;
  let dispose;
  newfolder = new NewFolder({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  header2 = new Header$9({});
  let if_block0 = (
    /*$contents*/
    ctx[5] && create_if_block_3$6(ctx)
  );
  let if_block1 = (
    /*$failed*/
    ctx[6] && create_if_block_2$c()
  );
  let if_block2 = (
    /*$loading*/
    ctx[7] && create_if_block_1$x()
  );
  let if_block3 = (
    /*dropping*/
    ctx[1] && create_if_block$1x()
  );
  return {
    c() {
      create_component(newfolder.$$.fragment);
      t0 = space();
      div = element("div");
      create_component(header2.$$.fragment);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      attr(div, "class", "directory-viewer");
      attr(div, "role", "directory");
      attr(div, "data-contextmenu", "dirviewer");
      attr(
        div,
        "data-path",
        /*$path*/
        ctx[4]
      );
      toggle_class(
        div,
        "grid",
        /*$UserDataStore*/
        ctx[2].appdata.FileManager.grid
      );
      toggle_class(
        div,
        "newfolder",
        /*$newFolder*/
        ctx[3]
      );
      toggle_class(
        div,
        "dropping",
        /*dropping*/
        ctx[1]
      );
    },
    m(target, anchor) {
      mount_component(newfolder, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      mount_component(header2, div, null);
      append(div, t1);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t3);
      if (if_block2)
        if_block2.m(div, null);
      insert(target, t4, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, if_block3_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "dragover",
            /*dragOver*/
            ctx[13]
          ),
          listen(
            div,
            "drop",
            /*drop*/
            ctx[14]
          ),
          listen(
            div,
            "dragenter",
            /*dragenter_handler*/
            ctx[15]
          ),
          listen(
            div,
            "dragleave",
            /*dragleave_handler*/
            ctx[16]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const newfolder_changes = {};
      if (dirty & /*runtime*/
      1)
        newfolder_changes.runtime = /*runtime*/
        ctx2[0];
      newfolder.$set(newfolder_changes);
      if (
        /*$contents*/
        ctx2[5]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$contents*/
          32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$6(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$failed*/
        ctx2[6]
      ) {
        if (if_block1) {
          if (dirty & /*$failed*/
          64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$c();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$loading*/
        ctx2[7]
      ) {
        if (if_block2) {
          if (dirty & /*$loading*/
          128) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$x();
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*$path*/
      16) {
        attr(
          div,
          "data-path",
          /*$path*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*$UserDataStore*/
      4) {
        toggle_class(
          div,
          "grid",
          /*$UserDataStore*/
          ctx2[2].appdata.FileManager.grid
        );
      }
      if (!current || dirty & /*$newFolder*/
      8) {
        toggle_class(
          div,
          "newfolder",
          /*$newFolder*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*dropping*/
      2) {
        toggle_class(
          div,
          "dropping",
          /*dropping*/
          ctx2[1]
        );
      }
      if (
        /*dropping*/
        ctx2[1]
      ) {
        if (if_block3) {
          if (dirty & /*dropping*/
          2) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$1x();
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(newfolder.$$.fragment, local);
      transition_in(header2.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(newfolder.$$.fragment, local);
      transition_out(header2.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t4);
        detach(if_block3_anchor);
      }
      destroy_component(newfolder, detaching);
      destroy_component(header2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3n($$self, $$props, $$invalidate) {
  let $UserDataStore;
  let $newFolder;
  let $path;
  let $contents;
  let $failed;
  let $loading;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(2, $UserDataStore = $$value));
  let { runtime } = $$props;
  const { loading, failed, contents, newFolder, path } = runtime;
  component_subscribe($$self, loading, (value) => $$invalidate(7, $loading = value));
  component_subscribe($$self, failed, (value) => $$invalidate(6, $failed = value));
  component_subscribe($$self, contents, (value) => $$invalidate(5, $contents = value));
  component_subscribe($$self, newFolder, (value) => $$invalidate(3, $newFolder = value));
  component_subscribe($$self, path, (value) => $$invalidate(4, $path = value));
  let dropping = false;
  function dragOver(e2) {
    $$invalidate(1, dropping = true);
    e2.preventDefault();
  }
  function drop(e2) {
    runtime.dropFiles(e2);
    $$invalidate(1, dropping = false);
  }
  const dragenter_handler = () => $$invalidate(1, dropping = true);
  const dragleave_handler = () => $$invalidate(1, dropping = false);
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [
    runtime,
    dropping,
    $UserDataStore,
    $newFolder,
    $path,
    $contents,
    $failed,
    $loading,
    loading,
    failed,
    contents,
    newFolder,
    path,
    dragOver,
    drop,
    dragenter_handler,
    dragleave_handler
  ];
}
let DirectoryViewer$1 = class DirectoryViewer extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3n, create_fragment$3G, safe_not_equal, { runtime: 0 });
  }
};
function create_else_block$p(ctx) {
  let t0;
  let t1;
  let t2_value = Plural(
    "item",
    /*size*/
    ctx[1]
  ) + "";
  let t2;
  let t3;
  let t4;
  return {
    c() {
      t0 = text(
        /*size*/
        ctx[1]
      );
      t1 = space();
      t2 = text(t2_value);
      t3 = text(" in ");
      t4 = text(
        /*folder*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, t4, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*size*/
      2)
        set_data(
          t0,
          /*size*/
          ctx2[1]
        );
      if (dirty & /*size*/
      2 && t2_value !== (t2_value = Plural(
        "item",
        /*size*/
        ctx2[1]
      ) + ""))
        set_data(t2, t2_value);
      if (dirty & /*folder*/
      1)
        set_data(
          t4,
          /*folder*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
      }
    }
  };
}
function create_if_block_1$w(ctx) {
  let t0;
  let t1_value = (
    /*$selected*/
    ctx[3].length + ""
  );
  let t1;
  let t2;
  let t3;
  let t4;
  let t5_value = Plural(
    "item",
    /*size*/
    ctx[1]
  ) + "";
  let t5;
  let t6;
  let t7;
  return {
    c() {
      t0 = text("Selecting ");
      t1 = text(t1_value);
      t2 = text(" of ");
      t3 = text(
        /*size*/
        ctx[1]
      );
      t4 = space();
      t5 = text(t5_value);
      t6 = text(" in ");
      t7 = text(
        /*folder*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, t4, anchor);
      insert(target, t5, anchor);
      insert(target, t6, anchor);
      insert(target, t7, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$selected*/
      8 && t1_value !== (t1_value = /*$selected*/
      ctx2[3].length + ""))
        set_data(t1, t1_value);
      if (dirty & /*size*/
      2)
        set_data(
          t3,
          /*size*/
          ctx2[1]
        );
      if (dirty & /*size*/
      2 && t5_value !== (t5_value = Plural(
        "item",
        /*size*/
        ctx2[1]
      ) + ""))
        set_data(t5, t5_value);
      if (dirty & /*folder*/
      1)
        set_data(
          t7,
          /*folder*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
      }
    }
  };
}
function create_if_block$1w(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = WarningIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "Lots of items!");
      attr(img, "title", "Lots of items!");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_fragment$3F(ctx) {
  let div1;
  let p2;
  let t0;
  let t1;
  let div0;
  let button0;
  let t3;
  let button1;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*$selected*/
      ctx2[3].length
    )
      return create_if_block_1$w;
    return create_else_block$p;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*size*/
    ctx[1] > 1e3 && create_if_block$1w()
  );
  return {
    c() {
      div1 = element("div");
      p2 = element("p");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "format_list_bulleted";
      t3 = space();
      button1 = element("button");
      button1.textContent = "grid_on";
      attr(p2, "class", "count");
      attr(button0, "class", "material-icons-round");
      toggle_class(button0, "suggested", !/*grid*/
      ctx[2]);
      attr(button1, "class", "material-icons-round");
      toggle_class(
        button1,
        "suggested",
        /*grid*/
        ctx[2]
      );
      attr(div0, "class", "view-modes");
      attr(div1, "class", "toolbar");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, p2);
      if_block0.m(p2, null);
      append(p2, t0);
      if (if_block1)
        if_block1.m(p2, null);
      append(div1, t1);
      append(div1, div0);
      append(div0, button0);
      append(div0, t3);
      append(div0, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*gridOff*/
            ctx[5]
          ),
          listen(
            button1,
            "click",
            /*gridOn*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(p2, t0);
        }
      }
      if (
        /*size*/
        ctx2[1] > 1e3
      ) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block$1w();
          if_block1.c();
          if_block1.m(p2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*grid*/
      4) {
        toggle_class(button0, "suggested", !/*grid*/
        ctx2[2]);
      }
      if (dirty & /*grid*/
      4) {
        toggle_class(
          button1,
          "suggested",
          /*grid*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3m($$self, $$props, $$invalidate) {
  let $UserDataStore;
  let $selected;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(8, $UserDataStore = $$value));
  let { runtime } = $$props;
  const { contents, selected } = runtime;
  component_subscribe($$self, selected, (value) => $$invalidate(3, $selected = value));
  let folder = "";
  let size = 0;
  let grid = false;
  contents.subscribe((v2) => {
    if (!v2)
      return;
    $$invalidate(0, folder = pathToFriendlyName(v2.scopedPath));
    $$invalidate(1, size = v2.directories.length + v2.files.length);
  });
  UserDataStore.subscribe((v2) => {
    $$invalidate(2, grid = !!$UserDataStore.appdata.FileManager.grid);
  });
  function gridOff() {
    set_store_value(UserDataStore, $UserDataStore.appdata.FileManager.grid = false, $UserDataStore);
  }
  function gridOn() {
    set_store_value(UserDataStore, $UserDataStore.appdata.FileManager.grid = true, $UserDataStore);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(7, runtime = $$props2.runtime);
  };
  return [folder, size, grid, $selected, selected, gridOff, gridOn, runtime];
}
let Toolbar$5 = class Toolbar3 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3m, create_fragment$3F, safe_not_equal, { runtime: 7 });
  }
};
function create_fragment$3E(ctx) {
  let div;
  let titlebar;
  let t0;
  let addressbar;
  let t1;
  let directoryviewer;
  let t2;
  let toolbar;
  let current;
  titlebar = new Titlebar({
    props: {
      app: (
        /*runtime*/
        ctx[0].appMutator
      ),
      pid: (
        /*runtime*/
        ctx[0].pid
      )
    }
  });
  addressbar = new AddressBar({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  directoryviewer = new DirectoryViewer$1({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  toolbar = new Toolbar$5({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(titlebar.$$.fragment);
      t0 = space();
      create_component(addressbar.$$.fragment);
      t1 = space();
      create_component(directoryviewer.$$.fragment);
      t2 = space();
      create_component(toolbar.$$.fragment);
      attr(div, "class", "content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(titlebar, div, null);
      append(div, t0);
      mount_component(addressbar, div, null);
      append(div, t1);
      mount_component(directoryviewer, div, null);
      append(div, t2);
      mount_component(toolbar, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const titlebar_changes = {};
      if (dirty & /*runtime*/
      1)
        titlebar_changes.app = /*runtime*/
        ctx2[0].appMutator;
      if (dirty & /*runtime*/
      1)
        titlebar_changes.pid = /*runtime*/
        ctx2[0].pid;
      titlebar.$set(titlebar_changes);
      const addressbar_changes = {};
      if (dirty & /*runtime*/
      1)
        addressbar_changes.runtime = /*runtime*/
        ctx2[0];
      addressbar.$set(addressbar_changes);
      const directoryviewer_changes = {};
      if (dirty & /*runtime*/
      1)
        directoryviewer_changes.runtime = /*runtime*/
        ctx2[0];
      directoryviewer.$set(directoryviewer_changes);
      const toolbar_changes = {};
      if (dirty & /*runtime*/
      1)
        toolbar_changes.runtime = /*runtime*/
        ctx2[0];
      toolbar.$set(toolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(titlebar.$$.fragment, local);
      transition_in(addressbar.$$.fragment, local);
      transition_in(directoryviewer.$$.fragment, local);
      transition_in(toolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(titlebar.$$.fragment, local);
      transition_out(addressbar.$$.fragment, local);
      transition_out(directoryviewer.$$.fragment, local);
      transition_out(toolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(titlebar);
      destroy_component(addressbar);
      destroy_component(directoryviewer);
      destroy_component(toolbar);
    }
  };
}
function instance$3l($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime];
}
let Content$3 = class Content2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3l, create_fragment$3E, safe_not_equal, { runtime: 0 });
  }
};
function create_fragment$3D(ctx) {
  let button;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1_value = (
    /*folder*/
    ctx[0].name + ""
  );
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      if (!src_url_equal(img.src, img_src_value = /*folder*/
      ctx[0].icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(img, "class", "icon");
      attr(button, "class", "folder");
      toggle_class(
        button,
        "selected",
        /*folder*/
        ctx[0].path === /*current*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, span);
      append(span, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*goHere*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*folder*/
      1 && !src_url_equal(img.src, img_src_value = /*folder*/
      ctx2[0].icon)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*folder*/
      1 && t1_value !== (t1_value = /*folder*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*folder, current*/
      3) {
        toggle_class(
          button,
          "selected",
          /*folder*/
          ctx2[0].path === /*current*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3k($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { folder } = $$props;
  let { current } = $$props;
  function goHere() {
    runtime.navigate(folder.path);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
    if ("folder" in $$props2)
      $$invalidate(0, folder = $$props2.folder);
    if ("current" in $$props2)
      $$invalidate(1, current = $$props2.current);
  };
  return [folder, current, goHere, runtime];
}
let Folder$1 = class Folder extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3k, create_fragment$3D, safe_not_equal, { runtime: 3, folder: 0, current: 1 });
  }
};
function create_fragment$3C(ctx) {
  let div3;
  let div1;
  let div0;
  let t0;
  let div2;
  let p0;
  let t1_value = formatBytes(
    /*$quota*/
    ctx[0].used
  ) + "";
  let t1;
  let t2;
  let p1;
  let t3_value = formatBytes(
    /*$quota*/
    ctx[0].max
  ) + "";
  let t3;
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      div2 = element("div");
      p0 = element("p");
      t1 = text(t1_value);
      t2 = space();
      p1 = element("p");
      t3 = text(t3_value);
      attr(div0, "class", "inner");
      set_style(div0, "--w", 100 / /*$quota*/
      ctx[0].max * /*$quota*/
      ctx[0].used + "%");
      attr(div1, "class", "bar");
      attr(p0, "class", "used");
      attr(p1, "class", "max");
      attr(div2, "class", "stats");
      attr(div3, "class", "fs-quota");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      append(div3, t0);
      append(div3, div2);
      append(div2, p0);
      append(p0, t1);
      append(div2, t2);
      append(div2, p1);
      append(p1, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$quota*/
      1) {
        set_style(div0, "--w", 100 / /*$quota*/
        ctx2[0].max * /*$quota*/
        ctx2[0].used + "%");
      }
      if (dirty & /*$quota*/
      1 && t1_value !== (t1_value = formatBytes(
        /*$quota*/
        ctx2[0].used
      ) + ""))
        set_data(t1, t1_value);
      if (dirty & /*$quota*/
      1 && t3_value !== (t3_value = formatBytes(
        /*$quota*/
        ctx2[0].max
      ) + ""))
        set_data(t3, t3_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
    }
  };
}
function instance$3j($$self, $$props, $$invalidate) {
  let $quota;
  let { runtime } = $$props;
  const { quota } = runtime;
  component_subscribe($$self, quota, (value) => $$invalidate(0, $quota = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [$quota, quota, runtime];
}
class Quota extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3j, create_fragment$3C, safe_not_equal, { runtime: 2 });
  }
}
function get_each_context$D(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function create_each_block$D(ctx) {
  let folder_1;
  let current;
  folder_1 = new Folder$1({
    props: {
      folder: (
        /*folder*/
        ctx[3]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      current: (
        /*$path*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(folder_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(folder_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const folder_1_changes = {};
      if (dirty & /*runtime*/
      1)
        folder_1_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*$path*/
      2)
        folder_1_changes.current = /*$path*/
        ctx2[1];
      folder_1.$set(folder_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(folder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(folder_1, detaching);
    }
  };
}
function create_fragment$3B(ctx) {
  let div1;
  let div0;
  let t2;
  let quota;
  let current;
  let each_value = ensure_array_like(SystemFolders);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$D(get_each_context$D(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  quota = new Quota({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      create_component(quota.$$.fragment);
      attr(div0, "class", "folders");
      attr(div1, "class", "sidebar");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div1, t2);
      mount_component(quota, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*runtime, $path*/
      3) {
        each_value = ensure_array_like(SystemFolders);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$D(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$D(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const quota_changes = {};
      if (dirty & /*runtime*/
      1)
        quota_changes.runtime = /*runtime*/
        ctx2[0];
      quota.$set(quota_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(quota.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(quota.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      destroy_component(quota);
    }
  };
}
function instance$3i($$self, $$props, $$invalidate) {
  let $path;
  let { runtime } = $$props;
  const { path } = runtime;
  component_subscribe($$self, path, (value) => $$invalidate(1, $path = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, $path, path];
}
let SideBar$2 = class SideBar extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3i, create_fragment$3B, safe_not_equal, { runtime: 0 });
  }
};
function create_fragment$3A(ctx) {
  let div;
  let img;
  let img_src_value;
  let t2;
  let spinner;
  let current;
  spinner = new Spinner({ props: { height: 30 } });
  return {
    c() {
      div = element("div");
      img = element("img");
      t2 = space();
      create_component(spinner.$$.fragment);
      if (!src_url_equal(img.src, img_src_value = FileManagerIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(div, "class", "center-flex splash");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
      append(div, t2);
      mount_component(spinner, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(spinner);
    }
  };
}
class Splash extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$3A, safe_not_equal, {});
  }
}
const main$n = "";
function create_else_block$o(ctx) {
  let splash;
  let current;
  splash = new Splash({});
  return {
    c() {
      create_component(splash.$$.fragment);
    },
    m(target, anchor) {
      mount_component(splash, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(splash.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(splash.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(splash, detaching);
    }
  };
}
function create_if_block$1v(ctx) {
  let sidebar;
  let t2;
  let content;
  let current;
  sidebar = new SideBar$2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  content = new Content$3({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(sidebar.$$.fragment);
      t2 = space();
      create_component(content.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sidebar, target, anchor);
      insert(target, t2, anchor);
      mount_component(content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sidebar_changes = {};
      if (dirty & /*runtime*/
      1)
        sidebar_changes.runtime = /*runtime*/
        ctx2[0];
      sidebar.$set(sidebar_changes);
      const content_changes = {};
      if (dirty & /*runtime*/
      1)
        content_changes.runtime = /*runtime*/
        ctx2[0];
      content.$set(content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      transition_in(content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      transition_out(content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(sidebar, detaching);
      destroy_component(content, detaching);
    }
  };
}
function create_fragment$3z(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1v, create_else_block$o];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*$starting*/
    ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$3h($$self, $$props, $$invalidate) {
  let $starting;
  let { runtime } = $$props;
  const { starting } = runtime;
  component_subscribe($$self, starting, (value) => $$invalidate(1, $starting = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, $starting, starting];
}
let App$j = class App12 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3h, create_fragment$3z, safe_not_equal, { runtime: 0 });
  }
};
function compileOpenWithMenu() {
  const openWithMenu = {
    caption: "Open With",
    subItems: []
  };
  for (const handler of FileHandlers) {
    openWithMenu.subItems.push({
      caption: handler.name,
      image: handler.image,
      async action(_2, data2) {
        const partial = await getPartialFile(data2.path);
        if (!partial)
          return;
        handler.handler(partial);
      }
    });
  }
  return openWithMenu;
}
const FileManagerContextMenus = {
  "dirviewer-file": [
    {
      caption: "Open",
      async action(window2, data2) {
        const partial = await getPartialFile(data2.path);
        if (!partial)
          return;
        OpenWith(partial, window2.pid);
      }
    },
    compileOpenWithMenu(),
    SEP_ITEM,
    {
      caption: "Cut",
      icon: "content_cut",
      async action(window2, data2) {
        ProcessStack.dispatch.dispatchToPid(window2.pid, "context-cut", data2.path);
      }
    },
    {
      caption: "Copy",
      icon: "content_copy",
      async action(window2, data2) {
        ProcessStack.dispatch.dispatchToPid(window2.pid, "context-copy", data2.path);
      }
    },
    {
      caption: "Paste",
      icon: "content_paste",
      async action(window2) {
        ProcessStack.dispatch.dispatchToPid(window2.pid, "context-paste");
      }
    },
    SEP_ITEM,
    {
      caption: "Delete",
      image: TrashIcon,
      async action(window2, data2) {
        ProcessStack.dispatch.dispatchToPid(window2.pid, "context-delete", data2.path);
      }
    },
    {
      caption: "Rename",
      icon: "mode_edit",
      async action(window2, data2) {
        ProcessStack.dispatch.dispatchToPid(window2.pid, "context-rename", data2.path);
      }
    }
  ],
  dirviewer: [
    {
      caption: "View",
      icon: "visibility",
      subItems: [
        {
          caption: "List",
          icon: "format_list_bulleted",
          isActive: () => !UserDataStore.get().appdata.FileManager.grid,
          action() {
            UserDataStore.update((v2) => {
              v2.appdata.FileManager.grid = false;
              return v2;
            });
          }
        },
        {
          caption: "Grid",
          icon: "grid_on",
          isActive: () => UserDataStore.get().appdata.FileManager.grid,
          action() {
            UserDataStore.update((v2) => {
              v2.appdata.FileManager.grid = true;
              return v2;
            });
          }
        }
      ]
    },
    {
      caption: "Refresh",
      icon: "refresh",
      async action(window2) {
        ProcessStack.dispatch.dispatchToPid(window2.pid, "refresh");
      }
    },
    SEP_ITEM,
    {
      caption: "Cut",
      icon: "content_cut",
      async action(window2) {
        ProcessStack.dispatch.dispatchToPid(window2.pid, "context-cut");
      }
    },
    {
      caption: "Copy",
      icon: "content_copy",
      async action(window2) {
        ProcessStack.dispatch.dispatchToPid(window2.pid, "context-copy");
      }
    },
    {
      caption: "Copy folder path",
      icon: "content_copy",
      async action(_2, data2) {
        navigator.clipboard.writeText(data2.path);
      }
    },
    {
      caption: "Paste",
      icon: "content_paste",
      async action(window2) {
        ProcessStack.dispatch.dispatchToPid(window2.pid, "context-paste");
      }
    },
    SEP_ITEM,
    {
      caption: "Add",
      subItems: [
        {
          caption: "Empty file",
          image: FileIcon,
          async action(window2, data2) {
            const id = Math.floor(Math.random() * 1e3);
            const blob = new Blob();
            const filename = `${data2.path}/$new${id}.$new`.replaceAll("//", "/");
            ProcessStack.dispatch.dispatchToPid(
              window2.pid,
              "context-rename",
              pathToFriendlyPath(filename)
            );
            await writeFile(filename, blob);
            await sleep(100);
          }
        },
        {
          caption: "Folder",
          image: FolderIcon,
          action(window2) {
            ProcessStack.dispatch.dispatchToPid(window2.pid, "new-folder");
          }
        },
        SEP_ITEM,
        {
          caption: "Upload",
          image: UploadIcon,
          action(window2, data2) {
            directUploadProgressy(data2.path, true, window2.pid);
          }
        }
      ]
    }
  ]
};
const FileManager = {
  metadata: {
    name: "File Manager",
    description: "Manage your ArcFS files",
    author: "The ArcOS Team",
    version: "2.0.0",
    icon: FileManagerIcon,
    dependendsOn: ["FsProgress", "OpenWith"]
  },
  runtime: Runtime$c,
  content: App$j,
  id: "FileManager",
  size: { w: 800, h: 600 },
  minSize: { w: 650, h: 520 },
  maxSize: { w: 1400, h: 800 },
  pos: { x: 120, y: 60 },
  state: {
    minimized: false,
    maximized: false,
    headless: true,
    fullscreen: false,
    resizable: true
  },
  controls: {
    minimize: true,
    maximize: true,
    close: true
  },
  glass: true,
  contextMenu: FileManagerContextMenus,
  acceleratorDescriptions: {
    "ctrl+a": "Select all items in the folder",
    "alt+up": "Go to the parent directory",
    "alt+r": "Reload the directory",
    f2: "Rename the item (if there's only one selected)",
    enter: "Open file or navigate to folder",
    "shift+enter": "Launch Open With menu for a file, or open a folder in a new window",
    esc: "Clear the current selection",
    del: "Delete the currently selected items",
    up: "Move selection up using the keyboard",
    down: "Move selection down using the keyboard"
  },
  loadCondition: () => !SafeMode.get(),
  helpArticle: HelpArticles.fileManager
};
let Runtime$b = class Runtime12 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "Progress", Store$1());
    function stop2() {
      process.handler.kill(process.pid, true);
    }
    const args = process.args;
    const store = args[0];
    if (!args.length || !store || !store.get || !store.set) {
      stop2();
      return;
    }
    let errorNotified = false;
    store.subscribe(async (v2) => {
      this.Progress.set(v2);
      this.setWindowTitle(v2.caption);
      this.setWindowIcon(v2.icon);
      if (v2.done >= v2.max && !v2.errors) {
        await sleep(350);
        stop2();
      }
      if (v2.done >= v2.max && v2.errors && !errorNotified) {
        errorNotified = true;
        createErrorDialog(
          {
            title: "Errors Occured",
            message: `${v2.errors} ${Plural("Error", v2.errors)} occured while <b>${v2.caption}</b> was running.`,
            buttons: [
              {
                caption: "Okay",
                action() {
                  stop2();
                },
                suggested: true
              }
            ],
            image: WarningIcon,
            sound: "arcos.dialog.warning"
          },
          this.process.parentPid || 0,
          !!this.process.parentPid
        );
      }
    });
  }
};
function create_fragment$3y(ctx) {
  let div;
  let span0;
  let t0;
  let span0_title_value;
  let t1;
  let span1;
  let t3;
  let span2;
  return {
    c() {
      div = element("div");
      span0 = element("span");
      t0 = text("warning");
      t1 = space();
      span1 = element("span");
      span1.textContent = "storage";
      t3 = space();
      span2 = element("span");
      span2.textContent = "hourglass_top";
      attr(span0, "class", "material-icons-round warning");
      attr(span0, "title", span0_title_value = /*$Progress*/
      ctx[0].errors + " Error(s)");
      toggle_class(
        span0,
        "active",
        /*$Progress*/
        ctx[0].errors
      );
      attr(span1, "class", "material-icons-round working");
      attr(span1, "title", "Writing data indicator");
      toggle_class(
        span1,
        "active",
        /*$Progress*/
        ctx[0].working
      );
      attr(span2, "class", "material-icons-round waiting");
      attr(span2, "title", "Cooldown indicator");
      toggle_class(
        span2,
        "active",
        /*$Progress*/
        ctx[0].waiting
      );
      attr(div, "class", "status");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      append(span0, t0);
      append(div, t1);
      append(div, span1);
      append(div, t3);
      append(div, span2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$Progress*/
      1 && span0_title_value !== (span0_title_value = /*$Progress*/
      ctx2[0].errors + " Error(s)")) {
        attr(span0, "title", span0_title_value);
      }
      if (dirty & /*$Progress*/
      1) {
        toggle_class(
          span0,
          "active",
          /*$Progress*/
          ctx2[0].errors
        );
      }
      if (dirty & /*$Progress*/
      1) {
        toggle_class(
          span1,
          "active",
          /*$Progress*/
          ctx2[0].working
        );
      }
      if (dirty & /*$Progress*/
      1) {
        toggle_class(
          span2,
          "active",
          /*$Progress*/
          ctx2[0].waiting
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$3g($$self, $$props, $$invalidate) {
  let $Progress;
  let { runtime } = $$props;
  const { Progress: Progress2 } = runtime;
  component_subscribe($$self, Progress2, (value) => $$invalidate(0, $Progress = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [$Progress, Progress2, runtime];
}
let Status$1 = class Status extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3g, create_fragment$3y, safe_not_equal, { runtime: 2 });
  }
};
function create_if_block_1$v(ctx) {
  let t0_value = formatBytes(
    /*$Progress*/
    ctx[2].done
  ) + "";
  let t0;
  let t1;
  let t2_value = formatBytes(
    /*$Progress*/
    ctx[2].max
  ) + "";
  let t2;
  let t3;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" / ");
      t2 = text(t2_value);
      t3 = text(" done");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$Progress*/
      4 && t0_value !== (t0_value = formatBytes(
        /*$Progress*/
        ctx2[2].done
      ) + ""))
        set_data(t0, t0_value);
      if (dirty & /*$Progress*/
      4 && t2_value !== (t2_value = formatBytes(
        /*$Progress*/
        ctx2[2].max
      ) + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
      }
    }
  };
}
function create_if_block$1u(ctx) {
  let t0_value = (
    /*$Progress*/
    ctx[2].done + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*$Progress*/
    ctx[2].max + ""
  );
  let t2;
  let t3;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" / ");
      t2 = text(t2_value);
      t3 = text(" done");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$Progress*/
      4 && t0_value !== (t0_value = /*$Progress*/
      ctx2[2].done + ""))
        set_data(t0, t0_value);
      if (dirty & /*$Progress*/
      4 && t2_value !== (t2_value = /*$Progress*/
      ctx2[2].max + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
      }
    }
  };
}
function create_fragment$3x(ctx) {
  let div;
  let p2;
  let t0;
  let status2;
  let t1;
  let button;
  let t2;
  let button_disabled_value;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*$Progress*/
      ctx2[2].type == "quantity"
    )
      return create_if_block$1u;
    if (
      /*$Progress*/
      ctx2[2].type == "size"
    )
      return create_if_block_1$v;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  status2 = new Status$1({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div = element("div");
      p2 = element("p");
      if (if_block)
        if_block.c();
      t0 = space();
      create_component(status2.$$.fragment);
      t1 = space();
      button = element("button");
      t2 = text("Cancel");
      attr(p2, "class", "status");
      attr(button, "class", "cancel");
      button.disabled = button_disabled_value = !/*$Progress*/
      ctx[2].cancel || /*canceling*/
      ctx[1];
      attr(div, "class", "bottom");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p2);
      if (if_block)
        if_block.m(p2, null);
      append(div, t0);
      mount_component(status2, div, null);
      append(div, t1);
      append(div, button);
      append(button, t2);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*cancel*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(p2, null);
        }
      }
      const status_changes = {};
      if (dirty & /*runtime*/
      1)
        status_changes.runtime = /*runtime*/
        ctx2[0];
      status2.$set(status_changes);
      if (!current || dirty & /*$Progress, canceling*/
      6 && button_disabled_value !== (button_disabled_value = !/*$Progress*/
      ctx2[2].cancel || /*canceling*/
      ctx2[1])) {
        button.disabled = button_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(status2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(status2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) {
        if_block.d();
      }
      destroy_component(status2);
      mounted = false;
      dispose();
    }
  };
}
function instance$3f($$self, $$props, $$invalidate) {
  let $Progress;
  let { runtime } = $$props;
  const { Progress: Progress2 } = runtime;
  component_subscribe($$self, Progress2, (value) => $$invalidate(2, $Progress = value));
  let canceling = false;
  async function cancel() {
    $$invalidate(1, canceling = true);
    await $Progress.cancel();
    runtime.process.handler.kill(runtime.pid, true);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, canceling, $Progress, Progress2, cancel];
}
let Bottom$2 = class Bottom3 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3f, create_fragment$3x, safe_not_equal, { runtime: 0 });
  }
};
function create_fragment$3w(ctx) {
  let div1;
  let div0;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "inner");
      set_style(
        div0,
        "--max",
        /*$Progress*/
        ctx[1].max
      );
      set_style(
        div0,
        "--done",
        /*$Progress*/
        ctx[1].done
      );
      attr(div1, "class", "bar");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$Progress*/
      2) {
        set_style(
          div0,
          "--max",
          /*$Progress*/
          ctx2[1].max
        );
      }
      if (dirty & /*$Progress*/
      2) {
        set_style(
          div0,
          "--done",
          /*$Progress*/
          ctx2[1].done
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
    }
  };
}
function instance$3e($$self, $$props, $$invalidate) {
  let $Progress, $$unsubscribe_Progress = noop$1, $$subscribe_Progress = () => ($$unsubscribe_Progress(), $$unsubscribe_Progress = subscribe(Progress2, ($$value) => $$invalidate(1, $Progress = $$value)), Progress2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_Progress());
  let { runtime } = $$props;
  let { Progress: Progress_1 } = runtime;
  let { Progress: Progress2 = Progress_1 } = $$props;
  $$subscribe_Progress();
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
    if ("Progress" in $$props2)
      $$subscribe_Progress($$invalidate(0, Progress2 = $$props2.Progress));
  };
  return [Progress2, $Progress, runtime];
}
let Bar$1 = class Bar extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3e, create_fragment$3w, safe_not_equal, { runtime: 2, Progress: 0 });
  }
};
function create_fragment$3v(ctx) {
  let div2;
  let div1;
  let img;
  let img_src_value;
  let t0;
  let div0;
  let p0;
  let t1_value = (
    /*$Progress*/
    ctx[1].caption + ""
  );
  let t1;
  let t2;
  let p1;
  let t3_value = (
    /*$Progress*/
    ctx[1].subtitle + ""
  );
  let t3;
  let t4;
  let bar;
  let current;
  bar = new Bar$1({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      img = element("img");
      t0 = space();
      div0 = element("div");
      p0 = element("p");
      t1 = text(t1_value);
      t2 = space();
      p1 = element("p");
      t3 = text(t3_value);
      t4 = space();
      create_component(bar.$$.fragment);
      if (!src_url_equal(img.src, img_src_value = /*$Progress*/
      ctx[1].icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(p0, "class", "caption");
      attr(p1, "class", "subtitle");
      attr(div0, "class", "context");
      attr(div1, "class", "display");
      attr(div2, "class", "top");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, img);
      append(div1, t0);
      append(div1, div0);
      append(div0, p0);
      append(p0, t1);
      append(div0, t2);
      append(div0, p1);
      append(p1, t3);
      append(div2, t4);
      mount_component(bar, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$Progress*/
      2 && !src_url_equal(img.src, img_src_value = /*$Progress*/
      ctx2[1].icon)) {
        attr(img, "src", img_src_value);
      }
      if ((!current || dirty & /*$Progress*/
      2) && t1_value !== (t1_value = /*$Progress*/
      ctx2[1].caption + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & /*$Progress*/
      2) && t3_value !== (t3_value = /*$Progress*/
      ctx2[1].subtitle + ""))
        set_data(t3, t3_value);
      const bar_changes = {};
      if (dirty & /*runtime*/
      1)
        bar_changes.runtime = /*runtime*/
        ctx2[0];
      bar.$set(bar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(bar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(bar);
    }
  };
}
function instance$3d($$self, $$props, $$invalidate) {
  let $Progress;
  let { runtime } = $$props;
  const { Progress: Progress2 } = runtime;
  component_subscribe($$self, Progress2, (value) => $$invalidate(1, $Progress = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, $Progress, Progress2];
}
let Top$1 = class Top extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3d, create_fragment$3v, safe_not_equal, { runtime: 0 });
  }
};
const main$m = "";
function create_if_block$1t(ctx) {
  let top;
  let t2;
  let bottom;
  let current;
  top = new Top$1({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  bottom = new Bottom$2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(top.$$.fragment);
      t2 = space();
      create_component(bottom.$$.fragment);
    },
    m(target, anchor) {
      mount_component(top, target, anchor);
      insert(target, t2, anchor);
      mount_component(bottom, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const top_changes = {};
      if (dirty & /*runtime*/
      1)
        top_changes.runtime = /*runtime*/
        ctx2[0];
      top.$set(top_changes);
      const bottom_changes = {};
      if (dirty & /*runtime*/
      1)
        bottom_changes.runtime = /*runtime*/
        ctx2[0];
      bottom.$set(bottom_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(top.$$.fragment, local);
      transition_in(bottom.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(top.$$.fragment, local);
      transition_out(bottom.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(top, detaching);
      destroy_component(bottom, detaching);
    }
  };
}
function create_fragment$3u(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$Progress*/
    ctx[1] && create_if_block$1t(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$Progress*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$Progress*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1t(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$3c($$self, $$props, $$invalidate) {
  let $Progress;
  let { runtime } = $$props;
  const { Progress: Progress2 } = runtime;
  component_subscribe($$self, Progress2, (value) => $$invalidate(1, $Progress = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, $Progress, Progress2];
}
let App$i = class App13 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3c, create_fragment$3u, safe_not_equal, { runtime: 0 });
  }
};
const FsProgress = {
  metadata: {
    name: "FsProgress",
    description: "Tells you how far filesystem operations are complete",
    author: "The ArcOS Team",
    version: "1.0.0",
    icon: ComponentIcon,
    noCloseAccelerator: true,
    hidden: true,
    appGroup: "internal"
  },
  runtime: Runtime$b,
  content: App$i,
  id: "FsProgress",
  size: { w: 400, h: NaN },
  minSize: { w: 400, h: 160 },
  maxSize: { w: 400, h: NaN },
  pos: { x: 300, y: 300 },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: {
    minimize: false,
    maximize: false,
    close: false
  },
  isOverlay: true,
  loadCondition: () => !SafeMode.get()
};
const BROWSER = true;
function pxToNumber(pxString) {
  if (!pxString.endsWith("px")) {
    return void 0;
  }
  const num = parseFloat(pxString.slice(0, pxString.length - 2));
  return isNaN(num) ? void 0 : num;
}
const getDimensionName = (horizontal) => horizontal ? "height" : "width";
const calcComputedStyle = (element2) => /* @__PURE__ */ window.getComputedStyle(element2);
const getElementRect = (element2) => /* @__PURE__ */ element2.getBoundingClientRect();
const getBordersSizeOffsets = (computedStyle, calcEnds = true) => {
  if (computedStyle.getPropertyValue("box-sizing") === "border-box") {
    return void 0;
  }
  const left = pxToNumber(computedStyle.getPropertyValue("border-left-width"));
  if (left === void 0) {
    console.error("Splitpanes Error: Fail to parse container `border-left-width`.");
    return void 0;
  }
  const top = pxToNumber(computedStyle.getPropertyValue("border-top-width"));
  if (top === void 0) {
    console.error("Splitpanes Error: Fail to parse container `border-top-width`.");
    return void 0;
  }
  const result = { left, top };
  if (calcEnds) {
    const right = pxToNumber(computedStyle.getPropertyValue("border-right-width"));
    if (right === void 0) {
      console.error("Splitpanes Error: Fail to parse container `border-right-width`.");
      return void 0;
    }
    const bottom = pxToNumber(computedStyle.getPropertyValue("border-bottom-width"));
    if (bottom === void 0) {
      console.error("Splitpanes Error: Fail to parse container `border-bottom-width`.");
      return void 0;
    }
    const resultExtended = result;
    resultExtended.right = right;
    resultExtended.bottom = bottom;
  }
  return result;
};
function elementRectWithoutBorder(element2, computedStyle) {
  if (!computedStyle) {
    computedStyle = calcComputedStyle(element2);
  }
  const rect = getElementRect(element2);
  const borderOffsets = getBordersSizeOffsets(computedStyle, true) || { left: 0, top: 0, right: 0, bottom: 0 };
  return {
    width: rect.width - borderOffsets.left - borderOffsets.right,
    height: rect.height - borderOffsets.top - borderOffsets.bottom,
    left: rect.left + borderOffsets.left,
    top: rect.top + borderOffsets.top
  };
}
const positionDiff = (to, from) => ({
  left: to.left - from.left,
  top: to.top - from.top
});
function getGlobalMousePosition(event) {
  const eventMouse = event;
  const eventTouch = event;
  const { clientX, clientY } = "ontouchstart" in window && eventTouch.touches ? eventTouch.touches[0] : eventMouse;
  return { left: clientX, top: clientY };
}
function sumPartial(arr, start2, end, valueFunction) {
  let sum = 0;
  for (let i2 = start2; i2 < end; i2++) {
    sum += valueFunction(arr[i2], i2);
  }
  return sum;
}
function forEachPartial(arr, start2, end, callback) {
  for (let i2 = start2; i2 < end; i2++) {
    callback(arr[i2], i2);
  }
}
const Splitpanes_svelte_svelte_type_style_lang = "";
function create_fragment$3t(ctx) {
  let div;
  let t2;
  let div_class_value;
  let current;
  let if_block = !BROWSER;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  return {
    c() {
      div = element("div");
      t2 = space();
      if (default_slot)
        default_slot.c();
      attr(
        div,
        "id",
        /*id*/
        ctx[0]
      );
      attr(div, "class", div_class_value = `splitpanes ${/*theme*/
      ctx[3] || ""} ${/*clazz*/
      ctx[4] || ""}`);
      attr(
        div,
        "style",
        /*style*/
        ctx[2]
      );
      toggle_class(
        div,
        "splitpanes--horizontal",
        /*horizontal*/
        ctx[1]
      );
      toggle_class(div, "splitpanes--vertical", !/*horizontal*/
      ctx[1]);
      toggle_class(
        div,
        "splitpanes--dragging",
        /*isMouseDown*/
        ctx[7] || /*isDragging*/
        ctx[8]
      );
      toggle_class(div, "splitpanes--freeze", !/*isAfterInitialTimeoutZero*/
      ctx[6]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[17](div);
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*id*/
      1) {
        attr(
          div,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*theme, clazz*/
      24 && div_class_value !== (div_class_value = `splitpanes ${/*theme*/
      ctx2[3] || ""} ${/*clazz*/
      ctx2[4] || ""}`)) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*style*/
      4) {
        attr(
          div,
          "style",
          /*style*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*theme, clazz, horizontal*/
      26) {
        toggle_class(
          div,
          "splitpanes--horizontal",
          /*horizontal*/
          ctx2[1]
        );
      }
      if (!current || dirty[0] & /*theme, clazz, horizontal*/
      26) {
        toggle_class(div, "splitpanes--vertical", !/*horizontal*/
        ctx2[1]);
      }
      if (!current || dirty[0] & /*theme, clazz, isMouseDown, isDragging*/
      408) {
        toggle_class(
          div,
          "splitpanes--dragging",
          /*isMouseDown*/
          ctx2[7] || /*isDragging*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*theme, clazz, isAfterInitialTimeoutZero*/
      88) {
        toggle_class(div, "splitpanes--freeze", !/*isAfterInitialTimeoutZero*/
        ctx2[6]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[17](null);
    }
  };
}
const KEY = {};
function instance$3b($$self, $$props, $$invalidate) {
  let $veryFirstPaneKey;
  let $showFirstSplitter;
  let $isHorizontal;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { id = void 0 } = $$props;
  let { horizontal = false } = $$props;
  let { pushOtherPanes = true } = $$props;
  let { dblClickSplitter = true } = $$props;
  let { rtl = "auto" } = $$props;
  let { firstSplitter = false } = $$props;
  let { style: style2 = null } = $$props;
  let { theme = "default-theme" } = $$props;
  let { class: clazz = "" } = $$props;
  const dispatch = createEventDispatcher();
  let container;
  let isReady = false;
  let isAwaitingPaneReset = false;
  let isAfterInitialTimeoutZero = false;
  let isMouseDown = false;
  let isDragging = false;
  let activeSplitter = -1;
  let clickedSplitter = -1;
  let timeoutId;
  let panes = new Array();
  let isHorizontal = writable(horizontal);
  component_subscribe($$self, isHorizontal, (value) => $$invalidate(31, $isHorizontal = value));
  const showFirstSplitter = writable(firstSplitter);
  component_subscribe($$self, showFirstSplitter, (value) => $$invalidate(30, $showFirstSplitter = value));
  const veryFirstPaneKey = writable(void 0);
  component_subscribe($$self, veryFirstPaneKey, (value) => $$invalidate(29, $veryFirstPaneKey = value));
  let activeSplitterElement = null;
  let activeSplitterDrag = null;
  const onPaneInit = (key2) => {
    if ($veryFirstPaneKey === void 0) {
      set_store_value(veryFirstPaneKey, $veryFirstPaneKey = key2, $veryFirstPaneKey);
    }
    return {
      undefinedPaneInitSize: 0
    };
  };
  setContext(KEY, {
    showFirstSplitter,
    veryFirstPaneKey,
    isHorizontal,
    ssrRegisterPaneSize: void 0,
    onPaneInit,
    clientOnly: { onPaneAdd, onPaneRemove }
  });
  function onPaneAdd(pane) {
    let index = -1;
    Array.from(pane.element.parentNode.children).some((el) => {
      if (el.className.includes("splitpanes__pane"))
        index++;
      return el === pane.element;
    });
    if (index === 0) {
      set_store_value(veryFirstPaneKey, $veryFirstPaneKey = pane.key, $veryFirstPaneKey);
    }
    panes.splice(index, 0, pane);
    for (let i2 = 0; i2 < panes.length; i2++) {
      panes[i2].index = i2;
    }
    if (isReady) {
      tickAndResetPaneSizes().then(() => {
        pane.isReady = true;
        dispatch("pane-add", { index, panes: prepareSizeEvent() });
      });
    }
    const paneForward = (cb, includingFirst = true) => (value) => {
      if (includingFirst || pane.index > 0) {
        cb(value, pane);
      }
    };
    return {
      onSplitterDown: paneForward(onMouseDown, false),
      onSplitterClick: paneForward(onSplitterClick, false),
      onSplitterDblClick: paneForward(onSplitterDblClick),
      onPaneClick: paneForward(onPaneClick),
      reportGivenSizeChange: paneForward(reportGivenSizeChange)
    };
  }
  async function onPaneRemove(key2) {
    const index = panes.findIndex((p2) => p2.key === key2);
    if (index >= 0) {
      const removed = panes.splice(index, 1)[0];
      for (let i2 = 0; i2 < panes.length; i2++) {
        panes[i2].index = i2;
      }
      if (index === 0) {
        set_store_value(veryFirstPaneKey, $veryFirstPaneKey = panes.length > 0 ? panes[0].key : void 0, $veryFirstPaneKey);
      }
      if (isReady) {
        await tickAndResetPaneSizes();
        dispatch("pane-remove", { removed, panes: prepareSizeEvent() });
      }
    }
  }
  function onPaneClick(_event, pane) {
    dispatch("pane-click", pane);
  }
  function reportGivenSizeChange(newGivenSize, pane) {
    pane.setSz(newGivenSize);
    tickAndResetPaneSizes();
  }
  onMount(() => {
    verifyAndUpdatePanesOrder();
    resetPaneSizes();
    for (let i2 = 0; i2 < panes.length; i2++) {
      panes[i2].isReady = true;
    }
    isReady = true;
    dispatch("ready");
    setTimeout(
      () => {
        $$invalidate(6, isAfterInitialTimeoutZero = true);
      },
      0
    );
  });
  {
    onDestroy(() => {
      if (isReady) {
        unbindEvents();
      }
      isReady = false;
    });
  }
  afterUpdate(() => {
    verifyAndUpdatePanesOrder();
  });
  function isRTL(containerComputedStyle) {
    if (rtl === "auto") {
      try {
        return (containerComputedStyle ?? calcComputedStyle(container)).direction === "rtl";
      } catch (err2) {
      }
    }
    return rtl === true;
  }
  function bindEvents() {
    document.body.style.cursor = isHorizontal ? "col-resize" : "row-resize";
    document.addEventListener("mousemove", onMouseMove, { passive: false });
    document.addEventListener("mouseup", onMouseUp);
    if ("ontouchstart" in window) {
      document.addEventListener("touchmove", onMouseMove, { passive: false });
      document.addEventListener("touchend", onMouseUp);
    }
  }
  function unbindEvents() {
    document.body.style.cursor = "";
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    if ("ontouchstart" in window) {
      document.removeEventListener("touchmove", onMouseMove);
      document.removeEventListener("touchend", onMouseUp);
    }
  }
  const isSplitterElement = (node) => node.nodeType === Node.ELEMENT_NODE && node.classList.contains("splitpanes__splitter");
  function getOrientedDiff(drag, elementSize, isRTL2) {
    let tdrag = drag[horizontal ? "top" : "left"];
    if (isRTL2 && !horizontal)
      tdrag = elementSize - tdrag;
    return tdrag;
  }
  const getCurrentDimensionName = () => getDimensionName(horizontal);
  function onMouseDown(event, splitterPane) {
    $$invalidate(7, isMouseDown = true);
    activeSplitter = splitterPane.index;
    splitterPane.setSplitterActive(true);
    const paneElement = splitterPane.element;
    let activeSplitterNode = paneElement;
    while (activeSplitterNode != null) {
      activeSplitterNode = activeSplitterNode.previousSibling;
      if (isSplitterElement(activeSplitterNode)) {
        break;
      }
    }
    if (activeSplitterNode == null) {
      console.error("Splitpane Error: Active splitter wasn't found!");
      return;
    }
    activeSplitterElement = activeSplitterNode;
    const globalMousePosition = getGlobalMousePosition(event);
    const splitterRect = getElementRect(activeSplitterElement);
    activeSplitterDrag = getOrientedDiff(positionDiff(globalMousePosition, splitterRect), splitterRect[getCurrentDimensionName()], isRTL());
    bindEvents();
  }
  function onMouseMove(event) {
    if (isMouseDown) {
      event.preventDefault();
      $$invalidate(8, isDragging = true);
      const globalMousePosition = getGlobalMousePosition(event);
      const containerComputedStyle = calcComputedStyle(container);
      const containerRectWithoutBorder = elementRectWithoutBorder(container, containerComputedStyle);
      const containerSizeWithoutBorder = containerRectWithoutBorder[getCurrentDimensionName()];
      const _isRTL = isRTL(containerComputedStyle);
      const currentMouseDrag = positionDiff(globalMousePosition, containerRectWithoutBorder);
      const tdrag = getOrientedDiff(currentMouseDrag, containerSizeWithoutBorder, _isRTL);
      calculatePanesSize(tdrag, containerSizeWithoutBorder);
      dispatch("resize", prepareSizeEvent());
    }
  }
  function onMouseUp() {
    if (isDragging) {
      dispatch("resized", prepareSizeEvent());
    }
    $$invalidate(7, isMouseDown = false);
    const pane = panes[activeSplitter];
    pane.setSplitterActive(false);
    setTimeout(
      () => {
        $$invalidate(8, isDragging = false);
        unbindEvents();
      },
      100
    );
  }
  function onSplitterClick(event, splitterPane) {
    if ("ontouchstart" in window) {
      event.preventDefault();
      const splitterIndex = splitterPane.index;
      if (dblClickSplitter) {
        if (clickedSplitter === splitterIndex) {
          if (timeoutId)
            clearTimeout(timeoutId);
          timeoutId = null;
          onSplitterDblClick(event, splitterPane);
          clickedSplitter = -1;
        } else {
          clickedSplitter = splitterIndex;
          timeoutId = setTimeout(
            () => {
              clickedSplitter = -1;
            },
            500
          );
        }
      }
    }
    if (!isDragging)
      dispatch("splitter-click", splitterPane);
  }
  function onSplitterDblClick(_event, splitterPane) {
    if (dblClickSplitter) {
      const splitterIndex = splitterPane.index;
      let totalMinSizes = 0;
      for (let i2 = 0; i2 < panes.length; i2++) {
        const pane = panes[i2];
        if (i2 !== splitterIndex) {
          totalMinSizes += pane.min();
        }
      }
      const maxExtendedSize = Math.min(Math.max(0, 100 - totalMinSizes), splitterPane.max());
      const totalMaxExtendedPlusMinSizes = totalMinSizes + maxExtendedSize;
      if (totalMaxExtendedPlusMinSizes >= 100) {
        for (let i2 = 0; i2 < panes.length; i2++) {
          const pane = panes[i2];
          if (pane !== splitterPane) {
            pane.setSz(pane.min());
          } else {
            pane.setSz(100 - totalMinSizes);
          }
        }
      } else {
        let leftSpare = 100 - totalMaxExtendedPlusMinSizes;
        splitterPane.setSz(maxExtendedSize);
        const giveBest = (pane) => {
          const min = pane.min();
          const max = pane.max();
          const szExtra = Math.min(Math.max(0, leftSpare), max - min);
          pane.setSz(min + szExtra);
          leftSpare -= szExtra;
        };
        for (let i2 = splitterIndex - 1; i2 >= 0; i2--)
          giveBest(panes[i2]);
        for (let i2 = splitterIndex + 1; i2 < panes.length; i2++)
          giveBest(panes[i2]);
        if (leftSpare != 0) {
          console.warn("Splitpanes: there is a left spare size after computation of splitter double click, which means there are issues on the size constains of the panes.");
        }
      }
      dispatch("pane-maximize", splitterPane);
      dispatch("resized", prepareSizeEvent());
    }
    $$invalidate(7, isMouseDown = false);
  }
  const prepareSizeEvent = () => panes.map((pane) => ({
    min: pane.min(),
    max: pane.max(),
    size: pane.sz(),
    snap: pane.snap()
  }));
  function getCurrentDragPercentage(tdrag, containerSizeWithoutBorder) {
    const splitterSize = (node) => getElementRect(node)[getCurrentDimensionName()];
    const activeSplitterSize = splitterSize(activeSplitterElement);
    let splittersTotalSizeBefore = 0;
    let currentBeforeNode = activeSplitterElement.previousSibling;
    while (currentBeforeNode != null) {
      if (isSplitterElement(currentBeforeNode)) {
        splittersTotalSizeBefore += splitterSize(currentBeforeNode);
      }
      currentBeforeNode = currentBeforeNode.previousSibling;
    }
    let splittersTotalSizeAfter = 0;
    let currentAfterNode = activeSplitterElement.nextSibling;
    while (currentAfterNode != null) {
      if (isSplitterElement(currentAfterNode)) {
        splittersTotalSizeAfter += splitterSize(currentAfterNode);
      }
      currentAfterNode = currentAfterNode.nextSibling;
    }
    const totalSplitterBefore = splittersTotalSizeBefore + activeSplitterDrag;
    const totalSplitter = splittersTotalSizeBefore + activeSplitterSize + splittersTotalSizeAfter;
    return (tdrag - totalSplitterBefore) / (containerSizeWithoutBorder - totalSplitter) * 100;
  }
  function calculatePanesSize(tdrag, containerSizeWithoutBorder) {
    let paneBeforeIndex = activeSplitter - 1;
    let paneBefore = panes[paneBeforeIndex];
    let paneAfterIndex = activeSplitter;
    let paneAfter = panes[paneAfterIndex];
    let sums = {
      prevPanesSize: sumPrevPanesSize(paneBeforeIndex),
      nextPanesSize: sumNextPanesSize(paneAfterIndex),
      prevReachedMinPanes: 0,
      nextReachedMinPanes: 0
    };
    const minDrag = 0 + (pushOtherPanes ? 0 : sums.prevPanesSize);
    const maxDrag = 100 - (pushOtherPanes ? 0 : sums.nextPanesSize);
    const mouseDragPercentage = Math.max(Math.min(getCurrentDragPercentage(tdrag, containerSizeWithoutBorder), maxDrag), minDrag);
    const paneBeforeSnap = sums.prevPanesSize + paneBefore.min() + paneBefore.snap();
    const paneAfterSnap = 100 - (sums.nextPanesSize + paneAfter.min() + paneAfter.snap());
    let dragPercentage = mouseDragPercentage;
    let snapped = false;
    if (mouseDragPercentage <= paneBeforeSnap) {
      if (mouseDragPercentage > sums.prevPanesSize + paneBefore.min()) {
        dragPercentage = Math.max(paneBefore.min() + sums.prevPanesSize, 100 - (paneAfter.max() + sums.nextPanesSize));
        snapped = true;
      }
    } else if (mouseDragPercentage >= paneAfterSnap) {
      if (mouseDragPercentage < 100 - sums.nextPanesSize - paneAfter.min()) {
        dragPercentage = Math.min(100 - (paneAfter.min() + sums.nextPanesSize), paneBefore.max() + sums.prevPanesSize);
        snapped = true;
      }
    }
    const paneBeforeMaxReached = paneBefore.max() < 100 && dragPercentage >= paneBefore.max() + sums.prevPanesSize;
    const paneAfterMaxReached = paneAfter.max() < 100 && dragPercentage <= 100 - (paneAfter.max() + sums.nextPanesSize);
    if (paneBeforeMaxReached || paneAfterMaxReached) {
      if (paneBeforeMaxReached) {
        paneBefore.setSz(paneBefore.max());
        paneAfter.setSz(Math.max(100 - paneBefore.max() - sums.prevPanesSize - sums.nextPanesSize, 0));
      } else {
        paneBefore.setSz(Math.max(100 - paneAfter.max() - sums.prevPanesSize - sums.nextPanesSize, 0));
        paneAfter.setSz(paneAfter.max());
      }
    } else {
      if (pushOtherPanes && !snapped) {
        const vars = doPushOtherPanes(sums, dragPercentage);
        if (!vars) {
          return;
        }
        ({ sums, paneBeforeIndex, paneAfterIndex } = vars);
        paneBefore = panes[paneBeforeIndex];
        paneAfter = panes[paneAfterIndex];
      }
      if (paneBeforeIndex != null) {
        paneBefore.setSz(Math.min(Math.max(dragPercentage - sums.prevPanesSize - sums.prevReachedMinPanes, paneBefore.min()), paneBefore.max()));
      }
      if (paneAfterIndex != null) {
        paneAfter.setSz(Math.min(Math.max(100 - dragPercentage - sums.nextPanesSize - sums.nextReachedMinPanes, paneAfter.min()), paneAfter.max()));
      }
    }
  }
  function doPushOtherPanes(sums, dragPercentage) {
    var _a, _b;
    const splitterIndex = activeSplitter - 1;
    let paneBeforeIndex = splitterIndex;
    let paneAfterIndex = splitterIndex + 1;
    if (dragPercentage < sums.prevPanesSize + panes[paneBeforeIndex].min()) {
      paneBeforeIndex = (_a = findPrevExpandedPane(splitterIndex)) == null ? void 0 : _a.index;
      sums.prevReachedMinPanes = 0;
      if (paneBeforeIndex < splitterIndex) {
        forEachPartial(panes, paneBeforeIndex + 1, splitterIndex + 1, (pane) => {
          pane.setSz(pane.min());
          sums.prevReachedMinPanes += pane.min();
        });
      }
      sums.prevPanesSize = sumPrevPanesSize(paneBeforeIndex);
      if (paneBeforeIndex == null) {
        sums.prevReachedMinPanes = 0;
        panes[0].setSz(panes[0].min());
        forEachPartial(panes, 1, splitterIndex + 1, (pane) => {
          pane.setSz(pane.min());
          sums.prevReachedMinPanes += pane.min();
        });
        panes[paneAfterIndex].setSz(100 - sums.prevReachedMinPanes - panes[0].min() - sums.prevPanesSize - sums.nextPanesSize);
        return null;
      }
    }
    if (dragPercentage > 100 - sums.nextPanesSize - panes[paneAfterIndex].min()) {
      paneAfterIndex = (_b = findNextExpandedPane(splitterIndex)) == null ? void 0 : _b.index;
      sums.nextReachedMinPanes = 0;
      if (paneAfterIndex > splitterIndex + 1) {
        forEachPartial(panes, splitterIndex + 1, paneAfterIndex, (pane) => {
          pane.setSz(pane.min());
          sums.nextReachedMinPanes += pane.min();
        });
      }
      sums.nextPanesSize = sumNextPanesSize(paneAfterIndex);
      const panesCount = panes.length;
      if (paneAfterIndex == null) {
        sums.nextReachedMinPanes = 0;
        panes[panesCount - 1].setSz(panes[panesCount - 1].min());
        forEachPartial(panes, splitterIndex + 1, panesCount - 1, (pane) => {
          pane.setSz(pane.min());
          sums.nextReachedMinPanes += pane.min();
        });
        panes[paneBeforeIndex].setSz(100 - sums.prevPanesSize - sums.nextReachedMinPanes - panes[panesCount - 1].min() - sums.nextPanesSize);
        return null;
      }
    }
    return { sums, paneBeforeIndex, paneAfterIndex };
  }
  const getSizeOfPane = (pane) => pane.sz();
  const sumPrevPanesSize = (splitterIndex) => sumPartial(panes, 0, splitterIndex, getSizeOfPane);
  const sumNextPanesSize = (splitterIndex) => sumPartial(panes, splitterIndex + 1, panes.length, getSizeOfPane);
  const findPrevExpandedPane = (splitterIndex) => [...panes].reverse().find((p2) => p2.index < splitterIndex && p2.sz() > p2.min());
  const findNextExpandedPane = (splitterIndex) => panes.find((p2) => p2.index > splitterIndex + 1 && p2.sz() > p2.min());
  async function tickAndResetPaneSizes() {
    isAwaitingPaneReset = true;
    await tick();
    if (isAwaitingPaneReset) {
      resetPaneSizes();
      isAwaitingPaneReset = false;
    }
  }
  function resetPaneSizes() {
    equalize();
    if (isReady)
      dispatch("resized", prepareSizeEvent());
  }
  function equalize() {
    if (panes.length === 0) {
      return;
    }
    const panesCount = panes.length;
    let leftToAllocate = 100;
    let definedSizesCount = 0;
    let undefinedSizesNotReadyCount = 0;
    let undefinedSizesSum = 0;
    let ungrowable = [];
    let unshrinkable = [];
    for (let i2 = 0; i2 < panesCount; i2++) {
      const pane = panes[i2];
      const sz = pane.sz();
      if (pane.givenSize == null) {
        if (pane.isReady) {
          undefinedSizesSum += sz;
          if (sz >= pane.max())
            ungrowable.push(pane);
          if (sz <= pane.min())
            unshrinkable.push(pane);
        } else {
          undefinedSizesNotReadyCount += 1;
        }
      } else {
        leftToAllocate -= sz;
        definedSizesCount++;
        ungrowable.push(pane);
        unshrinkable.push(pane);
      }
    }
    const undefinedSizesCount = panesCount - definedSizesCount;
    const undefinedSizesReadyCount = undefinedSizesCount - undefinedSizesNotReadyCount;
    let undefinedSizesNotReadySz;
    let undefinedScaleFactor;
    if (undefinedSizesReadyCount > 0) {
      undefinedSizesNotReadySz = undefinedSizesSum / undefinedSizesReadyCount;
      if (undefinedSizesNotReadySz > 0.1 && leftToAllocate > 0.1) {
        undefinedSizesSum += undefinedSizesNotReadyCount * undefinedSizesNotReadySz;
        undefinedScaleFactor = leftToAllocate / undefinedSizesSum;
      } else {
        undefinedSizesNotReadySz = 0;
        undefinedScaleFactor = 1;
      }
    } else {
      undefinedSizesNotReadySz = leftToAllocate / undefinedSizesCount;
      undefinedScaleFactor = 1;
    }
    if (leftToAllocate + undefinedSizesSum > 0.1) {
      leftToAllocate = 100;
      for (let i2 = 0; i2 < panesCount; i2++) {
        const pane = panes[i2];
        if (pane.givenSize == null) {
          const currentSz = pane.isReady ? pane.sz() : undefinedSizesNotReadySz;
          const sz = Math.max(Math.min(currentSz * undefinedScaleFactor, pane.max()), pane.min());
          pane.setSz(sz);
        }
        leftToAllocate -= pane.sz();
      }
      if (Math.abs(leftToAllocate) > 0.1) {
        leftToAllocate = readjustSizes(leftToAllocate, ungrowable, unshrinkable);
      }
    }
    if (!isFinite(leftToAllocate)) {
      console.warn("Splitpanes: Internal error, sizes might be NaN as a result.");
    } else if (Math.abs(leftToAllocate) > 0.1) {
      console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
    }
  }
  function readjustSizes(leftToAllocate, ungrowable, unshrinkable) {
    const panesCount = panes.length;
    const panesSizableCount = panesCount - (leftToAllocate > 0 ? ungrowable.length : unshrinkable.length);
    if (panesSizableCount <= 0) {
      return leftToAllocate;
    }
    const equalSpaceToAllocate = leftToAllocate / panesSizableCount;
    if (panes.length === 1) {
      panes[0].setSz(100);
      leftToAllocate = 0;
    } else
      for (let i2 = 0; i2 < panes.length; i2++) {
        const pane = panes[i2];
        const sz = pane.sz();
        if (leftToAllocate > 0 && !ungrowable.includes(pane)) {
          const newPaneSize = Math.max(Math.min(sz + equalSpaceToAllocate, pane.max()), pane.min());
          const allocated = newPaneSize - sz;
          leftToAllocate -= allocated;
          pane.setSz(newPaneSize);
        } else if (!unshrinkable.includes(pane)) {
          const newPaneSize = Math.max(Math.min(sz + equalSpaceToAllocate, pane.max()), pane.min());
          const allocated = newPaneSize - sz;
          leftToAllocate -= allocated;
          pane.setSz(newPaneSize);
        }
      }
    return leftToAllocate;
  }
  function verifyAndUpdatePanesOrder() {
    var _a;
    const { children: children2 } = container;
    let currentPaneIndex = 0;
    let needReorder = false;
    for (let i2 = 0; i2 < children2.length; i2++) {
      const child = children2.item(i2);
      const isPane = child.classList.contains("splitpanes__pane");
      const isSplitter = child.classList.contains("splitpanes__splitter");
      if (!isPane && !isSplitter) {
        (_a = child.parentNode) == null ? void 0 : _a.removeChild(child);
        console.warn("Splitpanes: Only <Pane> elements are allowed at the root of <Splitpanes>. One of your DOM nodes was removed.");
        return;
      } else if (isPane) {
        if (!needReorder && panes[currentPaneIndex].element !== child) {
          needReorder = true;
        }
        currentPaneIndex++;
      }
    }
    if (needReorder) {
      const newPanes = [];
      for (let i2 = 0; i2 < children2.length; i2++) {
        const child = children2.item(i2);
        const isPane = child.classList.contains("splitpanes__pane");
        if (isPane) {
          const pane = panes.find((pane2) => pane2.element === child);
          if (pane != null) {
            pane.index = newPanes.length;
            newPanes.push(pane);
          } else {
            console.warn("Splitpanes: Internal error - found a <Pane> elements which isn't tracked.");
          }
        }
      }
      panes = newPanes;
      set_store_value(veryFirstPaneKey, $veryFirstPaneKey = panes.length > 0 ? panes[0].key : void 0, $veryFirstPaneKey);
    }
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(5, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("horizontal" in $$props2)
      $$invalidate(1, horizontal = $$props2.horizontal);
    if ("pushOtherPanes" in $$props2)
      $$invalidate(12, pushOtherPanes = $$props2.pushOtherPanes);
    if ("dblClickSplitter" in $$props2)
      $$invalidate(13, dblClickSplitter = $$props2.dblClickSplitter);
    if ("rtl" in $$props2)
      $$invalidate(14, rtl = $$props2.rtl);
    if ("firstSplitter" in $$props2)
      $$invalidate(15, firstSplitter = $$props2.firstSplitter);
    if ("style" in $$props2)
      $$invalidate(2, style2 = $$props2.style);
    if ("theme" in $$props2)
      $$invalidate(3, theme = $$props2.theme);
    if ("class" in $$props2)
      $$invalidate(4, clazz = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*horizontal*/
    2) {
      set_store_value(isHorizontal, $isHorizontal = horizontal, $isHorizontal);
    }
    if ($$self.$$.dirty[0] & /*firstSplitter*/
    32768) {
      set_store_value(showFirstSplitter, $showFirstSplitter = firstSplitter, $showFirstSplitter);
    }
  };
  return [
    id,
    horizontal,
    style2,
    theme,
    clazz,
    container,
    isAfterInitialTimeoutZero,
    isMouseDown,
    isDragging,
    isHorizontal,
    showFirstSplitter,
    veryFirstPaneKey,
    pushOtherPanes,
    dblClickSplitter,
    rtl,
    firstSplitter,
    slots,
    div_binding,
    $$scope
  ];
}
class Splitpanes extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(
      this,
      options2,
      instance$3b,
      create_fragment$3t,
      safe_not_equal,
      {
        id: 0,
        horizontal: 1,
        pushOtherPanes: 12,
        dblClickSplitter: 13,
        rtl: 14,
        firstSplitter: 15,
        style: 2,
        theme: 3,
        class: 4
      },
      null,
      [-1, -1, -1]
    );
  }
}
const carefullCallbackGenerator = (callbackObjectGetter, callbackName) => (value) => {
  const callbackObject = callbackObjectGetter();
  if (callbackObject != null) {
    callbackObject[callbackName](value);
  }
};
const carefullCallbackSource = (callbackObjectGetter) => carefullCallbackGenerator.bind(null, callbackObjectGetter);
function create_if_block$1s(ctx) {
  let t2;
  let div;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$veryFirstPaneKey*/
    (ctx[4] !== /*key*/
    ctx[9] || /*$showFirstSplitter*/
    ctx[5]) && create_if_block_1$u(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      t2 = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", div_class_value = `splitpanes__pane ${/*clazz*/
      ctx[0] || ""}`);
      attr(
        div,
        "style",
        /*style*/
        ctx[3]
      );
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[21](div);
      current = true;
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*carefullClientCallbacks*/
          ctx[11]("onPaneClick")
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*$veryFirstPaneKey*/
        ctx2[4] !== /*key*/
        ctx2[9] || /*$showFirstSplitter*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$u(ctx2);
          if_block.c();
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*clazz*/
      1 && div_class_value !== (div_class_value = `splitpanes__pane ${/*clazz*/
      ctx2[0] || ""}`)) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*style*/
      8) {
        attr(
          div,
          "style",
          /*style*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(div);
      }
      if (if_block)
        if_block.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      ctx[21](null);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$u(ctx) {
  let div;
  let div_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = "splitpanes__splitter " + /*isSplitterActive*/
      (ctx[2] ? "splitpanes__splitter__active" : ""));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          listen(
            div,
            "mousedown",
            /*carefullClientCallbacks*/
            ctx[11]("onSplitterDown")
          ),
          listen(
            div,
            "touchstart",
            /*carefullClientCallbacks*/
            ctx[11]("onSplitterDown")
          ),
          listen(
            div,
            "click",
            /*carefullClientCallbacks*/
            ctx[11]("onSplitterClick")
          ),
          listen(
            div,
            "dblclick",
            /*carefullClientCallbacks*/
            ctx[11]("onSplitterDblClick")
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*isSplitterActive*/
      4 && div_class_value !== (div_class_value = "splitpanes__splitter " + /*isSplitterActive*/
      (ctx2[2] ? "splitpanes__splitter__active" : ""))) {
        attr(div, "class", div_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$3s(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*gathering*/
  ctx[10] && create_if_block$1s(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*gathering*/
      ctx2[10])
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$3a($$self, $$props, $$invalidate) {
  let dimension;
  let style2;
  let $isHorizontal;
  let $veryFirstPaneKey;
  let $showFirstSplitter;
  let { $$slots: slots = {}, $$scope } = $$props;
  const { ssrRegisterPaneSize, onPaneInit, clientOnly: clientOnlyContext, isHorizontal, showFirstSplitter, veryFirstPaneKey } = getContext(KEY);
  component_subscribe($$self, isHorizontal, (value) => $$invalidate(18, $isHorizontal = value));
  component_subscribe($$self, showFirstSplitter, (value) => $$invalidate(5, $showFirstSplitter = value));
  component_subscribe($$self, veryFirstPaneKey, (value) => $$invalidate(4, $veryFirstPaneKey = value));
  let { size = null } = $$props;
  let { minSize = 0 } = $$props;
  let { maxSize = 100 } = $$props;
  let { snapSize = 0 } = $$props;
  let { class: clazz = "" } = $$props;
  const key2 = {};
  const gathering = !BROWSER;
  const { undefinedPaneInitSize } = onPaneInit(key2);
  let element2;
  let sz = size ?? undefinedPaneInitSize;
  let isSplitterActive = false;
  let clientCallbacks = void 0;
  const carefullClientCallbacks = carefullCallbackSource(() => clientCallbacks);
  const reportGivenSizeChangeSafe = (size2) => {
    if (size2 != sz) {
      carefullClientCallbacks("reportGivenSizeChange")(size2);
    }
  };
  {
    onMount(() => {
      const inst = {
        key: key2,
        element: element2,
        givenSize: size,
        sz: () => sz,
        setSz: (v2) => {
          $$invalidate(16, sz = v2);
          if (size != null && size != sz) {
            $$invalidate(12, size = sz);
          }
        },
        min: () => minSize,
        max: () => maxSize,
        snap: () => snapSize,
        setSplitterActive: (isActive) => {
          $$invalidate(2, isSplitterActive = isActive);
        },
        isReady: false
      };
      clientCallbacks = clientOnlyContext.onPaneAdd(inst);
    });
    onDestroy(() => {
      clientOnlyContext.onPaneRemove(key2);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(12, size = $$props2.size);
    if ("minSize" in $$props2)
      $$invalidate(13, minSize = $$props2.minSize);
    if ("maxSize" in $$props2)
      $$invalidate(14, maxSize = $$props2.maxSize);
    if ("snapSize" in $$props2)
      $$invalidate(15, snapSize = $$props2.snapSize);
    if ("class" in $$props2)
      $$invalidate(0, clazz = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(19, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*size*/
    4096) {
      {
        if (size != null) {
          reportGivenSizeChangeSafe(size);
        }
      }
    }
    if ($$self.$$.dirty & /*$isHorizontal*/
    262144) {
      $$invalidate(17, dimension = getDimensionName($isHorizontal));
    }
    if ($$self.$$.dirty & /*dimension, sz*/
    196608) {
      $$invalidate(3, style2 = `${dimension}: ${sz}%;`);
    }
  };
  return [
    clazz,
    element2,
    isSplitterActive,
    style2,
    $veryFirstPaneKey,
    $showFirstSplitter,
    isHorizontal,
    showFirstSplitter,
    veryFirstPaneKey,
    key2,
    gathering,
    carefullClientCallbacks,
    size,
    minSize,
    maxSize,
    snapSize,
    sz,
    dimension,
    $isHorizontal,
    $$scope,
    slots,
    div_binding
  ];
}
class Pane extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3a, create_fragment$3s, safe_not_equal, {
      size: 12,
      minSize: 13,
      maxSize: 14,
      snapSize: 15,
      class: 0
    });
  }
}
function supressWarnings() {
  const origWarn = console.warn;
  console.warn = (message) => {
    if (message.includes("unknown prop"))
      return;
    if (message.includes("unexpected slot"))
      return;
    origWarn(message);
  };
  onMount(() => {
    console.warn = origWarn;
  });
}
function get_each_context_5(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list2[i2];
  return child_ctx;
}
function get_each_context_4(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list2[i2];
  return child_ctx;
}
function get_each_context_1$5(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list2[i2];
  return child_ctx;
}
function get_each_context_2$1(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list2[i2];
  child_ctx[15] = i2;
  return child_ctx;
}
function get_each_context_3(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list2[i2];
  child_ctx[15] = i2;
  return child_ctx;
}
function get_each_context$C(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list2[i2];
  return child_ctx;
}
function create_if_block_1$t(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2$b, create_if_block_3$5, create_else_block_1$2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*type*/
      ctx2[0] === "table"
    )
      return 0;
    if (
      /*type*/
      ctx2[0] === "list"
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block$1r(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*tokens*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$C(get_each_context$C(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*tokens, renderers*/
      34) {
        each_value = ensure_array_like(
          /*tokens*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$C(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$C(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block_1$2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*$$restProps*/
    ctx[6]
  ];
  var switch_value = (
    /*renderers*/
    ctx[5][
      /*type*/
      ctx[0]
    ]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx: ctx2 }
    };
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty & /*$$restProps*/
    64) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[6]
      )]));
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers, type*/
      33 && switch_value !== (switch_value = /*renderers*/
      ctx2[5][
        /*type*/
        ctx2[0]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*$$restProps*/
        64 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )]) : {};
        if (dirty & /*$$scope, tokens, renderers, $$restProps*/
        8388706) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_3$5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4$2, create_else_block$n];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*ordered*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_2$b(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].table
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot$k] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].table)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$scope, renderers, rows, $$restProps, header*/
        8388716) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_else_block_2(ctx) {
  let t_value = (
    /*$$restProps*/
    ctx[6].raw + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$$restProps*/
      64 && t_value !== (t_value = /*$$restProps*/
      ctx2[6].raw + ""))
        set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_5$1(ctx) {
  let parser;
  let current;
  parser = new Parser$1({
    props: {
      tokens: (
        /*tokens*/
        ctx[1]
      ),
      renderers: (
        /*renderers*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      create_component(parser.$$.fragment);
    },
    m(target, anchor) {
      mount_component(parser, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const parser_changes = {};
      if (dirty & /*tokens*/
      2)
        parser_changes.tokens = /*tokens*/
        ctx2[1];
      if (dirty & /*renderers*/
      32)
        parser_changes.renderers = /*renderers*/
        ctx2[5];
      parser.$set(parser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(parser, detaching);
    }
  };
}
function create_default_slot_11(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_5$1, create_else_block_2];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*tokens*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_3(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$n(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { ordered: (
      /*ordered*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  var switch_value = (
    /*renderers*/
    ctx[5].list
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_9$1] },
      $$scope: { ctx: ctx2 }
    };
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty & /*ordered, $$restProps*/
    80) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty & /*ordered*/
        16 && { ordered: (
          /*ordered*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].list)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*ordered, $$restProps*/
        80 ? get_spread_update(switch_instance_spread_levels, [
          dirty & /*ordered*/
          16 && { ordered: (
            /*ordered*/
            ctx2[4]
          ) },
          dirty & /*$$restProps*/
          64 && get_spread_object(
            /*$$restProps*/
            ctx2[6]
          )
        ]) : {};
        if (dirty & /*$$scope, $$restProps, renderers*/
        8388704) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_4$2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { ordered: (
      /*ordered*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  var switch_value = (
    /*renderers*/
    ctx[5].list
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_7$1] },
      $$scope: { ctx: ctx2 }
    };
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty & /*ordered, $$restProps*/
    80) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty & /*ordered*/
        16 && { ordered: (
          /*ordered*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].list)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*ordered, $$restProps*/
        80 ? get_spread_update(switch_instance_spread_levels, [
          dirty & /*ordered*/
          16 && { ordered: (
            /*ordered*/
            ctx2[4]
          ) },
          dirty & /*$$restProps*/
          64 && get_spread_object(
            /*$$restProps*/
            ctx2[6]
          )
        ]) : {};
        if (dirty & /*$$scope, $$restProps, renderers*/
        8388704) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_10(ctx) {
  let parser;
  let t2;
  let current;
  parser = new Parser$1({
    props: {
      tokens: (
        /*item*/
        ctx[18].tokens
      ),
      renderers: (
        /*renderers*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      create_component(parser.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(parser, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const parser_changes = {};
      if (dirty & /*$$restProps*/
      64)
        parser_changes.tokens = /*item*/
        ctx2[18].tokens;
      if (dirty & /*renderers*/
      32)
        parser_changes.renderers = /*renderers*/
        ctx2[5];
      parser.$set(parser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(parser, detaching);
    }
  };
}
function create_each_block_5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*item*/
    ctx[18]
  ];
  var switch_value = (
    /*renderers*/
    ctx[5].unorderedlistitem || /*renderers*/
    ctx[5].listitem
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx: ctx2 }
    };
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty & /*$$restProps*/
    64) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*item*/
        ctx2[18]
      )]));
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].unorderedlistitem || /*renderers*/
      ctx2[5].listitem)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*$$restProps*/
        64 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*item*/
          ctx2[18]
        )]) : {};
        if (dirty & /*$$scope, $$restProps, renderers*/
        8388704) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_9$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_5 = ensure_array_like(
    /*$$restProps*/
    ctx[6].items
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_5.length; i2 += 1) {
    each_blocks[i2] = create_each_block_5(get_each_context_5(ctx, each_value_5, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers, $$restProps*/
      96) {
        each_value_5 = ensure_array_like(
          /*$$restProps*/
          ctx2[6].items
        );
        let i2;
        for (i2 = 0; i2 < each_value_5.length; i2 += 1) {
          const child_ctx = get_each_context_5(ctx2, each_value_5, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_5.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_5.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_8$1(ctx) {
  let parser;
  let t2;
  let current;
  parser = new Parser$1({
    props: {
      tokens: (
        /*item*/
        ctx[18].tokens
      ),
      renderers: (
        /*renderers*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      create_component(parser.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(parser, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const parser_changes = {};
      if (dirty & /*$$restProps*/
      64)
        parser_changes.tokens = /*item*/
        ctx2[18].tokens;
      if (dirty & /*renderers*/
      32)
        parser_changes.renderers = /*renderers*/
        ctx2[5];
      parser.$set(parser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(parser, detaching);
    }
  };
}
function create_each_block_4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*item*/
    ctx[18]
  ];
  var switch_value = (
    /*renderers*/
    ctx[5].orderedlistitem || /*renderers*/
    ctx[5].listitem
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_8$1] },
      $$scope: { ctx: ctx2 }
    };
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty & /*$$restProps*/
    64) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*item*/
        ctx2[18]
      )]));
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].orderedlistitem || /*renderers*/
      ctx2[5].listitem)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*$$restProps*/
        64 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*item*/
          ctx2[18]
        )]) : {};
        if (dirty & /*$$scope, $$restProps, renderers*/
        8388704) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_7$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_4 = ensure_array_like(
    /*$$restProps*/
    ctx[6].items
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
    each_blocks[i2] = create_each_block_4(get_each_context_4(ctx, each_value_4, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers, $$restProps*/
      96) {
        each_value_4 = ensure_array_like(
          /*$$restProps*/
          ctx2[6].items
        );
        let i2;
        for (i2 = 0; i2 < each_value_4.length; i2 += 1) {
          const child_ctx = get_each_context_4(ctx2, each_value_4, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_4(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_4.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_6$1(ctx) {
  let parser;
  let t2;
  let current;
  parser = new Parser$1({
    props: {
      tokens: (
        /*headerItem*/
        ctx[16].tokens
      ),
      renderers: (
        /*renderers*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      create_component(parser.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(parser, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const parser_changes = {};
      if (dirty & /*header*/
      4)
        parser_changes.tokens = /*headerItem*/
        ctx2[16].tokens;
      if (dirty & /*renderers*/
      32)
        parser_changes.renderers = /*renderers*/
        ctx2[5];
      parser.$set(parser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(parser, detaching);
    }
  };
}
function create_each_block_3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].tablecell
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        header: true,
        align: (
          /*$$restProps*/
          ctx2[6].align[
            /*i*/
            ctx2[15]
          ] || "center"
        ),
        $$slots: { default: [create_default_slot_6$1] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].tablecell)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$restProps*/
        64)
          switch_instance_changes.align = /*$$restProps*/
          ctx2[6].align[
            /*i*/
            ctx2[15]
          ] || "center";
        if (dirty & /*$$scope, header, renderers*/
        8388644) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_5$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_3 = ensure_array_like(
    /*header*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    each_blocks[i2] = create_each_block_3(get_each_context_3(ctx, each_value_3, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers, $$restProps, header*/
      100) {
        each_value_3 = ensure_array_like(
          /*header*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value_3.length; i2 += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_3.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_4$1(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].tablerow
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot_5$1] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].tablerow)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$scope, header, renderers, $$restProps*/
        8388708) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_3$6(ctx) {
  let parser;
  let current;
  parser = new Parser$1({
    props: {
      tokens: (
        /*cells*/
        ctx[13].tokens
      ),
      renderers: (
        /*renderers*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      create_component(parser.$$.fragment);
    },
    m(target, anchor) {
      mount_component(parser, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const parser_changes = {};
      if (dirty & /*rows*/
      8)
        parser_changes.tokens = /*cells*/
        ctx2[13].tokens;
      if (dirty & /*renderers*/
      32)
        parser_changes.renderers = /*renderers*/
        ctx2[5];
      parser.$set(parser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(parser, detaching);
    }
  };
}
function create_each_block_2$1(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].tablecell
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        header: false,
        align: (
          /*$$restProps*/
          ctx2[6].align[
            /*i*/
            ctx2[15]
          ] || "center"
        ),
        $$slots: { default: [create_default_slot_3$6] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].tablecell)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$restProps*/
        64)
          switch_instance_changes.align = /*$$restProps*/
          ctx2[6].align[
            /*i*/
            ctx2[15]
          ] || "center";
        if (dirty & /*$$scope, rows, renderers*/
        8388648) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_2$b(ctx) {
  let t2;
  let current;
  let each_value_2 = ensure_array_like(
    /*row*/
    ctx[10]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers, $$restProps, rows*/
      104) {
        each_value_2 = ensure_array_like(
          /*row*/
          ctx2[10]
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$1(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2$1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t2.parentNode, t2);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1$5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].tablerow
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot_2$b] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].tablerow)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$scope, rows, renderers, $$restProps*/
        8388712) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_1$d(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*rows*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers, rows, $$restProps*/
      104) {
        each_value_1 = ensure_array_like(
          /*rows*/
          ctx2[3]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$5(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot$k(ctx) {
  let switch_instance0;
  let t2;
  let switch_instance1;
  let switch_instance1_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].tablehead
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot_4$1] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx));
  }
  var switch_value_1 = (
    /*renderers*/
    ctx[5].tablebody
  );
  function switch_props_1(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot_1$d] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx));
  }
  return {
    c() {
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t2 = space();
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      switch_instance1_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance0)
        mount_component(switch_instance0, target, anchor);
      insert(target, t2, anchor);
      if (switch_instance1)
        mount_component(switch_instance1, target, anchor);
      insert(target, switch_instance1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].tablehead)) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, t2.parentNode, t2);
        } else {
          switch_instance0 = null;
        }
      } else if (switch_value) {
        const switch_instance0_changes = {};
        if (dirty & /*$$scope, renderers, header, $$restProps*/
        8388708) {
          switch_instance0_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance0.$set(switch_instance0_changes);
      }
      if (dirty & /*renderers*/
      32 && switch_value_1 !== (switch_value_1 = /*renderers*/
      ctx2[5].tablebody)) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx2));
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, switch_instance1_anchor.parentNode, switch_instance1_anchor);
        } else {
          switch_instance1 = null;
        }
      } else if (switch_value_1) {
        const switch_instance1_changes = {};
        if (dirty & /*$$scope, rows, renderers, $$restProps*/
        8388712) {
          switch_instance1_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance1.$set(switch_instance1_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(switch_instance1_anchor);
      }
      if (switch_instance0)
        destroy_component(switch_instance0, detaching);
      if (switch_instance1)
        destroy_component(switch_instance1, detaching);
    }
  };
}
function create_each_block$C(ctx) {
  let parser;
  let current;
  const parser_spread_levels = [
    /*token*/
    ctx[7],
    { renderers: (
      /*renderers*/
      ctx[5]
    ) }
  ];
  let parser_props = {};
  for (let i2 = 0; i2 < parser_spread_levels.length; i2 += 1) {
    parser_props = assign(parser_props, parser_spread_levels[i2]);
  }
  parser = new Parser$1({ props: parser_props });
  return {
    c() {
      create_component(parser.$$.fragment);
    },
    m(target, anchor) {
      mount_component(parser, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const parser_changes = dirty & /*tokens, renderers*/
      34 ? get_spread_update(parser_spread_levels, [
        dirty & /*tokens*/
        2 && get_spread_object(
          /*token*/
          ctx2[7]
        ),
        dirty & /*renderers*/
        32 && { renderers: (
          /*renderers*/
          ctx2[5]
        ) }
      ]) : {};
      parser.$set(parser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(parser, detaching);
    }
  };
}
function create_fragment$3r(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1r, create_if_block_1$t];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*type*/
    ctx2[0])
      return 0;
    if (
      /*renderers*/
      ctx2[5][
        /*type*/
        ctx2[0]
      ]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function instance$39($$self, $$props, $$invalidate) {
  const omit_props_names = ["type", "tokens", "header", "rows", "ordered", "renderers"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { type = void 0 } = $$props;
  let { tokens = void 0 } = $$props;
  let { header: header2 = void 0 } = $$props;
  let { rows = void 0 } = $$props;
  let { ordered = false } = $$props;
  let { renderers } = $$props;
  supressWarnings();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props)
      $$invalidate(0, type = $$new_props.type);
    if ("tokens" in $$new_props)
      $$invalidate(1, tokens = $$new_props.tokens);
    if ("header" in $$new_props)
      $$invalidate(2, header2 = $$new_props.header);
    if ("rows" in $$new_props)
      $$invalidate(3, rows = $$new_props.rows);
    if ("ordered" in $$new_props)
      $$invalidate(4, ordered = $$new_props.ordered);
    if ("renderers" in $$new_props)
      $$invalidate(5, renderers = $$new_props.renderers);
  };
  return [type, tokens, header2, rows, ordered, renderers, $$restProps];
}
let Parser$1 = class Parser extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$39, create_fragment$3r, safe_not_equal, {
      type: 0,
      tokens: 1,
      header: 2,
      rows: 3,
      ordered: 4,
      renderers: 5
    });
  }
};
function getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    hooks: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
let defaults = getDefaults();
function changeDefaults(newDefaults) {
  defaults = newDefaults;
}
const escapeTest = /[&<>"']/;
const escapeReplace = new RegExp(escapeTest.source, "g");
const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
const escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html, encode2) {
  if (encode2) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape$1(html) {
  return html.replace(unescapeTest, (_2, n2) => {
    n2 = n2.toLowerCase();
    if (n2 === "colon")
      return ":";
    if (n2.charAt(0) === "#") {
      return n2.charAt(1) === "x" ? String.fromCharCode(parseInt(n2.substring(2), 16)) : String.fromCharCode(+n2.substring(1));
    }
    return "";
  });
}
const caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
const nonWordAndColonTest = /[^\w:]/g;
const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape$1(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e2) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e2) {
    return null;
  }
  return href;
}
const baseUrls = {};
const justDomain = /^[^:]+:\/*[^/]*$/;
const protocol = /^([^:]+:)[\s\S]*$/;
const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, "$1") + href;
  } else {
    return base + href;
  }
}
const noopTest = { exec: function noopTest2() {
} };
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false, curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i2 = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count)
      cells.push("");
  }
  for (; i2 < cells.length; i2++) {
    cells[i2] = cells[i2].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c2, invert) {
  const l2 = str.length;
  if (l2 === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l2) {
    const currChar = str.charAt(l2 - suffLen - 1);
    if (currChar === c2 && !invert) {
      suffLen++;
    } else if (currChar !== c2 && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l2 - suffLen);
}
function findClosingBracket(str, b2) {
  if (str.indexOf(b2[1]) === -1) {
    return -1;
  }
  const l2 = str.length;
  let level = 0, i2 = 0;
  for (; i2 < l2; i2++) {
    if (str[i2] === "\\") {
      i2++;
    } else if (str[i2] === b2[0]) {
      level++;
    } else if (str[i2] === b2[1]) {
      level--;
      if (level < 0) {
        return i2;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
}
function repeatString(pattern, count) {
  if (count < 1) {
    return "";
  }
  let result = "";
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer) {
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text2 = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text: text2,
      tokens: lexer.inlineTokens(text2)
    };
    lexer.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape(text2)
  };
}
function indentCodeCompensation(raw, text2) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text2;
  }
  const indentToCode = matchIndentToCode[1];
  return text2.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
class Tokenizer {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text2 = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text2, "\n") : text2
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text2 = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
        text: text2
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text2 = cap[2].trim();
      if (/#$/.test(text2)) {
        const trimmed = rtrim(text2, "#");
        if (this.options.pedantic) {
          text2 = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text2 = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text2 = cap[0].replace(/^ *>[ \t]?/gm, "");
      const top = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text2);
      this.lexer.state.top = top;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text: text2
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw, istask, ischecked, indent, i2, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list2 = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t2) => " ".repeat(3 * t2.length));
        nextLine = src.split("\n", 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list2.loose) {
          if (endsWithBlankLine) {
            list2.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list2.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list2.raw += raw;
      }
      list2.items[list2.items.length - 1].raw = raw.trimRight();
      list2.items[list2.items.length - 1].text = itemContents.trimRight();
      list2.raw = list2.raw.trimRight();
      const l2 = list2.items.length;
      for (i2 = 0; i2 < l2; i2++) {
        this.lexer.state.top = false;
        list2.items[i2].tokens = this.lexer.blockTokens(list2.items[i2].text, []);
        if (!list2.loose) {
          const spacers = list2.items[i2].tokens.filter((t2) => t2.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t2) => /\n.*\n/.test(t2.raw));
          list2.loose = hasMultipleLineBreaks;
        }
      }
      if (list2.loose) {
        for (i2 = 0; i2 < l2; i2++) {
          list2.items[i2].loose = true;
        }
      }
      return list2;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      };
      if (this.options.sanitize) {
        const text2 = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        token.type = "paragraph";
        token.text = text2;
        token.tokens = this.lexer.inline(text2);
      }
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
      return {
        type: "def",
        tag,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: "table",
        header: splitCells(cap[1]).map((c2) => {
          return { text: c2 };
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        let l2 = item.align.length;
        let i2, j2, k2, row;
        for (i2 = 0; i2 < l2; i2++) {
          if (/^ *-+: *$/.test(item.align[i2])) {
            item.align[i2] = "right";
          } else if (/^ *:-+: *$/.test(item.align[i2])) {
            item.align[i2] = "center";
          } else if (/^ *:-+ *$/.test(item.align[i2])) {
            item.align[i2] = "left";
          } else {
            item.align[i2] = null;
          }
        }
        l2 = item.rows.length;
        for (i2 = 0; i2 < l2; i2++) {
          item.rows[i2] = splitCells(item.rows[i2], item.header.length).map((c2) => {
            return { text: c2 };
          });
        }
        l2 = item.header.length;
        for (j2 = 0; j2 < l2; j2++) {
          item.header[j2].tokens = this.lexer.inline(item.header[j2].text);
        }
        l2 = item.rows.length;
        for (j2 = 0; j2 < l2; j2++) {
          row = item.rows[j2];
          for (k2 = 0; k2 < row.length; k2++) {
            row[k2].tokens = this.lexer.inline(row[k2].text);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text2 = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start2 = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start2 + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links[link.toLowerCase()];
      if (!link) {
        const text2 = cap[0].charAt(0);
        return {
          type: "text",
          raw: text2,
          text: text2
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = rDelim.length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text3 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text3,
            tokens: this.lexer.inlineTokens(text3)
          };
        }
        const text2 = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text: text2,
          tokens: this.lexer.inlineTokens(text2)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text2 = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text2);
      const hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text2 = text2.substring(1, text2.length - 1);
      }
      text2 = escape(text2, true);
      return {
        type: "codespan",
        raw: cap[0],
        text: text2
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
        href = "mailto:" + text2;
      } else {
        text2 = escape(cap[1]);
        href = text2;
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [
          {
            type: "text",
            raw: text2,
            text: text2
          }
        ]
      };
    }
  }
  url(src, mangle2) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
        href = "mailto:" + text2;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text2 = escape(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [
          {
            type: "text",
            raw: text2,
            text: text2
          }
        ]
      };
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text2;
      if (this.lexer.state.inRawBlock) {
        text2 = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
      } else {
        text2 = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text: text2
      };
    }
  }
}
const block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = { ...block };
block.gfm = {
  ...block.normal,
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
};
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = {
  ...block.normal,
  html: edit(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
};
const inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = { ...inline };
inline.pedantic = {
  ...inline.normal,
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
};
inline.gfm = {
  ...inline.normal,
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = {
  ...inline.gfm,
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
function smartypants(text2) {
  return text2.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…");
}
function mangle(text2) {
  let out = "", i2, ch;
  const l2 = text2.length;
  for (i2 = 0; i2 < l2; i2++) {
    ch = text2.charCodeAt(i2);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
class Lexer {
  constructor(options2) {
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer = new Lexer(options2);
    return lexer.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer = new Lexer(options2);
    return lexer.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  /**
   * Lexing
   */
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_2, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
}
let Renderer$1 = class Renderer {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  /**
   * @param {string} quote
   */
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`;
  }
  html(html) {
    return html;
  }
  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */
  heading(text2, level, raw, slugger) {
    if (this.options.headerIds) {
      const id = this.options.headerPrefix + slugger.slug(raw);
      return `<h${level} id="${id}">${text2}</h${level}>
`;
    }
    return `<h${level}>${text2}</h${level}>
`;
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  }
  list(body, ordered, start2) {
    const type = ordered ? "ol" : "ul", startatt = ordered && start2 !== 1 ? ' start="' + start2 + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  /**
   * @param {string} text
   */
  listitem(text2) {
    return `<li>${text2}</li>
`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  /**
   * @param {string} text
   */
  paragraph(text2) {
    return `<p>${text2}</p>
`;
  }
  /**
   * @param {string} header
   * @param {string} body
   */
  table(header2, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header2 + "</thead>\n" + body + "</table>\n";
  }
  /**
   * @param {string} content
   */
  tablerow(content) {
    return `<tr>
${content}</tr>
`;
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag + content + `</${type}>
`;
  }
  /**
   * span level renderer
   * @param {string} text
   */
  strong(text2) {
    return `<strong>${text2}</strong>`;
  }
  /**
   * @param {string} text
   */
  em(text2) {
    return `<em>${text2}</em>`;
  }
  /**
   * @param {string} text
   */
  codespan(text2) {
    return `<code>${text2}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  /**
   * @param {string} text
   */
  del(text2) {
    return `<del>${text2}</del>`;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  link(href, title, text2) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text2;
    }
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text2 + "</a>";
    return out;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  image(href, title, text2) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text2;
    }
    let out = `<img src="${href}" alt="${text2}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  }
  text(text2) {
    return text2;
  }
};
class TextRenderer {
  // no need for block level renderers
  strong(text2) {
    return text2;
  }
  em(text2) {
    return text2;
  }
  codespan(text2) {
    return text2;
  }
  del(text2) {
    return text2;
  }
  html(text2) {
    return text2;
  }
  text(text2) {
    return text2;
  }
  link(href, title, text2) {
    return "" + text2;
  }
  image(href, title, text2) {
    return "" + text2;
  }
  br() {
    return "";
  }
}
class Slugger {
  constructor() {
    this.seen = {};
  }
  /**
   * @param {string} value
   */
  serialize(value) {
    return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + "-" + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }
  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(value, options2 = {}) {
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options2.dryrun);
  }
}
class Parser2 {
  constructor(options2) {
    this.options = options2 || defaults;
    this.options.renderer = this.options.renderer || new Renderer$1();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser = new Parser2(options2);
    return parser.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser = new Parser2(options2);
    return parser.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out = "", i2, j2, k2, l2, l3, row, cell, header2, body, token, ordered, start2, loose, itemBody, item, checked, task, checkbox, ret;
    const l4 = tokens.length;
    for (i2 = 0; i2 < l4; i2++) {
      token = tokens[i2];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          out += this.renderer.heading(
            this.parseInline(token.tokens),
            token.depth,
            unescape$1(this.parseInline(token.tokens, this.textRenderer)),
            this.slugger
          );
          continue;
        }
        case "code": {
          out += this.renderer.code(
            token.text,
            token.lang,
            token.escaped
          );
          continue;
        }
        case "table": {
          header2 = "";
          cell = "";
          l2 = token.header.length;
          for (j2 = 0; j2 < l2; j2++) {
            cell += this.renderer.tablecell(
              this.parseInline(token.header[j2].tokens),
              { header: true, align: token.align[j2] }
            );
          }
          header2 += this.renderer.tablerow(cell);
          body = "";
          l2 = token.rows.length;
          for (j2 = 0; j2 < l2; j2++) {
            row = token.rows[j2];
            cell = "";
            l3 = row.length;
            for (k2 = 0; k2 < l3; k2++) {
              cell += this.renderer.tablecell(
                this.parseInline(row[k2].tokens),
                { header: false, align: token.align[k2] }
              );
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header2, body);
          continue;
        }
        case "blockquote": {
          body = this.parse(token.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          ordered = token.ordered;
          start2 = token.start;
          loose = token.loose;
          l2 = token.items.length;
          body = "";
          for (j2 = 0; j2 < l2; j2++) {
            item = token.items[j2];
            checked = item.checked;
            task = item.task;
            itemBody = "";
            if (item.task) {
              checkbox = this.renderer.checkbox(checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked);
          }
          out += this.renderer.list(body, ordered, start2);
          continue;
        }
        case "html": {
          out += this.renderer.html(token.text);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
        }
        case "text": {
          body = token.tokens ? this.parseInline(token.tokens) : token.text;
          while (i2 + 1 < l4 && tokens[i2 + 1].type === "text") {
            token = tokens[++i2];
            body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "", i2, token, ret;
    const l2 = tokens.length;
    for (i2 = 0; i2 < l2; i2++) {
      token = tokens[i2];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          out += renderer.text(token.text);
          break;
        }
        case "html": {
          out += renderer.html(token.text);
          break;
        }
        case "link": {
          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
          break;
        }
        case "image": {
          out += renderer.image(token.href, token.title, token.text);
          break;
        }
        case "strong": {
          out += renderer.strong(this.parseInline(token.tokens, renderer));
          break;
        }
        case "em": {
          out += renderer.em(this.parseInline(token.tokens, renderer));
          break;
        }
        case "codespan": {
          out += renderer.codespan(token.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          out += renderer.del(this.parseInline(token.tokens, renderer));
          break;
        }
        case "text": {
          out += renderer.text(token.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
}
class Hooks {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html) {
    return html;
  }
}
__publicField(Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess"
]));
function onError(silent, async, callback) {
  return (e2) => {
    e2.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (silent) {
      const msg = "<p>An error occurred:</p><pre>" + escape(e2.message + "", true) + "</pre>";
      if (async) {
        return Promise.resolve(msg);
      }
      if (callback) {
        callback(null, msg);
        return;
      }
      return msg;
    }
    if (async) {
      return Promise.reject(e2);
    }
    if (callback) {
      callback(e2);
      return;
    }
    throw e2;
  };
}
function parseMarkdown(lexer, parser) {
  return (src, opt, callback) => {
    if (typeof opt === "function") {
      callback = opt;
      opt = null;
    }
    const origOpt = { ...opt };
    opt = { ...marked.defaults, ...origOpt };
    const throwError = onError(opt.silent, opt.async, callback);
    if (typeof src === "undefined" || src === null) {
      return throwError(new Error("marked(): input parameter is undefined or null"));
    }
    if (typeof src !== "string") {
      return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
    }
    checkSanitizeDeprecation(opt);
    if (opt.hooks) {
      opt.hooks.options = opt;
    }
    if (callback) {
      const highlight = opt.highlight;
      let tokens;
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        tokens = lexer(src, opt);
      } catch (e2) {
        return throwError(e2);
      }
      const done = function(err2) {
        let out;
        if (!err2) {
          try {
            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens);
            }
            out = parser(tokens, opt);
            if (opt.hooks) {
              out = opt.hooks.postprocess(out);
            }
          } catch (e2) {
            err2 = e2;
          }
        }
        opt.highlight = highlight;
        return err2 ? throwError(err2) : callback(null, out);
      };
      if (!highlight || highlight.length < 3) {
        return done();
      }
      delete opt.highlight;
      if (!tokens.length)
        return done();
      let pending = 0;
      marked.walkTokens(tokens, function(token) {
        if (token.type === "code") {
          pending++;
          setTimeout(() => {
            highlight(token.text, token.lang, function(err2, code) {
              if (err2) {
                return done(err2);
              }
              if (code != null && code !== token.text) {
                token.text = code;
                token.escaped = true;
              }
              pending--;
              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });
      if (pending === 0) {
        done();
      }
      return;
    }
    if (opt.async) {
      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser(tokens, opt)).then((html) => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);
    }
    try {
      if (opt.hooks) {
        src = opt.hooks.preprocess(src);
      }
      const tokens = lexer(src, opt);
      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens);
      }
      let html = parser(tokens, opt);
      if (opt.hooks) {
        html = opt.hooks.postprocess(html);
      }
      return html;
    } catch (e2) {
      return throwError(e2);
    }
  };
}
function marked(src, opt, callback) {
  return parseMarkdown(Lexer.lex, Parser2.parse)(src, opt, callback);
}
marked.options = marked.setOptions = function(opt) {
  marked.defaults = { ...marked.defaults, ...opt };
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults;
marked.use = function(...args) {
  const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
  args.forEach((pack) => {
    const opts = { ...pack };
    opts.async = marked.defaults.async || opts.async || false;
    if (pack.extensions) {
      pack.extensions.forEach((ext2) => {
        if (!ext2.name) {
          throw new Error("extension name required");
        }
        if (ext2.renderer) {
          const prevRenderer = extensions.renderers[ext2.name];
          if (prevRenderer) {
            extensions.renderers[ext2.name] = function(...args2) {
              let ret = ext2.renderer.apply(this, args2);
              if (ret === false) {
                ret = prevRenderer.apply(this, args2);
              }
              return ret;
            };
          } else {
            extensions.renderers[ext2.name] = ext2.renderer;
          }
        }
        if (ext2.tokenizer) {
          if (!ext2.level || ext2.level !== "block" && ext2.level !== "inline") {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions[ext2.level]) {
            extensions[ext2.level].unshift(ext2.tokenizer);
          } else {
            extensions[ext2.level] = [ext2.tokenizer];
          }
          if (ext2.start) {
            if (ext2.level === "block") {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext2.start);
              } else {
                extensions.startBlock = [ext2.start];
              }
            } else if (ext2.level === "inline") {
              if (extensions.startInline) {
                extensions.startInline.push(ext2.start);
              } else {
                extensions.startInline = [ext2.start];
              }
            }
          }
        }
        if (ext2.childTokens) {
          extensions.childTokens[ext2.name] = ext2.childTokens;
        }
      });
      opts.extensions = extensions;
    }
    if (pack.renderer) {
      const renderer = marked.defaults.renderer || new Renderer$1();
      for (const prop in pack.renderer) {
        const prevRenderer = renderer[prop];
        renderer[prop] = (...args2) => {
          let ret = pack.renderer[prop].apply(renderer, args2);
          if (ret === false) {
            ret = prevRenderer.apply(renderer, args2);
          }
          return ret;
        };
      }
      opts.renderer = renderer;
    }
    if (pack.tokenizer) {
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) {
        const prevTokenizer = tokenizer[prop];
        tokenizer[prop] = (...args2) => {
          let ret = pack.tokenizer[prop].apply(tokenizer, args2);
          if (ret === false) {
            ret = prevTokenizer.apply(tokenizer, args2);
          }
          return ret;
        };
      }
      opts.tokenizer = tokenizer;
    }
    if (pack.hooks) {
      const hooks = marked.defaults.hooks || new Hooks();
      for (const prop in pack.hooks) {
        const prevHook = hooks[prop];
        if (Hooks.passThroughHooks.has(prop)) {
          hooks[prop] = (arg) => {
            if (marked.defaults.async) {
              return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then((ret2) => {
                return prevHook.call(hooks, ret2);
              });
            }
            const ret = pack.hooks[prop].call(hooks, arg);
            return prevHook.call(hooks, ret);
          };
        } else {
          hooks[prop] = (...args2) => {
            let ret = pack.hooks[prop].apply(hooks, args2);
            if (ret === false) {
              ret = prevHook.apply(hooks, args2);
            }
            return ret;
          };
        }
      }
      opts.hooks = hooks;
    }
    if (pack.walkTokens) {
      const walkTokens = marked.defaults.walkTokens;
      opts.walkTokens = function(token) {
        let values = [];
        values.push(pack.walkTokens.call(this, token));
        if (walkTokens) {
          values = values.concat(walkTokens.call(this, token));
        }
        return values;
      };
    }
    marked.setOptions(opts);
  });
};
marked.walkTokens = function(tokens, callback) {
  let values = [];
  for (const token of tokens) {
    values = values.concat(callback.call(marked, token));
    switch (token.type) {
      case "table": {
        for (const cell of token.header) {
          values = values.concat(marked.walkTokens(cell.tokens, callback));
        }
        for (const row of token.rows) {
          for (const cell of row) {
            values = values.concat(marked.walkTokens(cell.tokens, callback));
          }
        }
        break;
      }
      case "list": {
        values = values.concat(marked.walkTokens(token.items, callback));
        break;
      }
      default: {
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
            values = values.concat(marked.walkTokens(token[childTokens], callback));
          });
        } else if (token.tokens) {
          values = values.concat(marked.walkTokens(token.tokens, callback));
        }
      }
    }
  }
  return values;
};
marked.parseInline = parseMarkdown(Lexer.lexInline, Parser2.parseInline);
marked.Parser = Parser2;
marked.parser = Parser2.parse;
marked.Renderer = Renderer$1;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.Hooks = Hooks;
marked.parse = marked;
marked.options;
marked.setOptions;
marked.use;
marked.walkTokens;
marked.parseInline;
Parser2.parse;
Lexer.lex;
const key = {};
function create_else_block$m(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*raw*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*raw*/
      2)
        set_data(
          t2,
          /*raw*/
          ctx2[1]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_5(ctx) {
  let h6;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      h6 = element("h6");
      if (default_slot)
        default_slot.c();
      attr(
        h6,
        "id",
        /*id*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, h6, anchor);
      if (default_slot) {
        default_slot.m(h6, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr(
          h6,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h6);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block_4$1(ctx) {
  let h5;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      h5 = element("h5");
      if (default_slot)
        default_slot.c();
      attr(
        h5,
        "id",
        /*id*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, h5, anchor);
      if (default_slot) {
        default_slot.m(h5, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr(
          h5,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h5);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block_3$4(ctx) {
  let h4;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      h4 = element("h4");
      if (default_slot)
        default_slot.c();
      attr(
        h4,
        "id",
        /*id*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, h4, anchor);
      if (default_slot) {
        default_slot.m(h4, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr(
          h4,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h4);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block_2$a(ctx) {
  let h3;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      h3 = element("h3");
      if (default_slot)
        default_slot.c();
      attr(
        h3,
        "id",
        /*id*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      if (default_slot) {
        default_slot.m(h3, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr(
          h3,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block_1$s(ctx) {
  let h2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      h2 = element("h2");
      if (default_slot)
        default_slot.c();
      attr(
        h2,
        "id",
        /*id*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      if (default_slot) {
        default_slot.m(h2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr(
          h2,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block$1q(ctx) {
  let h1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      h1 = element("h1");
      if (default_slot)
        default_slot.c();
      attr(
        h1,
        "id",
        /*id*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      if (default_slot) {
        default_slot.m(h1, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr(
          h1,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h1);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$3q(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block$1q,
    create_if_block_1$s,
    create_if_block_2$a,
    create_if_block_3$4,
    create_if_block_4$1,
    create_if_block_5,
    create_else_block$m
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*depth*/
      ctx2[0] === 1
    )
      return 0;
    if (
      /*depth*/
      ctx2[0] === 2
    )
      return 1;
    if (
      /*depth*/
      ctx2[0] === 3
    )
      return 2;
    if (
      /*depth*/
      ctx2[0] === 4
    )
      return 3;
    if (
      /*depth*/
      ctx2[0] === 5
    )
      return 4;
    if (
      /*depth*/
      ctx2[0] === 6
    )
      return 5;
    return 6;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$38($$self, $$props, $$invalidate) {
  let id;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { depth } = $$props;
  let { raw } = $$props;
  let { text: text2 } = $$props;
  const { slug, getOptions } = getContext(key);
  const options2 = getOptions();
  $$self.$$set = ($$props2) => {
    if ("depth" in $$props2)
      $$invalidate(0, depth = $$props2.depth);
    if ("raw" in $$props2)
      $$invalidate(1, raw = $$props2.raw);
    if ("text" in $$props2)
      $$invalidate(3, text2 = $$props2.text);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*text*/
    8) {
      $$invalidate(2, id = options2.headerIds ? options2.headerPrefix + slug(text2) : void 0);
    }
  };
  return [depth, raw, id, text2, $$scope, slots];
}
class Heading extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$38, create_fragment$3q, safe_not_equal, { depth: 0, raw: 1, text: 3 });
  }
}
function create_fragment$3p(ctx) {
  let p2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      p2 = element("p");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      if (default_slot) {
        default_slot.m(p2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$37($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Paragraph extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$37, create_fragment$3p, safe_not_equal, {});
  }
}
function create_fragment$3o(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$36($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { text: text2 } = $$props;
  let { raw } = $$props;
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("raw" in $$props2)
      $$invalidate(1, raw = $$props2.raw);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [text2, raw, $$scope, slots];
}
class Text extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$36, create_fragment$3o, safe_not_equal, { text: 0, raw: 1 });
  }
}
function create_fragment$3n(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*href*/
      ctx[0]))
        attr(img, "src", img_src_value);
      attr(
        img,
        "title",
        /*title*/
        ctx[1]
      );
      attr(
        img,
        "alt",
        /*text*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*href*/
      1 && !src_url_equal(img.src, img_src_value = /*href*/
      ctx2[0])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*title*/
      2) {
        attr(
          img,
          "title",
          /*title*/
          ctx2[1]
        );
      }
      if (dirty & /*text*/
      4) {
        attr(
          img,
          "alt",
          /*text*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function instance$35($$self, $$props, $$invalidate) {
  let { href = "" } = $$props;
  let { title = void 0 } = $$props;
  let { text: text2 = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("href" in $$props2)
      $$invalidate(0, href = $$props2.href);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("text" in $$props2)
      $$invalidate(2, text2 = $$props2.text);
  };
  return [href, title, text2];
}
let Image$1 = class Image2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$35, create_fragment$3n, safe_not_equal, { href: 0, title: 1, text: 2 });
  }
};
function create_fragment$3m(ctx) {
  let a2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      a2 = element("a");
      if (default_slot)
        default_slot.c();
      attr(
        a2,
        "href",
        /*href*/
        ctx[0]
      );
      attr(
        a2,
        "title",
        /*title*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, a2, anchor);
      if (default_slot) {
        default_slot.m(a2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*href*/
      1) {
        attr(
          a2,
          "href",
          /*href*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*title*/
      2) {
        attr(
          a2,
          "title",
          /*title*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(a2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$34($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { href = "" } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("href" in $$props2)
      $$invalidate(0, href = $$props2.href);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [href, title, $$scope, slots];
}
class Link extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$34, create_fragment$3m, safe_not_equal, { href: 0, title: 1 });
  }
}
function create_fragment$3l(ctx) {
  let em;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      em = element("em");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, em, anchor);
      if (default_slot) {
        default_slot.m(em, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(em);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$33($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Em extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$33, create_fragment$3l, safe_not_equal, {});
  }
}
function create_fragment$3k(ctx) {
  let del;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      del = element("del");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, del, anchor);
      if (default_slot) {
        default_slot.m(del, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(del);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$32($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Del extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$32, create_fragment$3k, safe_not_equal, {});
  }
}
function create_fragment$3j(ctx) {
  let code;
  let t_value = (
    /*raw*/
    ctx[0].replace(/`/g, "") + ""
  );
  let t2;
  return {
    c() {
      code = element("code");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, code, anchor);
      append(code, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*raw*/
      1 && t_value !== (t_value = /*raw*/
      ctx2[0].replace(/`/g, "") + ""))
        set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(code);
      }
    }
  };
}
function instance$31($$self, $$props, $$invalidate) {
  let { raw } = $$props;
  $$self.$$set = ($$props2) => {
    if ("raw" in $$props2)
      $$invalidate(0, raw = $$props2.raw);
  };
  return [raw];
}
class Codespan extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$31, create_fragment$3j, safe_not_equal, { raw: 0 });
  }
}
function create_fragment$3i(ctx) {
  let strong;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      strong = element("strong");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, strong, anchor);
      if (default_slot) {
        default_slot.m(strong, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(strong);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$30($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Strong extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$30, create_fragment$3i, safe_not_equal, {});
  }
}
function create_fragment$3h(ctx) {
  let table;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      table = element("table");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, table, anchor);
      if (default_slot) {
        default_slot.m(table, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(table);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$2$($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Table extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2$, create_fragment$3h, safe_not_equal, {});
  }
}
function create_fragment$3g(ctx) {
  let thead;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      thead = element("thead");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, thead, anchor);
      if (default_slot) {
        default_slot.m(thead, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(thead);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$2_($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class TableHead extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2_, create_fragment$3g, safe_not_equal, {});
  }
}
function create_fragment$3f(ctx) {
  let tbody;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      tbody = element("tbody");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, tbody, anchor);
      if (default_slot) {
        default_slot.m(tbody, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(tbody);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$2Z($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class TableBody extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2Z, create_fragment$3f, safe_not_equal, {});
  }
}
function create_fragment$3e(ctx) {
  let tr;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      tr = element("tr");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$2Y($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class TableRow extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2Y, create_fragment$3e, safe_not_equal, {});
  }
}
function create_else_block$l(ctx) {
  let td;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      td = element("td");
      if (default_slot)
        default_slot.c();
      attr(
        td,
        "align",
        /*align*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, td, anchor);
      if (default_slot) {
        default_slot.m(td, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*align*/
      2) {
        attr(
          td,
          "align",
          /*align*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block$1p(ctx) {
  let th;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      th = element("th");
      if (default_slot)
        default_slot.c();
      attr(
        th,
        "align",
        /*align*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, th, anchor);
      if (default_slot) {
        default_slot.m(th, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*align*/
      2) {
        attr(
          th,
          "align",
          /*align*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(th);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$3d(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1p, create_else_block$l];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*header*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$2X($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { header: header2 } = $$props;
  let { align } = $$props;
  $$self.$$set = ($$props2) => {
    if ("header" in $$props2)
      $$invalidate(0, header2 = $$props2.header);
    if ("align" in $$props2)
      $$invalidate(1, align = $$props2.align);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [header2, align, $$scope, slots];
}
class TableCell extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2X, create_fragment$3d, safe_not_equal, { header: 0, align: 1 });
  }
}
function create_else_block$k(ctx) {
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block$1o(ctx) {
  let ol;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      ol = element("ol");
      if (default_slot)
        default_slot.c();
      attr(
        ol,
        "start",
        /*start*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*start*/
      2) {
        attr(
          ol,
          "start",
          /*start*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ol);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$3c(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1o, create_else_block$k];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*ordered*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$2W($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { ordered } = $$props;
  let { start: start2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("ordered" in $$props2)
      $$invalidate(0, ordered = $$props2.ordered);
    if ("start" in $$props2)
      $$invalidate(1, start2 = $$props2.start);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [ordered, start2, $$scope, slots];
}
let List$3 = class List extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2W, create_fragment$3c, safe_not_equal, { ordered: 0, start: 1 });
  }
};
function create_fragment$3b(ctx) {
  let li;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      li = element("li");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$2V($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class ListItem extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2V, create_fragment$3b, safe_not_equal, {});
  }
}
function create_fragment$3a(ctx) {
  let hr;
  return {
    c() {
      hr = element("hr");
    },
    m(target, anchor) {
      insert(target, hr, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(hr);
      }
    }
  };
}
class Hr extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$3a, safe_not_equal, {});
  }
}
function create_fragment$39(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(
        /*text*/
        ctx[0],
        target,
        anchor
      );
      insert(target, html_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*text*/
      1)
        html_tag.p(
          /*text*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function instance$2U($$self, $$props, $$invalidate) {
  let { text: text2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
  };
  return [text2];
}
class Html extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2U, create_fragment$39, safe_not_equal, { text: 0 });
  }
}
function create_fragment$38(ctx) {
  let blockquote;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      blockquote = element("blockquote");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, blockquote, anchor);
      if (default_slot) {
        default_slot.m(blockquote, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(blockquote);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$2T($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Blockquote extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2T, create_fragment$38, safe_not_equal, {});
  }
}
function create_fragment$37(ctx) {
  let pre;
  let code;
  let t2;
  return {
    c() {
      pre = element("pre");
      code = element("code");
      t2 = text(
        /*text*/
        ctx[1]
      );
      attr(
        pre,
        "class",
        /*lang*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append(pre, code);
      append(code, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*text*/
      2)
        set_data(
          t2,
          /*text*/
          ctx2[1]
        );
      if (dirty & /*lang*/
      1) {
        attr(
          pre,
          "class",
          /*lang*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(pre);
      }
    }
  };
}
function instance$2S($$self, $$props, $$invalidate) {
  let { lang } = $$props;
  let { text: text2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("lang" in $$props2)
      $$invalidate(0, lang = $$props2.lang);
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
  };
  return [lang, text2];
}
let Code$1 = class Code extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2S, create_fragment$37, safe_not_equal, { lang: 0, text: 1 });
  }
};
function create_fragment$36(ctx) {
  let br;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      br = element("br");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, br, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(br);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$2R($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Br extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2R, create_fragment$36, safe_not_equal, {});
  }
}
const defaultRenderers = {
  heading: Heading,
  paragraph: Paragraph,
  text: Text,
  image: Image$1,
  link: Link,
  em: Em,
  strong: Strong,
  codespan: Codespan,
  del: Del,
  table: Table,
  tablehead: TableHead,
  tablebody: TableBody,
  tablerow: TableRow,
  tablecell: TableCell,
  list: List$3,
  orderedlistitem: null,
  unorderedlistitem: null,
  listitem: ListItem,
  hr: Hr,
  html: Html,
  blockquote: Blockquote,
  code: Code$1,
  br: Br
};
const defaultOptions = {
  baseUrl: null,
  breaks: false,
  gfm: true,
  headerIds: true,
  headerPrefix: "",
  highlight: null,
  langPrefix: "language-",
  mangle: true,
  pedantic: false,
  renderer: null,
  sanitize: false,
  sanitizer: null,
  silent: false,
  smartLists: false,
  smartypants: false,
  tokenizer: null,
  xhtml: false
};
function create_fragment$35(ctx) {
  let parser;
  let current;
  parser = new Parser$1({
    props: {
      tokens: (
        /*tokens*/
        ctx[0]
      ),
      renderers: (
        /*combinedRenderers*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(parser.$$.fragment);
    },
    m(target, anchor) {
      mount_component(parser, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const parser_changes = {};
      if (dirty & /*tokens*/
      1)
        parser_changes.tokens = /*tokens*/
        ctx2[0];
      if (dirty & /*combinedRenderers*/
      2)
        parser_changes.renderers = /*combinedRenderers*/
        ctx2[1];
      parser.$set(parser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(parser, detaching);
    }
  };
}
function instance$2Q($$self, $$props, $$invalidate) {
  let preprocessed;
  let slugger;
  let combinedOptions;
  let combinedRenderers;
  let { source = [] } = $$props;
  let { renderers = {} } = $$props;
  let { options: options2 = {} } = $$props;
  let { isInline = false } = $$props;
  const dispatch = createEventDispatcher();
  let tokens;
  let lexer;
  let mounted;
  setContext(key, {
    slug: (val) => slugger ? slugger.slug(val) : "",
    getOptions: () => combinedOptions
  });
  onMount(() => {
    $$invalidate(7, mounted = true);
  });
  $$self.$$set = ($$props2) => {
    if ("source" in $$props2)
      $$invalidate(2, source = $$props2.source);
    if ("renderers" in $$props2)
      $$invalidate(3, renderers = $$props2.renderers);
    if ("options" in $$props2)
      $$invalidate(4, options2 = $$props2.options);
    if ("isInline" in $$props2)
      $$invalidate(5, isInline = $$props2.isInline);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*source*/
    4) {
      $$invalidate(8, preprocessed = Array.isArray(source));
    }
    if ($$self.$$.dirty & /*source*/
    4) {
      slugger = source ? new Slugger() : void 0;
    }
    if ($$self.$$.dirty & /*options*/
    16) {
      $$invalidate(9, combinedOptions = { ...defaultOptions, ...options2 });
    }
    if ($$self.$$.dirty & /*preprocessed, source, combinedOptions, isInline, lexer, tokens*/
    869) {
      if (preprocessed) {
        $$invalidate(0, tokens = source);
      } else {
        $$invalidate(6, lexer = new Lexer(combinedOptions));
        $$invalidate(0, tokens = isInline ? lexer.inlineTokens(source) : lexer.lex(source));
        dispatch("parsed", { tokens });
      }
    }
    if ($$self.$$.dirty & /*renderers*/
    8) {
      $$invalidate(1, combinedRenderers = { ...defaultRenderers, ...renderers });
    }
    if ($$self.$$.dirty & /*mounted, preprocessed, tokens*/
    385) {
      mounted && !preprocessed && dispatch("parsed", { tokens });
    }
  };
  return [
    tokens,
    combinedRenderers,
    source,
    renderers,
    options2,
    isInline,
    lexer,
    mounted,
    preprocessed,
    combinedOptions
  ];
}
class SvelteMarkdown extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2Q, create_fragment$35, safe_not_equal, {
      source: 2,
      renderers: 3,
      options: 4,
      isInline: 5
    });
  }
}
function create_fragment$34(ctx) {
  let div;
  let sveltemarkdown;
  let current;
  sveltemarkdown = new SvelteMarkdown({ props: { source: (
    /*content*/
    ctx[0]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(sveltemarkdown.$$.fragment);
      attr(div, "class", "markdownrenderer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(sveltemarkdown, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const sveltemarkdown_changes = {};
      if (dirty & /*content*/
      1)
        sveltemarkdown_changes.source = /*content*/
        ctx2[0];
      sveltemarkdown.$set(sveltemarkdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sveltemarkdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sveltemarkdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(sveltemarkdown);
    }
  };
}
function instance$2P($$self, $$props, $$invalidate) {
  let { content } = $$props;
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(0, content = $$props2.content);
  };
  return [content];
}
class MarkdownRenderer extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2P, create_fragment$34, safe_not_equal, { content: 0 });
  }
}
const Bottom$1 = "" + new URL("Bottom-cf9f1c11.svg", import.meta.url).href;
const BottomLeft = "" + new URL("BottomLeft-e9f23216.svg", import.meta.url).href;
const BottomRight = "" + new URL("BottomRight-461ea3b0.svg", import.meta.url).href;
const Disable = "" + new URL("Disable-d009ccb8.svg", import.meta.url).href;
const Left$1 = "" + new URL("Left-6b949c92.svg", import.meta.url).href;
const Right$1 = "" + new URL("Right-0065fbbd.svg", import.meta.url).href;
const Top2 = "" + new URL("Top-2da866de.svg", import.meta.url).href;
const TopLeft = "" + new URL("TopLeft-1e728d18.svg", import.meta.url).href;
const TopRight = "" + new URL("TopRight-502dcfb5.svg", import.meta.url).href;
const Snapping = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bottom: Bottom$1,
  BottomLeft,
  BottomRight,
  Disable,
  Left: Left$1,
  Right: Right$1,
  Top: Top2,
  TopLeft,
  TopRight
}, Symbol.toStringTag, { value: "Module" }));
const BadStatusIcon = "" + new URL("bad-a940c2eb.svg", import.meta.url).href;
const good = "" + new URL("good-70133394.svg", import.meta.url).href;
const Status2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BadStatusIcon,
  GoodStatusIcon: good
}, Symbol.toStringTag, { value: "Module" }));
function getAllImages() {
  return {
    ...Branding,
    ...General,
    ...Apps$1,
    ...Filesystem,
    ...Power,
    ...Dialog$1,
    ...Status2,
    ...Snapping,
    ...Mimetypes
  };
}
function getGroupedIcons() {
  return {
    Branding,
    Apps: Apps$1,
    Filesystem,
    Mimetypes,
    General,
    Dialog: Dialog$1,
    Power,
    Status: Status2,
    Snapping
  };
}
const HelpSupportAccelerators = (runtime) => {
  return [
    {
      key: "r",
      alt: true,
      shift: false,
      async action() {
        const path = runtime.path.get();
        runtime.handleOpenFile("");
        await sleep();
        runtime.handleOpenFile(path);
      }
    }
  ];
};
let Runtime$a = class Runtime13 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "File", Store$1());
    __publicField(this, "buffer", Store$1());
    __publicField(this, "path", Store$1());
    __publicField(this, "wrapper", Store$1());
    __publicField(this, "Index", Store$1([]));
    __publicField(this, "renderArticle", Store$1(false));
    __publicField(this, "STARTPATH", "@client/help/Home.md");
    this.openedFile.subscribe(async (v2) => {
      if (!v2)
        return;
      await this.readFile(v2);
    });
    this.process.accelerator.store.push(...HelpSupportAccelerators(this));
    this._init();
  }
  async _init() {
    await this.readIndex();
    const args = this.process.args;
    this.handleOpenFile(!args.length || typeof args[0] != "string" ? this.STARTPATH : args[0]);
    this.process.handler.dispatch.subscribe(this.process.pid, "change-article", (page) => {
      this.handleOpenFile(page);
    });
    this.process.handler.dispatch.dispatchToPid(this.pid, "snapping-set", "right");
  }
  async readIndex() {
    const index = await readFile(`@client/help/index.json`);
    if (!index)
      return this.indexReadError();
    const data2 = await index.data.text();
    const json = tryJsonConvert(data2);
    if (typeof json === "string")
      return this.indexReadError();
    this.Index.set(json);
  }
  async readFile(v2) {
    this.renderArticle.set(false);
    const file = await readFile(v2);
    if (!file)
      return this.articleReadError(v2);
    this.path.set(v2);
    const content = await file.data.text();
    this.buffer.set("");
    await sleep(10);
    this.buffer.set(content);
    this.File.set(file);
    setTimeout(() => {
      this.setAnchorRedirects();
      this.replaceIconSources();
      this.renderArticle.set(true);
    }, 100);
  }
  setAnchorRedirects() {
    const path = this.path.get();
    const wrapper = this.wrapper.get();
    if (!path || !wrapper) {
      return false;
    }
    const anchors = wrapper.querySelectorAll("a");
    for (const anchor of anchors) {
      anchor.addEventListener("click", (e2) => {
        e2.preventDefault();
        const href = anchor.getAttribute("href");
        if (!href.startsWith("@client"))
          return;
        this.handleOpenFile(href);
      });
    }
  }
  replaceIconSources() {
    const path = this.path.get();
    const wrapper = this.wrapper.get();
    if (!path || !wrapper) {
      return false;
    }
    const images = wrapper.querySelectorAll("img");
    const icons = getAllImages();
    for (const image of images) {
      const src = image.getAttribute("src");
      for (const id in icons) {
        if (src == `#${id}`) {
          image.setAttribute("src", icons[id]);
        }
      }
      if (src.startsWith("@client"))
        image.setAttribute("src", src.replace("@client", "."));
    }
  }
  indexReadError() {
    createErrorDialog(
      {
        title: "Load failed!",
        message: "Help & Support can't find the Index file! Without it, it doesn't know what articles are available. Try restarting ArcOS, if that doesn't work, create a GitHub issue.",
        buttons: [
          {
            caption: "Close",
            action: () => this.closeApp(),
            suggested: true
          }
        ],
        image: BadStatusIcon,
        sound: "arcos.dialog.error"
      },
      this.pid,
      true
    );
    return false;
  }
  articleReadError(path = this.path.get()) {
    createErrorDialog(
      {
        title: "Wisdom out of reach!",
        message: `It seems you've found a glitch in the matrix. It's either that, or you modified the frontend. Regardless, the help article you tried to open doesn't exist.<br/><br/>Tried to open <code>${path}</code>`,
        buttons: [
          {
            caption: "Go Home",
            action: () => {
              this.handleOpenFile(this.STARTPATH);
            },
            suggested: true
          }
        ],
        image: BadStatusIcon,
        sound: "arcos.dialog.error"
      },
      this.pid,
      true
    );
    return false;
  }
};
function create_fragment$33(ctx) {
  let div;
  let markdownrenderer;
  let current;
  markdownrenderer = new MarkdownRenderer({ props: { content: (
    /*$buffer*/
    ctx[2]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(markdownrenderer.$$.fragment);
      attr(div, "class", "wrapper");
      toggle_class(
        div,
        "show",
        /*$renderArticle*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(markdownrenderer, div, null);
      ctx[6](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      const markdownrenderer_changes = {};
      if (dirty & /*$buffer*/
      4)
        markdownrenderer_changes.content = /*$buffer*/
        ctx2[2];
      markdownrenderer.$set(markdownrenderer_changes);
      if (!current || dirty & /*$renderArticle*/
      2) {
        toggle_class(
          div,
          "show",
          /*$renderArticle*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(markdownrenderer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(markdownrenderer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(markdownrenderer);
      ctx[6](null);
    }
  };
}
function instance$2O($$self, $$props, $$invalidate) {
  let $renderArticle;
  let $buffer;
  let { runtime } = $$props;
  const { buffer, renderArticle } = runtime;
  component_subscribe($$self, buffer, (value) => $$invalidate(2, $buffer = value));
  component_subscribe($$self, renderArticle, (value) => $$invalidate(1, $renderArticle = value));
  let wrapper;
  onMount(() => {
    runtime.wrapper.set(wrapper);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapper = $$value;
      $$invalidate(0, wrapper);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
  };
  return [wrapper, $renderArticle, $buffer, buffer, renderArticle, runtime, div_binding];
}
class Renderer2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2O, create_fragment$33, safe_not_equal, { runtime: 5 });
  }
}
function get_each_context$B(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list2[i2];
  return child_ctx;
}
function create_if_block$1n(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*article*/
    ctx[0].subitems
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$B(get_each_context$B(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "indent");
      toggle_class(
        div,
        "show",
        /*$path*/
        ctx[3] == /*article*/
        ctx[0].path
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*article, runtime*/
      3) {
        each_value = ensure_array_like(
          /*article*/
          ctx2[0].subitems
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$B(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$B(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*$path, article*/
      9) {
        toggle_class(
          div,
          "show",
          /*$path*/
          ctx2[3] == /*article*/
          ctx2[0].path
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$B(ctx) {
  let article_1;
  let current;
  article_1 = new Article_1({
    props: {
      article: (
        /*subArticle*/
        ctx[6]
      ),
      runtime: (
        /*runtime*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(article_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(article_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const article_1_changes = {};
      if (dirty & /*article*/
      1)
        article_1_changes.article = /*subArticle*/
        ctx2[6];
      if (dirty & /*runtime*/
      2)
        article_1_changes.runtime = /*runtime*/
        ctx2[1];
      article_1.$set(article_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(article_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(article_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(article_1, detaching);
    }
  };
}
function create_fragment$32(ctx) {
  let div;
  let button;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1_value = (
    /*article*/
    ctx[0].name + ""
  );
  let t1;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*article*/
    ctx[0].subitems && create_if_block$1n(ctx)
  );
  return {
    c() {
      div = element("div");
      button = element("button");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      if (!src_url_equal(img.src, img_src_value = /*icon*/
      ctx[2]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      toggle_class(
        button,
        "active",
        /*$path*/
        ctx[3] == /*article*/
        ctx[0].path
      );
      toggle_class(button, "subitems", !!/*article*/
      ctx[0].subitems);
      attr(div, "class", "article");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, img);
      append(button, t0);
      append(button, span);
      append(span, t1);
      append(div, t2);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*trigger*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*icon*/
      4 && !src_url_equal(img.src, img_src_value = /*icon*/
      ctx2[2])) {
        attr(img, "src", img_src_value);
      }
      if ((!current || dirty & /*article*/
      1) && t1_value !== (t1_value = /*article*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
      if (!current || dirty & /*$path, article*/
      9) {
        toggle_class(
          button,
          "active",
          /*$path*/
          ctx2[3] == /*article*/
          ctx2[0].path
        );
      }
      if (!current || dirty & /*article*/
      1) {
        toggle_class(button, "subitems", !!/*article*/
        ctx2[0].subitems);
      }
      if (
        /*article*/
        ctx2[0].subitems
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*article*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1n(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$2N($$self, $$props, $$invalidate) {
  let $path;
  let { article } = $$props;
  let { runtime } = $$props;
  const { path } = runtime;
  component_subscribe($$self, path, (value) => $$invalidate(3, $path = value));
  let icon = BookIcon;
  function trigger() {
    runtime.handleOpenFile(article.path);
  }
  onMount(() => {
    if (!article.icon)
      return;
    const icons = getAllImages();
    $$invalidate(2, icon = icons[article.icon] || BookIcon);
  });
  $$self.$$set = ($$props2) => {
    if ("article" in $$props2)
      $$invalidate(0, article = $$props2.article);
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [article, runtime, icon, $path, path, trigger];
}
class Article_1 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2N, create_fragment$32, safe_not_equal, { article: 0, runtime: 1 });
  }
}
function get_each_context$A(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function create_each_block$A(ctx) {
  let article_1;
  let current;
  article_1 = new Article_1({
    props: {
      article: (
        /*article*/
        ctx[3]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(article_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(article_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const article_1_changes = {};
      if (dirty & /*$Index*/
      2)
        article_1_changes.article = /*article*/
        ctx2[3];
      if (dirty & /*runtime*/
      1)
        article_1_changes.runtime = /*runtime*/
        ctx2[0];
      article_1.$set(article_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(article_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(article_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(article_1, detaching);
    }
  };
}
function create_fragment$31(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*$Index*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$A(get_each_context$A(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "sidebar");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$Index, runtime*/
      3) {
        each_value = ensure_array_like(
          /*$Index*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$A(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$A(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$2M($$self, $$props, $$invalidate) {
  let $Index;
  let { runtime } = $$props;
  const { Index } = runtime;
  component_subscribe($$self, Index, (value) => $$invalidate(1, $Index = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, $Index, Index];
}
let Sidebar$1 = class Sidebar2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2M, create_fragment$31, safe_not_equal, { runtime: 0 });
  }
};
const main$l = "";
function create_if_block$1m(ctx) {
  let splitpanes;
  let current;
  splitpanes = new Splitpanes({
    props: {
      $$slots: { default: [create_default_slot$j] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(splitpanes.$$.fragment);
    },
    m(target, anchor) {
      mount_component(splitpanes, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const splitpanes_changes = {};
      if (dirty & /*$$scope, runtime*/
      9) {
        splitpanes_changes.$$scope = { dirty, ctx: ctx2 };
      }
      splitpanes.$set(splitpanes_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(splitpanes.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(splitpanes.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(splitpanes, detaching);
    }
  };
}
function create_default_slot_2$a(ctx) {
  let renderer;
  let current;
  renderer = new Renderer2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(renderer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(renderer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const renderer_changes = {};
      if (dirty & /*runtime*/
      1)
        renderer_changes.runtime = /*runtime*/
        ctx2[0];
      renderer.$set(renderer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(renderer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(renderer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(renderer, detaching);
    }
  };
}
function create_default_slot_1$c(ctx) {
  let sidebar;
  let current;
  sidebar = new Sidebar$1({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(sidebar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sidebar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sidebar_changes = {};
      if (dirty & /*runtime*/
      1)
        sidebar_changes.runtime = /*runtime*/
        ctx2[0];
      sidebar.$set(sidebar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sidebar, detaching);
    }
  };
}
function create_default_slot$j(ctx) {
  let pane0;
  let t2;
  let pane1;
  let current;
  pane0 = new Pane({
    props: {
      minSize: 60,
      $$slots: { default: [create_default_slot_2$a] },
      $$scope: { ctx }
    }
  });
  pane1 = new Pane({
    props: {
      minSize: 30,
      size: 40,
      $$slots: { default: [create_default_slot_1$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(pane0.$$.fragment);
      t2 = space();
      create_component(pane1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pane0, target, anchor);
      insert(target, t2, anchor);
      mount_component(pane1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pane0_changes = {};
      if (dirty & /*$$scope, runtime*/
      9) {
        pane0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pane0.$set(pane0_changes);
      const pane1_changes = {};
      if (dirty & /*$$scope, runtime*/
      9) {
        pane1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pane1.$set(pane1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pane0.$$.fragment, local);
      transition_in(pane1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pane0.$$.fragment, local);
      transition_out(pane1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(pane0, detaching);
      destroy_component(pane1, detaching);
    }
  };
}
function create_fragment$30(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$Index*/
    ctx[1].length && create_if_block$1m(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$Index*/
        ctx2[1].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$Index*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1m(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$2L($$self, $$props, $$invalidate) {
  let $Index;
  let { runtime } = $$props;
  const { Index } = runtime;
  component_subscribe($$self, Index, (value) => $$invalidate(1, $Index = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, $Index, Index];
}
let App$h = class App14 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2L, create_fragment$30, safe_not_equal, { runtime: 0 });
  }
};
const HelpSupport = {
  metadata: {
    name: "Help & Support",
    description: "Get useful information and help",
    author: "The ArcOS Team",
    version: "1.0.5",
    icon: QuestionIcon,
    appGroup: "support"
  },
  runtime: Runtime$a,
  content: App$h,
  id: "HelpSupport",
  size: { w: 900, h: 550 },
  minSize: { w: 550, h: 400 },
  maxSize: { w: 1200, h: 900 },
  pos: { x: 150, y: 150 },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: true
  },
  controls: {
    minimize: true,
    maximize: true,
    close: true
  },
  singleInstance: true
};
const ICON_GROUP_CAPTIONS = {
  Branding: "ArcOS logos",
  General: "General icons",
  Apps: "Application icons",
  Filesystem: "Filesystem-related icons",
  Power: "Power icons",
  Dialog: "Dialog icons",
  Status: "Status indicators",
  Mimetypes: "File mimetypes"
};
const main$k = "";
function get_each_context$z(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2][0];
  child_ctx[2] = list2[i2][1];
  return child_ctx;
}
function get_each_context_1$4(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2][0];
  child_ctx[6] = list2[i2][1];
  return child_ctx;
}
function create_if_block$1l(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(Object.entries(
    /*groups*/
    ctx[0]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$z(get_each_context$z(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, groups*/
      1) {
        each_value = ensure_array_like(Object.entries(
          /*groups*/
          ctx2[0]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$z(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$z(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1$4(ctx) {
  let img;
  let img_src_value;
  let img_title_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*url*/
      ctx[6]))
        attr(img, "src", img_src_value);
      attr(img, "title", img_title_value = /*icon*/
      ctx[5]);
      attr(img, "alt", img_alt_value = /*icon*/
      ctx[5]);
      attr(img, "class", "icon");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups*/
      1 && !src_url_equal(img.src, img_src_value = /*url*/
      ctx2[6])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*groups*/
      1 && img_title_value !== (img_title_value = /*icon*/
      ctx2[5])) {
        attr(img, "title", img_title_value);
      }
      if (dirty & /*groups*/
      1 && img_alt_value !== (img_alt_value = /*icon*/
      ctx2[5])) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_each_block$z(ctx) {
  let div1;
  let h2;
  let t0_value = (ICON_GROUP_CAPTIONS[
    /*id*/
    ctx[1]
  ] || /*id*/
  ctx[1]) + "";
  let t0;
  let t1;
  let div0;
  let t2;
  let div1_class_value;
  let each_value_1 = ensure_array_like(Object.entries(
    /*items*/
    ctx[2]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i2));
  }
  return {
    c() {
      div1 = element("div");
      h2 = element("h2");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      attr(h2, "class", "header");
      attr(div0, "class", "icons");
      attr(div1, "class", div1_class_value = "group group-" + /*id*/
      ctx[1]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, h2);
      append(h2, t0);
      append(div1, t1);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups*/
      1 && t0_value !== (t0_value = (ICON_GROUP_CAPTIONS[
        /*id*/
        ctx2[1]
      ] || /*id*/
      ctx2[1]) + ""))
        set_data(t0, t0_value);
      if (dirty & /*Object, groups*/
      1) {
        each_value_1 = ensure_array_like(Object.entries(
          /*items*/
          ctx2[2]
        ));
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$4(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$4(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div0, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*groups*/
      1 && div1_class_value !== (div1_class_value = "group group-" + /*id*/
      ctx2[1])) {
        attr(div1, "class", div1_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$2$(ctx) {
  let if_block_anchor;
  let if_block = (
    /*groups*/
    ctx[0] && create_if_block$1l(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*groups*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1l(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$2K($$self, $$props, $$invalidate) {
  let groups;
  onMount(() => {
    $$invalidate(0, groups = getGroupedIcons());
  });
  return [groups];
}
let App$g = class App15 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2K, create_fragment$2$, safe_not_equal, {});
  }
};
let Runtime$9 = class Runtime14 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
  }
};
const IconLibrary = {
  metadata: {
    name: "Icon Library",
    description: "View the icons used in ArcOS",
    author: "Izaak Kuipers",
    version: "1.0.1",
    icon: IconLibraryIcon,
    hidden: true,
    appGroup: "utilities"
  },
  runtime: Runtime$9,
  content: App$g,
  id: "IconLibrary",
  size: { w: 595, h: NaN },
  minSize: { w: 500, h: 470 },
  maxSize: { w: NaN, h: NaN },
  pos: { x: 30, y: 40 },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: true
  },
  controls: {
    minimize: true,
    maximize: true,
    close: true
  },
  loadCondition: () => !SafeMode.get()
};
const main$j = "";
const ImageViewerAccelerators = (runtime) => {
  return [
    {
      key: "o",
      alt: true,
      shift: true,
      action() {
        runtime.openFileLocation();
      }
    },
    {
      key: "o",
      alt: true,
      action() {
        runtime.openFile();
      }
    },
    {
      key: "a",
      alt: true,
      shift: true,
      action() {
        runtime.setAsBackground();
      }
    }
  ];
};
const ImageViewerAltMenu = (runtime) => [
  {
    caption: "File",
    subItems: [
      {
        icon: "file_open",
        caption: "Open...",
        action: () => runtime.openFile(),
        accelerator: "Alt+O"
      },
      {
        icon: "folder_open",
        caption: "Open file location",
        action: () => {
          runtime.openFileLocation();
        },
        disabled: () => !runtime.path.get(),
        accelerator: "Alt+Shift+O"
      },
      SEP_ITEM,
      {
        image: PersonalizationIcon,
        caption: "Set as wallpaper",
        action() {
          runtime.setAsBackground();
        },
        disabled: () => !runtime.path.get()
      },
      SEP_ITEM,
      {
        caption: "Exit",
        action: () => {
          runtime.process.handler.kill(runtime.pid, true);
        },
        accelerator: "Alt+Q"
      }
    ]
  }
];
let Runtime$8 = class Runtime15 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "File", Store$1());
    __publicField(this, "buffer", Store$1());
    __publicField(this, "path", Store$1());
    __publicField(this, "url", Store$1());
    this.openedFile.subscribe(async (v2) => {
      if (!v2)
        return;
      await this.readFile(v2);
    });
    if (process.args.length && typeof process.args[0] === "string") {
      this.handleOpenFile(process.args[0]);
    } else {
      this.openFile();
    }
    this.loadAltMenu(...ImageViewerAltMenu(this));
    this.process.accelerator.store.push(...ImageViewerAccelerators(this));
  }
  async readFile(v2) {
    this.path.set(v2);
    const { setDone, setErrors } = await this.LoadProgress(v2);
    const file = await readFile(v2);
    if (!file) {
      setErrors(1);
      setDone(1);
      return;
    }
    this.buffer.set(await file.data.text());
    this.File.set(file);
    this.url.set(URL.createObjectURL(file.data));
    this.setWindowTitle(file.name);
    this.setWindowIcon(getMimeIcon(file.name));
    setDone(1);
  }
  openFile() {
    spawnOverlay(getAppById("LoadSaveDialog"), this.pid, [
      {
        title: "Select Image file to open",
        icon: ImageViewerIcon,
        extensions: MimeTypeIcons[ImageMimeIcon],
        startDir: getParentDirectory(this.path.get() || "./")
      }
    ]);
  }
  openFileLocation() {
    const path = this.path.get();
    if (!path)
      return;
    const split = path.split("/");
    const filename = split[split.length - 1];
    spawnApp("FileManager", 0, [path.replace(filename, "") || ".", path]);
  }
  setAsBackground() {
    if (!this.path.get())
      return;
    const path = this.path.get();
    const udata = UserDataStore.get();
    const base64 = toBase64(path);
    if (base64 == path)
      return;
    udata.sh.desktop.wallpaper = `@local:${base64}`;
    UserDataStore.set(udata);
  }
  async LoadProgress(v2 = this.path.get()) {
    return await FileProgress(
      {
        caption: "Reading Image",
        subtitle: pathToFriendlyPath(v2),
        icon: ImageMimeIcon,
        max: 1,
        done: 0,
        type: "quantity",
        waiting: false,
        working: true,
        errors: 0
      },
      this.pid,
      false
    );
  }
};
function create_if_block$1k(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*$url*/
      ctx[0]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$url*/
      1 && !src_url_equal(img.src, img_src_value = /*$url*/
      ctx2[0])) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_fragment$2_(ctx) {
  let if_block_anchor;
  let if_block = (
    /*$url*/
    ctx[0] && create_if_block$1k(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*$url*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1k(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$2J($$self, $$props, $$invalidate) {
  let $url;
  let { runtime } = $$props;
  const { url } = runtime;
  component_subscribe($$self, url, (value) => $$invalidate(0, $url = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [$url, url, runtime];
}
let App$f = class App16 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2J, create_fragment$2_, safe_not_equal, { runtime: 2 });
  }
};
const ImageViewer = {
  metadata: {
    name: "Image Viewer",
    description: "View images in ArcOS",
    author: "The ArcOS Team",
    version: "3.0.0",
    icon: ImageViewerIcon,
    appGroup: "utilities"
  },
  runtime: Runtime$8,
  content: App$f,
  id: "ImageViewer",
  size: { w: 640, h: 480 },
  minSize: { w: 300, h: 200 },
  maxSize: { w: 1200, h: 800 },
  pos: { x: 150, y: 150 },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: true
  },
  controls: {
    minimize: true,
    maximize: true,
    close: true
  },
  glass: true,
  acceleratorDescriptions: {
    "alt+shift+o": "Open the file in File Manager",
    "alt+o": "Open a file",
    "alt+shift+a": "Set the file as your desktop wallpaper"
  },
  loadCondition: () => !SafeMode.get(),
  helpArticle: HelpArticles.imageViewer
};
class LightsOffLevels {
  constructor(runtime) {
    __publicField(this, "runtime");
    __publicField(this, "_store", [
      [
        [false, false, false, false, true],
        [false, false, false, true, true],
        [false, false, false, false, true],
        [false, false, false, false, false],
        [false, false, false, false, false]
      ],
      [
        [false, false, false, false, false],
        [false, false, false, false, false],
        [false, false, false, false, false],
        [true, false, false, false, true],
        [true, true, false, true, true]
      ],
      [
        [true, true, false, true, true],
        [false, true, true, true, false],
        [false, true, true, true, false],
        [false, false, true, false, false],
        [false, false, false, false, false]
      ],
      [
        [false, true, false, false, false],
        [true, true, false, false, false],
        [false, true, true, true, false],
        [true, true, false, false, false],
        [false, true, false, false, false]
      ],
      [
        [true, false, false, false, true],
        [false, true, false, true, false],
        [false, true, false, true, false],
        [false, false, false, false, false],
        [false, false, false, false, false]
      ],
      [
        [true, true, true, false, false],
        [true, true, true, false, false],
        [true, false, true, true, false],
        [true, true, true, false, false],
        [true, true, true, false, false]
      ],
      [
        [true, true, false, false, false],
        [false, false, true, true, false],
        [false, false, true, false, false],
        [false, true, false, true, false],
        [true, true, false, true, true]
      ],
      [
        [true, false, false, false, true],
        [true, false, false, false, true],
        [false, true, true, true, false],
        [false, false, true, false, false],
        [false, false, true, false, false]
      ]
    ]);
    this.runtime = runtime;
  }
  loadLevel(level) {
    if (level >= this._store.length)
      return this.runtime.finish();
    if (!this._store[level])
      return;
    this.runtime.Grid.set(JSON.parse(JSON.stringify(this._store[level])));
    this.runtime.LEVEL.set(level);
    this.runtime.Clicks.set(0);
  }
  async checkNextLevel() {
    if (this.runtime.containsLights() || get_store_value(this.runtime.Clicks) == 0)
      return false;
    this.runtime.Transitioning.set(true);
    await sleep(300);
    this.runtime.LEVEL.set(get_store_value(this.runtime.LEVEL) + 1);
    if (get_store_value(this.runtime.LEVEL) > this._store.length)
      return this.runtime.finish();
    this.loadLevel(get_store_value(this.runtime.LEVEL));
    await sleep(200);
    this.runtime.Transitioning.set(false);
    return true;
  }
}
let Runtime$7 = class Runtime16 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "xModifiers", [-1, 0, 1]);
    __publicField(this, "yModifiers", [-1, 1]);
    __publicField(this, "Grid", Store$1([
      [false, false, false, false, false],
      [false, false, false, false, false],
      [false, false, false, false, false],
      [false, false, false, false, false],
      [false, false, false, false, false]
    ]));
    __publicField(this, "Transitioning", Store$1(false));
    __publicField(this, "Clicks", Store$1(0));
    __publicField(this, "LEVEL", Store$1(0));
    __publicField(this, "Levels");
    this.Levels = new LightsOffLevels(this);
    this.Grid.subscribe((v2) => {
      if (!v2)
        return;
      this.Levels.checkNextLevel();
      this.saveData();
    });
    this.LEVEL.subscribe(() => this.saveData());
    this.Clicks.subscribe(() => this.saveData());
    this.loadData();
  }
  containsLights() {
    this.Log("Checking lights", "containsLights");
    return JSON.stringify(this.Grid.get()).includes("true");
  }
  finish() {
    this.Log("User has won! Finishing...", "finish");
    createErrorDialog(
      {
        title: "You Win!",
        message: "You've managed to complete all 8 levels of Lights Off. The game will be reset so you can play it again in the future.",
        buttons: [
          {
            caption: "Play again",
            action: () => {
              this.LEVEL.set(0);
              this.Clicks.set(0);
              this.Levels.loadLevel(this.LEVEL.get());
            },
            suggested: true
          }
        ],
        image: LightsOffIcon
      },
      this.pid,
      true
    );
  }
  ToggleLight(x2, y2) {
    this.Log(`Toggling ${x2}x${y2}`, "ToggleLight");
    const grid = this.Grid.get();
    if (!grid[y2])
      return;
    if (typeof grid[y2][x2] !== "boolean")
      return;
    this.Clicks.set(this.Clicks.get() + 1);
    for (let i2 = 0; i2 < this.xModifiers.length; i2++) {
      const value = grid[y2][x2 + this.xModifiers[i2]];
      if (typeof value !== "boolean")
        continue;
      grid[y2][x2 + this.xModifiers[i2]] = !value;
    }
    for (let i2 = 0; i2 < this.yModifiers.length; i2++) {
      const rowExists = Array.isArray(grid[y2 + this.yModifiers[i2]]);
      if (!rowExists)
        continue;
      const value = grid[y2 + this.yModifiers[i2]][x2];
      if (typeof value !== "boolean")
        continue;
      grid[y2 + this.yModifiers[i2]][x2] = !value;
    }
    this.Grid.set(grid);
  }
  loadData() {
    this.Log("Loading Data from UserData", "loadData");
    const data2 = UserDataStore.get().appdata[this.app.id];
    if (data2 && data2.level) {
      this.Levels.loadLevel(data2.level);
      this.Grid.set(data2.grid);
      this.Clicks.set(data2.clicks);
      return;
    }
    this.Levels.loadLevel(0);
  }
  saveData() {
    if (this.LEVEL.get() == 0 && !this.containsLights())
      return this.Log("Not saving default state!", "saveData", LogLevel.warn);
    UserDataStore.update((udata) => {
      udata.appdata[this.app.id] = {
        clicks: this.Clicks.get(),
        level: this.LEVEL.get(),
        grid: this.Grid.get()
      };
      return udata;
    });
  }
};
const Light_svelte_svelte_type_style_lang = "";
function create_fragment$2Z(ctx) {
  let button;
  let button_id_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      attr(button, "id", button_id_value = "pos-" + /*x*/
      ctx[1] + "x" + /*y*/
      ctx[2]);
      attr(button, "class", "light svelte-11uaj66");
      toggle_class(
        button,
        "lit",
        /*light*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggle*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*x, y*/
      6 && button_id_value !== (button_id_value = "pos-" + /*x*/
      ctx2[1] + "x" + /*y*/
      ctx2[2])) {
        attr(button, "id", button_id_value);
      }
      if (dirty & /*light*/
      1) {
        toggle_class(
          button,
          "lit",
          /*light*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2I($$self, $$props, $$invalidate) {
  let { light = false } = $$props;
  let { x: x2 } = $$props;
  let { y: y2 } = $$props;
  let { runtime } = $$props;
  function toggle() {
    runtime.ToggleLight(x2, y2);
  }
  $$self.$$set = ($$props2) => {
    if ("light" in $$props2)
      $$invalidate(0, light = $$props2.light);
    if ("x" in $$props2)
      $$invalidate(1, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y2 = $$props2.y);
    if ("runtime" in $$props2)
      $$invalidate(4, runtime = $$props2.runtime);
  };
  return [light, x2, y2, toggle, runtime];
}
class Light extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2I, create_fragment$2Z, safe_not_equal, { light: 0, x: 1, y: 2, runtime: 4 });
  }
}
const Stats_svelte_svelte_type_style_lang = "";
function create_fragment$2Y(ctx) {
  let div3;
  let button;
  let t0;
  let button_disabled_value;
  let t1;
  let div2;
  let div0;
  let t2;
  let t3_value = (
    /*$LEVEL*/
    ctx[0] + 1 + ""
  );
  let t3;
  let t4;
  let div1;
  let t5;
  let t6;
  let t7_value = (
    /*$Clicks*/
    ctx[1] == 1 ? "" : "s"
  );
  let t7;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      button = element("button");
      t0 = text("Start Over");
      t1 = space();
      div2 = element("div");
      div0 = element("div");
      t2 = text("Level ");
      t3 = text(t3_value);
      t4 = space();
      div1 = element("div");
      t5 = text(
        /*$Clicks*/
        ctx[1]
      );
      t6 = text(" Click");
      t7 = text(t7_value);
      attr(button, "class", "reset-game svelte-192gzm8");
      button.disabled = button_disabled_value = /*$LEVEL*/
      ctx[0] == 0 && /*$Clicks*/
      ctx[1] == 0;
      attr(div0, "class", "stat svelte-192gzm8");
      attr(div1, "class", "stat svelte-192gzm8");
      attr(div2, "class", "right svelte-192gzm8");
      attr(div3, "class", "statistics svelte-192gzm8");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, button);
      append(button, t0);
      append(div3, t1);
      append(div3, div2);
      append(div2, div0);
      append(div0, t2);
      append(div0, t3);
      append(div2, t4);
      append(div2, div1);
      append(div1, t5);
      append(div1, t6);
      append(div1, t7);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*reset*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$LEVEL, $Clicks*/
      3 && button_disabled_value !== (button_disabled_value = /*$LEVEL*/
      ctx2[0] == 0 && /*$Clicks*/
      ctx2[1] == 0)) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*$LEVEL*/
      1 && t3_value !== (t3_value = /*$LEVEL*/
      ctx2[0] + 1 + ""))
        set_data(t3, t3_value);
      if (dirty & /*$Clicks*/
      2)
        set_data(
          t5,
          /*$Clicks*/
          ctx2[1]
        );
      if (dirty & /*$Clicks*/
      2 && t7_value !== (t7_value = /*$Clicks*/
      ctx2[1] == 1 ? "" : "s"))
        set_data(t7, t7_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2H($$self, $$props, $$invalidate) {
  let $UserDataStore;
  let $LEVEL;
  let $Clicks;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(7, $UserDataStore = $$value));
  let { app } = $$props;
  let { runtime } = $$props;
  const { LEVEL, Clicks } = runtime;
  component_subscribe($$self, LEVEL, (value) => $$invalidate(0, $LEVEL = value));
  component_subscribe($$self, Clicks, (value) => $$invalidate(1, $Clicks = value));
  function reset() {
    set_store_value(UserDataStore, $UserDataStore.appdata[app.id] = null, $UserDataStore);
    runtime.loadData();
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(5, app = $$props2.app);
    if ("runtime" in $$props2)
      $$invalidate(6, runtime = $$props2.runtime);
  };
  return [$LEVEL, $Clicks, LEVEL, Clicks, reset, app, runtime];
}
class Stats extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2H, create_fragment$2Y, safe_not_equal, { app: 5, runtime: 6 });
  }
}
const main$i = "";
const App_svelte_svelte_type_style_lang = "";
function get_each_context$y(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list2[i2];
  child_ctx[8] = i2;
  return child_ctx;
}
function get_each_context_1$3(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list2[i2];
  child_ctx[11] = i2;
  return child_ctx;
}
function create_each_block_1$3(ctx) {
  let light_1;
  let current;
  light_1 = new Light({
    props: {
      light: (
        /*light*/
        ctx[9]
      ),
      x: (
        /*x*/
        ctx[11]
      ),
      y: (
        /*y*/
        ctx[8]
      ),
      runtime: (
        /*runtime*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(light_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(light_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const light_1_changes = {};
      if (dirty & /*$Grid*/
      8)
        light_1_changes.light = /*light*/
        ctx2[9];
      if (dirty & /*runtime*/
      2)
        light_1_changes.runtime = /*runtime*/
        ctx2[1];
      light_1.$set(light_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(light_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(light_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(light_1, detaching);
    }
  };
}
function create_each_block$y(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*row*/
    ctx[6]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$Grid, runtime*/
      10) {
        each_value_1 = ensure_array_like(
          /*row*/
          ctx2[6]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$3(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$2X(ctx) {
  let stats;
  let t2;
  let div;
  let current;
  stats = new Stats({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      runtime: (
        /*runtime*/
        ctx[1]
      )
    }
  });
  let each_value = ensure_array_like(
    /*$Grid*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$y(get_each_context$y(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      create_component(stats.$$.fragment);
      t2 = space();
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "grid svelte-1ocaw0n");
      toggle_class(
        div,
        "transitioning",
        /*$Transitioning*/
        ctx[2]
      );
    },
    m(target, anchor) {
      mount_component(stats, target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const stats_changes = {};
      if (dirty & /*app*/
      1)
        stats_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*runtime*/
      2)
        stats_changes.runtime = /*runtime*/
        ctx2[1];
      stats.$set(stats_changes);
      if (dirty & /*$Grid, runtime*/
      10) {
        each_value = ensure_array_like(
          /*$Grid*/
          ctx2[3]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$y(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$y(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*$Transitioning*/
      4) {
        toggle_class(
          div,
          "transitioning",
          /*$Transitioning*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(stats.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(stats.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(div);
      }
      destroy_component(stats, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$2G($$self, $$props, $$invalidate) {
  let $Transitioning;
  let $Grid;
  let { app } = $$props;
  let { runtime } = $$props;
  const { Grid: Grid2, Transitioning } = runtime;
  component_subscribe($$self, Grid2, (value) => $$invalidate(3, $Grid = value));
  component_subscribe($$self, Transitioning, (value) => $$invalidate(2, $Transitioning = value));
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [app, runtime, $Transitioning, $Grid, Grid2, Transitioning];
}
let App$e = class App17 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2G, create_fragment$2X, safe_not_equal, { app: 0, runtime: 1 });
  }
};
const LightsOff = {
  metadata: {
    name: "Lights Off",
    description: "Turn off all the lights!",
    version: "1.0.0",
    author: "Tim Horton, ported to ArcOS by IzKuipers",
    icon: LightsOffIcon,
    appGroup: "entertainment"
  },
  runtime: Runtime$7,
  content: App$e,
  id: "LightsOff",
  size: { w: 442, h: NaN },
  pos: { x: 80, y: 80 },
  minSize: { w: 442, h: NaN },
  maxSize: { w: 442, h: NaN },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: {
    minimize: true,
    maximize: false,
    close: true
  },
  glass: true,
  singleInstance: true,
  loadCondition: () => !SafeMode.get(),
  helpArticle: HelpArticles.lightsOff
};
let Runtime$6 = class Runtime17 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "target", Store$1());
    __publicField(this, "path", Store$1());
    __publicField(this, "selected", Store$1());
    __publicField(this, "_refreshLocked", false);
    __publicField(this, "contents", Store$1());
    __publicField(this, "loading", Store$1(true));
    __publicField(this, "failed", Store$1(false));
    __publicField(this, "data", Store$1());
    __publicField(this, "isSave", Store$1(false));
    function stop2() {
      process.handler.kill(process.pid, true);
      sendNotification({
        title: "Can't open Load/save Dialog",
        message: `No valid data was specified to use in the dialog. Aborting.`,
        image: WarningIcon,
        timeout: 3e3
      });
    }
    const data2 = process.args[0];
    if (!app.isOverlay || !data2) {
      stop2();
      return;
    }
    mutator.update((v2) => {
      v2.metadata.name = data2.title;
      v2.metadata.icon = data2.icon || ComponentIcon;
      return v2;
    });
    this.data.set(data2);
    this.isSave.set(data2.isSave);
    this.path.set(
      data2.startDir && !data2.startDir.startsWith("@client") ? data2.startDir : "./"
    );
    this.target.set(data2.targetPid || this.process.parentPid);
    this.selected.set(data2.saveName || "");
    this._init();
  }
  async _init() {
    GlobalDispatch.subscribe("fs-flush", () => this.refresh());
    this.navigate(this.path.get());
  }
  async refresh() {
    if (this._refreshLocked)
      return;
    this.contents.set(void 0);
    this.loading.set(true);
    this.failed.set(false);
    const contents = await readDirectory(this.path.get());
    this.loading.set(false);
    if (!contents) {
      this.FileNotFound();
      return false;
    }
    this.contents.set(contents);
    return true;
  }
  async parentDir() {
    const current = this.path.get();
    const parent = getParentDirectory(current);
    if (parent == current)
      return;
    return await this.navigate(parent);
  }
  async navigate(path) {
    this.path.set(path);
    await this.refresh();
  }
  FileNotFound(path = this.path.get()) {
    this.failed.set(true);
    createErrorDialog(
      {
        title: "Location not found",
        message: `Folder <code>${path}</code> does not exist on your filesystem. Did you make a typo?`,
        image: ErrorIcon,
        buttons: [
          {
            caption: "Go Home",
            action: () => {
              this.navigate("./");
            },
            suggested: true
          }
        ]
      },
      this.pid,
      true
    );
  }
  ConfirmFile() {
    const pid = this.target.get();
    const dir = this.path.get();
    const file = this.selected.get();
    const path = `${dir}/${file}`.replaceAll("//", "/");
    const event = this.isSave.get() ? "save-file" : "open-file";
    ProcessStack.dispatch.dispatchToPid(pid, event, path);
  }
  async Cancel() {
    const pid = this.target.get();
    ProcessStack.dispatch.dispatchToPid(pid, "ls-dialog-cancel");
    await this.process.handler.kill(this.pid, true);
  }
};
function create_fragment$2W(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<img src="${ErrorIcon}" alt=""/>
  Folder not found!`;
      attr(div, "class", "center-flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
class Failed2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$2W, safe_not_equal, {});
  }
}
function create_fragment$2V(ctx) {
  let button;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let div1;
  let t1_value = (
    /*file*/
    ctx[0].filename + ""
  );
  let t1;
  let div1_title_value;
  let t2;
  let div2;
  let t3;
  let t4;
  let div3;
  let t5_value = formatBytes(
    /*file*/
    ctx[0].size
  ) + "";
  let t5;
  let t6;
  let div4;
  let t7;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      t3 = text(
        /*mime*/
        ctx[2]
      );
      t4 = space();
      div3 = element("div");
      t5 = text(t5_value);
      t6 = space();
      div4 = element("div");
      t7 = text(
        /*date*/
        ctx[1]
      );
      if (!src_url_equal(img.src, img_src_value = /*icon*/
      ctx[3]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(div0, "class", "segment icon");
      attr(div1, "class", "segment name");
      attr(div1, "title", div1_title_value = /*file*/
      ctx[0].filename);
      attr(div2, "class", "segment type");
      attr(div3, "class", "segment size");
      attr(div4, "class", "segment modified");
      attr(button, "class", "item file");
      button.disabled = /*incompatible*/
      ctx[4];
      toggle_class(
        button,
        "selected",
        /*$selected*/
        ctx[5] == /*file*/
        ctx[0].filename
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div0);
      append(div0, img);
      append(button, t0);
      append(button, div1);
      append(div1, t1);
      append(button, t2);
      append(button, div2);
      append(div2, t3);
      append(button, t4);
      append(button, div3);
      append(div3, t5);
      append(button, t6);
      append(button, div4);
      append(div4, t7);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*select*/
            ctx[8]
          ),
          listen(
            button,
            "dblclick",
            /*open*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*icon*/
      8 && !src_url_equal(img.src, img_src_value = /*icon*/
      ctx2[3])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*file*/
      1 && t1_value !== (t1_value = /*file*/
      ctx2[0].filename + ""))
        set_data(t1, t1_value);
      if (dirty & /*file*/
      1 && div1_title_value !== (div1_title_value = /*file*/
      ctx2[0].filename)) {
        attr(div1, "title", div1_title_value);
      }
      if (dirty & /*mime*/
      4)
        set_data(
          t3,
          /*mime*/
          ctx2[2]
        );
      if (dirty & /*file*/
      1 && t5_value !== (t5_value = formatBytes(
        /*file*/
        ctx2[0].size
      ) + ""))
        set_data(t5, t5_value);
      if (dirty & /*date*/
      2)
        set_data(
          t7,
          /*date*/
          ctx2[1]
        );
      if (dirty & /*incompatible*/
      16) {
        button.disabled = /*incompatible*/
        ctx2[4];
      }
      if (dirty & /*$selected, file*/
      33) {
        toggle_class(
          button,
          "selected",
          /*$selected*/
          ctx2[5] == /*file*/
          ctx2[0].filename
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2F($$self, $$props, $$invalidate) {
  let $data;
  let $selected;
  let { file } = $$props;
  let { runtime } = $$props;
  const { selected, data: data2 } = runtime;
  component_subscribe($$self, selected, (value) => $$invalidate(5, $selected = value));
  component_subscribe($$self, data2, (value) => $$invalidate(11, $data = value));
  let date = "";
  let mime2 = "";
  let icon = "";
  let incompatible = false;
  onMount(() => {
    dayjs.extend(relativeTime);
    dayjs.extend(updateLocale);
    dayjs.updateLocale("en", RelativeTimeMod);
    $$invalidate(1, date = dayjs(file.dateModified).fromNow());
    const m3 = humanFiletypes.fromMime(file.mime);
    $$invalidate(2, mime2 = m3.replace(m3[0], m3[0].toUpperCase()));
    $$invalidate(3, icon = getMimeIcon(file.filename));
    const extension = parseExtension(file.scopedPath);
    $$invalidate(4, incompatible = $data.extensions && !$data.extensions.includes(extension));
  });
  async function select() {
    if (incompatible)
      return;
    await sleep(0);
    runtime.selected.set(file.filename);
  }
  function open() {
    if (incompatible)
      return;
    runtime.ConfirmFile();
    ProcessStack.kill(runtime.pid, true);
  }
  $$self.$$set = ($$props2) => {
    if ("file" in $$props2)
      $$invalidate(0, file = $$props2.file);
    if ("runtime" in $$props2)
      $$invalidate(10, runtime = $$props2.runtime);
  };
  return [
    file,
    date,
    mime2,
    icon,
    incompatible,
    $selected,
    selected,
    data2,
    select,
    open,
    runtime
  ];
}
class FileItem2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2F, create_fragment$2V, safe_not_equal, { file: 0, runtime: 10 });
  }
}
function create_fragment$2U(ctx) {
  let button;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let div1;
  let t1_value = (
    /*dir*/
    ctx[0].name + ""
  );
  let t1;
  let t2;
  let div2;
  let t4;
  let div3;
  let t6;
  let div4;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      div2.textContent = "Folder";
      t4 = space();
      div3 = element("div");
      div3.textContent = "-";
      t6 = space();
      div4 = element("div");
      div4.textContent = "-";
      if (!src_url_equal(img.src, img_src_value = /*icon*/
      ctx[1]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(div0, "class", "segment icon");
      attr(div1, "class", "segment name");
      attr(div2, "class", "segment type");
      attr(div3, "class", "segment size");
      attr(div4, "class", "segment modified");
      attr(button, "class", "item folder");
      toggle_class(
        button,
        "selected",
        /*selected*/
        ctx[2].includes(
          /*dir*/
          ctx[0].scopedPath
        )
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div0);
      append(div0, img);
      append(button, t0);
      append(button, div1);
      append(div1, t1);
      append(button, t2);
      append(button, div2);
      append(button, t4);
      append(button, div3);
      append(button, t6);
      append(button, div4);
      if (!mounted) {
        dispose = listen(
          button,
          "dblclick",
          /*goHere*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*icon*/
      2 && !src_url_equal(img.src, img_src_value = /*icon*/
      ctx2[1])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*dir*/
      1 && t1_value !== (t1_value = /*dir*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*selected, dir*/
      5) {
        toggle_class(
          button,
          "selected",
          /*selected*/
          ctx2[2].includes(
            /*dir*/
            ctx2[0].scopedPath
          )
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2E($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { dir } = $$props;
  let selected = [];
  let icon = FolderIcon;
  onMount(() => $$invalidate(1, icon = GetSystemFolderIcon(dir.scopedPath)));
  function goHere() {
    runtime.navigate(dir.scopedPath);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(4, runtime = $$props2.runtime);
    if ("dir" in $$props2)
      $$invalidate(0, dir = $$props2.dir);
  };
  return [dir, icon, selected, goHere, runtime];
}
class FolderItem2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2E, create_fragment$2U, safe_not_equal, { runtime: 4, dir: 0 });
  }
}
function create_fragment$2T(ctx) {
  let button;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<div class="segment name">Name</div> <div class="segment type">Type</div> <div class="segment size">Size</div> <div class="segment modified">Modified</div>`;
      attr(button, "class", "item header-row");
    },
    m(target, anchor) {
      insert(target, button, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
    }
  };
}
let Header$8 = class Header5 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$2T, safe_not_equal, {});
  }
};
function create_fragment$2S(ctx) {
  let div;
  let spinner;
  let current;
  spinner = new Spinner({ props: { height: 32 } });
  return {
    c() {
      div = element("div");
      create_component(spinner.$$.fragment);
      attr(div, "class", "center-flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(spinner, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(spinner);
    }
  };
}
class Loading3 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$2S, safe_not_equal, {});
  }
}
function get_each_context$x(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list2[i2];
  return child_ctx;
}
function get_each_context_1$2(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list2[i2];
  return child_ctx;
}
function create_if_block_2$9(ctx) {
  let t0;
  let t1;
  let if_block_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*contents*/
    ctx[1].directories
  );
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  let each_value = ensure_array_like(
    /*contents*/
    ctx[1].files
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$x(get_each_context$x(ctx, each_value, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = !/*contents*/
  ctx[1].files.length && !/*contents*/
  ctx[1].directories.length && create_if_block_3$3();
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t0 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(target, anchor);
        }
      }
      insert(target, t0, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*runtime, contents*/
      3) {
        each_value_1 = ensure_array_like(
          /*contents*/
          ctx2[1].directories
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_1$2(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(t0.parentNode, t0);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (dirty & /*contents, runtime*/
      3) {
        each_value = ensure_array_like(
          /*contents*/
          ctx2[1].files
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$x(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$x(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t1.parentNode, t1);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
      if (!/*contents*/
      ctx2[1].files.length && !/*contents*/
      ctx2[1].directories.length) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_3$3();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block_anchor);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_each_block_1$2(ctx) {
  let folderitem;
  let current;
  folderitem = new FolderItem2({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      dir: (
        /*dir*/
        ctx[11]
      )
    }
  });
  return {
    c() {
      create_component(folderitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(folderitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const folderitem_changes = {};
      if (dirty & /*runtime*/
      1)
        folderitem_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*contents*/
      2)
        folderitem_changes.dir = /*dir*/
        ctx2[11];
      folderitem.$set(folderitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(folderitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folderitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(folderitem, detaching);
    }
  };
}
function create_each_block$x(ctx) {
  let fileitem;
  let current;
  fileitem = new FileItem2({
    props: {
      file: (
        /*file*/
        ctx[8]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(fileitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fileitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const fileitem_changes = {};
      if (dirty & /*contents*/
      2)
        fileitem_changes.file = /*file*/
        ctx2[8];
      if (dirty & /*runtime*/
      1)
        fileitem_changes.runtime = /*runtime*/
        ctx2[0];
      fileitem.$set(fileitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fileitem, detaching);
    }
  };
}
function create_if_block_3$3(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "This folder is empty.";
      attr(p2, "class", "empty");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_if_block_1$r(ctx) {
  let failed_1;
  let current;
  failed_1 = new Failed2({});
  return {
    c() {
      create_component(failed_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(failed_1, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(failed_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(failed_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(failed_1, detaching);
    }
  };
}
function create_if_block$1j(ctx) {
  let loading_1;
  let current;
  loading_1 = new Loading3({});
  return {
    c() {
      create_component(loading_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading_1, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loading_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading_1, detaching);
    }
  };
}
function create_fragment$2R(ctx) {
  let div;
  let header2;
  let t0;
  let t1;
  let t2;
  let current;
  header2 = new Header$8({});
  let if_block0 = (
    /*contents*/
    ctx[1] && create_if_block_2$9(ctx)
  );
  let if_block1 = (
    /*$failed*/
    ctx[3] && create_if_block_1$r()
  );
  let if_block2 = (
    /*$loading*/
    ctx[4] && create_if_block$1j()
  );
  return {
    c() {
      div = element("div");
      create_component(header2.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      attr(div, "class", "directory-viewer");
      attr(div, "role", "directory");
      toggle_class(
        div,
        "grid",
        /*$UserDataStore*/
        ctx[2].appdata.FileManager.grid
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(header2, div, null);
      append(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t2);
      if (if_block2)
        if_block2.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*contents*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*contents*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$9(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$failed*/
        ctx2[3]
      ) {
        if (if_block1) {
          if (dirty & /*$failed*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$r();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$loading*/
        ctx2[4]
      ) {
        if (if_block2) {
          if (dirty & /*$loading*/
          16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$1j();
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*$UserDataStore*/
      4) {
        toggle_class(
          div,
          "grid",
          /*$UserDataStore*/
          ctx2[2].appdata.FileManager.grid
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(header2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance$2D($$self, $$props, $$invalidate) {
  let $UserDataStore;
  let $failed;
  let $loading;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(2, $UserDataStore = $$value));
  let { runtime } = $$props;
  const { failed, loading, contents: ContentsStore } = runtime;
  component_subscribe($$self, failed, (value) => $$invalidate(3, $failed = value));
  component_subscribe($$self, loading, (value) => $$invalidate(4, $loading = value));
  let contents;
  ContentsStore.subscribe(async (v2) => {
    $$invalidate(1, contents = void 0);
    sleep(0);
    $$invalidate(1, contents = v2);
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, contents, $UserDataStore, $failed, $loading, failed, loading];
}
class DirectoryViewer2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2D, create_fragment$2R, safe_not_equal, { runtime: 0 });
  }
}
function create_fragment$2Q(ctx) {
  let div4;
  let div1;
  let button0;
  let t1;
  let div0;
  let t2;
  let t3;
  let div2;
  let t4;
  let div3;
  let button1;
  let t6;
  let button2;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div1 = element("div");
      button0 = element("button");
      button0.textContent = "arrow_upward";
      t1 = space();
      div0 = element("div");
      t2 = text(
        /*pathStr*/
        ctx[2]
      );
      t3 = space();
      div2 = element("div");
      t4 = space();
      div3 = element("div");
      button1 = element("button");
      button1.textContent = "format_list_bulleted";
      t6 = space();
      button2 = element("button");
      button2.textContent = "grid_on";
      attr(button0, "class", "material-icons-round parent");
      attr(div0, "class", "path");
      attr(div1, "class", "portion address");
      attr(div2, "class", "sep");
      attr(button1, "class", "material-icons-round");
      toggle_class(button1, "suggested", !/*grid*/
      ctx[1]);
      attr(button2, "class", "material-icons-round");
      toggle_class(
        button2,
        "suggested",
        /*grid*/
        ctx[1]
      );
      attr(div3, "class", "portion");
      attr(div4, "class", "address-bar");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div1);
      append(div1, button0);
      append(div1, t1);
      append(div1, div0);
      append(div0, t2);
      append(div4, t3);
      append(div4, div2);
      append(div4, t4);
      append(div4, div3);
      append(div3, button1);
      append(div3, t6);
      append(div3, button2);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[5]
          ),
          listen(
            button1,
            "click",
            /*gridOff*/
            ctx[3]
          ),
          listen(
            button2,
            "click",
            /*gridOn*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*pathStr*/
      4)
        set_data(
          t2,
          /*pathStr*/
          ctx2[2]
        );
      if (dirty & /*grid*/
      2) {
        toggle_class(button1, "suggested", !/*grid*/
        ctx2[1]);
      }
      if (dirty & /*grid*/
      2) {
        toggle_class(
          button2,
          "suggested",
          /*grid*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2C($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(6, $UserDataStore = $$value));
  let { runtime } = $$props;
  let grid = false;
  let pathStr = "";
  const { path } = runtime;
  path.subscribe((v2) => $$invalidate(2, pathStr = pathToFriendlyPath(v2)));
  UserDataStore.subscribe((v2) => {
    $$invalidate(1, grid = !!$UserDataStore.appdata.FileManager.grid);
  });
  function gridOff() {
    set_store_value(UserDataStore, $UserDataStore.appdata.FileManager.grid = false, $UserDataStore);
  }
  function gridOn() {
    set_store_value(UserDataStore, $UserDataStore.appdata.FileManager.grid = true, $UserDataStore);
  }
  const click_handler = () => runtime.parentDir();
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, grid, pathStr, gridOff, gridOn, click_handler];
}
let Header$7 = class Header6 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2C, create_fragment$2Q, safe_not_equal, { runtime: 0 });
  }
};
function create_fragment$2P(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "class", "name-input");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*$selected*/
        ctx[0]
      );
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$selected*/
      1 && input.value !== /*$selected*/
      ctx2[0]) {
        set_input_value(
          input,
          /*$selected*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2B($$self, $$props, $$invalidate) {
  let $selected;
  let { runtime } = $$props;
  const { selected } = runtime;
  component_subscribe($$self, selected, (value) => $$invalidate(0, $selected = value));
  function input_input_handler() {
    $selected = this.value;
    selected.set($selected);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [$selected, selected, runtime, input_input_handler];
}
class NameInput extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2B, create_fragment$2P, safe_not_equal, { runtime: 2 });
  }
}
function create_else_block$j(ctx) {
  let p2;
  let t0;
  let t1;
  let t2_value = Plural(
    "item",
    /*size*/
    ctx[1]
  ) + "";
  let t2;
  let t3;
  let t4;
  return {
    c() {
      p2 = element("p");
      t0 = text(
        /*size*/
        ctx[1]
      );
      t1 = space();
      t2 = text(t2_value);
      t3 = text(" in ");
      t4 = text(
        /*folder*/
        ctx[2]
      );
      attr(p2, "class", "count");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      append(p2, t0);
      append(p2, t1);
      append(p2, t2);
      append(p2, t3);
      append(p2, t4);
    },
    p(ctx2, dirty) {
      if (dirty & /*size*/
      2)
        set_data(
          t0,
          /*size*/
          ctx2[1]
        );
      if (dirty & /*size*/
      2 && t2_value !== (t2_value = Plural(
        "item",
        /*size*/
        ctx2[1]
      ) + ""))
        set_data(t2, t2_value);
      if (dirty & /*folder*/
      4)
        set_data(
          t4,
          /*folder*/
          ctx2[2]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_if_block$1i(ctx) {
  let nameinput;
  let current;
  nameinput = new NameInput({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(nameinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nameinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const nameinput_changes = {};
      if (dirty & /*runtime*/
      1)
        nameinput_changes.runtime = /*runtime*/
        ctx2[0];
      nameinput.$set(nameinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nameinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nameinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nameinput, detaching);
    }
  };
}
function create_fragment$2O(ctx) {
  let div1;
  let current_block_type_index;
  let if_block;
  let t0;
  let div0;
  let button0;
  let t2;
  let button1;
  let t3_value = (
    /*$isSave*/
    ctx[3] ? "Save" : "Open"
  );
  let t3;
  let button1_disabled_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$1i, create_else_block$j];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$isSave*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element("div");
      if_block.c();
      t0 = space();
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "Cancel";
      t2 = space();
      button1 = element("button");
      t3 = text(t3_value);
      attr(button0, "class", "cancel");
      attr(button1, "class", "confirm suggested");
      button1.disabled = button1_disabled_value = !/*$selected*/
      ctx[4];
      attr(div0, "class", "confirm");
      attr(div1, "class", "toolbar");
      toggle_class(
        div1,
        "saving",
        /*$isSave*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if_blocks[current_block_type_index].m(div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div0, button0);
      append(div0, t2);
      append(div0, button1);
      append(button1, t3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*exit*/
            ctx[8]
          ),
          listen(
            button1,
            "click",
            /*sendOff*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, t0);
      }
      if ((!current || dirty & /*$isSave*/
      8) && t3_value !== (t3_value = /*$isSave*/
      ctx2[3] ? "Save" : "Open"))
        set_data(t3, t3_value);
      if (!current || dirty & /*$selected*/
      16 && button1_disabled_value !== (button1_disabled_value = !/*$selected*/
      ctx2[4])) {
        button1.disabled = button1_disabled_value;
      }
      if (!current || dirty & /*$isSave*/
      8) {
        toggle_class(
          div1,
          "saving",
          /*$isSave*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2A($$self, $$props, $$invalidate) {
  let $isSave;
  let $selected;
  let { runtime } = $$props;
  let size = 0;
  let folder = "";
  const { isSave, selected, contents: contentsStore } = runtime;
  component_subscribe($$self, isSave, (value) => $$invalidate(3, $isSave = value));
  component_subscribe($$self, selected, (value) => $$invalidate(4, $selected = value));
  contentsStore.subscribe((v2) => {
    if (!v2)
      return;
    $$invalidate(2, folder = pathToFriendlyName(v2.scopedPath));
    $$invalidate(1, size = v2.directories.length + v2.files.length);
  });
  function sendOff() {
    runtime.ConfirmFile();
    exit();
  }
  function exit() {
    ProcessStack.kill(runtime.pid, true);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, size, folder, $isSave, $selected, isSave, selected, sendOff, exit];
}
let Toolbar$4 = class Toolbar4 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2A, create_fragment$2O, safe_not_equal, { runtime: 0 });
  }
};
const main$h = "";
function create_fragment$2N(ctx) {
  let titlebar;
  let t0;
  let header2;
  let t1;
  let directoryviewer;
  let t2;
  let toolbar;
  let current;
  titlebar = new Titlebar({
    props: {
      app: (
        /*runtime*/
        ctx[0].appMutator
      ),
      pid: (
        /*runtime*/
        ctx[0].pid
      )
    }
  });
  header2 = new Header$7({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  directoryviewer = new DirectoryViewer2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  toolbar = new Toolbar$4({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(titlebar.$$.fragment);
      t0 = space();
      create_component(header2.$$.fragment);
      t1 = space();
      create_component(directoryviewer.$$.fragment);
      t2 = space();
      create_component(toolbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(titlebar, target, anchor);
      insert(target, t0, anchor);
      mount_component(header2, target, anchor);
      insert(target, t1, anchor);
      mount_component(directoryviewer, target, anchor);
      insert(target, t2, anchor);
      mount_component(toolbar, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const titlebar_changes = {};
      if (dirty & /*runtime*/
      1)
        titlebar_changes.app = /*runtime*/
        ctx2[0].appMutator;
      if (dirty & /*runtime*/
      1)
        titlebar_changes.pid = /*runtime*/
        ctx2[0].pid;
      titlebar.$set(titlebar_changes);
      const header_changes = {};
      if (dirty & /*runtime*/
      1)
        header_changes.runtime = /*runtime*/
        ctx2[0];
      header2.$set(header_changes);
      const directoryviewer_changes = {};
      if (dirty & /*runtime*/
      1)
        directoryviewer_changes.runtime = /*runtime*/
        ctx2[0];
      directoryviewer.$set(directoryviewer_changes);
      const toolbar_changes = {};
      if (dirty & /*runtime*/
      1)
        toolbar_changes.runtime = /*runtime*/
        ctx2[0];
      toolbar.$set(toolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(titlebar.$$.fragment, local);
      transition_in(header2.$$.fragment, local);
      transition_in(directoryviewer.$$.fragment, local);
      transition_in(toolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(titlebar.$$.fragment, local);
      transition_out(header2.$$.fragment, local);
      transition_out(directoryviewer.$$.fragment, local);
      transition_out(toolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(titlebar, detaching);
      destroy_component(header2, detaching);
      destroy_component(directoryviewer, detaching);
      destroy_component(toolbar, detaching);
    }
  };
}
function instance$2z($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime];
}
let App$d = class App18 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2z, create_fragment$2N, safe_not_equal, { runtime: 0 });
  }
};
const LoadSaveDialog = {
  metadata: {
    name: "LoadSaveDialog",
    description: "Used for choosing files to load/save",
    author: "ArcOS Team",
    version: "2.0.0",
    icon: ComponentIcon,
    appGroup: "internal",
    hidden: true
  },
  runtime: Runtime$6,
  content: App$d,
  id: "LoadSaveDialog",
  size: { w: 600, h: 400 },
  minSize: { w: 500, h: 300 },
  maxSize: { w: 1e3, h: 800 },
  pos: { x: 60, y: 60 },
  state: {
    minimized: false,
    maximized: false,
    headless: true,
    fullscreen: false,
    resizable: true
  },
  controls: {
    minimize: false,
    maximize: false,
    close: true
  },
  isOverlay: true,
  loadCondition: () => !SafeMode.get()
};
class LoggerRuntime extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "groups", Store$1(/* @__PURE__ */ new Map([])));
    this.updateGroups();
    LogStore.subscribe(() => this.updateGroups());
  }
  updateGroups() {
    const groupsStore = this.groups.get();
    const groups = collectLogsBySource(true);
    const entries = Object.entries(groups);
    for (const [source, items] of entries) {
      groupsStore.set(source, items);
    }
    this.setWindowTitle(`${LogStore.get().length} items`, true);
    this.groups.set(groupsStore);
  }
}
const FilterLevels = [
  LogLevel.info,
  LogLevel.warn,
  LogLevel.error,
  LogLevel.critical
];
const FilterCaptions = /* @__PURE__ */ new Map([
  [LogLevel.info, "Info"],
  [LogLevel.warn, "Warning"],
  [LogLevel.error, "Error"],
  [LogLevel.critical, "Critical"]
]);
const LogItemIcons = {
  [LogLevel.critical]: BugReportIcon,
  [LogLevel.error]: ErrorIcon,
  [LogLevel.warn]: WarningIcon,
  [LogLevel.info]: InfoIcon
};
function create_fragment$2M(ctx) {
  let tr;
  let td0;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let td1;
  let t1_value = (
    /*item*/
    ctx[0].source + ""
  );
  let t1;
  let td1_title_value;
  let t2;
  let td2;
  let t3;
  let t4;
  let td3;
  let span;
  let t5_value = (
    /*item*/
    ctx[0].msg + ""
  );
  let t5;
  let td3_title_value;
  let tr_class_value;
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      img = element("img");
      t0 = space();
      td1 = element("td");
      t1 = text(t1_value);
      t2 = space();
      td2 = element("td");
      t3 = text(
        /*timestamp*/
        ctx[1]
      );
      t4 = space();
      td3 = element("td");
      span = element("span");
      t5 = text(t5_value);
      if (!src_url_equal(img.src, img_src_value = LogItemIcons[
        /*item*/
        ctx[0].level
      ]))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = LogLevel[
        /*item*/
        ctx[0].level
      ]);
      attr(td0, "class", "icon");
      attr(td1, "class", "source");
      attr(td1, "title", td1_title_value = /*item*/
      ctx[0].source);
      attr(td2, "class", "timestamp");
      attr(td3, "class", "message");
      attr(td3, "title", td3_title_value = /*item*/
      ctx[0].msg);
      attr(tr, "class", tr_class_value = "log-item level-" + /*item*/
      ctx[0].level);
      toggle_class(
        tr,
        "highlight",
        /*now*/
        ctx[2] && /*now*/
        ctx[2] < /*item*/
        ctx[0].timestamp + 300
      );
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, img);
      append(tr, t0);
      append(tr, td1);
      append(td1, t1);
      append(tr, t2);
      append(tr, td2);
      append(td2, t3);
      append(tr, t4);
      append(tr, td3);
      append(td3, span);
      append(span, t5);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*item*/
      1 && !src_url_equal(img.src, img_src_value = LogItemIcons[
        /*item*/
        ctx2[0].level
      ])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*item*/
      1 && img_alt_value !== (img_alt_value = LogLevel[
        /*item*/
        ctx2[0].level
      ])) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*item*/
      1 && t1_value !== (t1_value = /*item*/
      ctx2[0].source + ""))
        set_data(t1, t1_value);
      if (dirty & /*item*/
      1 && td1_title_value !== (td1_title_value = /*item*/
      ctx2[0].source)) {
        attr(td1, "title", td1_title_value);
      }
      if (dirty & /*timestamp*/
      2)
        set_data(
          t3,
          /*timestamp*/
          ctx2[1]
        );
      if (dirty & /*item*/
      1 && t5_value !== (t5_value = /*item*/
      ctx2[0].msg + ""))
        set_data(t5, t5_value);
      if (dirty & /*item*/
      1 && td3_title_value !== (td3_title_value = /*item*/
      ctx2[0].msg)) {
        attr(td3, "title", td3_title_value);
      }
      if (dirty & /*item*/
      1 && tr_class_value !== (tr_class_value = "log-item level-" + /*item*/
      ctx2[0].level)) {
        attr(tr, "class", tr_class_value);
      }
      if (dirty & /*item, now, item*/
      5) {
        toggle_class(
          tr,
          "highlight",
          /*now*/
          ctx2[2] && /*now*/
          ctx2[2] < /*item*/
          ctx2[0].timestamp + 300
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
    }
  };
}
function instance$2y($$self, $$props, $$invalidate) {
  let { item } = $$props;
  let timestamp = "";
  let now = 0;
  onMount(() => {
    $$invalidate(1, timestamp = dayjs(item.timestamp || 0).format("HH:mm:ss.mmm"));
    setInterval(() => $$invalidate(2, now = (/* @__PURE__ */ new Date()).getTime()));
  });
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  return [item, timestamp, now];
}
class LogItem extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2y, create_fragment$2M, safe_not_equal, { item: 0 });
  }
}
function get_each_context$w(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  return child_ctx;
}
function create_if_block$1h(ctx) {
  let logitemsvelte;
  let current;
  logitemsvelte = new LogItem({ props: { item: (
    /*item*/
    ctx[4]
  ) } });
  return {
    c() {
      create_component(logitemsvelte.$$.fragment);
    },
    m(target, anchor) {
      mount_component(logitemsvelte, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const logitemsvelte_changes = {};
      if (dirty & /*items*/
      4)
        logitemsvelte_changes.item = /*item*/
        ctx2[4];
      logitemsvelte.$set(logitemsvelte_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(logitemsvelte.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(logitemsvelte.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(logitemsvelte, detaching);
    }
  };
}
function create_each_block$w(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*item*/
    (ctx[4].level == /*selectedLevel*/
    ctx[1] || /*selectedLevel*/
    ctx[1] == "all") && /*item*/
    (ctx[4].source == /*$currentSource*/
    ctx[3] || /*$currentSource*/
    ctx[3] == "*") && create_if_block$1h(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*item*/
        (ctx2[4].level == /*selectedLevel*/
        ctx2[1] || /*selectedLevel*/
        ctx2[1] == "all") && /*item*/
        (ctx2[4].source == /*$currentSource*/
        ctx2[3] || /*$currentSource*/
        ctx2[3] == "*")
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*items, selectedLevel, $currentSource*/
          14) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1h(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$2L(ctx) {
  let table;
  let thead;
  let t6;
  let tbody;
  let current;
  let each_value = ensure_array_like(
    /*items*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$w(get_each_context$w(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th class="icon"></th> <th class="source">Source</th> <th class="timestamp">Timestamp</th> <th class="message">Message</th></tr>`;
      t6 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(table, "class", "log-list");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      append(table, thead);
      append(table, t6);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*items, selectedLevel, $currentSource*/
      14) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$w(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$w(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(tbody, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(table);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$2x($$self, $$props, $$invalidate) {
  let $currentSource, $$unsubscribe_currentSource = noop$1, $$subscribe_currentSource = () => ($$unsubscribe_currentSource(), $$unsubscribe_currentSource = subscribe(currentSource, ($$value) => $$invalidate(3, $currentSource = $$value)), currentSource);
  $$self.$$.on_destroy.push(() => $$unsubscribe_currentSource());
  let { currentSource } = $$props;
  $$subscribe_currentSource();
  let { selectedLevel } = $$props;
  let items = [];
  LogStore.subscribe((v2) => {
    $$invalidate(2, items = v2.sort((a2, b2) => b2.timestamp - a2.timestamp));
  });
  $$self.$$set = ($$props2) => {
    if ("currentSource" in $$props2)
      $$subscribe_currentSource($$invalidate(0, currentSource = $$props2.currentSource));
    if ("selectedLevel" in $$props2)
      $$invalidate(1, selectedLevel = $$props2.selectedLevel);
  };
  return [currentSource, selectedLevel, items, $currentSource];
}
let List$2 = class List2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2x, create_fragment$2L, safe_not_equal, { currentSource: 0, selectedLevel: 1 });
  }
};
function get_each_context$v(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function create_each_block$v(ctx) {
  let button;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[2](
        /*level*/
        ctx[3]
      )
    );
  }
  return {
    c() {
      button = element("button");
      button.textContent = `${FilterCaptions.get(
        /*level*/
        ctx[3]
      )} `;
      attr(button, "class", "option level-" + LogItemIcons[
        /*level*/
        ctx[3]
      ]);
      toggle_class(
        button,
        "suggested",
        /*selectedLevel*/
        ctx[0] == /*level*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*selectedLevel*/
      1) {
        toggle_class(
          button,
          "suggested",
          /*selectedLevel*/
          ctx[0] == /*level*/
          ctx[3]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2K(ctx) {
  let div;
  let button;
  let t1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(FilterLevels);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$v(get_each_context$v(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      button = element("button");
      button.textContent = "select_all";
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(button, "class", "material-icons-round none");
      toggle_class(
        button,
        "suggested",
        /*selectedLevel*/
        ctx[0] == "all"
      );
      attr(div, "class", "filter-options");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(div, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*selectedLevel*/
      1) {
        toggle_class(
          button,
          "suggested",
          /*selectedLevel*/
          ctx2[0] == "all"
        );
      }
      if (dirty & /*selectedLevel*/
      1) {
        each_value = ensure_array_like(FilterLevels);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$v(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$v(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$2w($$self, $$props, $$invalidate) {
  let { selectedLevel } = $$props;
  const click_handler = () => $$invalidate(0, selectedLevel = "all");
  const click_handler_1 = (level) => $$invalidate(0, selectedLevel = level);
  $$self.$$set = ($$props2) => {
    if ("selectedLevel" in $$props2)
      $$invalidate(0, selectedLevel = $$props2.selectedLevel);
  };
  return [selectedLevel, click_handler, click_handler_1];
}
class Filter2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2w, create_fragment$2K, safe_not_equal, { selectedLevel: 0 });
  }
}
function create_fragment$2J(ctx) {
  let div2;
  let div0;
  let t0_value = (
    /*$currentSource*/
    (ctx[2] == "*" ? "All Log Items" : (
      /*$currentSource*/
      ctx[2]
    )) + ""
  );
  let t0;
  let t1;
  let div1;
  let t2;
  let filter2;
  let updating_selectedLevel;
  let current;
  function filter_selectedLevel_binding(value) {
    ctx[3](value);
  }
  let filter_props = {};
  if (
    /*selectedLevel*/
    ctx[0] !== void 0
  ) {
    filter_props.selectedLevel = /*selectedLevel*/
    ctx[0];
  }
  filter2 = new Filter2({ props: filter_props });
  binding_callbacks.push(() => bind$1(filter2, "selectedLevel", filter_selectedLevel_binding));
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = space();
      create_component(filter2.$$.fragment);
      attr(div0, "class", "current-source");
      attr(div1, "class", "sep");
      attr(div2, "class", "options");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div2, t2);
      mount_component(filter2, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*$currentSource*/
      4) && t0_value !== (t0_value = /*$currentSource*/
      (ctx2[2] == "*" ? "All Log Items" : (
        /*$currentSource*/
        ctx2[2]
      )) + ""))
        set_data(t0, t0_value);
      const filter_changes = {};
      if (!updating_selectedLevel && dirty & /*selectedLevel*/
      1) {
        updating_selectedLevel = true;
        filter_changes.selectedLevel = /*selectedLevel*/
        ctx2[0];
        add_flush_callback(() => updating_selectedLevel = false);
      }
      filter2.$set(filter_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(filter2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filter2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(filter2);
    }
  };
}
function instance$2v($$self, $$props, $$invalidate) {
  let $currentSource, $$unsubscribe_currentSource = noop$1, $$subscribe_currentSource = () => ($$unsubscribe_currentSource(), $$unsubscribe_currentSource = subscribe(currentSource, ($$value) => $$invalidate(2, $currentSource = $$value)), currentSource);
  $$self.$$.on_destroy.push(() => $$unsubscribe_currentSource());
  let { currentSource } = $$props;
  $$subscribe_currentSource();
  let { selectedLevel } = $$props;
  function filter_selectedLevel_binding(value) {
    selectedLevel = value;
    $$invalidate(0, selectedLevel);
  }
  $$self.$$set = ($$props2) => {
    if ("currentSource" in $$props2)
      $$subscribe_currentSource($$invalidate(1, currentSource = $$props2.currentSource));
    if ("selectedLevel" in $$props2)
      $$invalidate(0, selectedLevel = $$props2.selectedLevel);
  };
  return [selectedLevel, currentSource, $currentSource, filter_selectedLevel_binding];
}
let Options$2 = class Options2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2v, create_fragment$2J, safe_not_equal, { currentSource: 1, selectedLevel: 0 });
  }
};
function create_fragment$2I(ctx) {
  let div1;
  let titlebar;
  let t0;
  let options2;
  let updating_selectedLevel;
  let t1;
  let div0;
  let list2;
  let current;
  titlebar = new Titlebar({
    props: {
      pid: (
        /*runtime*/
        ctx[1].pid
      ),
      app: (
        /*runtime*/
        ctx[1].appMutator
      )
    }
  });
  function options_selectedLevel_binding(value) {
    ctx[3](value);
  }
  let options_props = { currentSource: (
    /*currentSource*/
    ctx[0]
  ) };
  if (
    /*selectedLevel*/
    ctx[2] !== void 0
  ) {
    options_props.selectedLevel = /*selectedLevel*/
    ctx[2];
  }
  options2 = new Options$2({ props: options_props });
  binding_callbacks.push(() => bind$1(options2, "selectedLevel", options_selectedLevel_binding));
  list2 = new List$2({
    props: {
      currentSource: (
        /*currentSource*/
        ctx[0]
      ),
      selectedLevel: (
        /*selectedLevel*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      div1 = element("div");
      create_component(titlebar.$$.fragment);
      t0 = space();
      create_component(options2.$$.fragment);
      t1 = space();
      div0 = element("div");
      create_component(list2.$$.fragment);
      attr(div0, "class", "log-list-wrapper");
      attr(div1, "class", "main-content");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(titlebar, div1, null);
      append(div1, t0);
      mount_component(options2, div1, null);
      append(div1, t1);
      append(div1, div0);
      mount_component(list2, div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const titlebar_changes = {};
      if (dirty & /*runtime*/
      2)
        titlebar_changes.pid = /*runtime*/
        ctx2[1].pid;
      if (dirty & /*runtime*/
      2)
        titlebar_changes.app = /*runtime*/
        ctx2[1].appMutator;
      titlebar.$set(titlebar_changes);
      const options_changes = {};
      if (dirty & /*currentSource*/
      1)
        options_changes.currentSource = /*currentSource*/
        ctx2[0];
      if (!updating_selectedLevel && dirty & /*selectedLevel*/
      4) {
        updating_selectedLevel = true;
        options_changes.selectedLevel = /*selectedLevel*/
        ctx2[2];
        add_flush_callback(() => updating_selectedLevel = false);
      }
      options2.$set(options_changes);
      const list_changes = {};
      if (dirty & /*currentSource*/
      1)
        list_changes.currentSource = /*currentSource*/
        ctx2[0];
      if (dirty & /*selectedLevel*/
      4)
        list_changes.selectedLevel = /*selectedLevel*/
        ctx2[2];
      list2.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(titlebar.$$.fragment, local);
      transition_in(options2.$$.fragment, local);
      transition_in(list2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(titlebar.$$.fragment, local);
      transition_out(options2.$$.fragment, local);
      transition_out(list2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(titlebar);
      destroy_component(options2);
      destroy_component(list2);
    }
  };
}
function instance$2u($$self, $$props, $$invalidate) {
  let $currentSource, $$unsubscribe_currentSource = noop$1, $$subscribe_currentSource = () => ($$unsubscribe_currentSource(), $$unsubscribe_currentSource = subscribe(currentSource, ($$value) => $$invalidate(4, $currentSource = $$value)), currentSource);
  $$self.$$.on_destroy.push(() => $$unsubscribe_currentSource());
  let { currentSource } = $$props;
  $$subscribe_currentSource();
  let { runtime } = $$props;
  let selectedLevel = "all";
  onMount(() => {
    runtime.process.handler.dispatch.subscribe(runtime.pid, "change-source", (source2) => {
      set_store_value(currentSource, $currentSource = source2, $currentSource);
    });
    const args = runtime.process.args;
    if (args.length < 2)
      return;
    const [level, source] = runtime.process.args;
    if (!level || typeof source !== "string")
      return;
    $$invalidate(2, selectedLevel = level);
    currentSource.set(source);
  });
  function options_selectedLevel_binding(value) {
    selectedLevel = value;
    $$invalidate(2, selectedLevel);
  }
  $$self.$$set = ($$props2) => {
    if ("currentSource" in $$props2)
      $$subscribe_currentSource($$invalidate(0, currentSource = $$props2.currentSource));
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [currentSource, runtime, selectedLevel, options_selectedLevel_binding];
}
let Content$2 = class Content3 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2u, create_fragment$2I, safe_not_equal, { currentSource: 0, runtime: 1 });
  }
};
function create_fragment$2H(ctx) {
  let button;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(
        /*source*/
        ctx[1]
      );
      if (!src_url_equal(img.src, img_src_value = FolderIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(button, "class", "source-option");
      attr(
        button,
        "title",
        /*source*/
        ctx[1]
      );
      toggle_class(
        button,
        "selected",
        /*$currentSource*/
        ctx[2] == /*source*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, span);
      append(span, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*select*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*source*/
      2)
        set_data(
          t1,
          /*source*/
          ctx2[1]
        );
      if (dirty & /*source*/
      2) {
        attr(
          button,
          "title",
          /*source*/
          ctx2[1]
        );
      }
      if (dirty & /*$currentSource, source*/
      6) {
        toggle_class(
          button,
          "selected",
          /*$currentSource*/
          ctx2[2] == /*source*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2t($$self, $$props, $$invalidate) {
  let $currentSource, $$unsubscribe_currentSource = noop$1, $$subscribe_currentSource = () => ($$unsubscribe_currentSource(), $$unsubscribe_currentSource = subscribe(currentSource, ($$value) => $$invalidate(2, $currentSource = $$value)), currentSource);
  $$self.$$.on_destroy.push(() => $$unsubscribe_currentSource());
  let { currentSource } = $$props;
  $$subscribe_currentSource();
  let { source } = $$props;
  function select() {
    set_store_value(currentSource, $currentSource = source, $currentSource);
  }
  $$self.$$set = ($$props2) => {
    if ("currentSource" in $$props2)
      $$subscribe_currentSource($$invalidate(0, currentSource = $$props2.currentSource));
    if ("source" in $$props2)
      $$invalidate(1, source = $$props2.source);
  };
  return [currentSource, source, $currentSource, select];
}
class Source extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2t, create_fragment$2H, safe_not_equal, { currentSource: 0, source: 1 });
  }
}
function get_each_context$u(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2][0];
  return child_ctx;
}
function create_each_block$u(ctx) {
  let source_1;
  let current;
  source_1 = new Source({
    props: {
      source: (
        /*source*/
        ctx[4]
      ),
      currentSource: (
        /*currentSource*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(source_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(source_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const source_1_changes = {};
      if (dirty & /*store*/
      2)
        source_1_changes.source = /*source*/
        ctx2[4];
      if (dirty & /*currentSource*/
      1)
        source_1_changes.currentSource = /*currentSource*/
        ctx2[0];
      source_1.$set(source_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(source_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(source_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(source_1, detaching);
    }
  };
}
function create_fragment$2G(ctx) {
  let div;
  let button;
  let t2;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like([.../*store*/
  ctx[1]]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$u(get_each_context$u(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      button = element("button");
      button.innerHTML = `<img src="${AppsIcon}" alt=""/> <span>All Logs</span>`;
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(button, "class", "source-option");
      toggle_class(
        button,
        "selected",
        /*$currentSource*/
        ctx[2] == "*"
      );
      attr(div, "class", "sidebar");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(div, t2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$currentSource*/
      4) {
        toggle_class(
          button,
          "selected",
          /*$currentSource*/
          ctx2[2] == "*"
        );
      }
      if (dirty & /*store, currentSource*/
      3) {
        each_value = ensure_array_like([.../*store*/
        ctx2[1]]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$u(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$u(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$2s($$self, $$props, $$invalidate) {
  let $currentSource, $$unsubscribe_currentSource = noop$1, $$subscribe_currentSource = () => ($$unsubscribe_currentSource(), $$unsubscribe_currentSource = subscribe(currentSource, ($$value) => $$invalidate(2, $currentSource = $$value)), currentSource);
  $$self.$$.on_destroy.push(() => $$unsubscribe_currentSource());
  let { currentSource } = $$props;
  $$subscribe_currentSource();
  let { store } = $$props;
  const click_handler = () => set_store_value(currentSource, $currentSource = "*", $currentSource);
  $$self.$$set = ($$props2) => {
    if ("currentSource" in $$props2)
      $$subscribe_currentSource($$invalidate(0, currentSource = $$props2.currentSource));
    if ("store" in $$props2)
      $$invalidate(1, store = $$props2.store);
  };
  return [currentSource, store, $currentSource, click_handler];
}
let SideBar$1 = class SideBar2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2s, create_fragment$2G, safe_not_equal, { currentSource: 0, store: 1 });
  }
};
const main$g = "";
function create_if_block$1g(ctx) {
  let sidebar;
  let t2;
  let content;
  let current;
  sidebar = new SideBar$1({
    props: {
      store: (
        /*$store*/
        ctx[1]
      ),
      currentSource: (
        /*currentSource*/
        ctx[3]
      )
    }
  });
  content = new Content$2({
    props: {
      currentSource: (
        /*currentSource*/
        ctx[3]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(sidebar.$$.fragment);
      t2 = space();
      create_component(content.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sidebar, target, anchor);
      insert(target, t2, anchor);
      mount_component(content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sidebar_changes = {};
      if (dirty & /*$store*/
      2)
        sidebar_changes.store = /*$store*/
        ctx2[1];
      sidebar.$set(sidebar_changes);
      const content_changes = {};
      if (dirty & /*runtime*/
      1)
        content_changes.runtime = /*runtime*/
        ctx2[0];
      content.$set(content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      transition_in(content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      transition_out(content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(sidebar, detaching);
      destroy_component(content, detaching);
    }
  };
}
function create_fragment$2F(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*store*/
    ctx[2] && /*runtime*/
    ctx[0] && create_if_block$1g(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*store*/
        ctx2[2] && /*runtime*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*runtime*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1g(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$2r($$self, $$props, $$invalidate) {
  let $store;
  let { runtime } = $$props;
  const { groups: store } = runtime;
  component_subscribe($$self, store, (value) => $$invalidate(1, $store = value));
  let currentSource = Store$1("*");
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, $store, store, currentSource];
}
let App$c = class App19 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2r, create_fragment$2F, safe_not_equal, { runtime: 0 });
  }
};
const LoggerApp = {
  metadata: {
    name: "Logging",
    description: "View ArcOS Logs",
    author: "The ArcOS Team",
    version: "2.0.0",
    icon: LoggerIcon,
    appGroup: "systemTools"
  },
  runtime: LoggerRuntime,
  content: App$c,
  id: "LoggerApp",
  size: { w: 1e3, h: 600 },
  minSize: { w: 1e3, h: 600 },
  maxSize: { w: 1300, h: 900 },
  pos: { x: 200, y: 60 },
  state: {
    minimized: false,
    maximized: false,
    headless: true,
    fullscreen: false,
    resizable: true
  },
  controls: {
    minimize: true,
    maximize: true,
    close: true
  },
  glass: true,
  elevated: true,
  helpArticle: HelpArticles.logging
};
const main$f = "";
const MarkDownViewerAccelerators = (runtime) => {
  return [
    {
      key: "o",
      alt: true,
      shift: true,
      action() {
        runtime.openFileLocation();
      }
    },
    {
      key: "o",
      alt: true,
      action() {
        runtime.openFile();
      }
    }
  ];
};
function FileMenu$2(runtime) {
  return {
    caption: "File",
    subItems: [
      {
        caption: "Open...",
        icon: "file_open",
        action: () => runtime.openFile()
      },
      SEP_ITEM,
      {
        caption: "Open with...",
        image: AppsIcon,
        async action() {
          const path = runtime.path.get();
          if (!path)
            return;
          const partial = await getPartialFile(path);
          OpenWith(partial, runtime.pid, true);
        },
        disabled: () => runtime.isClient.get()
      },
      {
        caption: "Edit File",
        image: TextEditorIcon,
        async action() {
          const path = runtime.path.get();
          if (!path)
            return;
          const partial = await getPartialFile(path);
          await openFileWithApp("TextEditor", partial);
          runtime.closeApp();
        },
        disabled: () => runtime.isClient.get()
      },
      SEP_ITEM,
      {
        caption: "Open file location",
        icon: "folder_open",
        action: () => {
          runtime.openFileLocation();
        },
        disabled: () => !runtime.path.get() || runtime.isClient.get()
      },
      SEP_ITEM,
      {
        caption: "Exit",
        action: () => {
          runtime.process.handler.kill(runtime.pid, true);
        },
        image: ShutdownIcon
      }
    ]
  };
}
const MarkDownViewerAltMenu = (runtime) => [FileMenu$2(runtime)];
let Runtime$5 = class Runtime18 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "File", Store$1());
    __publicField(this, "buffer", Store$1());
    __publicField(this, "path", Store$1());
    __publicField(this, "wrapper", Store$1());
    __publicField(this, "isClient", Store$1(false));
    this.openedFile.subscribe(async (v2) => {
      if (!v2)
        return;
      await this.readFile(v2);
    });
    if (process.args.length && typeof process.args[0] === "string") {
      this.handleOpenFile(process.args[0]);
    } else {
      this.openFile();
    }
    this.loadAltMenu(...MarkDownViewerAltMenu(this));
    this.process.accelerator.store.push(...MarkDownViewerAccelerators(this));
  }
  async readFile(v2) {
    this.path.set(v2);
    this.buffer.set("");
    this.isClient.set(false);
    if (v2.startsWith("@client/"))
      return await this.readFileQuiet(v2);
    const { setDone, setErrors } = await this.LoadProgress(v2);
    const file = await readFile(v2);
    if (!file) {
      setErrors(1);
      setDone(1);
      return;
    }
    const content = await file.data.text();
    this.buffer.set("");
    await sleep(10);
    this.buffer.set(content);
    this.File.set(file);
    this.setWindowTitle(file.name);
    this.setWindowTitle(`Viewing ${file.name}`);
    setTimeout(() => {
      this.setAnchorRedirects();
      this.replaceIconSources();
    }, 10);
    setDone(1);
  }
  async readFileQuiet(v2) {
    this.isClient.set(true);
    const file = await readFile(v2);
    if (!file)
      return;
    this.buffer.set(await file.data.text());
    this.File.set(file);
    this.setWindowTitle(`Viewing ${file.name}` + (this.isClient.get() ? " (Client file)" : ""));
    this.setWindowIcon(getMimeIcon(file.name));
    setTimeout(() => {
      this.setAnchorRedirects();
      this.replaceIconSources();
    }, 100);
  }
  openFile() {
    spawnOverlay(getAppById("LoadSaveDialog"), this.pid, [
      {
        title: "Select Markdown file to open",
        icon: MarkdownMimeIcon,
        extensions: [".md"],
        startDir: getParentDirectory(this.path.get() || "./")
      }
    ]);
  }
  openFileLocation() {
    const path = this.path.get();
    if (!path || this.isClient.get())
      return;
    const split = path.split("/");
    const filename = split[split.length - 1];
    spawnApp("FileManager", 0, [path.replace(`/${filename}`, ""), path]);
  }
  async LoadProgress(v2 = this.path.get()) {
    return await FileProgress(
      {
        caption: "Reading Document",
        subtitle: pathToFriendlyPath(v2),
        icon: MarkdownMimeIcon,
        max: 1,
        done: 0,
        type: "quantity",
        waiting: false,
        working: true,
        errors: 0
      },
      this.pid,
      false
    );
  }
  setAnchorRedirects() {
    const path = this.path.get();
    const wrapper = this.wrapper.get();
    if (!path || !wrapper) {
      return false;
    }
    const anchors = wrapper.querySelectorAll("a");
    for (const anchor of anchors) {
      anchor.addEventListener("click", (e2) => {
        e2.preventDefault();
        const href = anchor.getAttribute("href");
        if (!href.startsWith("@client"))
          return;
        this.handleOpenFile(href);
      });
    }
  }
  replaceIconSources() {
    const path = this.path.get();
    const wrapper = this.wrapper.get();
    if (!path || !wrapper) {
      return false;
    }
    const images = wrapper.querySelectorAll("img");
    const icons = getAllImages();
    for (const image of images) {
      for (const id in icons) {
        const src = image.getAttribute("src");
        if (src == `#${id}`)
          image.setAttribute("src", icons[id]);
      }
    }
  }
};
function create_fragment$2E(ctx) {
  let div;
  let markdownrenderer;
  let current;
  markdownrenderer = new MarkdownRenderer({ props: { content: (
    /*$buffer*/
    ctx[1]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(markdownrenderer.$$.fragment);
      attr(div, "class", "wrapper");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(markdownrenderer, div, null);
      ctx[4](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      const markdownrenderer_changes = {};
      if (dirty & /*$buffer*/
      2)
        markdownrenderer_changes.content = /*$buffer*/
        ctx2[1];
      markdownrenderer.$set(markdownrenderer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(markdownrenderer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(markdownrenderer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(markdownrenderer);
      ctx[4](null);
    }
  };
}
function instance$2q($$self, $$props, $$invalidate) {
  let $buffer;
  let { runtime } = $$props;
  const { buffer } = runtime;
  component_subscribe($$self, buffer, (value) => $$invalidate(1, $buffer = value));
  let wrapper;
  onMount(() => {
    runtime.wrapper.set(wrapper);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapper = $$value;
      $$invalidate(0, wrapper);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [wrapper, $buffer, buffer, runtime, div_binding];
}
let App$b = class App20 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2q, create_fragment$2E, safe_not_equal, { runtime: 3 });
  }
};
const MarkDownViewer = {
  metadata: {
    name: "Markdown Viewer",
    description: "View Markdown files",
    author: "ArcOS Team",
    version: "2.0.0",
    icon: MarkdownMimeIcon,
    appGroup: "utilities"
  },
  runtime: Runtime$5,
  content: App$b,
  id: "MarkDownViewer",
  size: { w: 700, h: 500 },
  minSize: { w: 480, h: 500 },
  maxSize: { w: 1800, h: 1e3 },
  pos: { x: 60, y: 60 },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: true
  },
  controls: {
    minimize: true,
    maximize: true,
    close: true
  },
  glass: true,
  acceleratorDescriptions: {
    "alt+shift+o": "Open the file in File Manager",
    "alt+o": "Open a file"
  },
  loadCondition: () => !SafeMode.get(),
  helpArticle: HelpArticles.markdownViewer
};
const tray = "";
function create_fragment$2D(ctx) {
  let div0;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1_value = (
    /*$appMutator*/
    ctx[5].metadata.name + ""
  );
  let t1;
  let t2;
  let div1;
  let button0;
  let t3;
  let button0_disabled_value;
  let t4;
  let button1;
  let t5_value = (
    /*$State*/
    ctx[4].paused ? "play_arrow" : "pause"
  );
  let t5;
  let button1_disabled_value;
  let t6;
  let button2;
  let t7;
  let button2_disabled_value;
  let t8;
  let bar;
  let t9;
  let div4;
  let div2;
  let t10;
  let t11;
  let div3;
  let t12;
  let current;
  let mounted;
  let dispose;
  bar = new Bar2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div0 = element("div");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      div1 = element("div");
      button0 = element("button");
      t3 = text("fast_rewind");
      t4 = space();
      button1 = element("button");
      t5 = text(t5_value);
      t6 = space();
      button2 = element("button");
      t7 = text("fast_forward");
      t8 = space();
      create_component(bar.$$.fragment);
      t9 = space();
      div4 = element("div");
      div2 = element("div");
      t10 = text(
        /*current*/
        ctx[1]
      );
      t11 = space();
      div3 = element("div");
      t12 = text(
        /*duration*/
        ctx[2]
      );
      if (!src_url_equal(img.src, img_src_value = /*$appMutator*/
      ctx[5].metadata.icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(div0, "class", "file");
      attr(button0, "class", "material-icons-round reverse");
      button0.disabled = button0_disabled_value = !/*$path*/
      ctx[6] || !/*$Loaded*/
      ctx[3];
      attr(button1, "class", "material-icons-round play suggested");
      button1.disabled = button1_disabled_value = !/*$path*/
      ctx[6] || !/*$Loaded*/
      ctx[3];
      attr(button2, "class", "material-icons-round forward");
      button2.disabled = button2_disabled_value = !/*$path*/
      ctx[6] || !/*$Loaded*/
      ctx[3];
      attr(div1, "class", "controls");
      attr(div2, "class", "current");
      attr(div3, "class", "duration");
      attr(div4, "class", "timestamps");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, img);
      append(div0, t0);
      append(div0, span);
      append(span, t1);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      append(div1, button0);
      append(button0, t3);
      append(div1, t4);
      append(div1, button1);
      append(button1, t5);
      append(div1, t6);
      append(div1, button2);
      append(button2, t7);
      insert(target, t8, anchor);
      mount_component(bar, target, anchor);
      insert(target, t9, anchor);
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, t10);
      append(div4, t11);
      append(div4, div3);
      append(div3, t12);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*rewind*/
            ctx[11]
          ),
          listen(
            button1,
            "click",
            /*toggle*/
            ctx[13]
          ),
          listen(
            button2,
            "click",
            /*forward*/
            ctx[12]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$appMutator*/
      32 && !src_url_equal(img.src, img_src_value = /*$appMutator*/
      ctx2[5].metadata.icon)) {
        attr(img, "src", img_src_value);
      }
      if ((!current || dirty & /*$appMutator*/
      32) && t1_value !== (t1_value = /*$appMutator*/
      ctx2[5].metadata.name + ""))
        set_data(t1, t1_value);
      if (!current || dirty & /*$path, $Loaded*/
      72 && button0_disabled_value !== (button0_disabled_value = !/*$path*/
      ctx2[6] || !/*$Loaded*/
      ctx2[3])) {
        button0.disabled = button0_disabled_value;
      }
      if ((!current || dirty & /*$State*/
      16) && t5_value !== (t5_value = /*$State*/
      ctx2[4].paused ? "play_arrow" : "pause"))
        set_data(t5, t5_value);
      if (!current || dirty & /*$path, $Loaded*/
      72 && button1_disabled_value !== (button1_disabled_value = !/*$path*/
      ctx2[6] || !/*$Loaded*/
      ctx2[3])) {
        button1.disabled = button1_disabled_value;
      }
      if (!current || dirty & /*$path, $Loaded*/
      72 && button2_disabled_value !== (button2_disabled_value = !/*$path*/
      ctx2[6] || !/*$Loaded*/
      ctx2[3])) {
        button2.disabled = button2_disabled_value;
      }
      const bar_changes = {};
      if (dirty & /*runtime*/
      1)
        bar_changes.runtime = /*runtime*/
        ctx2[0];
      bar.$set(bar_changes);
      if (!current || dirty & /*current*/
      2)
        set_data(
          t10,
          /*current*/
          ctx2[1]
        );
      if (!current || dirty & /*duration*/
      4)
        set_data(
          t12,
          /*duration*/
          ctx2[2]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(bar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t2);
        detach(div1);
        detach(t8);
        detach(t9);
        detach(div4);
      }
      destroy_component(bar, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2p($$self, $$props, $$invalidate) {
  let $Loaded;
  let $State;
  let $appMutator;
  let $path;
  let { runtime } = $$props;
  const { State, Loaded, appMutator, path } = runtime;
  component_subscribe($$self, State, (value) => $$invalidate(4, $State = value));
  component_subscribe($$self, Loaded, (value) => $$invalidate(3, $Loaded = value));
  component_subscribe($$self, appMutator, (value) => $$invalidate(5, $appMutator = value));
  component_subscribe($$self, path, (value) => $$invalidate(6, $path = value));
  let current = "--:--";
  let duration = "--:--";
  function rewind() {
    runtime.Seek(-10);
  }
  function forward() {
    runtime.Seek(10);
  }
  function toggle() {
    if ($State.paused)
      runtime.Play();
    else
      runtime.Pause();
  }
  State.subscribe((v2) => {
    $$invalidate(1, current = $Loaded ? runtime.formatTime(v2.current) : "--:--");
    $$invalidate(2, duration = $Loaded ? runtime.formatTime(v2.duration) : "--:--");
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [
    runtime,
    current,
    duration,
    $Loaded,
    $State,
    $appMutator,
    $path,
    State,
    Loaded,
    appMutator,
    path,
    rewind,
    forward,
    toggle
  ];
}
class TrayPopup2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2p, create_fragment$2D, safe_not_equal, { runtime: 0 });
  }
}
const MediaPlayerAccelerators = (runtime) => {
  return [
    {
      key: "o",
      alt: true,
      shift: true,
      action() {
        runtime.openFileLocation();
      }
    },
    {
      key: "o",
      alt: true,
      action() {
        runtime.openFile();
      }
    }
  ];
};
function AudioMenu(runtime) {
  return {
    caption: "Playback",
    subItems: [
      {
        caption: "Play",
        icon: "play_arrow",
        action() {
          runtime.Play();
        }
      },
      {
        caption: "Pause",
        icon: "pause",
        action() {
          runtime.Pause();
        }
      },
      SEP_ITEM,
      {
        caption: "Stop",
        icon: "stop",
        action() {
          runtime.Stop();
        }
      }
    ]
  };
}
function FileMenu$1(runtime) {
  return {
    caption: "File",
    subItems: [
      {
        caption: "Open...",
        icon: "file_open",
        action() {
          runtime.openFile();
        },
        accelerator: "Alt+O"
      },
      {
        caption: "Open file location",
        icon: "folder_open",
        action: () => {
          runtime.openFileLocation();
        },
        disabled: () => !runtime.path.get(),
        accelerator: "Alt+Shift+O"
      },
      SEP_ITEM,
      {
        caption: "Exit",
        action: () => {
          runtime.closeApp();
        },
        image: ShutdownIcon,
        accelerator: "Alt+Q"
      }
    ]
  };
}
function MediaPlayerAltMenu(runtime) {
  return [FileMenu$1(runtime), AudioMenu(runtime)];
}
let Runtime$4 = class Runtime19 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "path", Store$1());
    __publicField(this, "url", Store$1());
    __publicField(this, "player");
    __publicField(this, "State", Store$1({ paused: true, current: 0, duration: 0 }));
    __publicField(this, "isVideo", Store$1(false));
    __publicField(this, "Loaded", Store$1(false));
    this.loadAltMenu(...MediaPlayerAltMenu(this));
    this.process.accelerator.store.push(...MediaPlayerAccelerators(this));
    this.openedFile.subscribe(async (v2) => {
      if (!v2)
        return;
      await this.readFile(v2);
    });
    if (process.args.length && typeof process.args[0] === "string") {
      this.handleOpenFile(process.args[0]);
    }
    this._trayIcon();
  }
  async readFile(v2) {
    this.path.set(v2);
    this.Loaded.set(false);
    const { setDone, setErrors } = await this.LoadProgress(v2);
    const file = await readFile(v2);
    if (!ProcessStack.isPid(this.pid, true))
      return;
    if (!file) {
      setErrors(1);
      setDone(1);
      this.Loaded.set(true);
      return;
    }
    const ext2 = parseExtension(file.path);
    this.isVideo.set(MimeTypeIcons[VideoMimeIcon].includes(ext2));
    this.url.set(URL.createObjectURL(file.data));
    this.setWindowTitle(pathToFriendlyName(v2), false);
    this.setWindowIcon(getMimeIcon(v2));
    this.Reset();
    setDone(1);
    setTimeout(() => {
      this.player.play();
      this.Loaded.set(true);
    });
  }
  setPlayer(player) {
    this.player = player;
    this.player.addEventListener("timeupdate", () => this.updateState());
    this.player.addEventListener("pause", () => this.updateState());
    this.player.addEventListener("play", () => this.updateState());
  }
  Reset() {
    if (!this.player)
      return;
    this.player.pause();
    this.player.src = this.url.get();
    this.player.currentTime = 0;
  }
  Play() {
    if (!this.player)
      return;
    this.player.play();
  }
  Pause() {
    if (!this.player)
      return;
    this.player.pause();
  }
  Seek(mod) {
    if (!this.player)
      return;
    this.player.currentTime += mod;
  }
  Stop() {
    if (!this.player)
      return;
    this.player.pause();
    this.player.currentTime = 0;
  }
  updateState() {
    if (!this.player)
      return {
        paused: true,
        current: 0,
        duration: 0
      };
    const state = {
      paused: this.player.paused,
      current: this.player.currentTime,
      duration: this.player.duration
    };
    this.State.set(state);
  }
  formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
  }
  openFileLocation() {
    const path = this.path.get();
    if (!path)
      return;
    const split = path.split("/");
    const filename = split[split.length - 1];
    spawnApp("FileManager", 0, [path.replace(filename, "") || ".", path]);
  }
  openFile() {
    spawnOverlay(getAppById("LoadSaveDialog"), this.pid, [
      {
        title: "Select an audio or video file to open",
        icon: MediaPlayerIcon,
        startDir: getParentDirectory(this.path.get() || "./"),
        extensions: [...MimeTypeIcons[AudioMimeIcon], ...MimeTypeIcons[VideoMimeIcon]]
      }
    ]);
  }
  async LoadProgress(v2 = this.path.get()) {
    return await FileProgress(
      {
        caption: "Loading this amazing file...",
        subtitle: `Home/${pathToFriendlyPath(v2)}`,
        icon: MediaPlayerIcon,
        max: 1,
        done: 0,
        type: "quantity",
        waiting: false,
        working: true,
        errors: 0
      },
      this.pid,
      false
    );
  }
  _trayIcon() {
    const id = `MediaPlayer#${this.pid}`;
    createTrayIcon({
      identifier: id,
      title: "Messages",
      image: MediaPlayerIcon,
      popup: {
        width: 250,
        height: 150,
        component: TrayPopup2,
        runtime: this,
        className: "media-player-tray-popup"
      }
    });
    ProcessStack.processes.subscribe(() => {
      if (!ProcessStack.isPid(this.pid, true))
        disposeTrayIcon(id);
    });
  }
};
function create_fragment$2C(ctx) {
  let div1;
  let div0;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "inner");
      set_style(div0, "--w", 100 / /*$State*/
      ctx[1].duration * /*$State*/
      ctx[1].current + "%");
      attr(div1, "class", "bar");
      toggle_class(div1, "bounce", !/*$Loaded*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$State*/
      2) {
        set_style(div0, "--w", 100 / /*$State*/
        ctx2[1].duration * /*$State*/
        ctx2[1].current + "%");
      }
      if (dirty & /*$Loaded*/
      1) {
        toggle_class(div1, "bounce", !/*$Loaded*/
        ctx2[0]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
    }
  };
}
function instance$2o($$self, $$props, $$invalidate) {
  let $Loaded;
  let $State;
  let { runtime } = $$props;
  const { State, Loaded } = runtime;
  component_subscribe($$self, State, (value) => $$invalidate(1, $State = value));
  component_subscribe($$self, Loaded, (value) => $$invalidate(0, $Loaded = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(4, runtime = $$props2.runtime);
  };
  return [$Loaded, $State, State, Loaded, runtime];
}
class Bar2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2o, create_fragment$2C, safe_not_equal, { runtime: 4 });
  }
}
function create_fragment$2B(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "fast_forward";
      attr(button, "class", "material-icons-round forward");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*forward*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2n($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  function forward() {
    runtime.Seek(10);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [forward, runtime];
}
class Forward extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2n, create_fragment$2B, safe_not_equal, { runtime: 1 });
  }
}
function create_fragment$2A(ctx) {
  let div;
  let button;
  let t_value = (
    /*$State*/
    ctx[0].paused ? "play_arrow" : "pause"
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      t2 = text(t_value);
      attr(button, "class", "material-icons-round play suggested");
      attr(div, "class", "group playpause");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggle*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$State*/
      1 && t_value !== (t_value = /*$State*/
      ctx2[0].paused ? "play_arrow" : "pause"))
        set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2m($$self, $$props, $$invalidate) {
  let $State;
  let { runtime } = $$props;
  const { State } = runtime;
  component_subscribe($$self, State, (value) => $$invalidate(0, $State = value));
  function toggle() {
    if ($State.paused)
      runtime.Play();
    else
      runtime.Pause();
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [$State, State, toggle, runtime];
}
class PlayPause extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2m, create_fragment$2A, safe_not_equal, { runtime: 3 });
  }
}
function create_fragment$2z(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "fast_rewind";
      attr(button, "class", "material-icons-round reverse");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*rewind*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2l($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  function rewind() {
    runtime.Seek(-10);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [rewind, runtime];
}
class Rewind extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2l, create_fragment$2z, safe_not_equal, { runtime: 1 });
  }
}
function create_fragment$2y(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "stop";
      attr(button, "class", "material-icons-round stop");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*stop*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2k($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  function stop2() {
    runtime.Stop();
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [stop2, runtime];
}
class Stop extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2k, create_fragment$2y, safe_not_equal, { runtime: 1 });
  }
}
function create_fragment$2x(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  return {
    c() {
      div = element("div");
      t0 = text(
        /*current*/
        ctx[0]
      );
      t1 = text(" / ");
      t2 = text(
        /*duration*/
        ctx[1]
      );
      attr(div, "class", "timestamp");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*current*/
      1)
        set_data(
          t0,
          /*current*/
          ctx2[0]
        );
      if (dirty & /*duration*/
      2)
        set_data(
          t2,
          /*duration*/
          ctx2[1]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$2j($$self, $$props, $$invalidate) {
  let $Loaded;
  let { runtime } = $$props;
  const { State, Loaded } = runtime;
  component_subscribe($$self, Loaded, (value) => $$invalidate(4, $Loaded = value));
  let current = "--:--";
  let duration = "--:--";
  State.subscribe((v2) => {
    $$invalidate(0, current = $Loaded ? runtime.formatTime(v2.current) : "--:--");
    $$invalidate(1, duration = $Loaded ? runtime.formatTime(v2.duration) : "--:--");
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [current, duration, Loaded, runtime];
}
class Time extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2j, create_fragment$2x, safe_not_equal, { runtime: 3 });
  }
}
function create_fragment$2w(ctx) {
  let div;
  let rewind;
  let t0;
  let playpause;
  let t1;
  let forward;
  let t2;
  let stop2;
  let t3;
  let time;
  let current;
  rewind = new Rewind({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  playpause = new PlayPause({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  forward = new Forward({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  stop2 = new Stop({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  time = new Time({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(rewind.$$.fragment);
      t0 = space();
      create_component(playpause.$$.fragment);
      t1 = space();
      create_component(forward.$$.fragment);
      t2 = space();
      create_component(stop2.$$.fragment);
      t3 = space();
      create_component(time.$$.fragment);
      attr(div, "class", "controls");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(rewind, div, null);
      append(div, t0);
      mount_component(playpause, div, null);
      append(div, t1);
      mount_component(forward, div, null);
      append(div, t2);
      mount_component(stop2, div, null);
      append(div, t3);
      mount_component(time, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const rewind_changes = {};
      if (dirty & /*runtime*/
      1)
        rewind_changes.runtime = /*runtime*/
        ctx2[0];
      rewind.$set(rewind_changes);
      const playpause_changes = {};
      if (dirty & /*runtime*/
      1)
        playpause_changes.runtime = /*runtime*/
        ctx2[0];
      playpause.$set(playpause_changes);
      const forward_changes = {};
      if (dirty & /*runtime*/
      1)
        forward_changes.runtime = /*runtime*/
        ctx2[0];
      forward.$set(forward_changes);
      const stop_changes = {};
      if (dirty & /*runtime*/
      1)
        stop_changes.runtime = /*runtime*/
        ctx2[0];
      stop2.$set(stop_changes);
      const time_changes = {};
      if (dirty & /*runtime*/
      1)
        time_changes.runtime = /*runtime*/
        ctx2[0];
      time.$set(time_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(rewind.$$.fragment, local);
      transition_in(playpause.$$.fragment, local);
      transition_in(forward.$$.fragment, local);
      transition_in(stop2.$$.fragment, local);
      transition_in(time.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rewind.$$.fragment, local);
      transition_out(playpause.$$.fragment, local);
      transition_out(forward.$$.fragment, local);
      transition_out(stop2.$$.fragment, local);
      transition_out(time.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(rewind);
      destroy_component(playpause);
      destroy_component(forward);
      destroy_component(stop2);
      destroy_component(time);
    }
  };
}
function instance$2i($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime];
}
class Controls2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2i, create_fragment$2w, safe_not_equal, { runtime: 0 });
  }
}
const main$e = "";
function create_else_block$i(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<img src="${MediaPlayerIcon}" alt=""/> <h2>No File Opened!</h2> <p>Select a file to play from the File Menu or by pressing Alt+O.</p>`;
      attr(div, "class", "no-file");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block$1f(ctx) {
  let t0;
  let bar;
  let t1;
  let controls;
  let current;
  let if_block = !/*$isVideo*/
  ctx[2] && create_if_block_1$q();
  bar = new Bar2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  controls = new Controls2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      create_component(bar.$$.fragment);
      t1 = space();
      create_component(controls.$$.fragment);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      mount_component(bar, target, anchor);
      insert(target, t1, anchor);
      mount_component(controls, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*$isVideo*/
      ctx2[2]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_1$q();
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const bar_changes = {};
      if (dirty & /*runtime*/
      1)
        bar_changes.runtime = /*runtime*/
        ctx2[0];
      bar.$set(bar_changes);
      const controls_changes = {};
      if (dirty & /*runtime*/
      1)
        controls_changes.runtime = /*runtime*/
        ctx2[0];
      controls.$set(controls_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(bar.$$.fragment, local);
      transition_in(controls.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bar.$$.fragment, local);
      transition_out(controls.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_component(bar, detaching);
      destroy_component(controls, detaching);
    }
  };
}
function create_if_block_1$q(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<span class="material-icons-round">music_note</span>`;
      attr(div, "class", "audio-visual");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$2v(ctx) {
  let video;
  let t2;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1f, create_else_block$i];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$State*/
      ctx2[3] && /*$path*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      video = element("video");
      video.innerHTML = `<track kind="captions"/>`;
      t2 = space();
      if_block.c();
      if_block_anchor = empty();
      toggle_class(
        video,
        "show",
        /*$isVideo*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, video, anchor);
      ctx[8](video);
      insert(target, t2, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$isVideo*/
      4) {
        toggle_class(
          video,
          "show",
          /*$isVideo*/
          ctx2[2]
        );
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(video);
        detach(t2);
        detach(if_block_anchor);
      }
      ctx[8](null);
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$2h($$self, $$props, $$invalidate) {
  let $isVideo;
  let $State;
  let $path;
  let { runtime } = $$props;
  let audio;
  onMount(() => {
    runtime.setPlayer(audio);
  });
  const { State, path, isVideo } = runtime;
  component_subscribe($$self, State, (value) => $$invalidate(3, $State = value));
  component_subscribe($$self, path, (value) => $$invalidate(4, $path = value));
  component_subscribe($$self, isVideo, (value) => $$invalidate(2, $isVideo = value));
  function video_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      audio = $$value;
      $$invalidate(1, audio);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, audio, $isVideo, $State, $path, State, path, isVideo, video_binding];
}
let App$a = class App21 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2h, create_fragment$2v, safe_not_equal, { runtime: 0 });
  }
};
const MediaPlayer = {
  metadata: {
    name: "Media Player",
    description: "Play audio files",
    author: "Izaak Kuipers",
    version: "3.0.0",
    icon: MediaPlayerIcon
  },
  runtime: Runtime$4,
  content: App$a,
  id: "MediaPlayer",
  size: { w: 442, h: NaN },
  pos: { x: 100, y: 100 },
  minSize: { w: 442, h: 130 },
  maxSize: { w: NaN, h: NaN },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: true
  },
  controls: {
    minimize: true,
    maximize: true,
    close: true
  },
  acceleratorDescriptions: {
    "alt+o": "Open an audio file",
    "alt+shift+o": "Open file location of audio file"
  },
  glass: true,
  loadCondition: () => !SafeMode.get(),
  helpArticle: HelpArticles.mediaPlayer
};
async function getAllMessages(length = 30) {
  const token = UserToken.get();
  const url = getServerUrl(Endpoints.MessagesList, { preview_length: length });
  if (!url || !token)
    return [];
  const response = await axios$1.get(url, makeTokenOptions(token));
  if (response.status !== 200)
    return [];
  return response.data.data;
}
async function getMessage(id) {
  const base64 = toBase64(id);
  if (base64 == id)
    return null;
  const token = UserToken.get();
  const url = getServerUrl(Endpoints.MessagesGet, { id: base64 });
  if (!url || !token)
    return null;
  const response = await axios$1.get(url, makeTokenOptions(token));
  if (response.status !== 200)
    return null;
  return response.data.data;
}
async function getInboxMessages() {
  const messages = await getAllMessages();
  const archive = getMessageArchive() || [];
  const username = UserName.get();
  return messages.filter(
    (m3) => !archive.includes(m3.id) && (username != m3.sender || username == m3.receiver && username == m3.sender)
  );
}
async function getSentMessages() {
  const messages = await getAllMessages();
  let returnValue = [];
  for (let i2 = 0; i2 < messages.length; i2++) {
    if (messages[i2].sender == UserName.get())
      returnValue.push(messages[i2]);
  }
  return returnValue;
}
async function getReceivedMessages(length = 30) {
  const messages = await getAllMessages(length);
  let returnValue = [];
  for (let i2 = 0; i2 < messages.length; i2++) {
    if (messages[i2].receiver == UserName.get() && messages[i2].sender != UserName.get())
      returnValue.push(messages[i2]);
  }
  return returnValue;
}
async function getUnreadMessages(length = 30) {
  const messages = await getReceivedMessages(length);
  let returnValue = [];
  for (let i2 = 0; i2 < messages.length; i2++) {
    if (!messages[i2].read)
      returnValue.push(messages[i2]);
  }
  return returnValue;
}
function getMessageArchive() {
  const udata = UserDataStore.get();
  if (!udata || !udata.appdata.MessagingApp)
    return [];
  return udata.appdata.MessagingApp.archive;
}
async function getArchivedMessages() {
  const archived = getMessageArchive() || [];
  const messages = await getAllMessages();
  return messages.filter((m3) => archived.includes(m3.id));
}
function archiveMessage(id) {
  const udata = UserDataStore.get();
  if (!udata.appdata.MessagingApp)
    udata.appdata.MessagingApp = { archive: [] };
  const archive = udata.appdata.MessagingApp.archive || [];
  if (archive.includes(id))
    return;
  archive.push(id);
  udata.appdata.MessagingApp.archive = archive;
  UserDataStore.set(udata);
  GlobalDispatch.dispatch("message-flush");
}
function unarchiveMessage(id) {
  const udata = UserDataStore.get();
  if (!udata.appdata.MessagingApp)
    udata.appdata.MessagingApp = { archive: [] };
  const archive = udata.appdata.MessagingApp.archive || [];
  if (!archive.includes(id))
    return;
  const index = archive.indexOf(id);
  archive.splice(index, 1);
  udata.appdata.MessagingApp.archive = archive;
  UserDataStore.set(udata);
  GlobalDispatch.dispatch("message-flush");
}
function isArchived(id) {
  const udata = UserDataStore.get();
  if (!udata.appdata.MessagingApp)
    return false;
  const archive = udata.appdata.MessagingApp.archive || [];
  return archive && archive.includes(id);
}
async function deleteMessage(id) {
  const base64 = toBase64(id);
  if (base64 == id)
    return false;
  const url = getServerUrl(Endpoints.MessagesDelete, { id: base64 });
  const token = UserToken.get();
  if (!url || !token)
    return false;
  try {
    const response = await axios$1.get(url, makeTokenOptions(token));
    if (response.status !== 200)
      return false;
    GlobalDispatch.dispatch("message-flush");
    return true;
  } catch {
    return false;
  }
}
const partialFilters = ["#", "](", "![", "!", ">", "|", "(", ")"];
function filterPartialMessageBody(partial) {
  let str = partial;
  for (let i2 = 0; i2 < partialFilters.length; i2++) {
    str = str.split(partialFilters[i2]).join("");
  }
  return str;
}
function parseTitle(body) {
  const data2 = { title: "", body: "" };
  const bodyParts = body.split("\n");
  let title = "";
  if (bodyParts[0].startsWith("### ")) {
    title = bodyParts[0].replace("### ", "");
  }
  data2.title = title;
  data2.body = title ? body.replace(`${bodyParts[0]}
`, "") : body;
  return data2;
}
async function GetSaveFilePath(pid, data2) {
  const app = LoadSaveDialog;
  await spawnOverlay(app, pid, [{ ...data2, isSave: true }]);
  return new Promise((r2) => {
    ProcessStack.dispatch.subscribe(pid, "save-file", (v2) => r2(v2));
    ProcessStack.dispatch.subscribe(pid, "ls-dialog-cancel", () => r2(""));
  });
}
async function sendMessage(receivers, body) {
  const token = UserToken.get();
  if (!ConnectedServer.get() || !token)
    return false;
  for (const receiver of receivers) {
    const base64 = toBase64(receiver);
    if (base64 == receiver)
      return false;
    const url = getServerUrl(Endpoints.MessagesSend, { target: base64 });
    try {
      const response = await axios$1.post(url, body, makeTokenOptions(token));
      if (response.status !== 200)
        return false;
    } catch {
      return false;
    }
  }
  GlobalDispatch.dispatch("message-flush");
  return true;
}
async function replyToMessage(id, receiver, body) {
  const base64 = toBase64(receiver);
  if (base64 == id)
    return false;
  const url = getServerUrl(Endpoints.MessagesReply, { target: base64, id });
  const token = UserToken.get();
  if (!token || !url)
    return false;
  try {
    const response = await axios$1.post(url, body, makeTokenOptions(token));
    if (response.status !== 200)
      return false;
    GlobalDispatch.dispatch("message-flush");
    return true;
  } catch {
    return false;
  }
}
class ComposeRuntime extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "ReplyId", Store$1());
    __publicField(this, "Title", Store$1(""));
    __publicField(this, "Body", Store$1(""));
    __publicField(this, "COMPOSE_LIMIT", 1940);
    __publicField(this, "Previewing", Store$1(false));
    __publicField(this, "Receivers", Store$1([]));
    const args = process.args;
    const replyId = args[0];
    const body = args[1];
    const title = args[2];
    if (replyId)
      this.setReply(replyId.toString());
    if (body && typeof body == "string")
      this.Body.set(body);
    if (title && typeof title == "string")
      this.Title.set(title);
  }
  async setReply(id) {
    const message = await getMessage(id);
    if (!message)
      return false;
    this.ReplyId.set(message.id);
    this.Receivers.set([message.sender]);
  }
  async send() {
    const receivers = this.Receivers.get();
    const body = this.Body.get();
    const title = this.Title.get();
    const replyId = this.ReplyId.get();
    if (!receivers.length || !body || !title)
      return;
    const content = `### ${title}
${body}`;
    const { setDone } = await FileProgress(
      {
        caption: "Sending message...",
        subtitle: `${title}`,
        max: 1,
        done: 0,
        errors: 0,
        working: false,
        waiting: false,
        type: "quantity",
        icon: this.app.metadata.icon
      },
      this.pid
    );
    let sent = false;
    if (replyId)
      sent = await replyToMessage(replyId, receivers[0], content);
    else
      sent = await sendMessage(receivers, content);
    setDone(1);
    if (sent)
      ProcessStack.dispatch.dispatchToPid(this.process.parentPid, "open-latest-sent");
    focusedPid.set(this.process.parentPid);
    this.closeApp();
  }
  discard() {
    const body = this.Body.get();
    if (!body)
      return this.closeApp();
    createErrorDialog(
      {
        title: "Discard message?",
        message: "Are you sure you want to discard this message? The message will be permanently deleted.",
        image: WarningIcon,
        buttons: [
          { action() {
          }, caption: "Cancel" },
          {
            caption: "Discard",
            action: () => {
              focusedPid.set(this.process.parentPid);
              this.closeApp();
            },
            suggested: true
          }
        ],
        sound: "arcos.dialog.warning"
      },
      this.pid,
      true
    );
  }
}
function create_else_block$h(ctx) {
  let markdownrenderer;
  let current;
  markdownrenderer = new MarkdownRenderer({ props: { content: (
    /*$Body*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(markdownrenderer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(markdownrenderer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const markdownrenderer_changes = {};
      if (dirty & /*$Body*/
      4)
        markdownrenderer_changes.content = /*$Body*/
        ctx2[2];
      markdownrenderer.$set(markdownrenderer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(markdownrenderer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(markdownrenderer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(markdownrenderer, detaching);
    }
  };
}
function create_if_block$1e(ctx) {
  let textarea;
  let textarea_placeholder_value;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "class", "composer");
      attr(textarea, "placeholder", textarea_placeholder_value = /*$ReplyId*/
      ctx[1] ? "New Reply..." : "New Message...");
      attr(
        textarea,
        "maxlength",
        /*COMPOSE_LIMIT*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      set_input_value(
        textarea,
        /*$Body*/
        ctx[2]
      );
      if (!mounted) {
        dispose = listen(
          textarea,
          "input",
          /*textarea_input_handler*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$ReplyId*/
      2 && textarea_placeholder_value !== (textarea_placeholder_value = /*$ReplyId*/
      ctx2[1] ? "New Reply..." : "New Message...")) {
        attr(textarea, "placeholder", textarea_placeholder_value);
      }
      if (dirty & /*$Body*/
      4) {
        set_input_value(
          textarea,
          /*$Body*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(textarea);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2u(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$1e, create_else_block$h];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*$Previewing*/
    ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "compose-body");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$2g($$self, $$props, $$invalidate) {
  let $Previewing;
  let $ReplyId;
  let $Body;
  let { runtime } = $$props;
  const { Previewing, Body: Body2, COMPOSE_LIMIT, ReplyId } = runtime;
  component_subscribe($$self, Previewing, (value) => $$invalidate(0, $Previewing = value));
  component_subscribe($$self, Body2, (value) => $$invalidate(2, $Body = value));
  component_subscribe($$self, ReplyId, (value) => $$invalidate(1, $ReplyId = value));
  function textarea_input_handler() {
    $Body = this.value;
    Body2.set($Body);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(7, runtime = $$props2.runtime);
  };
  return [
    $Previewing,
    $ReplyId,
    $Body,
    Previewing,
    Body2,
    COMPOSE_LIMIT,
    ReplyId,
    runtime,
    textarea_input_handler
  ];
}
class ComposeField extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2g, create_fragment$2u, safe_not_equal, { runtime: 7 });
  }
}
function create_fragment$2t(ctx) {
  let div;
  let profilepicture;
  let t0;
  let p2;
  let t1;
  let t2;
  let button;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: {
      src: (
        /*pfp*/
        ctx[1] || ProfilePictures.def
      ),
      height: 20
    }
  });
  return {
    c() {
      div = element("div");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      p2 = element("p");
      t1 = text(
        /*receiver*/
        ctx[0]
      );
      t2 = space();
      button = element("button");
      button.textContent = "close";
      attr(p2, "class", "name");
      attr(button, "class", "material-icons-round remove");
      attr(div, "class", "receiver-pill");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(profilepicture, div, null);
      append(div, t0);
      append(div, p2);
      append(p2, t1);
      append(div, t2);
      append(div, button);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*remove*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      2)
        profilepicture_changes.src = /*pfp*/
        ctx2[1] || ProfilePictures.def;
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*receiver*/
      1)
        set_data(
          t1,
          /*receiver*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(profilepicture);
      mounted = false;
      dispose();
    }
  };
}
function instance$2f($$self, $$props, $$invalidate) {
  let { receiver } = $$props;
  let { receivers } = $$props;
  let { users } = $$props;
  let pfp;
  onMount(async () => {
    $$invalidate(1, pfp = await getUserPfp(receiver, "", users));
  });
  async function remove() {
    if (!receivers.includes(receiver))
      return;
    receivers.splice(receivers.indexOf(receiver), 1);
    const x2 = [...receivers];
    $$invalidate(3, receivers = []);
    await sleep(0);
    $$invalidate(3, receivers = [...x2]);
  }
  $$self.$$set = ($$props2) => {
    if ("receiver" in $$props2)
      $$invalidate(0, receiver = $$props2.receiver);
    if ("receivers" in $$props2)
      $$invalidate(3, receivers = $$props2.receivers);
    if ("users" in $$props2)
      $$invalidate(4, users = $$props2.users);
  };
  return [receiver, pfp, remove, receivers, users];
}
class Recipient extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2f, create_fragment$2t, safe_not_equal, { receiver: 0, receivers: 3, users: 4 });
  }
}
function get_each_context$t(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list2[i2][0];
  child_ctx[11] = list2[i2][1];
  return child_ctx;
}
function get_each_context_1$1(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list2[i2];
  return child_ctx;
}
function create_if_block$1d(ctx) {
  let div1;
  let p2;
  let t0_value = Plural(
    "Recipient",
    /*$Receivers*/
    ctx[2].length
  ) + "";
  let t0;
  let t1;
  let div0;
  let t2;
  let show_if = Object.entries(
    /*users*/
    ctx[0]
  ).length !== /*$Receivers*/
  ctx[2].length && /*$Receivers*/
  ctx[2].length < 11 && !/*$ReplyId*/
  (ctx[3] && /*$Receivers*/
  ctx[2].length > 0);
  let current;
  let if_block0 = (
    /*$Receivers*/
    ctx[2].length && create_if_block_3$2(ctx)
  );
  let if_block1 = show_if && create_if_block_1$p(ctx);
  return {
    c() {
      div1 = element("div");
      p2 = element("p");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      attr(p2, "class", "caption");
      attr(div0, "class", "input");
      attr(div1, "class", "field recipients");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, p2);
      append(p2, t0);
      append(div1, t1);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t2);
      if (if_block1)
        if_block1.m(div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*$Receivers*/
      4) && t0_value !== (t0_value = Plural(
        "Recipient",
        /*$Receivers*/
        ctx2[2].length
      ) + ""))
        set_data(t0, t0_value);
      if (
        /*$Receivers*/
        ctx2[2].length
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$Receivers*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty & /*users, $Receivers, $ReplyId*/
      13)
        show_if = Object.entries(
          /*users*/
          ctx2[0]
        ).length !== /*$Receivers*/
        ctx2[2].length && /*$Receivers*/
        ctx2[2].length < 11 && !/*$ReplyId*/
        (ctx2[3] && /*$Receivers*/
        ctx2[2].length > 0);
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$p(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_3$2(ctx) {
  let div;
  let current;
  let each_value_1 = ensure_array_like(
    /*$Receivers*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "current");
      toggle_class(
        div,
        "replying",
        /*$ReplyId*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$Receivers, users*/
      5) {
        each_value_1 = ensure_array_like(
          /*$Receivers*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*$ReplyId*/
      8) {
        toggle_class(
          div,
          "replying",
          /*$ReplyId*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1$1(ctx) {
  let recipient;
  let updating_receivers;
  let current;
  function recipient_receivers_binding(value) {
    ctx[8](value);
  }
  let recipient_props = {
    receiver: (
      /*receiver*/
      ctx[14]
    ),
    users: (
      /*users*/
      ctx[0]
    )
  };
  if (
    /*$Receivers*/
    ctx[2] !== void 0
  ) {
    recipient_props.receivers = /*$Receivers*/
    ctx[2];
  }
  recipient = new Recipient({ props: recipient_props });
  binding_callbacks.push(() => bind$1(recipient, "receivers", recipient_receivers_binding));
  return {
    c() {
      create_component(recipient.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recipient, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recipient_changes = {};
      if (dirty & /*$Receivers*/
      4)
        recipient_changes.receiver = /*receiver*/
        ctx2[14];
      if (dirty & /*users*/
      1)
        recipient_changes.users = /*users*/
        ctx2[0];
      if (!updating_receivers && dirty & /*$Receivers*/
      4) {
        updating_receivers = true;
        recipient_changes.receivers = /*$Receivers*/
        ctx2[2];
        add_flush_callback(() => updating_receivers = false);
      }
      recipient.$set(recipient_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recipient.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recipient.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recipient, detaching);
    }
  };
}
function create_if_block_1$p(ctx) {
  let select;
  let option;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(Object.entries(
    /*users*/
    ctx[0]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$t(get_each_context$t(ctx, each_value, i2));
  }
  return {
    c() {
      select = element("select");
      option = element("option");
      option.textContent = "Add...";
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      option.__value = "none";
      set_input_value(option, option.__value);
      option.disabled = true;
      option.selected = true;
      attr(select, "class", "adder");
      if (
        /*input*/
        ctx[1] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[9].call(select)
        ));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      append(select, option);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(
        select,
        /*input*/
        ctx[1],
        true
      );
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[9]
          ),
          listen(
            select,
            "change",
            /*add*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, users, $Receivers*/
      5) {
        each_value = ensure_array_like(Object.entries(
          /*users*/
          ctx2[0]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$t(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$t(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*input, Object, users*/
      3) {
        select_option(
          select,
          /*input*/
          ctx2[1]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$8(ctx) {
  let option;
  let t_value = (
    /*name*/
    ctx[10] + ""
  );
  let t2;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t2 = text(t_value);
      option.__value = option_value_value = /*name*/
      ctx[10];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*users*/
      1 && t_value !== (t_value = /*name*/
      ctx2[10] + ""))
        set_data(t2, t_value);
      if (dirty & /*users*/
      1 && option_value_value !== (option_value_value = /*name*/
      ctx2[10])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block$t(ctx) {
  let show_if = !/*$Receivers*/
  ctx[2].includes(
    /*name*/
    ctx[10]
  );
  let if_block_anchor;
  let if_block = show_if && create_if_block_2$8(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$Receivers, users*/
      5)
        show_if = !/*$Receivers*/
        ctx2[2].includes(
          /*name*/
          ctx2[10]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$8(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$2s(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*users*/
    ctx[0] && create_if_block$1d(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*users*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*users*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1d(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$2e($$self, $$props, $$invalidate) {
  let $Receivers;
  let $ReplyId;
  let { runtime } = $$props;
  const { Receivers, ReplyId } = runtime;
  component_subscribe($$self, Receivers, (value) => $$invalidate(2, $Receivers = value));
  component_subscribe($$self, ReplyId, (value) => $$invalidate(3, $ReplyId = value));
  let users;
  onMount(async () => {
    $$invalidate(0, users = await getUsers());
  });
  async function add() {
    if (input == "none")
      return;
    $Receivers.push(input);
    const x2 = [...$Receivers];
    set_store_value(Receivers, $Receivers = [], $Receivers);
    await sleep(0);
    set_store_value(Receivers, $Receivers = [...x2], $Receivers);
    $$invalidate(1, input = "none");
  }
  let input;
  function recipient_receivers_binding(value) {
    $Receivers = value;
    Receivers.set($Receivers);
  }
  function select_change_handler() {
    input = select_value(this);
    $$invalidate(1, input);
    $$invalidate(0, users);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(7, runtime = $$props2.runtime);
  };
  return [
    users,
    input,
    $Receivers,
    $ReplyId,
    Receivers,
    ReplyId,
    add,
    runtime,
    recipient_receivers_binding,
    select_change_handler
  ];
}
class RecipientsField extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2e, create_fragment$2s, safe_not_equal, { runtime: 7 });
  }
}
function create_fragment$2r(ctx) {
  let div1;
  let p2;
  let t1;
  let div0;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      p2 = element("p");
      p2.textContent = "Title";
      t1 = space();
      div0 = element("div");
      input = element("input");
      attr(p2, "class", "caption");
      attr(input, "type", "text");
      attr(input, "placeholder", "Something very important...");
      attr(input, "maxlength", "50");
      attr(div0, "class", "input");
      attr(div1, "class", "field");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, p2);
      append(div1, t1);
      append(div1, div0);
      append(div0, input);
      set_input_value(
        input,
        /*$Title*/
        ctx[0]
      );
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$Title*/
      1 && input.value !== /*$Title*/
      ctx2[0]) {
        set_input_value(
          input,
          /*$Title*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2d($$self, $$props, $$invalidate) {
  let $Title;
  let { runtime } = $$props;
  const { Title } = runtime;
  component_subscribe($$self, Title, (value) => $$invalidate(0, $Title = value));
  function input_input_handler() {
    $Title = this.value;
    Title.set($Title);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [$Title, Title, runtime, input_input_handler];
}
class TitleField extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2d, create_fragment$2r, safe_not_equal, { runtime: 2 });
  }
}
function create_if_block$1c(ctx) {
  let span;
  let t0;
  let t1_value = (
    /*$Receivers*/
    ctx[2][0] + ""
  );
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text("- Replying to ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$Receivers*/
      4 && t1_value !== (t1_value = /*$Receivers*/
      ctx2[2][0] + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$2q(ctx) {
  let div3;
  let p2;
  let span;
  let t0_value = (
    /*$Body*/
    ctx[0].length + ""
  );
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let div0;
  let button0;
  let t7;
  let button1;
  let t9;
  let div1;
  let t10;
  let div2;
  let button2;
  let t12;
  let button3;
  let t13_value = (
    /*$ReplyId*/
    ctx[1] ? "Reply" : "Send"
  );
  let t13;
  let button3_disabled_value;
  let mounted;
  let dispose;
  let if_block = (
    /*$ReplyId*/
    ctx[1] && create_if_block$1c(ctx)
  );
  return {
    c() {
      div3 = element("div");
      p2 = element("p");
      span = element("span");
      t0 = text(t0_value);
      t1 = text(" / ");
      t2 = text(
        /*COMPOSE_LIMIT*/
        ctx[8]
      );
      t3 = text(" characters");
      t4 = space();
      if (if_block)
        if_block.c();
      t5 = space();
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "visibility";
      t7 = space();
      button1 = element("button");
      button1.textContent = "edit";
      t9 = space();
      div1 = element("div");
      t10 = space();
      div2 = element("div");
      button2 = element("button");
      button2.textContent = "Discard";
      t12 = space();
      button3 = element("button");
      t13 = text(t13_value);
      attr(p2, "class", "quota");
      attr(button0, "class", "material-icons-round");
      toggle_class(
        button0,
        "suggested",
        /*$Previewing*/
        ctx[3]
      );
      attr(button1, "class", "material-icons-round");
      toggle_class(button1, "suggested", !/*$Previewing*/
      ctx[3]);
      attr(div0, "class", "view-modes");
      attr(div1, "class", "sep");
      attr(button3, "class", "suggested");
      button3.disabled = button3_disabled_value = !/*$Body*/
      ctx[0] || !/*$Receivers*/
      ctx[2].length || !/*$Title*/
      ctx[4];
      attr(div2, "class", "actions");
      attr(div3, "class", "toolbar");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, p2);
      append(p2, span);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
      append(p2, t4);
      if (if_block)
        if_block.m(p2, null);
      append(div3, t5);
      append(div3, div0);
      append(div0, button0);
      append(div0, t7);
      append(div0, button1);
      append(div3, t9);
      append(div3, div1);
      append(div3, t10);
      append(div3, div2);
      append(div2, button2);
      append(div2, t12);
      append(div2, button3);
      append(button3, t13);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[14]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[15]
          ),
          listen(
            button2,
            "click",
            /*discard*/
            ctx[11]
          ),
          listen(
            button3,
            "click",
            /*send*/
            ctx[12]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$Body*/
      1 && t0_value !== (t0_value = /*$Body*/
      ctx2[0].length + ""))
        set_data(t0, t0_value);
      if (
        /*$ReplyId*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1c(ctx2);
          if_block.c();
          if_block.m(p2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*$Previewing*/
      8) {
        toggle_class(
          button0,
          "suggested",
          /*$Previewing*/
          ctx2[3]
        );
      }
      if (dirty & /*$Previewing*/
      8) {
        toggle_class(button1, "suggested", !/*$Previewing*/
        ctx2[3]);
      }
      if (dirty & /*$ReplyId*/
      2 && t13_value !== (t13_value = /*$ReplyId*/
      ctx2[1] ? "Reply" : "Send"))
        set_data(t13, t13_value);
      if (dirty & /*$Body, $Receivers, $Title*/
      21 && button3_disabled_value !== (button3_disabled_value = !/*$Body*/
      ctx2[0] || !/*$Receivers*/
      ctx2[2].length || !/*$Title*/
      ctx2[4])) {
        button3.disabled = button3_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2c($$self, $$props, $$invalidate) {
  let $Body;
  let $ReplyId;
  let $Receivers;
  let $Previewing;
  let $Title;
  let { runtime } = $$props;
  const { Title, Body: Body2, Receivers, COMPOSE_LIMIT, Previewing, ReplyId } = runtime;
  component_subscribe($$self, Title, (value) => $$invalidate(4, $Title = value));
  component_subscribe($$self, Body2, (value) => $$invalidate(0, $Body = value));
  component_subscribe($$self, Receivers, (value) => $$invalidate(2, $Receivers = value));
  component_subscribe($$self, Previewing, (value) => $$invalidate(3, $Previewing = value));
  component_subscribe($$self, ReplyId, (value) => $$invalidate(1, $ReplyId = value));
  function discard() {
    runtime.discard();
  }
  function send() {
    runtime.send();
  }
  const click_handler = () => set_store_value(Previewing, $Previewing = true, $Previewing);
  const click_handler_1 = () => set_store_value(Previewing, $Previewing = false, $Previewing);
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(13, runtime = $$props2.runtime);
  };
  return [
    $Body,
    $ReplyId,
    $Receivers,
    $Previewing,
    $Title,
    Title,
    Body2,
    Receivers,
    COMPOSE_LIMIT,
    Previewing,
    ReplyId,
    discard,
    send,
    runtime,
    click_handler,
    click_handler_1
  ];
}
let Toolbar$3 = class Toolbar5 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2c, create_fragment$2q, safe_not_equal, { runtime: 13 });
  }
};
const main$d = "";
function create_fragment$2p(ctx) {
  let titlefield;
  let t0;
  let recipientsfield;
  let t1;
  let composefield;
  let t2;
  let toolbar;
  let current;
  titlefield = new TitleField({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  recipientsfield = new RecipientsField({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  composefield = new ComposeField({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  toolbar = new Toolbar$3({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(titlefield.$$.fragment);
      t0 = space();
      create_component(recipientsfield.$$.fragment);
      t1 = space();
      create_component(composefield.$$.fragment);
      t2 = space();
      create_component(toolbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(titlefield, target, anchor);
      insert(target, t0, anchor);
      mount_component(recipientsfield, target, anchor);
      insert(target, t1, anchor);
      mount_component(composefield, target, anchor);
      insert(target, t2, anchor);
      mount_component(toolbar, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const titlefield_changes = {};
      if (dirty & /*runtime*/
      1)
        titlefield_changes.runtime = /*runtime*/
        ctx2[0];
      titlefield.$set(titlefield_changes);
      const recipientsfield_changes = {};
      if (dirty & /*runtime*/
      1)
        recipientsfield_changes.runtime = /*runtime*/
        ctx2[0];
      recipientsfield.$set(recipientsfield_changes);
      const composefield_changes = {};
      if (dirty & /*runtime*/
      1)
        composefield_changes.runtime = /*runtime*/
        ctx2[0];
      composefield.$set(composefield_changes);
      const toolbar_changes = {};
      if (dirty & /*runtime*/
      1)
        toolbar_changes.runtime = /*runtime*/
        ctx2[0];
      toolbar.$set(toolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(titlefield.$$.fragment, local);
      transition_in(recipientsfield.$$.fragment, local);
      transition_in(composefield.$$.fragment, local);
      transition_in(toolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(titlefield.$$.fragment, local);
      transition_out(recipientsfield.$$.fragment, local);
      transition_out(composefield.$$.fragment, local);
      transition_out(toolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(titlefield, detaching);
      destroy_component(recipientsfield, detaching);
      destroy_component(composefield, detaching);
      destroy_component(toolbar, detaching);
    }
  };
}
function instance$2b($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime];
}
let Compose$1 = class Compose extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2b, create_fragment$2p, safe_not_equal, { runtime: 0 });
  }
};
const ComposeApp = {
  metadata: {
    name: "Compose Message",
    description: "Compose a new message",
    icon: MessagingIcon,
    author: "The ArcOS Team",
    version: "1.0.0"
  },
  runtime: ComposeRuntime,
  content: Compose$1,
  id: "MessageComposer",
  size: { w: 650, h: 500 },
  minSize: { w: 650, h: 500 },
  maxSize: { w: 650, h: 500 },
  pos: { x: 0, y: 0 },
  state: {
    maximized: false,
    minimized: false,
    fullscreen: false,
    resizable: false,
    headless: true
  },
  controls: {
    minimize: false,
    maximize: false,
    close: false
  },
  isOverlay: true
};
async function getPartialTree(id) {
  const base64 = toBase64(id);
  if (id == base64)
    return null;
  const url = getServerUrl(Endpoints.MessagesThread, { id: base64 });
  const token = UserToken.get();
  if (!url || !token)
    return null;
  try {
    const response = await axios$1.get(url, makeTokenOptions(token));
    if (response.status !== 200)
      return null;
    return response.data.data;
  } catch {
    return null;
  }
}
class ThreadViewRuntime extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "MessageId", Store$1());
    __publicField(this, "Tree", Store$1(null));
    __publicField(this, "Loading", Store$1(false));
    const args = process.args;
    const replyId = args[0];
    if (replyId)
      this.setMessage(replyId.toString());
    else
      this.closeApp();
  }
  async setMessage(id) {
    this.Loading.set(true);
    const tree = await getPartialTree(id);
    if (!tree)
      return false;
    this.Tree.set(tree);
    this.MessageId.set(id);
    this.Loading.set(false);
  }
  viewMessage(id) {
    ProcessStack.dispatch.dispatchToPid(this.process.parentPid, "open-message", id);
    this.closeApp();
  }
}
function get_each_context$s(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function create_if_block$1b(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*items*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$s(get_each_context$s(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*items, users, runtime*/
      7) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$s(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$s(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$s(ctx) {
  let item_1;
  let current;
  item_1 = new Item$1({
    props: {
      item: (
        /*item*/
        ctx[3]
      ),
      users: (
        /*users*/
        ctx[1]
      ),
      runtime: (
        /*runtime*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(item_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(item_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const item_1_changes = {};
      if (dirty & /*items*/
      1)
        item_1_changes.item = /*item*/
        ctx2[3];
      if (dirty & /*users*/
      2)
        item_1_changes.users = /*users*/
        ctx2[1];
      if (dirty & /*runtime*/
      4)
        item_1_changes.runtime = /*runtime*/
        ctx2[2];
      item_1.$set(item_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(item_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(item_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(item_1, detaching);
    }
  };
}
function create_fragment$2o(ctx) {
  let div;
  let current;
  let if_block = (
    /*items*/
    ctx[0] && create_if_block$1b(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "branch");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*items*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*items*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1b(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$2a($$self, $$props, $$invalidate) {
  let { items = [] } = $$props;
  let { users } = $$props;
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("users" in $$props2)
      $$invalidate(1, users = $$props2.users);
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [items, users, runtime];
}
class Branch extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2a, create_fragment$2o, safe_not_equal, { items: 0, users: 1, runtime: 2 });
  }
}
function create_if_block$1a(ctx) {
  let branch;
  let current;
  branch = new Branch({
    props: {
      items: (
        /*item*/
        ctx[0].replies
      ),
      users: (
        /*users*/
        ctx[1]
      ),
      runtime: (
        /*runtime*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(branch.$$.fragment);
    },
    m(target, anchor) {
      mount_component(branch, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const branch_changes = {};
      if (dirty & /*item*/
      1)
        branch_changes.items = /*item*/
        ctx2[0].replies;
      if (dirty & /*users*/
      2)
        branch_changes.users = /*users*/
        ctx2[1];
      if (dirty & /*runtime*/
      4)
        branch_changes.runtime = /*runtime*/
        ctx2[2];
      branch.$set(branch_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(branch.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(branch.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(branch, detaching);
    }
  };
}
function create_fragment$2n(ctx) {
  let button;
  let profilepicture;
  let t0;
  let div;
  let p0;
  let t1_value = (
    /*item*/
    ctx[0].sender + ""
  );
  let t1;
  let t2;
  let p1;
  let t3_value = filterPartialMessageBody(
    /*item*/
    ctx[0].partialBody
  ) + "";
  let t3;
  let t4_value = (
    /*item*/
    ctx[0].partialBody.length > 29 ? "..." : ""
  );
  let t4;
  let t5;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*pfp*/
      ctx[3]
    ), height: 32 }
  });
  let if_block = (
    /*item*/
    ctx[0].replies && create_if_block$1a(ctx)
  );
  return {
    c() {
      button = element("button");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      div = element("div");
      p0 = element("p");
      t1 = text(t1_value);
      t2 = space();
      p1 = element("p");
      t3 = text(t3_value);
      t4 = text(t4_value);
      t5 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(p0, "class", "name");
      attr(p1, "class", "partial");
      attr(div, "class", "context");
      attr(button, "class", "item");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(profilepicture, button, null);
      append(button, t0);
      append(button, div);
      append(div, p0);
      append(p0, t1);
      append(div, t2);
      append(div, p1);
      append(p1, t3);
      append(p1, t4);
      insert(target, t5, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*openThis*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      8)
        profilepicture_changes.src = /*pfp*/
        ctx2[3];
      profilepicture.$set(profilepicture_changes);
      if ((!current || dirty & /*item*/
      1) && t1_value !== (t1_value = /*item*/
      ctx2[0].sender + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & /*item*/
      1) && t3_value !== (t3_value = filterPartialMessageBody(
        /*item*/
        ctx2[0].partialBody
      ) + ""))
        set_data(t3, t3_value);
      if ((!current || dirty & /*item*/
      1) && t4_value !== (t4_value = /*item*/
      ctx2[0].partialBody.length > 29 ? "..." : ""))
        set_data(t4, t4_value);
      if (
        /*item*/
        ctx2[0].replies
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1a(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
        detach(t5);
        detach(if_block_anchor);
      }
      destroy_component(profilepicture);
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$29($$self, $$props, $$invalidate) {
  let { item } = $$props;
  let { users } = $$props;
  let { runtime } = $$props;
  let pfp = "";
  onMount(async () => {
    $$invalidate(3, pfp = await getUserPfp(item.sender, "", users));
  });
  function openThis() {
    runtime.viewMessage(item.id);
  }
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("users" in $$props2)
      $$invalidate(1, users = $$props2.users);
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [item, users, runtime, pfp, openThis];
}
let Item$1 = class Item extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$29, create_fragment$2n, safe_not_equal, { item: 0, users: 1, runtime: 2 });
  }
};
const main$c = "";
function create_if_block_1$o(ctx) {
  let div0;
  let item;
  let t0;
  let div1;
  let p2;
  let t1;
  let t2_value = (
    /*$Tree*/
    ctx[3].id + ""
  );
  let t2;
  let t3;
  let button;
  let current;
  let mounted;
  let dispose;
  item = new Item$1({
    props: {
      item: (
        /*$Tree*/
        ctx[3]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      users: (
        /*users*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      div0 = element("div");
      create_component(item.$$.fragment);
      t0 = space();
      div1 = element("div");
      p2 = element("p");
      t1 = text("Thread of #");
      t2 = text(t2_value);
      t3 = space();
      button = element("button");
      button.textContent = "Close";
      attr(div0, "class", "top");
      attr(p2, "class", "of");
      attr(button, "class", "suggested");
      attr(div1, "class", "bottom");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      mount_component(item, div0, null);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      append(div1, p2);
      append(p2, t1);
      append(p2, t2);
      append(div1, t3);
      append(div1, button);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*close*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const item_changes = {};
      if (dirty & /*$Tree*/
      8)
        item_changes.item = /*$Tree*/
        ctx2[3];
      if (dirty & /*runtime*/
      1)
        item_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*users*/
      2)
        item_changes.users = /*users*/
        ctx2[1];
      item.$set(item_changes);
      if ((!current || dirty & /*$Tree*/
      8) && t2_value !== (t2_value = /*$Tree*/
      ctx2[3].id + ""))
        set_data(t2, t2_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(item.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(item.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div1);
      }
      destroy_component(item);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$19(ctx) {
  let spinner;
  let current;
  spinner = new Spinner({ props: { height: 32 } });
  return {
    c() {
      create_component(spinner.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spinner, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spinner, detaching);
    }
  };
}
function create_fragment$2m(ctx) {
  let t2;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*$MessageId*/
    ctx[2] && /*$Tree*/
    ctx[3] && /*users*/
    ctx[1] && create_if_block_1$o(ctx)
  );
  let if_block1 = (
    /*$Loading*/
    ctx[4] && create_if_block$19()
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$MessageId*/
        ctx2[2] && /*$Tree*/
        ctx2[3] && /*users*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$MessageId, $Tree, users*/
          14) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$o(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$Loading*/
        ctx2[4]
      ) {
        if (if_block1) {
          if (dirty & /*$Loading*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$19();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function instance$28($$self, $$props, $$invalidate) {
  let $MessageId;
  let $Tree;
  let $Loading;
  let { runtime } = $$props;
  const { Tree: Tree2, MessageId, Loading: Loading4 } = runtime;
  component_subscribe($$self, Tree2, (value) => $$invalidate(3, $Tree = value));
  component_subscribe($$self, MessageId, (value) => $$invalidate(2, $MessageId = value));
  component_subscribe($$self, Loading4, (value) => $$invalidate(4, $Loading = value));
  let users;
  onMount(async () => {
    $$invalidate(1, users = await getUsers());
  });
  function close() {
    runtime.closeApp();
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, users, $MessageId, $Tree, $Loading, Tree2, MessageId, Loading4, close];
}
class ThreadView extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$28, create_fragment$2m, safe_not_equal, { runtime: 0 });
  }
}
const ThreadViewApp = {
  metadata: {
    name: "MsgThreadView",
    description: "View the thread of a message",
    icon: MessagingIcon,
    author: "The ArcOS Team",
    version: "2.0.0"
  },
  runtime: ThreadViewRuntime,
  content: ThreadView,
  id: "ThreadView",
  size: { w: 500, h: 500 },
  minSize: { w: 500, h: 500 },
  maxSize: { w: 500, h: 500 },
  pos: { x: 0, y: 0 },
  state: {
    maximized: false,
    minimized: false,
    fullscreen: false,
    resizable: false,
    headless: true
  },
  controls: {
    minimize: false,
    maximize: false,
    close: false
  },
  isOverlay: true
};
const MessagingPages = {
  unread: {
    name: "Unread",
    icon: "mark_email_unread",
    supplier: getUnreadMessages
  },
  inbox: {
    name: "Inbox",
    icon: "inbox",
    supplier: getInboxMessages
  },
  sent: {
    name: "Sent",
    icon: "send",
    supplier: getSentMessages
  },
  archive: {
    name: "Archived",
    icon: "inventory_2",
    supplier: getArchivedMessages
  }
};
let Runtime$3 = class Runtime20 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "Store", Store$1([]));
    __publicField(this, "Message", Store$1());
    __publicField(this, "Page", Store$1("unread"));
    __publicField(this, "Loading", Store$1(false));
    __publicField(this, "SearchFilter", Store$1(""));
    __publicField(this, "SearchResults", Store$1([]));
    __publicField(this, "LockRefresh", Store$1(false));
    __publicField(this, "ViewingMessageSource", Store$1(false));
    __publicField(this, "ViewingThread", Store$1(false));
    __publicField(this, "HasOverlay", Store$1(false));
    this._init();
  }
  async _init() {
    this.Update();
    this.assignDispatchers();
    const args = this.process.args;
    if (args[0] && typeof args[0] === "string") {
      this.openMessage(args[0]);
      this.openMessagePage();
    }
    this._trayIcon();
  }
  async Update(reset = true, flush2 = true) {
    const page = MessagingPages[this.Page.get()];
    if (this.LockRefresh.get() || !page)
      return;
    this.setWindowTitle(page.name, true);
    this.Store.set([]);
    this.Loading.set(true);
    const supplier = (await page.supplier() || []).sort(
      (a2, b2) => new Date(b2.timestamp).getTime() - new Date(a2.timestamp).getTime()
    );
    const currentMessage = this.Message.get();
    if (reset)
      this.Message.set(null);
    this.Store.set(supplier);
    if (flush2) {
      if (currentMessage)
        await this.openMessage(currentMessage.id, true);
      else if (supplier[0])
        await this.openMessage(supplier[0].id);
    }
    this.Loading.set(false);
  }
  async navigate(id, reset = true, flush2 = true) {
    if (this.Loading.get())
      return false;
    const current = this.Page.get();
    const page = MessagingPages[id];
    if (!page || current == id)
      return false;
    this.Page.set(id);
    await this.Update(reset, flush2);
    return true;
  }
  async openMessage(id, force = false) {
    const current = this.Message.get();
    if (current && current.id == id && !force)
      return false;
    this.Message.set(null);
    const message = await getMessage(id);
    if (!message)
      return false;
    this.Message.set(message);
  }
  openMessagePage(flush2 = true) {
    const message = this.Message.get();
    const username = UserName.get();
    if (!message)
      return;
    if (message.receiver == username)
      this.navigate(message.read ? "inbox" : "unread", false, flush2);
    else if (message.sender == username)
      this.navigate("sent", false, flush2);
  }
  Search(query) {
    if (!query) {
      this.SearchResults.set([]);
      this.SearchFilter.set("");
      return;
    }
    const store = this.Store.get();
    const options2 = {
      keys: ["sender", "partialBody"]
    };
    if (!store)
      return;
    const fuse = new Fuse(store, options2);
    const search2 = fuse.search(query);
    this.SearchResults.set(search2.map((a2) => a2.item.id));
    this.SearchFilter.set(query);
  }
  async ArchiveMessage(id) {
    const message = this.Message.get();
    this.LockRefresh.set(true);
    id || (id = message ? message.id : id);
    const archived = isArchived(id);
    if (archived) {
      unarchiveMessage(id);
    } else {
      archiveMessage(id);
    }
    const unsub = this.Loading.subscribe(async (v2) => {
      if (v2)
        return;
      this.LockRefresh.set(false);
      await this.navigate(message.id == id && !archived ? "archive" : "inbox", false);
      unsub();
    });
  }
  async SaveMessage() {
    const message = this.Message.get();
    if (!message)
      return false;
    const filename = `${message.id} from ${message.sender}.md`;
    const path = await GetSaveFilePath(this.pid, {
      title: "Where do you want to save the message?",
      icon: SaveIcon,
      saveName: filename,
      isSave: true
    });
    const { setDone, mutErr } = await FileProgress(
      {
        max: 1,
        done: 0,
        caption: `Saving message to ${pathToFriendlyName(path)}...`,
        type: "quantity",
        icon: SaveIcon,
        subtitle: `To ${pathToFriendlyPath(path)}`,
        waiting: false,
        working: false,
        errors: 0
      },
      this.pid,
      false
    );
    const written = await writeFile(path, textToBlob(message.body), true);
    if (!written)
      mutErr(1);
    else
      setDone(1);
  }
  async DeleteMessage() {
    const message = this.Message.get();
    const currentUser = UserName.get();
    if (!message)
      return;
    if (message.sender == currentUser && message.receiver !== currentUser) {
      createErrorDialog(
        {
          title: "Can't delete message",
          message: `You have to be the recipient of a message in order to delete it. Please ask <b>${message.receiver}</b> to delete it for you.`,
          buttons: [{ caption: "Okay", action() {
          }, suggested: true }],
          image: ErrorIcon,
          sound: "arcos.dialog.error"
        },
        this.pid,
        true
      );
      return;
    }
    createErrorDialog(
      {
        title: "Delete message?",
        message: `Are you sure you want to <b>permanently</b> delete message <code>#${message.id}</code> from ${message.sender}? This cannot be undone.`,
        buttons: [
          { caption: "Cancel", action() {
          } },
          {
            caption: "Delete",
            action: async () => {
              const deleted = await deleteMessage(message.id);
              if (!deleted) {
                createErrorDialog(
                  {
                    title: "Delete failed!",
                    message: `An error occured while deleting this message. Please make sure it exists, and then try again.`,
                    image: ErrorIcon,
                    buttons: [{ caption: "Okay", action() {
                    }, suggested: true }],
                    sound: "arcos.dialog.error"
                  },
                  this.pid,
                  true
                );
                return;
              }
              this.Message.set(null);
              this.Update();
            },
            suggested: true
          }
        ],
        image: TrashIcon,
        sound: "arcos.dialog.info"
      },
      this.pid,
      true
    );
  }
  async Compose(body, title, replyId) {
    if (this.HasOverlay.get())
      return;
    const proc = await spawnOverlay(ComposeApp, this.pid, [replyId, body, title]);
    if (typeof proc === "string")
      return;
    this.HasOverlay.set(true);
    const subscriber = ProcessStack.processes.subscribe(() => {
      if (!ProcessStack.isPid(proc.pid, true)) {
        this.HasOverlay.set(false);
        subscriber();
      }
    });
  }
  async ViewThread(id) {
    if (this.HasOverlay.get())
      return;
    const proc = await spawnOverlay(ThreadViewApp, this.pid, [id]);
    if (typeof proc === "string")
      return;
    this.HasOverlay.set(true);
    const subscriber = ProcessStack.processes.subscribe(() => {
      if (!ProcessStack.isPid(proc.pid, true)) {
        this.HasOverlay.set(false);
        subscriber();
      }
    });
  }
  async ReplyToMessage() {
    const message = this.Message.get();
    if (!message)
      return;
    const { title } = parseTitle(message.body);
    this.Compose("", title ? `Re: ${title}` : "", message.id);
  }
  ForwardMessage() {
    const message = this.Message.get();
    if (!message)
      return;
    const { title, body: source } = parseTitle(message.body);
    const sender = message.sender;
    const receiver = message.receiver;
    const ts = dayjs(message.timestamp).format("[on] D MMMM YYYY [at] H:mm:ss");
    const body = `${source}

---

Sent to **${receiver}** by **${sender}** ${ts} (timezone of server). `;
    this.Compose(body, title ? `Fw: ${title}` : "");
  }
  async openLatestSent() {
    await this.navigate("sent", true);
    const sent = await getSentMessages();
    const first = sent[0];
    if (!first)
      return;
    await this.openMessage(first.id);
    this.openMessagePage();
  }
  assignDispatchers() {
    GlobalDispatch.subscribe("message-flush", () => this.Update());
    this.process.handler.dispatch.subscribe(this.pid, "open-message", async (data2) => {
      await this.openMessage(data2);
      this.openMessagePage(false);
    });
    this.process.handler.dispatch.subscribe(this.pid, "open-latest-sent", async () => {
      await sleep(100);
      this.openLatestSent();
    });
  }
  _trayIcon() {
    const id = `MessagingApp#${this.pid}`;
    createTrayIcon({
      identifier: id,
      title: "Messages",
      image: MessagingIcon,
      onOpen: () => {
        focusedPid.set(this.pid);
      }
    });
    ProcessStack.processes.subscribe(() => {
      if (!ProcessStack.isPid(this.pid, true))
        disposeTrayIcon(id);
    });
  }
};
function create_else_block$g(ctx) {
  let textarea;
  return {
    c() {
      textarea = element("textarea");
      textarea.readOnly = true;
      textarea.value = /*body*/
      ctx[1];
      attr(textarea, "class", "source");
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*body*/
      2) {
        textarea.value = /*body*/
        ctx2[1];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(textarea);
      }
    }
  };
}
function create_if_block_1$n(ctx) {
  let markdownrenderer;
  let current;
  markdownrenderer = new MarkdownRenderer({ props: { content: (
    /*body*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(markdownrenderer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(markdownrenderer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const markdownrenderer_changes = {};
      if (dirty & /*body*/
      2)
        markdownrenderer_changes.content = /*body*/
        ctx2[1];
      markdownrenderer.$set(markdownrenderer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(markdownrenderer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(markdownrenderer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(markdownrenderer, detaching);
    }
  };
}
function create_if_block$18(ctx) {
  let div;
  let p2;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      p2 = element("p");
      p2.textContent = "Message is part of a thread.";
      t1 = space();
      button = element("button");
      button.textContent = "View Thread";
      attr(p2, "class", "notice");
      attr(button, "class", "suggested");
      attr(div, "class", "threading-notice");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p2);
      append(div, t1);
      append(div, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*thread*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2l(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block0;
  let t2;
  let current;
  const if_block_creators = [create_if_block_1$n, create_else_block$g];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*$ViewingMessageSource*/
    ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*isThread*/
    ctx[0] && create_if_block$18(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "message-content");
      attr(div1, "class", "message-body");
      toggle_class(
        div1,
        "threading",
        /*isThread*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div0, null);
      }
      if (
        /*isThread*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$18(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*isThread*/
      1) {
        toggle_class(
          div1,
          "threading",
          /*isThread*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance$27($$self, $$props, $$invalidate) {
  let $Message;
  let $ViewingMessageSource;
  let { runtime } = $$props;
  const { Message, ViewingMessageSource } = runtime;
  component_subscribe($$self, Message, (value) => $$invalidate(7, $Message = value));
  component_subscribe($$self, ViewingMessageSource, (value) => $$invalidate(2, $ViewingMessageSource = value));
  let isThread = false;
  let body = "";
  Message.subscribe(async (v2) => {
    if (!v2)
      return $$invalidate(0, isThread = false);
    $$invalidate(0, isThread = !!(v2.replyingTo || v2.replies && v2.replies.length));
    $$invalidate(1, body = "");
    await sleep(5);
    $$invalidate(1, body = v2.body);
  });
  function thread() {
    runtime.ViewThread($Message.id);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(6, runtime = $$props2.runtime);
  };
  return [
    isThread,
    body,
    $ViewingMessageSource,
    Message,
    ViewingMessageSource,
    thread,
    runtime
  ];
}
class MessageBody extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$27, create_fragment$2l, safe_not_equal, { runtime: 6 });
  }
}
function create_if_block$17(ctx) {
  let button;
  let profilepicture;
  let t0;
  let div1;
  let span1;
  let span0;
  let t1;
  let t2;
  let div0;
  let t3;
  let span2;
  let t4_value = filterPartialMessageBody(
    /*message*/
    ctx[0].partialBody
  ) + "";
  let t4;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: { height: 32, src: (
      /*pfp*/
      ctx[1]
    ) }
  });
  return {
    c() {
      button = element("button");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      div1 = element("div");
      span1 = element("span");
      span0 = element("span");
      t1 = text(
        /*username*/
        ctx[2]
      );
      t2 = space();
      div0 = element("div");
      t3 = space();
      span2 = element("span");
      t4 = text(t4_value);
      attr(div0, "class", "unread-dot");
      attr(span1, "class", "receiver");
      attr(span2, "class", "partial");
      attr(div1, "class", "context");
      attr(button, "class", "message-link");
      toggle_class(
        button,
        "selected",
        /*$Message*/
        ctx[7] && /*$Message*/
        ctx[7].id == /*message*/
        ctx[0].id
      );
      toggle_class(
        button,
        "unread",
        /*isUnread*/
        ctx[3]
      );
      toggle_class(button, "reply", !!/*message*/
      ctx[0].replyingTo);
      toggle_class(
        button,
        "sent",
        /*message*/
        ctx[0].sender == /*$UserName*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(profilepicture, button, null);
      append(button, t0);
      append(button, div1);
      append(div1, span1);
      append(span1, span0);
      append(span0, t1);
      append(span1, t2);
      append(span1, div0);
      append(div1, t3);
      append(div1, span2);
      append(span2, t4);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*read*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      2)
        profilepicture_changes.src = /*pfp*/
        ctx2[1];
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*username*/
      4)
        set_data(
          t1,
          /*username*/
          ctx2[2]
        );
      if ((!current || dirty & /*message*/
      1) && t4_value !== (t4_value = filterPartialMessageBody(
        /*message*/
        ctx2[0].partialBody
      ) + ""))
        set_data(t4, t4_value);
      if (!current || dirty & /*$Message, message*/
      129) {
        toggle_class(
          button,
          "selected",
          /*$Message*/
          ctx2[7] && /*$Message*/
          ctx2[7].id == /*message*/
          ctx2[0].id
        );
      }
      if (!current || dirty & /*isUnread*/
      8) {
        toggle_class(
          button,
          "unread",
          /*isUnread*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*message*/
      1) {
        toggle_class(button, "reply", !!/*message*/
        ctx2[0].replyingTo);
      }
      if (!current || dirty & /*message, $UserName*/
      17) {
        toggle_class(
          button,
          "sent",
          /*message*/
          ctx2[0].sender == /*$UserName*/
          ctx2[4]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(profilepicture);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2k(ctx) {
  let show_if = (
    /*$SearchFilter*/
    ctx[5] ? (
      /*$SearchResults*/
      ctx[6].includes(
        /*message*/
        ctx[0].id
      )
    ) : true
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block$17(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$SearchFilter, $SearchResults, message*/
      97)
        show_if = /*$SearchFilter*/
        ctx2[5] ? (
          /*$SearchResults*/
          ctx2[6].includes(
            /*message*/
            ctx2[0].id
          )
        ) : true;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$SearchFilter, $SearchResults, message*/
          97) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$17(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$26($$self, $$props, $$invalidate) {
  let $UserName;
  let $SearchFilter;
  let $SearchResults;
  let $Message;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(4, $UserName = $$value));
  let { runtime } = $$props;
  let { message } = $$props;
  let { users } = $$props;
  const { Message, SearchResults, SearchFilter } = runtime;
  component_subscribe($$self, Message, (value) => $$invalidate(7, $Message = value));
  component_subscribe($$self, SearchResults, (value) => $$invalidate(6, $SearchResults = value));
  component_subscribe($$self, SearchFilter, (value) => $$invalidate(5, $SearchFilter = value));
  let pfp = "";
  let username = "";
  let isUnread = false;
  onMount(async () => {
    const isReceived = message.receiver == $UserName;
    $$invalidate(2, username = isReceived ? message.sender : message.receiver);
    $$invalidate(3, isUnread = isReceived && !message.read);
    $$invalidate(1, pfp = await getUserPfp(username, "", users));
  });
  function read() {
    runtime.openMessage(message.id);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(12, runtime = $$props2.runtime);
    if ("message" in $$props2)
      $$invalidate(0, message = $$props2.message);
    if ("users" in $$props2)
      $$invalidate(13, users = $$props2.users);
  };
  return [
    message,
    pfp,
    username,
    isUnread,
    $UserName,
    $SearchFilter,
    $SearchResults,
    $Message,
    Message,
    SearchResults,
    SearchFilter,
    read,
    runtime,
    users
  ];
}
class Message_1 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$26, create_fragment$2k, safe_not_equal, { runtime: 12, message: 0, users: 13 });
  }
}
function get_each_context$r(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list2[i2];
  return child_ctx;
}
function create_if_block$16(ctx) {
  let div;
  let t2;
  let current;
  let each_value = ensure_array_like(
    /*$Store*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$r(get_each_context$r(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = !/*$Store*/
  ctx[2].length && create_if_block_1$m(ctx);
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "message-list");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      append(div, t2);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$Store, runtime, users*/
      7) {
        each_value = ensure_array_like(
          /*$Store*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$r(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$r(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, t2);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!/*$Store*/
      ctx2[2].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$Store*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$m(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function create_each_block$r(ctx) {
  let message_1;
  let current;
  message_1 = new Message_1({
    props: {
      message: (
        /*message*/
        ctx[6]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      users: (
        /*users*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(message_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(message_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const message_1_changes = {};
      if (dirty & /*$Store*/
      4)
        message_1_changes.message = /*message*/
        ctx2[6];
      if (dirty & /*runtime*/
      1)
        message_1_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*users*/
      2)
        message_1_changes.users = /*users*/
        ctx2[1];
      message_1.$set(message_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(message_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(message_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(message_1, detaching);
    }
  };
}
function create_if_block_1$m(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2$7, create_else_block$f];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*$Loading*/
    ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$f(ctx) {
  let spinner;
  let current;
  spinner = new Spinner({ props: { height: 32 } });
  return {
    c() {
      create_component(spinner.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spinner, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spinner, detaching);
    }
  };
}
function create_if_block_2$7(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "No messages here!";
      attr(p2, "class", "none");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_fragment$2j(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*users*/
    ctx[1] && create_if_block$16(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*users*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*users*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$16(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$25($$self, $$props, $$invalidate) {
  let $Store;
  let $Loading;
  let { runtime } = $$props;
  const { Store: Store2, Loading: Loading4 } = runtime;
  component_subscribe($$self, Store2, (value) => $$invalidate(2, $Store = value));
  component_subscribe($$self, Loading4, (value) => $$invalidate(3, $Loading = value));
  let users;
  onMount(async () => {
    $$invalidate(1, users = await getUsers());
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, users, $Store, $Loading, Store2, Loading4];
}
class MessageList extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$25, create_fragment$2j, safe_not_equal, { runtime: 0 });
  }
}
function create_else_block$e(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Please wait...");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$l(ctx) {
  let t0_value = (
    /*$Store*/
    ctx[1].length + ""
  );
  let t0;
  let t1;
  let t2_value = Plural(
    "message",
    /*$Store*/
    ctx[1].length
  ) + "";
  let t2;
  let t3;
  let t4;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = text(" in ");
      t4 = text(
        /*$Page*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, t4, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$Store*/
      2 && t0_value !== (t0_value = /*$Store*/
      ctx2[1].length + ""))
        set_data(t0, t0_value);
      if (dirty & /*$Store*/
      2 && t2_value !== (t2_value = Plural(
        "message",
        /*$Store*/
        ctx2[1].length
      ) + ""))
        set_data(t2, t2_value);
      if (dirty & /*$Page*/
      8)
        set_data(
          t4,
          /*$Page*/
          ctx2[3]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
      }
    }
  };
}
function create_if_block$15(ctx) {
  let div;
  let span0;
  let t0;
  let t1_value = (
    /*$Message*/
    ctx[4].sender + ""
  );
  let t1;
  let t2;
  let t3_value = (
    /*$Message*/
    ctx[4].receiver + ""
  );
  let t3;
  let t4;
  let span1;
  return {
    c() {
      div = element("div");
      span0 = element("span");
      t0 = text("From: ");
      t1 = text(t1_value);
      t2 = text(" - To: ");
      t3 = text(t3_value);
      t4 = space();
      span1 = element("span");
      span1.textContent = "done_all";
      attr(span1, "class", "material-icons-round");
      toggle_class(span1, "disabled", !/*$Message*/
      ctx[4].read);
      attr(div, "class", "segment people");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      append(span0, t0);
      append(span0, t1);
      append(span0, t2);
      append(span0, t3);
      append(div, t4);
      append(div, span1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$Message*/
      16 && t1_value !== (t1_value = /*$Message*/
      ctx2[4].sender + ""))
        set_data(t1, t1_value);
      if (dirty & /*$Message*/
      16 && t3_value !== (t3_value = /*$Message*/
      ctx2[4].receiver + ""))
        set_data(t3, t3_value);
      if (dirty & /*$Message*/
      16) {
        toggle_class(span1, "disabled", !/*$Message*/
        ctx2[4].read);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$2i(ctx) {
  let div5;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let apireveal;
  let t3;
  let div2;
  let t4;
  let t5;
  let div3;
  let span0;
  let t7;
  let span1;
  let t9;
  let span2;
  let t11;
  let span3;
  let t13;
  let div4;
  let t14_value = (
    /*$Loading*/
    ctx[2] ? "Loading..." : "Ready."
  );
  let t14;
  let current;
  apireveal = new ApiReveal({});
  function select_block_type(ctx2, dirty) {
    if (
      /*$Store*/
      ctx2[1] && !/*$Loading*/
      ctx2[2]
    )
      return create_if_block_1$l;
    return create_else_block$e;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*$Message*/
    ctx[4] && create_if_block$15(ctx)
  );
  return {
    c() {
      div5 = element("div");
      div0 = element("div");
      t0 = text(
        /*$UserName*/
        ctx[0]
      );
      t1 = space();
      div1 = element("div");
      t2 = text("Server ");
      create_component(apireveal.$$.fragment);
      t3 = space();
      div2 = element("div");
      if_block0.c();
      t4 = space();
      if (if_block1)
        if_block1.c();
      t5 = space();
      div3 = element("div");
      span0 = element("span");
      span0.textContent = "reply";
      t7 = space();
      span1 = element("span");
      span1.textContent = "sync";
      t9 = space();
      span2 = element("span");
      span2.textContent = "edit";
      t11 = space();
      span3 = element("span");
      span3.textContent = "code";
      t13 = space();
      div4 = element("div");
      t14 = text(t14_value);
      attr(div0, "class", "segment");
      attr(div1, "class", "segment");
      attr(div2, "class", "segment");
      attr(span0, "class", "material-icons-round");
      toggle_class(
        span0,
        "disabled",
        /*$Message*/
        ctx[4] ? !/*$Message*/
        ctx[4].replyingTo : true
      );
      attr(span1, "class", "material-icons-round");
      toggle_class(span1, "disabled", !/*$Loading*/
      ctx[2]);
      attr(span2, "class", "material-icons-round");
      toggle_class(span2, "disabled", !/*$Composing*/
      ctx[5]);
      attr(span3, "class", "material-icons-round");
      toggle_class(span3, "disabled", !/*$ViewingMessageSource*/
      ctx[6]);
      attr(div3, "class", "segment right");
      attr(div4, "class", "segment");
      attr(div5, "class", "statusbar");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div0);
      append(div0, t0);
      append(div5, t1);
      append(div5, div1);
      append(div1, t2);
      mount_component(apireveal, div1, null);
      append(div5, t3);
      append(div5, div2);
      if_block0.m(div2, null);
      append(div5, t4);
      if (if_block1)
        if_block1.m(div5, null);
      append(div5, t5);
      append(div5, div3);
      append(div3, span0);
      append(div3, t7);
      append(div3, span1);
      append(div3, t9);
      append(div3, span2);
      append(div3, t11);
      append(div3, span3);
      append(div5, t13);
      append(div5, div4);
      append(div4, t14);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$UserName*/
      1)
        set_data(
          t0,
          /*$UserName*/
          ctx2[0]
        );
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div2, null);
        }
      }
      if (
        /*$Message*/
        ctx2[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$15(ctx2);
          if_block1.c();
          if_block1.m(div5, t5);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*$Message*/
      16) {
        toggle_class(
          span0,
          "disabled",
          /*$Message*/
          ctx2[4] ? !/*$Message*/
          ctx2[4].replyingTo : true
        );
      }
      if (!current || dirty & /*$Loading*/
      4) {
        toggle_class(span1, "disabled", !/*$Loading*/
        ctx2[2]);
      }
      if (!current || dirty & /*$Composing*/
      32) {
        toggle_class(span2, "disabled", !/*$Composing*/
        ctx2[5]);
      }
      if (!current || dirty & /*$ViewingMessageSource*/
      64) {
        toggle_class(span3, "disabled", !/*$ViewingMessageSource*/
        ctx2[6]);
      }
      if ((!current || dirty & /*$Loading*/
      4) && t14_value !== (t14_value = /*$Loading*/
      ctx2[2] ? "Loading..." : "Ready."))
        set_data(t14, t14_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(apireveal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(apireveal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      destroy_component(apireveal);
      if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance$24($$self, $$props, $$invalidate) {
  let $UserName;
  let $Store;
  let $Loading;
  let $Page;
  let $Message;
  let $Composing;
  let $ViewingMessageSource;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(0, $UserName = $$value));
  let { runtime } = $$props;
  const { Store: Store2, Page: Page3, Loading: Loading4, Message, HasOverlay: Composing, ViewingMessageSource } = runtime;
  component_subscribe($$self, Store2, (value) => $$invalidate(1, $Store = value));
  component_subscribe($$self, Page3, (value) => $$invalidate(3, $Page = value));
  component_subscribe($$self, Loading4, (value) => $$invalidate(2, $Loading = value));
  component_subscribe($$self, Message, (value) => $$invalidate(4, $Message = value));
  component_subscribe($$self, Composing, (value) => $$invalidate(5, $Composing = value));
  component_subscribe($$self, ViewingMessageSource, (value) => $$invalidate(6, $ViewingMessageSource = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(13, runtime = $$props2.runtime);
  };
  return [
    $UserName,
    $Store,
    $Loading,
    $Page,
    $Message,
    $Composing,
    $ViewingMessageSource,
    Store2,
    Page3,
    Loading4,
    Message,
    Composing,
    ViewingMessageSource,
    runtime
  ];
}
let Statusbar$1 = class Statusbar extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$24, create_fragment$2i, safe_not_equal, { runtime: 13 });
  }
};
function create_fragment$2h(ctx) {
  let button;
  let t_value = (
    /*$ViewingMessageSource*/
    ctx[0] ? "code_off" : "code"
  );
  let t2;
  let button_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "class", "material-icons-round");
      attr(button, "title", button_title_value = /*$ViewingMessageSource*/
      ctx[0] ? "View Parsed" : "View Source");
      button.disabled = /*$Composing*/
      ctx[1];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggle*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$ViewingMessageSource*/
      1 && t_value !== (t_value = /*$ViewingMessageSource*/
      ctx2[0] ? "code_off" : "code"))
        set_data(t2, t_value);
      if (dirty & /*$ViewingMessageSource*/
      1 && button_title_value !== (button_title_value = /*$ViewingMessageSource*/
      ctx2[0] ? "View Parsed" : "View Source")) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*$Composing*/
      2) {
        button.disabled = /*$Composing*/
        ctx2[1];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$23($$self, $$props, $$invalidate) {
  let $ViewingMessageSource;
  let $Composing;
  let { runtime } = $$props;
  const { ViewingMessageSource, HasOverlay: Composing } = runtime;
  component_subscribe($$self, ViewingMessageSource, (value) => $$invalidate(0, $ViewingMessageSource = value));
  component_subscribe($$self, Composing, (value) => $$invalidate(1, $Composing = value));
  function toggle() {
    set_store_value(ViewingMessageSource, $ViewingMessageSource = !$ViewingMessageSource, $ViewingMessageSource);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
  };
  return [
    $ViewingMessageSource,
    $Composing,
    ViewingMessageSource,
    Composing,
    toggle,
    runtime
  ];
}
class Code2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$23, create_fragment$2h, safe_not_equal, { runtime: 5 });
  }
}
function create_fragment$2g(ctx) {
  let button;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text("Compose");
      attr(button, "class", "compose-button suggested");
      button.disabled = /*$Composing*/
      ctx[0];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*compose*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$Composing*/
      1) {
        button.disabled = /*$Composing*/
        ctx2[0];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$22($$self, $$props, $$invalidate) {
  let $Composing;
  let { runtime } = $$props;
  const { HasOverlay: Composing } = runtime;
  component_subscribe($$self, Composing, (value) => $$invalidate(0, $Composing = value));
  function compose() {
    runtime.Compose();
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [$Composing, Composing, compose, runtime];
}
class Compose2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$22, create_fragment$2g, safe_not_equal, { runtime: 3 });
  }
}
function create_fragment$2f(ctx) {
  let div1;
  let div0;
  let span;
  let t1;
  let input;
  let t2;
  let button;
  let t3;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      span.textContent = "search";
      t1 = space();
      input = element("input");
      t2 = space();
      button = element("button");
      t3 = text("refresh");
      attr(span, "class", "material-icons-round");
      attr(input, "type", "text");
      attr(input, "placeholder", "Search");
      input.disabled = /*$Composing*/
      ctx[0];
      attr(div0, "class", "search-box");
      attr(button, "class", "material-icons-round");
      button.disabled = /*$Composing*/
      ctx[0];
      attr(button, "title", "Refresh");
      attr(div1, "class", "left");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span);
      append(div0, t1);
      append(div0, input);
      set_input_value(
        input,
        /*$value*/
        ctx[1]
      );
      append(div1, t2);
      append(div1, button);
      append(button, t3);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[6]
          ),
          listen(
            button,
            "click",
            /*refresh*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$Composing*/
      1) {
        input.disabled = /*$Composing*/
        ctx2[0];
      }
      if (dirty & /*$value*/
      2 && input.value !== /*$value*/
      ctx2[1]) {
        set_input_value(
          input,
          /*$value*/
          ctx2[1]
        );
      }
      if (dirty & /*$Composing*/
      1) {
        button.disabled = /*$Composing*/
        ctx2[0];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$21($$self, $$props, $$invalidate) {
  let $Composing;
  let $value;
  let { runtime } = $$props;
  const { HasOverlay: Composing } = runtime;
  component_subscribe($$self, Composing, (value2) => $$invalidate(0, $Composing = value2));
  let value = Store$1();
  component_subscribe($$self, value, (value2) => $$invalidate(1, $value = value2));
  value.subscribe((v2) => {
    runtime.Search(v2);
  });
  function refresh() {
    runtime.Update();
  }
  function input_input_handler() {
    $value = this.value;
    value.set($value);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
  };
  return [$Composing, $value, Composing, value, refresh, runtime, input_input_handler];
}
class Left extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$21, create_fragment$2f, safe_not_equal, { runtime: 5 });
  }
}
function create_fragment$2e(ctx) {
  let div;
  let button0;
  let t0;
  let button0_disabled_value;
  let t1;
  let button1;
  let t2;
  let button1_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text("reply");
      t1 = space();
      button1 = element("button");
      t2 = text("share");
      attr(button0, "class", "material-icons-round");
      button0.disabled = button0_disabled_value = !/*$Message*/
      ctx[0] || /*$Composing*/
      ctx[1];
      attr(button0, "title", "Reply to Message");
      attr(button1, "class", "material-icons-round");
      button1.disabled = button1_disabled_value = !/*$Message*/
      ctx[0] || /*$Composing*/
      ctx[1];
      attr(button1, "title", "Forward Message");
      attr(div, "class", "group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*reply*/
            ctx[5]
          ),
          listen(
            button1,
            "click",
            /*forward*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$Message, $Composing*/
      3 && button0_disabled_value !== (button0_disabled_value = !/*$Message*/
      ctx2[0] || /*$Composing*/
      ctx2[1])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*$Message, $Composing*/
      3 && button1_disabled_value !== (button1_disabled_value = !/*$Message*/
      ctx2[0] || /*$Composing*/
      ctx2[1])) {
        button1.disabled = button1_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$20($$self, $$props, $$invalidate) {
  let $Message;
  let $Composing;
  let { runtime } = $$props;
  const { Message, HasOverlay: Composing } = runtime;
  component_subscribe($$self, Message, (value) => $$invalidate(0, $Message = value));
  component_subscribe($$self, Composing, (value) => $$invalidate(1, $Composing = value));
  function forward() {
    runtime.ForwardMessage();
  }
  function reply() {
    runtime.ReplyToMessage();
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(6, runtime = $$props2.runtime);
  };
  return [$Message, $Composing, Message, Composing, forward, reply, runtime];
}
class ReplyShare extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$20, create_fragment$2e, safe_not_equal, { runtime: 6 });
  }
}
function create_fragment$2d(ctx) {
  let div;
  let button0;
  let t0;
  let button0_disabled_value;
  let t1;
  let button1;
  let t2;
  let button1_disabled_value;
  let t3;
  let button2;
  let t4_value = (
    /*archived*/
    ctx[0] ? "unarchive" : "archive"
  );
  let t4;
  let button2_disabled_value;
  let button2_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text("save");
      t1 = space();
      button1 = element("button");
      t2 = text("delete");
      t3 = space();
      button2 = element("button");
      t4 = text(t4_value);
      attr(button0, "class", "material-icons-round");
      button0.disabled = button0_disabled_value = !/*$Message*/
      ctx[1] || /*$Composing*/
      ctx[2];
      attr(button0, "title", "Save Message...");
      attr(button1, "class", "material-icons-round");
      button1.disabled = button1_disabled_value = !/*$Message*/
      ctx[1] || /*$Message*/
      ctx[1].receiver !== /*$UserName*/
      ctx[3] || /*$Composing*/
      ctx[2];
      attr(button1, "title", "Delete Message");
      attr(button2, "class", "material-icons-round");
      button2.disabled = button2_disabled_value = !/*$Message*/
      ctx[1] || /*$Composing*/
      ctx[2];
      attr(button2, "title", button2_title_value = /*archived*/
      ctx[0] ? "Unarchive message" : "Archive message");
      attr(div, "class", "group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      append(div, t3);
      append(div, button2);
      append(button2, t4);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*saveMessage*/
            ctx[7]
          ),
          listen(
            button1,
            "click",
            /*deleteMessage*/
            ctx[8]
          ),
          listen(
            button2,
            "click",
            /*archive*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$Message, $Composing*/
      6 && button0_disabled_value !== (button0_disabled_value = !/*$Message*/
      ctx2[1] || /*$Composing*/
      ctx2[2])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*$Message, $UserName, $Composing*/
      14 && button1_disabled_value !== (button1_disabled_value = !/*$Message*/
      ctx2[1] || /*$Message*/
      ctx2[1].receiver !== /*$UserName*/
      ctx2[3] || /*$Composing*/
      ctx2[2])) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*archived*/
      1 && t4_value !== (t4_value = /*archived*/
      ctx2[0] ? "unarchive" : "archive"))
        set_data(t4, t4_value);
      if (dirty & /*$Message, $Composing*/
      6 && button2_disabled_value !== (button2_disabled_value = !/*$Message*/
      ctx2[1] || /*$Composing*/
      ctx2[2])) {
        button2.disabled = button2_disabled_value;
      }
      if (dirty & /*archived*/
      1 && button2_title_value !== (button2_title_value = /*archived*/
      ctx2[0] ? "Unarchive message" : "Archive message")) {
        attr(button2, "title", button2_title_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1$($$self, $$props, $$invalidate) {
  let $Message;
  let $Composing;
  let $UserName;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(3, $UserName = $$value));
  let { runtime } = $$props;
  const { Message, HasOverlay: Composing } = runtime;
  component_subscribe($$self, Message, (value) => $$invalidate(1, $Message = value));
  component_subscribe($$self, Composing, (value) => $$invalidate(2, $Composing = value));
  let archived = false;
  Message.subscribe((v2) => {
    if (!v2)
      return;
    $$invalidate(0, archived = isArchived(v2.id));
  });
  function archive() {
    runtime.ArchiveMessage();
  }
  function saveMessage() {
    runtime.SaveMessage();
  }
  function deleteMessage2() {
    runtime.DeleteMessage();
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(9, runtime = $$props2.runtime);
  };
  return [
    archived,
    $Message,
    $Composing,
    $UserName,
    Message,
    Composing,
    archive,
    saveMessage,
    deleteMessage2,
    runtime
  ];
}
class Store extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1$, create_fragment$2d, safe_not_equal, { runtime: 9 });
  }
}
function create_if_block_1$k(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "sep");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block$14(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "sep");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$2c(ctx) {
  let div3;
  let t0;
  let left;
  let t1;
  let div0;
  let t2;
  let replyshare;
  let t3;
  let div1;
  let t4;
  let store;
  let t5;
  let div2;
  let t6;
  let code;
  let t7;
  let compose;
  let t8;
  let current;
  let if_block0 = (
    /*$UserDataStore*/
    ctx[2].sh.window.lefttb && create_if_block_1$k()
  );
  left = new Left({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  replyshare = new ReplyShare({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  store = new Store({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  code = new Code2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  compose = new Compose2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  let if_block1 = !/*$UserDataStore*/
  ctx[2].sh.window.lefttb && create_if_block$14();
  return {
    c() {
      div3 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(left.$$.fragment);
      t1 = space();
      div0 = element("div");
      t2 = space();
      create_component(replyshare.$$.fragment);
      t3 = space();
      div1 = element("div");
      t4 = space();
      create_component(store.$$.fragment);
      t5 = space();
      div2 = element("div");
      t6 = space();
      create_component(code.$$.fragment);
      t7 = space();
      create_component(compose.$$.fragment);
      t8 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "sep");
      attr(div1, "class", "sep");
      attr(div2, "class", "sep");
      attr(div3, "class", "toolbar");
      toggle_class(
        div3,
        "disabled",
        /*$Composing*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, t0);
      mount_component(left, div3, null);
      append(div3, t1);
      append(div3, div0);
      append(div3, t2);
      mount_component(replyshare, div3, null);
      append(div3, t3);
      append(div3, div1);
      append(div3, t4);
      mount_component(store, div3, null);
      append(div3, t5);
      append(div3, div2);
      append(div3, t6);
      mount_component(code, div3, null);
      append(div3, t7);
      mount_component(compose, div3, null);
      append(div3, t8);
      if (if_block1)
        if_block1.m(div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$UserDataStore*/
        ctx2[2].sh.window.lefttb
      ) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_1$k();
          if_block0.c();
          if_block0.m(div3, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      const left_changes = {};
      if (dirty & /*runtime*/
      1)
        left_changes.runtime = /*runtime*/
        ctx2[0];
      left.$set(left_changes);
      const replyshare_changes = {};
      if (dirty & /*runtime*/
      1)
        replyshare_changes.runtime = /*runtime*/
        ctx2[0];
      replyshare.$set(replyshare_changes);
      const store_changes = {};
      if (dirty & /*runtime*/
      1)
        store_changes.runtime = /*runtime*/
        ctx2[0];
      store.$set(store_changes);
      const code_changes = {};
      if (dirty & /*runtime*/
      1)
        code_changes.runtime = /*runtime*/
        ctx2[0];
      code.$set(code_changes);
      const compose_changes = {};
      if (dirty & /*runtime*/
      1)
        compose_changes.runtime = /*runtime*/
        ctx2[0];
      compose.$set(compose_changes);
      if (!/*$UserDataStore*/
      ctx2[2].sh.window.lefttb) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block$14();
          if_block1.c();
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*$Composing*/
      2) {
        toggle_class(
          div3,
          "disabled",
          /*$Composing*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(left.$$.fragment, local);
      transition_in(replyshare.$$.fragment, local);
      transition_in(store.$$.fragment, local);
      transition_in(code.$$.fragment, local);
      transition_in(compose.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(left.$$.fragment, local);
      transition_out(replyshare.$$.fragment, local);
      transition_out(store.$$.fragment, local);
      transition_out(code.$$.fragment, local);
      transition_out(compose.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block0)
        if_block0.d();
      destroy_component(left);
      destroy_component(replyshare);
      destroy_component(store);
      destroy_component(code);
      destroy_component(compose);
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance$1_($$self, $$props, $$invalidate) {
  let $Composing;
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(2, $UserDataStore = $$value));
  let { runtime } = $$props;
  const { HasOverlay: Composing } = runtime;
  component_subscribe($$self, Composing, (value) => $$invalidate(1, $Composing = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, $Composing, $UserDataStore, Composing];
}
let Toolbar$2 = class Toolbar6 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1_, create_fragment$2c, safe_not_equal, { runtime: 0 });
  }
};
function create_default_slot$i(ctx) {
  let toolbar;
  let current;
  toolbar = new Toolbar$2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(toolbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(toolbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const toolbar_changes = {};
      if (dirty & /*runtime*/
      1)
        toolbar_changes.runtime = /*runtime*/
        ctx2[0];
      toolbar.$set(toolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toolbar, detaching);
    }
  };
}
function create_fragment$2b(ctx) {
  let div1;
  let titlebar;
  let t0;
  let div0;
  let messagelist;
  let t1;
  let messagebody;
  let t2;
  let statusbar;
  let current;
  titlebar = new Titlebar({
    props: {
      pid: (
        /*runtime*/
        ctx[0].pid
      ),
      app: (
        /*runtime*/
        ctx[0].appMutator
      ),
      showIcon: false,
      showTitle: false,
      $$slots: { default: [create_default_slot$i] },
      $$scope: { ctx }
    }
  });
  messagelist = new MessageList({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  messagebody = new MessageBody({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  statusbar = new Statusbar$1({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div1 = element("div");
      create_component(titlebar.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(messagelist.$$.fragment);
      t1 = space();
      create_component(messagebody.$$.fragment);
      t2 = space();
      create_component(statusbar.$$.fragment);
      attr(div0, "class", "bottom");
      attr(div1, "class", "content");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(titlebar, div1, null);
      append(div1, t0);
      append(div1, div0);
      mount_component(messagelist, div0, null);
      append(div0, t1);
      mount_component(messagebody, div0, null);
      append(div1, t2);
      mount_component(statusbar, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const titlebar_changes = {};
      if (dirty & /*runtime*/
      1)
        titlebar_changes.pid = /*runtime*/
        ctx2[0].pid;
      if (dirty & /*runtime*/
      1)
        titlebar_changes.app = /*runtime*/
        ctx2[0].appMutator;
      if (dirty & /*$$scope, runtime*/
      3) {
        titlebar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      titlebar.$set(titlebar_changes);
      const messagelist_changes = {};
      if (dirty & /*runtime*/
      1)
        messagelist_changes.runtime = /*runtime*/
        ctx2[0];
      messagelist.$set(messagelist_changes);
      const messagebody_changes = {};
      if (dirty & /*runtime*/
      1)
        messagebody_changes.runtime = /*runtime*/
        ctx2[0];
      messagebody.$set(messagebody_changes);
      const statusbar_changes = {};
      if (dirty & /*runtime*/
      1)
        statusbar_changes.runtime = /*runtime*/
        ctx2[0];
      statusbar.$set(statusbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(titlebar.$$.fragment, local);
      transition_in(messagelist.$$.fragment, local);
      transition_in(messagebody.$$.fragment, local);
      transition_in(statusbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(titlebar.$$.fragment, local);
      transition_out(messagelist.$$.fragment, local);
      transition_out(messagebody.$$.fragment, local);
      transition_out(statusbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(titlebar);
      destroy_component(messagelist);
      destroy_component(messagebody);
      destroy_component(statusbar);
    }
  };
}
function instance$1Z($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime];
}
let Content$1 = class Content4 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1Z, create_fragment$2b, safe_not_equal, { runtime: 0 });
  }
};
function create_fragment$2a(ctx) {
  let button;
  let span0;
  let t0_value = (
    /*page*/
    ctx[1].icon + ""
  );
  let t0;
  let t1;
  let span1;
  let t2_value = (
    /*page*/
    ctx[1].name + ""
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      attr(span0, "class", "material-icons-round");
      attr(button, "class", "page");
      toggle_class(
        button,
        "active",
        /*$Page*/
        ctx[2] == /*id*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span0);
      append(span0, t0);
      append(button, t1);
      append(button, span1);
      append(span1, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*navigate*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*page*/
      2 && t0_value !== (t0_value = /*page*/
      ctx2[1].icon + ""))
        set_data(t0, t0_value);
      if (dirty & /*page*/
      2 && t2_value !== (t2_value = /*page*/
      ctx2[1].name + ""))
        set_data(t2, t2_value);
      if (dirty & /*$Page, id*/
      5) {
        toggle_class(
          button,
          "active",
          /*$Page*/
          ctx2[2] == /*id*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$1Y($$self, $$props, $$invalidate) {
  let $Page;
  let { id } = $$props;
  let { page } = $$props;
  let { runtime } = $$props;
  const { Page: Page3 } = runtime;
  component_subscribe($$self, Page3, (value) => $$invalidate(2, $Page = value));
  function navigate() {
    runtime.navigate(id);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("page" in $$props2)
      $$invalidate(1, page = $$props2.page);
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
  };
  return [id, page, $Page, Page3, navigate, runtime];
}
class Page_1 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1Y, create_fragment$2a, safe_not_equal, { id: 0, page: 1, runtime: 5 });
  }
}
function get_each_context$q(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2][0];
  child_ctx[2] = list2[i2][1];
  return child_ctx;
}
function create_each_block$q(ctx) {
  let page_1;
  let current;
  page_1 = new Page_1({
    props: {
      id: (
        /*id*/
        ctx[1]
      ),
      page: (
        /*page*/
        ctx[2]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(page_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(page_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const page_1_changes = {};
      if (dirty & /*runtime*/
      1)
        page_1_changes.runtime = /*runtime*/
        ctx2[0];
      page_1.$set(page_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(page_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(page_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(page_1, detaching);
    }
  };
}
function create_fragment$29(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(Object.entries(MessagingPages));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$q(get_each_context$q(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "sidebar");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Object, runtime*/
      1) {
        each_value = ensure_array_like(Object.entries(MessagingPages));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$q(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$q(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$1X($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime];
}
class Sidebar3 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1X, create_fragment$29, safe_not_equal, { runtime: 0 });
  }
}
const main$b = "";
function create_fragment$28(ctx) {
  let sidebar;
  let t2;
  let content;
  let current;
  sidebar = new Sidebar3({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  content = new Content$1({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(sidebar.$$.fragment);
      t2 = space();
      create_component(content.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sidebar, target, anchor);
      insert(target, t2, anchor);
      mount_component(content, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const sidebar_changes = {};
      if (dirty & /*runtime*/
      1)
        sidebar_changes.runtime = /*runtime*/
        ctx2[0];
      sidebar.$set(sidebar_changes);
      const content_changes = {};
      if (dirty & /*runtime*/
      1)
        content_changes.runtime = /*runtime*/
        ctx2[0];
      content.$set(content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      transition_in(content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      transition_out(content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(sidebar, detaching);
      destroy_component(content, detaching);
    }
  };
}
function instance$1W($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime];
}
let App$9 = class App22 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1W, create_fragment$28, safe_not_equal, { runtime: 0 });
  }
};
const MessagingApp = {
  metadata: {
    name: "Messages",
    description: "Send messages to other ArcOS users",
    author: "The ArcOS Team",
    version: "2.0.0",
    icon: MessagingIcon,
    appGroup: "communication"
  },
  runtime: Runtime$3,
  content: App$9,
  id: "MessagingApp",
  size: { w: 1e3, h: 700 },
  minSize: { w: 900, h: 550 },
  maxSize: { w: 1800, h: 1e3 },
  pos: { x: 100, y: 100 },
  state: {
    minimized: false,
    maximized: false,
    headless: true,
    fullscreen: false,
    resizable: true
  },
  controls: {
    minimize: true,
    maximize: true,
    close: true
  },
  glass: true,
  singleInstance: true,
  loadCondition: () => !SafeMode.get()
};
const get_renderer_slot_changes = (dirty) => ({});
const get_renderer_slot_context = (ctx) => ({});
const get_right_slot_changes = (dirty) => ({});
const get_right_slot_context = (ctx) => ({});
function get_each_context$p(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2];
  return child_ctx;
}
function create_each_block$p(ctx) {
  let button;
  let t_value = (
    /*tab*/
    ctx[5] + ""
  );
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[4](
        /*tab*/
        ctx[5]
      )
    );
  }
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "class", "tab");
      toggle_class(
        button,
        "suggested",
        /*current*/
        ctx[0] == /*tab*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*tabs*/
      2 && t_value !== (t_value = /*tab*/
      ctx[5] + ""))
        set_data(t2, t_value);
      if (dirty & /*current, tabs*/
      3) {
        toggle_class(
          button,
          "suggested",
          /*current*/
          ctx[0] == /*tab*/
          ctx[5]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$27(ctx) {
  let div2;
  let div1;
  let t0;
  let div0;
  let t1;
  let current;
  let each_value = ensure_array_like(
    /*tabs*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$p(get_each_context$p(ctx, each_value, i2));
  }
  const right_slot_template = (
    /*#slots*/
    ctx[3].right
  );
  const right_slot = create_slot(
    right_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_right_slot_context
  );
  const renderer_slot_template = (
    /*#slots*/
    ctx[3].renderer
  );
  const renderer_slot = create_slot(
    renderer_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_renderer_slot_context
  );
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      div0 = element("div");
      if (right_slot)
        right_slot.c();
      t1 = space();
      if (renderer_slot)
        renderer_slot.c();
      attr(div0, "class", "right");
      attr(div1, "class", "tabs");
      attr(div2, "class", "tab-interface");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      append(div1, t0);
      append(div1, div0);
      if (right_slot) {
        right_slot.m(div0, null);
      }
      append(div2, t1);
      if (renderer_slot) {
        renderer_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*current, tabs*/
      3) {
        each_value = ensure_array_like(
          /*tabs*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$p(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$p(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div1, t0);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (right_slot) {
        if (right_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            right_slot,
            right_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              right_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_right_slot_changes
            ),
            get_right_slot_context
          );
        }
      }
      if (renderer_slot) {
        if (renderer_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            renderer_slot,
            renderer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              renderer_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_renderer_slot_changes
            ),
            get_renderer_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(right_slot, local);
      transition_in(renderer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(right_slot, local);
      transition_out(renderer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
      if (right_slot)
        right_slot.d(detaching);
      if (renderer_slot)
        renderer_slot.d(detaching);
    }
  };
}
function instance$1V($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { tabs = [] } = $$props;
  let { current = "" } = $$props;
  onMount(() => {
    $$invalidate(0, current = tabs.length ? tabs[0] : "");
  });
  const click_handler = (tab) => $$invalidate(0, current = tab);
  $$self.$$set = ($$props2) => {
    if ("tabs" in $$props2)
      $$invalidate(1, tabs = $$props2.tabs);
    if ("current" in $$props2)
      $$invalidate(0, current = $$props2.current);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [current, tabs, $$scope, slots, click_handler];
}
class Tabs extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1V, create_fragment$27, safe_not_equal, { tabs: 1, current: 0 });
  }
}
function create_fragment$26(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "tab");
      toggle_class(
        div,
        "visible",
        /*current*/
        ctx[0] == /*selector*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*current, selector*/
      3) {
        toggle_class(
          div,
          "visible",
          /*current*/
          ctx2[0] == /*selector*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$1U($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { current } = $$props;
  let { selector } = $$props;
  $$self.$$set = ($$props2) => {
    if ("current" in $$props2)
      $$invalidate(0, current = $$props2.current);
    if ("selector" in $$props2)
      $$invalidate(1, selector = $$props2.selector);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [current, selector, $$scope, slots];
}
class Tab extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1U, create_fragment$26, safe_not_equal, { current: 0, selector: 1 });
  }
}
let Runtime$2 = class Runtime21 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "selected", Store$1());
    __publicField(this, "selectedService", Store$1());
    process.accelerator.store.push({
      key: "escape",
      action() {
        if (app.isOverlay)
          process.handler.kill(process.pid, true);
      }
    });
  }
};
function create_fragment$25(ctx) {
  let div3;
  return {
    c() {
      div3 = element("div");
      div3.innerHTML = `<div class="segment name">Process Name</div> <div class="segment pid">PID</div> <div class="segment app-id">App ID</div>`;
      attr(div3, "class", "row header");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
    }
  };
}
let Header$6 = class Header7 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$25, safe_not_equal, {});
  }
};
function create_if_block$13(ctx) {
  let div3;
  let div0;
  let p2;
  let t0;
  let t1;
  let t2;
  let div2;
  let button0;
  let t3;
  let button0_disabled_value;
  let t4;
  let button1;
  let t5;
  let button1_disabled_value;
  let t6;
  let div1;
  let t7;
  let button2;
  let t8;
  let t9_value = (
    /*proc*/
    ctx[1] && /*proc*/
    ctx[1].app ? "App" : "Process"
  );
  let t9;
  let button2_disabled_value;
  let t10;
  let mounted;
  let dispose;
  let if_block = (
    /*runtime*/
    ctx[0].app && /*runtime*/
    ctx[0].app.isOverlay && create_if_block_1$j(ctx)
  );
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      p2 = element("p");
      t0 = text(
        /*amount*/
        ctx[2]
      );
      t1 = text(" running tasks");
      t2 = space();
      div2 = element("div");
      button0 = element("button");
      t3 = text("App Info");
      t4 = space();
      button1 = element("button");
      t5 = text("Focus");
      t6 = space();
      div1 = element("div");
      t7 = space();
      button2 = element("button");
      t8 = text("Kill ");
      t9 = text(t9_value);
      t10 = space();
      if (if_block)
        if_block.c();
      attr(p2, "class", "running");
      attr(div0, "class", "left");
      button0.disabled = button0_disabled_value = !/*proc*/
      ctx[1] || !/*proc*/
      ctx[1].app;
      button1.disabled = button1_disabled_value = !/*proc*/
      ctx[1] || !/*proc*/
      ctx[1].app;
      attr(div1, "class", "sep");
      attr(button2, "class", "suggested");
      button2.disabled = button2_disabled_value = !/*proc*/
      ctx[1];
      attr(div2, "class", "right");
      attr(div3, "class", "toolbar");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, p2);
      append(p2, t0);
      append(p2, t1);
      append(div3, t2);
      append(div3, div2);
      append(div2, button0);
      append(button0, t3);
      append(div2, t4);
      append(div2, button1);
      append(button1, t5);
      append(div2, t6);
      append(div2, div1);
      append(div2, t7);
      append(div2, button2);
      append(button2, t8);
      append(button2, t9);
      append(div2, t10);
      if (if_block)
        if_block.m(div2, null);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*info*/
            ctx[3]
          ),
          listen(
            button1,
            "click",
            /*focus*/
            ctx[4]
          ),
          listen(
            button2,
            "click",
            /*kill*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*amount*/
      4)
        set_data(
          t0,
          /*amount*/
          ctx2[2]
        );
      if (dirty & /*proc*/
      2 && button0_disabled_value !== (button0_disabled_value = !/*proc*/
      ctx2[1] || !/*proc*/
      ctx2[1].app)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*proc*/
      2 && button1_disabled_value !== (button1_disabled_value = !/*proc*/
      ctx2[1] || !/*proc*/
      ctx2[1].app)) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*proc*/
      2 && t9_value !== (t9_value = /*proc*/
      ctx2[1] && /*proc*/
      ctx2[1].app ? "App" : "Process"))
        set_data(t9, t9_value);
      if (dirty & /*proc*/
      2 && button2_disabled_value !== (button2_disabled_value = !/*proc*/
      ctx2[1])) {
        button2.disabled = button2_disabled_value;
      }
      if (
        /*runtime*/
        ctx2[0].app && /*runtime*/
        ctx2[0].app.isOverlay
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$j(ctx2);
          if_block.c();
          if_block.m(div2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$j(ctx) {
  let div;
  let t0;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t0 = space();
      button = element("button");
      button.textContent = "Done";
      attr(div, "class", "sep");
      attr(button, "class", "close");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t0, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*close*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t0);
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$24(ctx) {
  let if_block_anchor;
  let if_block = (
    /*runtime*/
    ctx[0] && create_if_block$13(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*runtime*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$13(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1T($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  const { selected } = runtime;
  let proc;
  let amount = 0;
  selected.subscribe((v2) => {
    $$invalidate(1, proc = ProcessStack.getProcess(v2));
  });
  ProcessStack.processes.subscribe((v2) => {
    $$invalidate(2, amount = [...v2].filter(([_2, proc2]) => !proc2._disposed).length);
  });
  function info2() {
    spawnOverlay(getAppById("AppInfo"), runtime.process.pid, [proc.app.id]);
  }
  async function focus() {
    await sleep();
    focusedPid.set(proc.pid);
  }
  function close() {
    ProcessStack.kill(runtime.process.pid, true);
  }
  function killError(name, status2) {
    const caption = ProcessKillResultCaptions[status2];
    createErrorDialog(
      {
        title: `Couldn't kill ${name}!`,
        message: `An error occured while trying to end the process. ${caption}`,
        buttons: [
          {
            caption: "Okay",
            action() {
            },
            suggested: true
          }
        ],
        image: ErrorIcon,
        sound: "arcos.dialog.error"
      },
      runtime.process.pid,
      true
    );
  }
  async function kill() {
    const elevation = await GetUserElevation(ElevationKillProcess(proc), ProcessStack);
    if (!elevation)
      return;
    const name = proc.app ? proc.app.metadata.name : proc.name;
    createErrorDialog(
      {
        title: `Do you want to end ${name}?`,
        message: "By killing this process, it's window will close and you will lose any unsaved information. If you end a system process, it might make ArcOS unstable. Are you sure you want to continue?",
        image: WarningIcon,
        buttons: [
          {
            caption: "Cancel",
            action() {
            }
          },
          {
            caption: "End process",
            async action() {
              if (!proc)
                return;
              const status2 = await ProcessStack.kill(proc.pid, true);
              if (status2 !== "success")
                killError(name, status2);
              runtime.selected.set(null);
            },
            suggested: true
          }
        ],
        sound: "arcos.dialog.warning"
      },
      runtime.process.pid,
      true
    );
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, proc, amount, info2, focus, close, kill];
}
let Toolbar$1 = class Toolbar7 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1T, create_fragment$24, safe_not_equal, { runtime: 0 });
  }
};
function get_each_context$o(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2][0];
  child_ctx[3] = list2[i2][1];
  return child_ctx;
}
function create_if_block$12(ctx) {
  let div3;
  let div0;
  let img09;
  let img0_src_value;
  let span0;
  let t0;
  let t1;
  let div1;
  let img1;
  let img1_src_value;
  let t2;
  let span1;
  let t3;
  let t4;
  let div2;
  let t5;
  let t6;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*children*/
    ctx[5].size && create_if_block_1$i(ctx)
  );
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      img09 = element("img");
      span0 = element("span");
      t0 = text(
        /*name*/
        ctx[7]
      );
      t1 = space();
      div1 = element("div");
      img1 = element("img");
      t2 = space();
      span1 = element("span");
      t3 = text(
        /*pid*/
        ctx[2]
      );
      t4 = space();
      div2 = element("div");
      t5 = text(
        /*appId*/
        ctx[8]
      );
      t6 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      if (!src_url_equal(img09.src, img0_src_value = /*icon*/
      ctx[6]))
        attr(img09, "src", img0_src_value);
      attr(img09, "alt", "");
      attr(div0, "class", "segment name");
      if (!src_url_equal(img1.src, img1_src_value = FlagIcon))
        attr(img1, "src", img1_src_value);
      attr(img1, "alt", "");
      attr(img1, "class", "flag");
      attr(div1, "class", "segment pid");
      toggle_class(
        div1,
        "flagged",
        /*proc*/
        ctx[3].pid == /*$focusedPid*/
        ctx[9]
      );
      attr(div2, "class", "segment app-id");
      attr(div3, "class", "row");
      toggle_class(
        div3,
        "selected",
        /*selected*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, img09);
      append(div0, span0);
      append(span0, t0);
      append(div3, t1);
      append(div3, div1);
      append(div1, img1);
      append(div1, t2);
      append(div1, span1);
      append(span1, t3);
      append(div3, t4);
      append(div3, div2);
      append(div2, t5);
      insert(target, t6, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          div3,
          "click",
          /*select*/
          ctx[10]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*icon*/
      64 && !src_url_equal(img09.src, img0_src_value = /*icon*/
      ctx2[6])) {
        attr(img09, "src", img0_src_value);
      }
      if (!current || dirty & /*name*/
      128)
        set_data(
          t0,
          /*name*/
          ctx2[7]
        );
      if (!current || dirty & /*pid*/
      4)
        set_data(
          t3,
          /*pid*/
          ctx2[2]
        );
      if (!current || dirty & /*proc, $focusedPid*/
      520) {
        toggle_class(
          div1,
          "flagged",
          /*proc*/
          ctx2[3].pid == /*$focusedPid*/
          ctx2[9]
        );
      }
      if (!current || dirty & /*appId*/
      256)
        set_data(
          t5,
          /*appId*/
          ctx2[8]
        );
      if (!current || dirty & /*selected*/
      16) {
        toggle_class(
          div3,
          "selected",
          /*selected*/
          ctx2[4]
        );
      }
      if (
        /*children*/
        ctx2[5].size
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*children*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$i(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
        detach(t6);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$i(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like([.../*children*/
  ctx[5]]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$o(get_each_context$o(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "indent");
      attr(
        div,
        "data-pid",
        /*pid*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*children, handler, runtime*/
      35) {
        each_value = ensure_array_like([.../*children*/
        ctx2[5]]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$o(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$o(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*pid*/
      4) {
        attr(
          div,
          "data-pid",
          /*pid*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$o(ctx) {
  let row;
  let current;
  row = new Row_1({
    props: {
      pid: (
        /*pid*/
        ctx[2]
      ),
      proc: (
        /*proc*/
        ctx[3]
      ),
      handler: (
        /*handler*/
        ctx[0]
      ),
      runtime: (
        /*runtime*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const row_changes = {};
      if (dirty & /*children*/
      32)
        row_changes.pid = /*pid*/
        ctx2[2];
      if (dirty & /*children*/
      32)
        row_changes.proc = /*proc*/
        ctx2[3];
      if (dirty & /*handler*/
      1)
        row_changes.handler = /*handler*/
        ctx2[0];
      if (dirty & /*runtime*/
      2)
        row_changes.runtime = /*runtime*/
        ctx2[1];
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_fragment$23(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*proc*/
  ctx[3]._disposed && create_if_block$12(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*proc*/
      ctx2[3]._disposed) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*proc*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1S($$self, $$props, $$invalidate) {
  let $focusedPid;
  component_subscribe($$self, focusedPid, ($$value) => $$invalidate(9, $focusedPid = $$value));
  let { handler } = $$props;
  let { pid } = $$props;
  let { proc } = $$props;
  let { runtime } = $$props;
  const { selected: selectedStore } = runtime;
  const { mutator: app } = proc;
  let selected = false;
  let children2;
  let icon = DefaultIcon;
  let name = "";
  let appId = "";
  onMount(() => {
    if (proc.name.startsWith("svc#"))
      $$invalidate(6, icon = ComponentIcon);
    $$invalidate(7, name = proc.name);
    if (runtime.app) {
      app.subscribe((v2) => {
        if (!v2)
          return;
        $$invalidate(8, appId = v2.id);
        $$invalidate(7, name = v2.metadata.name);
        $$invalidate(6, icon = v2.metadata.icon);
      });
      return;
    }
  });
  selectedStore.subscribe((v2) => {
    $$invalidate(4, selected = v2 == pid);
  });
  handler.processes.subscribe(() => {
    $$invalidate(5, children2 = handler.getSubProcesses(pid));
  });
  function select() {
    runtime.selected.set(pid);
  }
  $$self.$$set = ($$props2) => {
    if ("handler" in $$props2)
      $$invalidate(0, handler = $$props2.handler);
    if ("pid" in $$props2)
      $$invalidate(2, pid = $$props2.pid);
    if ("proc" in $$props2)
      $$invalidate(3, proc = $$props2.proc);
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [
    handler,
    runtime,
    pid,
    proc,
    selected,
    children2,
    icon,
    name,
    appId,
    $focusedPid,
    select
  ];
}
class Row_1 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1S, create_fragment$23, safe_not_equal, { handler: 0, pid: 2, proc: 3, runtime: 1 });
  }
}
function get_each_context$n(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2][0];
  child_ctx[4] = list2[i2][1];
  return child_ctx;
}
function create_if_block$11(ctx) {
  let row;
  let current;
  row = new Row_1({
    props: {
      proc: (
        /*proc*/
        ctx[4]
      ),
      pid: (
        /*pid*/
        ctx[3]
      ),
      handler: (
        /*handler*/
        ctx[0]
      ),
      runtime: (
        /*runtime*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const row_changes = {};
      if (dirty & /*map*/
      4)
        row_changes.proc = /*proc*/
        ctx2[4];
      if (dirty & /*map*/
      4)
        row_changes.pid = /*pid*/
        ctx2[3];
      if (dirty & /*handler*/
      1)
        row_changes.handler = /*handler*/
        ctx2[0];
      if (dirty & /*runtime*/
      2)
        row_changes.runtime = /*runtime*/
        ctx2[1];
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_each_block$n(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*proc*/
  ctx[4].parentPid && create_if_block$11(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*proc*/
      ctx2[4].parentPid) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*map*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$11(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$22(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like([.../*map*/
  ctx[2]]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$n(get_each_context$n(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "process-tree");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*map, handler, runtime*/
      7) {
        each_value = ensure_array_like([.../*map*/
        ctx2[2]]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$n(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$n(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$1R($$self, $$props, $$invalidate) {
  let { handler = ProcessStack } = $$props;
  let { runtime } = $$props;
  let map;
  handler.processes.subscribe((v2) => {
    $$invalidate(2, map = null);
    $$invalidate(2, map = v2);
  });
  $$self.$$set = ($$props2) => {
    if ("handler" in $$props2)
      $$invalidate(0, handler = $$props2.handler);
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [handler, runtime, map];
}
class Tree extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1R, create_fragment$22, safe_not_equal, { handler: 0, runtime: 1 });
  }
}
function create_fragment$21(ctx) {
  let div;
  let header2;
  let t0;
  let tree;
  let t1;
  let toolbar;
  let current;
  header2 = new Header$6({});
  tree = new Tree({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  toolbar = new Toolbar$1({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(header2.$$.fragment);
      t0 = space();
      create_component(tree.$$.fragment);
      t1 = space();
      create_component(toolbar.$$.fragment);
      attr(div, "class", "top");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(header2, div, null);
      append(div, t0);
      mount_component(tree, div, null);
      insert(target, t1, anchor);
      mount_component(toolbar, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tree_changes = {};
      if (dirty & /*runtime*/
      1)
        tree_changes.runtime = /*runtime*/
        ctx2[0];
      tree.$set(tree_changes);
      const toolbar_changes = {};
      if (dirty & /*runtime*/
      1)
        toolbar_changes.runtime = /*runtime*/
        ctx2[0];
      toolbar.$set(toolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(tree.$$.fragment, local);
      transition_in(toolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(tree.$$.fragment, local);
      transition_out(toolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t1);
      }
      destroy_component(header2);
      destroy_component(tree);
      destroy_component(toolbar, detaching);
    }
  };
}
function instance$1Q($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime];
}
class Processes extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1Q, create_fragment$21, safe_not_equal, { runtime: 0 });
  }
}
function create_else_block$d(ctx) {
  let button;
  let t2;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text("Disable elevation");
      attr(button, "class", "disable");
      button.disabled = button_disabled_value = /*$UserDataStore*/
      ctx[0].sh.elevationDisabled;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*disableElevation*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore*/
      1 && button_disabled_value !== (button_disabled_value = /*$UserDataStore*/
      ctx2[0].sh.elevationDisabled)) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$10(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Enable elevation";
      attr(button, "class", "enable");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*enableElevation*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$9(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*$UserDataStore*/
      ctx2[0].sh.bypassElevation
    )
      return create_if_block$10;
    return create_else_block$d;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_default_slot_1$b(ctx) {
  let input;
  let input_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
      input.disabled = input_disabled_value = /*$UserDataStore*/
      ctx[0].sh.bypassElevation;
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.elevationDisabled;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore*/
      1 && input_disabled_value !== (input_disabled_value = /*$UserDataStore*/
      ctx2[0].sh.bypassElevation)) {
        input.disabled = input_disabled_value;
      }
      if (dirty & /*$UserDataStore*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.elevationDisabled;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$h(ctx) {
  let input;
  let input_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
      input.disabled = input_disabled_value = /*$UserDataStore*/
      ctx[0].sh.elevationDisabled || /*$UserDataStore*/
      ctx[0].sh.bypassElevation;
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserDataStore*/
      ctx[0].sh.securityNoPassword;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_1*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserDataStore*/
      1 && input_disabled_value !== (input_disabled_value = /*$UserDataStore*/
      ctx2[0].sh.elevationDisabled || /*$UserDataStore*/
      ctx2[0].sh.bypassElevation)) {
        input.disabled = input_disabled_value;
      }
      if (dirty & /*$UserDataStore*/
      1) {
        input.checked = /*$UserDataStore*/
        ctx2[0].sh.securityNoPassword;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$20(ctx) {
  let div;
  let h2;
  let span;
  let t0;
  let t1_value = (
    /*$UserDataStore*/
    ctx[0].sh.bypassElevation ? "Inadvisable configuration" : (
      /*$UserDataStore*/
      ctx[0].sh.elevationDisabled ? "In lockdown" : (
        /*$UserDataStore*/
        ctx[0].sh.securityNoPassword ? "Mildly insecure" : "Recommended configuration"
      )
    )
  );
  let t1;
  let t2;
  let img;
  let img_src_value;
  let t3;
  let p2;
  let t7;
  let settingsoption0;
  let t8;
  let settingsoption1;
  let t9;
  let settingsoption2;
  let current;
  settingsoption0 = new SettingsOption({
    props: {
      title: (
        /*$UserDataStore*/
        (ctx[0].sh.bypassElevation ? "Re-enable" : "Disable") + " elevation"
      ),
      context: (
        /*$UserDataStore*/
        ctx[0].sh.bypassElevation ? "Elevation is currently DISABLED. This allows any application from performing elevated operations without asking you for permission first. <b>We recommend that you re-enable elevation</b>." : "Disabling elevation allows all elevated operations from running without your permission. <b>We recommend that you leave elevation ENABLED.</b>"
      ),
      className: "bypass " + /*$UserDataStore*/
      ctx[0].sh.bypassElevation,
      $$slots: { default: [create_default_slot_2$9] },
      $$scope: { ctx }
    }
  });
  settingsoption1 = new SettingsOption({
    props: {
      title: "Lock down elevation",
      context: "Completely prevent any operations that require elevation",
      disabled: (
        /*$UserDataStore*/
        ctx[0].sh.bypassElevation
      ),
      $$slots: { default: [create_default_slot_1$b] },
      $$scope: { ctx }
    }
  });
  settingsoption2 = new SettingsOption({
    props: {
      title: "Don't ask for password",
      context: "Don't require a password to approve an elevation request",
      disabled: (
        /*$UserDataStore*/
        ctx[0].sh.elevationDisabled || /*$UserDataStore*/
        ctx[0].sh.bypassElevation
      ),
      $$slots: { default: [create_default_slot$h] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      h2 = element("h2");
      span = element("span");
      t0 = text("Security - ");
      t1 = text(t1_value);
      t2 = space();
      img = element("img");
      t3 = space();
      p2 = element("p");
      p2.innerHTML = `The ArcOS Secure Context is put in place to protect you from performing unwanted operations. It
    asks for<br/>
    your confirmation when performing elevated operations, like managing services, and stopping processes.<br/><br/>
    We recommend leaving it on it&#39;s default settings for the best security.`;
      t7 = space();
      create_component(settingsoption0.$$.fragment);
      t8 = space();
      create_component(settingsoption1.$$.fragment);
      t9 = space();
      create_component(settingsoption2.$$.fragment);
      if (!src_url_equal(img.src, img_src_value = /*$UserDataStore*/
      ctx[0].sh.bypassElevation ? SecurityHighIcon : (
        /*$UserDataStore*/
        ctx[0].sh.elevationDisabled ? LockIcon : (
          /*$UserDataStore*/
          ctx[0].sh.securityNoPassword ? SecurityMediumIcon : SecurityLowIcon
        )
      )))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(h2, "class", "title");
      toggle_class(
        h2,
        "bypass",
        /*$UserDataStore*/
        ctx[0].sh.bypassElevation
      );
      toggle_class(
        h2,
        "nopass",
        /*$UserDataStore*/
        ctx[0].sh.securityNoPassword
      );
      toggle_class(
        h2,
        "lockdown",
        /*$UserDataStore*/
        ctx[0].sh.elevationDisabled
      );
      attr(div, "class", "top security-settings");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h2);
      append(h2, span);
      append(span, t0);
      append(span, t1);
      append(h2, t2);
      append(h2, img);
      append(div, t3);
      append(div, p2);
      append(div, t7);
      mount_component(settingsoption0, div, null);
      append(div, t8);
      mount_component(settingsoption1, div, null);
      append(div, t9);
      mount_component(settingsoption2, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*$UserDataStore*/
      1) && t1_value !== (t1_value = /*$UserDataStore*/
      ctx2[0].sh.bypassElevation ? "Inadvisable configuration" : (
        /*$UserDataStore*/
        ctx2[0].sh.elevationDisabled ? "In lockdown" : (
          /*$UserDataStore*/
          ctx2[0].sh.securityNoPassword ? "Mildly insecure" : "Recommended configuration"
        )
      )))
        set_data(t1, t1_value);
      if (!current || dirty & /*$UserDataStore*/
      1 && !src_url_equal(img.src, img_src_value = /*$UserDataStore*/
      ctx2[0].sh.bypassElevation ? SecurityHighIcon : (
        /*$UserDataStore*/
        ctx2[0].sh.elevationDisabled ? LockIcon : (
          /*$UserDataStore*/
          ctx2[0].sh.securityNoPassword ? SecurityMediumIcon : SecurityLowIcon
        )
      ))) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*$UserDataStore*/
      1) {
        toggle_class(
          h2,
          "bypass",
          /*$UserDataStore*/
          ctx2[0].sh.bypassElevation
        );
      }
      if (!current || dirty & /*$UserDataStore*/
      1) {
        toggle_class(
          h2,
          "nopass",
          /*$UserDataStore*/
          ctx2[0].sh.securityNoPassword
        );
      }
      if (!current || dirty & /*$UserDataStore*/
      1) {
        toggle_class(
          h2,
          "lockdown",
          /*$UserDataStore*/
          ctx2[0].sh.elevationDisabled
        );
      }
      const settingsoption0_changes = {};
      if (dirty & /*$UserDataStore*/
      1)
        settingsoption0_changes.title = /*$UserDataStore*/
        (ctx2[0].sh.bypassElevation ? "Re-enable" : "Disable") + " elevation";
      if (dirty & /*$UserDataStore*/
      1)
        settingsoption0_changes.context = /*$UserDataStore*/
        ctx2[0].sh.bypassElevation ? "Elevation is currently DISABLED. This allows any application from performing elevated operations without asking you for permission first. <b>We recommend that you re-enable elevation</b>." : "Disabling elevation allows all elevated operations from running without your permission. <b>We recommend that you leave elevation ENABLED.</b>";
      if (dirty & /*$UserDataStore*/
      1)
        settingsoption0_changes.className = "bypass " + /*$UserDataStore*/
        ctx2[0].sh.bypassElevation;
      if (dirty & /*$$scope, $UserDataStore*/
      33) {
        settingsoption0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption0.$set(settingsoption0_changes);
      const settingsoption1_changes = {};
      if (dirty & /*$UserDataStore*/
      1)
        settingsoption1_changes.disabled = /*$UserDataStore*/
        ctx2[0].sh.bypassElevation;
      if (dirty & /*$$scope, $UserDataStore*/
      33) {
        settingsoption1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption1.$set(settingsoption1_changes);
      const settingsoption2_changes = {};
      if (dirty & /*$UserDataStore*/
      1)
        settingsoption2_changes.disabled = /*$UserDataStore*/
        ctx2[0].sh.elevationDisabled || /*$UserDataStore*/
        ctx2[0].sh.bypassElevation;
      if (dirty & /*$$scope, $UserDataStore*/
      33) {
        settingsoption2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingsoption2.$set(settingsoption2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingsoption0.$$.fragment, local);
      transition_in(settingsoption1.$$.fragment, local);
      transition_in(settingsoption2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingsoption0.$$.fragment, local);
      transition_out(settingsoption1.$$.fragment, local);
      transition_out(settingsoption2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(settingsoption0);
      destroy_component(settingsoption1);
      destroy_component(settingsoption2);
    }
  };
}
function instance$1P($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(0, $UserDataStore = $$value));
  async function disableElevation() {
    const permitted = await GetUserElevation(ElevationEnableBypass(), ProcessStack);
    if (permitted) {
      set_store_value(UserDataStore, $UserDataStore.sh.bypassElevation = true, $UserDataStore);
    }
  }
  function enableElevation() {
    set_store_value(UserDataStore, $UserDataStore.sh.bypassElevation = false, $UserDataStore);
  }
  function input_change_handler() {
    $UserDataStore.sh.elevationDisabled = this.checked;
    UserDataStore.set($UserDataStore);
  }
  function input_change_handler_1() {
    $UserDataStore.sh.securityNoPassword = this.checked;
    UserDataStore.set($UserDataStore);
  }
  return [
    $UserDataStore,
    disableElevation,
    enableElevation,
    input_change_handler,
    input_change_handler_1
  ];
}
class Security extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1P, create_fragment$20, safe_not_equal, {});
  }
}
function create_fragment$1$(ctx) {
  let div4;
  return {
    c() {
      div4 = element("div");
      div4.innerHTML = `<div class="segment name">Service Name</div> <div class="segment description">Description</div> <div class="segment pid">PID</div> <div class="segment status">Status</div>`;
      attr(div4, "class", "row header");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
    }
  };
}
let Header$5 = class Header8 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$1$, safe_not_equal, {});
  }
};
function create_if_block$$(ctx) {
  let div4;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1_value = (
    /*service*/
    ctx[0].name + ""
  );
  let t1;
  let t2;
  let div1;
  let t3_value = (
    /*service*/
    ctx[0].description + ""
  );
  let t3;
  let t4;
  let div2;
  let t5_value = (
    /*service*/
    (ctx[0].pid || "-") + ""
  );
  let t5;
  let t6;
  let div3;
  let t7_value = (
    /*service*/
    ctx[0].pid ? "Running" : "Stopped"
  );
  let t7;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      div1 = element("div");
      t3 = text(t3_value);
      t4 = space();
      div2 = element("div");
      t5 = text(t5_value);
      t6 = space();
      div3 = element("div");
      t7 = text(t7_value);
      if (!src_url_equal(img.src, img_src_value = ComponentIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(div0, "class", "segment name");
      attr(div1, "class", "segment description");
      attr(div2, "class", "segment pid");
      attr(div3, "class", "segment status");
      attr(div4, "class", "row service");
      toggle_class(
        div4,
        "selected",
        /*selected*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div0, img);
      append(div0, t0);
      append(div0, span);
      append(span, t1);
      append(div4, t2);
      append(div4, div1);
      append(div1, t3);
      append(div4, t4);
      append(div4, div2);
      append(div2, t5);
      append(div4, t6);
      append(div4, div3);
      append(div3, t7);
      if (!mounted) {
        dispose = listen(
          div4,
          "click",
          /*select*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*service*/
      1 && t1_value !== (t1_value = /*service*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*service*/
      1 && t3_value !== (t3_value = /*service*/
      ctx2[0].description + ""))
        set_data(t3, t3_value);
      if (dirty & /*service*/
      1 && t5_value !== (t5_value = /*service*/
      (ctx2[0].pid || "-") + ""))
        set_data(t5, t5_value);
      if (dirty & /*service*/
      1 && t7_value !== (t7_value = /*service*/
      ctx2[0].pid ? "Running" : "Stopped"))
        set_data(t7, t7_value);
      if (dirty & /*selected*/
      2) {
        toggle_class(
          div4,
          "selected",
          /*selected*/
          ctx2[1]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1_(ctx) {
  let if_block_anchor;
  let if_block = (
    /*service*/
    ctx[0] && create_if_block$$(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*service*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$$(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1O($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { id } = $$props;
  const { selectedService } = runtime;
  let service;
  let selected = false;
  selectedService.subscribe((v2) => {
    $$invalidate(1, selected = v2 == id);
    update2();
  });
  GlobalDispatch.subscribe("services-flush", update2);
  onMount(update2);
  function update2() {
    $$invalidate(0, service = getService(id));
  }
  function select() {
    runtime.selectedService.set(id);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
    if ("id" in $$props2)
      $$invalidate(4, id = $$props2.id);
  };
  return [service, selected, select, runtime, id];
}
class Row extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1O, create_fragment$1_, safe_not_equal, { runtime: 3, id: 4 });
  }
}
function get_each_context$m(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2][0];
  child_ctx[3] = list2[i2][1];
  return child_ctx;
}
function create_else_block$c(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<img src="${ErrorIcon}" alt=""/> <p>Could not contact Service Manager!</p>`;
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block$_(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like([.../*services*/
  ctx[1]]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$m(get_each_context$m(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "process-tree");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*runtime, services*/
      3) {
        each_value = ensure_array_like([.../*services*/
        ctx2[1]]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$m(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$m(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$m(ctx) {
  let row;
  let current;
  row = new Row({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      id: (
        /*id*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const row_changes = {};
      if (dirty & /*runtime*/
      1)
        row_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*services*/
      2)
        row_changes.id = /*id*/
        ctx2[2];
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_fragment$1Z(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$_, create_else_block$c];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*services*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$1N($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let services;
  ProcessStack.processes.subscribe(() => {
    $$invalidate(1, services = getAllServices());
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, services];
}
let List$1 = class List3 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1N, create_fragment$1Z, safe_not_equal, { runtime: 0 });
  }
};
function create_fragment$1Y(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "html-spinner");
      set_style(
        div,
        "--size",
        /*height*/
        ctx[0] + "px"
      );
      toggle_class(div, "going", !/*stopped*/
      ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*height*/
      1) {
        set_style(
          div,
          "--size",
          /*height*/
          ctx2[0] + "px"
        );
      }
      if (dirty & /*stopped*/
      2) {
        toggle_class(div, "going", !/*stopped*/
        ctx2[1]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$1M($$self, $$props, $$invalidate) {
  let { height } = $$props;
  let { stopped = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("height" in $$props2)
      $$invalidate(0, height = $$props2.height);
    if ("stopped" in $$props2)
      $$invalidate(1, stopped = $$props2.stopped);
  };
  return [height, stopped];
}
class HtmlSpinner extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1M, create_fragment$1Y, safe_not_equal, { height: 0, stopped: 1 });
  }
}
async function stopServiceNotified(id) {
  const status2 = await stopService(id);
  if (status2 !== "success") {
    const caption = ServiceChangeResultCaptions[status2];
    sendNotification({
      title: "Service Stop Failed",
      message: `ArcOS failed to stop ${id}: ${caption}<br/><br/>Error Code: ${status2}`,
      image: WarningIcon
    });
  }
  return status2;
}
async function startServiceNotified(id) {
  const status2 = await startService(id);
  if (status2 !== "success") {
    const caption = ServiceChangeResultCaptions[status2];
    sendNotification({
      title: "Service Start Failed",
      message: `ArcOS failed to start ${id}: ${caption}<br/><br/>Error Code: ${status2}`,
      image: WarningIcon
    });
  }
  return status2;
}
function create_if_block$Z(ctx) {
  let div3;
  let div0;
  let p2;
  let t0;
  let t1;
  let t2;
  let div2;
  let button0;
  let t3;
  let button0_disabled_value;
  let t4;
  let button1;
  let t5;
  let button1_disabled_value;
  let t6;
  let div1;
  let t7;
  let button2;
  let current_block_type_index;
  let if_block0;
  let button2_disabled_value;
  let t8;
  let button3;
  let current_block_type_index_1;
  let if_block1;
  let button3_disabled_value;
  let t9;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_3$1, create_else_block_1$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*restarting*/
    ctx2[5])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const if_block_creators_1 = [create_if_block_2$6, create_else_block$b];
  const if_blocks_1 = [];
  function select_block_type_1(ctx2, dirty) {
    if (!/*flipping*/
    ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index_1 = select_block_type_1(ctx);
  if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  let if_block2 = (
    /*runtime*/
    ctx[0].app && /*runtime*/
    ctx[0].app.isOverlay && create_if_block_1$h(ctx)
  );
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      p2 = element("p");
      t0 = text(
        /*amount*/
        ctx[1]
      );
      t1 = text(" total services");
      t2 = space();
      div2 = element("div");
      button0 = element("button");
      t3 = text("Service Info");
      t4 = space();
      button1 = element("button");
      t5 = text("Go to process");
      t6 = space();
      div1 = element("div");
      t7 = space();
      button2 = element("button");
      if_block0.c();
      t8 = space();
      button3 = element("button");
      if_block1.c();
      t9 = space();
      if (if_block2)
        if_block2.c();
      attr(p2, "class", "running");
      attr(div0, "class", "left");
      button0.disabled = button0_disabled_value = !/*selected*/
      ctx[2];
      button1.disabled = button1_disabled_value = !/*selected*/
      ctx[2];
      attr(div1, "class", "sep");
      attr(button2, "class", "restart");
      button2.disabled = button2_disabled_value = !/*selected*/
      ctx[2] || /*restarting*/
      ctx[5];
      attr(button3, "class", "flip");
      button3.disabled = button3_disabled_value = !/*selected*/
      ctx[2] || /*flipping*/
      ctx[4];
      toggle_class(
        button3,
        "running",
        /*data*/
        ctx[3] && /*data*/
        ctx[3].pid
      );
      attr(div2, "class", "right");
      attr(div3, "class", "toolbar");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, p2);
      append(p2, t0);
      append(p2, t1);
      append(div3, t2);
      append(div3, div2);
      append(div2, button0);
      append(button0, t3);
      append(div2, t4);
      append(div2, button1);
      append(button1, t5);
      append(div2, t6);
      append(div2, div1);
      append(div2, t7);
      append(div2, button2);
      if_blocks[current_block_type_index].m(button2, null);
      append(div2, t8);
      append(div2, button3);
      if_blocks_1[current_block_type_index_1].m(button3, null);
      append(div2, t9);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*openServiceInfo*/
            ctx[10]
          ),
          listen(
            button1,
            "click",
            /*gotoProcess*/
            ctx[9]
          ),
          listen(
            button2,
            "click",
            /*restart*/
            ctx[8]
          ),
          listen(
            button3,
            "click",
            /*flip*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*amount*/
      2)
        set_data(
          t0,
          /*amount*/
          ctx2[1]
        );
      if (!current || dirty & /*selected*/
      4 && button0_disabled_value !== (button0_disabled_value = !/*selected*/
      ctx2[2])) {
        button0.disabled = button0_disabled_value;
      }
      if (!current || dirty & /*selected*/
      4 && button1_disabled_value !== (button1_disabled_value = !/*selected*/
      ctx2[2])) {
        button1.disabled = button1_disabled_value;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        }
        transition_in(if_block0, 1);
        if_block0.m(button2, null);
      }
      if (!current || dirty & /*selected, restarting*/
      36 && button2_disabled_value !== (button2_disabled_value = !/*selected*/
      ctx2[2] || /*restarting*/
      ctx2[5])) {
        button2.disabled = button2_disabled_value;
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx2);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block1 = if_blocks_1[current_block_type_index_1];
        if (!if_block1) {
          if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(button3, null);
      }
      if (!current || dirty & /*selected, flipping*/
      20 && button3_disabled_value !== (button3_disabled_value = !/*selected*/
      ctx2[2] || /*flipping*/
      ctx2[4])) {
        button3.disabled = button3_disabled_value;
      }
      if (!current || dirty & /*data*/
      8) {
        toggle_class(
          button3,
          "running",
          /*data*/
          ctx2[3] && /*data*/
          ctx2[3].pid
        );
      }
      if (
        /*runtime*/
        ctx2[0].app && /*runtime*/
        ctx2[0].app.isOverlay
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1$h(ctx2);
          if_block2.c();
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if_blocks[current_block_type_index].d();
      if_blocks_1[current_block_type_index_1].d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_1$1(ctx) {
  let htmlspinner;
  let current;
  htmlspinner = new HtmlSpinner({ props: { height: 16 } });
  return {
    c() {
      create_component(htmlspinner.$$.fragment);
    },
    m(target, anchor) {
      mount_component(htmlspinner, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(htmlspinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(htmlspinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(htmlspinner, detaching);
    }
  };
}
function create_if_block_3$1(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Restart");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_else_block$b(ctx) {
  let htmlspinner;
  let current;
  htmlspinner = new HtmlSpinner({ props: { height: 16 } });
  return {
    c() {
      create_component(htmlspinner.$$.fragment);
    },
    m(target, anchor) {
      mount_component(htmlspinner, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(htmlspinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(htmlspinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(htmlspinner, detaching);
    }
  };
}
function create_if_block_2$6(ctx) {
  let t_value = (
    /*data*/
    ctx[3] && /*data*/
    ctx[3].pid ? "Stop" : "Start"
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      8 && t_value !== (t_value = /*data*/
      ctx2[3] && /*data*/
      ctx2[3].pid ? "Stop" : "Start"))
        set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$h(ctx) {
  let div;
  let t0;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t0 = space();
      button = element("button");
      button.textContent = "Done";
      attr(div, "class", "sep");
      attr(button, "class", "close");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t0, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*close*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t0);
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1X(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*runtime*/
    ctx[0] && create_if_block$Z(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*runtime*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*runtime*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$Z(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1L($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { current } = $$props;
  let amount = 0;
  let selected;
  let data2;
  let flipping = false;
  let restarting = false;
  function update2() {
    $$invalidate(3, data2 = getService(selected));
  }
  const { selectedService } = runtime;
  selectedService.subscribe((v2) => {
    $$invalidate(2, selected = v2);
    update2();
  });
  GlobalDispatch.subscribe("services-flush", update2);
  ProcessStack.processes.subscribe(() => {
    const services = getAllServices();
    $$invalidate(1, amount = services ? services.size : 0);
  });
  function close() {
    ProcessStack.kill(runtime.process.pid, true);
  }
  async function flip() {
    $$invalidate(4, flipping = true);
    if (data2.pid)
      await stopServiceNotified(selected);
    else
      await startServiceNotified(selected);
    $$invalidate(4, flipping = false);
  }
  async function restart2() {
    $$invalidate(5, restarting = true);
    await restartService(selected);
    $$invalidate(5, restarting = false);
  }
  function gotoProcess() {
    if (!data2 || !data2.pid)
      return;
    $$invalidate(11, current = "Processes");
    runtime.selected.set(data2.pid);
  }
  function openServiceInfo() {
    spawnOverlay(getAppById("ServiceInfo"), runtime.pid, [selected]);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("current" in $$props2)
      $$invalidate(11, current = $$props2.current);
  };
  return [
    runtime,
    amount,
    selected,
    data2,
    flipping,
    restarting,
    close,
    flip,
    restart2,
    gotoProcess,
    openServiceInfo,
    current
  ];
}
class Toolbar8 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1L, create_fragment$1X, safe_not_equal, { runtime: 0, current: 11 });
  }
}
function create_fragment$1W(ctx) {
  let div;
  let header2;
  let t0;
  let list2;
  let t1;
  let toolbar;
  let updating_current;
  let current;
  header2 = new Header$5({});
  list2 = new List$1({ props: { runtime: (
    /*runtime*/
    ctx[1]
  ) } });
  function toolbar_current_binding(value) {
    ctx[2](value);
  }
  let toolbar_props = { runtime: (
    /*runtime*/
    ctx[1]
  ) };
  if (
    /*current*/
    ctx[0] !== void 0
  ) {
    toolbar_props.current = /*current*/
    ctx[0];
  }
  toolbar = new Toolbar8({ props: toolbar_props });
  binding_callbacks.push(() => bind$1(toolbar, "current", toolbar_current_binding));
  return {
    c() {
      div = element("div");
      create_component(header2.$$.fragment);
      t0 = space();
      create_component(list2.$$.fragment);
      t1 = space();
      create_component(toolbar.$$.fragment);
      attr(div, "class", "top");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(header2, div, null);
      append(div, t0);
      mount_component(list2, div, null);
      insert(target, t1, anchor);
      mount_component(toolbar, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const list_changes = {};
      if (dirty & /*runtime*/
      2)
        list_changes.runtime = /*runtime*/
        ctx2[1];
      list2.$set(list_changes);
      const toolbar_changes = {};
      if (dirty & /*runtime*/
      2)
        toolbar_changes.runtime = /*runtime*/
        ctx2[1];
      if (!updating_current && dirty & /*current*/
      1) {
        updating_current = true;
        toolbar_changes.current = /*current*/
        ctx2[0];
        add_flush_callback(() => updating_current = false);
      }
      toolbar.$set(toolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(list2.$$.fragment, local);
      transition_in(toolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(list2.$$.fragment, local);
      transition_out(toolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t1);
      }
      destroy_component(header2);
      destroy_component(list2);
      destroy_component(toolbar, detaching);
    }
  };
}
function instance$1K($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { current } = $$props;
  function toolbar_current_binding(value) {
    current = value;
    $$invalidate(0, current);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
    if ("current" in $$props2)
      $$invalidate(0, current = $$props2.current);
  };
  return [current, runtime, toolbar_current_binding];
}
class Services extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1K, create_fragment$1W, safe_not_equal, { runtime: 1, current: 0 });
  }
}
function create_else_block$a(ctx) {
  let t0;
  let t1_value = (
    /*users*/
    ctx[1].length + ""
  );
  let t1;
  let t2;
  let t3_value = (
    /*$ConnectedServer*/
    ctx[2].host + ""
  );
  let t3;
  let t4;
  return {
    c() {
      t0 = text("Showing ");
      t1 = text(t1_value);
      t2 = text(" users on ");
      t3 = text(t3_value);
      t4 = text(".");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, t4, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*users*/
      2 && t1_value !== (t1_value = /*users*/
      ctx2[1].length + ""))
        set_data(t1, t1_value);
      if (dirty & /*$ConnectedServer*/
      4 && t3_value !== (t3_value = /*$ConnectedServer*/
      ctx2[2].host + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
      }
    }
  };
}
function create_if_block$Y(ctx) {
  let t0;
  let t1_value = (
    /*filtered*/
    ctx[0].length + ""
  );
  let t1;
  let t2;
  let t3_value = (
    /*users*/
    ctx[1].length + ""
  );
  let t3;
  let t4;
  let t5_value = (
    /*$ConnectedServer*/
    ctx[2].host + ""
  );
  let t5;
  let t6;
  return {
    c() {
      t0 = text("Showing ");
      t1 = text(t1_value);
      t2 = text(" of ");
      t3 = text(t3_value);
      t4 = text(" users on ");
      t5 = text(t5_value);
      t6 = text(".");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, t4, anchor);
      insert(target, t5, anchor);
      insert(target, t6, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*filtered*/
      1 && t1_value !== (t1_value = /*filtered*/
      ctx2[0].length + ""))
        set_data(t1, t1_value);
      if (dirty & /*users*/
      2 && t3_value !== (t3_value = /*users*/
      ctx2[1].length + ""))
        set_data(t3, t3_value);
      if (dirty & /*$ConnectedServer*/
      4 && t5_value !== (t5_value = /*$ConnectedServer*/
      ctx2[2].host + ""))
        set_data(t5, t5_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
      }
    }
  };
}
function create_fragment$1V(ctx) {
  let div;
  let p2;
  function select_block_type(ctx2, dirty) {
    if (
      /*filtered*/
      ctx2[0].length && /*users*/
      ctx2[1].length != /*filtered*/
      ctx2[0].length
    )
      return create_if_block$Y;
    return create_else_block$a;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      p2 = element("p");
      if_block.c();
      attr(p2, "class", "user-count");
      attr(div, "class", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p2);
      if_block.m(p2, null);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(p2, null);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_block.d();
    }
  };
}
function instance$1J($$self, $$props, $$invalidate) {
  let $ConnectedServer;
  component_subscribe($$self, ConnectedServer, ($$value) => $$invalidate(2, $ConnectedServer = $$value));
  let users = [];
  let { filtered = [] } = $$props;
  onMount(async () => {
    $$invalidate(1, users = await getUserList());
    $$invalidate(0, filtered = users);
  });
  $$self.$$set = ($$props2) => {
    if ("filtered" in $$props2)
      $$invalidate(0, filtered = $$props2.filtered);
  };
  return [filtered, users, $ConnectedServer];
}
let Header$4 = class Header9 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1J, create_fragment$1V, safe_not_equal, { filtered: 0 });
  }
};
function create_fragment$1U(ctx) {
  let div;
  let profilepicture;
  let t0;
  let span;
  let t1_value = (
    /*user*/
    ctx[0].username + ""
  );
  let t1;
  let span_title_value;
  let current;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*url*/
      ctx[1]
    ), height: 24 }
  });
  return {
    c() {
      div = element("div");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      attr(span, "class", "username");
      attr(span, "title", span_title_value = `${/*user*/
      ctx[0].username} (${/*user*/
      ctx[0].acc.v6 ? "v6 user" : "normal user"})`);
      attr(div, "class", "user");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(profilepicture, div, null);
      append(div, t0);
      append(div, span);
      append(span, t1);
      current = true;
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*url*/
      2)
        profilepicture_changes.src = /*url*/
        ctx2[1];
      profilepicture.$set(profilepicture_changes);
      if ((!current || dirty & /*user*/
      1) && t1_value !== (t1_value = /*user*/
      ctx2[0].username + ""))
        set_data(t1, t1_value);
      if (!current || dirty & /*user*/
      1 && span_title_value !== (span_title_value = `${/*user*/
      ctx2[0].username} (${/*user*/
      ctx2[0].acc.v6 ? "v6 user" : "normal user"})`)) {
        attr(span, "title", span_title_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(profilepicture);
    }
  };
}
function instance$1I($$self, $$props, $$invalidate) {
  let { user } = $$props;
  let url = "";
  onMount(() => {
    $$invalidate(1, url = getProfilePicture(user.acc.profilePicture));
  });
  $$self.$$set = ($$props2) => {
    if ("user" in $$props2)
      $$invalidate(0, user = $$props2.user);
  };
  return [user, url];
}
class User2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1I, create_fragment$1U, safe_not_equal, { user: 0 });
  }
}
function get_each_context$l(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2];
  return child_ctx;
}
function create_each_block$l(ctx) {
  let user_1;
  let current;
  user_1 = new User2({ props: { user: (
    /*user*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(user_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(user_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const user_1_changes = {};
      if (dirty & /*filtered*/
      1)
        user_1_changes.user = /*user*/
        ctx2[1];
      user_1.$set(user_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(user_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(user_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(user_1, detaching);
    }
  };
}
function create_fragment$1T(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*filtered*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$l(get_each_context$l(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "user-list");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*filtered*/
      1) {
        each_value = ensure_array_like(
          /*filtered*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$l(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$l(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$1H($$self, $$props, $$invalidate) {
  let { filtered } = $$props;
  $$self.$$set = ($$props2) => {
    if ("filtered" in $$props2)
      $$invalidate(0, filtered = $$props2.filtered);
  };
  return [filtered];
}
class List4 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1H, create_fragment$1T, safe_not_equal, { filtered: 0 });
  }
}
function create_fragment$1S(ctx) {
  let div0;
  let header2;
  let updating_filtered;
  let t0;
  let list2;
  let t1;
  let div1;
  let current;
  function header_filtered_binding(value) {
    ctx[1](value);
  }
  let header_props = {};
  if (
    /*filtered*/
    ctx[0] !== void 0
  ) {
    header_props.filtered = /*filtered*/
    ctx[0];
  }
  header2 = new Header$4({ props: header_props });
  binding_callbacks.push(() => bind$1(header2, "filtered", header_filtered_binding));
  list2 = new List4({ props: { filtered: (
    /*filtered*/
    ctx[0]
  ) } });
  return {
    c() {
      div0 = element("div");
      create_component(header2.$$.fragment);
      t0 = space();
      create_component(list2.$$.fragment);
      t1 = space();
      div1 = element("div");
      attr(div0, "class", "top users");
      attr(div1, "class", "toolbar");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      mount_component(header2, div0, null);
      append(div0, t0);
      mount_component(list2, div0, null);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const header_changes = {};
      if (!updating_filtered && dirty & /*filtered*/
      1) {
        updating_filtered = true;
        header_changes.filtered = /*filtered*/
        ctx2[0];
        add_flush_callback(() => updating_filtered = false);
      }
      header2.$set(header_changes);
      const list_changes = {};
      if (dirty & /*filtered*/
      1)
        list_changes.filtered = /*filtered*/
        ctx2[0];
      list2.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(list2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(list2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t1);
        detach(div1);
      }
      destroy_component(header2);
      destroy_component(list2);
    }
  };
}
function instance$1G($$self, $$props, $$invalidate) {
  let filtered = [];
  function header_filtered_binding(value) {
    filtered = value;
    $$invalidate(0, filtered);
  }
  return [filtered, header_filtered_binding];
}
class Users extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1G, create_fragment$1S, safe_not_equal, {});
  }
}
const main$a = "";
function create_default_slot_3$5(ctx) {
  let processes;
  let current;
  processes = new Processes({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(processes.$$.fragment);
    },
    m(target, anchor) {
      mount_component(processes, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const processes_changes = {};
      if (dirty & /*runtime*/
      1)
        processes_changes.runtime = /*runtime*/
        ctx2[0];
      processes.$set(processes_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(processes.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(processes.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(processes, detaching);
    }
  };
}
function create_default_slot_2$8(ctx) {
  let services;
  let updating_current;
  let current;
  function services_current_binding(value) {
    ctx[3](value);
  }
  let services_props = { runtime: (
    /*runtime*/
    ctx[0]
  ) };
  if (
    /*current*/
    ctx[1] !== void 0
  ) {
    services_props.current = /*current*/
    ctx[1];
  }
  services = new Services({ props: services_props });
  binding_callbacks.push(() => bind$1(services, "current", services_current_binding));
  return {
    c() {
      create_component(services.$$.fragment);
    },
    m(target, anchor) {
      mount_component(services, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const services_changes = {};
      if (dirty & /*runtime*/
      1)
        services_changes.runtime = /*runtime*/
        ctx2[0];
      if (!updating_current && dirty & /*current*/
      2) {
        updating_current = true;
        services_changes.current = /*current*/
        ctx2[1];
        add_flush_callback(() => updating_current = false);
      }
      services.$set(services_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(services.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(services.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(services, detaching);
    }
  };
}
function create_default_slot_1$a(ctx) {
  let users;
  let current;
  users = new Users({});
  return {
    c() {
      create_component(users.$$.fragment);
    },
    m(target, anchor) {
      mount_component(users, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(users.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(users.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(users, detaching);
    }
  };
}
function create_default_slot$g(ctx) {
  let security;
  let current;
  security = new Security({});
  return {
    c() {
      create_component(security.$$.fragment);
    },
    m(target, anchor) {
      mount_component(security, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(security.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(security.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(security, detaching);
    }
  };
}
function create_renderer_slot(ctx) {
  let div;
  let tab0;
  let t0;
  let tab1;
  let t1;
  let tab2;
  let t2;
  let tab3;
  let current;
  tab0 = new Tab({
    props: {
      current: (
        /*current*/
        ctx[1]
      ),
      selector: "Processes",
      $$slots: { default: [create_default_slot_3$5] },
      $$scope: { ctx }
    }
  });
  tab1 = new Tab({
    props: {
      current: (
        /*current*/
        ctx[1]
      ),
      selector: "Services",
      $$slots: { default: [create_default_slot_2$8] },
      $$scope: { ctx }
    }
  });
  tab2 = new Tab({
    props: {
      current: (
        /*current*/
        ctx[1]
      ),
      selector: "Users",
      $$slots: { default: [create_default_slot_1$a] },
      $$scope: { ctx }
    }
  });
  tab3 = new Tab({
    props: {
      current: (
        /*current*/
        ctx[1]
      ),
      selector: "Security",
      $$slots: { default: [create_default_slot$g] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tab0.$$.fragment);
      t0 = space();
      create_component(tab1.$$.fragment);
      t1 = space();
      create_component(tab2.$$.fragment);
      t2 = space();
      create_component(tab3.$$.fragment);
      attr(div, "class", "renderer");
      attr(div, "slot", "renderer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(tab0, div, null);
      append(div, t0);
      mount_component(tab1, div, null);
      append(div, t1);
      mount_component(tab2, div, null);
      append(div, t2);
      mount_component(tab3, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const tab0_changes = {};
      if (dirty & /*current*/
      2)
        tab0_changes.current = /*current*/
        ctx2[1];
      if (dirty & /*$$scope, runtime*/
      33) {
        tab0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab0.$set(tab0_changes);
      const tab1_changes = {};
      if (dirty & /*current*/
      2)
        tab1_changes.current = /*current*/
        ctx2[1];
      if (dirty & /*$$scope, runtime, current*/
      35) {
        tab1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab1.$set(tab1_changes);
      const tab2_changes = {};
      if (dirty & /*current*/
      2)
        tab2_changes.current = /*current*/
        ctx2[1];
      if (dirty & /*$$scope*/
      32) {
        tab2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab2.$set(tab2_changes);
      const tab3_changes = {};
      if (dirty & /*current*/
      2)
        tab3_changes.current = /*current*/
        ctx2[1];
      if (dirty & /*$$scope*/
      32) {
        tab3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab3.$set(tab3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tab0.$$.fragment, local);
      transition_in(tab1.$$.fragment, local);
      transition_in(tab2.$$.fragment, local);
      transition_in(tab3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tab0.$$.fragment, local);
      transition_out(tab1.$$.fragment, local);
      transition_out(tab2.$$.fragment, local);
      transition_out(tab3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(tab0);
      destroy_component(tab1);
      destroy_component(tab2);
      destroy_component(tab3);
    }
  };
}
function create_right_slot(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "close";
      attr(button, "class", "close material-icons-round");
      attr(button, "slot", "right");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*closeThis*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1R(ctx) {
  let tabs;
  let updating_current;
  let current;
  function tabs_current_binding(value) {
    ctx[4](value);
  }
  let tabs_props = {
    tabs: ["Processes", "Services", "Users", "Security"],
    $$slots: {
      right: [create_right_slot],
      renderer: [create_renderer_slot]
    },
    $$scope: { ctx }
  };
  if (
    /*current*/
    ctx[1] !== void 0
  ) {
    tabs_props.current = /*current*/
    ctx[1];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind$1(tabs, "current", tabs_current_binding));
  return {
    c() {
      create_component(tabs.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tabs, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tabs_changes = {};
      if (dirty & /*$$scope, current, runtime*/
      35) {
        tabs_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_current && dirty & /*current*/
      2) {
        updating_current = true;
        tabs_changes.current = /*current*/
        ctx2[1];
        add_flush_callback(() => updating_current = false);
      }
      tabs.$set(tabs_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tabs.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tabs.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tabs, detaching);
    }
  };
}
function instance$1F($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let current;
  onMount(() => {
    if (runtime.process.args && typeof runtime.process.args[0] == "string")
      $$invalidate(1, current = runtime.process.args[0]);
    ProcessStack.dispatch.subscribe(runtime.pid, "change-tab", (data2) => {
      $$invalidate(1, current = data2[0]);
    });
  });
  function closeThis() {
    runtime.closeApp();
  }
  function services_current_binding(value) {
    current = value;
    $$invalidate(1, current);
  }
  function tabs_current_binding(value) {
    current = value;
    $$invalidate(1, current);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, current, closeThis, services_current_binding, tabs_current_binding];
}
let App$8 = class App23 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1F, create_fragment$1R, safe_not_equal, { runtime: 0 });
  }
};
const ProcessManager = {
  metadata: {
    name: "Processes",
    description: "Manage running processes",
    author: "The ArcOS Team",
    version: "2.0.0",
    icon: ProcessManagerIcon,
    appGroup: "systemTools",
    dependendsOn: ["AppInfo", "ServiceInfo"]
  },
  runtime: Runtime$2,
  content: App$8,
  id: "ProcessManager",
  size: { w: 750, h: 500 },
  minSize: { w: 750, h: 500 },
  maxSize: { w: 950, h: 700 },
  pos: { x: 200, y: 150 },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: true
  },
  controls: {
    minimize: false,
    maximize: true,
    close: true
  },
  singleInstance: true,
  glass: true
};
const Page_svelte_svelte_type_style_lang = "";
function create_if_block$X(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$1Q(ctx) {
  let div;
  let current;
  let if_block = (
    /*$store*/
    ctx[2] == /*name*/
    ctx[1] && create_if_block$X(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "window-page svelte-gho42m");
      toggle_class(
        div,
        "show",
        /*$store*/
        ctx[2] == /*name*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$store*/
        ctx2[2] == /*name*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$store, name*/
          6) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$X(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*$store, name*/
      6) {
        toggle_class(
          div,
          "show",
          /*$store*/
          ctx2[2] == /*name*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$1E($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop$1, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, ($$value) => $$invalidate(2, $store = $$value)), store);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { store } = $$props;
  $$subscribe_store();
  let { name } = $$props;
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(0, store = $$props2.store));
    if ("name" in $$props2)
      $$invalidate(1, name = $$props2.name);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [store, name, $store, $$scope, slots];
}
let Page$1 = class Page extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1E, create_fragment$1Q, safe_not_equal, { store: 0, name: 1 });
  }
};
class QlorbRuntime extends AppRuntime {
  constructor(appData, appMutator, process) {
    super(appData, appMutator, process);
    __publicField(this, "random", (m3) => Math.floor(Math.random() * m3));
    __publicField(this, "Boxes", Store$1([]));
    __publicField(this, "BoxesOffset", Store$1(0));
    __publicField(this, "Clicks", Store$1(0));
    __publicField(this, "Score", Store$1(0));
    __publicField(this, "OldClicks", Store$1(0));
    __publicField(this, "BOX_SIZE", 30);
    __publicField(this, "BOX_VALUES", [1, -1, -1, 5, 2, -5, -4, 1, -2]);
    __publicField(this, "PAGES", ["intro", "start", "help", "game"]);
    setInterval(() => {
      if (this.Boxes.get().length - this.Clicks.get() < 21 && this.CurrentPage.get() == "game")
        this.spawnBox();
    }, 300);
  }
  spawnBox(props, useOffset, forcePositive = false) {
    this.Log(
      `Spawning box (useOffset = ${useOffset}, forcePositive = ${forcePositive})`,
      "spawnBox"
    );
    const boxProps = props || this.createRandomBox(useOffset, forcePositive);
    this.Boxes.update((v2) => {
      v2.push(boxProps);
      return v2;
    });
    this.BoxesOffset.update((v2) => v2 + 1);
    return boxProps;
  }
  createRandomBox(useOffset = true, forcePositive = false) {
    this.Log(
      `Creating random box (useOffset = ${useOffset}, forcePositive = ${forcePositive})`,
      "createRandomBox"
    );
    const values = !forcePositive ? this.BOX_VALUES : this.BOX_VALUES.filter((v2) => v2 > 0);
    const modifier = values[this.random(values.length)];
    const offset = this.random(this.BOX_SIZE * 2);
    const box = {
      modifier,
      class: this.findBoxClass(modifier),
      yoffset: useOffset ? offset : 0
    };
    return box;
  }
  findBoxClass(mod) {
    if (mod > 3)
      return "golden";
    if (mod < 0)
      return "bad";
    if (mod == 1)
      return "good";
    if (mod == 0)
      return "neutral";
    return "good";
  }
  ScorePoints(box, button) {
    this.Log(`Scoring ${box.modifier} points`, "ScorePoints");
    if (box.modifier < 0)
      return this.clickReset();
    this.Score.update((v2) => v2 + box.modifier);
    this.Clicks.update((v2) => v2 + 1);
    this.spawnBox();
    if (button)
      button.blur();
  }
  ScoreNegativePoints(box, button) {
    this.ScorePoints({ ...box, modifier: -box.modifier }, button);
  }
  levelDown() {
    this.Log(`Deprecating the player's level down...`, "levelDown");
    const score = this.Score.get();
    if (score < 100)
      return this.Score.set(0);
    return this.Score.set(score - 100);
  }
  clickReset() {
    this.Log(`Resetting click variables`, "clickReset");
    this.Clicks.set(1);
    this.Clicks.set(0);
    this.levelDown();
  }
  flushStores() {
    this.Log(`Flushing all stores to their default values`, "flushStores");
    this.Score.set(0);
    this.Clicks.set(0);
    this.OldClicks.set(0);
    this.Boxes.set([]);
    this.BoxesOffset.set(0);
  }
  onSwitchPage() {
    this.flushStores();
  }
}
const Intro_svelte_svelte_type_style_lang = "";
function create_default_slot$f(ctx) {
  let div3;
  let div0;
  let t3;
  let div1;
  let t6;
  let div2;
  let img1;
  let img1_src_value;
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h1 class="svelte-1mie1hx">Created by IzKuipers</h1> <p>www.izkuipers.nl</p>`;
      t3 = space();
      div1 = element("div");
      div1.innerHTML = `<h1 class="svelte-1mie1hx"><img src="${Logo()}" alt="ArcOS" class="svelte-1mie1hx"/> <span>Written for ArcOS</span></h1>`;
      t6 = space();
      div2 = element("div");
      img1 = element("img");
      attr(div0, "class", "stage1 svelte-1mie1hx");
      attr(div1, "class", "stage2 svelte-1mie1hx");
      if (!src_url_equal(img1.src, img1_src_value = /*app*/
      ctx[1].metadata.icon))
        attr(img1, "src", img1_src_value);
      attr(img1, "alt", "");
      attr(img1, "class", "logo svelte-1mie1hx");
      attr(div2, "class", "stage3 svelte-1mie1hx");
      attr(div3, "class", "intro fullscreen svelte-1mie1hx");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div3, t3);
      append(div3, div1);
      append(div3, t6);
      append(div3, div2);
      append(div2, img1);
    },
    p(ctx2, dirty) {
      if (dirty & /*app*/
      2 && !src_url_equal(img1.src, img1_src_value = /*app*/
      ctx2[1].metadata.icon)) {
        attr(img1, "src", img1_src_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
    }
  };
}
function create_fragment$1P(ctx) {
  let page;
  let current;
  page = new Page$1({
    props: {
      store: (
        /*runtime*/
        ctx[0].CurrentPage
      ),
      name: "intro",
      $$slots: { default: [create_default_slot$f] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(page.$$.fragment);
    },
    m(target, anchor) {
      mount_component(page, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const page_changes = {};
      if (dirty & /*runtime*/
      1)
        page_changes.store = /*runtime*/
        ctx2[0].CurrentPage;
      if (dirty & /*$$scope, app*/
      18) {
        page_changes.$$scope = { dirty, ctx: ctx2 };
      }
      page.$set(page_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(page.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(page.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(page, detaching);
    }
  };
}
function instance$1D($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(2, $UserDataStore = $$value));
  let { runtime } = $$props;
  let { app } = $$props;
  const { CurrentPage } = runtime;
  CurrentPage.subscribe((v2) => {
    if (v2 != "intro")
      return;
    if ($UserDataStore.appdata.QlorbApp.introed)
      return runtime.switchPage("start");
    setTimeout(
      () => {
        set_store_value(UserDataStore, $UserDataStore.appdata.QlorbApp.introed = true, $UserDataStore);
        runtime.switchPage("start");
      },
      17e3
    );
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
  };
  return [runtime, app];
}
class Intro extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1D, create_fragment$1P, safe_not_equal, { runtime: 0, app: 1 });
  }
}
const generatedAttribute = "generated";
const mouseDownEvent = "pointerdown";
const mouseUpEvent = "pointerup";
const mouseLeaveEvent = "pointerleave";
const mouseOutEvent = "pointerout";
const mouseMoveEvent = "pointermove";
const touchStartEvent = "touchstart";
const touchEndEvent = "touchend";
const touchMoveEvent = "touchmove";
const touchCancelEvent = "touchcancel";
const resizeEvent = "resize";
const visibilityChangeEvent = "visibilitychange";
const errorPrefix = "tsParticles - Error";
class Vector3d {
  constructor(xOrCoords, y2, z2) {
    this._updateFromAngle = (angle, length) => {
      this.x = Math.cos(angle) * length;
      this.y = Math.sin(angle) * length;
    };
    if (!isNumber(xOrCoords) && xOrCoords) {
      this.x = xOrCoords.x;
      this.y = xOrCoords.y;
      const coords3d = xOrCoords;
      this.z = coords3d.z ? coords3d.z : 0;
    } else if (xOrCoords !== void 0 && y2 !== void 0) {
      this.x = xOrCoords;
      this.y = y2;
      this.z = z2 ?? 0;
    } else {
      throw new Error(`${errorPrefix} Vector3d not initialized correctly`);
    }
  }
  static get origin() {
    return Vector3d.create(0, 0, 0);
  }
  get angle() {
    return Math.atan2(this.y, this.x);
  }
  set angle(angle) {
    this._updateFromAngle(angle, this.length);
  }
  get length() {
    return Math.sqrt(this.getLengthSq());
  }
  set length(length) {
    this._updateFromAngle(this.angle, length);
  }
  static clone(source) {
    return Vector3d.create(source.x, source.y, source.z);
  }
  static create(x2, y2, z2) {
    return new Vector3d(x2, y2, z2);
  }
  add(v2) {
    return Vector3d.create(this.x + v2.x, this.y + v2.y, this.z + v2.z);
  }
  addTo(v2) {
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
  }
  copy() {
    return Vector3d.clone(this);
  }
  distanceTo(v2) {
    return this.sub(v2).length;
  }
  distanceToSq(v2) {
    return this.sub(v2).getLengthSq();
  }
  div(n2) {
    return Vector3d.create(this.x / n2, this.y / n2, this.z / n2);
  }
  divTo(n2) {
    this.x /= n2;
    this.y /= n2;
    this.z /= n2;
  }
  getLengthSq() {
    return this.x ** 2 + this.y ** 2;
  }
  mult(n2) {
    return Vector3d.create(this.x * n2, this.y * n2, this.z * n2);
  }
  multTo(n2) {
    this.x *= n2;
    this.y *= n2;
    this.z *= n2;
  }
  normalize() {
    const length = this.length;
    if (length != 0) {
      this.multTo(1 / length);
    }
  }
  rotate(angle) {
    return Vector3d.create(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle), 0);
  }
  setTo(c2) {
    this.x = c2.x;
    this.y = c2.y;
    const v3d = c2;
    this.z = v3d.z ? v3d.z : 0;
  }
  sub(v2) {
    return Vector3d.create(this.x - v2.x, this.y - v2.y, this.z - v2.z);
  }
  subFrom(v2) {
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
  }
}
class Vector extends Vector3d {
  constructor(xOrCoords, y2) {
    super(xOrCoords, y2, 0);
  }
  static get origin() {
    return Vector.create(0, 0);
  }
  static clone(source) {
    return Vector.create(source.x, source.y);
  }
  static create(x2, y2) {
    return new Vector(x2, y2);
  }
}
let _random = Math.random;
function getRandom() {
  return clamp(_random(), 0, 1 - 1e-16);
}
function clamp(num, min, max) {
  return Math.min(Math.max(num, min), max);
}
function randomInRange(r2) {
  const max = getRangeMax(r2);
  let min = getRangeMin(r2);
  if (max === min) {
    min = 0;
  }
  return getRandom() * (max - min) + min;
}
function getRangeValue(value) {
  return isNumber(value) ? value : randomInRange(value);
}
function getRangeMin(value) {
  return isNumber(value) ? value : value.min;
}
function getRangeMax(value) {
  return isNumber(value) ? value : value.max;
}
function setRangeValue(source, value) {
  if (source === value || value === void 0 && isNumber(source)) {
    return source;
  }
  const min = getRangeMin(source), max = getRangeMax(source);
  return value !== void 0 ? {
    min: Math.min(min, value),
    max: Math.max(max, value)
  } : setRangeValue(min, max);
}
function getValue(options2) {
  const random = options2.random, { enable, minimumValue } = isBoolean(random) ? {
    enable: random,
    minimumValue: 0
  } : random;
  return enable ? getRangeValue(setRangeValue(options2.value, minimumValue)) : getRangeValue(options2.value);
}
function getDistances(pointA, pointB) {
  const dx = pointA.x - pointB.x, dy = pointA.y - pointB.y;
  return { dx, dy, distance: Math.sqrt(dx ** 2 + dy ** 2) };
}
function getDistance(pointA, pointB) {
  return getDistances(pointA, pointB).distance;
}
function getParticleDirectionAngle(direction, position, center) {
  if (isNumber(direction)) {
    return direction * Math.PI / 180;
  }
  switch (direction) {
    case "top":
      return -Math.PI / 2;
    case "top-right":
      return -Math.PI / 4;
    case "right":
      return 0;
    case "bottom-right":
      return Math.PI / 4;
    case "bottom":
      return Math.PI / 2;
    case "bottom-left":
      return 3 * Math.PI / 4;
    case "left":
      return Math.PI;
    case "top-left":
      return -3 * Math.PI / 4;
    case "inside":
      return Math.atan2(center.y - position.y, center.x - position.x);
    case "outside":
      return Math.atan2(position.y - center.y, position.x - center.x);
    default:
      return getRandom() * Math.PI * 2;
  }
}
function getParticleBaseVelocity(direction) {
  const baseVelocity = Vector.origin;
  baseVelocity.length = 1;
  baseVelocity.angle = direction;
  return baseVelocity;
}
function calcExactPositionOrRandomFromSize(data2) {
  var _a, _b;
  return {
    x: ((_a = data2.position) == null ? void 0 : _a.x) ?? getRandom() * data2.size.width,
    y: ((_b = data2.position) == null ? void 0 : _b.y) ?? getRandom() * data2.size.height
  };
}
function parseAlpha(input) {
  return input ? input.endsWith("%") ? parseFloat(input) / 100 : parseFloat(input) : 1;
}
const _logger = {
  debug: console.debug,
  error: console.error,
  info: console.info,
  log: console.log,
  verbose: console.log,
  warning: console.warn
};
function getLogger() {
  return _logger;
}
function isSsr() {
  return typeof window === "undefined" || !window || typeof window.document === "undefined" || !window.document;
}
function hasMatchMedia() {
  return !isSsr() && typeof matchMedia !== "undefined";
}
function safeMatchMedia(query) {
  if (!hasMatchMedia()) {
    return;
  }
  return matchMedia(query);
}
function safeMutationObserver(callback) {
  if (isSsr() || typeof MutationObserver === "undefined") {
    return;
  }
  return new MutationObserver(callback);
}
function isInArray(value, array) {
  return value === array || isArray(array) && array.indexOf(value) > -1;
}
function arrayRandomIndex(array) {
  return Math.floor(getRandom() * array.length);
}
function itemFromArray(array, index, useIndex = true) {
  return array[index !== void 0 && useIndex ? index % array.length : arrayRandomIndex(array)];
}
function isPointInside(point, size, offset, radius, direction) {
  return areBoundsInside(calculateBounds(point, radius ?? 0), size, offset, direction);
}
function areBoundsInside(bounds, size, offset, direction) {
  let inside = true;
  if (!direction || direction === "bottom") {
    inside = bounds.top < size.height + offset.x;
  }
  if (inside && (!direction || direction === "left")) {
    inside = bounds.right > offset.x;
  }
  if (inside && (!direction || direction === "right")) {
    inside = bounds.left < size.width + offset.y;
  }
  if (inside && (!direction || direction === "top")) {
    inside = bounds.bottom > offset.y;
  }
  return inside;
}
function calculateBounds(point, radius) {
  return {
    bottom: point.y + radius,
    left: point.x - radius,
    right: point.x + radius,
    top: point.y - radius
  };
}
function deepExtend(destination, ...sources) {
  for (const source of sources) {
    if (source === void 0 || source === null) {
      continue;
    }
    if (!isObject(source)) {
      destination = source;
      continue;
    }
    const sourceIsArray = Array.isArray(source);
    if (sourceIsArray && (isObject(destination) || !destination || !Array.isArray(destination))) {
      destination = [];
    } else if (!sourceIsArray && (isObject(destination) || !destination || Array.isArray(destination))) {
      destination = {};
    }
    for (const key2 in source) {
      if (key2 === "__proto__") {
        continue;
      }
      const sourceDict = source, value = sourceDict[key2], destDict = destination;
      destDict[key2] = isObject(value) && Array.isArray(value) ? value.map((v2) => deepExtend(destDict[key2], v2)) : deepExtend(destDict[key2], value);
    }
  }
  return destination;
}
function executeOnSingleOrMultiple(obj, callback) {
  return isArray(obj) ? obj.map((item, index) => callback(item, index)) : callback(obj, 0);
}
function itemFromSingleOrMultiple(obj, index, useIndex) {
  return isArray(obj) ? itemFromArray(obj, index, useIndex) : obj;
}
function initParticleNumericAnimationValue(options2, pxRatio) {
  const valueRange = options2.value, animationOptions = options2.animation, res = {
    delayTime: getRangeValue(animationOptions.delay) * 1e3,
    enable: animationOptions.enable,
    value: getRangeValue(options2.value) * pxRatio,
    max: getRangeMax(valueRange) * pxRatio,
    min: getRangeMin(valueRange) * pxRatio,
    loops: 0,
    maxLoops: getRangeValue(animationOptions.count),
    time: 0
  };
  if (animationOptions.enable) {
    res.decay = 1 - getRangeValue(animationOptions.decay);
    switch (animationOptions.mode) {
      case "increase":
        res.status = "increasing";
        break;
      case "decrease":
        res.status = "decreasing";
        break;
      case "random":
        res.status = getRandom() >= 0.5 ? "increasing" : "decreasing";
        break;
    }
    const autoStatus = animationOptions.mode === "auto";
    switch (animationOptions.startValue) {
      case "min":
        res.value = res.min;
        if (autoStatus) {
          res.status = "increasing";
        }
        break;
      case "max":
        res.value = res.max;
        if (autoStatus) {
          res.status = "decreasing";
        }
        break;
      case "random":
      default:
        res.value = randomInRange(res);
        if (autoStatus) {
          res.status = getRandom() >= 0.5 ? "increasing" : "decreasing";
        }
        break;
    }
  }
  res.initialValue = res.value;
  return res;
}
function getPositionOrSize(positionOrSize, canvasSize) {
  const isPercent = positionOrSize.mode === "percent";
  if (!isPercent) {
    const { mode: _2, ...rest } = positionOrSize;
    return rest;
  }
  const isPosition = "x" in positionOrSize;
  if (isPosition) {
    return {
      x: positionOrSize.x / 100 * canvasSize.width,
      y: positionOrSize.y / 100 * canvasSize.height
    };
  } else {
    return {
      width: positionOrSize.width / 100 * canvasSize.width,
      height: positionOrSize.height / 100 * canvasSize.height
    };
  }
}
function getPosition(position, canvasSize) {
  return getPositionOrSize(position, canvasSize);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isString(arg) {
  return typeof arg === "string";
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isArray(arg) {
  return Array.isArray(arg);
}
const randomColorValue = "random", colorManagers = /* @__PURE__ */ new Map();
function addColorManager(manager) {
  colorManagers.set(manager.key, manager);
}
function hue2rgb(p2, q2, t2) {
  if (t2 < 0) {
    t2 += 1;
  }
  if (t2 > 1) {
    t2 -= 1;
  }
  if (t2 < 1 / 6) {
    return p2 + (q2 - p2) * 6 * t2;
  }
  if (t2 < 1 / 2) {
    return q2;
  }
  if (t2 < 2 / 3) {
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  }
  return p2;
}
function stringToRgba(input) {
  for (const [, manager] of colorManagers) {
    if (input.startsWith(manager.stringPrefix)) {
      return manager.parseString(input);
    }
  }
  const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, hexFixed = input.replace(shorthandRegex, (_2, r2, g2, b2, a2) => {
    return r2 + r2 + g2 + g2 + b2 + b2 + (a2 !== void 0 ? a2 + a2 : "");
  }), regex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, result = regex.exec(hexFixed);
  return result ? {
    a: result[4] !== void 0 ? parseInt(result[4], 16) / 255 : 1,
    b: parseInt(result[3], 16),
    g: parseInt(result[2], 16),
    r: parseInt(result[1], 16)
  } : void 0;
}
function rangeColorToRgb(input, index, useIndex = true) {
  if (!input) {
    return;
  }
  const color = isString(input) ? { value: input } : input;
  if (isString(color.value)) {
    return colorToRgb(color.value, index, useIndex);
  }
  if (isArray(color.value)) {
    return rangeColorToRgb({
      value: itemFromArray(color.value, index, useIndex)
    });
  }
  for (const [, manager] of colorManagers) {
    const res = manager.handleRangeColor(color);
    if (res) {
      return res;
    }
  }
}
function colorToRgb(input, index, useIndex = true) {
  if (!input) {
    return;
  }
  const color = isString(input) ? { value: input } : input;
  if (isString(color.value)) {
    return color.value === randomColorValue ? getRandomRgbColor() : stringToRgb(color.value);
  }
  if (isArray(color.value)) {
    return colorToRgb({
      value: itemFromArray(color.value, index, useIndex)
    });
  }
  for (const [, manager] of colorManagers) {
    const res = manager.handleColor(color);
    if (res) {
      return res;
    }
  }
}
function rangeColorToHsl(color, index, useIndex = true) {
  const rgb = rangeColorToRgb(color, index, useIndex);
  return rgb ? rgbToHsl(rgb) : void 0;
}
function rgbToHsl(color) {
  const r1 = color.r / 255, g1 = color.g / 255, b1 = color.b / 255, max = Math.max(r1, g1, b1), min = Math.min(r1, g1, b1), res = {
    h: 0,
    l: (max + min) / 2,
    s: 0
  };
  if (max !== min) {
    res.s = res.l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
    res.h = r1 === max ? (g1 - b1) / (max - min) : res.h = g1 === max ? 2 + (b1 - r1) / (max - min) : 4 + (r1 - g1) / (max - min);
  }
  res.l *= 100;
  res.s *= 100;
  res.h *= 60;
  if (res.h < 0) {
    res.h += 360;
  }
  if (res.h >= 360) {
    res.h -= 360;
  }
  return res;
}
function stringToRgb(input) {
  return stringToRgba(input);
}
function hslToRgb(hsl) {
  const result = { b: 0, g: 0, r: 0 }, hslPercent = {
    h: hsl.h / 360,
    l: hsl.l / 100,
    s: hsl.s / 100
  };
  if (!hslPercent.s) {
    result.r = result.g = result.b = hslPercent.l;
  } else {
    const q2 = hslPercent.l < 0.5 ? hslPercent.l * (1 + hslPercent.s) : hslPercent.l + hslPercent.s - hslPercent.l * hslPercent.s, p2 = 2 * hslPercent.l - q2;
    result.r = hue2rgb(p2, q2, hslPercent.h + 1 / 3);
    result.g = hue2rgb(p2, q2, hslPercent.h);
    result.b = hue2rgb(p2, q2, hslPercent.h - 1 / 3);
  }
  result.r = Math.floor(result.r * 255);
  result.g = Math.floor(result.g * 255);
  result.b = Math.floor(result.b * 255);
  return result;
}
function hslaToRgba(hsla) {
  const rgbResult = hslToRgb(hsla);
  return {
    a: hsla.a,
    b: rgbResult.b,
    g: rgbResult.g,
    r: rgbResult.r
  };
}
function getRandomRgbColor(min) {
  const fixedMin = min ?? 0;
  return {
    b: Math.floor(randomInRange(setRangeValue(fixedMin, 256))),
    g: Math.floor(randomInRange(setRangeValue(fixedMin, 256))),
    r: Math.floor(randomInRange(setRangeValue(fixedMin, 256)))
  };
}
function getStyleFromRgb(color, opacity) {
  return `rgba(${color.r}, ${color.g}, ${color.b}, ${opacity ?? 1})`;
}
function getStyleFromHsl(color, opacity) {
  return `hsla(${color.h}, ${color.s}%, ${color.l}%, ${opacity ?? 1})`;
}
function getHslFromAnimation(animation) {
  return animation !== void 0 ? {
    h: animation.h.value,
    s: animation.s.value,
    l: animation.l.value
  } : void 0;
}
function getHslAnimationFromHsl(hsl, animationOptions, reduceFactor) {
  const resColor = {
    h: {
      enable: false,
      value: hsl.h
    },
    s: {
      enable: false,
      value: hsl.s
    },
    l: {
      enable: false,
      value: hsl.l
    }
  };
  if (animationOptions) {
    setColorAnimation(resColor.h, animationOptions.h, reduceFactor);
    setColorAnimation(resColor.s, animationOptions.s, reduceFactor);
    setColorAnimation(resColor.l, animationOptions.l, reduceFactor);
  }
  return resColor;
}
function setColorAnimation(colorValue, colorAnimation, reduceFactor) {
  colorValue.enable = colorAnimation.enable;
  if (colorValue.enable) {
    colorValue.velocity = getRangeValue(colorAnimation.speed) / 100 * reduceFactor;
    colorValue.decay = 1 - getRangeValue(colorAnimation.decay);
    colorValue.status = "increasing";
    colorValue.loops = 0;
    colorValue.maxLoops = getRangeValue(colorAnimation.count);
    colorValue.time = 0;
    colorValue.delayTime = getRangeValue(colorAnimation.delay) * 1e3;
    if (!colorAnimation.sync) {
      colorValue.velocity *= getRandom();
      colorValue.value *= getRandom();
    }
    colorValue.initialValue = colorValue.value;
  } else {
    colorValue.velocity = 0;
  }
}
function paintBase(context, dimension, baseColor) {
  context.fillStyle = baseColor ?? "rgba(0,0,0,0)";
  context.fillRect(0, 0, dimension.width, dimension.height);
}
function paintImage(context, dimension, image, opacity) {
  if (!image) {
    return;
  }
  context.globalAlpha = opacity;
  context.drawImage(image, 0, 0, dimension.width, dimension.height);
  context.globalAlpha = 1;
}
function clear(context, dimension) {
  context.clearRect(0, 0, dimension.width, dimension.height);
}
function drawParticle(data2) {
  const { container, context, particle, delta, colorStyles, backgroundMask, composite, radius, opacity, shadow, transform } = data2;
  const pos = particle.getPosition(), angle = particle.rotation + (particle.pathRotation ? particle.velocity.angle : 0), rotateData = {
    sin: Math.sin(angle),
    cos: Math.cos(angle)
  }, transformData2 = {
    a: rotateData.cos * (transform.a ?? 1),
    b: rotateData.sin * (transform.b ?? 1),
    c: -rotateData.sin * (transform.c ?? 1),
    d: rotateData.cos * (transform.d ?? 1)
  };
  context.setTransform(transformData2.a, transformData2.b, transformData2.c, transformData2.d, pos.x, pos.y);
  context.beginPath();
  if (backgroundMask) {
    context.globalCompositeOperation = composite;
  }
  const shadowColor = particle.shadowColor;
  if (shadow.enable && shadowColor) {
    context.shadowBlur = shadow.blur;
    context.shadowColor = getStyleFromRgb(shadowColor);
    context.shadowOffsetX = shadow.offset.x;
    context.shadowOffsetY = shadow.offset.y;
  }
  if (colorStyles.fill) {
    context.fillStyle = colorStyles.fill;
  }
  const strokeWidth = particle.strokeWidth ?? 0;
  context.lineWidth = strokeWidth;
  if (colorStyles.stroke) {
    context.strokeStyle = colorStyles.stroke;
  }
  drawShape(container, context, particle, radius, opacity, delta);
  if (strokeWidth > 0) {
    context.stroke();
  }
  if (particle.close) {
    context.closePath();
  }
  if (particle.fill) {
    context.fill();
  }
  drawShapeAfterEffect(container, context, particle, radius, opacity, delta);
  context.globalCompositeOperation = "source-over";
  context.setTransform(1, 0, 0, 1, 0, 0);
}
function drawShape(container, context, particle, radius, opacity, delta) {
  if (!particle.shape) {
    return;
  }
  const drawer = container.drawers.get(particle.shape);
  if (!drawer) {
    return;
  }
  drawer.draw(context, particle, radius, opacity, delta, container.retina.pixelRatio);
}
function drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {
  if (!particle.shape) {
    return;
  }
  const drawer = container.drawers.get(particle.shape);
  if (!drawer || !drawer.afterEffect) {
    return;
  }
  drawer.afterEffect(context, particle, radius, opacity, delta, container.retina.pixelRatio);
}
function drawPlugin(context, plugin, delta) {
  if (!plugin.draw) {
    return;
  }
  plugin.draw(context, delta);
}
function drawParticlePlugin(context, plugin, particle, delta) {
  if (!plugin.drawParticle) {
    return;
  }
  plugin.drawParticle(context, particle, delta);
}
function alterHsl(color, type, value) {
  return {
    h: color.h,
    s: color.s,
    l: color.l + (type === "darken" ? -1 : 1) * value
  };
}
function setTransformValue(factor, newFactor, key2) {
  const newValue = newFactor[key2];
  if (newValue !== void 0) {
    factor[key2] = (factor[key2] ?? 1) * newValue;
  }
}
class Canvas {
  constructor(container) {
    this.container = container;
    this._applyPostDrawUpdaters = (particle) => {
      for (const updater of this._postDrawUpdaters) {
        updater.afterDraw && updater.afterDraw(particle);
      }
    };
    this._applyPreDrawUpdaters = (ctx, particle, radius, zOpacity, colorStyles, transform) => {
      for (const updater of this._preDrawUpdaters) {
        if (updater.getColorStyles) {
          const { fill, stroke } = updater.getColorStyles(particle, ctx, radius, zOpacity);
          if (fill) {
            colorStyles.fill = fill;
          }
          if (stroke) {
            colorStyles.stroke = stroke;
          }
        }
        if (updater.getTransformValues) {
          const updaterTransform = updater.getTransformValues(particle);
          for (const key2 in updaterTransform) {
            setTransformValue(transform, updaterTransform, key2);
          }
        }
        updater.beforeDraw && updater.beforeDraw(particle);
      }
    };
    this._applyResizePlugins = () => {
      for (const plugin of this._resizePlugins) {
        plugin.resize && plugin.resize();
      }
    };
    this._getPluginParticleColors = (particle) => {
      let fColor, sColor;
      for (const plugin of this._colorPlugins) {
        if (!fColor && plugin.particleFillColor) {
          fColor = rangeColorToHsl(plugin.particleFillColor(particle));
        }
        if (!sColor && plugin.particleStrokeColor) {
          sColor = rangeColorToHsl(plugin.particleStrokeColor(particle));
        }
        if (fColor && sColor) {
          break;
        }
      }
      return [fColor, sColor];
    };
    this._initCover = () => {
      const options2 = this.container.actualOptions, cover = options2.backgroundMask.cover, color = cover.color, coverRgb = rangeColorToRgb(color);
      if (coverRgb) {
        const coverColor = {
          ...coverRgb,
          a: cover.opacity
        };
        this._coverColorStyle = getStyleFromRgb(coverColor, coverColor.a);
      }
    };
    this._initStyle = () => {
      const element2 = this.element, options2 = this.container.actualOptions;
      if (!element2) {
        return;
      }
      if (this._fullScreen) {
        this._originalStyle = deepExtend({}, element2.style);
        this._setFullScreenStyle();
      } else {
        this._resetOriginalStyle();
      }
      for (const key2 in options2.style) {
        if (!key2 || !options2.style) {
          continue;
        }
        const value = options2.style[key2];
        if (!value) {
          continue;
        }
        element2.style.setProperty(key2, value, "important");
      }
    };
    this._initTrail = async () => {
      const options2 = this.container.actualOptions, trail = options2.particles.move.trail, trailFill = trail.fill;
      if (!trail.enable) {
        return;
      }
      if (trailFill.color) {
        const fillColor = rangeColorToRgb(trailFill.color);
        if (!fillColor) {
          return;
        }
        const trail2 = options2.particles.move.trail;
        this._trailFill = {
          color: {
            ...fillColor
          },
          opacity: 1 / trail2.length
        };
      } else {
        await new Promise((resolve, reject) => {
          if (!trailFill.image) {
            return;
          }
          const img = document.createElement("img");
          img.addEventListener("load", () => {
            this._trailFill = {
              image: img,
              opacity: 1 / trail.length
            };
            resolve();
          });
          img.addEventListener("error", (evt) => {
            reject(evt.error);
          });
          img.src = trailFill.image;
        });
      }
    };
    this._paintBase = (baseColor) => {
      this.draw((ctx) => paintBase(ctx, this.size, baseColor));
    };
    this._paintImage = (image, opacity) => {
      this.draw((ctx) => paintImage(ctx, this.size, image, opacity));
    };
    this._repairStyle = () => {
      const element2 = this.element;
      if (!element2) {
        return;
      }
      this._safeMutationObserver((observer2) => observer2.disconnect());
      this._initStyle();
      this.initBackground();
      this._safeMutationObserver((observer2) => observer2.observe(element2, { attributes: true }));
    };
    this._resetOriginalStyle = () => {
      const element2 = this.element, originalStyle = this._originalStyle;
      if (!(element2 && originalStyle)) {
        return;
      }
      const style2 = element2.style;
      style2.position = originalStyle.position;
      style2.zIndex = originalStyle.zIndex;
      style2.top = originalStyle.top;
      style2.left = originalStyle.left;
      style2.width = originalStyle.width;
      style2.height = originalStyle.height;
    };
    this._safeMutationObserver = (callback) => {
      if (!this._mutationObserver) {
        return;
      }
      callback(this._mutationObserver);
    };
    this._setFullScreenStyle = () => {
      const element2 = this.element;
      if (!element2) {
        return;
      }
      const priority = "important", style2 = element2.style;
      style2.setProperty("position", "fixed", priority);
      style2.setProperty("z-index", this.container.actualOptions.fullScreen.zIndex.toString(10), priority);
      style2.setProperty("top", "0", priority);
      style2.setProperty("left", "0", priority);
      style2.setProperty("width", "100%", priority);
      style2.setProperty("height", "100%", priority);
    };
    this.size = {
      height: 0,
      width: 0
    };
    this._context = null;
    this._generated = false;
    this._preDrawUpdaters = [];
    this._postDrawUpdaters = [];
    this._resizePlugins = [];
    this._colorPlugins = [];
  }
  get _fullScreen() {
    return this.container.actualOptions.fullScreen.enable;
  }
  clear() {
    const options2 = this.container.actualOptions, trail = options2.particles.move.trail, trailFill = this._trailFill;
    if (options2.backgroundMask.enable) {
      this.paint();
    } else if (trail.enable && trail.length > 0 && trailFill) {
      if (trailFill.color) {
        this._paintBase(getStyleFromRgb(trailFill.color, trailFill.opacity));
      } else if (trailFill.image) {
        this._paintImage(trailFill.image, trailFill.opacity);
      }
    } else {
      this.draw((ctx) => {
        clear(ctx, this.size);
      });
    }
  }
  destroy() {
    this.stop();
    if (this._generated) {
      const element2 = this.element;
      element2 && element2.remove();
    } else {
      this._resetOriginalStyle();
    }
    this._preDrawUpdaters = [];
    this._postDrawUpdaters = [];
    this._resizePlugins = [];
    this._colorPlugins = [];
  }
  draw(cb) {
    const ctx = this._context;
    if (!ctx) {
      return;
    }
    return cb(ctx);
  }
  drawParticle(particle, delta) {
    if (particle.spawning || particle.destroyed) {
      return;
    }
    const radius = particle.getRadius();
    if (radius <= 0) {
      return;
    }
    const pfColor = particle.getFillColor(), psColor = particle.getStrokeColor() ?? pfColor;
    let [fColor, sColor] = this._getPluginParticleColors(particle);
    if (!fColor) {
      fColor = pfColor;
    }
    if (!sColor) {
      sColor = psColor;
    }
    if (!fColor && !sColor) {
      return;
    }
    this.draw((ctx) => {
      var _a;
      const container = this.container, options2 = container.actualOptions, zIndexOptions = particle.options.zIndex, zOpacityFactor = (1 - particle.zIndexFactor) ** zIndexOptions.opacityRate, opacity = particle.bubble.opacity ?? ((_a = particle.opacity) == null ? void 0 : _a.value) ?? 1, strokeOpacity = particle.strokeOpacity ?? opacity, zOpacity = opacity * zOpacityFactor, zStrokeOpacity = strokeOpacity * zOpacityFactor, transform = {}, colorStyles = {
        fill: fColor ? getStyleFromHsl(fColor, zOpacity) : void 0
      };
      colorStyles.stroke = sColor ? getStyleFromHsl(sColor, zStrokeOpacity) : colorStyles.fill;
      this._applyPreDrawUpdaters(ctx, particle, radius, zOpacity, colorStyles, transform);
      drawParticle({
        container,
        context: ctx,
        particle,
        delta,
        colorStyles,
        backgroundMask: options2.backgroundMask.enable,
        composite: options2.backgroundMask.composite,
        radius: radius * (1 - particle.zIndexFactor) ** zIndexOptions.sizeRate,
        opacity: zOpacity,
        shadow: particle.options.shadow,
        transform
      });
      this._applyPostDrawUpdaters(particle);
    });
  }
  drawParticlePlugin(plugin, particle, delta) {
    this.draw((ctx) => drawParticlePlugin(ctx, plugin, particle, delta));
  }
  drawPlugin(plugin, delta) {
    this.draw((ctx) => drawPlugin(ctx, plugin, delta));
  }
  async init() {
    this._safeMutationObserver((obs) => obs.disconnect());
    this._mutationObserver = safeMutationObserver((records) => {
      for (const record of records) {
        if (record.type === "attributes" && record.attributeName === "style") {
          this._repairStyle();
        }
      }
    });
    this.resize();
    this._initStyle();
    this._initCover();
    try {
      await this._initTrail();
    } catch (e2) {
      getLogger().error(e2);
    }
    this.initBackground();
    this._safeMutationObserver((obs) => {
      if (!this.element) {
        return;
      }
      obs.observe(this.element, { attributes: true });
    });
    this.initUpdaters();
    this.initPlugins();
    this.paint();
  }
  initBackground() {
    const options2 = this.container.actualOptions, background = options2.background, element2 = this.element;
    if (!element2) {
      return;
    }
    const elementStyle = element2.style;
    if (!elementStyle) {
      return;
    }
    if (background.color) {
      const color = rangeColorToRgb(background.color);
      elementStyle.backgroundColor = color ? getStyleFromRgb(color, background.opacity) : "";
    } else {
      elementStyle.backgroundColor = "";
    }
    elementStyle.backgroundImage = background.image || "";
    elementStyle.backgroundPosition = background.position || "";
    elementStyle.backgroundRepeat = background.repeat || "";
    elementStyle.backgroundSize = background.size || "";
  }
  initPlugins() {
    this._resizePlugins = [];
    for (const [, plugin] of this.container.plugins) {
      if (plugin.resize) {
        this._resizePlugins.push(plugin);
      }
      if (plugin.particleFillColor || plugin.particleStrokeColor) {
        this._colorPlugins.push(plugin);
      }
    }
  }
  initUpdaters() {
    this._preDrawUpdaters = [];
    this._postDrawUpdaters = [];
    for (const updater of this.container.particles.updaters) {
      if (updater.afterDraw) {
        this._postDrawUpdaters.push(updater);
      }
      if (updater.getColorStyles || updater.getTransformValues || updater.beforeDraw) {
        this._preDrawUpdaters.push(updater);
      }
    }
  }
  loadCanvas(canvas) {
    if (this._generated && this.element) {
      this.element.remove();
    }
    this._generated = canvas.dataset && generatedAttribute in canvas.dataset ? canvas.dataset[generatedAttribute] === "true" : this._generated;
    this.element = canvas;
    this.element.ariaHidden = "true";
    this._originalStyle = deepExtend({}, this.element.style);
    this.size.height = canvas.offsetHeight;
    this.size.width = canvas.offsetWidth;
    this._context = this.element.getContext("2d");
    this._safeMutationObserver((obs) => {
      if (!this.element) {
        return;
      }
      obs.observe(this.element, { attributes: true });
    });
    this.container.retina.init();
    this.initBackground();
  }
  paint() {
    const options2 = this.container.actualOptions;
    this.draw((ctx) => {
      if (options2.backgroundMask.enable && options2.backgroundMask.cover) {
        clear(ctx, this.size);
        this._paintBase(this._coverColorStyle);
      } else {
        this._paintBase();
      }
    });
  }
  resize() {
    if (!this.element) {
      return false;
    }
    const container = this.container, pxRatio = container.retina.pixelRatio, size = container.canvas.size, newSize = {
      width: this.element.offsetWidth * pxRatio,
      height: this.element.offsetHeight * pxRatio
    };
    if (newSize.height === size.height && newSize.width === size.width && newSize.height === this.element.height && newSize.width === this.element.width) {
      return false;
    }
    const oldSize = { ...size };
    this.element.width = size.width = this.element.offsetWidth * pxRatio;
    this.element.height = size.height = this.element.offsetHeight * pxRatio;
    if (this.container.started) {
      this.resizeFactor = {
        width: size.width / oldSize.width,
        height: size.height / oldSize.height
      };
    }
    return true;
  }
  stop() {
    this._safeMutationObserver((obs) => obs.disconnect());
    this._mutationObserver = void 0;
    this.draw((ctx) => clear(ctx, this.size));
  }
  async windowResize() {
    if (!this.element || !this.resize()) {
      return;
    }
    const container = this.container, needsRefresh = container.updateActualOptions();
    container.particles.setDensity();
    this._applyResizePlugins();
    if (needsRefresh) {
      await container.refresh();
    }
  }
}
function manageListener(element2, event, handler, add, options2) {
  if (add) {
    let addOptions = { passive: true };
    if (isBoolean(options2)) {
      addOptions.capture = options2;
    } else if (options2 !== void 0) {
      addOptions = options2;
    }
    element2.addEventListener(event, handler, addOptions);
  } else {
    const removeOptions = options2;
    element2.removeEventListener(event, handler, removeOptions);
  }
}
class EventListeners {
  constructor(container) {
    this.container = container;
    this._doMouseTouchClick = (e2) => {
      const container2 = this.container, options2 = container2.actualOptions;
      if (this._canPush) {
        const mouseInteractivity = container2.interactivity.mouse, mousePos = mouseInteractivity.position;
        if (!mousePos) {
          return;
        }
        mouseInteractivity.clickPosition = { ...mousePos };
        mouseInteractivity.clickTime = (/* @__PURE__ */ new Date()).getTime();
        const onClick = options2.interactivity.events.onClick;
        executeOnSingleOrMultiple(onClick.mode, (mode) => this.container.handleClickMode(mode));
      }
      if (e2.type === "touchend") {
        setTimeout(() => this._mouseTouchFinish(), 500);
      }
    };
    this._handleThemeChange = (e2) => {
      const mediaEvent = e2, container2 = this.container, options2 = container2.options, defaultThemes = options2.defaultThemes, themeName = mediaEvent.matches ? defaultThemes.dark : defaultThemes.light, theme = options2.themes.find((theme2) => theme2.name === themeName);
      if (theme && theme.default.auto) {
        container2.loadTheme(themeName);
      }
    };
    this._handleVisibilityChange = () => {
      const container2 = this.container, options2 = container2.actualOptions;
      this._mouseTouchFinish();
      if (!options2.pauseOnBlur) {
        return;
      }
      if (document && document.hidden) {
        container2.pageHidden = true;
        container2.pause();
      } else {
        container2.pageHidden = false;
        if (container2.getAnimationStatus()) {
          container2.play(true);
        } else {
          container2.draw(true);
        }
      }
    };
    this._handleWindowResize = async () => {
      if (this._resizeTimeout) {
        clearTimeout(this._resizeTimeout);
        delete this._resizeTimeout;
      }
      this._resizeTimeout = setTimeout(async () => {
        const canvas = this.container.canvas;
        canvas && await canvas.windowResize();
      }, this.container.actualOptions.interactivity.events.resize.delay * 1e3);
    };
    this._manageInteractivityListeners = (mouseLeaveTmpEvent, add) => {
      const handlers = this._handlers, container2 = this.container, options2 = container2.actualOptions;
      const interactivityEl = container2.interactivity.element;
      if (!interactivityEl) {
        return;
      }
      const html = interactivityEl, canvasEl = container2.canvas.element;
      if (canvasEl) {
        canvasEl.style.pointerEvents = html === canvasEl ? "initial" : "none";
      }
      if (!(options2.interactivity.events.onHover.enable || options2.interactivity.events.onClick.enable)) {
        return;
      }
      manageListener(interactivityEl, mouseMoveEvent, handlers.mouseMove, add);
      manageListener(interactivityEl, touchStartEvent, handlers.touchStart, add);
      manageListener(interactivityEl, touchMoveEvent, handlers.touchMove, add);
      if (!options2.interactivity.events.onClick.enable) {
        manageListener(interactivityEl, touchEndEvent, handlers.touchEnd, add);
      } else {
        manageListener(interactivityEl, touchEndEvent, handlers.touchEndClick, add);
        manageListener(interactivityEl, mouseUpEvent, handlers.mouseUp, add);
        manageListener(interactivityEl, mouseDownEvent, handlers.mouseDown, add);
      }
      manageListener(interactivityEl, mouseLeaveTmpEvent, handlers.mouseLeave, add);
      manageListener(interactivityEl, touchCancelEvent, handlers.touchCancel, add);
    };
    this._manageListeners = (add) => {
      const handlers = this._handlers, container2 = this.container, options2 = container2.actualOptions, detectType = options2.interactivity.detectsOn, canvasEl = container2.canvas.element;
      let mouseLeaveTmpEvent = mouseLeaveEvent;
      if (detectType === "window") {
        container2.interactivity.element = window;
        mouseLeaveTmpEvent = mouseOutEvent;
      } else if (detectType === "parent" && canvasEl) {
        container2.interactivity.element = canvasEl.parentElement ?? canvasEl.parentNode;
      } else {
        container2.interactivity.element = canvasEl;
      }
      this._manageMediaMatch(add);
      this._manageResize(add);
      this._manageInteractivityListeners(mouseLeaveTmpEvent, add);
      if (document) {
        manageListener(document, visibilityChangeEvent, handlers.visibilityChange, add, false);
      }
    };
    this._manageMediaMatch = (add) => {
      const handlers = this._handlers, mediaMatch = safeMatchMedia("(prefers-color-scheme: dark)");
      if (!mediaMatch) {
        return;
      }
      if (mediaMatch.addEventListener !== void 0) {
        manageListener(mediaMatch, "change", handlers.themeChange, add);
        return;
      }
      if (mediaMatch.addListener === void 0) {
        return;
      }
      if (add) {
        mediaMatch.addListener(handlers.oldThemeChange);
      } else {
        mediaMatch.removeListener(handlers.oldThemeChange);
      }
    };
    this._manageResize = (add) => {
      const handlers = this._handlers, container2 = this.container, options2 = container2.actualOptions;
      if (!options2.interactivity.events.resize) {
        return;
      }
      if (typeof ResizeObserver === "undefined") {
        manageListener(window, resizeEvent, handlers.resize, add);
        return;
      }
      const canvasEl = container2.canvas.element;
      if (this._resizeObserver && !add) {
        if (canvasEl) {
          this._resizeObserver.unobserve(canvasEl);
        }
        this._resizeObserver.disconnect();
        delete this._resizeObserver;
      } else if (!this._resizeObserver && add && canvasEl) {
        this._resizeObserver = new ResizeObserver(async (entries) => {
          const entry = entries.find((e2) => e2.target === canvasEl);
          if (!entry) {
            return;
          }
          await this._handleWindowResize();
        });
        this._resizeObserver.observe(canvasEl);
      }
    };
    this._mouseDown = () => {
      const { interactivity } = this.container;
      if (!interactivity) {
        return;
      }
      const { mouse } = interactivity;
      mouse.clicking = true;
      mouse.downPosition = mouse.position;
    };
    this._mouseTouchClick = (e2) => {
      const container2 = this.container, options2 = container2.actualOptions, { mouse } = container2.interactivity;
      mouse.inside = true;
      let handled = false;
      const mousePosition = mouse.position;
      if (!mousePosition || !options2.interactivity.events.onClick.enable) {
        return;
      }
      for (const [, plugin] of container2.plugins) {
        if (!plugin.clickPositionValid) {
          continue;
        }
        handled = plugin.clickPositionValid(mousePosition);
        if (handled) {
          break;
        }
      }
      if (!handled) {
        this._doMouseTouchClick(e2);
      }
      mouse.clicking = false;
    };
    this._mouseTouchFinish = () => {
      const interactivity = this.container.interactivity;
      if (!interactivity) {
        return;
      }
      const mouse = interactivity.mouse;
      delete mouse.position;
      delete mouse.clickPosition;
      delete mouse.downPosition;
      interactivity.status = mouseLeaveEvent;
      mouse.inside = false;
      mouse.clicking = false;
    };
    this._mouseTouchMove = (e2) => {
      const container2 = this.container, options2 = container2.actualOptions, interactivity = container2.interactivity, canvasEl = container2.canvas.element;
      if (!interactivity || !interactivity.element) {
        return;
      }
      interactivity.mouse.inside = true;
      let pos;
      if (e2.type.startsWith("pointer")) {
        this._canPush = true;
        const mouseEvent = e2;
        if (interactivity.element === window) {
          if (canvasEl) {
            const clientRect = canvasEl.getBoundingClientRect();
            pos = {
              x: mouseEvent.clientX - clientRect.left,
              y: mouseEvent.clientY - clientRect.top
            };
          }
        } else if (options2.interactivity.detectsOn === "parent") {
          const source = mouseEvent.target, target = mouseEvent.currentTarget;
          if (source && target && canvasEl) {
            const sourceRect = source.getBoundingClientRect(), targetRect = target.getBoundingClientRect(), canvasRect = canvasEl.getBoundingClientRect();
            pos = {
              x: mouseEvent.offsetX + 2 * sourceRect.left - (targetRect.left + canvasRect.left),
              y: mouseEvent.offsetY + 2 * sourceRect.top - (targetRect.top + canvasRect.top)
            };
          } else {
            pos = {
              x: mouseEvent.offsetX ?? mouseEvent.clientX,
              y: mouseEvent.offsetY ?? mouseEvent.clientY
            };
          }
        } else if (mouseEvent.target === canvasEl) {
          pos = {
            x: mouseEvent.offsetX ?? mouseEvent.clientX,
            y: mouseEvent.offsetY ?? mouseEvent.clientY
          };
        }
      } else {
        this._canPush = e2.type !== "touchmove";
        if (canvasEl) {
          const touchEvent = e2, lastTouch = touchEvent.touches[touchEvent.touches.length - 1], canvasRect = canvasEl.getBoundingClientRect();
          pos = {
            x: lastTouch.clientX - (canvasRect.left ?? 0),
            y: lastTouch.clientY - (canvasRect.top ?? 0)
          };
        }
      }
      const pxRatio = container2.retina.pixelRatio;
      if (pos) {
        pos.x *= pxRatio;
        pos.y *= pxRatio;
      }
      interactivity.mouse.position = pos;
      interactivity.status = mouseMoveEvent;
    };
    this._touchEnd = (e2) => {
      const evt = e2, touches = Array.from(evt.changedTouches);
      for (const touch of touches) {
        this._touches.delete(touch.identifier);
      }
      this._mouseTouchFinish();
    };
    this._touchEndClick = (e2) => {
      const evt = e2, touches = Array.from(evt.changedTouches);
      for (const touch of touches) {
        this._touches.delete(touch.identifier);
      }
      this._mouseTouchClick(e2);
    };
    this._touchStart = (e2) => {
      const evt = e2, touches = Array.from(evt.changedTouches);
      for (const touch of touches) {
        this._touches.set(touch.identifier, performance.now());
      }
      this._mouseTouchMove(e2);
    };
    this._canPush = true;
    this._touches = /* @__PURE__ */ new Map();
    this._handlers = {
      mouseDown: () => this._mouseDown(),
      mouseLeave: () => this._mouseTouchFinish(),
      mouseMove: (e2) => this._mouseTouchMove(e2),
      mouseUp: (e2) => this._mouseTouchClick(e2),
      touchStart: (e2) => this._touchStart(e2),
      touchMove: (e2) => this._mouseTouchMove(e2),
      touchEnd: (e2) => this._touchEnd(e2),
      touchCancel: (e2) => this._touchEnd(e2),
      touchEndClick: (e2) => this._touchEndClick(e2),
      visibilityChange: () => this._handleVisibilityChange(),
      themeChange: (e2) => this._handleThemeChange(e2),
      oldThemeChange: (e2) => this._handleThemeChange(e2),
      resize: () => {
        this._handleWindowResize();
      }
    };
  }
  addListeners() {
    this._manageListeners(true);
  }
  removeListeners() {
    this._manageListeners(false);
  }
}
class OptionsColor {
  constructor() {
    this.value = "";
  }
  static create(source, data2) {
    const color = new OptionsColor();
    color.load(source);
    if (data2 !== void 0) {
      if (isString(data2) || isArray(data2)) {
        color.load({ value: data2 });
      } else {
        color.load(data2);
      }
    }
    return color;
  }
  load(data2) {
    if ((data2 == null ? void 0 : data2.value) === void 0) {
      return;
    }
    this.value = data2.value;
  }
}
let Background$2 = class Background {
  constructor() {
    this.color = new OptionsColor();
    this.color.value = "";
    this.image = "";
    this.position = "";
    this.repeat = "";
    this.size = "";
    this.opacity = 1;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.color !== void 0) {
      this.color = OptionsColor.create(this.color, data2.color);
    }
    if (data2.image !== void 0) {
      this.image = data2.image;
    }
    if (data2.position !== void 0) {
      this.position = data2.position;
    }
    if (data2.repeat !== void 0) {
      this.repeat = data2.repeat;
    }
    if (data2.size !== void 0) {
      this.size = data2.size;
    }
    if (data2.opacity !== void 0) {
      this.opacity = data2.opacity;
    }
  }
};
class BackgroundMaskCover {
  constructor() {
    this.color = new OptionsColor();
    this.color.value = "#fff";
    this.opacity = 1;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.color !== void 0) {
      this.color = OptionsColor.create(this.color, data2.color);
    }
    if (data2.opacity !== void 0) {
      this.opacity = data2.opacity;
    }
  }
}
class BackgroundMask {
  constructor() {
    this.composite = "destination-out";
    this.cover = new BackgroundMaskCover();
    this.enable = false;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.composite !== void 0) {
      this.composite = data2.composite;
    }
    if (data2.cover !== void 0) {
      const cover = data2.cover;
      const color = isString(data2.cover) ? { color: data2.cover } : data2.cover;
      this.cover.load(cover.color !== void 0 ? cover : { color });
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
  }
}
class FullScreen {
  constructor() {
    this.enable = true;
    this.zIndex = 0;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    if (data2.zIndex !== void 0) {
      this.zIndex = data2.zIndex;
    }
  }
}
class ClickEvent {
  constructor() {
    this.enable = false;
    this.mode = [];
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    if (data2.mode !== void 0) {
      this.mode = data2.mode;
    }
  }
}
class DivEvent {
  constructor() {
    this.selectors = [];
    this.enable = false;
    this.mode = [];
    this.type = "circle";
  }
  get el() {
    return this.elementId;
  }
  set el(value) {
    this.elementId = value;
  }
  get elementId() {
    return this.ids;
  }
  set elementId(value) {
    this.ids = value;
  }
  get ids() {
    return executeOnSingleOrMultiple(this.selectors, (t2) => t2.replace("#", ""));
  }
  set ids(value) {
    this.selectors = executeOnSingleOrMultiple(value, (t2) => `#${t2}`);
  }
  load(data2) {
    if (!data2) {
      return;
    }
    const ids = data2.ids ?? data2.elementId ?? data2.el;
    if (ids !== void 0) {
      this.ids = ids;
    }
    if (data2.selectors !== void 0) {
      this.selectors = data2.selectors;
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    if (data2.mode !== void 0) {
      this.mode = data2.mode;
    }
    if (data2.type !== void 0) {
      this.type = data2.type;
    }
  }
}
class Parallax {
  constructor() {
    this.enable = false;
    this.force = 2;
    this.smooth = 10;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    if (data2.force !== void 0) {
      this.force = data2.force;
    }
    if (data2.smooth !== void 0) {
      this.smooth = data2.smooth;
    }
  }
}
class HoverEvent {
  constructor() {
    this.enable = false;
    this.mode = [];
    this.parallax = new Parallax();
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    if (data2.mode !== void 0) {
      this.mode = data2.mode;
    }
    this.parallax.load(data2.parallax);
  }
}
class ResizeEvent {
  constructor() {
    this.delay = 0.5;
    this.enable = true;
  }
  load(data2) {
    if (data2 === void 0) {
      return;
    }
    if (data2.delay !== void 0) {
      this.delay = data2.delay;
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
  }
}
class Events {
  constructor() {
    this.onClick = new ClickEvent();
    this.onDiv = new DivEvent();
    this.onHover = new HoverEvent();
    this.resize = new ResizeEvent();
  }
  get onclick() {
    return this.onClick;
  }
  set onclick(value) {
    this.onClick = value;
  }
  get ondiv() {
    return this.onDiv;
  }
  set ondiv(value) {
    this.onDiv = value;
  }
  get onhover() {
    return this.onHover;
  }
  set onhover(value) {
    this.onHover = value;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    this.onClick.load(data2.onClick ?? data2.onclick);
    const onDiv = data2.onDiv ?? data2.ondiv;
    if (onDiv !== void 0) {
      this.onDiv = executeOnSingleOrMultiple(onDiv, (t2) => {
        const tmp = new DivEvent();
        tmp.load(t2);
        return tmp;
      });
    }
    this.onHover.load(data2.onHover ?? data2.onhover);
    if (isBoolean(data2.resize)) {
      this.resize.enable = data2.resize;
    } else {
      this.resize.load(data2.resize);
    }
  }
}
class Modes {
  constructor(engine, container) {
    this._engine = engine;
    this._container = container;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (!this._container) {
      return;
    }
    const interactors = this._engine.plugins.interactors.get(this._container);
    if (!interactors) {
      return;
    }
    for (const interactor of interactors) {
      if (!interactor.loadModeOptions) {
        continue;
      }
      interactor.loadModeOptions(this, data2);
    }
  }
}
class Interactivity {
  constructor(engine, container) {
    this.detectsOn = "window";
    this.events = new Events();
    this.modes = new Modes(engine, container);
  }
  get detect_on() {
    return this.detectsOn;
  }
  set detect_on(value) {
    this.detectsOn = value;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    const detectsOn = data2.detectsOn ?? data2.detect_on;
    if (detectsOn !== void 0) {
      this.detectsOn = detectsOn;
    }
    this.events.load(data2.events);
    this.modes.load(data2.modes);
  }
}
class ManualParticle {
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.position) {
      this.position = {
        x: data2.position.x ?? 50,
        y: data2.position.y ?? 50,
        mode: data2.position.mode ?? "percent"
      };
    }
    if (data2.options) {
      this.options = deepExtend({}, data2.options);
    }
  }
}
class Responsive {
  constructor() {
    this.maxWidth = Infinity;
    this.options = {};
    this.mode = "canvas";
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.maxWidth !== void 0) {
      this.maxWidth = data2.maxWidth;
    }
    if (data2.mode !== void 0) {
      if (data2.mode === "screen") {
        this.mode = "screen";
      } else {
        this.mode = "canvas";
      }
    }
    if (data2.options !== void 0) {
      this.options = deepExtend({}, data2.options);
    }
  }
}
class ThemeDefault {
  constructor() {
    this.auto = false;
    this.mode = "any";
    this.value = false;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.auto !== void 0) {
      this.auto = data2.auto;
    }
    if (data2.mode !== void 0) {
      this.mode = data2.mode;
    }
    if (data2.value !== void 0) {
      this.value = data2.value;
    }
  }
}
class Theme {
  constructor() {
    this.name = "";
    this.default = new ThemeDefault();
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.name !== void 0) {
      this.name = data2.name;
    }
    this.default.load(data2.default);
    if (data2.options !== void 0) {
      this.options = deepExtend({}, data2.options);
    }
  }
}
class ColorAnimation {
  constructor() {
    this.count = 0;
    this.enable = false;
    this.offset = 0;
    this.speed = 1;
    this.delay = 0;
    this.decay = 0;
    this.sync = true;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.count !== void 0) {
      this.count = setRangeValue(data2.count);
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    if (data2.offset !== void 0) {
      this.offset = setRangeValue(data2.offset);
    }
    if (data2.speed !== void 0) {
      this.speed = setRangeValue(data2.speed);
    }
    if (data2.decay !== void 0) {
      this.decay = setRangeValue(data2.decay);
    }
    if (data2.delay !== void 0) {
      this.delay = setRangeValue(data2.delay);
    }
    if (data2.sync !== void 0) {
      this.sync = data2.sync;
    }
  }
}
class HslAnimation {
  constructor() {
    this.h = new ColorAnimation();
    this.s = new ColorAnimation();
    this.l = new ColorAnimation();
  }
  load(data2) {
    if (!data2) {
      return;
    }
    this.h.load(data2.h);
    this.s.load(data2.s);
    this.l.load(data2.l);
  }
}
class AnimatableColor extends OptionsColor {
  constructor() {
    super();
    this.animation = new HslAnimation();
  }
  static create(source, data2) {
    const color = new AnimatableColor();
    color.load(source);
    if (data2 !== void 0) {
      if (isString(data2) || isArray(data2)) {
        color.load({ value: data2 });
      } else {
        color.load(data2);
      }
    }
    return color;
  }
  load(data2) {
    super.load(data2);
    if (!data2) {
      return;
    }
    const colorAnimation = data2.animation;
    if (colorAnimation !== void 0) {
      if (colorAnimation.enable !== void 0) {
        this.animation.h.load(colorAnimation);
      } else {
        this.animation.load(data2.animation);
      }
    }
  }
}
class CollisionsAbsorb {
  constructor() {
    this.speed = 2;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.speed !== void 0) {
      this.speed = data2.speed;
    }
  }
}
class CollisionsOverlap {
  constructor() {
    this.enable = true;
    this.retries = 0;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    if (data2.retries !== void 0) {
      this.retries = data2.retries;
    }
  }
}
class AnimationOptions {
  constructor() {
    this.count = 0;
    this.enable = false;
    this.speed = 1;
    this.decay = 0;
    this.delay = 0;
    this.sync = false;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.count !== void 0) {
      this.count = setRangeValue(data2.count);
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    if (data2.speed !== void 0) {
      this.speed = setRangeValue(data2.speed);
    }
    if (data2.decay !== void 0) {
      this.decay = setRangeValue(data2.decay);
    }
    if (data2.delay !== void 0) {
      this.delay = setRangeValue(data2.delay);
    }
    if (data2.sync !== void 0) {
      this.sync = data2.sync;
    }
  }
}
class RangedAnimationOptions extends AnimationOptions {
  constructor() {
    super();
    this.mode = "auto";
    this.startValue = "random";
  }
  load(data2) {
    super.load(data2);
    if (!data2) {
      return;
    }
    if (data2.minimumValue !== void 0) {
      this.minimumValue = data2.minimumValue;
    }
    if (data2.mode !== void 0) {
      this.mode = data2.mode;
    }
    if (data2.startValue !== void 0) {
      this.startValue = data2.startValue;
    }
  }
}
class Random {
  constructor() {
    this.enable = false;
    this.minimumValue = 0;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    if (data2.minimumValue !== void 0) {
      this.minimumValue = data2.minimumValue;
    }
  }
}
class ValueWithRandom {
  constructor() {
    this.random = new Random();
    this.value = 0;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (isBoolean(data2.random)) {
      this.random.enable = data2.random;
    } else {
      this.random.load(data2.random);
    }
    if (data2.value !== void 0) {
      this.value = setRangeValue(data2.value, this.random.enable ? this.random.minimumValue : void 0);
    }
  }
}
class ParticlesBounceFactor extends ValueWithRandom {
  constructor() {
    super();
    this.random.minimumValue = 0.1;
    this.value = 1;
  }
}
class ParticlesBounce {
  constructor() {
    this.horizontal = new ParticlesBounceFactor();
    this.vertical = new ParticlesBounceFactor();
  }
  load(data2) {
    if (!data2) {
      return;
    }
    this.horizontal.load(data2.horizontal);
    this.vertical.load(data2.vertical);
  }
}
class Collisions {
  constructor() {
    this.absorb = new CollisionsAbsorb();
    this.bounce = new ParticlesBounce();
    this.enable = false;
    this.maxSpeed = 50;
    this.mode = "bounce";
    this.overlap = new CollisionsOverlap();
  }
  load(data2) {
    if (!data2) {
      return;
    }
    this.absorb.load(data2.absorb);
    this.bounce.load(data2.bounce);
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    if (data2.maxSpeed !== void 0) {
      this.maxSpeed = setRangeValue(data2.maxSpeed);
    }
    if (data2.mode !== void 0) {
      this.mode = data2.mode;
    }
    this.overlap.load(data2.overlap);
  }
}
class MoveAngle {
  constructor() {
    this.offset = 0;
    this.value = 90;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.offset !== void 0) {
      this.offset = setRangeValue(data2.offset);
    }
    if (data2.value !== void 0) {
      this.value = setRangeValue(data2.value);
    }
  }
}
class MoveAttract {
  constructor() {
    this.distance = 200;
    this.enable = false;
    this.rotate = {
      x: 3e3,
      y: 3e3
    };
  }
  get rotateX() {
    return this.rotate.x;
  }
  set rotateX(value) {
    this.rotate.x = value;
  }
  get rotateY() {
    return this.rotate.y;
  }
  set rotateY(value) {
    this.rotate.y = value;
  }
  load(data2) {
    var _a, _b;
    if (!data2) {
      return;
    }
    if (data2.distance !== void 0) {
      this.distance = setRangeValue(data2.distance);
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    const rotateX = ((_a = data2.rotate) == null ? void 0 : _a.x) ?? data2.rotateX;
    if (rotateX !== void 0) {
      this.rotate.x = rotateX;
    }
    const rotateY = ((_b = data2.rotate) == null ? void 0 : _b.y) ?? data2.rotateY;
    if (rotateY !== void 0) {
      this.rotate.y = rotateY;
    }
  }
}
class MoveCenter {
  constructor() {
    this.x = 50;
    this.y = 50;
    this.mode = "percent";
    this.radius = 0;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.x !== void 0) {
      this.x = data2.x;
    }
    if (data2.y !== void 0) {
      this.y = data2.y;
    }
    if (data2.mode !== void 0) {
      this.mode = data2.mode;
    }
    if (data2.radius !== void 0) {
      this.radius = data2.radius;
    }
  }
}
class MoveGravity {
  constructor() {
    this.acceleration = 9.81;
    this.enable = false;
    this.inverse = false;
    this.maxSpeed = 50;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.acceleration !== void 0) {
      this.acceleration = setRangeValue(data2.acceleration);
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    if (data2.inverse !== void 0) {
      this.inverse = data2.inverse;
    }
    if (data2.maxSpeed !== void 0) {
      this.maxSpeed = setRangeValue(data2.maxSpeed);
    }
  }
}
class MovePath {
  constructor() {
    this.clamp = true;
    this.delay = new ValueWithRandom();
    this.enable = false;
    this.options = {};
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.clamp !== void 0) {
      this.clamp = data2.clamp;
    }
    this.delay.load(data2.delay);
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    this.generator = data2.generator;
    if (data2.options) {
      this.options = deepExtend(this.options, data2.options);
    }
  }
}
class MoveTrailFill {
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.color !== void 0) {
      this.color = OptionsColor.create(this.color, data2.color);
    }
    if (data2.image !== void 0) {
      this.image = data2.image;
    }
  }
}
class MoveTrail {
  constructor() {
    this.enable = false;
    this.length = 10;
    this.fill = new MoveTrailFill();
  }
  get fillColor() {
    return this.fill.color;
  }
  set fillColor(value) {
    this.fill.load({ color: value });
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    if (data2.fill !== void 0 || data2.fillColor !== void 0) {
      this.fill.load(data2.fill || { color: data2.fillColor });
    }
    if (data2.length !== void 0) {
      this.length = data2.length;
    }
  }
}
class OutModes {
  constructor() {
    this.default = "out";
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.default !== void 0) {
      this.default = data2.default;
    }
    this.bottom = data2.bottom ?? data2.default;
    this.left = data2.left ?? data2.default;
    this.right = data2.right ?? data2.default;
    this.top = data2.top ?? data2.default;
  }
}
class Spin {
  constructor() {
    this.acceleration = 0;
    this.enable = false;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.acceleration !== void 0) {
      this.acceleration = setRangeValue(data2.acceleration);
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    if (data2.position) {
      this.position = deepExtend({}, data2.position);
    }
  }
}
class Move {
  constructor() {
    this.angle = new MoveAngle();
    this.attract = new MoveAttract();
    this.center = new MoveCenter();
    this.decay = 0;
    this.distance = {};
    this.direction = "none";
    this.drift = 0;
    this.enable = false;
    this.gravity = new MoveGravity();
    this.path = new MovePath();
    this.outModes = new OutModes();
    this.random = false;
    this.size = false;
    this.speed = 2;
    this.spin = new Spin();
    this.straight = false;
    this.trail = new MoveTrail();
    this.vibrate = false;
    this.warp = false;
  }
  get bounce() {
    return this.collisions;
  }
  set bounce(value) {
    this.collisions = value;
  }
  get collisions() {
    return false;
  }
  set collisions(_2) {
  }
  get noise() {
    return this.path;
  }
  set noise(value) {
    this.path = value;
  }
  get outMode() {
    return this.outModes.default;
  }
  set outMode(value) {
    this.outModes.default = value;
  }
  get out_mode() {
    return this.outMode;
  }
  set out_mode(value) {
    this.outMode = value;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    this.angle.load(isNumber(data2.angle) ? { value: data2.angle } : data2.angle);
    this.attract.load(data2.attract);
    this.center.load(data2.center);
    if (data2.decay !== void 0) {
      this.decay = setRangeValue(data2.decay);
    }
    if (data2.direction !== void 0) {
      this.direction = data2.direction;
    }
    if (data2.distance !== void 0) {
      this.distance = isNumber(data2.distance) ? {
        horizontal: data2.distance,
        vertical: data2.distance
      } : { ...data2.distance };
    }
    if (data2.drift !== void 0) {
      this.drift = setRangeValue(data2.drift);
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    this.gravity.load(data2.gravity);
    const outModes = data2.outModes ?? data2.outMode ?? data2.out_mode;
    if (outModes !== void 0) {
      if (isObject(outModes)) {
        this.outModes.load(outModes);
      } else {
        this.outModes.load({
          default: outModes
        });
      }
    }
    this.path.load(data2.path ?? data2.noise);
    if (data2.random !== void 0) {
      this.random = data2.random;
    }
    if (data2.size !== void 0) {
      this.size = data2.size;
    }
    if (data2.speed !== void 0) {
      this.speed = setRangeValue(data2.speed);
    }
    this.spin.load(data2.spin);
    if (data2.straight !== void 0) {
      this.straight = data2.straight;
    }
    this.trail.load(data2.trail);
    if (data2.vibrate !== void 0) {
      this.vibrate = data2.vibrate;
    }
    if (data2.warp !== void 0) {
      this.warp = data2.warp;
    }
  }
}
class OpacityAnimation extends RangedAnimationOptions {
  constructor() {
    super();
    this.destroy = "none";
    this.speed = 2;
  }
  get opacity_min() {
    return this.minimumValue;
  }
  set opacity_min(value) {
    this.minimumValue = value;
  }
  load(data2) {
    if ((data2 == null ? void 0 : data2.opacity_min) !== void 0 && data2.minimumValue === void 0) {
      data2.minimumValue = data2.opacity_min;
    }
    super.load(data2);
    if (!data2) {
      return;
    }
    if (data2.destroy !== void 0) {
      this.destroy = data2.destroy;
    }
  }
}
class Opacity extends ValueWithRandom {
  constructor() {
    super();
    this.animation = new OpacityAnimation();
    this.random.minimumValue = 0.1;
    this.value = 1;
  }
  get anim() {
    return this.animation;
  }
  set anim(value) {
    this.animation = value;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    super.load(data2);
    const animation = data2.animation ?? data2.anim;
    if (animation !== void 0) {
      this.animation.load(animation);
      this.value = setRangeValue(this.value, this.animation.enable ? this.animation.minimumValue : void 0);
    }
  }
}
class ParticlesDensity {
  constructor() {
    this.enable = false;
    this.width = 1920;
    this.height = 1080;
  }
  get area() {
    return this.width;
  }
  set area(value) {
    this.width = value;
  }
  get factor() {
    return this.height;
  }
  set factor(value) {
    this.height = value;
  }
  get value_area() {
    return this.area;
  }
  set value_area(value) {
    this.area = value;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    const width = data2.width ?? data2.area ?? data2.value_area;
    if (width !== void 0) {
      this.width = width;
    }
    const height = data2.height ?? data2.factor;
    if (height !== void 0) {
      this.height = height;
    }
  }
}
class ParticlesNumber {
  constructor() {
    this.density = new ParticlesDensity();
    this.limit = 0;
    this.value = 0;
  }
  get max() {
    return this.limit;
  }
  set max(value) {
    this.limit = value;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    this.density.load(data2.density);
    const limit = data2.limit ?? data2.max;
    if (limit !== void 0) {
      this.limit = limit;
    }
    if (data2.value !== void 0) {
      this.value = data2.value;
    }
  }
}
class Shadow {
  constructor() {
    this.blur = 0;
    this.color = new OptionsColor();
    this.enable = false;
    this.offset = {
      x: 0,
      y: 0
    };
    this.color.value = "#000";
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.blur !== void 0) {
      this.blur = data2.blur;
    }
    this.color = OptionsColor.create(this.color, data2.color);
    if (data2.enable !== void 0) {
      this.enable = data2.enable;
    }
    if (data2.offset === void 0) {
      return;
    }
    if (data2.offset.x !== void 0) {
      this.offset.x = data2.offset.x;
    }
    if (data2.offset.y !== void 0) {
      this.offset.y = data2.offset.y;
    }
  }
}
const charKey = "character", charAltKey = "char", imageKey = "image", imageAltKey = "images", polygonKey = "polygon", polygonAltKey = "star";
class Shape {
  constructor() {
    this.loadShape = (item, mainKey, altKey, altOverride) => {
      if (!item) {
        return;
      }
      const itemIsArray = isArray(item), emptyValue = itemIsArray ? [] : {}, mainDifferentValues = itemIsArray !== isArray(this.options[mainKey]), altDifferentValues = itemIsArray !== isArray(this.options[altKey]);
      if (mainDifferentValues) {
        this.options[mainKey] = emptyValue;
      }
      if (altDifferentValues && altOverride) {
        this.options[altKey] = emptyValue;
      }
      this.options[mainKey] = deepExtend(this.options[mainKey] ?? emptyValue, item);
      if (!this.options[altKey] || altOverride) {
        this.options[altKey] = deepExtend(this.options[altKey] ?? emptyValue, item);
      }
    };
    this.close = true;
    this.fill = true;
    this.options = {};
    this.type = "circle";
  }
  get character() {
    return this.options[charKey] ?? this.options[charAltKey];
  }
  set character(value) {
    this.options[charAltKey] = this.options[charKey] = value;
  }
  get custom() {
    return this.options;
  }
  set custom(value) {
    this.options = value;
  }
  get image() {
    return this.options[imageKey] ?? this.options[imageAltKey];
  }
  set image(value) {
    this.options[imageAltKey] = this.options[imageKey] = value;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
  get polygon() {
    return this.options[polygonKey] ?? this.options[polygonAltKey];
  }
  set polygon(value) {
    this.options[polygonAltKey] = this.options[polygonKey] = value;
  }
  get stroke() {
    return [];
  }
  set stroke(_value) {
  }
  load(data2) {
    if (!data2) {
      return;
    }
    const options2 = data2.options ?? data2.custom;
    if (options2 !== void 0) {
      for (const shape in options2) {
        const item = options2[shape];
        if (item) {
          this.options[shape] = deepExtend(this.options[shape] ?? {}, item);
        }
      }
    }
    this.loadShape(data2.character, charKey, charAltKey, true);
    this.loadShape(data2.polygon, polygonKey, polygonAltKey, false);
    this.loadShape(data2.image ?? data2.images, imageKey, imageAltKey, true);
    if (data2.close !== void 0) {
      this.close = data2.close;
    }
    if (data2.fill !== void 0) {
      this.fill = data2.fill;
    }
    if (data2.type !== void 0) {
      this.type = data2.type;
    }
  }
}
class SizeAnimation extends RangedAnimationOptions {
  constructor() {
    super();
    this.destroy = "none";
    this.speed = 5;
  }
  get size_min() {
    return this.minimumValue;
  }
  set size_min(value) {
    this.minimumValue = value;
  }
  load(data2) {
    if ((data2 == null ? void 0 : data2.size_min) !== void 0 && data2.minimumValue === void 0) {
      data2.minimumValue = data2.size_min;
    }
    super.load(data2);
    if (!data2) {
      return;
    }
    if (data2.destroy !== void 0) {
      this.destroy = data2.destroy;
    }
  }
}
class Size extends ValueWithRandom {
  constructor() {
    super();
    this.animation = new SizeAnimation();
    this.random.minimumValue = 1;
    this.value = 3;
  }
  get anim() {
    return this.animation;
  }
  set anim(value) {
    this.animation = value;
  }
  load(data2) {
    super.load(data2);
    if (!data2) {
      return;
    }
    const animation = data2.animation ?? data2.anim;
    if (animation !== void 0) {
      this.animation.load(animation);
      this.value = setRangeValue(this.value, this.animation.enable ? this.animation.minimumValue : void 0);
    }
  }
}
class Stroke {
  constructor() {
    this.width = 0;
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.color !== void 0) {
      this.color = AnimatableColor.create(this.color, data2.color);
    }
    if (data2.width !== void 0) {
      this.width = setRangeValue(data2.width);
    }
    if (data2.opacity !== void 0) {
      this.opacity = setRangeValue(data2.opacity);
    }
  }
}
class ZIndex extends ValueWithRandom {
  constructor() {
    super();
    this.opacityRate = 1;
    this.sizeRate = 1;
    this.velocityRate = 1;
  }
  load(data2) {
    super.load(data2);
    if (!data2) {
      return;
    }
    if (data2.opacityRate !== void 0) {
      this.opacityRate = data2.opacityRate;
    }
    if (data2.sizeRate !== void 0) {
      this.sizeRate = data2.sizeRate;
    }
    if (data2.velocityRate !== void 0) {
      this.velocityRate = data2.velocityRate;
    }
  }
}
class ParticlesOptions {
  constructor(engine, container) {
    this._engine = engine;
    this._container = container;
    this.bounce = new ParticlesBounce();
    this.collisions = new Collisions();
    this.color = new AnimatableColor();
    this.color.value = "#fff";
    this.groups = {};
    this.move = new Move();
    this.number = new ParticlesNumber();
    this.opacity = new Opacity();
    this.reduceDuplicates = false;
    this.shadow = new Shadow();
    this.shape = new Shape();
    this.size = new Size();
    this.stroke = new Stroke();
    this.zIndex = new ZIndex();
  }
  load(data2) {
    var _a, _b, _c;
    if (!data2) {
      return;
    }
    this.bounce.load(data2.bounce);
    this.color.load(AnimatableColor.create(this.color, data2.color));
    if (data2.groups !== void 0) {
      for (const group in data2.groups) {
        const item = data2.groups[group];
        if (item !== void 0) {
          this.groups[group] = deepExtend(this.groups[group] ?? {}, item);
        }
      }
    }
    this.move.load(data2.move);
    this.number.load(data2.number);
    this.opacity.load(data2.opacity);
    if (data2.reduceDuplicates !== void 0) {
      this.reduceDuplicates = data2.reduceDuplicates;
    }
    this.shape.load(data2.shape);
    this.size.load(data2.size);
    this.shadow.load(data2.shadow);
    this.zIndex.load(data2.zIndex);
    const collisions = ((_a = data2.move) == null ? void 0 : _a.collisions) ?? ((_b = data2.move) == null ? void 0 : _b.bounce);
    if (collisions !== void 0) {
      this.collisions.enable = collisions;
    }
    this.collisions.load(data2.collisions);
    if (data2.interactivity !== void 0) {
      this.interactivity = deepExtend({}, data2.interactivity);
    }
    const strokeToLoad = data2.stroke ?? ((_c = data2.shape) == null ? void 0 : _c.stroke);
    if (strokeToLoad) {
      this.stroke = executeOnSingleOrMultiple(strokeToLoad, (t2) => {
        const tmp = new Stroke();
        tmp.load(t2);
        return tmp;
      });
    }
    if (this._container) {
      const updaters = this._engine.plugins.updaters.get(this._container);
      if (updaters) {
        for (const updater of updaters) {
          if (updater.loadOptions) {
            updater.loadOptions(this, data2);
          }
        }
      }
      const interactors = this._engine.plugins.interactors.get(this._container);
      if (interactors) {
        for (const interactor of interactors) {
          if (interactor.loadParticlesOptions) {
            interactor.loadParticlesOptions(this, data2);
          }
        }
      }
    }
  }
}
function loadOptions(options2, ...sourceOptionsArr) {
  for (const sourceOptions of sourceOptionsArr) {
    options2.load(sourceOptions);
  }
}
function loadParticlesOptions(engine, container, ...sourceOptionsArr) {
  const options2 = new ParticlesOptions(engine, container);
  loadOptions(options2, ...sourceOptionsArr);
  return options2;
}
let Options$1 = class Options3 {
  constructor(engine, container) {
    this._findDefaultTheme = (mode) => {
      return this.themes.find((theme) => theme.default.value && theme.default.mode === mode) ?? this.themes.find((theme) => theme.default.value && theme.default.mode === "any");
    };
    this._importPreset = (preset) => {
      this.load(this._engine.plugins.getPreset(preset));
    };
    this._engine = engine;
    this._container = container;
    this.autoPlay = true;
    this.background = new Background$2();
    this.backgroundMask = new BackgroundMask();
    this.defaultThemes = {};
    this.delay = 0;
    this.fullScreen = new FullScreen();
    this.detectRetina = true;
    this.duration = 0;
    this.fpsLimit = 120;
    this.interactivity = new Interactivity(engine, container);
    this.manualParticles = [];
    this.particles = loadParticlesOptions(this._engine, this._container);
    this.pauseOnBlur = true;
    this.pauseOnOutsideViewport = true;
    this.responsive = [];
    this.smooth = false;
    this.style = {};
    this.themes = [];
    this.zLayers = 100;
  }
  get backgroundMode() {
    return this.fullScreen;
  }
  set backgroundMode(value) {
    this.fullScreen.load(value);
  }
  get fps_limit() {
    return this.fpsLimit;
  }
  set fps_limit(value) {
    this.fpsLimit = value;
  }
  get retina_detect() {
    return this.detectRetina;
  }
  set retina_detect(value) {
    this.detectRetina = value;
  }
  load(data2) {
    var _a, _b;
    if (!data2) {
      return;
    }
    if (data2.preset !== void 0) {
      executeOnSingleOrMultiple(data2.preset, (preset) => this._importPreset(preset));
    }
    if (data2.autoPlay !== void 0) {
      this.autoPlay = data2.autoPlay;
    }
    if (data2.delay !== void 0) {
      this.delay = setRangeValue(data2.delay);
    }
    const detectRetina = data2.detectRetina ?? data2.retina_detect;
    if (detectRetina !== void 0) {
      this.detectRetina = detectRetina;
    }
    if (data2.duration !== void 0) {
      this.duration = setRangeValue(data2.duration);
    }
    const fpsLimit = data2.fpsLimit ?? data2.fps_limit;
    if (fpsLimit !== void 0) {
      this.fpsLimit = fpsLimit;
    }
    if (data2.pauseOnBlur !== void 0) {
      this.pauseOnBlur = data2.pauseOnBlur;
    }
    if (data2.pauseOnOutsideViewport !== void 0) {
      this.pauseOnOutsideViewport = data2.pauseOnOutsideViewport;
    }
    if (data2.zLayers !== void 0) {
      this.zLayers = data2.zLayers;
    }
    this.background.load(data2.background);
    const fullScreen = data2.fullScreen ?? data2.backgroundMode;
    if (isBoolean(fullScreen)) {
      this.fullScreen.enable = fullScreen;
    } else {
      this.fullScreen.load(fullScreen);
    }
    this.backgroundMask.load(data2.backgroundMask);
    this.interactivity.load(data2.interactivity);
    if (data2.manualParticles) {
      this.manualParticles = data2.manualParticles.map((t2) => {
        const tmp = new ManualParticle();
        tmp.load(t2);
        return tmp;
      });
    }
    this.particles.load(data2.particles);
    this.style = deepExtend(this.style, data2.style);
    this._engine.plugins.loadOptions(this, data2);
    if (data2.smooth !== void 0) {
      this.smooth = data2.smooth;
    }
    const interactors = this._engine.plugins.interactors.get(this._container);
    if (interactors) {
      for (const interactor of interactors) {
        if (interactor.loadOptions) {
          interactor.loadOptions(this, data2);
        }
      }
    }
    if (data2.responsive !== void 0) {
      for (const responsive of data2.responsive) {
        const optResponsive = new Responsive();
        optResponsive.load(responsive);
        this.responsive.push(optResponsive);
      }
    }
    this.responsive.sort((a2, b2) => a2.maxWidth - b2.maxWidth);
    if (data2.themes !== void 0) {
      for (const theme of data2.themes) {
        const existingTheme = this.themes.find((t2) => t2.name === theme.name);
        if (!existingTheme) {
          const optTheme = new Theme();
          optTheme.load(theme);
          this.themes.push(optTheme);
        } else {
          existingTheme.load(theme);
        }
      }
    }
    this.defaultThemes.dark = (_a = this._findDefaultTheme("dark")) == null ? void 0 : _a.name;
    this.defaultThemes.light = (_b = this._findDefaultTheme("light")) == null ? void 0 : _b.name;
  }
  setResponsive(width, pxRatio, defaultOptions2) {
    this.load(defaultOptions2);
    const responsiveOptions = this.responsive.find((t2) => t2.mode === "screen" && screen ? t2.maxWidth > screen.availWidth : t2.maxWidth * pxRatio > width);
    this.load(responsiveOptions == null ? void 0 : responsiveOptions.options);
    return responsiveOptions == null ? void 0 : responsiveOptions.maxWidth;
  }
  setTheme(name) {
    if (name) {
      const chosenTheme = this.themes.find((theme) => theme.name === name);
      if (chosenTheme) {
        this.load(chosenTheme.options);
      }
    } else {
      const mediaMatch = safeMatchMedia("(prefers-color-scheme: dark)"), clientDarkMode = mediaMatch && mediaMatch.matches, defaultTheme = this._findDefaultTheme(clientDarkMode ? "dark" : "light");
      if (defaultTheme) {
        this.load(defaultTheme.options);
      }
    }
  }
};
class InteractionManager {
  constructor(engine, container) {
    this.container = container;
    this._engine = engine;
    this._interactors = engine.plugins.getInteractors(this.container, true);
    this._externalInteractors = [];
    this._particleInteractors = [];
  }
  async externalInteract(delta) {
    for (const interactor of this._externalInteractors) {
      interactor.isEnabled() && await interactor.interact(delta);
    }
  }
  handleClickMode(mode) {
    for (const interactor of this._externalInteractors) {
      interactor.handleClickMode && interactor.handleClickMode(mode);
    }
  }
  init() {
    this._externalInteractors = [];
    this._particleInteractors = [];
    for (const interactor of this._interactors) {
      switch (interactor.type) {
        case "external":
          this._externalInteractors.push(interactor);
          break;
        case "particles":
          this._particleInteractors.push(interactor);
          break;
      }
      interactor.init();
    }
  }
  async particlesInteract(particle, delta) {
    for (const interactor of this._externalInteractors) {
      interactor.clear(particle, delta);
    }
    for (const interactor of this._particleInteractors) {
      interactor.isEnabled(particle) && await interactor.interact(particle, delta);
    }
  }
  async reset(particle) {
    for (const interactor of this._externalInteractors) {
      interactor.isEnabled() && interactor.reset(particle);
    }
    for (const interactor of this._particleInteractors) {
      interactor.isEnabled(particle) && interactor.reset(particle);
    }
  }
}
const fixOutMode = (data2) => {
  if (!isInArray(data2.outMode, data2.checkModes)) {
    return;
  }
  const diameter = data2.radius * 2;
  if (data2.coord > data2.maxCoord - diameter) {
    data2.setCb(-data2.radius);
  } else if (data2.coord < diameter) {
    data2.setCb(data2.radius);
  }
};
class Particle {
  constructor(engine, id, container, position, overrideOptions, group) {
    this.container = container;
    this._calcPosition = (container2, position2, zIndex, tryCount = 0) => {
      for (const [, plugin] of container2.plugins) {
        const pluginPos = plugin.particlePosition !== void 0 ? plugin.particlePosition(position2, this) : void 0;
        if (pluginPos) {
          return Vector3d.create(pluginPos.x, pluginPos.y, zIndex);
        }
      }
      const canvasSize = container2.canvas.size, exactPosition = calcExactPositionOrRandomFromSize({
        size: canvasSize,
        position: position2
      }), pos = Vector3d.create(exactPosition.x, exactPosition.y, zIndex), radius = this.getRadius(), outModes = this.options.move.outModes, fixHorizontal = (outMode) => {
        fixOutMode({
          outMode,
          checkModes: ["bounce", "bounce-horizontal"],
          coord: pos.x,
          maxCoord: container2.canvas.size.width,
          setCb: (value) => pos.x += value,
          radius
        });
      }, fixVertical = (outMode) => {
        fixOutMode({
          outMode,
          checkModes: ["bounce", "bounce-vertical"],
          coord: pos.y,
          maxCoord: container2.canvas.size.height,
          setCb: (value) => pos.y += value,
          radius
        });
      };
      fixHorizontal(outModes.left ?? outModes.default);
      fixHorizontal(outModes.right ?? outModes.default);
      fixVertical(outModes.top ?? outModes.default);
      fixVertical(outModes.bottom ?? outModes.default);
      if (this._checkOverlap(pos, tryCount)) {
        return this._calcPosition(container2, void 0, zIndex, tryCount + 1);
      }
      return pos;
    };
    this._calculateVelocity = () => {
      const baseVelocity = getParticleBaseVelocity(this.direction), res = baseVelocity.copy(), moveOptions = this.options.move;
      if (moveOptions.direction === "inside" || moveOptions.direction === "outside") {
        return res;
      }
      const rad = Math.PI / 180 * getRangeValue(moveOptions.angle.value), radOffset = Math.PI / 180 * getRangeValue(moveOptions.angle.offset), range = {
        left: radOffset - rad / 2,
        right: radOffset + rad / 2
      };
      if (!moveOptions.straight) {
        res.angle += randomInRange(setRangeValue(range.left, range.right));
      }
      if (moveOptions.random && typeof moveOptions.speed === "number") {
        res.length *= getRandom();
      }
      return res;
    };
    this._checkOverlap = (pos, tryCount = 0) => {
      const collisionsOptions = this.options.collisions, radius = this.getRadius();
      if (!collisionsOptions.enable) {
        return false;
      }
      const overlapOptions = collisionsOptions.overlap;
      if (overlapOptions.enable) {
        return false;
      }
      const retries = overlapOptions.retries;
      if (retries >= 0 && tryCount > retries) {
        throw new Error(`${errorPrefix} particle is overlapping and can't be placed`);
      }
      return !!this.container.particles.find((particle) => getDistance(pos, particle.position) < radius + particle.getRadius());
    };
    this._getRollColor = (color) => {
      if (!color || !this.roll || !this.backColor && !this.roll.alter) {
        return color;
      }
      const backFactor = this.roll.horizontal && this.roll.vertical ? 2 : 1, backSum = this.roll.horizontal ? Math.PI / 2 : 0, rolled = Math.floor(((this.roll.angle ?? 0) + backSum) / (Math.PI / backFactor)) % 2;
      if (!rolled) {
        return color;
      }
      if (this.backColor) {
        return this.backColor;
      }
      if (this.roll.alter) {
        return alterHsl(color, this.roll.alter.type, this.roll.alter.value);
      }
      return color;
    };
    this._initPosition = (position2) => {
      const container2 = this.container, zIndexValue = getRangeValue(this.options.zIndex.value);
      this.position = this._calcPosition(container2, position2, clamp(zIndexValue, 0, container2.zLayers));
      this.initialPosition = this.position.copy();
      const canvasSize = container2.canvas.size;
      this.moveCenter = {
        ...getPosition(this.options.move.center, canvasSize),
        radius: this.options.move.center.radius ?? 0,
        mode: this.options.move.center.mode ?? "percent"
      };
      this.direction = getParticleDirectionAngle(this.options.move.direction, this.position, this.moveCenter);
      switch (this.options.move.direction) {
        case "inside":
          this.outType = "inside";
          break;
        case "outside":
          this.outType = "outside";
          break;
      }
      this.offset = Vector.origin;
    };
    this._loadShapeData = (shapeOptions, reduceDuplicates) => {
      const shapeData = shapeOptions.options[this.shape];
      if (!shapeData) {
        return;
      }
      return deepExtend({
        close: shapeOptions.close,
        fill: shapeOptions.fill
      }, itemFromSingleOrMultiple(shapeData, this.id, reduceDuplicates));
    };
    this._engine = engine;
    this.init(id, position, overrideOptions, group);
  }
  destroy(override) {
    if (this.unbreakable || this.destroyed) {
      return;
    }
    this.destroyed = true;
    this.bubble.inRange = false;
    this.slow.inRange = false;
    const container = this.container, pathGenerator = this.pathGenerator;
    for (const [, plugin] of container.plugins) {
      if (plugin.particleDestroyed) {
        plugin.particleDestroyed(this, override);
      }
    }
    for (const updater of container.particles.updaters) {
      if (updater.particleDestroyed) {
        updater.particleDestroyed(this, override);
      }
    }
    if (pathGenerator) {
      pathGenerator.reset(this);
    }
  }
  draw(delta) {
    const container = this.container;
    for (const [, plugin] of container.plugins) {
      container.canvas.drawParticlePlugin(plugin, this, delta);
    }
    container.canvas.drawParticle(this, delta);
  }
  getFillColor() {
    return this._getRollColor(this.bubble.color ?? getHslFromAnimation(this.color));
  }
  getMass() {
    return this.getRadius() ** 2 * Math.PI / 2;
  }
  getPosition() {
    return {
      x: this.position.x + this.offset.x,
      y: this.position.y + this.offset.y,
      z: this.position.z
    };
  }
  getRadius() {
    return this.bubble.radius ?? this.size.value;
  }
  getStrokeColor() {
    return this._getRollColor(this.bubble.color ?? getHslFromAnimation(this.strokeColor));
  }
  init(id, position, overrideOptions, group) {
    const container = this.container, engine = this._engine;
    this.id = id;
    this.group = group;
    this.fill = true;
    this.pathRotation = false;
    this.close = true;
    this.lastPathTime = 0;
    this.destroyed = false;
    this.unbreakable = false;
    this.rotation = 0;
    this.misplaced = false;
    this.retina = {
      maxDistance: {}
    };
    this.outType = "normal";
    this.ignoresResizeRatio = true;
    const pxRatio = container.retina.pixelRatio, mainOptions = container.actualOptions, particlesOptions = loadParticlesOptions(this._engine, container, mainOptions.particles), shapeType = particlesOptions.shape.type, { reduceDuplicates } = particlesOptions;
    this.shape = itemFromSingleOrMultiple(shapeType, this.id, reduceDuplicates);
    const shapeOptions = particlesOptions.shape;
    if (overrideOptions && overrideOptions.shape && overrideOptions.shape.type) {
      const overrideShapeType = overrideOptions.shape.type, shape = itemFromSingleOrMultiple(overrideShapeType, this.id, reduceDuplicates);
      if (shape) {
        this.shape = shape;
        shapeOptions.load(overrideOptions.shape);
      }
    }
    this.shapeData = this._loadShapeData(shapeOptions, reduceDuplicates);
    particlesOptions.load(overrideOptions);
    const shapeData = this.shapeData;
    if (shapeData) {
      particlesOptions.load(shapeData.particles);
    }
    const interactivity = new Interactivity(engine, container);
    interactivity.load(container.actualOptions.interactivity);
    interactivity.load(particlesOptions.interactivity);
    this.interactivity = interactivity;
    this.fill = (shapeData == null ? void 0 : shapeData.fill) ?? particlesOptions.shape.fill;
    this.close = (shapeData == null ? void 0 : shapeData.close) ?? particlesOptions.shape.close;
    this.options = particlesOptions;
    const pathOptions = this.options.move.path;
    this.pathDelay = getValue(pathOptions.delay) * 1e3;
    if (pathOptions.generator) {
      this.pathGenerator = this._engine.plugins.getPathGenerator(pathOptions.generator);
      if (this.pathGenerator && container.addPath(pathOptions.generator, this.pathGenerator)) {
        this.pathGenerator.init(container);
      }
    }
    container.retina.initParticle(this);
    this.size = initParticleNumericAnimationValue(this.options.size, pxRatio);
    this.bubble = {
      inRange: false
    };
    this.slow = {
      inRange: false,
      factor: 1
    };
    this._initPosition(position);
    this.initialVelocity = this._calculateVelocity();
    this.velocity = this.initialVelocity.copy();
    this.moveDecay = 1 - getRangeValue(this.options.move.decay);
    const particles = container.particles;
    particles.needsSort = particles.needsSort || particles.lastZIndex < this.position.z;
    particles.lastZIndex = this.position.z;
    this.zIndexFactor = this.position.z / container.zLayers;
    this.sides = 24;
    let drawer = container.drawers.get(this.shape);
    if (!drawer) {
      drawer = this._engine.plugins.getShapeDrawer(this.shape);
      if (drawer) {
        container.drawers.set(this.shape, drawer);
      }
    }
    if (drawer && drawer.loadShape) {
      drawer.loadShape(this);
    }
    const sideCountFunc = drawer == null ? void 0 : drawer.getSidesCount;
    if (sideCountFunc) {
      this.sides = sideCountFunc(this);
    }
    this.spawning = false;
    this.shadowColor = rangeColorToRgb(this.options.shadow.color);
    for (const updater of container.particles.updaters) {
      updater.init(this);
    }
    for (const mover of container.particles.movers) {
      mover.init && mover.init(this);
    }
    if (drawer && drawer.particleInit) {
      drawer.particleInit(container, this);
    }
    for (const [, plugin] of container.plugins) {
      plugin.particleCreated && plugin.particleCreated(this);
    }
  }
  isInsideCanvas() {
    const radius = this.getRadius(), canvasSize = this.container.canvas.size, position = this.position;
    return position.x >= -radius && position.y >= -radius && position.y <= canvasSize.height + radius && position.x <= canvasSize.width + radius;
  }
  isVisible() {
    return !this.destroyed && !this.spawning && this.isInsideCanvas();
  }
  reset() {
    for (const updater of this.container.particles.updaters) {
      updater.reset && updater.reset(this);
    }
  }
}
class Point {
  constructor(position, particle) {
    this.position = position;
    this.particle = particle;
  }
}
class Range {
  constructor(x2, y2) {
    this.position = {
      x: x2,
      y: y2
    };
  }
}
class Rectangle extends Range {
  constructor(x2, y2, width, height) {
    super(x2, y2);
    this.size = {
      height,
      width
    };
  }
  contains(point) {
    const w2 = this.size.width, h2 = this.size.height, pos = this.position;
    return point.x >= pos.x && point.x <= pos.x + w2 && point.y >= pos.y && point.y <= pos.y + h2;
  }
  intersects(range) {
    if (range instanceof Circle) {
      range.intersects(this);
    }
    const w2 = this.size.width, h2 = this.size.height, pos1 = this.position, pos2 = range.position, size2 = range instanceof Rectangle ? range.size : { width: 0, height: 0 }, w22 = size2.width, h22 = size2.height;
    return pos2.x < pos1.x + w2 && pos2.x + w22 > pos1.x && pos2.y < pos1.y + h2 && pos2.y + h22 > pos1.y;
  }
}
class Circle extends Range {
  constructor(x2, y2, radius) {
    super(x2, y2);
    this.radius = radius;
  }
  contains(point) {
    return getDistance(point, this.position) <= this.radius;
  }
  intersects(range) {
    const pos1 = this.position, pos2 = range.position, distPos = { x: Math.abs(pos2.x - pos1.x), y: Math.abs(pos2.y - pos1.y) }, r2 = this.radius;
    if (range instanceof Circle) {
      const rSum = r2 + range.radius, dist = Math.sqrt(distPos.x ** 2 + distPos.y ** 2);
      return rSum > dist;
    } else if (range instanceof Rectangle) {
      const { width, height } = range.size, edges = Math.pow(distPos.x - width, 2) + Math.pow(distPos.y - height, 2);
      return edges <= r2 ** 2 || distPos.x <= r2 + width && distPos.y <= r2 + height || distPos.x <= width || distPos.y <= height;
    }
    return false;
  }
}
class QuadTree {
  constructor(rectangle, capacity) {
    this.rectangle = rectangle;
    this.capacity = capacity;
    this._subdivide = () => {
      const { x: x2, y: y2 } = this.rectangle.position, { width, height } = this.rectangle.size, { capacity: capacity2 } = this;
      for (let i2 = 0; i2 < 4; i2++) {
        this._subs.push(new QuadTree(new Rectangle(x2 + width / 2 * (i2 % 2), y2 + height / 2 * (Math.round(i2 / 2) - i2 % 2), width / 2, height / 2), capacity2));
      }
      this._divided = true;
    };
    this._points = [];
    this._divided = false;
    this._subs = [];
  }
  insert(point) {
    if (!this.rectangle.contains(point.position)) {
      return false;
    }
    if (this._points.length < this.capacity) {
      this._points.push(point);
      return true;
    }
    if (!this._divided) {
      this._subdivide();
    }
    return this._subs.some((sub) => sub.insert(point));
  }
  query(range, check, found) {
    const res = found || [];
    if (!range.intersects(this.rectangle)) {
      return [];
    }
    for (const p2 of this._points) {
      if (!range.contains(p2.position) && getDistance(range.position, p2.position) > p2.particle.getRadius() && (!check || check(p2.particle))) {
        continue;
      }
      res.push(p2.particle);
    }
    if (this._divided) {
      for (const sub of this._subs) {
        sub.query(range, check, res);
      }
    }
    return res;
  }
  queryCircle(position, radius, check) {
    return this.query(new Circle(position.x, position.y, radius), check);
  }
  queryRectangle(position, size, check) {
    return this.query(new Rectangle(position.x, position.y, size.width, size.height), check);
  }
}
const qTreeCapacity = 4;
const qTreeRectangle = (canvasSize) => {
  return new Rectangle(-canvasSize.width / 4, -canvasSize.height / 4, canvasSize.width * 3 / 2, canvasSize.height * 3 / 2);
};
class Particles {
  constructor(engine, container) {
    this._applyDensity = (options2, manualCount, group) => {
      var _a;
      if (!((_a = options2.number.density) == null ? void 0 : _a.enable)) {
        return;
      }
      const numberOptions = options2.number, densityFactor = this._initDensityFactor(numberOptions.density), optParticlesNumber = numberOptions.value, optParticlesLimit = numberOptions.limit > 0 ? numberOptions.limit : optParticlesNumber, particlesNumber = Math.min(optParticlesNumber, optParticlesLimit) * densityFactor + manualCount, particlesCount = Math.min(this.count, this.filter((t2) => t2.group === group).length);
      this.limit = numberOptions.limit * densityFactor;
      if (particlesCount < particlesNumber) {
        this.push(Math.abs(particlesNumber - particlesCount), void 0, options2, group);
      } else if (particlesCount > particlesNumber) {
        this.removeQuantity(particlesCount - particlesNumber, group);
      }
    };
    this._initDensityFactor = (densityOptions) => {
      const container2 = this._container;
      if (!container2.canvas.element || !densityOptions.enable) {
        return 1;
      }
      const canvas = container2.canvas.element, pxRatio = container2.retina.pixelRatio;
      return canvas.width * canvas.height / (densityOptions.factor * pxRatio ** 2 * densityOptions.area);
    };
    this._pushParticle = (position, overrideOptions, group, initializer) => {
      try {
        let particle = this.pool.pop();
        if (particle) {
          particle.init(this._nextId, position, overrideOptions, group);
        } else {
          particle = new Particle(this._engine, this._nextId, this._container, position, overrideOptions, group);
        }
        let canAdd = true;
        if (initializer) {
          canAdd = initializer(particle);
        }
        if (!canAdd) {
          return;
        }
        this._array.push(particle);
        this._zArray.push(particle);
        this._nextId++;
        this._engine.dispatchEvent("particleAdded", {
          container: this._container,
          data: {
            particle
          }
        });
        return particle;
      } catch (e2) {
        getLogger().warning(`${errorPrefix} adding particle: ${e2}`);
        return;
      }
    };
    this._removeParticle = (index, group, override) => {
      const particle = this._array[index];
      if (!particle || particle.group !== group) {
        return false;
      }
      particle.destroy(override);
      const zIdx = this._zArray.indexOf(particle);
      this._array.splice(index, 1);
      this._zArray.splice(zIdx, 1);
      this.pool.push(particle);
      this._engine.dispatchEvent("particleRemoved", {
        container: this._container,
        data: {
          particle
        }
      });
      return true;
    };
    this._engine = engine;
    this._container = container;
    this._nextId = 0;
    this._array = [];
    this._zArray = [];
    this.pool = [];
    this.limit = 0;
    this.needsSort = false;
    this.lastZIndex = 0;
    this._interactionManager = new InteractionManager(engine, container);
    const canvasSize = container.canvas.size;
    this.quadTree = new QuadTree(qTreeRectangle(canvasSize), qTreeCapacity);
    this.movers = this._engine.plugins.getMovers(container, true);
    this.updaters = this._engine.plugins.getUpdaters(container, true);
  }
  get count() {
    return this._array.length;
  }
  addManualParticles() {
    const container = this._container, options2 = container.actualOptions;
    for (const particle of options2.manualParticles) {
      this.addParticle(particle.position ? getPosition(particle.position, container.canvas.size) : void 0, particle.options);
    }
  }
  addParticle(position, overrideOptions, group, initializer) {
    const container = this._container, options2 = container.actualOptions, limit = options2.particles.number.limit;
    if (limit > 0) {
      const countToRemove = this.count + 1 - limit;
      if (countToRemove > 0) {
        this.removeQuantity(countToRemove);
      }
    }
    return this._pushParticle(position, overrideOptions, group, initializer);
  }
  clear() {
    this._array = [];
    this._zArray = [];
  }
  destroy() {
    this._array = [];
    this._zArray = [];
    this.movers = [];
    this.updaters = [];
  }
  async draw(delta) {
    const container = this._container;
    container.canvas.clear();
    await this.update(delta);
    for (const [, plugin] of container.plugins) {
      container.canvas.drawPlugin(plugin, delta);
    }
    for (const p2 of this._zArray) {
      p2.draw(delta);
    }
  }
  filter(condition) {
    return this._array.filter(condition);
  }
  find(condition) {
    return this._array.find(condition);
  }
  handleClickMode(mode) {
    this._interactionManager.handleClickMode(mode);
  }
  init() {
    var _a;
    const container = this._container, options2 = container.actualOptions;
    this.lastZIndex = 0;
    this.needsSort = false;
    let handled = false;
    this.updaters = this._engine.plugins.getUpdaters(container, true);
    this._interactionManager.init();
    for (const [, plugin] of container.plugins) {
      if (plugin.particlesInitialization !== void 0) {
        handled = plugin.particlesInitialization();
      }
      if (handled) {
        break;
      }
    }
    this._interactionManager.init();
    for (const [, pathGenerator] of container.pathGenerators) {
      pathGenerator.init(container);
    }
    this.addManualParticles();
    if (!handled) {
      for (const group in options2.particles.groups) {
        const groupOptions = options2.particles.groups[group];
        for (let i2 = this.count, j2 = 0; j2 < ((_a = groupOptions.number) == null ? void 0 : _a.value) && i2 < options2.particles.number.value; i2++, j2++) {
          this.addParticle(void 0, groupOptions, group);
        }
      }
      for (let i2 = this.count; i2 < options2.particles.number.value; i2++) {
        this.addParticle();
      }
    }
  }
  push(nb, mouse, overrideOptions, group) {
    this.pushing = true;
    for (let i2 = 0; i2 < nb; i2++) {
      this.addParticle(mouse == null ? void 0 : mouse.position, overrideOptions, group);
    }
    this.pushing = false;
  }
  async redraw() {
    this.clear();
    this.init();
    await this.draw({ value: 0, factor: 0 });
  }
  remove(particle, group, override) {
    this.removeAt(this._array.indexOf(particle), void 0, group, override);
  }
  removeAt(index, quantity = 1, group, override) {
    if (index < 0 || index > this.count) {
      return;
    }
    let deleted = 0;
    for (let i2 = index; deleted < quantity && i2 < this.count; i2++) {
      this._removeParticle(i2--, group, override) && deleted++;
    }
  }
  removeQuantity(quantity, group) {
    this.removeAt(0, quantity, group);
  }
  setDensity() {
    const options2 = this._container.actualOptions, groups = options2.particles.groups;
    for (const group in groups) {
      this._applyDensity(groups[group], 0, group);
    }
    this._applyDensity(options2.particles, options2.manualParticles.length);
  }
  async update(delta) {
    const container = this._container, particlesToDelete = /* @__PURE__ */ new Set();
    this.quadTree = new QuadTree(qTreeRectangle(container.canvas.size), qTreeCapacity);
    for (const [, pathGenerator] of container.pathGenerators) {
      pathGenerator.update();
    }
    for (const [, plugin] of container.plugins) {
      plugin.update && plugin.update(delta);
    }
    for (const particle of this._array) {
      const resizeFactor = container.canvas.resizeFactor;
      if (resizeFactor && !particle.ignoresResizeRatio) {
        particle.position.x *= resizeFactor.width;
        particle.position.y *= resizeFactor.height;
        particle.initialPosition.x *= resizeFactor.width;
        particle.initialPosition.y *= resizeFactor.height;
      }
      particle.ignoresResizeRatio = false;
      await this._interactionManager.reset(particle);
      for (const [, plugin] of this._container.plugins) {
        if (particle.destroyed) {
          break;
        }
        if (plugin.particleUpdate) {
          plugin.particleUpdate(particle, delta);
        }
      }
      for (const mover of this.movers) {
        mover.isEnabled(particle) && mover.move(particle, delta);
      }
      if (particle.destroyed) {
        particlesToDelete.add(particle);
        continue;
      }
      this.quadTree.insert(new Point(particle.getPosition(), particle));
    }
    if (particlesToDelete.size) {
      const checkDelete = (p2) => !particlesToDelete.has(p2);
      this._array = this.filter(checkDelete);
      this._zArray = this._zArray.filter(checkDelete);
      this.pool.push(...particlesToDelete);
    }
    await this._interactionManager.externalInteract(delta);
    for (const particle of this._array) {
      for (const updater of this.updaters) {
        updater.update(particle, delta);
      }
      if (!particle.destroyed && !particle.spawning) {
        await this._interactionManager.particlesInteract(particle, delta);
      }
    }
    delete container.canvas.resizeFactor;
    if (this.needsSort) {
      const zArray = this._zArray;
      zArray.sort((a2, b2) => b2.position.z - a2.position.z || a2.id - b2.id);
      this.lastZIndex = zArray[zArray.length - 1].position.z;
      this.needsSort = false;
    }
  }
}
class Retina {
  constructor(container) {
    this.container = container;
    this.pixelRatio = 1;
    this.reduceFactor = 1;
  }
  init() {
    const container = this.container, options2 = container.actualOptions;
    this.pixelRatio = !options2.detectRetina || isSsr() ? 1 : window.devicePixelRatio;
    this.reduceFactor = 1;
    const ratio = this.pixelRatio;
    if (container.canvas.element) {
      const element2 = container.canvas.element;
      container.canvas.size.width = element2.offsetWidth * ratio;
      container.canvas.size.height = element2.offsetHeight * ratio;
    }
    const particles = options2.particles, moveOptions = particles.move;
    this.attractDistance = getRangeValue(moveOptions.attract.distance) * ratio;
    this.maxSpeed = getRangeValue(moveOptions.gravity.maxSpeed) * ratio;
    this.sizeAnimationSpeed = getRangeValue(particles.size.animation.speed) * ratio;
  }
  initParticle(particle) {
    const options2 = particle.options, ratio = this.pixelRatio, moveOptions = options2.move, moveDistance = moveOptions.distance, props = particle.retina;
    props.attractDistance = getRangeValue(moveOptions.attract.distance) * ratio;
    props.moveDrift = getRangeValue(moveOptions.drift) * ratio;
    props.moveSpeed = getRangeValue(moveOptions.speed) * ratio;
    props.sizeAnimationSpeed = getRangeValue(options2.size.animation.speed) * ratio;
    const maxDistance = props.maxDistance;
    maxDistance.horizontal = moveDistance.horizontal !== void 0 ? moveDistance.horizontal * ratio : void 0;
    maxDistance.vertical = moveDistance.vertical !== void 0 ? moveDistance.vertical * ratio : void 0;
    props.maxSpeed = getRangeValue(moveOptions.gravity.maxSpeed) * ratio;
  }
}
function guardCheck(container) {
  return container && !container.destroyed;
}
function initDelta(value, fpsLimit = 60, smooth = false) {
  return {
    value,
    factor: smooth ? 60 / fpsLimit : 60 * value / 1e3
  };
}
function loadContainerOptions(engine, container, ...sourceOptionsArr) {
  const options2 = new Options$1(engine, container);
  loadOptions(options2, ...sourceOptionsArr);
  return options2;
}
const defaultPathGeneratorKey = "default", defaultPathGenerator = {
  generate: (p2) => p2.velocity,
  init: () => {
  },
  update: () => {
  },
  reset: () => {
  }
};
class Container {
  constructor(engine, id, sourceOptions) {
    this.id = id;
    this._intersectionManager = (entries) => {
      if (!guardCheck(this) || !this.actualOptions.pauseOnOutsideViewport) {
        return;
      }
      for (const entry of entries) {
        if (entry.target !== this.interactivity.element) {
          continue;
        }
        (entry.isIntersecting ? this.play : this.pause)();
      }
    };
    this._nextFrame = async (timestamp) => {
      try {
        if (!this.smooth && this.lastFrameTime !== void 0 && timestamp < this.lastFrameTime + 1e3 / this.fpsLimit) {
          this.draw(false);
          return;
        }
        this.lastFrameTime ?? (this.lastFrameTime = timestamp);
        const delta = initDelta(timestamp - this.lastFrameTime, this.fpsLimit, this.smooth);
        this.addLifeTime(delta.value);
        this.lastFrameTime = timestamp;
        if (delta.value > 1e3) {
          this.draw(false);
          return;
        }
        await this.particles.draw(delta);
        if (!this.alive()) {
          this.destroy();
          return;
        }
        if (this.getAnimationStatus()) {
          this.draw(false);
        }
      } catch (e2) {
        getLogger().error(`${errorPrefix} in animation loop`, e2);
      }
    };
    this._engine = engine;
    this.fpsLimit = 120;
    this.smooth = false;
    this._delay = 0;
    this._duration = 0;
    this._lifeTime = 0;
    this._firstStart = true;
    this.started = false;
    this.destroyed = false;
    this._paused = true;
    this.lastFrameTime = 0;
    this.zLayers = 100;
    this.pageHidden = false;
    this._sourceOptions = sourceOptions;
    this._initialSourceOptions = sourceOptions;
    this.retina = new Retina(this);
    this.canvas = new Canvas(this);
    this.particles = new Particles(this._engine, this);
    this.pathGenerators = /* @__PURE__ */ new Map();
    this.interactivity = {
      mouse: {
        clicking: false,
        inside: false
      }
    };
    this.plugins = /* @__PURE__ */ new Map();
    this.drawers = /* @__PURE__ */ new Map();
    this._options = loadContainerOptions(this._engine, this);
    this.actualOptions = loadContainerOptions(this._engine, this);
    this._eventListeners = new EventListeners(this);
    if (typeof IntersectionObserver !== "undefined" && IntersectionObserver) {
      this._intersectionObserver = new IntersectionObserver((entries) => this._intersectionManager(entries));
    }
    this._engine.dispatchEvent("containerBuilt", { container: this });
  }
  get options() {
    return this._options;
  }
  get sourceOptions() {
    return this._sourceOptions;
  }
  addClickHandler(callback) {
    if (!guardCheck(this)) {
      return;
    }
    const el = this.interactivity.element;
    if (!el) {
      return;
    }
    const clickOrTouchHandler = (e2, pos, radius) => {
      if (!guardCheck(this)) {
        return;
      }
      const pxRatio = this.retina.pixelRatio, posRetina = {
        x: pos.x * pxRatio,
        y: pos.y * pxRatio
      }, particles = this.particles.quadTree.queryCircle(posRetina, radius * pxRatio);
      callback(e2, particles);
    };
    const clickHandler = (e2) => {
      if (!guardCheck(this)) {
        return;
      }
      const mouseEvent = e2, pos = {
        x: mouseEvent.offsetX || mouseEvent.clientX,
        y: mouseEvent.offsetY || mouseEvent.clientY
      };
      clickOrTouchHandler(e2, pos, 1);
    };
    const touchStartHandler = () => {
      if (!guardCheck(this)) {
        return;
      }
      touched = true;
      touchMoved = false;
    };
    const touchMoveHandler = () => {
      if (!guardCheck(this)) {
        return;
      }
      touchMoved = true;
    };
    const touchEndHandler = (e2) => {
      if (!guardCheck(this)) {
        return;
      }
      if (touched && !touchMoved) {
        const touchEvent = e2;
        let lastTouch = touchEvent.touches[touchEvent.touches.length - 1];
        if (!lastTouch) {
          lastTouch = touchEvent.changedTouches[touchEvent.changedTouches.length - 1];
          if (!lastTouch) {
            return;
          }
        }
        const element2 = this.canvas.element, canvasRect = element2 ? element2.getBoundingClientRect() : void 0, pos = {
          x: lastTouch.clientX - (canvasRect ? canvasRect.left : 0),
          y: lastTouch.clientY - (canvasRect ? canvasRect.top : 0)
        };
        clickOrTouchHandler(e2, pos, Math.max(lastTouch.radiusX, lastTouch.radiusY));
      }
      touched = false;
      touchMoved = false;
    };
    const touchCancelHandler = () => {
      if (!guardCheck(this)) {
        return;
      }
      touched = false;
      touchMoved = false;
    };
    let touched = false, touchMoved = false;
    el.addEventListener("click", clickHandler);
    el.addEventListener("touchstart", touchStartHandler);
    el.addEventListener("touchmove", touchMoveHandler);
    el.addEventListener("touchend", touchEndHandler);
    el.addEventListener("touchcancel", touchCancelHandler);
  }
  addLifeTime(value) {
    this._lifeTime += value;
  }
  addPath(key2, generator, override = false) {
    if (!guardCheck(this) || !override && this.pathGenerators.has(key2)) {
      return false;
    }
    this.pathGenerators.set(key2, generator ?? defaultPathGenerator);
    return true;
  }
  alive() {
    return !this._duration || this._lifeTime <= this._duration;
  }
  destroy() {
    if (!guardCheck(this)) {
      return;
    }
    this.stop();
    this.particles.destroy();
    this.canvas.destroy();
    for (const [, drawer] of this.drawers) {
      drawer.destroy && drawer.destroy(this);
    }
    for (const key2 of this.drawers.keys()) {
      this.drawers.delete(key2);
    }
    this._engine.plugins.destroy(this);
    this.destroyed = true;
    const mainArr = this._engine.dom(), idx = mainArr.findIndex((t2) => t2 === this);
    if (idx >= 0) {
      mainArr.splice(idx, 1);
    }
    this._engine.dispatchEvent("containerDestroyed", { container: this });
  }
  draw(force) {
    if (!guardCheck(this)) {
      return;
    }
    let refreshTime = force;
    this._drawAnimationFrame = requestAnimationFrame(async (timestamp) => {
      if (refreshTime) {
        this.lastFrameTime = void 0;
        refreshTime = false;
      }
      await this._nextFrame(timestamp);
    });
  }
  async export(type, options2 = {}) {
    for (const [, plugin] of this.plugins) {
      if (!plugin.export) {
        continue;
      }
      const res = await plugin.export(type, options2);
      if (!res.supported) {
        continue;
      }
      return res.blob;
    }
    getLogger().error(`${errorPrefix} - Export plugin with type ${type} not found`);
  }
  getAnimationStatus() {
    return !this._paused && !this.pageHidden && guardCheck(this);
  }
  handleClickMode(mode) {
    if (!guardCheck(this)) {
      return;
    }
    this.particles.handleClickMode(mode);
    for (const [, plugin] of this.plugins) {
      plugin.handleClickMode && plugin.handleClickMode(mode);
    }
  }
  async init() {
    if (!guardCheck(this)) {
      return;
    }
    const shapes = this._engine.plugins.getSupportedShapes();
    for (const type of shapes) {
      const drawer = this._engine.plugins.getShapeDrawer(type);
      if (drawer) {
        this.drawers.set(type, drawer);
      }
    }
    this._options = loadContainerOptions(this._engine, this, this._initialSourceOptions, this.sourceOptions);
    this.actualOptions = loadContainerOptions(this._engine, this, this._options);
    const availablePlugins = this._engine.plugins.getAvailablePlugins(this);
    for (const [id, plugin] of availablePlugins) {
      this.plugins.set(id, plugin);
    }
    this.retina.init();
    await this.canvas.init();
    this.updateActualOptions();
    this.canvas.initBackground();
    this.canvas.resize();
    this.zLayers = this.actualOptions.zLayers;
    this._duration = getRangeValue(this.actualOptions.duration) * 1e3;
    this._delay = getRangeValue(this.actualOptions.delay) * 1e3;
    this._lifeTime = 0;
    this.fpsLimit = this.actualOptions.fpsLimit > 0 ? this.actualOptions.fpsLimit : 120;
    this.smooth = this.actualOptions.smooth;
    for (const [, drawer] of this.drawers) {
      drawer.init && await drawer.init(this);
    }
    for (const [, plugin] of this.plugins) {
      plugin.init && await plugin.init();
    }
    this._engine.dispatchEvent("containerInit", { container: this });
    this.particles.init();
    this.particles.setDensity();
    for (const [, plugin] of this.plugins) {
      plugin.particlesSetup && plugin.particlesSetup();
    }
    this._engine.dispatchEvent("particlesSetup", { container: this });
  }
  async loadTheme(name) {
    if (!guardCheck(this)) {
      return;
    }
    this._currentTheme = name;
    await this.refresh();
  }
  pause() {
    if (!guardCheck(this)) {
      return;
    }
    if (this._drawAnimationFrame !== void 0) {
      cancelAnimationFrame(this._drawAnimationFrame);
      delete this._drawAnimationFrame;
    }
    if (this._paused) {
      return;
    }
    for (const [, plugin] of this.plugins) {
      plugin.pause && plugin.pause();
    }
    if (!this.pageHidden) {
      this._paused = true;
    }
    this._engine.dispatchEvent("containerPaused", { container: this });
  }
  play(force) {
    if (!guardCheck(this)) {
      return;
    }
    const needsUpdate = this._paused || force;
    if (this._firstStart && !this.actualOptions.autoPlay) {
      this._firstStart = false;
      return;
    }
    if (this._paused) {
      this._paused = false;
    }
    if (needsUpdate) {
      for (const [, plugin] of this.plugins) {
        if (plugin.play) {
          plugin.play();
        }
      }
    }
    this._engine.dispatchEvent("containerPlay", { container: this });
    this.draw(needsUpdate || false);
  }
  async refresh() {
    if (!guardCheck(this)) {
      return;
    }
    this.stop();
    return this.start();
  }
  async reset() {
    if (!guardCheck(this)) {
      return;
    }
    this._initialSourceOptions = void 0;
    this._options = loadContainerOptions(this._engine, this);
    this.actualOptions = loadContainerOptions(this._engine, this, this._options);
    return this.refresh();
  }
  setNoise(noiseOrGenerator, init2, update2) {
    if (!guardCheck(this)) {
      return;
    }
    this.setPath(noiseOrGenerator, init2, update2);
  }
  setPath(pathOrGenerator, init2, update2) {
    if (!pathOrGenerator || !guardCheck(this)) {
      return;
    }
    const pathGenerator = { ...defaultPathGenerator };
    if (isFunction(pathOrGenerator)) {
      pathGenerator.generate = pathOrGenerator;
      if (init2) {
        pathGenerator.init = init2;
      }
      if (update2) {
        pathGenerator.update = update2;
      }
    } else {
      const oldGenerator = pathGenerator;
      pathGenerator.generate = pathOrGenerator.generate || oldGenerator.generate;
      pathGenerator.init = pathOrGenerator.init || oldGenerator.init;
      pathGenerator.update = pathOrGenerator.update || oldGenerator.update;
    }
    this.addPath(defaultPathGeneratorKey, pathGenerator, true);
  }
  async start() {
    if (!guardCheck(this) || this.started) {
      return;
    }
    await this.init();
    this.started = true;
    await new Promise((resolve) => {
      this._delayTimeout = setTimeout(async () => {
        this._eventListeners.addListeners();
        if (this.interactivity.element instanceof HTMLElement && this._intersectionObserver) {
          this._intersectionObserver.observe(this.interactivity.element);
        }
        for (const [, plugin] of this.plugins) {
          plugin.start && await plugin.start();
        }
        this._engine.dispatchEvent("containerStarted", { container: this });
        this.play();
        resolve();
      }, this._delay);
    });
  }
  stop() {
    if (!guardCheck(this) || !this.started) {
      return;
    }
    if (this._delayTimeout) {
      clearTimeout(this._delayTimeout);
      delete this._delayTimeout;
    }
    this._firstStart = true;
    this.started = false;
    this._eventListeners.removeListeners();
    this.pause();
    this.particles.clear();
    this.canvas.stop();
    if (this.interactivity.element instanceof HTMLElement && this._intersectionObserver) {
      this._intersectionObserver.unobserve(this.interactivity.element);
    }
    for (const [, plugin] of this.plugins) {
      plugin.stop && plugin.stop();
    }
    for (const key2 of this.plugins.keys()) {
      this.plugins.delete(key2);
    }
    this._sourceOptions = this._options;
    this._engine.dispatchEvent("containerStopped", { container: this });
  }
  updateActualOptions() {
    this.actualOptions.responsive = [];
    const newMaxWidth = this.actualOptions.setResponsive(this.canvas.size.width, this.retina.pixelRatio, this._options);
    this.actualOptions.setTheme(this._currentTheme);
    if (this.responsiveMaxWidth === newMaxWidth) {
      return false;
    }
    this.responsiveMaxWidth = newMaxWidth;
    return true;
  }
}
class EventDispatcher {
  constructor() {
    this._listeners = /* @__PURE__ */ new Map();
  }
  addEventListener(type, listener) {
    this.removeEventListener(type, listener);
    let arr = this._listeners.get(type);
    if (!arr) {
      arr = [];
      this._listeners.set(type, arr);
    }
    arr.push(listener);
  }
  dispatchEvent(type, args) {
    const listeners = this._listeners.get(type);
    listeners && listeners.forEach((handler) => handler(args));
  }
  hasEventListener(type) {
    return !!this._listeners.get(type);
  }
  removeAllEventListeners(type) {
    if (!type) {
      this._listeners = /* @__PURE__ */ new Map();
    } else {
      this._listeners.delete(type);
    }
  }
  removeEventListener(type, listener) {
    const arr = this._listeners.get(type);
    if (!arr) {
      return;
    }
    const length = arr.length, idx = arr.indexOf(listener);
    if (idx < 0) {
      return;
    }
    if (length === 1) {
      this._listeners.delete(type);
    } else {
      arr.splice(idx, 1);
    }
  }
}
function getItemsFromInitializer(container, map, initializers, force = false) {
  let res = map.get(container);
  if (!res || force) {
    res = [...initializers.values()].map((t2) => t2(container));
    map.set(container, res);
  }
  return res;
}
class Plugins {
  constructor(engine) {
    this._engine = engine;
    this.plugins = [];
    this._initializers = {
      interactors: /* @__PURE__ */ new Map(),
      movers: /* @__PURE__ */ new Map(),
      updaters: /* @__PURE__ */ new Map()
    };
    this.interactors = /* @__PURE__ */ new Map();
    this.movers = /* @__PURE__ */ new Map();
    this.updaters = /* @__PURE__ */ new Map();
    this.presets = /* @__PURE__ */ new Map();
    this.drawers = /* @__PURE__ */ new Map();
    this.pathGenerators = /* @__PURE__ */ new Map();
  }
  addInteractor(name, initInteractor) {
    this._initializers.interactors.set(name, initInteractor);
  }
  addParticleMover(name, initMover) {
    this._initializers.movers.set(name, initMover);
  }
  addParticleUpdater(name, initUpdater) {
    this._initializers.updaters.set(name, initUpdater);
  }
  addPathGenerator(type, pathGenerator) {
    !this.getPathGenerator(type) && this.pathGenerators.set(type, pathGenerator);
  }
  addPlugin(plugin) {
    !this.getPlugin(plugin.id) && this.plugins.push(plugin);
  }
  addPreset(presetKey, options2, override = false) {
    (override || !this.getPreset(presetKey)) && this.presets.set(presetKey, options2);
  }
  addShapeDrawer(types, drawer) {
    executeOnSingleOrMultiple(types, (type) => {
      !this.getShapeDrawer(type) && this.drawers.set(type, drawer);
    });
  }
  destroy(container) {
    this.updaters.delete(container);
    this.movers.delete(container);
    this.interactors.delete(container);
  }
  getAvailablePlugins(container) {
    const res = /* @__PURE__ */ new Map();
    for (const plugin of this.plugins) {
      plugin.needsPlugin(container.actualOptions) && res.set(plugin.id, plugin.getPlugin(container));
    }
    return res;
  }
  getInteractors(container, force = false) {
    return getItemsFromInitializer(container, this.interactors, this._initializers.interactors, force);
  }
  getMovers(container, force = false) {
    return getItemsFromInitializer(container, this.movers, this._initializers.movers, force);
  }
  getPathGenerator(type) {
    return this.pathGenerators.get(type);
  }
  getPlugin(plugin) {
    return this.plugins.find((t2) => t2.id === plugin);
  }
  getPreset(preset) {
    return this.presets.get(preset);
  }
  getShapeDrawer(type) {
    return this.drawers.get(type);
  }
  getSupportedShapes() {
    return this.drawers.keys();
  }
  getUpdaters(container, force = false) {
    return getItemsFromInitializer(container, this.updaters, this._initializers.updaters, force);
  }
  loadOptions(options2, sourceOptions) {
    for (const plugin of this.plugins) {
      plugin.loadOptions(options2, sourceOptions);
    }
  }
  loadParticlesOptions(container, options2, ...sourceOptions) {
    const updaters = this.updaters.get(container);
    if (!updaters) {
      return;
    }
    for (const updater of updaters) {
      updater.loadOptions && updater.loadOptions(options2, ...sourceOptions);
    }
  }
}
async function getDataFromUrl(data2) {
  const url = itemFromSingleOrMultiple(data2.url, data2.index);
  if (!url) {
    return data2.fallback;
  }
  const response = await fetch(url);
  if (response.ok) {
    return response.json();
  }
  getLogger().error(`${errorPrefix} ${response.status} while retrieving config file`);
  return data2.fallback;
}
function isParamsEmpty(params) {
  return !params.id && !params.element && !params.url && !params.options;
}
function isParams(obj) {
  return !isParamsEmpty(obj);
}
class Engine {
  constructor() {
    this._configs = /* @__PURE__ */ new Map();
    this._domArray = [];
    this._eventDispatcher = new EventDispatcher();
    this._initialized = false;
    this.plugins = new Plugins(this);
  }
  get configs() {
    const res = {};
    for (const [name, config] of this._configs) {
      res[name] = config;
    }
    return res;
  }
  get version() {
    return "2.12.0";
  }
  addConfig(nameOrConfig, config) {
    if (isString(nameOrConfig)) {
      if (config) {
        config.name = nameOrConfig;
        this._configs.set(nameOrConfig, config);
      }
    } else {
      this._configs.set(nameOrConfig.name ?? "default", nameOrConfig);
    }
  }
  addEventListener(type, listener) {
    this._eventDispatcher.addEventListener(type, listener);
  }
  async addInteractor(name, interactorInitializer, refresh = true) {
    this.plugins.addInteractor(name, interactorInitializer);
    await this.refresh(refresh);
  }
  async addMover(name, moverInitializer, refresh = true) {
    this.plugins.addParticleMover(name, moverInitializer);
    await this.refresh(refresh);
  }
  async addParticleUpdater(name, updaterInitializer, refresh = true) {
    this.plugins.addParticleUpdater(name, updaterInitializer);
    await this.refresh(refresh);
  }
  async addPathGenerator(name, generator, refresh = true) {
    this.plugins.addPathGenerator(name, generator);
    await this.refresh(refresh);
  }
  async addPlugin(plugin, refresh = true) {
    this.plugins.addPlugin(plugin);
    await this.refresh(refresh);
  }
  async addPreset(preset, options2, override = false, refresh = true) {
    this.plugins.addPreset(preset, options2, override);
    await this.refresh(refresh);
  }
  async addShape(shape, drawer, initOrRefresh, afterEffectOrRefresh, destroyOrRefresh, refresh = true) {
    let customDrawer;
    let realRefresh = refresh, realInit, realAfterEffect, realDestroy;
    if (isBoolean(initOrRefresh)) {
      realRefresh = initOrRefresh;
      realInit = void 0;
    } else {
      realInit = initOrRefresh;
    }
    if (isBoolean(afterEffectOrRefresh)) {
      realRefresh = afterEffectOrRefresh;
      realAfterEffect = void 0;
    } else {
      realAfterEffect = afterEffectOrRefresh;
    }
    if (isBoolean(destroyOrRefresh)) {
      realRefresh = destroyOrRefresh;
      realDestroy = void 0;
    } else {
      realDestroy = destroyOrRefresh;
    }
    if (isFunction(drawer)) {
      customDrawer = {
        afterEffect: realAfterEffect,
        destroy: realDestroy,
        draw: drawer,
        init: realInit
      };
    } else {
      customDrawer = drawer;
    }
    this.plugins.addShapeDrawer(shape, customDrawer);
    await this.refresh(realRefresh);
  }
  dispatchEvent(type, args) {
    this._eventDispatcher.dispatchEvent(type, args);
  }
  dom() {
    return this._domArray;
  }
  domItem(index) {
    const dom = this.dom(), item = dom[index];
    if (!item || item.destroyed) {
      dom.splice(index, 1);
      return;
    }
    return item;
  }
  init() {
    if (this._initialized) {
      return;
    }
    this._initialized = true;
  }
  async load(tagIdOrOptionsOrParams, options2) {
    return this.loadFromArray(tagIdOrOptionsOrParams, options2);
  }
  async loadFromArray(tagIdOrOptionsOrParams, optionsOrIndex, index) {
    let params;
    if (!isParams(tagIdOrOptionsOrParams)) {
      params = {};
      if (isString(tagIdOrOptionsOrParams)) {
        params.id = tagIdOrOptionsOrParams;
      } else {
        params.options = tagIdOrOptionsOrParams;
      }
      if (isNumber(optionsOrIndex)) {
        params.index = optionsOrIndex;
      } else {
        params.options = optionsOrIndex ?? params.options;
      }
      params.index = index ?? params.index;
    } else {
      params = tagIdOrOptionsOrParams;
    }
    return this._loadParams(params);
  }
  async loadJSON(tagId, pathConfigJson, index) {
    let url, id;
    if (isNumber(pathConfigJson) || pathConfigJson === void 0) {
      url = tagId;
    } else {
      id = tagId;
      url = pathConfigJson;
    }
    return this._loadParams({ id, url, index });
  }
  async refresh(refresh = true) {
    if (!refresh) {
      return;
    }
    this.dom().forEach((t2) => t2.refresh());
  }
  removeEventListener(type, listener) {
    this._eventDispatcher.removeEventListener(type, listener);
  }
  async set(id, element2, options2, index) {
    const params = { index };
    if (isString(id)) {
      params.id = id;
    } else {
      params.element = id;
    }
    if (element2 instanceof HTMLElement) {
      params.element = element2;
    } else {
      params.options = element2;
    }
    if (isNumber(options2)) {
      params.index = options2;
    } else {
      params.options = options2 ?? params.options;
    }
    return this._loadParams(params);
  }
  async setJSON(id, element2, pathConfigJson, index) {
    const params = {};
    if (id instanceof HTMLElement) {
      params.element = id;
      params.url = element2;
      params.index = pathConfigJson;
    } else {
      params.id = id;
      params.element = element2;
      params.url = pathConfigJson;
      params.index = index;
    }
    return this._loadParams(params);
  }
  setOnClickHandler(callback) {
    const dom = this.dom();
    if (!dom.length) {
      throw new Error(`${errorPrefix} can only set click handlers after calling tsParticles.load()`);
    }
    for (const domItem of dom) {
      domItem.addClickHandler(callback);
    }
  }
  async _loadParams(params) {
    const id = params.id ?? `tsparticles${Math.floor(getRandom() * 1e4)}`, { index, url } = params, options2 = url ? await getDataFromUrl({ fallback: params.options, url, index }) : params.options;
    let domContainer = params.element ?? document.getElementById(id);
    if (!domContainer) {
      domContainer = document.createElement("div");
      domContainer.id = id;
      document.body.append(domContainer);
    }
    const currentOptions = itemFromSingleOrMultiple(options2, index), dom = this.dom(), oldIndex = dom.findIndex((v2) => v2.id === id);
    if (oldIndex >= 0) {
      const old = this.domItem(oldIndex);
      if (old && !old.destroyed) {
        old.destroy();
        dom.splice(oldIndex, 1);
      }
    }
    let canvasEl;
    if (domContainer.tagName.toLowerCase() === "canvas") {
      canvasEl = domContainer;
      canvasEl.dataset[generatedAttribute] = "false";
    } else {
      const existingCanvases = domContainer.getElementsByTagName("canvas");
      if (existingCanvases.length) {
        canvasEl = existingCanvases[0];
        canvasEl.dataset[generatedAttribute] = "false";
      } else {
        canvasEl = document.createElement("canvas");
        canvasEl.dataset[generatedAttribute] = "true";
        domContainer.appendChild(canvasEl);
      }
    }
    if (!canvasEl.style.width) {
      canvasEl.style.width = "100%";
    }
    if (!canvasEl.style.height) {
      canvasEl.style.height = "100%";
    }
    const newItem = new Container(this, id, currentOptions);
    if (oldIndex >= 0) {
      dom.splice(oldIndex, 0, newItem);
    } else {
      dom.push(newItem);
    }
    newItem.canvas.loadCanvas(canvasEl);
    await newItem.start();
    return newItem;
  }
}
class HslColorManager {
  constructor() {
    this.key = "hsl";
    this.stringPrefix = "hsl";
  }
  handleColor(color) {
    const colorValue = color.value, hslColor = colorValue.hsl ?? color.value;
    if (hslColor.h !== void 0 && hslColor.s !== void 0 && hslColor.l !== void 0) {
      return hslToRgb(hslColor);
    }
  }
  handleRangeColor(color) {
    const colorValue = color.value, hslColor = colorValue.hsl ?? color.value;
    if (hslColor.h !== void 0 && hslColor.l !== void 0) {
      return hslToRgb({
        h: getRangeValue(hslColor.h),
        l: getRangeValue(hslColor.l),
        s: getRangeValue(hslColor.s)
      });
    }
  }
  parseString(input) {
    if (!input.startsWith("hsl")) {
      return;
    }
    const regex = /hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.%]+)\s*)?\)/i, result = regex.exec(input);
    return result ? hslaToRgba({
      a: result.length > 4 ? parseAlpha(result[5]) : 1,
      h: parseInt(result[1], 10),
      l: parseInt(result[3], 10),
      s: parseInt(result[2], 10)
    }) : void 0;
  }
}
class RgbColorManager {
  constructor() {
    this.key = "rgb";
    this.stringPrefix = "rgb";
  }
  handleColor(color) {
    const colorValue = color.value, rgbColor = colorValue.rgb ?? color.value;
    if (rgbColor.r !== void 0) {
      return rgbColor;
    }
  }
  handleRangeColor(color) {
    const colorValue = color.value, rgbColor = colorValue.rgb ?? color.value;
    if (rgbColor.r !== void 0) {
      return {
        r: getRangeValue(rgbColor.r),
        g: getRangeValue(rgbColor.g),
        b: getRangeValue(rgbColor.b)
      };
    }
  }
  parseString(input) {
    if (!input.startsWith(this.stringPrefix)) {
      return;
    }
    const regex = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([\d.%]+)\s*)?\)/i, result = regex.exec(input);
    return result ? {
      a: result.length > 4 ? parseAlpha(result[5]) : 1,
      b: parseInt(result[3], 10),
      g: parseInt(result[2], 10),
      r: parseInt(result[1], 10)
    } : void 0;
  }
}
function init() {
  const rgbColorManager = new RgbColorManager(), hslColorManager = new HslColorManager();
  addColorManager(rgbColorManager);
  addColorManager(hslColorManager);
  const engine = new Engine();
  engine.init();
  return engine;
}
class ExternalInteractorBase {
  constructor(container) {
    this.container = container;
    this.type = "external";
  }
}
const tsParticles = init();
if (!isSsr()) {
  window.tsParticles = tsParticles;
}
function applyDistance(particle) {
  const initialPosition = particle.initialPosition, { dx, dy } = getDistances(initialPosition, particle.position), dxFixed = Math.abs(dx), dyFixed = Math.abs(dy), { maxDistance } = particle.retina, hDistance = maxDistance.horizontal, vDistance = maxDistance.vertical;
  if (!hDistance && !vDistance) {
    return;
  }
  if ((hDistance && dxFixed >= hDistance || vDistance && dyFixed >= vDistance) && !particle.misplaced) {
    particle.misplaced = !!hDistance && dxFixed > hDistance || !!vDistance && dyFixed > vDistance;
    if (hDistance) {
      particle.velocity.x = particle.velocity.y / 2 - particle.velocity.x;
    }
    if (vDistance) {
      particle.velocity.y = particle.velocity.x / 2 - particle.velocity.y;
    }
  } else if ((!hDistance || dxFixed < hDistance) && (!vDistance || dyFixed < vDistance) && particle.misplaced) {
    particle.misplaced = false;
  } else if (particle.misplaced) {
    const pos = particle.position, vel = particle.velocity;
    if (hDistance && (pos.x < initialPosition.x && vel.x < 0 || pos.x > initialPosition.x && vel.x > 0)) {
      vel.x *= -getRandom();
    }
    if (vDistance && (pos.y < initialPosition.y && vel.y < 0 || pos.y > initialPosition.y && vel.y > 0)) {
      vel.y *= -getRandom();
    }
  }
}
function move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, delta) {
  applyPath(particle, delta);
  const gravityOptions = particle.gravity, gravityFactor = (gravityOptions == null ? void 0 : gravityOptions.enable) && gravityOptions.inverse ? -1 : 1;
  if (moveDrift && moveSpeed) {
    particle.velocity.x += moveDrift * delta.factor / (60 * moveSpeed);
  }
  if ((gravityOptions == null ? void 0 : gravityOptions.enable) && moveSpeed) {
    particle.velocity.y += gravityFactor * (gravityOptions.acceleration * delta.factor) / (60 * moveSpeed);
  }
  const decay = particle.moveDecay;
  particle.velocity.multTo(decay);
  const velocity = particle.velocity.mult(moveSpeed);
  if ((gravityOptions == null ? void 0 : gravityOptions.enable) && maxSpeed > 0 && (!gravityOptions.inverse && velocity.y >= 0 && velocity.y >= maxSpeed || gravityOptions.inverse && velocity.y <= 0 && velocity.y <= -maxSpeed)) {
    velocity.y = gravityFactor * maxSpeed;
    if (moveSpeed) {
      particle.velocity.y = velocity.y / moveSpeed;
    }
  }
  const zIndexOptions = particle.options.zIndex, zVelocityFactor = (1 - particle.zIndexFactor) ** zIndexOptions.velocityRate;
  velocity.multTo(zVelocityFactor);
  const { position } = particle;
  position.addTo(velocity);
  if (moveOptions.vibrate) {
    position.x += Math.sin(position.x * Math.cos(position.y));
    position.y += Math.cos(position.y * Math.sin(position.x));
  }
}
function spin(particle, moveSpeed) {
  const container = particle.container;
  if (!particle.spin) {
    return;
  }
  const updateFunc = {
    x: particle.spin.direction === "clockwise" ? Math.cos : Math.sin,
    y: particle.spin.direction === "clockwise" ? Math.sin : Math.cos
  };
  particle.position.x = particle.spin.center.x + particle.spin.radius * updateFunc.x(particle.spin.angle);
  particle.position.y = particle.spin.center.y + particle.spin.radius * updateFunc.y(particle.spin.angle);
  particle.spin.radius += particle.spin.acceleration;
  const maxCanvasSize = Math.max(container.canvas.size.width, container.canvas.size.height);
  if (particle.spin.radius > maxCanvasSize / 2) {
    particle.spin.radius = maxCanvasSize / 2;
    particle.spin.acceleration *= -1;
  } else if (particle.spin.radius < 0) {
    particle.spin.radius = 0;
    particle.spin.acceleration *= -1;
  }
  particle.spin.angle += moveSpeed / 100 * (1 - particle.spin.radius / maxCanvasSize);
}
function applyPath(particle, delta) {
  var _a;
  const particlesOptions = particle.options, pathOptions = particlesOptions.move.path, pathEnabled = pathOptions.enable;
  if (!pathEnabled) {
    return;
  }
  if (particle.lastPathTime <= particle.pathDelay) {
    particle.lastPathTime += delta.value;
    return;
  }
  const path = (_a = particle.pathGenerator) == null ? void 0 : _a.generate(particle, delta);
  if (path) {
    particle.velocity.addTo(path);
  }
  if (pathOptions.clamp) {
    particle.velocity.x = clamp(particle.velocity.x, -1, 1);
    particle.velocity.y = clamp(particle.velocity.y, -1, 1);
  }
  particle.lastPathTime -= particle.pathDelay;
}
function getProximitySpeedFactor(particle) {
  return particle.slow.inRange ? particle.slow.factor : 1;
}
const diffFactor = 2;
class BaseMover {
  constructor() {
    this._initSpin = (particle) => {
      const container = particle.container, options2 = particle.options, spinOptions = options2.move.spin;
      if (!spinOptions.enable) {
        return;
      }
      const spinPos = spinOptions.position ?? { x: 50, y: 50 }, spinCenter = {
        x: spinPos.x / 100 * container.canvas.size.width,
        y: spinPos.y / 100 * container.canvas.size.height
      }, pos = particle.getPosition(), distance = getDistance(pos, spinCenter), spinAcceleration = getRangeValue(spinOptions.acceleration);
      particle.retina.spinAcceleration = spinAcceleration * container.retina.pixelRatio;
      particle.spin = {
        center: spinCenter,
        direction: particle.velocity.x >= 0 ? "clockwise" : "counter-clockwise",
        angle: particle.velocity.angle,
        radius: distance,
        acceleration: particle.retina.spinAcceleration
      };
    };
  }
  init(particle) {
    const options2 = particle.options, gravityOptions = options2.move.gravity;
    particle.gravity = {
      enable: gravityOptions.enable,
      acceleration: getRangeValue(gravityOptions.acceleration),
      inverse: gravityOptions.inverse
    };
    this._initSpin(particle);
  }
  isEnabled(particle) {
    return !particle.destroyed && particle.options.move.enable;
  }
  move(particle, delta) {
    var _a, _b;
    const particleOptions = particle.options, moveOptions = particleOptions.move;
    if (!moveOptions.enable) {
      return;
    }
    const container = particle.container, pxRatio = container.retina.pixelRatio, slowFactor = getProximitySpeedFactor(particle), baseSpeed = ((_a = particle.retina).moveSpeed ?? (_a.moveSpeed = getRangeValue(moveOptions.speed) * pxRatio)) * container.retina.reduceFactor, moveDrift = (_b = particle.retina).moveDrift ?? (_b.moveDrift = getRangeValue(particle.options.move.drift) * pxRatio), maxSize = getRangeMax(particleOptions.size.value) * pxRatio, sizeFactor = moveOptions.size ? particle.getRadius() / maxSize : 1, moveSpeed = baseSpeed * sizeFactor * slowFactor * (delta.factor || 1) / diffFactor, maxSpeed = particle.retina.maxSpeed ?? container.retina.maxSpeed;
    if (moveOptions.spin.enable) {
      spin(particle, moveSpeed);
    } else {
      move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, delta);
    }
    applyDistance(particle);
  }
}
async function loadBaseMover(engine, refresh = true) {
  await engine.addMover("base", () => new BaseMover(), refresh);
}
class CircleDrawer {
  draw(context, particle, radius) {
    if (!particle.circleRange) {
      particle.circleRange = { min: 0, max: Math.PI * 2 };
    }
    const circleRange = particle.circleRange;
    context.arc(0, 0, radius, circleRange.min, circleRange.max, false);
  }
  getSidesCount() {
    return 12;
  }
  particleInit(container, particle) {
    const shapeData = particle.shapeData, angle = (shapeData == null ? void 0 : shapeData.angle) ?? {
      max: 360,
      min: 0
    };
    particle.circleRange = !isObject(angle) ? {
      min: 0,
      max: angle * Math.PI / 180
    } : { min: angle.min * Math.PI / 180, max: angle.max * Math.PI / 180 };
  }
}
async function loadCircleShape(engine, refresh = true) {
  await engine.addShape("circle", new CircleDrawer(), refresh);
}
function updateColorValue(delta, colorValue, valueAnimation, max, decrease) {
  if (!colorValue || !valueAnimation.enable || (colorValue.maxLoops ?? 0) > 0 && (colorValue.loops ?? 0) > (colorValue.maxLoops ?? 0)) {
    return;
  }
  if (!colorValue.time) {
    colorValue.time = 0;
  }
  if ((colorValue.delayTime ?? 0) > 0 && colorValue.time < (colorValue.delayTime ?? 0)) {
    colorValue.time += delta.value;
  }
  if ((colorValue.delayTime ?? 0) > 0 && colorValue.time < (colorValue.delayTime ?? 0)) {
    return;
  }
  const offset = randomInRange(valueAnimation.offset), velocity = (colorValue.velocity ?? 0) * delta.factor + offset * 3.6, decay = colorValue.decay ?? 1;
  if (!decrease || colorValue.status === "increasing") {
    colorValue.value += velocity;
    if (colorValue.value > max) {
      if (!colorValue.loops) {
        colorValue.loops = 0;
      }
      colorValue.loops++;
      if (decrease) {
        colorValue.status = "decreasing";
        colorValue.value -= colorValue.value % max;
      }
    }
  } else {
    colorValue.value -= velocity;
    if (colorValue.value < 0) {
      if (!colorValue.loops) {
        colorValue.loops = 0;
      }
      colorValue.loops++;
      colorValue.status = "increasing";
      colorValue.value += colorValue.value;
    }
  }
  if (colorValue.velocity && decay !== 1) {
    colorValue.velocity *= decay;
  }
  if (colorValue.value > max) {
    colorValue.value %= max;
  }
}
function updateColor(particle, delta) {
  const { h: hAnimation, s: sAnimation, l: lAnimation } = particle.options.color.animation, { color } = particle;
  if (!color) {
    return;
  }
  const { h: h2, s: s2, l: l2 } = color;
  if (h2) {
    updateColorValue(delta, h2, hAnimation, 360, false);
  }
  if (s2) {
    updateColorValue(delta, s2, sAnimation, 100, true);
  }
  if (l2) {
    updateColorValue(delta, l2, lAnimation, 100, true);
  }
}
class ColorUpdater {
  constructor(container) {
    this.container = container;
  }
  init(particle) {
    const hslColor = rangeColorToHsl(particle.options.color, particle.id, particle.options.reduceDuplicates);
    if (hslColor) {
      particle.color = getHslAnimationFromHsl(hslColor, particle.options.color.animation, this.container.retina.reduceFactor);
    }
  }
  isEnabled(particle) {
    const { h: hAnimation, s: sAnimation, l: lAnimation } = particle.options.color.animation, { color } = particle;
    return !particle.destroyed && !particle.spawning && ((color == null ? void 0 : color.h.value) !== void 0 && hAnimation.enable || (color == null ? void 0 : color.s.value) !== void 0 && sAnimation.enable || (color == null ? void 0 : color.l.value) !== void 0 && lAnimation.enable);
  }
  update(particle, delta) {
    updateColor(particle, delta);
  }
}
async function loadColorUpdater(engine, refresh = true) {
  await engine.addParticleUpdater("color", (container) => new ColorUpdater(container), refresh);
}
function checkDestroy$1(particle, value, minValue, maxValue) {
  switch (particle.options.opacity.animation.destroy) {
    case "max":
      if (value >= maxValue) {
        particle.destroy();
      }
      break;
    case "min":
      if (value <= minValue) {
        particle.destroy();
      }
      break;
  }
}
function updateOpacity(particle, delta) {
  const data2 = particle.opacity;
  if (particle.destroyed || !(data2 == null ? void 0 : data2.enable) || (data2.maxLoops ?? 0) > 0 && (data2.loops ?? 0) > (data2.maxLoops ?? 0)) {
    return;
  }
  const minValue = data2.min, maxValue = data2.max, decay = data2.decay ?? 1;
  if (!data2.time) {
    data2.time = 0;
  }
  if ((data2.delayTime ?? 0) > 0 && data2.time < (data2.delayTime ?? 0)) {
    data2.time += delta.value;
  }
  if ((data2.delayTime ?? 0) > 0 && data2.time < (data2.delayTime ?? 0)) {
    return;
  }
  switch (data2.status) {
    case "increasing":
      if (data2.value >= maxValue) {
        data2.status = "decreasing";
        if (!data2.loops) {
          data2.loops = 0;
        }
        data2.loops++;
      } else {
        data2.value += (data2.velocity ?? 0) * delta.factor;
      }
      break;
    case "decreasing":
      if (data2.value <= minValue) {
        data2.status = "increasing";
        if (!data2.loops) {
          data2.loops = 0;
        }
        data2.loops++;
      } else {
        data2.value -= (data2.velocity ?? 0) * delta.factor;
      }
      break;
  }
  if (data2.velocity && data2.decay !== 1) {
    data2.velocity *= decay;
  }
  checkDestroy$1(particle, data2.value, minValue, maxValue);
  if (!particle.destroyed) {
    data2.value = clamp(data2.value, minValue, maxValue);
  }
}
class OpacityUpdater {
  constructor(container) {
    this.container = container;
  }
  init(particle) {
    const opacityOptions = particle.options.opacity;
    particle.opacity = initParticleNumericAnimationValue(opacityOptions, 1);
    const opacityAnimation = opacityOptions.animation;
    if (opacityAnimation.enable) {
      particle.opacity.velocity = getRangeValue(opacityAnimation.speed) / 100 * this.container.retina.reduceFactor;
      if (!opacityAnimation.sync) {
        particle.opacity.velocity *= getRandom();
      }
    }
  }
  isEnabled(particle) {
    return !particle.destroyed && !particle.spawning && !!particle.opacity && particle.opacity.enable && ((particle.opacity.maxLoops ?? 0) <= 0 || (particle.opacity.maxLoops ?? 0) > 0 && (particle.opacity.loops ?? 0) < (particle.opacity.maxLoops ?? 0));
  }
  reset(particle) {
    if (particle.opacity) {
      particle.opacity.time = 0;
      particle.opacity.loops = 0;
    }
  }
  update(particle, delta) {
    if (!this.isEnabled(particle)) {
      return;
    }
    updateOpacity(particle, delta);
  }
}
async function loadOpacityUpdater(engine, refresh = true) {
  await engine.addParticleUpdater("opacity", (container) => new OpacityUpdater(container), refresh);
}
function bounceHorizontal(data2) {
  if (data2.outMode !== "bounce" && data2.outMode !== "bounce-horizontal" && data2.outMode !== "bounceHorizontal" && data2.outMode !== "split" || data2.direction !== "left" && data2.direction !== "right") {
    return;
  }
  if (data2.bounds.right < 0 && data2.direction === "left") {
    data2.particle.position.x = data2.size + data2.offset.x;
  } else if (data2.bounds.left > data2.canvasSize.width && data2.direction === "right") {
    data2.particle.position.x = data2.canvasSize.width - data2.size - data2.offset.x;
  }
  const velocity = data2.particle.velocity.x;
  let bounced = false;
  if (data2.direction === "right" && data2.bounds.right >= data2.canvasSize.width && velocity > 0 || data2.direction === "left" && data2.bounds.left <= 0 && velocity < 0) {
    const newVelocity = getValue(data2.particle.options.bounce.horizontal);
    data2.particle.velocity.x *= -newVelocity;
    bounced = true;
  }
  if (!bounced) {
    return;
  }
  const minPos = data2.offset.x + data2.size;
  if (data2.bounds.right >= data2.canvasSize.width && data2.direction === "right") {
    data2.particle.position.x = data2.canvasSize.width - minPos;
  } else if (data2.bounds.left <= 0 && data2.direction === "left") {
    data2.particle.position.x = minPos;
  }
  if (data2.outMode === "split") {
    data2.particle.destroy();
  }
}
function bounceVertical(data2) {
  if (data2.outMode !== "bounce" && data2.outMode !== "bounce-vertical" && data2.outMode !== "bounceVertical" && data2.outMode !== "split" || data2.direction !== "bottom" && data2.direction !== "top") {
    return;
  }
  if (data2.bounds.bottom < 0 && data2.direction === "top") {
    data2.particle.position.y = data2.size + data2.offset.y;
  } else if (data2.bounds.top > data2.canvasSize.height && data2.direction === "bottom") {
    data2.particle.position.y = data2.canvasSize.height - data2.size - data2.offset.y;
  }
  const velocity = data2.particle.velocity.y;
  let bounced = false;
  if (data2.direction === "bottom" && data2.bounds.bottom >= data2.canvasSize.height && velocity > 0 || data2.direction === "top" && data2.bounds.top <= 0 && velocity < 0) {
    const newVelocity = getValue(data2.particle.options.bounce.vertical);
    data2.particle.velocity.y *= -newVelocity;
    bounced = true;
  }
  if (!bounced) {
    return;
  }
  const minPos = data2.offset.y + data2.size;
  if (data2.bounds.bottom >= data2.canvasSize.height && data2.direction === "bottom") {
    data2.particle.position.y = data2.canvasSize.height - minPos;
  } else if (data2.bounds.top <= 0 && data2.direction === "top") {
    data2.particle.position.y = minPos;
  }
  if (data2.outMode === "split") {
    data2.particle.destroy();
  }
}
class BounceOutMode {
  constructor(container) {
    this.container = container;
    this.modes = [
      "bounce",
      "bounce-vertical",
      "bounce-horizontal",
      "bounceVertical",
      "bounceHorizontal",
      "split"
    ];
  }
  update(particle, direction, delta, outMode) {
    if (!this.modes.includes(outMode)) {
      return;
    }
    const container = this.container;
    let handled = false;
    for (const [, plugin] of container.plugins) {
      if (plugin.particleBounce !== void 0) {
        handled = plugin.particleBounce(particle, delta, direction);
      }
      if (handled) {
        break;
      }
    }
    if (handled) {
      return;
    }
    const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = calculateBounds(pos, size), canvasSize = container.canvas.size;
    bounceHorizontal({ particle, outMode, direction, bounds, canvasSize, offset, size });
    bounceVertical({ particle, outMode, direction, bounds, canvasSize, offset, size });
  }
}
class DestroyOutMode {
  constructor(container) {
    this.container = container;
    this.modes = ["destroy"];
  }
  update(particle, direction, _delta, outMode) {
    if (!this.modes.includes(outMode)) {
      return;
    }
    const container = this.container;
    switch (particle.outType) {
      case "normal":
      case "outside":
        if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {
          return;
        }
        break;
      case "inside": {
        const { dx, dy } = getDistances(particle.position, particle.moveCenter);
        const { x: vx, y: vy } = particle.velocity;
        if (vx < 0 && dx > particle.moveCenter.radius || vy < 0 && dy > particle.moveCenter.radius || vx >= 0 && dx < -particle.moveCenter.radius || vy >= 0 && dy < -particle.moveCenter.radius) {
          return;
        }
        break;
      }
    }
    container.particles.remove(particle, void 0, true);
  }
}
class NoneOutMode {
  constructor(container) {
    this.container = container;
    this.modes = ["none"];
  }
  update(particle, direction, delta, outMode) {
    if (!this.modes.includes(outMode)) {
      return;
    }
    if (particle.options.move.distance.horizontal && (direction === "left" || direction === "right") || particle.options.move.distance.vertical && (direction === "top" || direction === "bottom")) {
      return;
    }
    const gravityOptions = particle.options.move.gravity, container = this.container;
    const canvasSize = container.canvas.size;
    const pRadius = particle.getRadius();
    if (!gravityOptions.enable) {
      if (particle.velocity.y > 0 && particle.position.y <= canvasSize.height + pRadius || particle.velocity.y < 0 && particle.position.y >= -pRadius || particle.velocity.x > 0 && particle.position.x <= canvasSize.width + pRadius || particle.velocity.x < 0 && particle.position.x >= -pRadius) {
        return;
      }
      if (!isPointInside(particle.position, container.canvas.size, Vector.origin, pRadius, direction)) {
        container.particles.remove(particle);
      }
    } else {
      const position = particle.position;
      if (!gravityOptions.inverse && position.y > canvasSize.height + pRadius && direction === "bottom" || gravityOptions.inverse && position.y < -pRadius && direction === "top") {
        container.particles.remove(particle);
      }
    }
  }
}
class OutOutMode {
  constructor(container) {
    this.container = container;
    this.modes = ["out"];
  }
  update(particle, direction, delta, outMode) {
    if (!this.modes.includes(outMode)) {
      return;
    }
    const container = this.container;
    switch (particle.outType) {
      case "inside": {
        const { x: vx, y: vy } = particle.velocity;
        const circVec = Vector.origin;
        circVec.length = particle.moveCenter.radius;
        circVec.angle = particle.velocity.angle + Math.PI;
        circVec.addTo(Vector.create(particle.moveCenter));
        const { dx, dy } = getDistances(particle.position, circVec);
        if (vx <= 0 && dx >= 0 || vy <= 0 && dy >= 0 || vx >= 0 && dx <= 0 || vy >= 0 && dy <= 0) {
          return;
        }
        particle.position.x = Math.floor(randomInRange({
          min: 0,
          max: container.canvas.size.width
        }));
        particle.position.y = Math.floor(randomInRange({
          min: 0,
          max: container.canvas.size.height
        }));
        const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);
        particle.direction = Math.atan2(-newDy, -newDx);
        particle.velocity.angle = particle.direction;
        break;
      }
      default: {
        if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {
          return;
        }
        switch (particle.outType) {
          case "outside": {
            particle.position.x = Math.floor(randomInRange({
              min: -particle.moveCenter.radius,
              max: particle.moveCenter.radius
            })) + particle.moveCenter.x;
            particle.position.y = Math.floor(randomInRange({
              min: -particle.moveCenter.radius,
              max: particle.moveCenter.radius
            })) + particle.moveCenter.y;
            const { dx, dy } = getDistances(particle.position, particle.moveCenter);
            if (particle.moveCenter.radius) {
              particle.direction = Math.atan2(dy, dx);
              particle.velocity.angle = particle.direction;
            }
            break;
          }
          case "normal": {
            const wrap = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {
              bottom: canvasSize.height + particle.getRadius() + particle.offset.y,
              left: -particle.getRadius() - particle.offset.x,
              right: canvasSize.width + particle.getRadius() + particle.offset.x,
              top: -particle.getRadius() - particle.offset.y
            }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);
            if (direction === "right" && nextBounds.left > canvasSize.width + particle.offset.x) {
              particle.position.x = newPos.left;
              particle.initialPosition.x = particle.position.x;
              if (!wrap) {
                particle.position.y = getRandom() * canvasSize.height;
                particle.initialPosition.y = particle.position.y;
              }
            } else if (direction === "left" && nextBounds.right < -particle.offset.x) {
              particle.position.x = newPos.right;
              particle.initialPosition.x = particle.position.x;
              if (!wrap) {
                particle.position.y = getRandom() * canvasSize.height;
                particle.initialPosition.y = particle.position.y;
              }
            }
            if (direction === "bottom" && nextBounds.top > canvasSize.height + particle.offset.y) {
              if (!wrap) {
                particle.position.x = getRandom() * canvasSize.width;
                particle.initialPosition.x = particle.position.x;
              }
              particle.position.y = newPos.top;
              particle.initialPosition.y = particle.position.y;
            } else if (direction === "top" && nextBounds.bottom < -particle.offset.y) {
              if (!wrap) {
                particle.position.x = getRandom() * canvasSize.width;
                particle.initialPosition.x = particle.position.x;
              }
              particle.position.y = newPos.bottom;
              particle.initialPosition.y = particle.position.y;
            }
            break;
          }
        }
        break;
      }
    }
  }
}
class OutOfCanvasUpdater {
  constructor(container) {
    this.container = container;
    this._updateOutMode = (particle, delta, outMode, direction) => {
      for (const updater of this.updaters) {
        updater.update(particle, direction, delta, outMode);
      }
    };
    this.updaters = [
      new BounceOutMode(container),
      new DestroyOutMode(container),
      new OutOutMode(container),
      new NoneOutMode(container)
    ];
  }
  init() {
  }
  isEnabled(particle) {
    return !particle.destroyed && !particle.spawning;
  }
  update(particle, delta) {
    const outModes = particle.options.move.outModes;
    this._updateOutMode(particle, delta, outModes.bottom ?? outModes.default, "bottom");
    this._updateOutMode(particle, delta, outModes.left ?? outModes.default, "left");
    this._updateOutMode(particle, delta, outModes.right ?? outModes.default, "right");
    this._updateOutMode(particle, delta, outModes.top ?? outModes.default, "top");
  }
}
async function loadOutModesUpdater(engine, refresh = true) {
  await engine.addParticleUpdater("outModes", (container) => new OutOfCanvasUpdater(container), refresh);
}
function checkDestroy(particle, value, minValue, maxValue) {
  switch (particle.options.size.animation.destroy) {
    case "max":
      if (value >= maxValue) {
        particle.destroy();
      }
      break;
    case "min":
      if (value <= minValue) {
        particle.destroy();
      }
      break;
  }
}
function updateSize(particle, delta) {
  const data2 = particle.size;
  if (particle.destroyed || !data2 || !data2.enable || (data2.maxLoops ?? 0) > 0 && (data2.loops ?? 0) > (data2.maxLoops ?? 0)) {
    return;
  }
  const sizeVelocity = (data2.velocity ?? 0) * delta.factor, minValue = data2.min, maxValue = data2.max, decay = data2.decay ?? 1;
  if (!data2.time) {
    data2.time = 0;
  }
  if ((data2.delayTime ?? 0) > 0 && data2.time < (data2.delayTime ?? 0)) {
    data2.time += delta.value;
  }
  if ((data2.delayTime ?? 0) > 0 && data2.time < (data2.delayTime ?? 0)) {
    return;
  }
  switch (data2.status) {
    case "increasing":
      if (data2.value >= maxValue) {
        data2.status = "decreasing";
        if (!data2.loops) {
          data2.loops = 0;
        }
        data2.loops++;
      } else {
        data2.value += sizeVelocity;
      }
      break;
    case "decreasing":
      if (data2.value <= minValue) {
        data2.status = "increasing";
        if (!data2.loops) {
          data2.loops = 0;
        }
        data2.loops++;
      } else {
        data2.value -= sizeVelocity;
      }
  }
  if (data2.velocity && decay !== 1) {
    data2.velocity *= decay;
  }
  checkDestroy(particle, data2.value, minValue, maxValue);
  if (!particle.destroyed) {
    data2.value = clamp(data2.value, minValue, maxValue);
  }
}
class SizeUpdater {
  init(particle) {
    const container = particle.container, sizeOptions = particle.options.size, sizeAnimation = sizeOptions.animation;
    if (sizeAnimation.enable) {
      particle.size.velocity = (particle.retina.sizeAnimationSpeed ?? container.retina.sizeAnimationSpeed) / 100 * container.retina.reduceFactor;
      if (!sizeAnimation.sync) {
        particle.size.velocity *= getRandom();
      }
    }
  }
  isEnabled(particle) {
    return !particle.destroyed && !particle.spawning && particle.size.enable && ((particle.size.maxLoops ?? 0) <= 0 || (particle.size.maxLoops ?? 0) > 0 && (particle.size.loops ?? 0) < (particle.size.maxLoops ?? 0));
  }
  reset(particle) {
    particle.size.loops = 0;
  }
  update(particle, delta) {
    if (!this.isEnabled(particle)) {
      return;
    }
    updateSize(particle, delta);
  }
}
async function loadSizeUpdater(engine, refresh = true) {
  await engine.addParticleUpdater("size", () => new SizeUpdater(), refresh);
}
async function loadBasic(engine, refresh = true) {
  await loadBaseMover(engine, false);
  await loadCircleShape(engine, false);
  await loadColorUpdater(engine, false);
  await loadOpacityUpdater(engine, false);
  await loadOutModesUpdater(engine, false);
  await loadSizeUpdater(engine, false);
  await engine.refresh(refresh);
}
class Push {
  constructor() {
    this.default = true;
    this.groups = [];
    this.quantity = 4;
  }
  get particles_nb() {
    return this.quantity;
  }
  set particles_nb(value) {
    this.quantity = setRangeValue(value);
  }
  load(data2) {
    if (!data2) {
      return;
    }
    if (data2.default !== void 0) {
      this.default = data2.default;
    }
    if (data2.groups !== void 0) {
      this.groups = data2.groups.map((t2) => t2);
    }
    if (!this.groups.length) {
      this.default = true;
    }
    const quantity = data2.quantity ?? data2.particles_nb;
    if (quantity !== void 0) {
      this.quantity = setRangeValue(quantity);
    }
  }
}
class Pusher extends ExternalInteractorBase {
  constructor(container) {
    super(container);
    this.handleClickMode = (mode) => {
      if (mode !== "push") {
        return;
      }
      const container2 = this.container, options2 = container2.actualOptions, pushOptions = options2.interactivity.modes.push;
      if (!pushOptions) {
        return;
      }
      const quantity = getRangeValue(pushOptions.quantity);
      if (quantity <= 0) {
        return;
      }
      const group = itemFromArray([void 0, ...pushOptions.groups]), groupOptions = group !== void 0 ? container2.actualOptions.particles.groups[group] : void 0;
      container2.particles.push(quantity, container2.interactivity.mouse, groupOptions, group);
    };
  }
  clear() {
  }
  init() {
  }
  async interact() {
  }
  isEnabled() {
    return true;
  }
  loadModeOptions(options2, ...sources) {
    if (!options2.push) {
      options2.push = new Push();
    }
    for (const source of sources) {
      options2.push.load(source == null ? void 0 : source.push);
    }
  }
  reset() {
  }
}
async function loadExternalPushInteraction(engine, refresh = true) {
  await engine.addInteractor("externalPush", (container) => new Pusher(container), refresh);
}
const options = {
  fpsLimit: 40,
  particles: {
    number: {
      value: 200,
      density: {
        enable: true
      }
    },
    color: {
      value: ["#fdcf58", "#757676", "#f27d0c", "#800909", "#f07f13"]
    },
    opacity: {
      value: { min: 0.1, max: 0.5 }
    },
    size: {
      value: { min: 1, max: 3 }
    },
    move: {
      enable: true,
      speed: 6,
      random: false
    }
  },
  interactivity: {
    detectsOn: "window",
    events: {
      onClick: {
        enable: true,
        mode: "push"
      },
      resize: true
    }
  },
  background: {
    image: "radial-gradient(#4a0000, #000)"
  }
};
async function loadFirePreset(engine, refresh = true) {
  await loadBasic(engine, false);
  await loadExternalPushInteraction(engine, false);
  await engine.addPreset("fire", options, refresh);
}
function create_fragment$1O(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "bg fullscreen");
      attr(div, "id", "__qlorb-bg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$1C($$self) {
  onMount(async () => {
    await loadFirePreset(tsParticles);
    await tsParticles.load("__qlorb-bg", {
      preset: "fire",
      background: { opacity: 0 },
      backgroundMode: false,
      particles: {
        number: { limit: 500 },
        color: { value: "#888" },
        opacity: { value: 0.15 }
      }
    });
  });
  return [];
}
let Background$1 = class Background2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1C, create_fragment$1O, safe_not_equal, {});
  }
};
function create_fragment$1N(ctx) {
  let button_1;
  let span;
  let t_value = (
    /*rightclicked*/
    (ctx[4] ? -/*box*/
    ctx[0].modifier : (
      /*box*/
      ctx[0].modifier
    )) + ""
  );
  let t2;
  let button_1_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      button_1 = element("button");
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "modifier-floaty");
      toggle_class(
        span,
        "positive",
        /*rightclicked*/
        (ctx[4] ? -/*box*/
        ctx[0].modifier : (
          /*box*/
          ctx[0].modifier
        )) >= 0
      );
      toggle_class(
        span,
        "negative",
        /*rightclicked*/
        (ctx[4] ? -/*box*/
        ctx[0].modifier : (
          /*box*/
          ctx[0].modifier
        )) < 0
      );
      attr(button_1, "class", button_1_class_value = "box " + /*box*/
      ctx[0].class);
      set_style(
        button_1,
        "--offset",
        /*offset*/
        ctx[3] + "px"
      );
      button_1.disabled = /*disabled*/
      ctx[2];
      toggle_class(
        button_1,
        "triggered",
        /*disabled*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, button_1, anchor);
      append(button_1, span);
      append(span, t2);
      ctx[8](button_1);
      if (!mounted) {
        dispose = [
          listen(
            button_1,
            "click",
            /*score*/
            ctx[5]
          ),
          listen(
            button_1,
            "contextmenu",
            /*negativeScore*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*rightclicked, box*/
      17 && t_value !== (t_value = /*rightclicked*/
      (ctx2[4] ? -/*box*/
      ctx2[0].modifier : (
        /*box*/
        ctx2[0].modifier
      )) + ""))
        set_data(t2, t_value);
      if (dirty & /*rightclicked, box*/
      17) {
        toggle_class(
          span,
          "positive",
          /*rightclicked*/
          (ctx2[4] ? -/*box*/
          ctx2[0].modifier : (
            /*box*/
            ctx2[0].modifier
          )) >= 0
        );
      }
      if (dirty & /*rightclicked, box*/
      17) {
        toggle_class(
          span,
          "negative",
          /*rightclicked*/
          (ctx2[4] ? -/*box*/
          ctx2[0].modifier : (
            /*box*/
            ctx2[0].modifier
          )) < 0
        );
      }
      if (dirty & /*box*/
      1 && button_1_class_value !== (button_1_class_value = "box " + /*box*/
      ctx2[0].class)) {
        attr(button_1, "class", button_1_class_value);
      }
      if (dirty & /*offset*/
      8) {
        set_style(
          button_1,
          "--offset",
          /*offset*/
          ctx2[3] + "px"
        );
      }
      if (dirty & /*disabled*/
      4) {
        button_1.disabled = /*disabled*/
        ctx2[2];
      }
      if (dirty & /*box, disabled*/
      5) {
        toggle_class(
          button_1,
          "triggered",
          /*disabled*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button_1);
      }
      ctx[8](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1B($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { box } = $$props;
  const { Clicks } = runtime;
  let button;
  let disabled = false;
  let offset = -65;
  let rightclicked = false;
  onMount(() => {
    setTimeout(() => $$invalidate(3, offset = box.yoffset), 100);
  });
  Clicks.subscribe((v2) => v2 == 0 && setTimeout(() => $$invalidate(2, disabled = false)));
  function score() {
    runtime.ScorePoints(box, button);
    $$invalidate(2, disabled = true);
  }
  function negativeScore(e2) {
    e2.preventDefault();
    runtime.ScoreNegativePoints(box, button);
    $$invalidate(4, rightclicked = true);
    $$invalidate(2, disabled = true);
  }
  function button_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      button = $$value;
      $$invalidate(1, button);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(7, runtime = $$props2.runtime);
    if ("box" in $$props2)
      $$invalidate(0, box = $$props2.box);
  };
  return [
    box,
    button,
    disabled,
    offset,
    rightclicked,
    score,
    negativeScore,
    runtime,
    button_1_binding
  ];
}
class Box extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1B, create_fragment$1N, safe_not_equal, { runtime: 7, box: 0 });
  }
}
function get_each_context$k(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list2[i2];
  return child_ctx;
}
function create_if_block$W(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*boxes*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$k(get_each_context$k(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*runtime, boxes*/
      5) {
        each_value = ensure_array_like(
          /*boxes*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$k(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$k(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$k(ctx) {
  let boxcomponent;
  let current;
  boxcomponent = new Box({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      box: (
        /*box*/
        ctx[7]
      )
    }
  });
  return {
    c() {
      create_component(boxcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(boxcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const boxcomponent_changes = {};
      if (dirty & /*runtime*/
      1)
        boxcomponent_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*boxes*/
      4)
        boxcomponent_changes.box = /*box*/
        ctx2[7];
      boxcomponent.$set(boxcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(boxcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(boxcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(boxcomponent, detaching);
    }
  };
}
function create_fragment$1M(ctx) {
  let div1;
  let div0;
  let button;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*boxes*/
    ctx[2] && create_if_block$W(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button = element("button");
      t2 = space();
      if (if_block)
        if_block.c();
      attr(button, "class", "misclick-trigger");
      attr(div0, "class", "boxes");
      set_style(
        div0,
        "--boxsize",
        /*runtime*/
        ctx[0].BOX_SIZE + "px"
      );
      set_style(
        div0,
        "--boxes-offset",
        /*offset*/
        ctx[1] + "px"
      );
      attr(div1, "class", "game fullscreen");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button);
      append(div0, t2);
      if (if_block)
        if_block.m(div0, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*fail*/
            ctx[3]
          ),
          listen(
            button,
            "contextmenu",
            /*fail*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*boxes*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*boxes*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$W(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*runtime*/
      1) {
        set_style(
          div0,
          "--boxsize",
          /*runtime*/
          ctx2[0].BOX_SIZE + "px"
        );
      }
      if (!current || dirty & /*offset*/
      2) {
        set_style(
          div0,
          "--boxes-offset",
          /*offset*/
          ctx2[1] + "px"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1A($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  const { Clicks, Score, Boxes } = runtime;
  let offset = 0;
  let boxes;
  Clicks.subscribe((v2) => {
    const val = (v2 + 1) * (runtime.BOX_SIZE + runtime.BOX_SIZE / 2);
    $$invalidate(1, offset = val / 2 - runtime.BOX_SIZE / 2);
    $$invalidate(1, offset = -offset);
  });
  Score.subscribe((v2) => {
    if (v2 < 0)
      runtime.Score.set(0);
  });
  Boxes.subscribe((v2) => $$invalidate(2, boxes = v2));
  onMount(() => {
    runtime.spawnBox(null, false, true);
  });
  function fail(e2) {
    if (e2)
      e2.preventDefault();
    runtime.clickReset();
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, offset, boxes, fail];
}
class Game extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1A, create_fragment$1M, safe_not_equal, { runtime: 0 });
  }
}
function create_fragment$1L(ctx) {
  let button0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      button0.textContent = "arrow_back_ios_new";
      t1 = space();
      button1 = element("button");
      button1.textContent = "refresh";
      attr(button0, "class", "material-icons-round");
      attr(button1, "class", "material-icons-round");
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*back*/
            ctx[0]
          ),
          listen(
            button1,
            "click",
            /*reset*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t1);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1z($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  function back() {
    runtime.switchPage("intro");
  }
  function reset() {
    runtime.flushStores();
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [back, reset, runtime];
}
class Options4 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1z, create_fragment$1L, safe_not_equal, { runtime: 2 });
  }
}
function create_fragment$1K(ctx) {
  let div4;
  let span0;
  let t0;
  let t1;
  let div3;
  let div0;
  let span1;
  let t3;
  let span2;
  let t4;
  let t5;
  let div1;
  let span3;
  let t7;
  let span4;
  let t8;
  let t9;
  let div2;
  let span5;
  let t11;
  let span6;
  let t12_value = Math.floor(
    /*scoreN*/
    ctx[3] / 100
  ) + "";
  let t12;
  return {
    c() {
      div4 = element("div");
      span0 = element("span");
      t0 = text(
        /*score*/
        ctx[1]
      );
      t1 = space();
      div3 = element("div");
      div0 = element("div");
      span1 = element("span");
      span1.textContent = "Top";
      t3 = space();
      span2 = element("span");
      t4 = text(
        /*topScore*/
        ctx[0]
      );
      t5 = space();
      div1 = element("div");
      span3 = element("span");
      span3.textContent = "Clicks";
      t7 = space();
      span4 = element("span");
      t8 = text(
        /*clicks*/
        ctx[2]
      );
      t9 = space();
      div2 = element("div");
      span5 = element("span");
      span5.textContent = "Level";
      t11 = space();
      span6 = element("span");
      t12 = text(t12_value);
      attr(span0, "class", "current");
      attr(span1, "class", "label");
      attr(span2, "class", "value");
      attr(div0, "class", "stat");
      attr(span3, "class", "label");
      attr(span4, "class", "value");
      attr(div1, "class", "stat");
      attr(span5, "class", "label");
      attr(span6, "class", "value");
      attr(div2, "class", "stat");
      attr(div3, "class", "top");
      attr(div4, "class", "score");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, span0);
      append(span0, t0);
      append(div4, t1);
      append(div4, div3);
      append(div3, div0);
      append(div0, span1);
      append(div0, t3);
      append(div0, span2);
      append(span2, t4);
      append(div3, t5);
      append(div3, div1);
      append(div1, span3);
      append(div1, t7);
      append(div1, span4);
      append(span4, t8);
      append(div3, t9);
      append(div3, div2);
      append(div2, span5);
      append(div2, t11);
      append(div2, span6);
      append(span6, t12);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*score*/
      2)
        set_data(
          t0,
          /*score*/
          ctx2[1]
        );
      if (dirty & /*topScore*/
      1)
        set_data(
          t4,
          /*topScore*/
          ctx2[0]
        );
      if (dirty & /*clicks*/
      4)
        set_data(
          t8,
          /*clicks*/
          ctx2[2]
        );
      if (dirty & /*scoreN*/
      8 && t12_value !== (t12_value = Math.floor(
        /*scoreN*/
        ctx2[3] / 100
      ) + ""))
        set_data(t12, t12_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
    }
  };
}
function instance$1y($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(5, $UserDataStore = $$value));
  let { runtime } = $$props;
  let topScore = "";
  let score = "";
  let clicks = "";
  let scoreN = 0;
  const { Score, Clicks } = runtime;
  function setTopScore(score2) {
    if (!$UserDataStore.appdata.QlorbApp)
      set_store_value(UserDataStore, $UserDataStore.appdata.QlorbApp = { top: 0 }, $UserDataStore);
    const currentTop = $UserDataStore.appdata.QlorbApp.top || 0;
    if (score2 > currentTop)
      set_store_value(UserDataStore, $UserDataStore.appdata.QlorbApp.top = score2, $UserDataStore);
  }
  UserDataStore.subscribe((v2) => {
    if (!v2.appdata.QlorbApp || !v2.appdata.QlorbApp.top)
      return $$invalidate(0, topScore = "000000");
    $$invalidate(0, topScore = v2.appdata.QlorbApp.top.toString().padStart(6, "0"));
  });
  Score.subscribe((v2) => {
    $$invalidate(3, scoreN = v2);
    $$invalidate(1, score = v2.toString().padStart(6, "0"));
    setTopScore(v2);
  });
  Clicks.subscribe((v2) => $$invalidate(2, clicks = v2.toString().padStart(3, "0")));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(4, runtime = $$props2.runtime);
  };
  return [topScore, score, clicks, scoreN, runtime];
}
class Score_1 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1y, create_fragment$1K, safe_not_equal, { runtime: 4 });
  }
}
function create_fragment$1J(ctx) {
  let div3;
  let div0;
  let options2;
  let t0;
  let div1;
  let t1;
  let div2;
  let score;
  let current;
  options2 = new Options4({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  score = new Score_1({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      create_component(options2.$$.fragment);
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      create_component(score.$$.fragment);
      attr(div0, "class", "topleft");
      attr(div1, "class", "topright");
      attr(div2, "class", "bottomleft");
      attr(div3, "class", "osd fullscreen");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      mount_component(options2, div0, null);
      append(div3, t0);
      append(div3, div1);
      append(div3, t1);
      append(div3, div2);
      mount_component(score, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const options_changes = {};
      if (dirty & /*runtime*/
      1)
        options_changes.runtime = /*runtime*/
        ctx2[0];
      options2.$set(options_changes);
      const score_changes = {};
      if (dirty & /*runtime*/
      1)
        score_changes.runtime = /*runtime*/
        ctx2[0];
      score.$set(score_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(options2.$$.fragment, local);
      transition_in(score.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(options2.$$.fragment, local);
      transition_out(score.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(options2);
      destroy_component(score);
    }
  };
}
function instance$1x($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime];
}
class OnScreenDisplay extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1x, create_fragment$1J, safe_not_equal, { runtime: 0 });
  }
}
function create_default_slot$e(ctx) {
  let div;
  let background;
  let t0;
  let onscreendisplay;
  let t1;
  let game;
  let div_class_value;
  let current;
  background = new Background$1({});
  onscreendisplay = new OnScreenDisplay({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  game = new Game({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(background.$$.fragment);
      t0 = space();
      create_component(onscreendisplay.$$.fragment);
      t1 = space();
      create_component(game.$$.fragment);
      attr(div, "class", div_class_value = "game level-" + /*level*/
      ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(background, div, null);
      append(div, t0);
      mount_component(onscreendisplay, div, null);
      append(div, t1);
      mount_component(game, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const onscreendisplay_changes = {};
      if (dirty & /*runtime*/
      1)
        onscreendisplay_changes.runtime = /*runtime*/
        ctx2[0];
      onscreendisplay.$set(onscreendisplay_changes);
      const game_changes = {};
      if (dirty & /*runtime*/
      1)
        game_changes.runtime = /*runtime*/
        ctx2[0];
      game.$set(game_changes);
      if (!current || dirty & /*level*/
      2 && div_class_value !== (div_class_value = "game level-" + /*level*/
      ctx2[1])) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(background.$$.fragment, local);
      transition_in(onscreendisplay.$$.fragment, local);
      transition_in(game.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(background.$$.fragment, local);
      transition_out(onscreendisplay.$$.fragment, local);
      transition_out(game.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(background);
      destroy_component(onscreendisplay);
      destroy_component(game);
    }
  };
}
function create_fragment$1I(ctx) {
  let page;
  let updating_store;
  let current;
  function page_store_binding(value) {
    ctx[2](value);
  }
  let page_props = {
    name: "game",
    $$slots: { default: [create_default_slot$e] },
    $$scope: { ctx }
  };
  if (
    /*runtime*/
    ctx[0].CurrentPage !== void 0
  ) {
    page_props.store = /*runtime*/
    ctx[0].CurrentPage;
  }
  page = new Page$1({ props: page_props });
  binding_callbacks.push(() => bind$1(page, "store", page_store_binding));
  return {
    c() {
      create_component(page.$$.fragment);
    },
    m(target, anchor) {
      mount_component(page, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const page_changes = {};
      if (dirty & /*$$scope, level, runtime*/
      19) {
        page_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_store && dirty & /*runtime*/
      1) {
        updating_store = true;
        page_changes.store = /*runtime*/
        ctx2[0].CurrentPage;
        add_flush_callback(() => updating_store = false);
      }
      page.$set(page_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(page.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(page.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(page, detaching);
    }
  };
}
function instance$1w($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  const { Score } = runtime;
  let level = 0;
  Score.subscribe((v2) => $$invalidate(1, level = Math.floor(v2 / 100)));
  onMount(() => {
    runtime.flushStores();
  });
  function page_store_binding(value) {
    if ($$self.$$.not_equal(runtime.CurrentPage, value)) {
      runtime.CurrentPage = value;
      $$invalidate(0, runtime);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, level, page_store_binding];
}
class Main extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1w, create_fragment$1I, safe_not_equal, { runtime: 0 });
  }
}
function create_fragment$1H(ctx) {
  let p0;
  let t1;
  let ul;
  let t11;
  let p1;
  let t13;
  let p2;
  return {
    c() {
      p0 = element("p");
      p0.textContent = `Welcome to Qlorb. It's a game based on precision, reflexes and pure skills. The objective of the
  game is to get as many points as you can by interacting with the "orbs" that float on your screen.`;
      t1 = space();
      ul = element("ul");
      ul.innerHTML = `<li>Click a <b>Green</b> or <b>Gold</b> orb with your left mouse button</li> <li>Click a <b>Red</b> orb with your right mouse button</li>`;
      t11 = space();
      p1 = element("p");
      p1.textContent = "There are 10 levels, starting at 0. The levels are decided based on how many points you have. Each\n  level has a different color. If you mis-click at any point, you'll lose upwards of a hundred\n  points. If your score is already below 100, it will be reset back down to 0.";
      t13 = space();
      p2 = element("p");
      p2.textContent = "It may not seem difficult at first, but you are surely mistaken if you think that this is easy. So\n  what are you waiting for? Hop on and experience this beast.";
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      insert(target, t1, anchor);
      insert(target, ul, anchor);
      insert(target, t11, anchor);
      insert(target, p1, anchor);
      insert(target, t13, anchor);
      insert(target, p2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p0);
        detach(t1);
        detach(ul);
        detach(t11);
        detach(p1);
        detach(t13);
        detach(p2);
      }
    }
  };
}
let Help$1 = class Help extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$1H, safe_not_equal, {});
  }
};
const Start_svelte_svelte_type_style_lang = "";
function create_default_slot$d(ctx) {
  let div2;
  let background;
  let t0;
  let div0;
  let h1;
  let img;
  let img_src_value;
  let t1;
  let span;
  let t3;
  let p2;
  let t5;
  let button0;
  let t7;
  let button1;
  let t9;
  let button2;
  let t11;
  let div1;
  let current;
  let mounted;
  let dispose;
  background = new Background$1({});
  return {
    c() {
      div2 = element("div");
      create_component(background.$$.fragment);
      t0 = space();
      div0 = element("div");
      h1 = element("h1");
      img = element("img");
      t1 = space();
      span = element("span");
      span.textContent = "Qlorb";
      t3 = space();
      p2 = element("p");
      p2.textContent = "Catch orbs, get points, and get frustrated!";
      t5 = space();
      button0 = element("button");
      button0.textContent = "Start";
      t7 = space();
      button1 = element("button");
      button1.textContent = "Help";
      t9 = space();
      button2 = element("button");
      button2.textContent = "Exit";
      t11 = space();
      div1 = element("div");
      div1.textContent = "© Izaak Kuipers 2023. Licensed under GPLv3.";
      if (!src_url_equal(img.src, img_src_value = /*app*/
      ctx[1].metadata.icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(img, "class", "svelte-5005yv");
      attr(p2, "class", "svelte-5005yv");
      attr(h1, "class", "title svelte-5005yv");
      attr(button0, "class", "option svelte-5005yv");
      attr(button1, "class", "option svelte-5005yv");
      attr(button2, "class", "option svelte-5005yv");
      attr(div0, "class", "fullscreen center-flex svelte-5005yv");
      attr(div1, "class", "footer svelte-5005yv");
      attr(div2, "class", "start fullscreen svelte-5005yv");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(background, div2, null);
      append(div2, t0);
      append(div2, div0);
      append(div0, h1);
      append(h1, img);
      append(h1, t1);
      append(h1, span);
      append(h1, t3);
      append(h1, p2);
      append(div0, t5);
      append(div0, button0);
      append(div0, t7);
      append(div0, button1);
      append(div0, t9);
      append(div0, button2);
      append(div2, t11);
      append(div2, div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*start*/
            ctx[2]
          ),
          listen(
            button1,
            "click",
            /*help*/
            ctx[3]
          ),
          listen(
            button2,
            "click",
            /*exit*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*app*/
      2 && !src_url_equal(img.src, img_src_value = /*app*/
      ctx2[1].metadata.icon)) {
        attr(img, "src", img_src_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(background.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(background.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(background);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$1G(ctx) {
  let page;
  let updating_store;
  let current;
  function page_store_binding(value) {
    ctx[5](value);
  }
  let page_props = {
    name: "start",
    $$slots: { default: [create_default_slot$d] },
    $$scope: { ctx }
  };
  if (
    /*runtime*/
    ctx[0].CurrentPage !== void 0
  ) {
    page_props.store = /*runtime*/
    ctx[0].CurrentPage;
  }
  page = new Page$1({ props: page_props });
  binding_callbacks.push(() => bind$1(page, "store", page_store_binding));
  return {
    c() {
      create_component(page.$$.fragment);
    },
    m(target, anchor) {
      mount_component(page, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const page_changes = {};
      if (dirty & /*$$scope, app*/
      66) {
        page_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_store && dirty & /*runtime*/
      1) {
        updating_store = true;
        page_changes.store = /*runtime*/
        ctx2[0].CurrentPage;
        add_flush_callback(() => updating_store = false);
      }
      page.$set(page_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(page.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(page.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(page, detaching);
    }
  };
}
function instance$1v($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { app } = $$props;
  function start2() {
    runtime.switchPage("game");
  }
  function help() {
    createErrorDialog(
      {
        title: "Qlorb Help",
        component: Help$1,
        buttons: [
          {
            caption: "Understood",
            action() {
            },
            suggested: true
          }
        ]
      },
      runtime.pid,
      true
    );
  }
  function exit() {
    ProcessStack.kill(runtime.pid, true);
  }
  function page_store_binding(value) {
    if ($$self.$$.not_equal(runtime.CurrentPage, value)) {
      runtime.CurrentPage = value;
      $$invalidate(0, runtime);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
  };
  return [runtime, app, start2, help, exit, page_store_binding];
}
class Start extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1v, create_fragment$1G, safe_not_equal, { runtime: 0, app: 1 });
  }
}
const main$9 = "";
function create_if_block$V(ctx) {
  let main2;
  let t0;
  let intro;
  let t1;
  let start2;
  let current;
  main2 = new Main({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  intro = new Intro({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      app: (
        /*app*/
        ctx[1]
      )
    }
  });
  start2 = new Start({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      app: (
        /*app*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(main2.$$.fragment);
      t0 = space();
      create_component(intro.$$.fragment);
      t1 = space();
      create_component(start2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(main2, target, anchor);
      insert(target, t0, anchor);
      mount_component(intro, target, anchor);
      insert(target, t1, anchor);
      mount_component(start2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const main_changes = {};
      if (dirty & /*runtime*/
      1)
        main_changes.runtime = /*runtime*/
        ctx2[0];
      main2.$set(main_changes);
      const intro_changes = {};
      if (dirty & /*runtime*/
      1)
        intro_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*app*/
      2)
        intro_changes.app = /*app*/
        ctx2[1];
      intro.$set(intro_changes);
      const start_changes = {};
      if (dirty & /*runtime*/
      1)
        start_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*app*/
      2)
        start_changes.app = /*app*/
        ctx2[1];
      start2.$set(start_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(main2.$$.fragment, local);
      transition_in(intro.$$.fragment, local);
      transition_in(start2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(main2.$$.fragment, local);
      transition_out(intro.$$.fragment, local);
      transition_out(start2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(main2, detaching);
      destroy_component(intro, detaching);
      destroy_component(start2, detaching);
    }
  };
}
function create_fragment$1F(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*runtime*/
    ctx[0] && create_if_block$V(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*runtime*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*runtime*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$V(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1u($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { app } = $$props;
  onMount(() => {
    runtime.switchPage("intro");
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
  };
  return [runtime, app];
}
let App$7 = class App24 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1u, create_fragment$1F, safe_not_equal, { runtime: 0, app: 1 });
  }
};
const QlorbApp = {
  metadata: {
    name: "Qlorb",
    description: "Click on flying orbs",
    author: "Izaak Kuipers",
    version: "1.0.0",
    icon: QlorbIcon,
    appGroup: "entertainment"
  },
  runtime: QlorbRuntime,
  content: App$7,
  id: "QlorbApp",
  size: { w: 890, h: NaN },
  minSize: { w: 890, h: 600 },
  maxSize: { w: 1200, h: NaN },
  pos: { x: 100, y: 100 },
  state: {
    minimized: false,
    maximized: true,
    headless: false,
    fullscreen: false,
    resizable: true
  },
  controls: {
    minimize: true,
    maximize: true,
    close: true
  },
  singleInstance: true,
  loadCondition: () => !SafeMode.get(),
  helpArticle: HelpArticles.qlorb
};
function create_if_block$U(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let button_class_value;
  let button_disabled_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$g, create_else_block$9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*loading*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "class", button_class_value = "approve level-" + ElevationLevel[
        /*data*/
        ctx[0].level
      ]);
      button.disabled = button_disabled_value = !/*$UserDataStore*/
      ctx[5].sh.securityNoPassword && !/*password*/
      ctx[1] && !/*loading*/
      ctx[4];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*approve*/
            ctx[2]
          ))
            ctx[2].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
      if (!current || dirty & /*data*/
      1 && button_class_value !== (button_class_value = "approve level-" + ElevationLevel[
        /*data*/
        ctx[0].level
      ])) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*$UserDataStore, password, loading*/
      50 && button_disabled_value !== (button_disabled_value = !/*$UserDataStore*/
      ctx[5].sh.securityNoPassword && !/*password*/
      ctx[1] && !/*loading*/
      ctx[4])) {
        button.disabled = button_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$9(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Approve");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$g(ctx) {
  let htmlspinner;
  let current;
  htmlspinner = new HtmlSpinner({ props: { height: 16 } });
  return {
    c() {
      create_component(htmlspinner.$$.fragment);
    },
    m(target, anchor) {
      mount_component(htmlspinner, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(htmlspinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(htmlspinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(htmlspinner, detaching);
    }
  };
}
function create_fragment$1E(ctx) {
  let div1;
  let div0;
  let button;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block = !/*$UserDataStore*/
  ctx[5].sh.elevationDisabled && create_if_block$U(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button = element("button");
      button.textContent = "Reject";
      t1 = space();
      if (if_block)
        if_block.c();
      attr(button, "class", "reject");
      attr(div0, "class", "right");
      attr(div1, "class", "actions");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button);
      append(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*reject*/
            ctx[3]
          ))
            ctx[3].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (!/*$UserDataStore*/
      ctx[5].sh.elevationDisabled) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*$UserDataStore*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$U(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$1t($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(5, $UserDataStore = $$value));
  let { data: data2 } = $$props;
  let { password } = $$props;
  let { approve } = $$props;
  let { reject } = $$props;
  let { loading = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data2 = $$props2.data);
    if ("password" in $$props2)
      $$invalidate(1, password = $$props2.password);
    if ("approve" in $$props2)
      $$invalidate(2, approve = $$props2.approve);
    if ("reject" in $$props2)
      $$invalidate(3, reject = $$props2.reject);
    if ("loading" in $$props2)
      $$invalidate(4, loading = $$props2.loading);
  };
  return [data2, password, approve, reject, loading, $UserDataStore];
}
let Actions$4 = class Actions4 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1t, create_fragment$1E, safe_not_equal, {
      data: 0,
      password: 1,
      approve: 2,
      reject: 3,
      loading: 4
    });
  }
};
function create_fragment$1D(ctx) {
  let div1;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let div0;
  let p0;
  let t1_value = (
    /*data*/
    ctx[0].title + ""
  );
  let t1;
  let t2;
  let p1;
  let t3_value = (
    /*data*/
    ctx[0].description + ""
  );
  let t3;
  return {
    c() {
      div1 = element("div");
      img = element("img");
      t0 = space();
      div0 = element("div");
      p0 = element("p");
      t1 = text(t1_value);
      t2 = space();
      p1 = element("p");
      t3 = text(t3_value);
      if (!src_url_equal(img.src, img_src_value = /*data*/
      ctx[0].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*data*/
      ctx[0].title);
      attr(p0, "class", "title");
      attr(p1, "class", "description");
      attr(div0, "class", "context");
      attr(div1, "class", "display");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, img);
      append(div1, t0);
      append(div1, div0);
      append(div0, p0);
      append(p0, t1);
      append(div0, t2);
      append(div0, p1);
      append(p1, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*data*/
      1 && !src_url_equal(img.src, img_src_value = /*data*/
      ctx2[0].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*data*/
      1 && img_alt_value !== (img_alt_value = /*data*/
      ctx2[0].title)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*data*/
      1 && t1_value !== (t1_value = /*data*/
      ctx2[0].title + ""))
        set_data(t1, t1_value);
      if (dirty & /*data*/
      1 && t3_value !== (t3_value = /*data*/
      ctx2[0].description + ""))
        set_data(t3, t3_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
    }
  };
}
function instance$1s($$self, $$props, $$invalidate) {
  let { data: data2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data2 = $$props2.data);
  };
  return [data2];
}
class Display extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1s, create_fragment$1D, safe_not_equal, { data: 0 });
  }
}
function create_fragment$1C(ctx) {
  let div;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let p2;
  let div_class_value;
  return {
    c() {
      div = element("div");
      img = element("img");
      t0 = space();
      p2 = element("p");
      p2.textContent = "ArcOS Secure Context";
      if (!src_url_equal(img.src, img_src_value = ElevationLevelIcons[
        /*data*/
        ctx[0].level
      ]))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = ElevationLevel[
        /*data*/
        ctx[0].level
      ]);
      attr(div, "class", div_class_value = "header level-" + ElevationLevel[
        /*data*/
        ctx[0].level
      ]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
      append(div, t0);
      append(div, p2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*data*/
      1 && !src_url_equal(img.src, img_src_value = ElevationLevelIcons[
        /*data*/
        ctx2[0].level
      ])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*data*/
      1 && img_alt_value !== (img_alt_value = ElevationLevel[
        /*data*/
        ctx2[0].level
      ])) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*data*/
      1 && div_class_value !== (div_class_value = "header level-" + ElevationLevel[
        /*data*/
        ctx2[0].level
      ])) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$1r($$self, $$props, $$invalidate) {
  let { data: data2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data2 = $$props2.data);
  };
  return [data2];
}
let Header$3 = class Header10 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1r, create_fragment$1C, safe_not_equal, { data: 0 });
  }
};
function create_else_block$8(ctx) {
  let span0;
  let t1;
  let span1;
  return {
    c() {
      span0 = element("span");
      span0.textContent = "report";
      t1 = space();
      span1 = element("span");
      span1.innerHTML = `You can&#39;t continue because elevation is disabled. Click
      <b><i>Security Settings</i></b> to change this behaviour.`;
      attr(span0, "class", "material-icons-round");
    },
    m(target, anchor) {
      insert(target, span0, anchor);
      insert(target, t1, anchor);
      insert(target, span1, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span0);
        detach(t1);
        detach(span1);
      }
    }
  };
}
function create_if_block$T(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (!/*$UserDataStore*/
    ctx2[0].sh.securityNoPassword)
      return create_if_block_1$f;
    if (
      /*$UserDataStore*/
      ctx2[0]
    )
      return create_if_block_2$5;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type_1(ctx2))) {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) {
        if_block.d(detaching);
      }
    }
  };
}
function create_if_block_2$5(ctx) {
  let t0;
  let b2;
  let t2;
  return {
    c() {
      t0 = text("To continue, click ");
      b2 = element("b");
      b2.textContent = "Approve";
      t2 = text(".");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, b2, anchor);
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(b2);
        detach(t2);
      }
    }
  };
}
function create_if_block_1$f(ctx) {
  let t0;
  let b2;
  let t2;
  return {
    c() {
      t0 = text("To continue, type in your password, and then click ");
      b2 = element("b");
      b2.textContent = "Approve";
      t2 = text(".");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, b2, anchor);
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(b2);
        detach(t2);
      }
    }
  };
}
function create_fragment$1B(ctx) {
  let p2;
  function select_block_type(ctx2, dirty) {
    if (!/*$UserDataStore*/
    ctx2[0].sh.elevationDisabled)
      return create_if_block$T;
    return create_else_block$8;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      p2 = element("p");
      if_block.c();
      attr(p2, "class", "notice");
      toggle_class(
        p2,
        "flex",
        /*$UserDataStore*/
        ctx[0].sh.elevationDisabled
      );
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      if_block.m(p2, null);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(p2, null);
        }
      }
      if (dirty & /*$UserDataStore*/
      1) {
        toggle_class(
          p2,
          "flex",
          /*$UserDataStore*/
          ctx2[0].sh.elevationDisabled
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
      if_block.d();
    }
  };
}
function instance$1q($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(0, $UserDataStore = $$value));
  return [$UserDataStore];
}
class Notice extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1q, create_fragment$1B, safe_not_equal, {});
  }
}
function create_if_block$S(ctx) {
  let form;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      form = element("form");
      input = element("input");
      attr(input, "type", "password");
      attr(input, "placeholder", "Password");
      attr(input, "class", "password-field");
      input.disabled = /*loading*/
      ctx[1];
      attr(form, "class", "password-form");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      append(form, input);
      set_input_value(
        input,
        /*password*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[5]
          ),
          listen(
            form,
            "submit",
            /*submit*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*loading*/
      2) {
        input.disabled = /*loading*/
        ctx2[1];
      }
      if (dirty & /*password*/
      1 && input.value !== /*password*/
      ctx2[0]) {
        set_input_value(
          input,
          /*password*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(form);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$1A(ctx) {
  let if_block_anchor;
  let if_block = !/*$UserDataStore*/
  ctx[2].sh.securityNoPassword && !/*$UserDataStore*/
  ctx[2].sh.elevationDisabled && create_if_block$S(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (!/*$UserDataStore*/
      ctx2[2].sh.securityNoPassword && !/*$UserDataStore*/
      ctx2[2].sh.elevationDisabled) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$S(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1p($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(2, $UserDataStore = $$value));
  let { password = "" } = $$props;
  let { approve } = $$props;
  let { loading } = $$props;
  function submit(e2) {
    e2.preventDefault();
    approve();
  }
  function input_input_handler() {
    password = this.value;
    $$invalidate(0, password);
  }
  $$self.$$set = ($$props2) => {
    if ("password" in $$props2)
      $$invalidate(0, password = $$props2.password);
    if ("approve" in $$props2)
      $$invalidate(4, approve = $$props2.approve);
    if ("loading" in $$props2)
      $$invalidate(1, loading = $$props2.loading);
  };
  return [password, loading, $UserDataStore, submit, approve, input_input_handler];
}
class Password extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1p, create_fragment$1A, safe_not_equal, { password: 0, approve: 4, loading: 1 });
  }
}
const main$8 = "";
let Runtime$1 = class Runtime22 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "data", Store$1());
    __publicField(this, "id", Store$1());
    const args = process.args;
    function stop2() {
      ProcessStack.kill(process.pid, true);
      return this;
    }
    if (args.length < 2)
      return stop2();
    const [id, data2] = args;
    if (typeof data2 != "object" || typeof id != "number")
      return stop2();
    this.id.set(id);
    this.data.set(data2);
    ArcSoundBus.playSound("arcos.dialog.info");
  }
};
function create_if_block$R(ctx) {
  let header2;
  let t0;
  let div1;
  let p0;
  let raw_value = (
    /*$data*/
    ctx[4].what + ""
  );
  let t1;
  let display;
  let t2;
  let notice;
  let t3;
  let password_1;
  let updating_password;
  let updating_loading;
  let t4;
  let div0;
  let p1;
  let t5;
  let t6;
  let t7;
  let button;
  let t9;
  let actions;
  let current;
  header2 = new Header$3({ props: { data: (
    /*$data*/
    ctx[4]
  ) } });
  display = new Display({ props: { data: (
    /*$data*/
    ctx[4]
  ) } });
  notice = new Notice({});
  function password_1_password_binding(value) {
    ctx[10](value);
  }
  function password_1_loading_binding(value) {
    ctx[11](value);
  }
  let password_1_props = { approve: (
    /*approve*/
    ctx[8]
  ) };
  if (
    /*password*/
    ctx[0] !== void 0
  ) {
    password_1_props.password = /*password*/
    ctx[0];
  }
  if (
    /*loading*/
    ctx[1] !== void 0
  ) {
    password_1_props.loading = /*loading*/
    ctx[1];
  }
  password_1 = new Password({ props: password_1_props });
  binding_callbacks.push(() => bind$1(password_1, "password", password_1_password_binding));
  binding_callbacks.push(() => bind$1(password_1, "loading", password_1_loading_binding));
  actions = new Actions$4({
    props: {
      data: (
        /*$data*/
        ctx[4]
      ),
      password: (
        /*password*/
        ctx[0]
      ),
      approve: (
        /*approve*/
        ctx[8]
      ),
      reject: (
        /*reject*/
        ctx[7]
      ),
      loading: (
        /*loading*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(header2.$$.fragment);
      t0 = space();
      div1 = element("div");
      p0 = element("p");
      t1 = space();
      create_component(display.$$.fragment);
      t2 = space();
      create_component(notice.$$.fragment);
      t3 = space();
      create_component(password_1.$$.fragment);
      t4 = space();
      div0 = element("div");
      p1 = element("p");
      t5 = text("Authorizing as ");
      t6 = text(
        /*$UserName*/
        ctx[3]
      );
      t7 = space();
      button = element("button");
      button.textContent = "Security Settings";
      t9 = space();
      create_component(actions.$$.fragment);
      attr(p0, "class", "what");
      attr(p1, "class", "whoami");
      attr(button, "class", "link settings");
      attr(div0, "class", "login-status");
      attr(div1, "class", "top");
    },
    m(target, anchor) {
      mount_component(header2, target, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      append(div1, p0);
      p0.innerHTML = raw_value;
      append(div1, t1);
      mount_component(display, div1, null);
      append(div1, t2);
      mount_component(notice, div1, null);
      append(div1, t3);
      mount_component(password_1, div1, null);
      append(div1, t4);
      append(div1, div0);
      append(div0, p1);
      append(p1, t5);
      append(p1, t6);
      append(div0, t7);
      append(div0, button);
      insert(target, t9, anchor);
      mount_component(actions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty & /*$data*/
      16)
        header_changes.data = /*$data*/
        ctx2[4];
      header2.$set(header_changes);
      if ((!current || dirty & /*$data*/
      16) && raw_value !== (raw_value = /*$data*/
      ctx2[4].what + ""))
        p0.innerHTML = raw_value;
      const display_changes = {};
      if (dirty & /*$data*/
      16)
        display_changes.data = /*$data*/
        ctx2[4];
      display.$set(display_changes);
      const password_1_changes = {};
      if (!updating_password && dirty & /*password*/
      1) {
        updating_password = true;
        password_1_changes.password = /*password*/
        ctx2[0];
        add_flush_callback(() => updating_password = false);
      }
      if (!updating_loading && dirty & /*loading*/
      2) {
        updating_loading = true;
        password_1_changes.loading = /*loading*/
        ctx2[1];
        add_flush_callback(() => updating_loading = false);
      }
      password_1.$set(password_1_changes);
      if (!current || dirty & /*$UserName*/
      8)
        set_data(
          t6,
          /*$UserName*/
          ctx2[3]
        );
      const actions_changes = {};
      if (dirty & /*$data*/
      16)
        actions_changes.data = /*$data*/
        ctx2[4];
      if (dirty & /*password*/
      1)
        actions_changes.password = /*password*/
        ctx2[0];
      if (dirty & /*loading*/
      2)
        actions_changes.loading = /*loading*/
        ctx2[1];
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(display.$$.fragment, local);
      transition_in(notice.$$.fragment, local);
      transition_in(password_1.$$.fragment, local);
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(display.$$.fragment, local);
      transition_out(notice.$$.fragment, local);
      transition_out(password_1.$$.fragment, local);
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div1);
        detach(t9);
      }
      destroy_component(header2, detaching);
      destroy_component(display);
      destroy_component(notice);
      destroy_component(password_1);
      destroy_component(actions, detaching);
    }
  };
}
function create_fragment$1z(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$id*/
    ctx[2] && /*$data*/
    ctx[4] && create_if_block$R(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$id*/
        ctx2[2] && /*$data*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$id, $data*/
          20) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$R(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1o($$self, $$props, $$invalidate) {
  let $id;
  let $UserName;
  let $UserDataStore;
  let $data;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(3, $UserName = $$value));
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(12, $UserDataStore = $$value));
  let { runtime } = $$props;
  const { id, data: data2 } = runtime;
  component_subscribe($$self, id, (value) => $$invalidate(2, $id = value));
  component_subscribe($$self, data2, (value) => $$invalidate(4, $data = value));
  let password;
  let loading = false;
  async function reject() {
    GlobalDispatch.dispatch("elevation-reject", [$id]);
    exit();
  }
  async function approve() {
    if (loading)
      return;
    $$invalidate(1, loading = true);
    const valid = $UserDataStore.sh.securityNoPassword || await Authenticate($UserName, password, false);
    if (!valid) {
      createErrorDialog(
        {
          title: "Authentication failed",
          message: "The password you entered is incorrect. Please try typing it again.",
          sound: "arcos.dialog.error",
          image: ErrorIcon,
          buttons: [
            {
              caption: "Okay",
              action() {
                $$invalidate(1, loading = false);
              },
              suggested: true
            }
          ]
        },
        runtime.pid,
        true
      );
      return;
    }
    GlobalDispatch.dispatch("elevation-accept", [$id]);
    exit();
  }
  function exit() {
    ProcessStack.kill(runtime.pid, true);
  }
  function password_1_password_binding(value) {
    password = value;
    $$invalidate(0, password);
  }
  function password_1_loading_binding(value) {
    loading = value;
    $$invalidate(1, loading);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(9, runtime = $$props2.runtime);
  };
  return [
    password,
    loading,
    $id,
    $UserName,
    $data,
    id,
    data2,
    reject,
    approve,
    runtime,
    password_1_password_binding,
    password_1_loading_binding
  ];
}
let App$6 = class App25 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1o, create_fragment$1z, safe_not_equal, { runtime: 9 });
  }
};
const SecureContext = {
  metadata: {
    name: "Secure Context",
    description: "Asks for confirmation to perform dangerous tasks",
    author: "The ArcOS Team",
    version: "1.0.0",
    icon: SecureIcon,
    hidden: true,
    appGroup: "internal",
    noCloseAccelerator: true
  },
  runtime: Runtime$1,
  content: App$6,
  id: "SecureContext",
  size: { w: 385, h: 370 },
  minSize: { w: 385, h: 370 },
  maxSize: { w: 385, h: 370 },
  pos: { x: 40, y: 40 },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: {
    minimize: false,
    maximize: false,
    close: false
  },
  singleInstance: true,
  spawnCondition: () => isServiceRunning("ElevationService")
};
function create_fragment$1y(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.innerHTML = `The Start Condition is a condition that must be met for the<br/>
  Service to be started. If the Start Condition doesn&#39;t match,<br/>
  the Start process is aborted.`;
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
class StartCondition extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$1y, safe_not_equal, {});
  }
}
class ServiceInfoRuntime extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "_targetService", Store$1());
    __publicField(this, "_targetId", Store$1());
    function stop2(arg2) {
      process.handler.kill(process.pid, true);
      const suffix = arg2 ? ` Service "${arg2}" could not be found.` : "";
      sendNotification({
        title: "Can't open Service Info",
        message: `Service Info was opened without a valid Service ID to pull the information from.${suffix}`,
        image: ServiceInfoIcon
        /* timeout: 3000, */
      });
    }
    const arg = process.args[0];
    if (!arg || typeof arg !== "string") {
      stop2();
      this.Log(
        "Not opening ServiceInfo without an ID to pull data from",
        "constructor",
        LogLevel.error
      );
      return;
    }
    const targetService = getService(arg);
    if (!targetService) {
      stop2(arg);
      this.Log(
        "Not opening ServiceInfo without a valid app-ID to pull data from.",
        "constructor",
        LogLevel.error
      );
      return;
    }
    this.setWindowTitle(`Information about ${targetService.name}`);
    this._targetId.set(arg);
    this._targetService.set(targetService);
  }
  startConditionDialog() {
    createErrorDialog(
      {
        title: "Start Condition",
        component: StartCondition,
        buttons: [{ caption: "Understood", action() {
        }, suggested: true }],
        image: ServiceInfoIcon,
        sound: "arcos.dialog.info"
      },
      this.process.pid,
      true
    );
  }
}
function create_default_slot_1$9(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Close";
      attr(button, "class", "suggested");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*close*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$c(ctx) {
  let inforow;
  let current;
  inforow = new InfoRow({
    props: {
      $$slots: { default: [create_default_slot_1$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(inforow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inforow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inforow_changes = {};
      if (dirty & /*$$scope*/
      4) {
        inforow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inforow.$set(inforow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inforow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inforow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inforow, detaching);
    }
  };
}
function create_fragment$1x(ctx) {
  let infoblock;
  let current;
  infoblock = new InfoBlock({
    props: {
      className: "actions",
      $$slots: { default: [create_default_slot$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(infoblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(infoblock, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const infoblock_changes = {};
      if (dirty & /*$$scope*/
      4) {
        infoblock_changes.$$scope = { dirty, ctx: ctx2 };
      }
      infoblock.$set(infoblock_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(infoblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(infoblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(infoblock, detaching);
    }
  };
}
function instance$1n($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  function close() {
    runtime.process.handler.kill(runtime.process.pid, true);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [close, runtime];
}
let Actions$3 = class Actions5 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1n, create_fragment$1x, safe_not_equal, { runtime: 1 });
  }
};
function create_fragment$1w(ctx) {
  let div3;
  let div1;
  let img;
  let img_src_value;
  let t0;
  let div0;
  let p0;
  let span;
  let t1_value = (
    /*target*/
    ctx[0].name + ""
  );
  let t1;
  let t2;
  let p1;
  let t3_value = (
    /*target*/
    ctx[0].description + ""
  );
  let t3;
  let t4;
  let div2;
  let button;
  let t5_value = (
    /*stopped*/
    ctx[1] ? "Start" : "Stop"
  );
  let t5;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      img = element("img");
      t0 = space();
      div0 = element("div");
      p0 = element("p");
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      p1 = element("p");
      t3 = text(t3_value);
      t4 = space();
      div2 = element("div");
      button = element("button");
      t5 = text(t5_value);
      if (!src_url_equal(img.src, img_src_value = ServiceInfoIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(p0, "class", "name");
      attr(p1, "class", "description");
      attr(div0, "class", "base-info");
      attr(div1, "class", "left");
      attr(button, "class", "flip");
      toggle_class(
        button,
        "stopped",
        /*stopped*/
        ctx[1]
      );
      attr(div2, "class", "right");
      attr(div3, "class", "header");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, img);
      append(div1, t0);
      append(div1, div0);
      append(div0, p0);
      append(p0, span);
      append(span, t1);
      append(div0, t2);
      append(div0, p1);
      append(p1, t3);
      append(div3, t4);
      append(div3, div2);
      append(div2, button);
      append(button, t5);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggleDisable*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*target*/
      1 && t1_value !== (t1_value = /*target*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*target*/
      1 && t3_value !== (t3_value = /*target*/
      ctx2[0].description + ""))
        set_data(t3, t3_value);
      if (dirty & /*stopped*/
      2 && t5_value !== (t5_value = /*stopped*/
      ctx2[1] ? "Start" : "Stop"))
        set_data(t5, t5_value);
      if (dirty & /*stopped*/
      2) {
        toggle_class(
          button,
          "stopped",
          /*stopped*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$1m($$self, $$props, $$invalidate) {
  let { target } = $$props;
  let { id } = $$props;
  let stopped = false;
  function update2() {
    $$invalidate(1, stopped = !getService(id).pid);
  }
  onMount(update2);
  GlobalDispatch.subscribe("services-flush", update2);
  async function toggleDisable() {
    if (target.pid)
      await stopServiceNotified(id);
    else
      await startServiceNotified(id);
  }
  $$self.$$set = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
    if ("id" in $$props2)
      $$invalidate(3, id = $$props2.id);
  };
  return [target, stopped, toggleDisable, id];
}
let Header$2 = class Header11 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1m, create_fragment$1w, safe_not_equal, { target: 0, id: 3 });
  }
};
function create_default_slot_9(ctx) {
  let t_value = (
    /*target*/
    ctx[0].id + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*target*/
      1 && t_value !== (t_value = /*target*/
      ctx2[0].id + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_8(ctx) {
  let t_value = (
    /*target*/
    (ctx[0].initialState || "stopped") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*target*/
      1 && t_value !== (t_value = /*target*/
      (ctx2[0].initialState || "stopped") + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_7(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Stack");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_6(ctx) {
  let segment0;
  let t0;
  let segment1;
  let t1;
  let segment2;
  let current;
  segment0 = new Segment({
    props: {
      title: "Identifier",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  segment1 = new Segment({
    props: {
      title: "Initial State",
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  segment2 = new Segment({
    props: {
      title: "Handler",
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(segment0.$$.fragment);
      t0 = space();
      create_component(segment1.$$.fragment);
      t1 = space();
      create_component(segment2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(segment0, target, anchor);
      insert(target, t0, anchor);
      mount_component(segment1, target, anchor);
      insert(target, t1, anchor);
      mount_component(segment2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const segment0_changes = {};
      if (dirty & /*$$scope, target*/
      33) {
        segment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment0.$set(segment0_changes);
      const segment1_changes = {};
      if (dirty & /*$$scope, target*/
      33) {
        segment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment1.$set(segment1_changes);
      const segment2_changes = {};
      if (dirty & /*$$scope*/
      32) {
        segment2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment2.$set(segment2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(segment0.$$.fragment, local);
      transition_in(segment1.$$.fragment, local);
      transition_in(segment2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(segment0.$$.fragment, local);
      transition_out(segment1.$$.fragment, local);
      transition_out(segment2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(segment0, detaching);
      destroy_component(segment1, detaching);
      destroy_component(segment2, detaching);
    }
  };
}
function create_default_slot_5(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*loadedAt*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_4(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*changedAt*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_3$4(ctx) {
  let segment0;
  let t2;
  let segment1;
  let current;
  segment0 = new Segment({
    props: {
      title: "Loaded At",
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  segment1 = new Segment({
    props: {
      title: "Changed At",
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(segment0.$$.fragment);
      t2 = space();
      create_component(segment1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(segment0, target, anchor);
      insert(target, t2, anchor);
      mount_component(segment1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const segment0_changes = {};
      if (dirty & /*$$scope*/
      32) {
        segment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment0.$set(segment0_changes);
      const segment1_changes = {};
      if (dirty & /*$$scope*/
      32) {
        segment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment1.$set(segment1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(segment0.$$.fragment, local);
      transition_in(segment1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(segment0.$$.fragment, local);
      transition_out(segment1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(segment0, detaching);
      destroy_component(segment1, detaching);
    }
  };
}
function create_if_block$Q(ctx) {
  let inforow;
  let current;
  inforow = new InfoRow({
    props: {
      $$slots: { default: [create_default_slot_1$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(inforow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inforow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inforow_changes = {};
      if (dirty & /*$$scope, target*/
      33) {
        inforow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inforow.$set(inforow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inforow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inforow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inforow, detaching);
    }
  };
}
function create_default_slot_2$7(ctx) {
  let code;
  let t_value = (
    /*target*/
    ctx[0].startCondition + ""
  );
  let t2;
  return {
    c() {
      code = element("code");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, code, anchor);
      append(code, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*target*/
      1 && t_value !== (t_value = /*target*/
      ctx2[0].startCondition + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(code);
      }
    }
  };
}
function create_default_slot_1$8(ctx) {
  let segment;
  let current;
  segment = new Segment({
    props: {
      title: "Start Condition",
      help: (
        /*startConditionHelp*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_2$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(segment.$$.fragment);
    },
    m(target, anchor) {
      mount_component(segment, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const segment_changes = {};
      if (dirty & /*$$scope, target*/
      33) {
        segment_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment.$set(segment_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(segment.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(segment.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(segment, detaching);
    }
  };
}
function create_default_slot$b(ctx) {
  let inforow0;
  let t0;
  let inforow1;
  let t1;
  let if_block_anchor;
  let current;
  inforow0 = new InfoRow({
    props: {
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  inforow1 = new InfoRow({
    props: {
      $$slots: { default: [create_default_slot_3$4] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*target*/
    ctx[0].startCondition && create_if_block$Q(ctx)
  );
  return {
    c() {
      create_component(inforow0.$$.fragment);
      t0 = space();
      create_component(inforow1.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(inforow0, target, anchor);
      insert(target, t0, anchor);
      mount_component(inforow1, target, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inforow0_changes = {};
      if (dirty & /*$$scope, target*/
      33) {
        inforow0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inforow0.$set(inforow0_changes);
      const inforow1_changes = {};
      if (dirty & /*$$scope*/
      32) {
        inforow1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inforow1.$set(inforow1_changes);
      if (
        /*target*/
        ctx2[0].startCondition
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*target*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$Q(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(inforow0.$$.fragment, local);
      transition_in(inforow1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(inforow0.$$.fragment, local);
      transition_out(inforow1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block_anchor);
      }
      destroy_component(inforow0, detaching);
      destroy_component(inforow1, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$1v(ctx) {
  let infoblock;
  let current;
  infoblock = new InfoBlock({
    props: {
      $$slots: { default: [create_default_slot$b] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(infoblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(infoblock, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const infoblock_changes = {};
      if (dirty & /*$$scope, target*/
      33) {
        infoblock_changes.$$scope = { dirty, ctx: ctx2 };
      }
      infoblock.$set(infoblock_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(infoblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(infoblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(infoblock, detaching);
    }
  };
}
function instance$1l($$self, $$props, $$invalidate) {
  let { target } = $$props;
  let { runtime } = $$props;
  const loadedAt = dayjs(target.loadedAt).format("MMM D, HH:mm:ss");
  const changedAt = dayjs(target.changedAt).format("MMM D, HH:mm:ss");
  function startConditionHelp() {
    runtime.startConditionDialog();
  }
  $$self.$$set = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
    if ("runtime" in $$props2)
      $$invalidate(4, runtime = $$props2.runtime);
  };
  return [target, loadedAt, changedAt, startConditionHelp, runtime];
}
class IndepthInfo2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1l, create_fragment$1v, safe_not_equal, { target: 0, runtime: 4 });
  }
}
function create_if_block$P(ctx) {
  let infoblock;
  let current;
  infoblock = new InfoBlock({
    props: {
      $$slots: { default: [create_default_slot$a] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(infoblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(infoblock, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const infoblock_changes = {};
      if (dirty & /*$$scope, service*/
      9) {
        infoblock_changes.$$scope = { dirty, ctx: ctx2 };
      }
      infoblock.$set(infoblock_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(infoblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(infoblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(infoblock, detaching);
    }
  };
}
function create_default_slot_3$3(ctx) {
  let t_value = (
    /*service*/
    ctx[0].pid ? "Running" : "Stopped"
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*service*/
      1 && t_value !== (t_value = /*service*/
      ctx2[0].pid ? "Running" : "Stopped"))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_2$6(ctx) {
  let t_value = (
    /*service*/
    (ctx[0].pid || "-") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*service*/
      1 && t_value !== (t_value = /*service*/
      (ctx2[0].pid || "-") + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$7(ctx) {
  let segment0;
  let t2;
  let segment1;
  let current;
  segment0 = new Segment({
    props: {
      title: "Status",
      $$slots: { default: [create_default_slot_3$3] },
      $$scope: { ctx }
    }
  });
  segment1 = new Segment({
    props: {
      title: "First PID",
      $$slots: { default: [create_default_slot_2$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(segment0.$$.fragment);
      t2 = space();
      create_component(segment1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(segment0, target, anchor);
      insert(target, t2, anchor);
      mount_component(segment1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const segment0_changes = {};
      if (dirty & /*$$scope, service*/
      9) {
        segment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment0.$set(segment0_changes);
      const segment1_changes = {};
      if (dirty & /*$$scope, service*/
      9) {
        segment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      segment1.$set(segment1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(segment0.$$.fragment, local);
      transition_in(segment1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(segment0.$$.fragment, local);
      transition_out(segment1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(segment0, detaching);
      destroy_component(segment1, detaching);
    }
  };
}
function create_default_slot$a(ctx) {
  let inforow;
  let current;
  inforow = new InfoRow({
    props: {
      $$slots: { default: [create_default_slot_1$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(inforow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inforow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inforow_changes = {};
      if (dirty & /*$$scope, service*/
      9) {
        inforow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inforow.$set(inforow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inforow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inforow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inforow, detaching);
    }
  };
}
function create_fragment$1u(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*service*/
    ctx[0] && create_if_block$P(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*service*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*service*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$P(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1k($$self, $$props, $$invalidate) {
  let { id } = $$props;
  let service;
  function update2() {
    $$invalidate(0, service = getService(id));
  }
  onMount(update2);
  GlobalDispatch.subscribe("services-flush", update2);
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
  };
  return [service, id];
}
class ProcessInfo2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1k, create_fragment$1u, safe_not_equal, { id: 1 });
  }
}
const main$7 = "";
function create_if_block$O(ctx) {
  let header2;
  let t0;
  let indepthinfo;
  let t1;
  let processinfo;
  let t2;
  let actions;
  let current;
  header2 = new Header$2({
    props: {
      target: (
        /*target*/
        ctx[2]
      ),
      id: (
        /*id*/
        ctx[1]
      )
    }
  });
  indepthinfo = new IndepthInfo2({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      target: (
        /*target*/
        ctx[2]
      )
    }
  });
  processinfo = new ProcessInfo2({ props: { id: (
    /*id*/
    ctx[1]
  ) } });
  actions = new Actions$3({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(header2.$$.fragment);
      t0 = space();
      create_component(indepthinfo.$$.fragment);
      t1 = space();
      create_component(processinfo.$$.fragment);
      t2 = space();
      create_component(actions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(header2, target, anchor);
      insert(target, t0, anchor);
      mount_component(indepthinfo, target, anchor);
      insert(target, t1, anchor);
      mount_component(processinfo, target, anchor);
      insert(target, t2, anchor);
      mount_component(actions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty & /*target*/
      4)
        header_changes.target = /*target*/
        ctx2[2];
      if (dirty & /*id*/
      2)
        header_changes.id = /*id*/
        ctx2[1];
      header2.$set(header_changes);
      const indepthinfo_changes = {};
      if (dirty & /*runtime*/
      1)
        indepthinfo_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*target*/
      4)
        indepthinfo_changes.target = /*target*/
        ctx2[2];
      indepthinfo.$set(indepthinfo_changes);
      const processinfo_changes = {};
      if (dirty & /*id*/
      2)
        processinfo_changes.id = /*id*/
        ctx2[1];
      processinfo.$set(processinfo_changes);
      const actions_changes = {};
      if (dirty & /*runtime*/
      1)
        actions_changes.runtime = /*runtime*/
        ctx2[0];
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(indepthinfo.$$.fragment, local);
      transition_in(processinfo.$$.fragment, local);
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(indepthinfo.$$.fragment, local);
      transition_out(processinfo.$$.fragment, local);
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(header2, detaching);
      destroy_component(indepthinfo, detaching);
      destroy_component(processinfo, detaching);
      destroy_component(actions, detaching);
    }
  };
}
function create_fragment$1t(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*id*/
    ctx[1] && /*target*/
    ctx[2] && create_if_block$O(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*id*/
        ctx2[1] && /*target*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*id, target*/
          6) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$O(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1j($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let id;
  let target;
  onMount(() => {
    runtime._targetService.subscribe((v2) => $$invalidate(2, target = v2));
    runtime._targetId.subscribe((v2) => $$invalidate(1, id = v2));
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, id, target];
}
let App$5 = class App26 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1j, create_fragment$1t, safe_not_equal, { runtime: 0 });
  }
};
const ServiceInfo = {
  metadata: {
    name: "Service Info",
    description: "View information about an app",
    author: "The ArcOS Team",
    version: "2.0.0",
    appGroup: "internal",
    icon: ServiceInfoIcon,
    hidden: true
  },
  runtime: ServiceInfoRuntime,
  content: App$5,
  id: "ServiceInfo",
  size: { w: 500, h: NaN },
  minSize: { w: 500, h: 450 },
  maxSize: { w: 500, h: 460 },
  pos: { x: 120, y: 60 },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: {
    minimize: true,
    maximize: false,
    close: true
  },
  glass: true
};
const processrenderer = "";
const window$1 = "";
function generateCSS(app) {
  if (!app || app.metadata.core)
    return "";
  let cssString = "";
  let minHeight = app.minSize.h ? app.minSize.h + 40 : app.minSize.h;
  let maxHeight = app.maxSize.h ? app.maxSize.h + 40 : app.maxSize.h;
  let height = app.size.h ? app.size.h + 40 : app.size.h;
  if (app.isOverlay || app.state.headless)
    minHeight -= 40;
  if (app.isOverlay || app.state.headless)
    maxHeight -= 40;
  if (app.isOverlay || app.state.headless)
    height -= 40;
  cssString += `min-width: ${app.minSize.w}px;`;
  cssString += `min-height: ${minHeight}px;`;
  cssString += `max-width: ${app.maxSize.w}px;`;
  cssString += `max-height: ${maxHeight}px;`;
  cssString += `width: ${app.size.w}px;`;
  cssString += `height: ${height}px;`;
  if (!app.isOverlay)
    cssString += `z-index: ${maxZIndex.get() + 1}`;
  return cssString;
}
var t$1 = { dragStart: true }, e$1 = (t2, e2, n2) => Math.min(Math.max(t2, e2), n2), n$1 = (t2) => "string" == typeof t2, r$1 = ([t2, e2], n2, r2) => {
  const o2 = (t3, e3) => 0 === e3 ? 0 : Math.ceil(t3 / e3) * e3;
  return [o2(n2, t2), o2(r2, e2)];
};
var o$1 = (t2, e2) => t2.some((t3) => e2.some((e3) => t3.contains(e3)));
function i$1(t2, e2) {
  if (void 0 === t2)
    return;
  if (s$1(t2))
    return t2.getBoundingClientRect();
  if ("object" == typeof t2) {
    const { top: e3 = 0, left: n3 = 0, right: r2 = 0, bottom: o2 = 0 } = t2;
    return { top: e3, right: window.innerWidth - r2, bottom: window.innerHeight - o2, left: n3 };
  }
  if ("parent" === t2)
    return e2.parentNode.getBoundingClientRect();
  const n2 = document.querySelector(t2);
  if (null === n2)
    throw new Error("The selector provided for bound doesn't exists in the document.");
  return n2.getBoundingClientRect();
}
var a$1 = (t2, e2, n2) => t2.style.setProperty(e2, n2), s$1 = (t2) => t2 instanceof HTMLElement, d$1 = (d3, l2 = {}) => {
  let c2, u3, { bounds: f2, axis: g2 = "both", gpuAcceleration: h2 = true, legacyTranslate: p2 = true, transform: m3, applyUserSelectHack: y2 = true, disabled: b2 = false, ignoreMultitouch: w2 = false, recomputeBounds: v2 = t$1, grid: x2, position: E2, cancel: S2, handle: A2, defaultClass: C2 = "neodrag", defaultClassDragging: N2 = "neodrag-dragging", defaultClassDragged: D2 = "neodrag-dragged", defaultPosition: M2 = { x: 0, y: 0 }, onDragStart: B2, onDrag: $2, onDragEnd: R2 } = l2, H2 = false, L2 = 0, P2 = 0, T2 = 0, X2 = 0, Y2 = 0, q2 = 0, { x: k2, y: U2 } = E2 ? { x: (E2 == null ? void 0 : E2.x) ?? 0, y: (E2 == null ? void 0 : E2.y) ?? 0 } : M2;
  Q2(k2, U2);
  let W2, j2, z2, F2, G2, I2 = "", J2 = !!E2;
  v2 = { ...t$1, ...v2 };
  const K2 = document.body.style, O2 = d3.classList;
  function Q2(t2 = L2, e2 = P2) {
    if (!m3) {
      if (p2) {
        let n2 = `${+t2}px, ${+e2}px`;
        return a$1(d3, "transform", h2 ? `translate3d(${n2}, 0)` : `translate(${n2})`);
      }
      return a$1(d3, "translate", `${+t2}px ${+e2}px ${h2 ? "1px" : ""}`);
    }
    const r2 = m3({ offsetX: t2, offsetY: e2, rootNode: d3 });
    n$1(r2) && a$1(d3, "transform", r2);
  }
  const V2 = (t2, e2) => {
    const n2 = { offsetX: L2, offsetY: P2, rootNode: d3, currentNode: G2 };
    d3.dispatchEvent(new CustomEvent(t2, { detail: n2 })), e2 == null ? void 0 : e2(n2);
  };
  const Z2 = addEventListener;
  Z2("pointerdown", tt2, false), Z2("pointerup", et2, false), Z2("pointermove", nt2, false), a$1(d3, "touch-action", "none");
  const _2 = () => {
    let t2 = d3.offsetWidth / j2.width;
    return isNaN(t2) && (t2 = 1), t2;
  };
  function tt2(t2) {
    if (b2)
      return;
    if (2 === t2.button)
      return;
    if (w2 && !t2.isPrimary)
      return;
    if (v2.dragStart && (W2 = i$1(f2, d3)), n$1(A2) && n$1(S2) && A2 === S2)
      throw new Error("`handle` selector can't be same as `cancel` selector");
    if (O2.add(C2), z2 = function(t3, e3) {
      if (!t3)
        return [e3];
      if (s$1(t3))
        return [t3];
      if (Array.isArray(t3))
        return t3;
      const n2 = e3.querySelectorAll(t3);
      if (null === n2)
        throw new Error("Selector passed for `handle` option should be child of the element on which the action is applied");
      return Array.from(n2.values());
    }(A2, d3), F2 = function(t3, e3) {
      if (!t3)
        return [];
      if (s$1(t3))
        return [t3];
      if (Array.isArray(t3))
        return t3;
      const n2 = e3.querySelectorAll(t3);
      if (null === n2)
        throw new Error("Selector passed for `cancel` option should be child of the element on which the action is applied");
      return Array.from(n2.values());
    }(S2, d3), c2 = /(both|x)/.test(g2), u3 = /(both|y)/.test(g2), o$1(F2, z2))
      throw new Error("Element being dragged can't be a child of the element on which `cancel` is applied");
    const e2 = t2.composedPath()[0];
    if (!z2.some((t3) => {
      var _a;
      return t3.contains(e2) || ((_a = t3.shadowRoot) == null ? void 0 : _a.contains(e2));
    }) || o$1(F2, [e2]))
      return;
    G2 = 1 === z2.length ? d3 : z2.find((t3) => t3.contains(e2)), H2 = true, j2 = d3.getBoundingClientRect(), y2 && (I2 = K2.userSelect, K2.userSelect = "none"), V2("neodrag:start", B2);
    const { clientX: r2, clientY: a2 } = t2, l3 = _2();
    c2 && (T2 = r2 - k2 / l3), u3 && (X2 = a2 - U2 / l3), W2 && (Y2 = r2 - j2.left, q2 = a2 - j2.top);
  }
  function et2() {
    H2 && (v2.dragEnd && (W2 = i$1(f2, d3)), O2.remove(N2), O2.add(D2), y2 && (K2.userSelect = I2), V2("neodrag:end", R2), c2 && (T2 = L2), u3 && (X2 = P2), H2 = false);
  }
  function nt2(t2) {
    if (!H2)
      return;
    v2.drag && (W2 = i$1(f2, d3)), O2.add(N2), t2.preventDefault(), j2 = d3.getBoundingClientRect();
    let n2 = t2.clientX, o2 = t2.clientY;
    const a2 = _2();
    if (W2) {
      const t3 = { left: W2.left + Y2, top: W2.top + q2, right: W2.right + Y2 - j2.width, bottom: W2.bottom + q2 - j2.height };
      n2 = e$1(n2, t3.left, t3.right), o2 = e$1(o2, t3.top, t3.bottom);
    }
    if (Array.isArray(x2)) {
      let [t3, e2] = x2;
      if (isNaN(+t3) || t3 < 0)
        throw new Error("1st argument of `grid` must be a valid positive number");
      if (isNaN(+e2) || e2 < 0)
        throw new Error("2nd argument of `grid` must be a valid positive number");
      let i2 = n2 - T2, s2 = o2 - X2;
      [i2, s2] = r$1([t3 / a2, e2 / a2], i2, s2), n2 = T2 + i2, o2 = X2 + s2;
    }
    c2 && (L2 = Math.round((n2 - T2) * a2)), u3 && (P2 = Math.round((o2 - X2) * a2)), k2 = L2, U2 = P2, V2("neodrag", $2), Q2();
  }
  return { destroy: () => {
    const t2 = removeEventListener;
    t2("pointerdown", tt2, false), t2("pointerup", et2, false), t2("pointermove", nt2, false);
  }, update: (e2) => {
    var _a, _b;
    g2 = e2.axis || "both", b2 = e2.disabled ?? false, w2 = e2.ignoreMultitouch ?? false, A2 = e2.handle, f2 = e2.bounds, v2 = e2.recomputeBounds ?? t$1, S2 = e2.cancel, y2 = e2.applyUserSelectHack ?? true, x2 = e2.grid, h2 = e2.gpuAcceleration ?? true, p2 = e2.legacyTranslate ?? true, m3 = e2.transform;
    const n2 = O2.contains(D2);
    O2.remove(C2, D2), C2 = e2.defaultClass ?? "neodrag", N2 = e2.defaultClassDragging ?? "neodrag-dragging", D2 = e2.defaultClassDragged ?? "neodrag-dragged", O2.add(C2), n2 && O2.add(D2), J2 && (k2 = L2 = ((_a = e2.position) == null ? void 0 : _a.x) ?? L2, U2 = P2 = ((_b = e2.position) == null ? void 0 : _b.y) ?? P2, Q2());
  } };
};
function get_each_context$j(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list2[i2][0];
  child_ctx[2] = list2[i2][1];
  return child_ctx;
}
function create_if_block_1$e(ctx) {
  let window2;
  let current;
  window2 = new Window({
    props: {
      id: (
        /*proc*/
        ctx[2].app.id
      ),
      pid: (
        /*pid*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(window2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(window2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const window_changes = {};
      if (dirty & /*map*/
      2)
        window_changes.id = /*proc*/
        ctx2[2].app.id;
      if (dirty & /*map*/
      2)
        window_changes.pid = /*pid*/
        ctx2[0];
      window2.$set(window_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(window2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(window2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(window2, detaching);
    }
  };
}
function create_if_block$N(ctx) {
  let div;
  let div_class_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = "disposed pid-" + /*pid*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*map*/
      2 && div_class_value !== (div_class_value = "disposed pid-" + /*pid*/
      ctx2[0])) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block$j(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$N, create_if_block_1$e];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*proc*/
      ctx2[2]._disposed
    )
      return 0;
    if (
      /*proc*/
      ctx2[2].app && /*proc*/
      ctx2[2].parentPid && !/*proc*/
      ctx2[2].app.isOverlay
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function create_fragment$1s(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like([.../*map*/
  ctx[1]]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$j(get_each_context$j(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "process-renderer subprocesses");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*map*/
      2) {
        each_value = ensure_array_like([.../*map*/
        ctx2[1]]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$j(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$j(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$1i($$self, $$props, $$invalidate) {
  let { pid } = $$props;
  let map;
  ProcessStack.processes.subscribe(() => {
    $$invalidate(1, map = null);
    $$invalidate(1, map = ProcessStack.getSubProcesses(pid));
  });
  $$self.$$set = ($$props2) => {
    if ("pid" in $$props2)
      $$invalidate(0, pid = $$props2.pid);
  };
  return [pid, map];
}
class SubProcessRenderer extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1i, create_fragment$1s, safe_not_equal, { pid: 0 });
  }
}
function create_if_block$M(ctx) {
  let t0;
  let window2;
  let div;
  let t1;
  let overlayprocessrenderer;
  let window_id_value;
  let t2;
  let subprocessrenderer;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !/*$appData*/
  ctx[6].noOverlayShade && create_if_block_2$4(ctx);
  let if_block1 = (
    /*visible*/
    ctx[2] && create_if_block_1$d(ctx)
  );
  overlayprocessrenderer = new OverlayProcessRenderer({ props: { pid: (
    /*pid*/
    ctx[0]
  ) } });
  subprocessrenderer = new SubProcessRenderer({ props: { pid: (
    /*pid*/
    ctx[0]
  ) } });
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      window2 = element("window");
      div = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      create_component(overlayprocessrenderer.$$.fragment);
      t2 = space();
      create_component(subprocessrenderer.$$.fragment);
      attr(div, "class", "body");
      attr(
        window2,
        "data-pid",
        /*pid*/
        ctx[0]
      );
      attr(window2, "id", window_id_value = /*$appData*/
      ctx[6].id);
      attr(window2, "class", "overlay headless shell-colored");
      attr(
        window2,
        "style",
        /*style*/
        ctx[4]
      );
      toggle_class(
        window2,
        "colored",
        /*$UserDataStore*/
        ctx[7].sh.taskbar.colored
      );
      toggle_class(
        window2,
        "resizable",
        /*$appData*/
        ctx[6].state.resizable
      );
      toggle_class(
        window2,
        "glass",
        /*$appData*/
        ctx[6].glass
      );
      toggle_class(
        window2,
        "visible",
        /*visible*/
        ctx[2]
      );
      toggle_class(
        window2,
        "closing",
        /*closing*/
        ctx[3]
      );
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, window2, anchor);
      append(window2, div);
      if (if_block1)
        if_block1.m(div, null);
      append(window2, t1);
      mount_component(overlayprocessrenderer, window2, null);
      insert(target, t2, anchor);
      mount_component(subprocessrenderer, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          window2,
          "mousedown",
          /*handleMouse*/
          ctx[9]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!/*$appData*/
      ctx2[6].noOverlayShade) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$4(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*visible*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*visible*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$d(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const overlayprocessrenderer_changes = {};
      if (dirty & /*pid*/
      1)
        overlayprocessrenderer_changes.pid = /*pid*/
        ctx2[0];
      overlayprocessrenderer.$set(overlayprocessrenderer_changes);
      if (!current || dirty & /*pid*/
      1) {
        attr(
          window2,
          "data-pid",
          /*pid*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$appData*/
      64 && window_id_value !== (window_id_value = /*$appData*/
      ctx2[6].id)) {
        attr(window2, "id", window_id_value);
      }
      if (!current || dirty & /*style*/
      16) {
        attr(
          window2,
          "style",
          /*style*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*$UserDataStore*/
      128) {
        toggle_class(
          window2,
          "colored",
          /*$UserDataStore*/
          ctx2[7].sh.taskbar.colored
        );
      }
      if (!current || dirty & /*$appData*/
      64) {
        toggle_class(
          window2,
          "resizable",
          /*$appData*/
          ctx2[6].state.resizable
        );
      }
      if (!current || dirty & /*$appData*/
      64) {
        toggle_class(
          window2,
          "glass",
          /*$appData*/
          ctx2[6].glass
        );
      }
      if (!current || dirty & /*visible*/
      4) {
        toggle_class(
          window2,
          "visible",
          /*visible*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*closing*/
      8) {
        toggle_class(
          window2,
          "closing",
          /*closing*/
          ctx2[3]
        );
      }
      const subprocessrenderer_changes = {};
      if (dirty & /*pid*/
      1)
        subprocessrenderer_changes.pid = /*pid*/
        ctx2[0];
      subprocessrenderer.$set(subprocessrenderer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      transition_in(overlayprocessrenderer.$$.fragment, local);
      transition_in(subprocessrenderer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      transition_out(overlayprocessrenderer.$$.fragment, local);
      transition_out(subprocessrenderer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(window2);
        detach(t2);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d();
      destroy_component(overlayprocessrenderer);
      destroy_component(subprocessrenderer, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$4(ctx) {
  let div;
  let div_id_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", "overlay-shade");
      attr(
        div,
        "data-pid",
        /*pid*/
        ctx[0]
      );
      attr(div, "id", div_id_value = "shade-" + /*$appData*/
      ctx[6].id);
      toggle_class(
        div,
        "visible",
        /*visible*/
        ctx[2]
      );
      toggle_class(
        div,
        "closing",
        /*closing*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*pid*/
      1) {
        attr(
          div,
          "data-pid",
          /*pid*/
          ctx2[0]
        );
      }
      if (dirty & /*$appData*/
      64 && div_id_value !== (div_id_value = "shade-" + /*$appData*/
      ctx2[6].id)) {
        attr(div, "id", div_id_value);
      }
      if (dirty & /*visible*/
      4) {
        toggle_class(
          div,
          "visible",
          /*visible*/
          ctx2[2]
        );
      }
      if (dirty & /*closing*/
      8) {
        toggle_class(
          div,
          "closing",
          /*closing*/
          ctx2[3]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_1$d(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*$appData*/
    ctx[6].content
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        pid: (
          /*pid*/
          ctx2[0]
        ),
        app: (
          /*$appData*/
          ctx2[6]
        ),
        runtime: (
          /*runtime*/
          ctx2[5]
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$appData*/
      64 && switch_value !== (switch_value = /*$appData*/
      ctx2[6].content)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*pid*/
        1)
          switch_instance_changes.pid = /*pid*/
          ctx2[0];
        if (dirty & /*$appData*/
        64)
          switch_instance_changes.app = /*$appData*/
          ctx2[6];
        if (dirty & /*runtime*/
        32)
          switch_instance_changes.runtime = /*runtime*/
          ctx2[5];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$1r(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$appData*/
    ctx[6] && typeof /*pid*/
    ctx[0] == "number" && /*runtime*/
    ctx[5] && /*$UserDataStore*/
    ctx[7] && /*render*/
    ctx[1] && create_if_block$M(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$appData*/
        ctx2[6] && typeof /*pid*/
        ctx2[0] == "number" && /*runtime*/
        ctx2[5] && /*$UserDataStore*/
        ctx2[7] && /*render*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$appData, pid, runtime, $UserDataStore, render*/
          227) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$M(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1h($$self, $$props, $$invalidate) {
  let $focusedPid;
  let $appData;
  let $UserDataStore;
  component_subscribe($$self, focusedPid, ($$value) => $$invalidate(11, $focusedPid = $$value));
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(7, $UserDataStore = $$value));
  let { pid } = $$props;
  let { app } = $$props;
  let render = false;
  let visible = false;
  let closing = false;
  let style2 = "";
  let runtime;
  const proc = ProcessStack.getProcess(pid);
  const { mutator: appData } = proc;
  component_subscribe($$self, appData, (value) => $$invalidate(6, $appData = value));
  ProcessStack.closedPids.subscribe((v2) => $$invalidate(3, closing = v2.includes(pid)));
  onMount(async () => {
    $$invalidate(1, render = true);
    await sleep();
    $$invalidate(4, style2 = generateCSS(app));
    $$invalidate(5, runtime = new $appData.runtime($appData, appData, ProcessStack.getProcess(pid)));
    await sleep(100);
    focusedPid.set(pid);
    $$invalidate(2, visible = true);
  });
  appData.subscribe((v2) => {
    if (!v2)
      return;
    $$invalidate(4, style2 = generateCSS(v2));
  });
  async function handleMouse() {
    await sleep();
    set_store_value(focusedPid, $focusedPid = pid, $focusedPid);
  }
  $$self.$$set = ($$props2) => {
    if ("pid" in $$props2)
      $$invalidate(0, pid = $$props2.pid);
    if ("app" in $$props2)
      $$invalidate(10, app = $$props2.app);
  };
  return [
    pid,
    render,
    visible,
    closing,
    style2,
    runtime,
    $appData,
    $UserDataStore,
    appData,
    handleMouse,
    app
  ];
}
class OverlayWindow extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1h, create_fragment$1r, safe_not_equal, { pid: 0, app: 10 });
  }
}
function get_each_context$i(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list2[i2][0];
  child_ctx[2] = list2[i2][1];
  return child_ctx;
}
function create_if_block_1$c(ctx) {
  let overlaywindow;
  let current;
  overlaywindow = new OverlayWindow({
    props: {
      app: (
        /*proc*/
        ctx[2].app
      ),
      pid: (
        /*pid*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(overlaywindow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overlaywindow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const overlaywindow_changes = {};
      if (dirty & /*map*/
      2)
        overlaywindow_changes.app = /*proc*/
        ctx2[2].app;
      if (dirty & /*map*/
      2)
        overlaywindow_changes.pid = /*pid*/
        ctx2[0];
      overlaywindow.$set(overlaywindow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(overlaywindow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overlaywindow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overlaywindow, detaching);
    }
  };
}
function create_if_block$L(ctx) {
  let div;
  let div_class_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = "disposed pid-" + /*pid*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*map*/
      2 && div_class_value !== (div_class_value = "disposed pid-" + /*pid*/
      ctx2[0])) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block$i(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$L, create_if_block_1$c];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*proc*/
      ctx2[2]._disposed
    )
      return 0;
    if (
      /*proc*/
      ctx2[2].app && /*proc*/
      ctx2[2].parentPid && /*proc*/
      ctx2[2].app.isOverlay
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function create_fragment$1q(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like([.../*map*/
  ctx[1]]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$i(get_each_context$i(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "process-renderer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*map*/
      2) {
        each_value = ensure_array_like([.../*map*/
        ctx2[1]]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$i(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$i(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$1g($$self, $$props, $$invalidate) {
  let { pid } = $$props;
  let map;
  ProcessStack.processes.subscribe(() => {
    $$invalidate(1, map = null);
    $$invalidate(1, map = ProcessStack.getOverlayProcesses(pid));
  });
  $$self.$$set = ($$props2) => {
    if ("pid" in $$props2)
      $$invalidate(0, pid = $$props2.pid);
  };
  return [pid, map];
}
class OverlayProcessRenderer extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1g, create_fragment$1q, safe_not_equal, { pid: 0 });
  }
}
function create_if_block$K(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*$app*/
    ctx[4].content
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        pid: (
          /*pid*/
          ctx2[2]
        ),
        app: (
          /*$app*/
          ctx2[4]
        ),
        appMutator: (
          /*app*/
          ctx2[1]
        ),
        runtime: (
          /*runtime*/
          ctx2[3]
        ),
        appdata: (
          /*$UserDataStore*/
          ctx2[5] ? (
            /*$UserDataStore*/
            ctx2[5].appdata[
              /*$app*/
              ctx2[4].id
            ] || {}
          ) : {}
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$app*/
      16 && switch_value !== (switch_value = /*$app*/
      ctx2[4].content)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*pid*/
        4)
          switch_instance_changes.pid = /*pid*/
          ctx2[2];
        if (dirty & /*$app*/
        16)
          switch_instance_changes.app = /*$app*/
          ctx2[4];
        if (dirty & /*app*/
        2)
          switch_instance_changes.appMutator = /*app*/
          ctx2[1];
        if (dirty & /*runtime*/
        8)
          switch_instance_changes.runtime = /*runtime*/
          ctx2[3];
        if (dirty & /*$UserDataStore, $app*/
        48)
          switch_instance_changes.appdata = /*$UserDataStore*/
          ctx2[5] ? (
            /*$UserDataStore*/
            ctx2[5].appdata[
              /*$app*/
              ctx2[4].id
            ] || {}
          ) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$1p(ctx) {
  let div;
  let current;
  let if_block = (
    /*visible*/
    ctx[0] && create_if_block$K(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "body");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*visible*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*visible*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$K(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$1f($$self, $$props, $$invalidate) {
  let $app, $$unsubscribe_app = noop$1, $$subscribe_app = () => ($$unsubscribe_app(), $$unsubscribe_app = subscribe(app, ($$value) => $$invalidate(4, $app = $$value)), app);
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(5, $UserDataStore = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_app());
  let { visible } = $$props;
  let { app } = $$props;
  $$subscribe_app();
  let { pid } = $$props;
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("visible" in $$props2)
      $$invalidate(0, visible = $$props2.visible);
    if ("app" in $$props2)
      $$subscribe_app($$invalidate(1, app = $$props2.app));
    if ("pid" in $$props2)
      $$invalidate(2, pid = $$props2.pid);
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [visible, app, pid, runtime, $app, $UserDataStore];
}
class Body extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1f, create_fragment$1p, safe_not_equal, { visible: 0, app: 1, pid: 2, runtime: 3 });
  }
}
function create_if_block$J(ctx) {
  let window_1;
  let t0;
  let body;
  let t1;
  let overlayprocessrenderer;
  let window_1_id_value;
  let window_1_class_value;
  let draggable_action;
  let t2;
  let subprocessrenderer;
  let current;
  let mounted;
  let dispose;
  let if_block = !/*$app*/
  ctx[7].state.headless && create_if_block_1$b(ctx);
  body = new Body({
    props: {
      app: (
        /*app*/
        ctx[12]
      ),
      pid: (
        /*pid*/
        ctx[0]
      ),
      visible: (
        /*visible*/
        ctx[4]
      ),
      runtime: (
        /*runtime*/
        ctx[5]
      )
    }
  });
  overlayprocessrenderer = new OverlayProcessRenderer({ props: { pid: (
    /*pid*/
    ctx[0]
  ) } });
  subprocessrenderer = new SubProcessRenderer({ props: { pid: (
    /*pid*/
    ctx[0]
  ) } });
  return {
    c() {
      window_1 = element("window");
      if (if_block)
        if_block.c();
      t0 = space();
      create_component(body.$$.fragment);
      t1 = space();
      create_component(overlayprocessrenderer.$$.fragment);
      t2 = space();
      create_component(subprocessrenderer.$$.fragment);
      attr(
        window_1,
        "data-pid",
        /*pid*/
        ctx[0]
      );
      attr(window_1, "id", window_1_id_value = /*$app*/
      ctx[7].id);
      attr(window_1, "class", window_1_class_value = "taskbar-bounds tb-" + /*$UserDataStore*/
      ctx[10].sh.taskbar.pos + " " + /*$app*/
      (ctx[7].state.snapState || "") + " shell-colored");
      attr(
        window_1,
        "style",
        /*style*/
        ctx[2]
      );
      toggle_class(
        window_1,
        "minimized",
        /*$app*/
        ctx[7].state.minimized
      );
      toggle_class(
        window_1,
        "maximized",
        /*$app*/
        ctx[7].state.maximized || /*$app*/
        ctx[7].state.snapping
      );
      toggle_class(
        window_1,
        "headless",
        /*$app*/
        ctx[7].state.headless
      );
      toggle_class(
        window_1,
        "fullscreen",
        /*$app*/
        ctx[7].state.fullscreen
      );
      toggle_class(
        window_1,
        "resizable",
        /*$app*/
        ctx[7].state.resizable
      );
      toggle_class(
        window_1,
        "core",
        /*$app*/
        ctx[7].metadata.core
      );
      toggle_class(
        window_1,
        "glass",
        /*$app*/
        ctx[7].glass
      );
      toggle_class(
        window_1,
        "snapped",
        /*$app*/
        ctx[7].state.snapping
      );
      toggle_class(
        window_1,
        "visible",
        /*visible*/
        ctx[4]
      );
      toggle_class(
        window_1,
        "focused",
        /*$focusedPid*/
        ctx[9] == /*pid*/
        ctx[0]
      );
      toggle_class(
        window_1,
        "docked",
        /*$UserDataStore*/
        ctx[10].sh.taskbar.docked
      );
      toggle_class(
        window_1,
        "bigtb",
        /*$UserDataStore*/
        ctx[10].sh.window.bigtb
      );
      toggle_class(
        window_1,
        "colored",
        /*$UserDataStore*/
        ctx[10].sh.taskbar.colored && !/*$app*/
        ctx[7].metadata.core && /*$focusedPid*/
        ctx[9] == /*pid*/
        ctx[0]
      );
      toggle_class(
        window_1,
        "closing",
        /*closing*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, window_1, anchor);
      if (if_block)
        if_block.m(window_1, null);
      append(window_1, t0);
      mount_component(body, window_1, null);
      append(window_1, t1);
      mount_component(overlayprocessrenderer, window_1, null);
      ctx[16](window_1);
      insert(target, t2, anchor);
      mount_component(subprocessrenderer, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            window_1,
            "mousedown",
            /*handleMouse*/
            ctx[13]
          ),
          listen(
            window_1,
            "neodrag",
            /*drag*/
            ctx[14]
          ),
          action_destroyer(draggable_action = d$1.call(null, window_1, {
            disabled: (
              /*$app*/
              ctx[7].state.maximized
            ),
            handle: ".titlebar",
            bounds: { top: 0, left: 0, right: 0, bottom: -1e3 },
            position: (
              /*$pos*/
              ctx[8]
            ),
            defaultPosition: (
              /*$pos*/
              ctx[8]
            )
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!/*$app*/
      ctx2[7].state.headless) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$app*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$b(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(window_1, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const body_changes = {};
      if (dirty & /*pid*/
      1)
        body_changes.pid = /*pid*/
        ctx2[0];
      if (dirty & /*visible*/
      16)
        body_changes.visible = /*visible*/
        ctx2[4];
      if (dirty & /*runtime*/
      32)
        body_changes.runtime = /*runtime*/
        ctx2[5];
      body.$set(body_changes);
      const overlayprocessrenderer_changes = {};
      if (dirty & /*pid*/
      1)
        overlayprocessrenderer_changes.pid = /*pid*/
        ctx2[0];
      overlayprocessrenderer.$set(overlayprocessrenderer_changes);
      if (!current || dirty & /*pid*/
      1) {
        attr(
          window_1,
          "data-pid",
          /*pid*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$app*/
      128 && window_1_id_value !== (window_1_id_value = /*$app*/
      ctx2[7].id)) {
        attr(window_1, "id", window_1_id_value);
      }
      if (!current || dirty & /*$UserDataStore, $app*/
      1152 && window_1_class_value !== (window_1_class_value = "taskbar-bounds tb-" + /*$UserDataStore*/
      ctx2[10].sh.taskbar.pos + " " + /*$app*/
      (ctx2[7].state.snapState || "") + " shell-colored")) {
        attr(window_1, "class", window_1_class_value);
      }
      if (!current || dirty & /*style*/
      4) {
        attr(
          window_1,
          "style",
          /*style*/
          ctx2[2]
        );
      }
      if (draggable_action && is_function(draggable_action.update) && dirty & /*$app, $pos*/
      384)
        draggable_action.update.call(null, {
          disabled: (
            /*$app*/
            ctx2[7].state.maximized
          ),
          handle: ".titlebar",
          bounds: { top: 0, left: 0, right: 0, bottom: -1e3 },
          position: (
            /*$pos*/
            ctx2[8]
          ),
          defaultPosition: (
            /*$pos*/
            ctx2[8]
          )
        });
      if (!current || dirty & /*$UserDataStore, $app, $app*/
      1152) {
        toggle_class(
          window_1,
          "minimized",
          /*$app*/
          ctx2[7].state.minimized
        );
      }
      if (!current || dirty & /*$UserDataStore, $app, $app*/
      1152) {
        toggle_class(
          window_1,
          "maximized",
          /*$app*/
          ctx2[7].state.maximized || /*$app*/
          ctx2[7].state.snapping
        );
      }
      if (!current || dirty & /*$UserDataStore, $app, $app*/
      1152) {
        toggle_class(
          window_1,
          "headless",
          /*$app*/
          ctx2[7].state.headless
        );
      }
      if (!current || dirty & /*$UserDataStore, $app, $app*/
      1152) {
        toggle_class(
          window_1,
          "fullscreen",
          /*$app*/
          ctx2[7].state.fullscreen
        );
      }
      if (!current || dirty & /*$UserDataStore, $app, $app*/
      1152) {
        toggle_class(
          window_1,
          "resizable",
          /*$app*/
          ctx2[7].state.resizable
        );
      }
      if (!current || dirty & /*$UserDataStore, $app, $app*/
      1152) {
        toggle_class(
          window_1,
          "core",
          /*$app*/
          ctx2[7].metadata.core
        );
      }
      if (!current || dirty & /*$UserDataStore, $app, $app*/
      1152) {
        toggle_class(
          window_1,
          "glass",
          /*$app*/
          ctx2[7].glass
        );
      }
      if (!current || dirty & /*$UserDataStore, $app, $app*/
      1152) {
        toggle_class(
          window_1,
          "snapped",
          /*$app*/
          ctx2[7].state.snapping
        );
      }
      if (!current || dirty & /*$UserDataStore, $app, visible*/
      1168) {
        toggle_class(
          window_1,
          "visible",
          /*visible*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*$UserDataStore, $app, $focusedPid, pid*/
      1665) {
        toggle_class(
          window_1,
          "focused",
          /*$focusedPid*/
          ctx2[9] == /*pid*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$UserDataStore, $app, $UserDataStore*/
      1152) {
        toggle_class(
          window_1,
          "docked",
          /*$UserDataStore*/
          ctx2[10].sh.taskbar.docked
        );
      }
      if (!current || dirty & /*$UserDataStore, $app, $UserDataStore*/
      1152) {
        toggle_class(
          window_1,
          "bigtb",
          /*$UserDataStore*/
          ctx2[10].sh.window.bigtb
        );
      }
      if (!current || dirty & /*$UserDataStore, $app, $UserDataStore, $app, $focusedPid, pid*/
      1665) {
        toggle_class(
          window_1,
          "colored",
          /*$UserDataStore*/
          ctx2[10].sh.taskbar.colored && !/*$app*/
          ctx2[7].metadata.core && /*$focusedPid*/
          ctx2[9] == /*pid*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$UserDataStore, $app, closing*/
      1154) {
        toggle_class(
          window_1,
          "closing",
          /*closing*/
          ctx2[1]
        );
      }
      const subprocessrenderer_changes = {};
      if (dirty & /*pid*/
      1)
        subprocessrenderer_changes.pid = /*pid*/
        ctx2[0];
      subprocessrenderer.$set(subprocessrenderer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(body.$$.fragment, local);
      transition_in(overlayprocessrenderer.$$.fragment, local);
      transition_in(subprocessrenderer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(body.$$.fragment, local);
      transition_out(overlayprocessrenderer.$$.fragment, local);
      transition_out(subprocessrenderer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(window_1);
        detach(t2);
      }
      if (if_block)
        if_block.d();
      destroy_component(body);
      destroy_component(overlayprocessrenderer);
      ctx[16](null);
      destroy_component(subprocessrenderer, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$b(ctx) {
  let titlebar;
  let current;
  titlebar = new Titlebar({
    props: {
      app: (
        /*app*/
        ctx[12]
      ),
      pid: (
        /*pid*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(titlebar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(titlebar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const titlebar_changes = {};
      if (dirty & /*pid*/
      1)
        titlebar_changes.pid = /*pid*/
        ctx2[0];
      titlebar.$set(titlebar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(titlebar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(titlebar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(titlebar, detaching);
    }
  };
}
function create_fragment$1o(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$app*/
    ctx[7] && typeof /*pid*/
    ctx[0] == "number" && /*runtime*/
    ctx[5] && /*$UserDataStore*/
    ctx[10] && /*render*/
    ctx[3] && create_if_block$J(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$app*/
        ctx2[7] && typeof /*pid*/
        ctx2[0] == "number" && /*runtime*/
        ctx2[5] && /*$UserDataStore*/
        ctx2[10] && /*render*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$app, pid, runtime, $UserDataStore, render*/
          1193) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$J(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1e($$self, $$props, $$invalidate) {
  let $maxZIndex;
  let $app;
  let $pos;
  let $focusedPid;
  let $UserDataStore;
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(18, $maxZIndex = $$value));
  component_subscribe($$self, focusedPid, ($$value) => $$invalidate(9, $focusedPid = $$value));
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(10, $UserDataStore = $$value));
  let { pid } = $$props;
  let { handler = ProcessStack } = $$props;
  let closing = false;
  let style2 = "";
  let render = false;
  let visible = false;
  let runtime;
  let window2;
  let pos = Store$1({ x: 0, y: 0 });
  component_subscribe($$self, pos, (value) => $$invalidate(8, $pos = value));
  let inited = false;
  let proc = handler.getProcess(pid);
  const { mutator: app } = proc;
  component_subscribe($$self, app, (value) => $$invalidate(7, $app = value));
  onMount(async () => {
    $$invalidate(3, render = true);
    await sleep(10);
    set_store_value(pos, $pos = { ...$app.pos }, $pos);
    $$invalidate(2, style2 = generateCSS($app));
    $$invalidate(5, runtime = new $app.runtime($app, app, proc));
    await sleep(100);
    $$invalidate(4, visible = true);
    inited = true;
    focusedPid.set(pid);
    handler.closedPids.subscribe((v2) => $$invalidate(1, closing = v2.includes(pid)));
  });
  function handleMouse() {
    set_store_value(focusedPid, $focusedPid = pid, $focusedPid);
  }
  function drag(e2) {
    set_store_value(focusedPid, $focusedPid = pid, $focusedPid);
    if ($app.state.maximized)
      return;
    set_store_value(pos, $pos = { x: e2.detail.offsetX, y: e2.detail.offsetY }, $pos);
  }
  focusedPid.subscribe(async (v2) => {
    if (!$app || v2 != pid || $app.metadata.core || !inited || !window2)
      return;
    set_store_value(maxZIndex, $maxZIndex++, $maxZIndex);
    set_store_value(app, $app.state.minimized = false, $app);
    $$invalidate(6, window2.style.zIndex = `${$maxZIndex}`, window2);
  });
  function window_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      window2 = $$value;
      $$invalidate(6, window2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("pid" in $$props2)
      $$invalidate(0, pid = $$props2.pid);
    if ("handler" in $$props2)
      $$invalidate(15, handler = $$props2.handler);
  };
  return [
    pid,
    closing,
    style2,
    render,
    visible,
    runtime,
    window2,
    $app,
    $pos,
    $focusedPid,
    $UserDataStore,
    pos,
    app,
    handleMouse,
    drag,
    handler,
    window_1_binding
  ];
}
class Window extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1e, create_fragment$1o, safe_not_equal, { pid: 0, handler: 15 });
  }
}
function get_each_context$h(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2][0];
  child_ctx[3] = list2[i2][1];
  return child_ctx;
}
function create_if_block_1$a(ctx) {
  let window2;
  let current;
  window2 = new Window({
    props: {
      pid: (
        /*pid*/
        ctx[2]
      ),
      handler: (
        /*handler*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(window2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(window2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const window_changes = {};
      if (dirty & /*map*/
      2)
        window_changes.pid = /*pid*/
        ctx2[2];
      if (dirty & /*handler*/
      1)
        window_changes.handler = /*handler*/
        ctx2[0];
      window2.$set(window_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(window2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(window2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(window2, detaching);
    }
  };
}
function create_if_block$I(ctx) {
  let div;
  let div_class_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = "disposed pid-" + /*pid*/
      ctx[2]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*map*/
      2 && div_class_value !== (div_class_value = "disposed pid-" + /*pid*/
      ctx2[2])) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block$h(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$I, create_if_block_1$a];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*proc*/
      ctx2[3]._disposed
    )
      return 0;
    if (
      /*proc*/
      ctx2[3].app && !/*proc*/
      ctx2[3].parentPid
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function create_fragment$1n(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like([.../*map*/
  ctx[1]]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$h(get_each_context$h(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "process-renderer fullscreen");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*map, handler*/
      3) {
        each_value = ensure_array_like([.../*map*/
        ctx2[1]]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$h(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$h(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$1d($$self, $$props, $$invalidate) {
  let { handler = ProcessStack } = $$props;
  let map;
  handler.processes.subscribe((v2) => {
    $$invalidate(1, map = null);
    $$invalidate(1, map = v2);
  });
  $$self.$$set = ($$props2) => {
    if ("handler" in $$props2)
      $$invalidate(0, handler = $$props2.handler);
  };
  return [handler, map];
}
class ProcessRenderer extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1d, create_fragment$1n, safe_not_equal, { handler: 0 });
  }
}
function create_if_block$H(ctx) {
  let div;
  let div_class_value;
  let t2;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*state*/
    ctx[3].content && create_if_block_2$3(ctx)
  );
  let if_block1 = !/*state*/
  ctx[3].attribs.noProcesssRenderer && /*renderProcesses*/
  ctx[2] && create_if_block_1$9();
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr(div, "class", div_class_value = "state-renderer " + /*classes*/
      ctx[4] + " " + /*handler*/
      ctx[1].id + " " + /*state*/
      (ctx[3].className || "") + " state-" + /*handler*/
      ctx[1].id + "-" + /*state*/
      ctx[3].key);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      insert(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*state*/
        ctx2[3].content
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*state*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classes, handler, state*/
      26 && div_class_value !== (div_class_value = "state-renderer " + /*classes*/
      ctx2[4] + " " + /*handler*/
      ctx2[1].id + " " + /*state*/
      (ctx2[3].className || "") + " state-" + /*handler*/
      ctx2[1].id + "-" + /*state*/
      ctx2[3].key)) {
        attr(div, "class", div_class_value);
      }
      if (!/*state*/
      ctx2[3].attribs.noProcesssRenderer && /*renderProcesses*/
      ctx2[2]) {
        if (if_block1) {
          if (dirty & /*state, renderProcesses*/
          12) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$9();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t2);
        detach(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function create_if_block_2$3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*state*/
    ctx[3].content
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        thisState: (
          /*state*/
          ctx2[3]
        ),
        handler: (
          /*handler*/
          ctx2[1]
        ),
        runtime: (
          /*runtime*/
          ctx2[0]
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*state*/
      8 && switch_value !== (switch_value = /*state*/
      ctx2[3].content)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*state*/
        8)
          switch_instance_changes.thisState = /*state*/
          ctx2[3];
        if (dirty & /*handler*/
        2)
          switch_instance_changes.handler = /*handler*/
          ctx2[1];
        if (dirty & /*runtime*/
        1)
          switch_instance_changes.runtime = /*runtime*/
          ctx2[0];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_1$9(ctx) {
  let processrenderer2;
  let current;
  processrenderer2 = new ProcessRenderer({});
  return {
    c() {
      create_component(processrenderer2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(processrenderer2, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(processrenderer2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(processrenderer2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(processrenderer2, detaching);
    }
  };
}
function create_fragment$1m(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*handler*/
    ctx[1] && /*state*/
    ctx[3] && create_if_block$H(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*handler*/
        ctx2[1] && /*state*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*handler, state*/
          10) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$H(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1c($$self, $$props, $$invalidate) {
  let { runtime = null } = $$props;
  let { handler } = $$props;
  let { renderProcesses = false } = $$props;
  let state;
  let classes = "";
  onMount(() => handler.current.subscribe((v2) => {
    $$invalidate(3, state = v2);
    $$invalidate(4, classes = v2.attribs.classes || "");
  }));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("handler" in $$props2)
      $$invalidate(1, handler = $$props2.handler);
    if ("renderProcesses" in $$props2)
      $$invalidate(2, renderProcesses = $$props2.renderProcesses);
  };
  return [runtime, handler, renderProcesses, state, classes];
}
class StateRenderer extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1c, create_fragment$1m, safe_not_equal, {
      runtime: 0,
      handler: 1,
      renderProcesses: 2
    });
  }
}
function create_if_block$G(ctx) {
  let button;
  let profilepicture;
  let t0;
  let span;
  let p0;
  let t1;
  let t2;
  let p1;
  let apireveal;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*pfp*/
      ctx[2]
    ), height: 30 }
  });
  apireveal = new ApiReveal({});
  return {
    c() {
      button = element("button");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      span = element("span");
      p0 = element("p");
      t1 = text(
        /*$UserName*/
        ctx[3]
      );
      t2 = space();
      p1 = element("p");
      create_component(apireveal.$$.fragment);
      attr(p0, "class", "username");
      attr(p1, "class", "server");
      attr(span, "class", "name");
      attr(button, "class", "page account");
      toggle_class(
        button,
        "selected",
        /*current*/
        ctx[0] == PAGE_ID
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(profilepicture, button, null);
      append(button, t0);
      append(button, span);
      append(span, p0);
      append(p0, t1);
      append(span, t2);
      append(span, p1);
      mount_component(apireveal, p1, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*go*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      4)
        profilepicture_changes.src = /*pfp*/
        ctx2[2];
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*$UserName*/
      8)
        set_data(
          t1,
          /*$UserName*/
          ctx2[3]
        );
      if (!current || dirty & /*current, PAGE_ID*/
      1) {
        toggle_class(
          button,
          "selected",
          /*current*/
          ctx2[0] == PAGE_ID
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      transition_in(apireveal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      transition_out(apireveal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(profilepicture);
      destroy_component(apireveal);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1l(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*page*/
    ctx[1] && create_if_block$G(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*page*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*page*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$G(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
const PAGE_ID = "account";
function instance$1b($$self, $$props, $$invalidate) {
  let $UserName;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(3, $UserName = $$value));
  let { runtime } = $$props;
  let { current } = $$props;
  let page;
  let pfp = "";
  UserDataStore.subscribe((v2) => {
    $$invalidate(2, pfp = getProfilePicture(v2.acc.profilePicture));
  });
  onMount(() => {
    if (!runtime.state.store.has(PAGE_ID))
      return;
    $$invalidate(1, page = runtime.state.store.get(PAGE_ID));
  });
  function go() {
    runtime.state.navigate(PAGE_ID);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
    if ("current" in $$props2)
      $$invalidate(0, current = $$props2.current);
  };
  return [current, page, pfp, $UserName, go, runtime];
}
class AccountButton extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1b, create_fragment$1l, safe_not_equal, { runtime: 5, current: 0 });
  }
}
function create_if_block$F(ctx) {
  let button;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1_value = (
    /*page*/
    ctx[1].name + ""
  );
  let t1;
  let t2;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = (
    /*page*/
    ctx[1].attribs.separator && create_if_block_1$8()
  );
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      if (!src_url_equal(img.src, img_src_value = /*page*/
      ctx[1].image))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*id*/
        ctx[0]
      );
      attr(span, "class", "name");
      attr(button, "class", "page");
      attr(button, "data-contextmenu", "sidebar-page");
      attr(
        button,
        "data-id",
        /*id*/
        ctx[0]
      );
      toggle_class(
        button,
        "selected",
        /*selected*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, span);
      append(span, t1);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*switchTo*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*page*/
      2 && !src_url_equal(img.src, img_src_value = /*page*/
      ctx2[1].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*id*/
      1) {
        attr(
          img,
          "alt",
          /*id*/
          ctx2[0]
        );
      }
      if (dirty & /*page*/
      2 && t1_value !== (t1_value = /*page*/
      ctx2[1].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*id*/
      1) {
        attr(
          button,
          "data-id",
          /*id*/
          ctx2[0]
        );
      }
      if (dirty & /*selected*/
      4) {
        toggle_class(
          button,
          "selected",
          /*selected*/
          ctx2[2]
        );
      }
      if (
        /*page*/
        ctx2[1].attribs.separator
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_1$8();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
        detach(t2);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$8(ctx) {
  let hr;
  return {
    c() {
      hr = element("hr");
    },
    m(target, anchor) {
      insert(target, hr, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(hr);
      }
    }
  };
}
function create_fragment$1k(ctx) {
  let if_block_anchor;
  let if_block = !/*page*/
  (ctx[1].className == "safemode-hidden" && /*$SafeMode*/
  ctx[3]) && create_if_block$F(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (!/*page*/
      (ctx2[1].className == "safemode-hidden" && /*$SafeMode*/
      ctx2[3])) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$F(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1a($$self, $$props, $$invalidate) {
  let $SafeMode;
  component_subscribe($$self, SafeMode, ($$value) => $$invalidate(3, $SafeMode = $$value));
  let { id } = $$props;
  let { page } = $$props;
  let { selected = false } = $$props;
  let { runtime } = $$props;
  function switchTo() {
    runtime.state.navigate(id);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("page" in $$props2)
      $$invalidate(1, page = $$props2.page);
    if ("selected" in $$props2)
      $$invalidate(2, selected = $$props2.selected);
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
  };
  return [id, page, selected, $SafeMode, switchTo, runtime];
}
class Page2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1a, create_fragment$1k, safe_not_equal, { id: 0, page: 1, selected: 2, runtime: 5 });
  }
}
function get_each_context$g(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2][0];
  child_ctx[4] = list2[i2][1];
  return child_ctx;
}
function create_if_block$E(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like([.../*pages*/
  ctx[2]]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$g(get_each_context$g(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*pages, current, runtime*/
      7) {
        each_value = ensure_array_like([.../*pages*/
        ctx2[2]]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$g(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$g(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_1$7(ctx) {
  let page_1;
  let current;
  page_1 = new Page2({
    props: {
      id: (
        /*id*/
        ctx[3]
      ),
      page: (
        /*page*/
        ctx[4]
      ),
      selected: (
        /*current*/
        ctx[1] == /*id*/
        ctx[3]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(page_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(page_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const page_1_changes = {};
      if (dirty & /*pages*/
      4)
        page_1_changes.id = /*id*/
        ctx2[3];
      if (dirty & /*pages*/
      4)
        page_1_changes.page = /*page*/
        ctx2[4];
      if (dirty & /*current, pages*/
      6)
        page_1_changes.selected = /*current*/
        ctx2[1] == /*id*/
        ctx2[3];
      if (dirty & /*runtime*/
      1)
        page_1_changes.runtime = /*runtime*/
        ctx2[0];
      page_1.$set(page_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(page_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(page_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(page_1, detaching);
    }
  };
}
function create_each_block$g(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*page*/
  ctx[4].attribs.hidden && create_if_block_1$7(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*page*/
      ctx2[4].attribs.hidden) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*pages*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$1j(ctx) {
  let div1;
  let div0;
  let accountbutton;
  let t0;
  let hr;
  let t1;
  let current;
  accountbutton = new AccountButton({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      current: (
        /*current*/
        ctx[1]
      )
    }
  });
  let if_block = (
    /*pages*/
    ctx[2].size && create_if_block$E(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(accountbutton.$$.fragment);
      t0 = space();
      hr = element("hr");
      t1 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "flex");
      attr(div1, "class", "sidebar");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(accountbutton, div0, null);
      append(div0, t0);
      append(div0, hr);
      append(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const accountbutton_changes = {};
      if (dirty & /*runtime*/
      1)
        accountbutton_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*current*/
      2)
        accountbutton_changes.current = /*current*/
        ctx2[1];
      accountbutton.$set(accountbutton_changes);
      if (
        /*pages*/
        ctx2[2].size
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*pages*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$E(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(accountbutton.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(accountbutton.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(accountbutton);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$19($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let current = "";
  let pages = /* @__PURE__ */ new Map([]);
  onMount(() => {
    $$invalidate(2, pages = runtime.state.store);
    runtime.state.current.subscribe((v2) => $$invalidate(1, current = v2.key));
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, current, pages];
}
class SideBar3 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$19, create_fragment$1j, safe_not_equal, { runtime: 0 });
  }
}
const main$6 = "";
function create_if_block$D(ctx) {
  let sidebar;
  let t0;
  let div;
  let titlebar;
  let t1;
  let staterenderer;
  let div_class_value;
  let current;
  sidebar = new SideBar3({ props: { runtime: (
    /*runtime*/
    ctx[1]
  ) } });
  titlebar = new Titlebar({
    props: {
      app: (
        /*runtime*/
        ctx[1].appMutator
      ),
      pid: (
        /*pid*/
        ctx[0]
      ),
      showIcon: false,
      showTitle: false,
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx }
    }
  });
  staterenderer = new StateRenderer({
    props: {
      handler: (
        /*runtime*/
        ctx[1].state
      ),
      runtime: (
        /*runtime*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(sidebar.$$.fragment);
      t0 = space();
      div = element("div");
      create_component(titlebar.$$.fragment);
      t1 = space();
      create_component(staterenderer.$$.fragment);
      attr(div, "class", div_class_value = "content-wrapper settings-page-" + /*state*/
      ctx[2].key);
      toggle_class(
        div,
        "safemode",
        /*$SafeMode*/
        ctx[3]
      );
    },
    m(target, anchor) {
      mount_component(sidebar, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      mount_component(titlebar, div, null);
      append(div, t1);
      mount_component(staterenderer, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const sidebar_changes = {};
      if (dirty & /*runtime*/
      2)
        sidebar_changes.runtime = /*runtime*/
        ctx2[1];
      sidebar.$set(sidebar_changes);
      const titlebar_changes = {};
      if (dirty & /*runtime*/
      2)
        titlebar_changes.app = /*runtime*/
        ctx2[1].appMutator;
      if (dirty & /*pid*/
      1)
        titlebar_changes.pid = /*pid*/
        ctx2[0];
      if (dirty & /*$$scope, state*/
      20) {
        titlebar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      titlebar.$set(titlebar_changes);
      const staterenderer_changes = {};
      if (dirty & /*runtime*/
      2)
        staterenderer_changes.handler = /*runtime*/
        ctx2[1].state;
      if (dirty & /*runtime*/
      2)
        staterenderer_changes.runtime = /*runtime*/
        ctx2[1];
      staterenderer.$set(staterenderer_changes);
      if (!current || dirty & /*state*/
      4 && div_class_value !== (div_class_value = "content-wrapper settings-page-" + /*state*/
      ctx2[2].key)) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*state, $SafeMode*/
      12) {
        toggle_class(
          div,
          "safemode",
          /*$SafeMode*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      transition_in(titlebar.$$.fragment, local);
      transition_in(staterenderer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      transition_out(titlebar.$$.fragment, local);
      transition_out(staterenderer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
      }
      destroy_component(sidebar, detaching);
      destroy_component(titlebar);
      destroy_component(staterenderer);
    }
  };
}
function create_default_slot$9(ctx) {
  let h1;
  let t_value = (
    /*state*/
    ctx[2].name + ""
  );
  let t2;
  return {
    c() {
      h1 = element("h1");
      t2 = text(t_value);
      attr(h1, "class", "page-title");
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      append(h1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*state*/
      4 && t_value !== (t_value = /*state*/
      ctx2[2].name + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(h1);
      }
    }
  };
}
function create_fragment$1i(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*runtime*/
    ctx[1] && /*state*/
    ctx[2] && create_if_block$D(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*runtime*/
        ctx2[1] && /*state*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*runtime, state*/
          6) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$D(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$18($$self, $$props, $$invalidate) {
  let $SafeMode;
  component_subscribe($$self, SafeMode, ($$value) => $$invalidate(3, $SafeMode = $$value));
  let { pid } = $$props;
  let { runtime } = $$props;
  let state;
  onMount(() => {
    runtime.state.current.subscribe((v2) => $$invalidate(2, state = v2));
  });
  $$self.$$set = ($$props2) => {
    if ("pid" in $$props2)
      $$invalidate(0, pid = $$props2.pid);
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [pid, runtime, state, $SafeMode];
}
let App$4 = class App27 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$18, create_fragment$1i, safe_not_equal, { pid: 0, runtime: 1 });
  }
};
const SettingsAccountContext = {
  "account-pfp": [
    {
      caption: "What's this?",
      icon: "question_mark",
      action() {
        GetHelp(HelpArticles.settingsAccountProfile);
      }
    }
  ],
  "account-username": [
    {
      caption: "What's this?",
      icon: "question_mark",
      action() {
        GetHelp(HelpArticles.settingsAccountCredentials);
      }
    }
  ],
  "account-password": [
    {
      caption: "What's this?",
      icon: "question_mark",
      action() {
        GetHelp(HelpArticles.settingsAccountCredentials);
      }
    }
  ],
  "account-delete": [
    {
      caption: "What's this?",
      icon: "question_mark",
      action() {
        GetHelp(HelpArticles.settingsAccountDelete);
      }
    }
  ]
};
const SettingsAppsContext = {
  "apps-grid": [
    {
      caption: "View",
      icon: "visibility",
      subItems: [
        {
          caption: "Grid",
          icon: "grid_view",
          action() {
            const udata = UserDataStore.get();
            udata.appdata["SettingsApp"].list = false;
            UserDataStore.set(udata);
          },
          isActive: () => !UserDataStore.get().appdata["SettingsApp"].list
        },
        {
          caption: "List",
          icon: "details",
          action() {
            const udata = UserDataStore.get();
            udata.appdata["SettingsApp"].list = true;
            UserDataStore.set(udata);
          },
          isActive: () => !!UserDataStore.get().appdata["SettingsApp"].list
        }
      ]
    },
    {
      caption: "Show hidden apps",
      icon: "hide_source",
      action(window2, data2, scope) {
        const udata = UserDataStore.get();
        udata.sh.showHiddenApps = !udata.sh.showHiddenApps;
        UserDataStore.set(udata);
      },
      isActive: () => UserDataStore.get().sh.showHiddenApps
    }
  ]
};
const SettingsSideBarContext = {
  "sidebar-page": [
    {
      caption: "Copy command to page",
      action(window2, data2, scope) {
        const command = `open ${window2.id} ["${data2.id}"]`;
        navigator.clipboard.writeText(command);
      },
      icon: "copy"
    }
  ]
};
function FsThemeSaveFailed(name) {
  sendNotification({
    title: "Couldn't save theme",
    message: `An error occured while saving ${name} to ArcFS. The file might already exist.`,
    image: WarningIcon
  });
}
function DeleteUserThemeConfirm(pid, id) {
  createErrorDialog(
    {
      title: "Delete theme?",
      message: "Are you sure you want to delete this theme? This cannot be undone.",
      image: TrashIcon,
      buttons: [
        {
          caption: "Cancel",
          action() {
          }
        },
        {
          caption: "Delete Theme",
          action() {
            deleteCustomTheme(id);
          },
          suggested: true
        }
      ],
      sound: "arcos.dialog.warning"
    },
    pid,
    true
  );
}
const ThemeContext = {
  "user-theme": [
    {
      image: ThemesIcon,
      caption: "Apply theme",
      action(_2, data2) {
        applyUserTheme(data2.id);
      }
    },
    {
      image: SaveIcon,
      caption: "Save to ArcFS",
      async action(app, data2) {
        const theme = tryJsonConvert(data2.theme);
        const name = data2.name;
        if (!theme || !name)
          return;
        const path = await GetSaveFilePath(app.pid, {
          title: "Save theme file to...",
          icon: ThemesIcon,
          saveName: `${name}.arctheme`,
          startDir: "./Themes",
          isSave: true
        });
        const written = await writeFile(path, textToBlob(JSON.stringify(theme, null, 2)));
        if (!written)
          FsThemeSaveFailed(name);
      }
    },
    SEP_ITEM,
    {
      image: TrashIcon,
      caption: "Delete theme",
      action(window2, data2) {
        DeleteUserThemeConfirm(window2.pid, data2.id);
      }
    },
    SEP_ITEM,
    {
      icon: "question_mark",
      caption: "Get Help",
      action() {
        GetHelp(HelpArticles.settingsThemesApply);
      }
    }
  ],
  "system-theme": [
    {
      image: ThemesIcon,
      caption: "Apply built-in theme",
      action(_2, data2) {
        applySystemTheme(data2.id);
      }
    },
    {
      image: SaveIcon,
      caption: "Save to ArcFS",
      async action(app, data2) {
        const theme = tryJsonConvert(data2.theme);
        const name = data2.name;
        if (!theme || !name)
          return;
        const path = await GetSaveFilePath(app.pid, {
          title: "Save theme file to...",
          icon: ThemesIcon,
          saveName: `${name}.arctheme`,
          startDir: "./Themes",
          isSave: true
        });
        const written = await writeFile(path, textToBlob(JSON.stringify(theme, null, 2)));
        if (!written)
          FsThemeSaveFailed(name);
      }
    },
    SEP_ITEM,
    {
      icon: "question_mark",
      caption: "Get Help",
      action() {
        GetHelp(HelpArticles.settingsThemesApply);
      }
    }
  ],
  "themes-accent": [
    {
      caption: "What's this?",
      icon: "question_mark",
      action() {
        GetHelp(HelpArticles.settingsThemesStyle);
      }
    }
  ],
  "themes-save": [
    {
      caption: "What's this?",
      icon: "question_mark",
      action() {
        GetHelp(HelpArticles.settingsThemesSave);
      }
    }
  ]
};
const SettingsContext = {
  ...SettingsAccountContext,
  ...ThemeContext,
  ...SettingsSideBarContext,
  ...SettingsAppsContext
};
const SettingsApp = {
  metadata: {
    name: "Settings",
    description: "Change your ArcOS settings",
    author: "The ArcOS Team",
    version: ArcOSVersion,
    icon: SettingsIcon,
    appGroup: "systemTools"
  },
  runtime: Runtime$j,
  content: App$4,
  id: "SettingsApp",
  size: { w: 730, h: 500 },
  minSize: { w: 730, h: 500 },
  maxSize: { w: 860, h: 600 },
  pos: { x: 30, y: 40 },
  state: {
    minimized: false,
    maximized: false,
    headless: true,
    fullscreen: false,
    resizable: true
  },
  controls: {
    minimize: true,
    maximize: false,
    close: true
  },
  glass: true,
  singleInstance: true,
  contextMenu: SettingsContext,
  helpArticle: HelpArticles.settings
};
const StartMenuOpened = Store$1(false);
const ActionCenterOpened = Store$1(false);
const TrayIconOpened = Store$1(false);
function create_fragment$1h(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "clear_all";
      attr(button, "class", "material-icons-round clear");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", clearNotifications);
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
class Clear extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$1h, safe_not_equal, {});
  }
}
function create_fragment$1g(ctx) {
  let div;
  let h3;
  let t0;
  let t1;
  let p2;
  let t2;
  return {
    c() {
      div = element("div");
      h3 = element("h3");
      t0 = text(
        /*timeStr*/
        ctx[0]
      );
      t1 = space();
      p2 = element("p");
      t2 = text(
        /*dateStr*/
        ctx[1]
      );
      attr(h3, "class", "time");
      attr(p2, "class", "date");
      attr(div, "class", "clock");
      attr(div, "data-contextmenu", "clockcontext");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h3);
      append(h3, t0);
      append(div, t1);
      append(div, p2);
      append(p2, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*timeStr*/
      1)
        set_data(
          t0,
          /*timeStr*/
          ctx2[0]
        );
      if (dirty & /*dateStr*/
      2)
        set_data(
          t2,
          /*dateStr*/
          ctx2[1]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$17($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(2, $UserDataStore = $$value));
  let timeStr = "";
  let dateStr = "";
  onMount(() => {
    setInterval(
      () => {
        const tb = $UserDataStore.sh.taskbar;
        const secs = tb.clockSecs && !tb.pos ? ":ss" : "";
        const time = tb.clock12hr && !tb.pos ? `hh:mm${secs} A` : `HH:mm${secs}`;
        $$invalidate(0, timeStr = dayjs().format(time));
        $$invalidate(1, dateStr = dayjs().format(`dddd, D MMMM`));
      },
      500
    );
  });
  return [timeStr, dateStr];
}
let Clock$2 = class Clock extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$17, create_fragment$1g, safe_not_equal, {});
  }
};
function create_fragment$1f(ctx) {
  let div;
  let clock;
  let t2;
  let clear2;
  let current;
  clock = new Clock$2({});
  clear2 = new Clear({});
  return {
    c() {
      div = element("div");
      create_component(clock.$$.fragment);
      t2 = space();
      create_component(clear2.$$.fragment);
      attr(div, "class", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(clock, div, null);
      append(div, t2);
      mount_component(clear2, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(clock.$$.fragment, local);
      transition_in(clear2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clock.$$.fragment, local);
      transition_out(clear2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(clock);
      destroy_component(clear2);
    }
  };
}
let Header$1 = class Header12 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$1f, safe_not_equal, {});
  }
};
function create_fragment$1e(ctx) {
  let button_1;
  let t_value = (
    /*button*/
    ctx[0].caption + ""
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button_1 = element("button");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, button_1, anchor);
      append(button_1, t2);
      if (!mounted) {
        dispose = listen(
          button_1,
          "click",
          /*trigger*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*button*/
      1 && t_value !== (t_value = /*button*/
      ctx2[0].caption + ""))
        set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button_1);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$16($$self, $$props, $$invalidate) {
  let { button } = $$props;
  let { id } = $$props;
  let { deleting } = $$props;
  let { pushed = false } = $$props;
  async function trigger() {
    await button.action();
    $$invalidate(2, deleting = true);
    await sleep(pushed ? 0 : 500);
    deleteNotification(id);
  }
  $$self.$$set = ($$props2) => {
    if ("button" in $$props2)
      $$invalidate(0, button = $$props2.button);
    if ("id" in $$props2)
      $$invalidate(3, id = $$props2.id);
    if ("deleting" in $$props2)
      $$invalidate(2, deleting = $$props2.deleting);
    if ("pushed" in $$props2)
      $$invalidate(4, pushed = $$props2.pushed);
  };
  return [button, trigger, deleting, id, pushed];
}
class Button extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$16, create_fragment$1e, safe_not_equal, { button: 0, id: 3, deleting: 2, pushed: 4 });
  }
}
function get_each_context$f(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list2[i2];
  return child_ctx;
}
function create_if_block_2$2(ctx) {
  let div;
  let img;
  let img_src_value;
  return {
    c() {
      div = element("div");
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*data*/
      ctx[1].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(img, "class", "icon");
      attr(div, "class", "left");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      2 && !src_url_equal(img.src, img_src_value = /*data*/
      ctx2[1].image)) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_else_block$7(ctx) {
  let button_1;
  let mounted;
  let dispose;
  return {
    c() {
      button_1 = element("button");
      button_1.textContent = "arrow_forward";
      attr(button_1, "class", "close material-icons-round");
    },
    m(target, anchor) {
      insert(target, button_1, anchor);
      if (!mounted) {
        dispose = listen(button_1, "click", closeNotification);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button_1);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$6(ctx) {
  let span;
  let t0_value = (
    /*collapsed*/
    (ctx[5] ? (
      /*shortTime*/
      ctx[4]
    ) : (
      /*time*/
      ctx[3]
    )) + ""
  );
  let t0;
  let span_title_value;
  let t1;
  let button0;
  let t3;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      button0 = element("button");
      button0.textContent = "delete";
      t3 = space();
      button1 = element("button");
      button1.textContent = "expand_more";
      attr(span, "class", "timestamp");
      attr(span, "title", span_title_value = /*collapsed*/
      ctx[5] ? (
        /*shortTime*/
        ctx[4]
      ) : (
        /*time*/
        ctx[3]
      ));
      attr(button0, "class", "delete material-icons-round");
      toggle_class(
        button0,
        "collapsed",
        /*collapsed*/
        ctx[5]
      );
      attr(button1, "class", "collapse material-icons-round");
      toggle_class(
        button1,
        "collapsed",
        /*collapsed*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      insert(target, button0, anchor);
      insert(target, t3, anchor);
      insert(target, button1, anchor);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*deleteNotif*/
            ctx[8]
          ),
          listen(
            button1,
            "click",
            /*toggleCollapse*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*collapsed, shortTime, time*/
      56 && t0_value !== (t0_value = /*collapsed*/
      (ctx2[5] ? (
        /*shortTime*/
        ctx2[4]
      ) : (
        /*time*/
        ctx2[3]
      )) + ""))
        set_data(t0, t0_value);
      if (dirty & /*collapsed, shortTime, time*/
      56 && span_title_value !== (span_title_value = /*collapsed*/
      ctx2[5] ? (
        /*shortTime*/
        ctx2[4]
      ) : (
        /*time*/
        ctx2[3]
      ))) {
        attr(span, "title", span_title_value);
      }
      if (dirty & /*collapsed*/
      32) {
        toggle_class(
          button0,
          "collapsed",
          /*collapsed*/
          ctx2[5]
        );
      }
      if (dirty & /*collapsed*/
      32) {
        toggle_class(
          button1,
          "collapsed",
          /*collapsed*/
          ctx2[5]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t1);
        detach(button0);
        detach(t3);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$C(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*data*/
    ctx[1].buttons
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$f(get_each_context$f(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "buttons");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*pushed, data, id, deleting*/
      71) {
        each_value = ensure_array_like(
          /*data*/
          ctx2[1].buttons
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$f(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$f(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$f(ctx) {
  let button_1;
  let updating_deleting;
  let current;
  function button_1_deleting_binding(value) {
    ctx[9](value);
  }
  let button_1_props = {
    pushed: (
      /*pushed*/
      ctx[2]
    ),
    button: (
      /*button*/
      ctx[10]
    ),
    id: (
      /*id*/
      ctx[0]
    )
  };
  if (
    /*deleting*/
    ctx[6] !== void 0
  ) {
    button_1_props.deleting = /*deleting*/
    ctx[6];
  }
  button_1 = new Button({ props: button_1_props });
  binding_callbacks.push(() => bind$1(button_1, "deleting", button_1_deleting_binding));
  return {
    c() {
      create_component(button_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_1_changes = {};
      if (dirty & /*pushed*/
      4)
        button_1_changes.pushed = /*pushed*/
        ctx2[2];
      if (dirty & /*data*/
      2)
        button_1_changes.button = /*button*/
        ctx2[10];
      if (dirty & /*id*/
      1)
        button_1_changes.id = /*id*/
        ctx2[0];
      if (!updating_deleting && dirty & /*deleting*/
      64) {
        updating_deleting = true;
        button_1_changes.deleting = /*deleting*/
        ctx2[6];
        add_flush_callback(() => updating_deleting = false);
      }
      button_1.$set(button_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button_1, detaching);
    }
  };
}
function create_fragment$1d(ctx) {
  let div3;
  let t0;
  let div2;
  let div1;
  let h3;
  let t1_value = (
    /*data*/
    ctx[1].title + ""
  );
  let t1;
  let h3_title_value;
  let t2;
  let div0;
  let t3;
  let p2;
  let raw_value = (
    /*data*/
    ctx[1].message + ""
  );
  let t4;
  let current;
  let if_block0 = (
    /*data*/
    ctx[1].image && create_if_block_2$2(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (!/*pushed*/
    ctx2[2])
      return create_if_block_1$6;
    return create_else_block$7;
  }
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type(ctx);
  let if_block2 = (
    /*data*/
    ctx[1].buttons && create_if_block$C(ctx)
  );
  return {
    c() {
      div3 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      h3 = element("h3");
      t1 = text(t1_value);
      t2 = space();
      div0 = element("div");
      if_block1.c();
      t3 = space();
      p2 = element("p");
      t4 = space();
      if (if_block2)
        if_block2.c();
      attr(h3, "class", "title");
      attr(h3, "title", h3_title_value = /*data*/
      ctx[1].title);
      attr(div0, "class", "right");
      attr(div1, "class", "header");
      attr(p2, "class", "message");
      attr(div2, "class", "content");
      attr(div3, "class", "notification");
      toggle_class(
        div3,
        "collapsed",
        /*collapsed*/
        ctx[5]
      );
      toggle_class(div3, "no-image", !/*data*/
      ctx[1].image);
      toggle_class(
        div3,
        "deleting",
        /*deleting*/
        ctx[6] && !/*pushed*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, t0);
      append(div3, div2);
      append(div2, div1);
      append(div1, h3);
      append(h3, t1);
      append(div1, t2);
      append(div1, div0);
      if_block1.m(div0, null);
      append(div2, t3);
      append(div2, p2);
      p2.innerHTML = raw_value;
      append(div2, t4);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*data*/
        ctx2[1].image
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$2(ctx2);
          if_block0.c();
          if_block0.m(div3, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((!current || dirty & /*data*/
      2) && t1_value !== (t1_value = /*data*/
      ctx2[1].title + ""))
        set_data(t1, t1_value);
      if (!current || dirty & /*data*/
      2 && h3_title_value !== (h3_title_value = /*data*/
      ctx2[1].title)) {
        attr(h3, "title", h3_title_value);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div0, null);
        }
      }
      if ((!current || dirty & /*data*/
      2) && raw_value !== (raw_value = /*data*/
      ctx2[1].message + ""))
        p2.innerHTML = raw_value;
      if (
        /*data*/
        ctx2[1].buttons
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*data*/
          2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$C(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*collapsed*/
      32) {
        toggle_class(
          div3,
          "collapsed",
          /*collapsed*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*data*/
      2) {
        toggle_class(div3, "no-image", !/*data*/
        ctx2[1].image);
      }
      if (!current || dirty & /*deleting, pushed*/
      68) {
        toggle_class(
          div3,
          "deleting",
          /*deleting*/
          ctx2[6] && !/*pushed*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block0)
        if_block0.d();
      if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance$15($$self, $$props, $$invalidate) {
  let { id } = $$props;
  let { data: data2 } = $$props;
  let { pushed = false } = $$props;
  let time = "";
  let shortTime = "";
  let collapsed = false;
  let deleting = false;
  dayjs.extend(relativeTime);
  dayjs.extend(updateLocale);
  dayjs.updateLocale("en", RelativeTimeMod);
  onMount(() => setInterval(() => {
    const dj = dayjs(data2.timestamp || null);
    $$invalidate(3, time = dj.fromNow());
    $$invalidate(4, shortTime = dj.format("HH:mm"));
  }));
  function toggleCollapse() {
    $$invalidate(5, collapsed = !collapsed);
  }
  async function deleteNotif() {
    $$invalidate(6, deleting = true);
    await sleep(500);
    deleteNotification(id);
  }
  function button_1_deleting_binding(value) {
    deleting = value;
    $$invalidate(6, deleting);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("data" in $$props2)
      $$invalidate(1, data2 = $$props2.data);
    if ("pushed" in $$props2)
      $$invalidate(2, pushed = $$props2.pushed);
  };
  return [
    id,
    data2,
    pushed,
    time,
    shortTime,
    collapsed,
    deleting,
    toggleCollapse,
    deleteNotif,
    button_1_deleting_binding
  ];
}
class Notification extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$15, create_fragment$1d, safe_not_equal, { id: 0, data: 1, pushed: 2 });
  }
}
function get_each_context$e(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2][0];
  child_ctx[3] = list2[i2][1];
  return child_ctx;
}
function create_if_block_1$5(ctx) {
  let t2;
  let if_block_anchor;
  let current;
  let each_value = ensure_array_like([.../*store*/
  ctx[1]]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$e(get_each_context$e(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = !/*store*/
  ctx[1].size && !/*errored*/
  ctx[0] && create_if_block_2$1();
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*store*/
      2) {
        each_value = ensure_array_like([.../*store*/
        ctx2[1]]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$e(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$e(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t2.parentNode, t2);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!/*store*/
      ctx2[1].size && !/*errored*/
      ctx2[0]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_2$1();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_each_block$e(ctx) {
  let notificationsvelte;
  let current;
  notificationsvelte = new Notification({
    props: { id: (
      /*id*/
      ctx[2]
    ), data: (
      /*data*/
      ctx[3]
    ) }
  });
  return {
    c() {
      create_component(notificationsvelte.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notificationsvelte, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notificationsvelte_changes = {};
      if (dirty & /*store*/
      2)
        notificationsvelte_changes.id = /*id*/
        ctx2[2];
      if (dirty & /*store*/
      2)
        notificationsvelte_changes.data = /*data*/
        ctx2[3];
      notificationsvelte.$set(notificationsvelte_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(notificationsvelte.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notificationsvelte.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notificationsvelte, detaching);
    }
  };
}
function create_if_block_2$1(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "You have no notifications";
      attr(p2, "class", "none");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_if_block$B(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<img src="${WarningIcon}" alt=""/> <span>Missing Notification Service!</span>`;
      attr(div, "class", "service-error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$1c(ctx) {
  let div;
  let t2;
  let current;
  let if_block0 = (
    /*store*/
    ctx[1] && create_if_block_1$5(ctx)
  );
  let if_block1 = (
    /*errored*/
    ctx[0] && create_if_block$B()
  );
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      attr(div, "class", "notifications");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*store*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*store*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*errored*/
        ctx2[0]
      ) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block$B();
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance$14($$self, $$props, $$invalidate) {
  let errored = false;
  let store = /* @__PURE__ */ new Map([]);
  onMount(() => {
    const notifStore = getNotificationStore();
    if (!notifStore)
      return;
    notifStore.subscribe(async (v2) => {
      $$invalidate(1, store = null);
      if (!v2)
        return;
      await sleep();
      $$invalidate(1, store = v2);
    });
  });
  ProcessStack.processes.subscribe(() => {
    $$invalidate(0, errored = !isNotificationServiceActive());
    if (!errored) {
      const notifStore = getNotificationStore();
      $$invalidate(1, store = notifStore.get());
    }
  });
  return [errored, store];
}
class Notifications extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$14, create_fragment$1c, safe_not_equal, {});
  }
}
const QuickSettingsStore = [
  [
    {
      icon: "settings",
      iconOff: "settings",
      getter() {
        return false;
      },
      setter() {
        ActionCenterOpened.set(false);
        spawnApp("SettingsApp");
        return false;
      },
      caption: "Open Settings"
    }
  ],
  [
    {
      icon: "motion_photos_on",
      iconOff: "motion_photos_off",
      getter(udata) {
        return udata.sh.anim;
      },
      setter(udata) {
        udata.sh.anim = !udata.sh.anim;
        UserDataStore.set(udata);
        return udata.sh.anim;
      },
      caption: "Animations"
    },
    {
      icon: "blur_on",
      iconOff: "blur_off",
      getter(udata) {
        return !udata.sh.noGlass;
      },
      setter(udata) {
        udata.sh.noGlass = !udata.sh.noGlass;
        UserDataStore.set(udata);
        return !udata.sh.noGlass;
      },
      caption: "Transparency"
    },
    {
      icon: "call_to_action",
      iconOff: "call_to_action",
      getter(udata) {
        return udata.sh.taskbar.docked;
      },
      setter(udata) {
        udata.sh.taskbar.docked = !udata.sh.taskbar.docked;
        UserDataStore.set(udata);
        return udata.sh.taskbar.docked;
      },
      caption: "Dock Taskbar"
    },
    {
      icon: "dark_mode",
      iconOff: "light_mode",
      getter(udata) {
        return udata.sh.desktop.theme == "dark";
      },
      setter(udata) {
        const current = udata.sh.desktop.theme;
        udata.sh.desktop.theme = current == "dark" ? "light" : "dark";
        UserDataStore.set(udata);
        return udata.sh.desktop.theme == "dark";
      },
      caption: "Dark mode"
    },
    {
      icon: "invert_colors",
      iconOff: "invert_colors_off",
      getter(udata) {
        return udata.sh.taskbar.colored;
      },
      setter(udata) {
        udata.sh.taskbar.colored = !udata.sh.taskbar.colored;
        UserDataStore.set(udata);
        return udata.sh.taskbar.colored;
      },
      caption: "Colored Shell"
    }
  ],
  [
    {
      icon: "search",
      iconOff: "search",
      getter() {
        return false;
      },
      setter() {
        const pid = ProcessStack.getAppPids("ArcShell")[0];
        const proc = ProcessStack.getProcess(pid);
        if (!proc)
          return;
        ShellArcFind(proc);
        return false;
      },
      caption: "Search"
    },
    {
      icon: "logout",
      iconOff: "logout",
      getter() {
        return false;
      },
      setter() {
        spawnApp("ExitApp");
        return false;
      },
      caption: "Exit"
    }
  ]
];
function create_fragment$1b(ctx) {
  let button;
  let t_value = (
    /*active*/
    (ctx[1] ? (
      /*setting*/
      ctx[0].icon
    ) : (
      /*setting*/
      ctx[0].iconOff
    )) + ""
  );
  let t2;
  let button_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "class", "setting material-icons-round");
      attr(button, "title", button_title_value = /*setting*/
      ctx[0].caption);
      toggle_class(
        button,
        "active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*active, setting*/
      3 && t_value !== (t_value = /*active*/
      (ctx2[1] ? (
        /*setting*/
        ctx2[0].icon
      ) : (
        /*setting*/
        ctx2[0].iconOff
      )) + ""))
        set_data(t2, t_value);
      if (dirty & /*setting*/
      1 && button_title_value !== (button_title_value = /*setting*/
      ctx2[0].caption)) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*active*/
      2) {
        toggle_class(
          button,
          "active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$13($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(3, $UserDataStore = $$value));
  let active = false;
  let { setting } = $$props;
  function click2() {
    setting.setter($UserDataStore);
    $$invalidate(1, active = setting.getter($UserDataStore));
  }
  onMount(() => {
    $$invalidate(1, active = setting.getter($UserDataStore));
  });
  UserDataStore.subscribe((v2) => {
    $$invalidate(1, active = setting.getter(v2));
  });
  $$self.$$set = ($$props2) => {
    if ("setting" in $$props2)
      $$invalidate(0, setting = $$props2.setting);
  };
  return [setting, active, click2];
}
class QuickSetting extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$13, create_fragment$1b, safe_not_equal, { setting: 0 });
  }
}
function get_each_context$d(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2];
  return child_ctx;
}
function create_each_block$d(ctx) {
  let quicksettingsvelte;
  let current;
  quicksettingsvelte = new QuickSetting({ props: { setting: (
    /*setting*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(quicksettingsvelte.$$.fragment);
    },
    m(target, anchor) {
      mount_component(quicksettingsvelte, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const quicksettingsvelte_changes = {};
      if (dirty & /*group*/
      1)
        quicksettingsvelte_changes.setting = /*setting*/
        ctx2[1];
      quicksettingsvelte.$set(quicksettingsvelte_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(quicksettingsvelte.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(quicksettingsvelte.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(quicksettingsvelte, detaching);
    }
  };
}
function create_fragment$1a(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*group*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$d(get_each_context$d(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*group*/
      1) {
        each_value = ensure_array_like(
          /*group*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$d(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$d(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$12($$self, $$props, $$invalidate) {
  let { group } = $$props;
  $$self.$$set = ($$props2) => {
    if ("group" in $$props2)
      $$invalidate(0, group = $$props2.group);
  };
  return [group];
}
let Group$1 = class Group extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$12, create_fragment$1a, safe_not_equal, { group: 0 });
  }
};
function get_each_context$c(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list2[i2];
  return child_ctx;
}
function create_each_block$c(ctx) {
  let group_1;
  let current;
  group_1 = new Group$1({ props: { group: (
    /*group*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(group_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(group_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(group_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(group_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(group_1, detaching);
    }
  };
}
function create_fragment$19(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(QuickSettingsStore);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$c(get_each_context$c(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "quick-settings");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
class QuickSettings extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$19, safe_not_equal, {});
  }
}
function create_fragment$18(ctx) {
  let div;
  let header2;
  let t0;
  let notifications;
  let t1;
  let quicksettings;
  let current;
  header2 = new Header$1({});
  notifications = new Notifications({});
  quicksettings = new QuickSettings({});
  return {
    c() {
      div = element("div");
      create_component(header2.$$.fragment);
      t0 = space();
      create_component(notifications.$$.fragment);
      t1 = space();
      create_component(quicksettings.$$.fragment);
      attr(div, "class", "actioncenter shell-colored");
      toggle_class(
        div,
        "opened",
        /*$ActionCenterOpened*/
        ctx[0]
      );
      toggle_class(
        div,
        "colored",
        /*$UserDataStore*/
        ctx[1].sh.taskbar.colored
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(header2, div, null);
      append(div, t0);
      mount_component(notifications, div, null);
      append(div, t1);
      mount_component(quicksettings, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$ActionCenterOpened*/
      1) {
        toggle_class(
          div,
          "opened",
          /*$ActionCenterOpened*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$UserDataStore*/
      2) {
        toggle_class(
          div,
          "colored",
          /*$UserDataStore*/
          ctx2[1].sh.taskbar.colored
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(notifications.$$.fragment, local);
      transition_in(quicksettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(notifications.$$.fragment, local);
      transition_out(quicksettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(header2);
      destroy_component(notifications);
      destroy_component(quicksettings);
    }
  };
}
function instance$11($$self, $$props, $$invalidate) {
  let $ActionCenterOpened;
  let $UserDataStore;
  component_subscribe($$self, ActionCenterOpened, ($$value) => $$invalidate(0, $ActionCenterOpened = $$value));
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(1, $UserDataStore = $$value));
  function close() {
    set_store_value(ActionCenterOpened, $ActionCenterOpened = false, $ActionCenterOpened);
  }
  ActionCenterOpened.subscribe(closeNotification);
  ProcessStack.processes.subscribe(close);
  TrayIconOpened.subscribe(close);
  StartMenuOpened.subscribe((v2) => v2 && close());
  return [$ActionCenterOpened, $UserDataStore];
}
class ActionCenter extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$11, create_fragment$18, safe_not_equal, {});
  }
}
function create_if_block$A(ctx) {
  let notification2;
  let current;
  notification2 = new Notification({
    props: {
      id: (
        /*id*/
        ctx[1]
      ),
      data: (
        /*data*/
        ctx[2]
      ),
      pushed: true
    }
  });
  return {
    c() {
      create_component(notification2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notification2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notification_changes = {};
      if (dirty & /*id*/
      2)
        notification_changes.id = /*id*/
        ctx2[1];
      if (dirty & /*data*/
      4)
        notification_changes.data = /*data*/
        ctx2[2];
      notification2.$set(notification_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(notification2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notification2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notification2, detaching);
    }
  };
}
function create_fragment$17(ctx) {
  let div;
  let current;
  let if_block = (
    /*data*/
    ctx[2] && create_if_block$A(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "push-notification shell-colored");
      toggle_class(
        div,
        "colored",
        /*$UserDataStore*/
        ctx[4].sh.taskbar.colored
      );
      toggle_class(
        div,
        "show",
        /*show*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*data*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*data*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$A(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*$UserDataStore*/
      16) {
        toggle_class(
          div,
          "colored",
          /*$UserDataStore*/
          ctx2[4].sh.taskbar.colored
        );
      }
      if (!current || dirty & /*show*/
      1) {
        toggle_class(
          div,
          "show",
          /*show*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$10($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop$1, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, ($$value) => $$invalidate(7, $store = $$value)), store);
  let $ActionCenterOpened;
  let $UserDataStore;
  component_subscribe($$self, ActionCenterOpened, ($$value) => $$invalidate(8, $ActionCenterOpened = $$value));
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(4, $UserDataStore = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let show = false;
  let id = "";
  let data2 = null;
  let current = getNotifCurrentStore();
  let store = getNotificationStore();
  $$subscribe_store();
  let unsubscribe;
  onMount(subscribe$1);
  function subscribe$1() {
    if (!current)
      return;
    unsubscribe = current.subscribe(async (v2) => {
      if (id == v2)
        return;
      $$invalidate(1, id = v2);
      $$invalidate(0, show = false);
      if (!v2)
        return;
      await sleep(data2 ? 500 : 0);
      $$invalidate(0, show = !$ActionCenterOpened);
      ArcSoundBus.playSound("arcos.notification");
      $$invalidate(2, data2 = $store.get(id));
    });
  }
  let procSub = ProcessStack.processes.subscribe(() => {
    const errored = !isNotificationServiceActive();
    if (!errored && unsubscribe) {
      current = getNotifCurrentStore();
      $$subscribe_store($$invalidate(3, store = getNotificationStore()));
      if (unsubscribe)
        unsubscribe();
      unsubscribe = null;
      subscribe$1();
    }
  });
  onDestroy(() => {
    procSub();
    if (unsubscribe)
      unsubscribe();
  });
  return [show, id, data2, store, $UserDataStore];
}
class PushNotification extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$10, create_fragment$17, safe_not_equal, {});
  }
}
function create_fragment$16(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = ``;
      attr(button, "class", "shade fullscreen");
      toggle_class(
        button,
        "present",
        /*$ActionCenterOpened*/
        ctx[0] || /*$StartMenuOpened*/
        ctx[1] || /*$TrayIconOpened*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*closeAll*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$ActionCenterOpened, $StartMenuOpened, $TrayIconOpened*/
      7) {
        toggle_class(
          button,
          "present",
          /*$ActionCenterOpened*/
          ctx2[0] || /*$StartMenuOpened*/
          ctx2[1] || /*$TrayIconOpened*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$$($$self, $$props, $$invalidate) {
  let $ActionCenterOpened;
  let $StartMenuOpened;
  let $TrayIconOpened;
  component_subscribe($$self, ActionCenterOpened, ($$value) => $$invalidate(0, $ActionCenterOpened = $$value));
  component_subscribe($$self, StartMenuOpened, ($$value) => $$invalidate(1, $StartMenuOpened = $$value));
  component_subscribe($$self, TrayIconOpened, ($$value) => $$invalidate(2, $TrayIconOpened = $$value));
  function closeAll() {
    ActionCenterOpened.set(false);
    StartMenuOpened.set(false);
    TrayIconOpened.set(false);
  }
  return [$ActionCenterOpened, $StartMenuOpened, $TrayIconOpened, closeAll];
}
class Shade extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$$, create_fragment$16, safe_not_equal, {});
  }
}
function create_fragment$15(ctx) {
  let div1;
  let button0;
  let t1;
  let button1;
  let t3;
  let button2;
  let t5;
  let div0;
  let t6;
  let button3;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      button0 = element("button");
      button0.textContent = "question_mark";
      t1 = space();
      button1 = element("button");
      button1.textContent = "search";
      t3 = space();
      button2 = element("button");
      button2.textContent = "settings";
      t5 = space();
      div0 = element("div");
      t6 = space();
      button3 = element("button");
      button3.textContent = "power_settings_new";
      attr(button0, "class", "material-icons-round");
      attr(button0, "title", "Get Help");
      attr(button1, "class", "material-icons-round");
      attr(button1, "title", "Search (Alt+Shift+S)");
      attr(button2, "class", "material-icons-round");
      attr(div0, "class", "sep");
      attr(button3, "class", "material-icons-round");
      attr(div1, "class", "options");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, button0);
      append(div1, t1);
      append(div1, button1);
      append(div1, t3);
      append(div1, button2);
      append(div1, t5);
      append(div1, div0);
      append(div1, t6);
      append(div1, button3);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[3]
          ),
          listen(
            button1,
            "click",
            /*search*/
            ctx[0]
          ),
          listen(
            button2,
            "click",
            /*settings*/
            ctx[1]
          ),
          listen(
            button3,
            "click",
            /*exit*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$_($$self) {
  function search2() {
    const pid = ShellPid();
    const proc = ProcessStack.getProcess(pid);
    if (!proc)
      return;
    ShellArcFind(proc);
  }
  function settings2() {
    spawnApp("SettingsApp");
  }
  function exit() {
    spawnApp("ExitApp");
  }
  const click_handler = () => GetHelp(HelpArticles.home);
  return [search2, settings2, exit, click_handler];
}
class PowerOptions extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$_, create_fragment$15, safe_not_equal, {});
  }
}
function create_fragment$14(ctx) {
  let div;
  let profilepicture;
  let t0;
  let span;
  let t1;
  let t2;
  let poweroptions;
  let current;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*pfp*/
      ctx[0]
    ), height: 20 }
  });
  poweroptions = new PowerOptions({});
  return {
    c() {
      div = element("div");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(
        /*$UserName*/
        ctx[1]
      );
      t2 = space();
      create_component(poweroptions.$$.fragment);
      attr(div, "class", "bottompane");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(profilepicture, div, null);
      append(div, t0);
      append(div, span);
      append(span, t1);
      append(div, t2);
      mount_component(poweroptions, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      1)
        profilepicture_changes.src = /*pfp*/
        ctx2[0];
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*$UserName*/
      2)
        set_data(
          t1,
          /*$UserName*/
          ctx2[1]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      transition_in(poweroptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      transition_out(poweroptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(profilepicture);
      destroy_component(poweroptions);
    }
  };
}
function instance$Z($$self, $$props, $$invalidate) {
  let $UserName;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(1, $UserName = $$value));
  let pfp = "";
  UserDataStore.subscribe((v2) => {
    $$invalidate(0, pfp = getProfilePicture(v2.acc.profilePicture));
  });
  return [pfp, $UserName];
}
class Bottom4 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$Z, create_fragment$14, safe_not_equal, {});
  }
}
function getAppGroups() {
  const library = appLibrary.get();
  const grouped = [];
  let result = {};
  let rest = [];
  for (const [id, app] of library) {
    rest.push(id);
    const group = app.metadata.appGroup;
    if (!appGroups[group])
      continue;
    if (!isPopulatable(app)) {
      grouped.push(id);
      continue;
    }
    grouped.push(id);
    if (!result[group]) {
      result[group] = { ...appGroups[group], apps: [id] };
      continue;
    }
    result[group].apps.push(id);
  }
  rest = rest.filter((a2) => !grouped.includes(a2));
  const entries = Object.entries(result).map((g2) => {
    g2[1].apps = g2[1].apps.sort((a2, b2) => {
      const appA = library.get(a2);
      const appB = library.get(b2);
      return appA.metadata.name > appB.metadata.name ? 1 : -1;
    });
    return g2;
  });
  result = Object.fromEntries(
    entries.sort((a2, b2) => a2[1].index - b2[1].index)
  );
  return { groups: result, rest };
}
function create_if_block$z(ctx) {
  let button;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let t1_value = (
    /*app*/
    ctx[0].metadata.name + ""
  );
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      t1 = text(t1_value);
      if (!src_url_equal(img.src, img_src_value = /*app*/
      ctx[0].metadata.icon))
        attr(img, "src", img_src_value);
      attr(img, "class", "icon");
      attr(img, "alt", img_alt_value = /*app*/
      ctx[0].id);
      attr(button, "class", "item");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*open*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*app*/
      1 && !src_url_equal(img.src, img_src_value = /*app*/
      ctx2[0].metadata.icon)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*app*/
      1 && img_alt_value !== (img_alt_value = /*app*/
      ctx2[0].id)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*app*/
      1 && t1_value !== (t1_value = /*app*/
      ctx2[0].metadata.name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$13(ctx) {
  let if_block_anchor;
  let if_block = (
    /*render*/
    ctx[1] && create_if_block$z(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*render*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$z(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$Y($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let render = true;
  UserDataStore.subscribe(() => {
    $$invalidate(1, render = isPopulatable(app) && !isDisabled(app.id));
  });
  function open() {
    spawnApp(app.id);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [app, render, open];
}
class AppListItem extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$Y, create_fragment$13, safe_not_equal, { app: 0 });
  }
}
function get_each_context$b(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function create_if_block$y(ctx) {
  let div1;
  let button;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1_value = (
    /*group*/
    ctx[0].name + ""
  );
  let t1;
  let t2;
  let div0;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*group*/
    ctx[0].apps
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$b(get_each_context$b(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div1 = element("div");
      button = element("button");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (!src_url_equal(img.src, img_src_value = FolderIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(span, "class", "capt");
      attr(button, "class", "expander");
      attr(div0, "class", "apps");
      attr(div1, "class", "group");
      toggle_class(
        div1,
        "expand",
        /*expand*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, button);
      append(button, img);
      append(button, t0);
      append(button, span);
      append(span, t1);
      append(div1, t2);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggle*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*group*/
      1) && t1_value !== (t1_value = /*group*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*group*/
      1) {
        each_value = ensure_array_like(
          /*group*/
          ctx2[0].apps
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$b(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$b(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*expand*/
      2) {
        toggle_class(
          div1,
          "expand",
          /*expand*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$4(ctx) {
  let applistitem;
  let current;
  applistitem = new AppListItem({
    props: { app: getAppById(
      /*id*/
      ctx[3]
    ) }
  });
  return {
    c() {
      create_component(applistitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applistitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applistitem_changes = {};
      if (dirty & /*group*/
      1)
        applistitem_changes.app = getAppById(
          /*id*/
          ctx2[3]
        );
      applistitem.$set(applistitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applistitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applistitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applistitem, detaching);
    }
  };
}
function create_each_block$b(ctx) {
  let show_if = isPopulatable(getAppById(
    /*id*/
    ctx[3]
  ));
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_1$4(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*group*/
      1)
        show_if = isPopulatable(getAppById(
          /*id*/
          ctx2[3]
        ));
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*group*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$12(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*group*/
    ctx[0] && /*group*/
    ctx[0].apps && create_if_block$y(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*group*/
        ctx2[0] && /*group*/
        ctx2[0].apps
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*group*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$y(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$X($$self, $$props, $$invalidate) {
  let { group } = $$props;
  let expand = false;
  const toggle = () => $$invalidate(1, expand = !expand);
  $$self.$$set = ($$props2) => {
    if ("group" in $$props2)
      $$invalidate(0, group = $$props2.group);
  };
  return [group, expand, toggle];
}
class Group2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$X, create_fragment$12, safe_not_equal, { group: 0 });
  }
}
function get_each_context_2(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list2[i2][0];
  child_ctx[13] = list2[i2][1];
  return child_ctx;
}
function get_each_context$a(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list2[i2];
  return child_ctx;
}
function get_each_context_1(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list2[i2];
  return child_ctx;
}
function create_else_block$6(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ensure_array_like([.../*$appLibrary*/
  ctx[3]]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2(get_each_context_2(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$appLibrary*/
      8) {
        each_value_2 = ensure_array_like([.../*$appLibrary*/
        ctx2[3]]);
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block$x(ctx) {
  let t2;
  let each1_anchor;
  let current;
  let each_value_1 = ensure_array_like(Object.values(
    /*$groups*/
    ctx[1]
  ));
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  let each_value = ensure_array_like(
    /*rest*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$a(get_each_context$a(ctx, each_value, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, $groups*/
      2) {
        each_value_1 = ensure_array_like(Object.values(
          /*$groups*/
          ctx2[1]
        ));
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_1(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(t2.parentNode, t2);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (dirty & /*rest*/
      1) {
        each_value = ensure_array_like(
          /*rest*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$a(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$a(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each1_anchor.parentNode, each1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(each1_anchor);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_2(ctx) {
  let applistitem;
  let current;
  applistitem = new AppListItem({ props: { app: (
    /*window*/
    ctx[13]
  ) } });
  return {
    c() {
      create_component(applistitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applistitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applistitem_changes = {};
      if (dirty & /*$appLibrary*/
      8)
        applistitem_changes.app = /*window*/
        ctx2[13];
      applistitem.$set(applistitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applistitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applistitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applistitem, detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let group;
  let current;
  group = new Group2({ props: { group: (
    /*entry*/
    ctx[9]
  ) } });
  return {
    c() {
      create_component(group.$$.fragment);
    },
    m(target, anchor) {
      mount_component(group, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const group_changes = {};
      if (dirty & /*$groups*/
      2)
        group_changes.group = /*entry*/
        ctx2[9];
      group.$set(group_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(group.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(group.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(group, detaching);
    }
  };
}
function create_each_block$a(ctx) {
  let applistitem;
  let current;
  applistitem = new AppListItem({
    props: { app: getAppById(
      /*id*/
      ctx[6]
    ) }
  });
  return {
    c() {
      create_component(applistitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applistitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applistitem_changes = {};
      if (dirty & /*rest*/
      1)
        applistitem_changes.app = getAppById(
          /*id*/
          ctx2[6]
        );
      applistitem.$set(applistitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applistitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applistitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applistitem, detaching);
    }
  };
}
function create_fragment$11(ctx) {
  let div;
  let span;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$x, create_else_block$6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*$UserDataStore*/
    ctx2[2].sh.start.noGroups)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      span = element("span");
      if_block.c();
      attr(div, "class", "leftpane");
      attr(div, "data-contextmenu", "startmenu-applist");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      if_blocks[current_block_type_index].m(span, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(span, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$W($$self, $$props, $$invalidate) {
  let $groups;
  let $UserDataStore;
  let $appLibrary;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(2, $UserDataStore = $$value));
  component_subscribe($$self, appLibrary, ($$value) => $$invalidate(3, $appLibrary = $$value));
  let groups = Store$1({});
  component_subscribe($$self, groups, (value) => $$invalidate(1, $groups = value));
  let rest = [];
  async function update2() {
    set_store_value(groups, $groups = {}, $groups);
    await sleep();
    const getter = getAppGroups();
    set_store_value(groups, $groups = getter.groups, $groups);
    $$invalidate(0, rest = getter.rest);
  }
  appLibrary.subscribe(update2);
  UserDataStore.subscribe(update2);
  return [rest, $groups, $UserDataStore, $appLibrary, groups];
}
class LeftPane extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$W, create_fragment$11, safe_not_equal, {});
  }
}
function create_fragment$10(ctx) {
  let button;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1_value = (
    /*folder*/
    ctx[0].name + ""
  );
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      if (!src_url_equal(img.src, img_src_value = /*folder*/
      ctx[0].icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(img, "class", "icon");
      attr(button, "class", "folder");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, span);
      append(span, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*goHere*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*folder*/
      1 && !src_url_equal(img.src, img_src_value = /*folder*/
      ctx2[0].icon)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*folder*/
      1 && t1_value !== (t1_value = /*folder*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$V($$self, $$props, $$invalidate) {
  let { folder } = $$props;
  function goHere() {
    spawnApp("FileManager", 0, [folder.path]);
  }
  $$self.$$set = ($$props2) => {
    if ("folder" in $$props2)
      $$invalidate(0, folder = $$props2.folder);
  };
  return [folder, goHere];
}
class Folder2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$V, create_fragment$10, safe_not_equal, { folder: 0 });
  }
}
function get_each_context$9(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list2[i2];
  return child_ctx;
}
function create_each_block$9(ctx) {
  let folder_1;
  let current;
  folder_1 = new Folder2({ props: { folder: (
    /*folder*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(folder_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(folder_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(folder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(folder_1, detaching);
    }
  };
}
function create_fragment$$(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(SystemFolders);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$9(get_each_context$9(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "rightpane");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
class RightPane extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$$, safe_not_equal, {});
  }
}
function create_if_block$w(ctx) {
  let div1;
  let div0;
  let leftpane;
  let t0;
  let rightpane;
  let t1;
  let bottom;
  let current;
  leftpane = new LeftPane({});
  rightpane = new RightPane({});
  bottom = new Bottom4({});
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(leftpane.$$.fragment);
      t0 = space();
      create_component(rightpane.$$.fragment);
      t1 = space();
      create_component(bottom.$$.fragment);
      attr(div0, "class", "top");
      attr(div1, "class", "startmenu shell-colored");
      toggle_class(
        div1,
        "small",
        /*$UserDataStore*/
        ctx[1].sh.start.small
      );
      toggle_class(
        div1,
        "opened",
        /*$StartMenuOpened*/
        ctx[0]
      );
      toggle_class(
        div1,
        "colored",
        /*$UserDataStore*/
        ctx[1].sh.taskbar.colored
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(leftpane, div0, null);
      append(div0, t0);
      mount_component(rightpane, div0, null);
      append(div1, t1);
      mount_component(bottom, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*$UserDataStore*/
      2) {
        toggle_class(
          div1,
          "small",
          /*$UserDataStore*/
          ctx2[1].sh.start.small
        );
      }
      if (!current || dirty & /*$StartMenuOpened*/
      1) {
        toggle_class(
          div1,
          "opened",
          /*$StartMenuOpened*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$UserDataStore*/
      2) {
        toggle_class(
          div1,
          "colored",
          /*$UserDataStore*/
          ctx2[1].sh.taskbar.colored
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leftpane.$$.fragment, local);
      transition_in(rightpane.$$.fragment, local);
      transition_in(bottom.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(leftpane.$$.fragment, local);
      transition_out(rightpane.$$.fragment, local);
      transition_out(bottom.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(leftpane);
      destroy_component(rightpane);
      destroy_component(bottom);
    }
  };
}
function create_fragment$_(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$UserDataStore*/
    ctx[1] && create_if_block$w(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$UserDataStore*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$UserDataStore*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$w(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$U($$self, $$props, $$invalidate) {
  let $StartMenuOpened;
  let $UserDataStore;
  component_subscribe($$self, StartMenuOpened, ($$value) => $$invalidate(0, $StartMenuOpened = $$value));
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(1, $UserDataStore = $$value));
  function close() {
    set_store_value(StartMenuOpened, $StartMenuOpened = false, $StartMenuOpened);
  }
  focusedPid.subscribe(close);
  ProcessStack.processes.subscribe(close);
  ActionCenterOpened.subscribe((v2) => v2 && close());
  return [$StartMenuOpened, $UserDataStore];
}
class StartMenu extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$U, create_fragment$_, safe_not_equal, {});
  }
}
function create_if_block$v(ctx) {
  let button;
  let img;
  let img_src_value;
  let img_alt_value;
  let t2;
  let button_title_value;
  let button_data_id_value;
  let mounted;
  let dispose;
  let if_block = (
    /*$UserDataStore*/
    ctx[6].sh.taskbar.labels && create_if_block_1$3(ctx)
  );
  return {
    c() {
      button = element("button");
      img = element("img");
      t2 = space();
      if (if_block)
        if_block.c();
      if (!src_url_equal(img.src, img_src_value = /*$mutator*/
      ctx[5].metadata.icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*$mutator*/
      ctx[5].id);
      attr(button, "class", "opened-app");
      attr(button, "title", button_title_value = /*$UserDataStore*/
      ctx[6].sh.taskbar.labels ? (
        /*proc*/
        ctx[1].app.metadata.name
      ) : (
        /*$mutator*/
        ctx[5].metadata.name
      ));
      attr(button, "data-contextmenu", "opened-app");
      attr(button, "data-id", button_data_id_value = /*$mutator*/
      ctx[5].id);
      attr(
        button,
        "data-pid",
        /*pid*/
        ctx[0]
      );
      toggle_class(
        button,
        "activated",
        /*$focusedPid*/
        ctx[4] == /*pid*/
        ctx[0]
      );
      toggle_class(
        button,
        "labels",
        /*$UserDataStore*/
        ctx[6].sh.taskbar.labels
      );
      toggle_class(
        button,
        "closing",
        /*closing*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t2);
      if (if_block)
        if_block.m(button, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*show*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$mutator*/
      32 && !src_url_equal(img.src, img_src_value = /*$mutator*/
      ctx2[5].metadata.icon)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*$mutator*/
      32 && img_alt_value !== (img_alt_value = /*$mutator*/
      ctx2[5].id)) {
        attr(img, "alt", img_alt_value);
      }
      if (
        /*$UserDataStore*/
        ctx2[6].sh.taskbar.labels
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$3(ctx2);
          if_block.c();
          if_block.m(button, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*$UserDataStore, proc, $mutator*/
      98 && button_title_value !== (button_title_value = /*$UserDataStore*/
      ctx2[6].sh.taskbar.labels ? (
        /*proc*/
        ctx2[1].app.metadata.name
      ) : (
        /*$mutator*/
        ctx2[5].metadata.name
      ))) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*$mutator*/
      32 && button_data_id_value !== (button_data_id_value = /*$mutator*/
      ctx2[5].id)) {
        attr(button, "data-id", button_data_id_value);
      }
      if (dirty & /*pid*/
      1) {
        attr(
          button,
          "data-pid",
          /*pid*/
          ctx2[0]
        );
      }
      if (dirty & /*$focusedPid, pid*/
      17) {
        toggle_class(
          button,
          "activated",
          /*$focusedPid*/
          ctx2[4] == /*pid*/
          ctx2[0]
        );
      }
      if (dirty & /*$UserDataStore*/
      64) {
        toggle_class(
          button,
          "labels",
          /*$UserDataStore*/
          ctx2[6].sh.taskbar.labels
        );
      }
      if (dirty & /*closing*/
      4) {
        toggle_class(
          button,
          "closing",
          /*closing*/
          ctx2[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$3(ctx) {
  let span;
  let t_value = (
    /*$mutator*/
    ctx[5].metadata.name + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$mutator*/
      32 && t_value !== (t_value = /*$mutator*/
      ctx2[5].metadata.name + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$Z(ctx) {
  let if_block_anchor;
  let if_block = (
    /*render*/
    ctx[3] && !/*proc*/
    ctx[1]._disposed && /*$mutator*/
    ctx[5] && create_if_block$v(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*render*/
        ctx2[3] && !/*proc*/
        ctx2[1]._disposed && /*$mutator*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$v(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$T($$self, $$props, $$invalidate) {
  let $focusedPid;
  let $mutator;
  let $UserDataStore;
  component_subscribe($$self, focusedPid, ($$value) => $$invalidate(4, $focusedPid = $$value));
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(6, $UserDataStore = $$value));
  let { pid } = $$props;
  let { proc } = $$props;
  const { mutator } = proc;
  component_subscribe($$self, mutator, (value) => $$invalidate(5, $mutator = value));
  let closing = false;
  let render = true;
  ProcessStack.closedPids.subscribe(update2);
  async function update2(v2) {
    $$invalidate(2, closing = v2.includes(pid));
    if (closing) {
      await sleep(300);
      $$invalidate(3, render = false);
    }
  }
  UserDataStore.subscribe(() => {
    if (closing || !$mutator)
      return;
    $$invalidate(3, render = isPopulatable($mutator));
  });
  function show() {
    set_store_value(focusedPid, $focusedPid = pid, $focusedPid);
  }
  $$self.$$set = ($$props2) => {
    if ("pid" in $$props2)
      $$invalidate(0, pid = $$props2.pid);
    if ("proc" in $$props2)
      $$invalidate(1, proc = $$props2.proc);
  };
  return [
    pid,
    proc,
    closing,
    render,
    $focusedPid,
    $mutator,
    $UserDataStore,
    mutator,
    show
  ];
}
class OpenedApp extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$T, create_fragment$Z, safe_not_equal, { pid: 0, proc: 1 });
  }
}
function get_each_context$8(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2][0];
  child_ctx[3] = list2[i2][1];
  return child_ctx;
}
function create_each_block$8(ctx) {
  let openedapp;
  let current;
  openedapp = new OpenedApp({
    props: {
      pid: (
        /*pid*/
        ctx[2]
      ),
      proc: (
        /*proc*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(openedapp.$$.fragment);
    },
    m(target, anchor) {
      mount_component(openedapp, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const openedapp_changes = {};
      if (dirty & /*processes*/
      1)
        openedapp_changes.pid = /*pid*/
        ctx2[2];
      if (dirty & /*processes*/
      1)
        openedapp_changes.proc = /*proc*/
        ctx2[3];
      openedapp.$set(openedapp_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(openedapp.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(openedapp.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(openedapp, detaching);
    }
  };
}
function create_fragment$Y(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like([.../*processes*/
  ctx[0]]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$8(get_each_context$8(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "opened-apps");
      toggle_class(
        div,
        "centered",
        /*$UserDataStore*/
        ctx[1].sh.taskbar.centered
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*processes*/
      1) {
        each_value = ensure_array_like([.../*processes*/
        ctx2[0]]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$8(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$8(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*$UserDataStore*/
      2) {
        toggle_class(
          div,
          "centered",
          /*$UserDataStore*/
          ctx2[1].sh.taskbar.centered
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$S($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(1, $UserDataStore = $$value));
  let processes = /* @__PURE__ */ new Map([]);
  ProcessStack.processes.subscribe((v2) => $$invalidate(0, processes = v2));
  return [processes, $UserDataStore];
}
class OpenedApps extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$S, create_fragment$Y, safe_not_equal, {});
  }
}
const AccentedLogo_svelte_svelte_type_style_lang = "";
function create_fragment$X(ctx) {
  let svg;
  let g2;
  let path0;
  let path1;
  let path2;
  let defs;
  let clipPath;
  let rect;
  return {
    c() {
      svg = svg_element("svg");
      g2 = svg_element("g");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      defs = svg_element("defs");
      clipPath = svg_element("clipPath");
      rect = svg_element("rect");
      attr(path0, "d", "M258.424 72.16L259.472 72.272L260.512 72.432L261.544 72.632L262.552 72.872L263.552 73.16L264.536 73.48L265.496 73.848L266.44 74.248L267.368 74.688L268.28 75.168L269.168 75.68L270.032 76.232L270.88 76.808L271.704 77.424L272.496 78.072L273.272 78.752L274.024 79.464L274.744 80.208L275.44 80.976L276.104 81.768L276.288 82.008L276.44 82.184L276.616 82.4L276.776 82.632L276.84 82.72L277.352 83.44L277.936 84.32L278.48 85.216L279 86.136L279.48 87.08L279.912 88.016L421.504 333.264L421.648 333.512L421.768 333.768L421.888 334.024L421.992 334.28L422.08 334.544L422.168 334.808L422.232 335.072L422.296 335.336L422.344 335.6L422.384 335.872L422.408 336.136L422.432 336.408V336.672V336.936L422.416 337.208L422.392 337.472L422.36 337.736L422.32 338L422.264 338.256L422.2 338.512L422.128 338.768L422.04 339.024L421.952 339.272L421.848 339.52L421.736 339.76L421.616 339.992L421.48 340.232L421.344 340.456L421.192 340.68L421.032 340.896L420.872 341.112L420.696 341.32L420.512 341.52L420.312 341.712L420.112 341.896L419.904 342.08L419.68 342.248L419.456 342.416L419.216 342.568L418.976 342.712L377.76 366.512L377.512 366.648L377.256 366.776L377 366.888L376.744 366.992L376.48 367.088L376.216 367.168L375.952 367.24L375.688 367.296L375.424 367.352L375.16 367.384L374.888 367.416L374.624 367.432L374.352 367.44L374.088 367.432L373.816 367.424L373.552 367.4L373.288 367.368L373.032 367.32L372.768 367.264L372.512 367.2L372.256 367.128L372 367.048L371.752 366.952L371.512 366.848L371.264 366.736L371.032 366.616L370.792 366.488L370.568 366.344L370.344 366.2L370.128 366.04L369.912 365.872L369.704 365.696L369.504 365.512L369.312 365.32L369.128 365.12L368.952 364.904L368.776 364.688L368.616 364.456L368.456 364.224L368.312 363.976L256.2 169.8L144.088 363.976L143.944 364.224L143.784 364.456L143.624 364.688L143.448 364.904L143.272 365.12L143.088 365.32L142.896 365.512L142.696 365.696L142.488 365.872L142.272 366.04L142.056 366.2L141.832 366.344L141.608 366.488L141.368 366.616L141.136 366.736L140.888 366.848L140.648 366.952L140.4 367.048L140.144 367.128L139.888 367.2L139.632 367.264L139.368 367.32L139.112 367.368L138.848 367.4L138.584 367.424L138.312 367.432L138.048 367.44L137.776 367.432L137.512 367.416L137.24 367.384L136.976 367.352L136.712 367.296L136.448 367.24L136.184 367.168L135.92 367.088L135.656 366.992L135.4 366.888L135.144 366.776L134.888 366.648L134.64 366.512L93.424 342.712L93.184 342.568L92.944 342.416L92.72 342.248L92.496 342.08L92.288 341.896L92.088 341.712L91.888 341.52L91.704 341.32L91.528 341.112L91.368 340.896L91.208 340.68L91.056 340.456L90.92 340.232L90.784 339.992L90.664 339.76L90.552 339.52L90.448 339.272L90.36 339.024L90.272 338.768L90.2 338.512L90.136 338.256L90.08 338L90.04 337.736L90.008 337.472L89.984 337.208L89.968 336.936V336.672V336.408L89.992 336.136L90.016 335.872L90.056 335.6L90.104 335.336L90.168 335.072L90.232 334.808L90.32 334.544L90.408 334.28L90.512 334.024L90.632 333.768L90.752 333.512L90.896 333.264L233.544 86.192L233.568 86.136L234.08 85.216L234.472 84.576L235.32 83.112L235.464 82.864L235.624 82.632L235.784 82.4L235.96 82.184L236.136 81.976L236.32 81.768L236.52 81.576L236.72 81.392L236.912 81.232L237.128 80.976L237.824 80.208L238.544 79.464L239.288 78.752L240.064 78.072L240.864 77.424L241.688 76.808L242.528 76.232L243.4 75.68L244.288 75.168L245.192 74.688L246.12 74.248L247.064 73.848L248.032 73.48L249.016 73.16L250.008 72.872L251.024 72.632L252.048 72.432L253.088 72.272L254.144 72.16L255.208 72.088L256.28 72.064L257.36 72.088L258.424 72.16Z");
      attr(path0, "fill", "white");
      attr(path0, "fill-opacity", "0.25");
      attr(path0, "class", "part svelte-tolmqv");
      attr(path1, "d", "M259.224 97.76L260.272 97.872L261.312 98.032L262.344 98.232L263.352 98.472L264.352 98.76L265.336 99.08L266.296 99.448L267.24 99.848L268.168 100.288L269.08 100.768L269.968 101.28L270.832 101.832L271.68 102.408L272.504 103.024L273.296 103.672L274.072 104.352L274.824 105.064L275.544 105.808L276.24 106.576L276.904 107.368L277.088 107.608L277.24 107.784L277.416 108L277.576 108.232L277.64 108.32L278.152 109.04L278.736 109.92L279.28 110.816L279.8 111.736L280.28 112.68L280.712 113.616L422.304 358.864L422.448 359.112L422.568 359.368L422.688 359.624L422.792 359.88L422.88 360.144L422.968 360.408L423.032 360.672L423.096 360.936L423.144 361.2L423.184 361.472L423.208 361.736L423.232 362.008V362.272V362.536L423.216 362.808L423.192 363.072L423.16 363.336L423.12 363.6L423.064 363.856L423 364.112L422.928 364.368L422.84 364.624L422.752 364.872L422.648 365.12L422.536 365.36L422.416 365.592L422.28 365.832L422.144 366.056L421.992 366.28L421.832 366.496L421.672 366.712L421.496 366.92L421.312 367.12L421.112 367.312L420.912 367.496L420.704 367.68L420.48 367.848L420.256 368.016L420.016 368.168L419.776 368.312L378.56 392.112L378.312 392.248L378.056 392.376L377.8 392.488L377.544 392.592L377.28 392.688L377.016 392.768L376.752 392.84L376.488 392.896L376.224 392.952L375.96 392.984L375.688 393.016L375.424 393.032L375.152 393.04L374.888 393.032L374.616 393.024L374.352 393L374.088 392.968L373.832 392.92L373.568 392.864L373.312 392.8L373.056 392.728L372.8 392.648L372.552 392.552L372.312 392.448L372.064 392.336L371.832 392.216L371.592 392.088L371.368 391.944L371.144 391.8L370.928 391.64L370.712 391.472L370.504 391.296L370.304 391.112L370.112 390.92L369.928 390.72L369.752 390.504L369.576 390.288L369.416 390.056L369.256 389.824L369.112 389.576L257 195.4L144.888 389.576L144.744 389.824L144.584 390.056L144.424 390.288L144.248 390.504L144.072 390.72L143.888 390.92L143.696 391.112L143.496 391.296L143.288 391.472L143.072 391.64L142.856 391.8L142.632 391.944L142.408 392.088L142.168 392.216L141.936 392.336L141.688 392.448L141.448 392.552L141.2 392.648L140.944 392.728L140.688 392.8L140.432 392.864L140.168 392.92L139.912 392.968L139.648 393L139.384 393.024L139.112 393.032L138.848 393.04L138.576 393.032L138.312 393.016L138.04 392.984L137.776 392.952L137.512 392.896L137.248 392.84L136.984 392.768L136.72 392.688L136.456 392.592L136.2 392.488L135.944 392.376L135.688 392.248L135.44 392.112L94.224 368.312L93.984 368.168L93.744 368.016L93.52 367.848L93.296 367.68L93.088 367.496L92.888 367.312L92.688 367.12L92.504 366.92L92.328 366.712L92.168 366.496L92.008 366.28L91.856 366.056L91.72 365.832L91.584 365.592L91.464 365.36L91.352 365.12L91.248 364.872L91.16 364.624L91.072 364.368L91 364.112L90.936 363.856L90.88 363.6L90.84 363.336L90.808 363.072L90.784 362.808L90.768 362.536V362.272V362.008L90.792 361.736L90.816 361.472L90.856 361.2L90.904 360.936L90.968 360.672L91.032 360.408L91.12 360.144L91.208 359.88L91.312 359.624L91.432 359.368L91.552 359.112L91.696 358.864L234.344 111.792L234.368 111.736L234.88 110.816L235.272 110.176L236.12 108.712L236.264 108.464L236.424 108.232L236.584 108L236.76 107.784L236.936 107.576L237.12 107.368L237.32 107.176L237.52 106.992L237.712 106.832L237.928 106.576L238.624 105.808L239.344 105.064L240.088 104.352L240.864 103.672L241.664 103.024L242.488 102.408L243.328 101.832L244.2 101.28L245.088 100.768L245.992 100.288L246.92 99.848L247.864 99.448L248.832 99.08L249.816 98.76L250.808 98.472L251.824 98.232L252.848 98.032L253.888 97.872L254.944 97.76L256.008 97.688L257.08 97.664L258.16 97.688L259.224 97.76Z");
      attr(path1, "fill", "white");
      attr(path1, "fill-opacity", "0.5");
      attr(path1, "class", "part svelte-tolmqv");
      attr(path2, "d", "M259.224 126.472L260.272 126.584L261.312 126.744L262.344 126.944L263.352 127.184L264.352 127.472L265.336 127.8L266.296 128.16L267.24 128.56L268.168 129.008L269.08 129.48L269.968 129.992L270.832 130.544L271.68 131.128L272.504 131.744L273.296 132.392L274.072 133.072L274.824 133.776L275.544 134.52L276.24 135.288L276.904 136.088L277.088 136.32L277.24 136.496L277.416 136.72L277.576 136.944L277.64 137.04L278.152 137.76L278.736 138.632L279.28 139.528L279.8 140.456L280.28 141.4L280.712 142.328L422.304 387.576L422.448 387.832L422.568 388.08L422.688 388.336L422.792 388.6L422.88 388.856L422.968 389.12L423.032 389.384L423.096 389.648L423.144 389.912L423.184 390.184L423.208 390.448L423.232 390.72V390.984V391.256L423.216 391.52L423.192 391.784L423.16 392.048L423.12 392.312L423.064 392.568L423 392.832L422.928 393.088L422.84 393.336L422.752 393.584L422.648 393.832L422.536 394.072L422.416 394.312L422.28 394.544L422.144 394.768L421.992 394.992L421.832 395.216L421.672 395.424L421.496 395.632L421.312 395.832L421.112 396.024L420.912 396.208L420.704 396.392L420.48 396.56L420.256 396.728L420.016 396.88L419.776 397.032L378.56 420.824L378.312 420.96L378.056 421.088L377.8 421.208L377.544 421.312L377.28 421.4L377.016 421.48L376.752 421.552L376.488 421.616L376.224 421.664L375.96 421.704L375.688 421.728L375.424 421.744L375.152 421.752H374.888L374.616 421.736L374.352 421.712L374.088 421.68L373.832 421.632L373.568 421.584L373.312 421.52L373.056 421.44L372.8 421.36L372.552 421.264L372.312 421.168L372.064 421.056L371.832 420.928L371.592 420.8L371.368 420.664L371.144 420.512L370.928 420.352L370.712 420.184L370.504 420.008L370.304 419.824L370.112 419.632L369.928 419.432L369.752 419.216L369.576 419L369.416 418.776L369.256 418.536L369.112 418.296L257 224.112L144.888 418.296L144.744 418.536L144.584 418.776L144.424 419L144.248 419.216L144.072 419.432L143.888 419.632L143.696 419.824L143.496 420.008L143.288 420.184L143.072 420.352L142.856 420.512L142.632 420.664L142.408 420.8L142.168 420.928L141.936 421.056L141.688 421.168L141.448 421.264L141.2 421.36L140.944 421.44L140.688 421.52L140.432 421.584L140.168 421.632L139.912 421.68L139.648 421.712L139.384 421.736L139.112 421.752H138.848L138.576 421.744L138.312 421.728L138.04 421.704L137.776 421.664L137.512 421.616L137.248 421.552L136.984 421.48L136.72 421.4L136.456 421.312L136.2 421.208L135.944 421.088L135.688 420.96L135.44 420.824L94.224 397.032L93.984 396.88L93.744 396.728L93.52 396.56L93.296 396.392L93.088 396.208L92.888 396.024L92.688 395.832L92.504 395.632L92.328 395.424L92.168 395.216L92.008 394.992L91.856 394.768L91.72 394.544L91.584 394.312L91.464 394.072L91.352 393.832L91.248 393.584L91.16 393.336L91.072 393.088L91 392.832L90.936 392.568L90.88 392.312L90.84 392.048L90.808 391.784L90.784 391.52L90.768 391.256V390.984V390.72L90.792 390.448L90.816 390.184L90.856 389.912L90.904 389.648L90.968 389.384L91.032 389.12L91.12 388.856L91.208 388.6L91.312 388.336L91.432 388.08L91.552 387.832L91.696 387.576L234.344 140.504L234.368 140.456L234.88 139.528L235.272 138.888L236.12 137.424L236.264 137.184L236.424 136.944L236.584 136.72L236.76 136.496L236.936 136.288L237.12 136.088L237.32 135.896L237.52 135.704L237.712 135.544L237.928 135.288L238.624 134.52L239.344 133.776L240.088 133.072L240.864 132.392L241.664 131.744L242.488 131.128L243.328 130.544L244.2 129.992L245.088 129.48L245.992 129.008L246.92 128.56L247.864 128.16L248.832 127.8L249.816 127.472L250.808 127.184L251.824 126.944L252.848 126.744L253.888 126.584L254.944 126.472L256.008 126.4L257.08 126.376L258.16 126.4L259.224 126.472Z");
      attr(path2, "fill", "white");
      attr(path2, "class", "part svelte-tolmqv");
      attr(g2, "clip-path", "url(#clip0_202_2)");
      attr(rect, "width", "512");
      attr(rect, "height", "512");
      attr(rect, "fill", "white");
      attr(clipPath, "id", "clip0_202_2");
      attr(
        svg,
        "width",
        /*width*/
        ctx[0]
      );
      attr(
        svg,
        "height",
        /*height*/
        ctx[1]
      );
      attr(svg, "viewBox", "0 0 512 512");
      attr(svg, "fill", "none");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "class", "accented-logo svelte-tolmqv");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g2);
      append(g2, path0);
      append(g2, path1);
      append(g2, path2);
      append(svg, defs);
      append(defs, clipPath);
      append(clipPath, rect);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*width*/
      1) {
        attr(
          svg,
          "width",
          /*width*/
          ctx2[0]
        );
      }
      if (dirty & /*height*/
      2) {
        attr(
          svg,
          "height",
          /*height*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function instance$R($$self, $$props, $$invalidate) {
  let { width = 512 } = $$props;
  let { height = 512 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
  };
  return [width, height];
}
class AccentedLogo extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$R, create_fragment$X, safe_not_equal, { width: 0, height: 1 });
  }
}
function create_else_block$5(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = Logo()))
        attr(img, "src", img_src_value);
      attr(img, "alt", "ArcOS Logo");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_if_block$u(ctx) {
  let accentedlogo;
  let current;
  accentedlogo = new AccentedLogo({ props: { width: 30, height: 30 } });
  return {
    c() {
      create_component(accentedlogo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(accentedlogo, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(accentedlogo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accentedlogo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accentedlogo, detaching);
    }
  };
}
function create_fragment$W(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$u, create_else_block$5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$UserDataStore*/
      ctx2[1].sh.taskbar.accentedStart
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "class", "start-button");
      toggle_class(
        button,
        "activated",
        /*$StartMenuOpened*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggle*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
      if (!current || dirty & /*$StartMenuOpened*/
      1) {
        toggle_class(
          button,
          "activated",
          /*$StartMenuOpened*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function instance$Q($$self, $$props, $$invalidate) {
  let $StartMenuOpened;
  let $UserDataStore;
  component_subscribe($$self, StartMenuOpened, ($$value) => $$invalidate(0, $StartMenuOpened = $$value));
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(1, $UserDataStore = $$value));
  function toggle() {
    set_store_value(StartMenuOpened, $StartMenuOpened = !$StartMenuOpened, $StartMenuOpened);
  }
  return [$StartMenuOpened, $UserDataStore, toggle];
}
class StartButton extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$Q, create_fragment$W, safe_not_equal, {});
  }
}
function create_fragment$V(ctx) {
  let button;
  let t_value = (
    /*count*/
    ctx[0] ? "notifications" : "notifications_none"
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "class", "action-center material-icons-round");
      toggle_class(
        button,
        "activated",
        /*$ActionCenterOpened*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggle*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*count*/
      1 && t_value !== (t_value = /*count*/
      ctx2[0] ? "notifications" : "notifications_none"))
        set_data(t2, t_value);
      if (dirty & /*$ActionCenterOpened*/
      2) {
        toggle_class(
          button,
          "activated",
          /*$ActionCenterOpened*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$P($$self, $$props, $$invalidate) {
  let $ActionCenterOpened;
  component_subscribe($$self, ActionCenterOpened, ($$value) => $$invalidate(1, $ActionCenterOpened = $$value));
  let unsubscribe;
  let count = 0;
  function toggle() {
    set_store_value(ActionCenterOpened, $ActionCenterOpened = !$ActionCenterOpened, $ActionCenterOpened);
  }
  ProcessStack.processes.subscribe(() => {
    if (unsubscribe)
      unsubscribe();
    const notifStore = getNotificationStore();
    if (!notifStore)
      return;
    unsubscribe = notifStore.subscribe((v2) => v2 && $$invalidate(0, count = v2.size));
  });
  return [count, $ActionCenterOpened, toggle];
}
class ActionCenterButton extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$P, create_fragment$V, safe_not_equal, {});
  }
}
function create_fragment$U(ctx) {
  let div;
  let t2;
  return {
    c() {
      div = element("div");
      t2 = text(
        /*text*/
        ctx[0]
      );
      attr(div, "class", "clock");
      attr(div, "data-contextmenu", "clockcontext");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*text*/
      1)
        set_data(
          t2,
          /*text*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$O($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(1, $UserDataStore = $$value));
  let text2 = "";
  onMount(() => {
    setInterval(() => {
      const tb = $UserDataStore.sh.taskbar;
      const secs = tb.clockSecs && !tb.pos.includes("vertical") ? ":ss" : "";
      const date = tb.clockDate && !tb.pos.includes("vertical") ? "MMM D, " : "";
      const time = tb.clock12hr && !tb.pos.includes("vertical") ? `hh:mm${secs} A` : `HH:mm${secs}`;
      $$invalidate(0, text2 = dayjs().format(`${date}${time}`));
    });
  });
  return [text2];
}
let Clock$1 = class Clock2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$O, create_fragment$U, safe_not_equal, {});
  }
};
function create_if_block$t(ctx) {
  let div;
  let switch_instance;
  let div_class_value;
  let current;
  var switch_value = (
    /*trayIcon*/
    ctx[1].popup.component
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        icon: (
          /*trayIcon*/
          ctx2[1]
        ),
        openedTray: (
          /*openedTray*/
          ctx2[0]
        ),
        runtime: (
          /*trayIcon*/
          ctx2[1].popup.runtime
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "class", div_class_value = "popup shell-colored " + /*trayIcon*/
      (ctx[1].popup.className || ""));
      set_style(
        div,
        "--w",
        /*trayIcon*/
        ctx[1].popup.width + "px"
      );
      set_style(
        div,
        "--h",
        /*trayIcon*/
        ctx[1].popup.height + "px"
      );
      toggle_class(
        div,
        "colored",
        /*$UserDataStore*/
        ctx[2].sh.taskbar.colored
      );
      toggle_class(
        div,
        "visible",
        /*$openedTray*/
        ctx[3] == /*trayIcon*/
        ctx[1].identifier
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*trayIcon*/
      2 && switch_value !== (switch_value = /*trayIcon*/
      ctx2[1].popup.component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*trayIcon*/
        2)
          switch_instance_changes.icon = /*trayIcon*/
          ctx2[1];
        if (dirty & /*openedTray*/
        1)
          switch_instance_changes.openedTray = /*openedTray*/
          ctx2[0];
        if (dirty & /*trayIcon*/
        2)
          switch_instance_changes.runtime = /*trayIcon*/
          ctx2[1].popup.runtime;
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty & /*trayIcon*/
      2 && div_class_value !== (div_class_value = "popup shell-colored " + /*trayIcon*/
      (ctx2[1].popup.className || ""))) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*trayIcon*/
      2) {
        set_style(
          div,
          "--w",
          /*trayIcon*/
          ctx2[1].popup.width + "px"
        );
      }
      if (!current || dirty & /*trayIcon*/
      2) {
        set_style(
          div,
          "--h",
          /*trayIcon*/
          ctx2[1].popup.height + "px"
        );
      }
      if (!current || dirty & /*trayIcon, $UserDataStore*/
      6) {
        toggle_class(
          div,
          "colored",
          /*$UserDataStore*/
          ctx2[2].sh.taskbar.colored
        );
      }
      if (!current || dirty & /*trayIcon, $openedTray, trayIcon*/
      10) {
        toggle_class(
          div,
          "visible",
          /*$openedTray*/
          ctx2[3] == /*trayIcon*/
          ctx2[1].identifier
        );
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_fragment$T(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*trayIcon*/
    ctx[1].popup && create_if_block$t(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*trayIcon*/
        ctx2[1].popup
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*trayIcon*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$t(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$N($$self, $$props, $$invalidate) {
  let $UserDataStore;
  let $openedTray, $$unsubscribe_openedTray = noop$1, $$subscribe_openedTray = () => ($$unsubscribe_openedTray(), $$unsubscribe_openedTray = subscribe(openedTray, ($$value) => $$invalidate(3, $openedTray = $$value)), openedTray);
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(2, $UserDataStore = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_openedTray());
  let { openedTray } = $$props;
  $$subscribe_openedTray();
  let { trayIcon } = $$props;
  $$self.$$set = ($$props2) => {
    if ("openedTray" in $$props2)
      $$subscribe_openedTray($$invalidate(0, openedTray = $$props2.openedTray));
    if ("trayIcon" in $$props2)
      $$invalidate(1, trayIcon = $$props2.trayIcon);
  };
  return [openedTray, trayIcon, $UserDataStore, $openedTray];
}
class Popup extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$N, create_fragment$T, safe_not_equal, { openedTray: 0, trayIcon: 1 });
  }
}
function create_else_block$4(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*trayIcon*/
      ctx[0].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*trayIcon*/
      ctx[0].identifier);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*trayIcon*/
      1 && !src_url_equal(img.src, img_src_value = /*trayIcon*/
      ctx2[0].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*trayIcon*/
      1 && img_alt_value !== (img_alt_value = /*trayIcon*/
      ctx2[0].identifier)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_if_block$s(ctx) {
  let span;
  let t_value = (
    /*trayIcon*/
    ctx[0].icon + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "material-icons-round");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*trayIcon*/
      1 && t_value !== (t_value = /*trayIcon*/
      ctx2[0].icon + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$S(ctx) {
  let button;
  let button_title_value;
  let button_disabled_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*trayIcon*/
      ctx2[0].icon
    )
      return create_if_block$s;
    return create_else_block$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "class", "trigger");
      attr(button, "title", button_title_value = /*trayIcon*/
      ctx[0].title || "");
      button.disabled = button_disabled_value = /*trayIcon*/
      ctx[0].identifier == /*$openedTray*/
      ctx[2];
      toggle_class(
        button,
        "active",
        /*trayIcon*/
        ctx[0].identifier == /*$openedTray*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*open*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty & /*trayIcon*/
      1 && button_title_value !== (button_title_value = /*trayIcon*/
      ctx2[0].title || "")) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*trayIcon, $openedTray*/
      5 && button_disabled_value !== (button_disabled_value = /*trayIcon*/
      ctx2[0].identifier == /*$openedTray*/
      ctx2[2])) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*trayIcon, $openedTray*/
      5) {
        toggle_class(
          button,
          "active",
          /*trayIcon*/
          ctx2[0].identifier == /*$openedTray*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$M($$self, $$props, $$invalidate) {
  let $openedTray, $$unsubscribe_openedTray = noop$1, $$subscribe_openedTray = () => ($$unsubscribe_openedTray(), $$unsubscribe_openedTray = subscribe(openedTray, ($$value) => $$invalidate(2, $openedTray = $$value)), openedTray);
  $$self.$$.on_destroy.push(() => $$unsubscribe_openedTray());
  let { trayIcon } = $$props;
  let { openedTray } = $$props;
  $$subscribe_openedTray();
  function open() {
    if (trayIcon.onOpen) {
      trayIcon.onOpen(trayIcon);
    } else if (trayIcon.popup) {
      openedTray.set(trayIcon.identifier);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("trayIcon" in $$props2)
      $$invalidate(0, trayIcon = $$props2.trayIcon);
    if ("openedTray" in $$props2)
      $$subscribe_openedTray($$invalidate(1, openedTray = $$props2.openedTray));
  };
  return [trayIcon, openedTray, $openedTray, open];
}
class Trigger extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$M, create_fragment$S, safe_not_equal, { trayIcon: 0, openedTray: 1 });
  }
}
function create_fragment$R(ctx) {
  let div;
  let trigger;
  let t2;
  let popup;
  let current;
  trigger = new Trigger({
    props: {
      trayIcon: (
        /*trayIcon*/
        ctx[0]
      ),
      openedTray: (
        /*openedTray*/
        ctx[1]
      )
    }
  });
  popup = new Popup({
    props: {
      trayIcon: (
        /*trayIcon*/
        ctx[0]
      ),
      openedTray: (
        /*openedTray*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(trigger.$$.fragment);
      t2 = space();
      create_component(popup.$$.fragment);
      attr(div, "class", "icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(trigger, div, null);
      append(div, t2);
      mount_component(popup, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const trigger_changes = {};
      if (dirty & /*trayIcon*/
      1)
        trigger_changes.trayIcon = /*trayIcon*/
        ctx2[0];
      if (dirty & /*openedTray*/
      2)
        trigger_changes.openedTray = /*openedTray*/
        ctx2[1];
      trigger.$set(trigger_changes);
      const popup_changes = {};
      if (dirty & /*trayIcon*/
      1)
        popup_changes.trayIcon = /*trayIcon*/
        ctx2[0];
      if (dirty & /*openedTray*/
      2)
        popup_changes.openedTray = /*openedTray*/
        ctx2[1];
      popup.$set(popup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(trigger.$$.fragment, local);
      transition_in(popup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(trigger.$$.fragment, local);
      transition_out(popup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(trigger);
      destroy_component(popup);
    }
  };
}
function instance$L($$self, $$props, $$invalidate) {
  let { trayIcon } = $$props;
  let { openedTray } = $$props;
  $$self.$$set = ($$props2) => {
    if ("trayIcon" in $$props2)
      $$invalidate(0, trayIcon = $$props2.trayIcon);
    if ("openedTray" in $$props2)
      $$invalidate(1, openedTray = $$props2.openedTray);
  };
  return [trayIcon, openedTray];
}
class Icon extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$L, create_fragment$R, safe_not_equal, { trayIcon: 0, openedTray: 1 });
  }
}
function get_each_context$7(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2];
  return child_ctx;
}
function create_if_block$r(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "chevron_left";
      attr(button, "class", "toggle material-icons-round");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggle*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$7(ctx) {
  let icon;
  let current;
  icon = new Icon({
    props: {
      trayIcon: (
        /*trayIcon*/
        ctx[5]
      ),
      openedTray: (
        /*openedTray*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & /*icons*/
      2)
        icon_changes.trayIcon = /*trayIcon*/
        ctx2[5];
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_fragment$Q(ctx) {
  let div;
  let t2;
  let current;
  let if_block = (
    /*icons*/
    ctx[1].length > 4 && create_if_block$r(ctx)
  );
  let each_value = ensure_array_like(
    /*icons*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$7(get_each_context$7(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "tray");
      toggle_class(
        div,
        "opened",
        /*icons*/
        ctx[1].length > 3 ? (
          /*opened*/
          ctx[0]
        ) : true
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*icons*/
        ctx2[1].length > 4
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$r(ctx2);
          if_block.c();
          if_block.m(div, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*icons, openedTray*/
      6) {
        each_value = ensure_array_like(
          /*icons*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$7(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$7(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*icons, opened*/
      3) {
        toggle_class(
          div,
          "opened",
          /*icons*/
          ctx2[1].length > 3 ? (
            /*opened*/
            ctx2[0]
          ) : true
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$K($$self, $$props, $$invalidate) {
  let $TrayIconOpened;
  component_subscribe($$self, TrayIconOpened, ($$value) => $$invalidate(4, $TrayIconOpened = $$value));
  let opened = false;
  let icons = [];
  let openedTray = Store$1("");
  ActionCenterOpened.subscribe((v2) => v2 && set_store_value(TrayIconOpened, $TrayIconOpened = false, $TrayIconOpened));
  openedTray.subscribe((v2) => {
    if (!v2)
      return;
    TrayIconOpened.set(true);
  });
  TrayIconOpened.subscribe((v2) => {
    if (!v2)
      openedTray.set(null);
  });
  trayIcons.subscribe(async (v2) => {
    if (!v2)
      return;
    $$invalidate(1, icons = []);
    await sleep(0);
    $$invalidate(1, icons = v2);
  });
  function toggle() {
    $$invalidate(0, opened = !opened);
  }
  return [opened, icons, openedTray, toggle];
}
class Tray extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$K, create_fragment$Q, safe_not_equal, {});
  }
}
function create_fragment$P(ctx) {
  let div;
  let tray2;
  let t0;
  let clock;
  let t1;
  let actioncenterbutton;
  let current;
  tray2 = new Tray({});
  clock = new Clock$1({});
  actioncenterbutton = new ActionCenterButton({});
  return {
    c() {
      div = element("div");
      create_component(tray2.$$.fragment);
      t0 = space();
      create_component(clock.$$.fragment);
      t1 = space();
      create_component(actioncenterbutton.$$.fragment);
      attr(div, "class", "system-area");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(tray2, div, null);
      append(div, t0);
      mount_component(clock, div, null);
      append(div, t1);
      mount_component(actioncenterbutton, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(tray2.$$.fragment, local);
      transition_in(clock.$$.fragment, local);
      transition_in(actioncenterbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tray2.$$.fragment, local);
      transition_out(clock.$$.fragment, local);
      transition_out(actioncenterbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(tray2);
      destroy_component(clock);
      destroy_component(actioncenterbutton);
    }
  };
}
class SystemArea extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$P, safe_not_equal, {});
  }
}
function create_fragment$O(ctx) {
  let div;
  let startbutton;
  let t0;
  let openedapps;
  let t1;
  let systemarea;
  let current;
  startbutton = new StartButton({});
  openedapps = new OpenedApps({});
  systemarea = new SystemArea({});
  return {
    c() {
      div = element("div");
      create_component(startbutton.$$.fragment);
      t0 = space();
      create_component(openedapps.$$.fragment);
      t1 = space();
      create_component(systemarea.$$.fragment);
      attr(div, "class", "taskbar shell-colored");
      attr(div, "data-contextmenu", "shell-taskbar");
      toggle_class(
        div,
        "vertical",
        /*vertical*/
        ctx[0]
      );
      toggle_class(
        div,
        "colored",
        /*$UserDataStore*/
        ctx[1].sh.taskbar.colored
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(startbutton, div, null);
      append(div, t0);
      mount_component(openedapps, div, null);
      append(div, t1);
      mount_component(systemarea, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*vertical*/
      1) {
        toggle_class(
          div,
          "vertical",
          /*vertical*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$UserDataStore*/
      2) {
        toggle_class(
          div,
          "colored",
          /*$UserDataStore*/
          ctx2[1].sh.taskbar.colored
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(startbutton.$$.fragment, local);
      transition_in(openedapps.$$.fragment, local);
      transition_in(systemarea.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(startbutton.$$.fragment, local);
      transition_out(openedapps.$$.fragment, local);
      transition_out(systemarea.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(startbutton);
      destroy_component(openedapps);
      destroy_component(systemarea);
    }
  };
}
function instance$J($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(1, $UserDataStore = $$value));
  let { vertical = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("vertical" in $$props2)
      $$invalidate(0, vertical = $$props2.vertical);
  };
  return [vertical, $UserDataStore];
}
class Taskbar extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$J, create_fragment$O, safe_not_equal, { vertical: 0 });
  }
}
function create_if_block$q(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let br;
  let t6;
  let t7;
  let t8;
  let t9_value = (
    /*$ConnectedServer*/
    ctx[2].host + ""
  );
  let t9;
  let t10;
  let t11_value = (
    /*$ConnectedServer*/
    ctx[2].port + ""
  );
  let t11;
  let t12;
  let t13_value = (
    /*$ConnectedServer*/
    ctx[2].secure ? "Secure" : "Open"
  );
  let t13;
  let t14;
  let if_block = (
    /*$SafeMode*/
    ctx[0] && create_if_block_1$2()
  );
  return {
    c() {
      div = element("div");
      t0 = text("ArcOS v");
      t1 = text(ArcOSVersion);
      t2 = text("-");
      t3 = text(ARCOS_MODE);
      t4 = space();
      t5 = text(ARCOS_BUILD);
      br = element("br");
      t6 = space();
      t7 = text(
        /*$UserName*/
        ctx[1]
      );
      t8 = text("@");
      t9 = text(t9_value);
      t10 = text(":");
      t11 = text(t11_value);
      t12 = text(" (");
      t13 = text(t13_value);
      t14 = text(")\n    ");
      if (if_block)
        if_block.c();
      attr(div, "class", "desktop-watermark");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, t2);
      append(div, t3);
      append(div, t4);
      append(div, t5);
      append(div, br);
      append(div, t6);
      append(div, t7);
      append(div, t8);
      append(div, t9);
      append(div, t10);
      append(div, t11);
      append(div, t12);
      append(div, t13);
      append(div, t14);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserName*/
      2)
        set_data(
          t7,
          /*$UserName*/
          ctx2[1]
        );
      if (dirty & /*$ConnectedServer*/
      4 && t9_value !== (t9_value = /*$ConnectedServer*/
      ctx2[2].host + ""))
        set_data(t9, t9_value);
      if (dirty & /*$ConnectedServer*/
      4 && t11_value !== (t11_value = /*$ConnectedServer*/
      ctx2[2].port + ""))
        set_data(t11, t11_value);
      if (dirty & /*$ConnectedServer*/
      4 && t13_value !== (t13_value = /*$ConnectedServer*/
      ctx2[2].secure ? "Secure" : "Open"))
        set_data(t13, t13_value);
      if (
        /*$SafeMode*/
        ctx2[0]
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_1$2();
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$2(ctx) {
  let br;
  let t2;
  return {
    c() {
      br = element("br");
      t2 = text("Safe Mode Enabled");
    },
    m(target, anchor) {
      insert(target, br, anchor);
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(br);
        detach(t2);
      }
    }
  };
}
function create_fragment$N(ctx) {
  let if_block_anchor;
  let if_block = (ARCOS_MODE !== "release" || /*$SafeMode*/
  ctx[0]) && create_if_block$q(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (ARCOS_MODE !== "release" || /*$SafeMode*/
      ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$q(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$I($$self, $$props, $$invalidate) {
  let $SafeMode;
  let $UserName;
  let $ConnectedServer;
  component_subscribe($$self, SafeMode, ($$value) => $$invalidate(0, $SafeMode = $$value));
  component_subscribe($$self, UserName, ($$value) => $$invalidate(1, $UserName = $$value));
  component_subscribe($$self, ConnectedServer, ($$value) => $$invalidate(2, $ConnectedServer = $$value));
  return [$SafeMode, $UserName, $ConnectedServer];
}
class Watermark extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$I, create_fragment$N, safe_not_equal, {});
  }
}
const main$5 = "";
const ShellAccelerators = (process) => [
  {
    action(proc) {
      ShellProcessManager(proc);
    },
    shift: false,
    alt: true,
    key: "x",
    global: true
  },
  {
    action(proc) {
      ShellArcFind(proc);
    },
    shift: true,
    alt: false,
    ctrl: true,
    key: "f",
    global: true
  },
  {
    action(proc) {
      ShellKeyboardShortcuts(proc);
    },
    ctrl: true,
    key: "/",
    global: true
  },
  {
    alt: true,
    key: "q",
    global: true,
    async action() {
      const pid = focusedPid.get();
      if (!pid)
        return;
      const proc = process.handler.getProcess(pid);
      if (!proc)
        return;
      const parentPid = proc.parentPid;
      if (proc.app && (proc.app.metadata.core || proc.app.metadata.noCloseAccelerator))
        return;
      process.handler.kill(pid, true);
      await sleep();
      if (parentPid)
        focusedPid.set(parentPid);
    }
  },
  {
    alt: true,
    key: "n",
    global: true,
    action() {
      ActionCenterOpened.set(!ActionCenterOpened.get());
    }
  },
  {
    alt: true,
    shift: false,
    key: "z",
    global: true,
    action() {
      StartMenuOpened.set(true);
    }
  },
  {
    key: "escape",
    global: true,
    action() {
      closeContextMenu();
    }
  },
  {
    key: "d",
    global: true,
    alt: true,
    action() {
      GlobalDispatch.dispatch("minimize-all");
    }
  },
  {
    key: "t",
    alt: true,
    action() {
      spawnApp("ArcTerm");
    },
    global: true
  }
];
class ShellRuntime extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    process.accelerator.store.push(...ShellAccelerators(process));
  }
}
function create_if_block$p(ctx) {
  let shade;
  let t0;
  let div2;
  let div0;
  let startmenu2;
  let t1;
  let watermark;
  let t2;
  let pushnotification;
  let t3;
  let actioncenter;
  let t4;
  let div1;
  let taskbar;
  let div2_class_value;
  let current;
  shade = new Shade({});
  startmenu2 = new StartMenu({});
  watermark = new Watermark({});
  pushnotification = new PushNotification({});
  actioncenter = new ActionCenter({});
  taskbar = new Taskbar({
    props: {
      vertical: (
        /*$uds*/
        ctx[1].sh.taskbar.pos.includes("vertical")
      )
    }
  });
  return {
    c() {
      create_component(shade.$$.fragment);
      t0 = space();
      div2 = element("div");
      div0 = element("div");
      create_component(startmenu2.$$.fragment);
      t1 = space();
      create_component(watermark.$$.fragment);
      t2 = space();
      create_component(pushnotification.$$.fragment);
      t3 = space();
      create_component(actioncenter.$$.fragment);
      t4 = space();
      div1 = element("div");
      create_component(taskbar.$$.fragment);
      attr(div0, "class", "primary");
      attr(div1, "class", "secondary");
      attr(div2, "class", div2_class_value = "shell taskbar-bounds tb-" + /*$uds*/
      ctx[1].sh.taskbar.pos + " fullscreen");
      toggle_class(
        div2,
        "vertical",
        /*$uds*/
        ctx[1].sh.taskbar.pos.includes("vertical")
      );
      toggle_class(
        div2,
        "docked",
        /*$uds*/
        ctx[1].sh.taskbar.docked
      );
    },
    m(target, anchor) {
      mount_component(shade, target, anchor);
      insert(target, t0, anchor);
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(startmenu2, div0, null);
      append(div0, t1);
      mount_component(watermark, div0, null);
      append(div0, t2);
      mount_component(pushnotification, div0, null);
      append(div0, t3);
      mount_component(actioncenter, div0, null);
      append(div2, t4);
      append(div2, div1);
      mount_component(taskbar, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const taskbar_changes = {};
      if (dirty & /*$uds*/
      2)
        taskbar_changes.vertical = /*$uds*/
        ctx2[1].sh.taskbar.pos.includes("vertical");
      taskbar.$set(taskbar_changes);
      if (!current || dirty & /*$uds*/
      2 && div2_class_value !== (div2_class_value = "shell taskbar-bounds tb-" + /*$uds*/
      ctx2[1].sh.taskbar.pos + " fullscreen")) {
        attr(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*$uds, $uds*/
      2) {
        toggle_class(
          div2,
          "vertical",
          /*$uds*/
          ctx2[1].sh.taskbar.pos.includes("vertical")
        );
      }
      if (!current || dirty & /*$uds, $uds*/
      2) {
        toggle_class(
          div2,
          "docked",
          /*$uds*/
          ctx2[1].sh.taskbar.docked
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(shade.$$.fragment, local);
      transition_in(startmenu2.$$.fragment, local);
      transition_in(watermark.$$.fragment, local);
      transition_in(pushnotification.$$.fragment, local);
      transition_in(actioncenter.$$.fragment, local);
      transition_in(taskbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(shade.$$.fragment, local);
      transition_out(startmenu2.$$.fragment, local);
      transition_out(watermark.$$.fragment, local);
      transition_out(pushnotification.$$.fragment, local);
      transition_out(actioncenter.$$.fragment, local);
      transition_out(taskbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div2);
      }
      destroy_component(shade, detaching);
      destroy_component(startmenu2);
      destroy_component(watermark);
      destroy_component(pushnotification);
      destroy_component(actioncenter);
      destroy_component(taskbar);
    }
  };
}
function create_fragment$M(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$uds*/
    ctx[1] && /*render*/
    ctx[0] && create_if_block$p(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$uds*/
        ctx2[1] && /*render*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$uds, render*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$p(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$H($$self, $$props, $$invalidate) {
  let $uds;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(1, $uds = $$value));
  let { runtime } = $$props;
  let render = false;
  onMount(async () => {
    const args = runtime.process.args;
    if (args.length > 0 && args[0] === true)
      await StartCoreProcesses(true);
    $$invalidate(0, render = true);
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [render, $uds, runtime];
}
let App$3 = class App28 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$H, create_fragment$M, safe_not_equal, { runtime: 2 });
  }
};
const ShellContext = {
  clockcontext: [
    {
      caption: "Show Seconds",
      action: () => {
        UserDataStore.update((udata) => {
          udata.sh.taskbar.clockSecs = !udata.sh.taskbar.clockSecs;
          return udata;
        });
      },
      isActive: () => UserDataStore.get().sh.taskbar.clockSecs,
      icon: "av_timer"
    },
    {
      caption: "Show Date",
      action: () => {
        UserDataStore.update((udata) => {
          udata.sh.taskbar.clockDate = !udata.sh.taskbar.clockDate;
          return udata;
        });
      },
      isActive: () => UserDataStore.get().sh.taskbar.clockDate,
      icon: "calendar_month"
    },
    {
      caption: "12-hour clock",
      action: () => {
        UserDataStore.update((udata) => {
          udata.sh.taskbar.clock12hr = !udata.sh.taskbar.clock12hr;
          return udata;
        });
      },
      isActive: () => UserDataStore.get().sh.taskbar.clock12hr
    },
    SEP_ITEM,
    {
      image: ProcessManagerIcon,
      caption: "Processes",
      action: () => {
        spawnApp("ProcessManager");
      }
    },
    SEP_ITEM,
    {
      icon: "settings",
      caption: "Shell settings",
      action: () => {
        OpenSettingsPage("shell");
      }
    }
  ],
  "shell-taskbar": [
    {
      image: ProcessManagerIcon,
      caption: "Processes",
      action: () => {
        spawnApp("ProcessManager");
      }
    },
    SEP_ITEM,
    {
      icon: "settings",
      caption: "Shell settings",
      action: () => {
        OpenSettingsPage("shell");
      }
    }
  ],
  "startmenu-applist": [
    {
      image: AppsIcon,
      caption: "Group apps",
      isActive: () => !UserDataStore.get().sh.start.noGroups,
      action() {
        UserDataStore.update((udata) => {
          udata.sh.start.noGroups = !udata.sh.start.noGroups;
          return udata;
        });
      }
    }
  ],
  "opened-app": [
    {
      caption: "Launch Another",
      icon: "launch",
      action(_2, data2) {
        spawnApp(data2.id);
      }
    },
    SEP_ITEM,
    {
      caption: "App Info",
      icon: "info_outline",
      action(_2, data2) {
        spawnApp("AppInfo", 0, [data2.id]);
      }
    },
    {
      caption: "Close",
      image: ShutdownIcon,
      action(_2, data2) {
        ProcessStack.kill(+data2.pid, true);
      }
    }
  ]
};
const ArcShell = {
  metadata: {
    name: "ArcOS",
    description: "The ArcOS Shell",
    author: "The ArcOS Team",
    version: ArcOSVersion,
    appGroup: "coreApps",
    icon: Logo(),
    core: true,
    hidden: true
  },
  runtime: ShellRuntime,
  content: App$3,
  id: "ArcShell",
  size: { w: 0, h: 0 },
  minSize: { w: 0, h: 0 },
  maxSize: { w: 0, h: 0 },
  pos: { x: 0, y: 0 },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: {
    minimize: false,
    maximize: false,
    close: false
  },
  singleInstance: true,
  contextMenu: ShellContext,
  loadCondition: () => !!UserDataStore.get(),
  acceleratorDescriptions: {
    "ctrl+/": "Display the shortcuts overview",
    "ctrl+shift+f": "Open ArcFind",
    "alt+x": "Open the Process Manager overlay",
    "alt+q": "Close the focused application",
    "alt+n": "Toggle the notification center",
    "alt+z": "Toggle the Start menu",
    "alt+d": "Show the desktop",
    "alt+t": "Open a new ArcTerm window"
  }
};
const TextEditorAccelerators = (runtime) => {
  return [
    {
      key: "o",
      alt: true,
      shift: true,
      action() {
        runtime.openFileLocation();
      }
    },
    {
      key: "o",
      alt: true,
      action() {
        runtime.openFile();
      }
    },
    {
      key: "s",
      alt: true,
      action() {
        runtime.save();
      }
    },
    {
      key: "s",
      alt: true,
      shift: true,
      action() {
        runtime.saveAs();
      }
    },
    {
      key: "f3",
      action() {
        runtime.SearchReplaceDialog();
      }
    }
  ];
};
function EditMenu(runtime) {
  return {
    caption: "Edit",
    subItems: [
      {
        caption: "Select All",
        icon: "select_all",
        action() {
          runtime.selectAll();
        },
        accelerator: "Ctrl+A"
      },
      SEP_ITEM,
      {
        caption: "Search & Replace...",
        icon: "find_replace",
        action() {
          runtime.SearchReplaceDialog();
        },
        accelerator: "F3",
        disabled: () => runtime.isClient.get()
      }
    ]
  };
}
function FileMenu(runtime) {
  return {
    caption: "File",
    subItems: [
      {
        caption: "Open...",
        action: () => runtime.openFile(),
        icon: "file_open",
        accelerator: "Alt+O"
      },
      SEP_ITEM,
      {
        caption: "Save",
        image: SaveIcon,
        action: async () => {
          await runtime.save();
        },
        disabled: () => !runtime.path.get() || !runtime.buffer.get() || runtime.isClient.get(),
        accelerator: "Alt+S"
      },
      {
        caption: "Save As...",
        disabled: () => !runtime.buffer.get(),
        action: async () => await runtime.saveAs(),
        accelerator: "Alt+Shift+S"
      },
      SEP_ITEM,
      {
        caption: "Open file location",
        icon: "folder_open",
        action: () => {
          runtime.openFileLocation();
        },
        disabled: () => !runtime.path.get() || runtime.isClient.get(),
        accelerator: "Alt+Shift+O"
      },
      SEP_ITEM,
      {
        caption: "Exit",
        action: () => {
          runtime.process.handler.kill(runtime.pid, true);
        },
        accelerator: "Alt+Q"
      }
    ]
  };
}
function OpenMenu(runtime) {
  return {
    caption: "Open",
    subItems: [
      {
        caption: `Open file in...`,
        disabled: () => !runtime.path.get() || runtime.isClient.get(),
        image: AppsIcon,
        async action() {
          const path = runtime.path.get();
          const partial = await getPartialFile(path);
          OpenWith(partial, runtime.pid, true);
        }
      },
      {
        caption: "Open as Markdown",
        disabled: () => !runtime.path.get() || !runtime.path.get().endsWith(".md") || runtime.isClient.get(),
        image: MarkdownMimeIcon,
        async action() {
          const path = runtime.path.get();
          const partial = await getPartialFile(path);
          await openFileWithApp("MarkDownViewer", partial);
        }
      }
    ]
  };
}
function ViewMenu(runtime) {
  return {
    caption: "View",
    subItems: [
      {
        icon: "abc",
        caption: "Fixed-width font",
        action: () => {
          runtime.monospace.set(!runtime.monospace.get());
        },
        isActive: () => runtime.monospace.get()
      },
      {
        icon: "wrap_text",
        caption: "Word Wrap",
        action: () => {
          runtime.wordWrap.set(!runtime.wordWrap.get());
        },
        isActive: () => runtime.wordWrap.get()
      },
      SEP_ITEM,
      {
        icon: "spellcheck",
        caption: "Error Checking",
        action: () => {
          runtime.spellcheck.set(!runtime.spellcheck.get());
        },
        isActive: () => runtime.spellcheck.get()
      },
      SEP_ITEM,
      {
        caption: "Status bar",
        action: () => {
          runtime.statusBar.set(!runtime.statusBar.get());
        },
        isActive: () => runtime.statusBar.get(),
        disabled: () => !runtime.File.get()
      },
      SEP_ITEM,
      {
        caption: "Show Markdown preview",
        action: () => {
          runtime.markdownPreview.set(!runtime.markdownPreview.get());
        },
        isActive: () => runtime.markdownPreview.get(),
        image: MarkdownMimeIcon,
        disabled: () => {
          const path = runtime.path.get();
          return path ? !path.endsWith(".md") : true;
        }
      }
    ]
  };
}
const TextEditorAltMenu = (runtime) => [
  FileMenu(runtime),
  EditMenu(runtime),
  ViewMenu(runtime),
  OpenMenu(runtime)
];
const SearchReplace_svelte_svelte_type_style_lang = "";
function create_fragment$L(ctx) {
  let div2;
  let div0;
  let span0;
  let t1;
  let input0;
  let t2;
  let div1;
  let span1;
  let t4;
  let input1;
  let t5;
  let div3;
  let button0;
  let t7;
  let button1;
  let t8;
  let button1_disabled_value;
  let t9;
  let button2;
  let t10;
  let button2_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      span0 = element("span");
      span0.textContent = "Search:";
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      span1 = element("span");
      span1.textContent = "Replace With:";
      t4 = space();
      input1 = element("input");
      t5 = space();
      div3 = element("div");
      button0 = element("button");
      button0.textContent = "Close";
      t7 = space();
      button1 = element("button");
      t8 = text("Once");
      t9 = space();
      button2 = element("button");
      t10 = text("All");
      attr(span0, "class", "svelte-hofi4c");
      attr(input0, "type", "text");
      attr(input0, "placeholder", "Windows");
      attr(input0, "class", "svelte-hofi4c");
      attr(div0, "class", "row svelte-hofi4c");
      attr(span1, "class", "svelte-hofi4c");
      attr(input1, "type", "text");
      attr(input1, "placeholder", "ArcOS");
      attr(input1, "class", "svelte-hofi4c");
      attr(div1, "class", "row svelte-hofi4c");
      attr(div2, "class", "top svelte-hofi4c");
      attr(button0, "class", "close svelte-hofi4c");
      button1.disabled = button1_disabled_value = !/*search*/
      ctx[0] || !/*replace*/
      ctx[1];
      attr(button1, "class", "svelte-hofi4c");
      button2.disabled = button2_disabled_value = !/*search*/
      ctx[0] || !/*replace*/
      ctx[1];
      attr(button2, "class", "suggested svelte-hofi4c");
      attr(div3, "class", "bottom svelte-hofi4c");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, span0);
      append(div0, t1);
      append(div0, input0);
      set_input_value(
        input0,
        /*search*/
        ctx[0]
      );
      append(div2, t2);
      append(div2, div1);
      append(div1, span1);
      append(div1, t4);
      append(div1, input1);
      set_input_value(
        input1,
        /*replace*/
        ctx[1]
      );
      insert(target, t5, anchor);
      insert(target, div3, anchor);
      append(div3, button0);
      append(div3, t7);
      append(div3, button1);
      append(button1, t8);
      append(div3, t9);
      append(div3, button2);
      append(button2, t10);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[6]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[7]
          ),
          listen(
            button0,
            "click",
            /*close*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*once*/
            ctx[2]
          ),
          listen(
            button2,
            "click",
            /*all*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*search*/
      1 && input0.value !== /*search*/
      ctx2[0]) {
        set_input_value(
          input0,
          /*search*/
          ctx2[0]
        );
      }
      if (dirty & /*replace*/
      2 && input1.value !== /*replace*/
      ctx2[1]) {
        set_input_value(
          input1,
          /*replace*/
          ctx2[1]
        );
      }
      if (dirty & /*search, replace*/
      3 && button1_disabled_value !== (button1_disabled_value = !/*search*/
      ctx2[0] || !/*replace*/
      ctx2[1])) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*search, replace*/
      3 && button2_disabled_value !== (button2_disabled_value = !/*search*/
      ctx2[0] || !/*replace*/
      ctx2[1])) {
        button2.disabled = button2_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t5);
        detach(div3);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$G($$self, $$props, $$invalidate) {
  let search2 = "";
  let replace = "";
  let { runtime } = $$props;
  const pid = runtime.process.parentPid;
  function once() {
    ProcessStack.dispatch.dispatchToPid(pid, "replace-one", [search2, replace]);
  }
  function all3() {
    ProcessStack.dispatch.dispatchToPid(pid, "replace-all", [search2, replace]);
  }
  function close() {
    runtime.closeApp();
  }
  function input0_input_handler() {
    search2 = this.value;
    $$invalidate(0, search2);
  }
  function input1_input_handler() {
    replace = this.value;
    $$invalidate(1, replace);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
  };
  return [
    search2,
    replace,
    once,
    all3,
    close,
    runtime,
    input0_input_handler,
    input1_input_handler
  ];
}
let SearchReplace$1 = class SearchReplace extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$G, create_fragment$L, safe_not_equal, { runtime: 5 });
  }
};
const SearchReplace2 = {
  metadata: {
    name: "Search & Replace",
    description: "Replace text in the file",
    author: "The ArcOS Team",
    version: "1.0.0",
    icon: ComponentIcon
  },
  runtime: AppRuntime,
  content: SearchReplace$1,
  id: "SearchReplace",
  size: { w: 360, h: 186 },
  minSize: { w: 360, h: 186 },
  maxSize: { w: 360, h: 186 },
  pos: { x: 0, y: 0 },
  state: {
    maximized: false,
    minimized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  controls: {
    minimize: false,
    maximize: false,
    close: false
  }
};
function TextEditorDispatchers(runtime) {
  return {
    "replace-one": (data2) => {
      runtime.replaceOnce(data2[0], data2[1]);
    },
    "replace-all": (data2) => {
      runtime.replaceAll(data2[0], data2[1]);
    }
  };
}
class Runtime23 extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
    __publicField(this, "File", Store$1());
    __publicField(this, "buffer", Store$1());
    __publicField(this, "path", Store$1());
    __publicField(this, "wordWrap", Store$1(true));
    __publicField(this, "monospace", Store$1(true));
    __publicField(this, "spellcheck", Store$1(false));
    __publicField(this, "isClient", Store$1(false));
    __publicField(this, "markdownPreview", Store$1(false));
    __publicField(this, "statusBar", Store$1(true));
    __publicField(this, "input");
    this.openedFile.subscribe(async (v2) => {
      if (!v2)
        return;
      await this.readFile(v2);
    });
    if (process.args.length && typeof process.args[0] === "string") {
      this.handleOpenFile(process.args[0]);
    }
    this.loadAltMenu(...TextEditorAltMenu(this));
    this.process.accelerator.store.push(...TextEditorAccelerators(this));
    this.assignDispatchers();
  }
  setTextarea(input) {
    if (!input)
      return;
    this.input = input;
  }
  async readFile(v2) {
    this.path.set(v2);
    const { setDone, setErrors } = await this.LoadProgress(v2);
    const file = await readFile(v2);
    if (!file) {
      setErrors(1);
      setDone(1);
      return;
    }
    const content = await file.data.text();
    this.buffer.set("");
    await sleep(10);
    this.buffer.set(content);
    this.isClient.set(v2.startsWith("@client"));
    this.File.set(file);
    this.setWindowTitle(`Editing ${file.name}` + (this.isClient.get() ? " (Read-only)" : ""));
    this.setWindowIcon(getMimeIcon(file.name));
    setDone(1);
  }
  async save() {
    if (this.isClient.get() || !this.path.get())
      return;
    const content = this.buffer.get();
    const path = this.path.get();
    const file = this.File.get();
    const { setDone } = await this.SaveProgress(path);
    const written = await writeFile(path, textToBlob(content, file ? file.mime : null));
    setDone(1);
    return !!written;
  }
  async saveAs() {
    const path = await GetSaveFilePath(this.pid, {
      title: "Select location to save file",
      icon: SaveIcon,
      startDir: getParentDirectory(this.path.get() || "./")
    });
    if (!path)
      return;
    this.path.set(path);
    await this.save();
    this.openedFile.set(path);
  }
  openFile() {
    spawnOverlay(getAppById("LoadSaveDialog"), this.pid, [
      {
        title: "Select any file to open",
        icon: TextEditorIcon,
        startDir: getParentDirectory(this.path.get() || "./")
      }
    ]);
  }
  openFileLocation() {
    const path = this.path.get();
    if (!path || this.isClient.get())
      return;
    const split = path.split("/");
    const filename = split[split.length - 1];
    spawnApp("FileManager", 0, [path.replace(filename, "") || ".", path]);
  }
  selectAll() {
    if (!this.input)
      return;
    this.input.select();
  }
  replaceOnce(text2, replacer) {
    const buffer = this.buffer.get();
    this.buffer.set(buffer.replace(text2, replacer));
  }
  async replaceAll(text2, replacer) {
    const occurences = CountInstances(this.buffer.get(), text2) + 1;
    for (let i2 = 0; i2 < occurences; i2++) {
      this.buffer.set(this.buffer.get().replace(text2, replacer));
      await sleep(10);
    }
  }
  assignDispatchers() {
    const dispatchers = TextEditorDispatchers(this);
    for (const event in dispatchers) {
      const dispatcher = dispatchers[event];
      this.process.handler.dispatch.subscribe(this.pid, event, dispatcher);
    }
  }
  SearchReplaceDialog(args = []) {
    if (this.isClient.get())
      return;
    spawnOverlay(SearchReplace2, this.process.pid, args);
  }
  async LoadProgress(v2 = this.path.get()) {
    return await FileProgress(
      {
        caption: "Reading File",
        subtitle: `Home/${pathToFriendlyPath(v2)}`,
        icon: TextEditorIcon,
        max: 1,
        done: 0,
        type: "quantity",
        waiting: false,
        working: true,
        errors: 0
      },
      this.pid,
      false
    );
  }
  async SaveProgress(v2 = this.path.get()) {
    const filename = pathToFriendlyName(v2);
    return await FileProgress(
      {
        caption: `Saving ${filename}`,
        subtitle: `Home/${pathToFriendlyPath(v2)}`,
        icon: SaveIcon,
        max: 1,
        done: 0,
        type: "quantity",
        waiting: false,
        working: true,
        errors: 0
      },
      this.pid,
      false
    );
  }
}
function create_default_slot$8(ctx) {
  let markdownrenderer;
  let current;
  markdownrenderer = new MarkdownRenderer({ props: { content: (
    /*content*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(markdownrenderer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(markdownrenderer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const markdownrenderer_changes = {};
      if (dirty & /*content*/
      1)
        markdownrenderer_changes.content = /*content*/
        ctx2[0];
      markdownrenderer.$set(markdownrenderer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(markdownrenderer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(markdownrenderer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(markdownrenderer, detaching);
    }
  };
}
function create_fragment$K(ctx) {
  let pane;
  let current;
  pane = new Pane({
    props: {
      minSize: 25,
      $$slots: { default: [create_default_slot$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(pane.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pane, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const pane_changes = {};
      if (dirty & /*$$scope, content*/
      17) {
        pane_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pane.$set(pane_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pane.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pane.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pane, detaching);
    }
  };
}
function instance$F($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  const { buffer } = runtime;
  let timeout;
  let content = "";
  buffer.subscribe(async (v2) => {
    clearTimeout(timeout);
    timeout = setTimeout(
      async () => {
        $$invalidate(0, content = "");
        await sleep(0);
        $$invalidate(0, content = v2);
      },
      500
    );
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [content, runtime];
}
class Markdown extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$F, create_fragment$K, safe_not_equal, { runtime: 1 });
  }
}
const main$4 = "";
function create_if_block$o(ctx) {
  let div4;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1_value = (
    /*$File*/
    ctx[2].name + ""
  );
  let t1;
  let t2;
  let div1;
  let t3_value = formatBytes(
    /*$buffer*/
    ctx[3].length
  ) + "";
  let t3;
  let t4;
  let div2;
  let t5_value = (
    /*$File*/
    ctx[2].mime + ""
  );
  let t5;
  let t6;
  let div3;
  let t7;
  let t8_value = pathToFriendlyPath(getParentDirectory(
    /*$File*/
    ctx[2].path
  )) + "";
  let t8;
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      div1 = element("div");
      t3 = text(t3_value);
      t4 = space();
      div2 = element("div");
      t5 = text(t5_value);
      t6 = space();
      div3 = element("div");
      t7 = text("In ");
      t8 = text(t8_value);
      if (!src_url_equal(img.src, img_src_value = getMimeIcon(
        /*$File*/
        ctx[2].name
      )))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(div0, "class", "segment file");
      attr(div1, "class", "segment right");
      attr(div2, "class", "segment");
      attr(div3, "class", "segment");
      attr(div4, "class", "statusbar");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div0, img);
      append(div0, t0);
      append(div0, span);
      append(span, t1);
      append(div4, t2);
      append(div4, div1);
      append(div1, t3);
      append(div4, t4);
      append(div4, div2);
      append(div2, t5);
      append(div4, t6);
      append(div4, div3);
      append(div3, t7);
      append(div3, t8);
    },
    p(ctx2, dirty) {
      if (dirty & /*$File*/
      4 && !src_url_equal(img.src, img_src_value = getMimeIcon(
        /*$File*/
        ctx2[2].name
      ))) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*$File*/
      4 && t1_value !== (t1_value = /*$File*/
      ctx2[2].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*$buffer*/
      8 && t3_value !== (t3_value = formatBytes(
        /*$buffer*/
        ctx2[3].length
      ) + ""))
        set_data(t3, t3_value);
      if (dirty & /*$File*/
      4 && t5_value !== (t5_value = /*$File*/
      ctx2[2].mime + ""))
        set_data(t5, t5_value);
      if (dirty & /*$File*/
      4 && t8_value !== (t8_value = pathToFriendlyPath(getParentDirectory(
        /*$File*/
        ctx2[2].path
      )) + ""))
        set_data(t8, t8_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
    }
  };
}
function create_fragment$J(ctx) {
  let if_block_anchor;
  let if_block = (
    /*$statusBar*/
    ctx[0] && /*$path*/
    ctx[1] && /*$File*/
    ctx[2] && /*$buffer*/
    ctx[3] && create_if_block$o(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*$statusBar*/
        ctx2[0] && /*$path*/
        ctx2[1] && /*$File*/
        ctx2[2] && /*$buffer*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$o(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$E($$self, $$props, $$invalidate) {
  let $statusBar;
  let $path;
  let $File;
  let $buffer;
  let { runtime } = $$props;
  const { statusBar, path, File, buffer } = runtime;
  component_subscribe($$self, statusBar, (value) => $$invalidate(0, $statusBar = value));
  component_subscribe($$self, path, (value) => $$invalidate(1, $path = value));
  component_subscribe($$self, File, (value) => $$invalidate(2, $File = value));
  component_subscribe($$self, buffer, (value) => $$invalidate(3, $buffer = value));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(8, runtime = $$props2.runtime);
  };
  return [$statusBar, $path, $File, $buffer, statusBar, path, File, buffer, runtime];
}
class Statusbar2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$E, create_fragment$J, safe_not_equal, { runtime: 8 });
  }
}
function create_default_slot_1$6(ctx) {
  let textarea;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(
        textarea,
        "spellcheck",
        /*$spellcheck*/
        ctx[5]
      );
      textarea.readOnly = /*$isClient*/
      ctx[6];
      attr(textarea, "wrap", "soft");
      toggle_class(textarea, "nowrap", !/*$wordWrap*/
      ctx[3]);
      toggle_class(
        textarea,
        "monospace",
        /*$monospace*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      set_input_value(
        textarea,
        /*$buffer*/
        ctx[7]
      );
      ctx[15](textarea);
      if (!mounted) {
        dispose = listen(
          textarea,
          "input",
          /*textarea_input_handler*/
          ctx[14]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$spellcheck*/
      32) {
        attr(
          textarea,
          "spellcheck",
          /*$spellcheck*/
          ctx2[5]
        );
      }
      if (dirty & /*$isClient*/
      64) {
        textarea.readOnly = /*$isClient*/
        ctx2[6];
      }
      if (dirty & /*$buffer*/
      128) {
        set_input_value(
          textarea,
          /*$buffer*/
          ctx2[7]
        );
      }
      if (dirty & /*$wordWrap*/
      8) {
        toggle_class(textarea, "nowrap", !/*$wordWrap*/
        ctx2[3]);
      }
      if (dirty & /*$monospace*/
      16) {
        toggle_class(
          textarea,
          "monospace",
          /*$monospace*/
          ctx2[4]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(textarea);
      }
      ctx[15](null);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$n(ctx) {
  let markdown;
  let current;
  markdown = new Markdown({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(markdown.$$.fragment);
    },
    m(target, anchor) {
      mount_component(markdown, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const markdown_changes = {};
      if (dirty & /*runtime*/
      1)
        markdown_changes.runtime = /*runtime*/
        ctx2[0];
      markdown.$set(markdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(markdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(markdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(markdown, detaching);
    }
  };
}
function create_default_slot$7(ctx) {
  let pane;
  let t2;
  let if_block_anchor;
  let current;
  pane = new Pane({
    props: {
      minSize: (
        /*$markdownPreview*/
        ctx[2] ? 25 : 100
      ),
      $$slots: { default: [create_default_slot_1$6] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*$markdownPreview*/
    ctx[2] && create_if_block$n(ctx)
  );
  return {
    c() {
      create_component(pane.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(pane, target, anchor);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pane_changes = {};
      if (dirty & /*$markdownPreview*/
      4)
        pane_changes.minSize = /*$markdownPreview*/
        ctx2[2] ? 25 : 100;
      if (dirty & /*$$scope, $spellcheck, $isClient, $buffer, input, $wordWrap, $monospace*/
      524538) {
        pane_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pane.$set(pane_changes);
      if (
        /*$markdownPreview*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$markdownPreview*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$n(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(pane.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(pane.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(pane, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$I(ctx) {
  let splitpanes;
  let t2;
  let statusbar;
  let current;
  splitpanes = new Splitpanes({
    props: {
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx }
    }
  });
  statusbar = new Statusbar2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(splitpanes.$$.fragment);
      t2 = space();
      create_component(statusbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(splitpanes, target, anchor);
      insert(target, t2, anchor);
      mount_component(statusbar, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const splitpanes_changes = {};
      if (dirty & /*$$scope, runtime, $markdownPreview, $spellcheck, $isClient, $buffer, input, $wordWrap, $monospace*/
      524543) {
        splitpanes_changes.$$scope = { dirty, ctx: ctx2 };
      }
      splitpanes.$set(splitpanes_changes);
      const statusbar_changes = {};
      if (dirty & /*runtime*/
      1)
        statusbar_changes.runtime = /*runtime*/
        ctx2[0];
      statusbar.$set(statusbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(splitpanes.$$.fragment, local);
      transition_in(statusbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(splitpanes.$$.fragment, local);
      transition_out(statusbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(splitpanes, detaching);
      destroy_component(statusbar, detaching);
    }
  };
}
function instance$D($$self, $$props, $$invalidate) {
  let $markdownPreview;
  let $wordWrap;
  let $monospace;
  let $spellcheck;
  let $isClient;
  let $buffer;
  let { runtime } = $$props;
  const { wordWrap, monospace, spellcheck, buffer, isClient, markdownPreview, statusBar, path, File } = runtime;
  component_subscribe($$self, wordWrap, (value) => $$invalidate(3, $wordWrap = value));
  component_subscribe($$self, monospace, (value) => $$invalidate(4, $monospace = value));
  component_subscribe($$self, spellcheck, (value) => $$invalidate(5, $spellcheck = value));
  component_subscribe($$self, buffer, (value) => $$invalidate(7, $buffer = value));
  component_subscribe($$self, isClient, (value) => $$invalidate(6, $isClient = value));
  component_subscribe($$self, markdownPreview, (value) => $$invalidate(2, $markdownPreview = value));
  let input;
  onMount(() => {
    runtime.setTextarea(input);
  });
  function textarea_input_handler() {
    $buffer = this.value;
    buffer.set($buffer);
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(1, input);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [
    runtime,
    input,
    $markdownPreview,
    $wordWrap,
    $monospace,
    $spellcheck,
    $isClient,
    $buffer,
    wordWrap,
    monospace,
    spellcheck,
    buffer,
    isClient,
    markdownPreview,
    textarea_input_handler,
    textarea_binding
  ];
}
let App$2 = class App29 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$D, create_fragment$I, safe_not_equal, { runtime: 0 });
  }
};
const TextEditor = {
  metadata: {
    name: "Writer",
    description: "Read and edit plain-text files",
    author: "ArcOS Team",
    version: "2.0.0",
    icon: TextEditorIcon,
    appGroup: "utilities"
  },
  runtime: Runtime23,
  content: App$2,
  id: "TextEditor",
  size: { w: 700, h: 500 },
  minSize: { w: 480, h: 500 },
  maxSize: { w: 1800, h: 1e3 },
  pos: { x: 60, y: 60 },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: true
  },
  controls: {
    minimize: true,
    maximize: true,
    close: true
  },
  glass: true,
  acceleratorDescriptions: {
    "alt+shift+o": "Open the file in File Manager",
    "alt+o": "Open a file",
    "alt+s": "Save the contents to the opened file",
    "alt+shift+s": "Save the contents to a different file"
  },
  loadCondition: () => !SafeMode.get(),
  helpArticle: HelpArticles.writer
};
let LOCKED = false;
async function alignDesktopIcons(overrideLock = false) {
  Log(
    "Wallpaper/ts/icons",
    `Automatically positioning desktop icons (OVERRIDE=${overrideLock}, LOCKED=${LOCKED})`
  );
  const udata = UserDataStore.get();
  if (LOCKED && !overrideLock)
    return;
  if (!overrideLock)
    LOCKED = true;
  await sleep(100);
  const library = appLibrary.get();
  let apps = [];
  for (const [_2, app] of library) {
    apps.push(app);
  }
  apps = apps.sort((a2) => a2.metadata.hidden || a2.metadata.core ? 1 : -1);
  const GRIDX = 80;
  const GRIDY = 85;
  const MAXX = 4;
  let offsetX = 0;
  let offsetY = 0;
  for (const app of apps) {
    if (app.id == "ExperimentsApp")
      continue;
    Log("Wallpaper/ts/icons", `Automatically positioning desktop icon for ${app.id}`);
    udata.appdata.ArcShell[`icon$${app.id}`] = {
      x: offsetX * GRIDX,
      y: offsetY * GRIDY
    };
    offsetX++;
    if (offsetX >= MAXX) {
      offsetX = 0;
      offsetY++;
    }
  }
  UserDataStore.set(udata);
}
function create_if_block$m(ctx) {
  let button;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let p2;
  let t1_value = (
    /*app*/
    ctx[0].metadata.name + ""
  );
  let t1;
  let button_data_id_value;
  let draggable_action;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      p2 = element("p");
      t1 = text(t1_value);
      attr(img, "draggable", false);
      if (!src_url_equal(img.src, img_src_value = /*app*/
      ctx[0].metadata.icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*app*/
      ctx[0].metadata.name);
      attr(p2, "class", "name");
      attr(button, "class", "desktopIcon");
      attr(button, "data-contextmenu", "desktopicon-app");
      attr(button, "data-id", button_data_id_value = /*app*/
      ctx[0].id);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, p2);
      append(p2, t1);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "dblclick",
            /*open*/
            ctx[4]
          ),
          action_destroyer(draggable_action = d$1.call(null, button, {
            grid: (
              /*$UserDataStore*/
              ctx[3].sh.desktop.noIconGrid ? null : [40, 42.5]
            ),
            bounds: (
              /*$UserDataStore*/
              ctx[3].sh.desktop.noIconGrid ? { bottom: 80, left: 10, right: 10, top: 10 } : { bottom: 110, left: 0, right: 80, top: 0 }
            ),
            position: (
              /*position*/
              ctx[1]
            ),
            disabled: (
              /*$UserDataStore*/
              ctx[3].sh.desktop.lockIcons
            )
          })),
          listen(
            button,
            "neodrag:start",
            /*startDrag*/
            ctx[6]
          ),
          listen(
            button,
            "neodrag:end",
            /*endDrag*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*app*/
      1 && !src_url_equal(img.src, img_src_value = /*app*/
      ctx2[0].metadata.icon)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*app*/
      1 && img_alt_value !== (img_alt_value = /*app*/
      ctx2[0].metadata.name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*app*/
      1 && t1_value !== (t1_value = /*app*/
      ctx2[0].metadata.name + ""))
        set_data(t1, t1_value);
      if (dirty & /*app*/
      1 && button_data_id_value !== (button_data_id_value = /*app*/
      ctx2[0].id)) {
        attr(button, "data-id", button_data_id_value);
      }
      if (draggable_action && is_function(draggable_action.update) && dirty & /*$UserDataStore, position*/
      10)
        draggable_action.update.call(null, {
          grid: (
            /*$UserDataStore*/
            ctx2[3].sh.desktop.noIconGrid ? null : [40, 42.5]
          ),
          bounds: (
            /*$UserDataStore*/
            ctx2[3].sh.desktop.noIconGrid ? { bottom: 80, left: 10, right: 10, top: 10 } : { bottom: 110, left: 0, right: 80, top: 0 }
          ),
          position: (
            /*position*/
            ctx2[1]
          ),
          disabled: (
            /*$UserDataStore*/
            ctx2[3].sh.desktop.lockIcons
          )
        });
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$H(ctx) {
  let if_block_anchor;
  let if_block = (
    /*populatable*/
    ctx[2] && create_if_block$m(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*populatable*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$m(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$C($$self, $$props, $$invalidate) {
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(3, $UserDataStore = $$value));
  let { app } = $$props;
  let position = { x: 0, y: 0 };
  let populatable = true;
  UserDataStore.subscribe((v2) => {
    $$invalidate(2, populatable = isPopulatable(app) && !isDisabled(app.id));
  });
  function open() {
    spawnApp(app.id);
  }
  function updatePos() {
    const pos = getAppPreference("ArcShell", `icon$${app.id}`);
    $$invalidate(1, position = pos || { x: 0, y: 0 });
  }
  onMount(updatePos);
  UserDataStore.subscribe(updatePos);
  function endDrag(e2) {
    const { offsetX, offsetY } = e2.detail;
    setAppPreference("ArcShell", `icon$${app.id}`, { x: offsetX, y: offsetY });
  }
  function startDrag(e2) {
    ({ x: e2.detail.offsetX, y: e2.detail.offsetY });
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [app, position, populatable, $UserDataStore, open, endDrag, startDrag];
}
class DesktopIcon extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$C, create_fragment$H, safe_not_equal, { app: 0 });
  }
}
function get_each_context$6(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list2[i2][0];
  child_ctx[7] = list2[i2][1];
  return child_ctx;
}
function create_if_block$l(ctx) {
  let div;
  let div_class_value;
  let current;
  let each_value = ensure_array_like([.../*$appLibrary*/
  ctx[2]]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$6(get_each_context$6(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", div_class_value = "desktopIcons taskbar-bounds tb-" + /*$UserDataStore*/
      ctx[1].sh.taskbar.pos);
      toggle_class(
        div,
        "docked",
        /*$UserDataStore*/
        ctx[1].sh.taskbar.docked
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$appLibrary*/
      4) {
        each_value = ensure_array_like([.../*$appLibrary*/
        ctx2[2]]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$6(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$6(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*$UserDataStore*/
      2 && div_class_value !== (div_class_value = "desktopIcons taskbar-bounds tb-" + /*$UserDataStore*/
      ctx2[1].sh.taskbar.pos)) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*$UserDataStore, $UserDataStore*/
      2) {
        toggle_class(
          div,
          "docked",
          /*$UserDataStore*/
          ctx2[1].sh.taskbar.docked
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$6(ctx) {
  let desktopicon;
  let current;
  desktopicon = new DesktopIcon({ props: { app: (
    /*app*/
    ctx[7]
  ) } });
  return {
    c() {
      create_component(desktopicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(desktopicon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const desktopicon_changes = {};
      if (dirty & /*$appLibrary*/
      4)
        desktopicon_changes.app = /*app*/
        ctx2[7];
      desktopicon.$set(desktopicon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(desktopicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(desktopicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(desktopicon, detaching);
    }
  };
}
function create_fragment$G(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*loading*/
  ctx[0] && /*$UserDataStore*/
  ctx[1].sh.desktop.icons && create_if_block$l(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*loading*/
      ctx2[0] && /*$UserDataStore*/
      ctx2[1].sh.desktop.icons) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*loading, $UserDataStore*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$l(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$B($$self, $$props, $$invalidate) {
  let $UserDataStore;
  let $appLibrary;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(1, $UserDataStore = $$value));
  component_subscribe($$self, appLibrary, ($$value) => $$invalidate(2, $appLibrary = $$value));
  let loading = false;
  let alu;
  let udsu;
  async function update2() {
    if (!$UserDataStore)
      return;
    if (!Object.keys($UserDataStore.appdata["ArcShell"]).join(",").includes("icon$")) {
      $$invalidate(0, loading = true);
      await alignDesktopIcons(true);
      setTimeout(
        () => {
          $$invalidate(0, loading = false);
        },
        100
      );
    }
  }
  onMount(() => {
    update2();
    alu = appLibrary.subscribe(update2);
    udsu = UserDataStore.subscribe(update2);
  });
  onDestroy(() => {
    alu();
    udsu();
  });
  return [loading, $UserDataStore, $appLibrary];
}
class DesktopIcons extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$B, create_fragment$G, safe_not_equal, {});
  }
}
const main$3 = "";
function create_fragment$F(ctx) {
  let div;
  let desktopicons;
  let current;
  desktopicons = new DesktopIcons({});
  return {
    c() {
      div = element("div");
      create_component(desktopicons.$$.fragment);
      attr(div, "class", "wallpaper fullscreen");
      attr(div, "data-contextmenu", "shell-wallpaper");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(desktopicons, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(desktopicons.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(desktopicons.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(desktopicons);
    }
  };
}
let App$1 = class App30 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$F, safe_not_equal, {});
  }
};
const WallpaperContext = {
  "shell-wallpaper": [
    {
      icon: "apps",
      caption: "View",
      subItems: [
        {
          caption: "Show desktop icons",
          action: () => {
            UserDataStore.update((udata) => {
              udata.sh.desktop.icons = !udata.sh.desktop.icons;
              return udata;
            });
          },
          icon: "visibility",
          isActive: () => UserDataStore.get().sh.desktop.icons
        },
        {
          caption: "Align icons to grid",
          action: () => {
            UserDataStore.update((udata) => {
              udata.sh.desktop.noIconGrid = !udata.sh.desktop.noIconGrid;
              return udata;
            });
          },
          icon: "grid_4x4",
          isActive: () => !UserDataStore.get().sh.desktop.noIconGrid
        },
        {
          caption: "Lock desktop icons",
          action: () => {
            UserDataStore.update((udata) => {
              udata.sh.desktop.lockIcons = !udata.sh.desktop.lockIcons;
              return udata;
            });
          },
          icon: "lock",
          isActive: () => UserDataStore.get().sh.desktop.lockIcons
        },
        {
          caption: "Reset icon alignment",
          action: () => {
            createErrorDialog(
              {
                title: "Reset icon alignment?",
                message: "This will arrange the desktop icons back to their default positions. Do you want to continue?",
                image: DesktopIcon$1,
                buttons: [
                  {
                    caption: "Reset",
                    action() {
                      alignDesktopIcons(true);
                    },
                    suggested: true
                  },
                  { caption: "Cancel", action() {
                  } }
                ],
                sound: "arcos.dialog.warning"
              },
              ProcessStack.getAppPids("ArcShell")[0],
              true
            );
          },
          icon: "undo"
        },
        SEP_ITEM,
        {
          caption: "Show hidden apps",
          action() {
            UserDataStore.update((v2) => {
              v2.sh.showHiddenApps = !v2.sh.showHiddenApps;
              return v2;
            });
          },
          isActive: () => UserDataStore.get().sh.showHiddenApps
        }
      ]
    },
    SEP_ITEM,
    {
      caption: "File Manager",
      action: () => {
        spawnApp("FileManager");
      },
      image: FileManagerIcon
    },
    {
      caption: "Processes",
      action: () => {
        spawnApp("ProcessManager");
      },
      image: ProcessManagerIcon
    },
    {
      caption: "App settings",
      action: () => {
        OpenSettingsPage("apps");
      },
      image: AppsIcon
    },
    SEP_ITEM,
    {
      caption: "Shut down",
      action: shutdown,
      image: ShutdownIcon
    },
    {
      caption: "Restart",
      action: restart$3,
      image: RestartIcon
    },
    SEP_ITEM,
    {
      caption: "Themes",
      action: () => {
        OpenSettingsPage("themes");
      },
      image: ThemesIcon
    },
    {
      caption: "Wallpaper",
      action: () => {
        OpenSettingsPage("wallpaper");
      },
      image: DesktopIcon$1
    },
    {
      caption: "Visuals",
      action: () => {
        OpenSettingsPage("visuals");
      },
      image: PersonalizationIcon
    }
  ],
  "desktopicon-app": [
    {
      caption: "Open",
      action(window2, data2) {
        spawnApp(data2.id);
      },
      icon: "launch"
    },
    {
      image: ShutdownIcon,
      caption: "Kill",
      action(window2, data2) {
        killAllAppInstances(data2.id);
      }
    },
    /* SEP_ITEM,
    {
      image: TrashIcon,
      caption: "Disable",
      action(window, data, scope) {
        disableApp(data.id);
      },
    }, */
    SEP_ITEM,
    {
      image: AppInfoIcon,
      caption: "App Info",
      action(window2, data2, scope) {
        spawnApp("AppInfo", 0, [data2.id]);
      }
    }
  ]
};
class WallpaperRuntime extends AppRuntime {
  constructor(app, mutator, process) {
    super(app, mutator, process);
  }
}
const desktopWallpaper = {
  metadata: {
    name: "Desktop Wallpaper",
    description: "The beautiful wallpaper you set; rendered.",
    author: "The ArcOS Team",
    version: "2.0.0",
    appGroup: "coreApps",
    icon: ComponentIcon,
    core: true,
    hidden: true,
    dependendsOn: ["ArcShell"]
  },
  runtime: WallpaperRuntime,
  content: App$1,
  id: "desktopWallpaper",
  size: { w: 0, h: 0 },
  minSize: { w: 0, h: 0 },
  maxSize: { w: 0, h: 0 },
  pos: { x: 0, y: 0 },
  controls: { minimize: false, maximize: false, close: false },
  state: {
    minimized: false,
    maximized: false,
    headless: false,
    fullscreen: false,
    resizable: false
  },
  singleInstance: true,
  contextMenu: WallpaperContext,
  loadCondition: () => !!UserDataStore.get()
};
const builtinApps = {
  ArcShell,
  KeyboardShortcuts,
  desktopWallpaper,
  ArcTerm: ArcTermApp,
  SettingsApp,
  AppInfo,
  ServiceInfo,
  LoggerApp,
  ErrorDialog,
  ProcessManager,
  QlorbApp,
  SecureContext,
  LightsOff,
  ExitApp,
  TextEditor,
  LoadSaveDialog,
  FsProgress,
  OpenWith: OpenWith$1,
  FileManager,
  MarkDownViewer,
  ImageViewer,
  IconLibrary,
  DonutApp,
  MediaPlayer,
  HelpSupport,
  MessagingApp,
  BugReports,
  ArcFind,
  CalculatorApp
};
function appDependenciesMatch(deps) {
  const apps = [...appLibrary.get()].map((a2) => a2[1].id);
  for (const dep of deps) {
    if (!apps.includes(dep))
      return false;
  }
  return true;
}
function loadConditionFailed(app) {
  const shellPid = ProcessStack.getAppPids("ArcShell")[0];
  const dialog = {
    title: "App load aborted",
    message: `Loading application <code>${app.id}</code> was stopped because the necessary load condition failed. Try restarting to resolve this problem. If it persists, contact the ArcOS Team for more information.<br><br>Condition: <code>${app.loadCondition.toString()}</code>`,
    buttons: [{ caption: "Okay", action() {
    } }],
    image: WarningIcon,
    sound: "arcos.dialog.warning"
  };
  function onOpen(icon) {
    createErrorDialog(dialog, shellPid, true);
    if (!icon)
      return;
    disposeTrayIcon(icon.identifier);
  }
  Log(
    "apps/load",
    `Aborted ${app.id} because the load condition failed: ${app.loadCondition.toString()}`,
    LogLevel.error
  );
  if (SafeMode.get() && app.loadCondition.toString().includes("SafeMode"))
    return;
  if (shellPid)
    createTrayIcon({
      identifier: `lcFail#${app.id}`,
      image: WarningIcon,
      onOpen
    });
}
async function loadApp(id, data2) {
  Log("apps/load", `Loading application ${id}`);
  const library = appLibrary.get();
  if (library.has(id)) {
    Log(
      "apps/load",
      `${id} failed because an application with the same ID already exists`,
      LogLevel.error
    );
    return false;
  }
  const allowLoad = data2.loadCondition ? await data2.loadCondition() : true;
  const dependenciesMatch = appDependenciesMatch(data2.metadata.dependendsOn || []);
  if (!allowLoad) {
    loadConditionFailed(data2);
    return false;
  }
  if (!dependenciesMatch) {
    createErrorDialog(
      {
        title: "Dependency failure",
        message: `Application ${id} failed to load because one or more of the applications it depends on aren't loaded.`,
        image: WarningIcon,
        buttons: [{ caption: "Okay", action() {
        } }]
      },
      0
    );
    console.log(`Dependencies for ${id} failed: ${data2.metadata.dependendsOn}`);
    return false;
  }
  library.set(id, data2);
  await sleep();
  appLibrary.set(library);
  if (data2.metadata.core)
    spawnApp(id);
  return true;
}
async function loadBuiltinApps() {
  Log("apps/builtins", "Loading built-in applications...");
  const entries = Object.entries(builtinApps);
  for (const [id, app] of entries) {
    await loadApp(id, app);
  }
}
const ElevationPid = Store$1();
class ES extends Process {
  constructor(handler, pid, name, app, args) {
    super(handler, pid, name, app, args);
    __publicField(this, "_pausedError", "Can't elevate: I'm paused!");
  }
  start() {
    ElevationPid.set(this.pid);
    this._tray();
    const userdata = UserDataStore.get();
    if (userdata.sh.bypassElevation)
      this.bypassWarning();
  }
  async GetUserElevation(data2) {
    this.Log(`Getting user elevation: ${data2.what}`);
    if (this.pauseCheck())
      return false;
    const id = Math.floor(Math.random() * 1e6);
    const shellPid = ProcessStack.getAppPids("ArcShell")[0];
    const app = getAppById("SecureContext");
    const userdata = UserDataStore.get();
    if (userdata.sh.bypassElevation)
      return true;
    if (!app)
      return false;
    let proc;
    if (!shellPid) {
      proc = await spawnApp("SecureContext", 0, [id, data2]);
    } else {
      proc = await spawnOverlay(app, shellPid || 0, [id, data2]);
    }
    if (!proc || typeof proc == "string")
      return false;
    return new Promise((resolve) => {
      GlobalDispatch.subscribe("elevation-accept", (data22) => {
        if (!data22[0] || data22[0] !== id)
          return;
        this.Log(`Approving ID ${id}`);
        resolve(true);
      });
      GlobalDispatch.subscribe("elevation-reject", (data22) => {
        if (!data22[0] || data22[0] !== id)
          return;
        this.Log(`Denying ID ${id}`);
        resolve(false);
      });
    });
  }
  _tray() {
    const id = `svc#SecureContext_${this.pid}`;
    createTrayIcon({
      identifier: id,
      title: "Security Menu",
      image: SecureIcon,
      popup: {
        width: 200,
        height: 150,
        component: TrayPopup$1
      }
    });
    ProcessStack.processes.subscribe(() => {
      if (!ProcessStack.isPid(this.pid, true))
        disposeTrayIcon(id);
    });
  }
  async bypassWarning() {
    await sleep(1e3);
    function notif() {
      sendNotification({
        title: "Elevation is disabled",
        message: "ArcOS is currently not preventing any elevated requests from running without your permission. It is recommended to leave Elevation <b>enabled</b>. Click the button to solve this problem.",
        buttons: [
          {
            caption: "Re-enable elevation",
            action() {
              UserDataStore.update((v2) => {
                v2.sh.bypassElevation = false;
                return v2;
              });
            }
          }
        ],
        image: SecurityHighIcon
      });
    }
    notif();
    const id = `svc#ElevationService_disabledNotifier`;
    createTrayIcon({
      title: "Elevation is disabled",
      image: SecurityHighIcon,
      identifier: id,
      onOpen() {
        disposeTrayIcon(id);
        notif();
      }
    });
  }
}
const ElevationService = {
  name: "Elevation Serice",
  description: "Manages the ArcOS Secure Context",
  process: ES,
  initialState: "started"
};
async function GetUserElevation(data2, stack) {
  const elevation = ElevationPid.get();
  const manager = stack.getProcess(elevation);
  if (!elevation || !manager) {
    sendNotification({
      title: "Elevation failed",
      message: "The Elevation Service isn't running anymore. Without it, you can't access the ArcOS Secure Context. Please restart to resolve this problem.",
      image: SecurityHighIcon
    });
    return false;
  }
  return await manager.GetUserElevation(data2);
}
class BrowserCheckProcess extends Process {
  constructor(handler, pid, name, app, args) {
    super(handler, pid, name, app, args);
    __publicField(this, "warnings", {
      "safari/,mac": {
        title: "Safari",
        message: "ArcOS doesn't officially support Safari. For the best experience, please resort to a Chromium-based or Firefox browser.",
        image: GlobeIcon,
        buttons: [
          {
            caption: "Chrome",
            action() {
              window.open("https://chrome.google.com/", "_blank");
            }
          },
          {
            caption: "Firefox",
            action() {
              window.open("https://mozilla.org/firefox", "_blank");
            }
          },
          {
            caption: "Ignore",
            action() {
            },
            suggested: true
          }
        ]
      }
    });
  }
  async start() {
    await sleep(1e3);
    const ua = navigator.userAgent.toLowerCase();
    for (const browser in this.warnings) {
      let send = function() {
        createErrorDialog(
          { ...warning, buttons: [...warning.buttons || []], sound: "arcos.dialog.warning" },
          ProcessStack.getAppPids("ArcShell")[0] || 0,
          true
        );
      };
      const split = browser.split(",");
      if (browser.includes("safari") && !window["safari"])
        continue;
      let browserApplies = true;
      for (const item of split) {
        if (!ua.includes(item))
          browserApplies = false;
      }
      if (!browserApplies)
        continue;
      const warning = this.warnings[browser];
      createTrayIcon({
        title: warning.title,
        image: warning.image,
        onOpen: () => send(),
        identifier: `BrowserCheck_Warning#${browser}`
      });
      send();
    }
    stopService("BrowserCheck", true);
  }
}
const BrowserCheck = {
  name: "Browser Check",
  description: "Performs checks to ensure your browser is compatible",
  process: BrowserCheckProcess,
  initialState: "started",
  startCondition: () => PrimaryState.current.get().key == "desktop" && !SafeMode.get()
};
class MessageNotifierProcess extends Process {
  // Every 60 seconds
  constructor(handler, pid, name, app, args) {
    super(handler, pid, name, app, args);
    __publicField(this, "BLACKLIST", []);
    __publicField(this, "FREQUENCY", 1e3 * 60);
  }
  async start() {
    await sleep(500);
    setInterval(async () => {
      if (this._paused)
        return;
      await this.Tick();
    }, this.FREQUENCY);
    this.Tick();
  }
  async Tick() {
    const unreads = (await getUnreadMessages(200)).sort((a2, b2) => b2.timestamp - a2.timestamp).filter((m3) => !this.BLACKLIST.includes(m3.id));
    const message = unreads[0];
    if (!unreads.length || !message)
      return;
    GlobalDispatch.dispatch("message-flush");
    this.BLACKLIST.push(message.id);
    await this._notify(message);
  }
  async _notify(message) {
    const pfp = await getUserPfp(message.sender, MessagingIcon);
    const { title, body } = parseTitle(message.partialBody);
    sendNotification({
      title: `${message.sender}: ${title}`,
      message: `${filterPartialMessageBody(body)}`,
      image: pfp,
      buttons: [{ caption: "Open Message", action: () => this._open(message.id) }]
    });
  }
  async _open(id) {
    const pids = ProcessStack.getAppPids("MessagingApp");
    if (!pids.length)
      return await spawnApp("MessagingApp", 0, [id]);
    return ProcessStack.dispatch.dispatchToPid(pids[0], "open-message", id);
  }
}
const MessageNotifierService = {
  process: MessageNotifierProcess,
  initialState: "started",
  name: "Message Notifier Service",
  description: "Continuously checks for incoming ArcOS messages",
  startCondition: () => PrimaryState.current.get().key == "desktop" && !SafeMode.get()
};
class RateLimitNotifierProcess extends Process {
  constructor(handler, pid, name, app, args) {
    super(handler, pid, name, app, args);
  }
  start() {
    GlobalDispatch.subscribe("rate-limit", () => {
      this.notify();
    });
  }
  notify() {
    if (this._paused)
      return;
    sendNotification({
      title: "Hold up!",
      message: "You've been rate limited! Apparently the server thinks you're being too fast. Please wait a minute before trying anything again.",
      image: ConnectIcon,
      timeout: 5e3
    });
  }
}
const RateLimitNotifierService = {
  name: "Rate Limit Notifier Service",
  description: "Informs you when you're rate limited",
  process: RateLimitNotifierProcess,
  initialState: "started",
  startCondition: () => PrimaryState.current.get().key == "desktop"
};
class UDC extends Process {
  constructor(handler, pid, name, app, args) {
    super(handler, pid, name, app, args);
    __publicField(this, "unsubscribe");
  }
  start() {
    this.Log(`Starting UDC`);
    this.unsubscribe = UserDataStore.subscribe((v2) => this.commit(v2));
  }
  stop() {
    this.Log(`Stopping UDC`);
    if (!this.unsubscribe)
      return;
    this.unsubscribe();
    this.unsubscribe = null;
    return true;
  }
  async commit(data2) {
    if (this._paused)
      return;
    data2 = this._validateAppdata(data2);
    await setUserData(data2);
  }
  _validateAppdata(data2) {
    if (!data2.appdata)
      data2.appdata = { experiments: {} };
    const library = appLibrary.get();
    for (const [id] of library) {
      if (!data2.appdata[id])
        data2.appdata[id] = {};
    }
    return data2;
  }
}
const UserDataCommitter = {
  name: "User Data Committer",
  description: "Saves user data changes to your server",
  process: UDC,
  initialState: "started"
};
const serviceStore = /* @__PURE__ */ new Map([
  ["UserDataCommitter", UserDataCommitter],
  ["NotificationService", NotificationService],
  ["BrowserCheck", BrowserCheck],
  ["ElevationService", ElevationService],
  ["RateLimitNotifierService", RateLimitNotifierService],
  ["MessageNotifierService", MessageNotifierService]
]);
const ServiceManagerPid = Store$1();
class ServiceManager extends Process {
  constructor(handler, pid, name, app, args) {
    super(handler, pid, name, app, args);
    __publicField(this, "Services", Store$1());
    __publicField(this, "_criticalProcess", true);
    // Make sure the user can't end this one
    __publicField(this, "_storeLoaded", false);
    __publicField(this, "_holdRestart", false);
  }
  start() {
    ServiceManagerPid.set(this.pid);
    this.init();
  }
  loadStore(store) {
    if (this._storeLoaded) {
      this.Log(`Can't load another store: a store is already loaded.`, LogLevel.error);
      return false;
    }
    this.Log(`Loading store (${store.size} services)`);
    for (const [id, service] of [...store]) {
      service.id = id;
      service.loadedAt = (/* @__PURE__ */ new Date()).getTime();
      store.set(id, service);
    }
    this.Services.set(store);
    return this._storeLoaded = true;
  }
  async startService(id, fromSystem = false) {
    const services = this.Services.get();
    const service = services.get(id);
    if (!services.has(id))
      return "err_noExist";
    const elevation = fromSystem || await GetUserElevation(ElevationChangeServiceState(service), ProcessStack);
    if (!elevation)
      return "err_elevation";
    const canStart = service.startCondition ? await service.startCondition() : true;
    if (!canStart)
      return "err_startCondition";
    if (service.pid)
      return "err_alreadyRunning";
    const instance2 = await ProcessStack.spawn({
      proc: service.process,
      name: `svc#${id}`,
      parentPid: this.pid
    });
    if (typeof instance2 == "string")
      return "err_spawnFailed";
    service.pid = instance2.pid;
    service.changedAt = (/* @__PURE__ */ new Date()).getTime();
    services.set(id, service);
    this.Services.set(services);
    return "success";
  }
  async stopService(id, fromSystem = false) {
    this.Log(`Stopping ${id}`);
    const services = this.Services.get();
    const service = services.get(id);
    if (!services.has(id))
      return "err_noExist";
    if (!service.pid)
      return "err_notRunning";
    const elevation = fromSystem || await GetUserElevation(ElevationChangeServiceState(service), ProcessStack);
    if (!elevation)
      return "err_elevation";
    this._holdRestart = true;
    await ProcessStack.kill(service.pid, true);
    service.pid = null;
    service.changedAt = (/* @__PURE__ */ new Date()).getTime();
    services.set(id, service);
    this.Services.set(services);
    this._holdRestart = false;
    return "success";
  }
  async restartService(id, fromSystem = false) {
    const services = this.Services.get();
    if (!services.has(id))
      return "err_noExist";
    const elevation = fromSystem || await GetUserElevation(ElevationChangeServiceState(services.get(id)), ProcessStack);
    if (!elevation)
      return "err_elevation";
    await this.stopService(id, true);
    const started = await this.startService(id, true);
    return started;
  }
  initialRun() {
    const services = this.Services.get();
    for (const [id, service] of [...services]) {
      if (!service.initialState || service.initialState != "started")
        continue;
      this.startService(id, true);
    }
  }
  init() {
    this.loadStore(serviceStore);
    this.initialRun();
    ProcessStack.processes.subscribe(() => this.verifyServicesProcesses());
    this.Services.subscribe(() => GlobalDispatch.dispatch("services-flush"));
  }
  async verifyServicesProcesses() {
    if (this.pauseCheck() || this._holdRestart)
      return;
    const services = this.Services.get();
    for (const [id, service] of [...services]) {
      if (!service.pid || ProcessStack.isPid(service.pid, true))
        continue;
      this.Log(`Process of ${id} doesn't exist anymore! Restarting service...`, LogLevel.warn);
      await this.restartService(id, true);
    }
  }
}
const StartupProcesses = [
  {
    proc: ServiceManager,
    name: "ServiceManager"
  }
];
function CoreRestartNotification(count) {
  sendNotification({
    title: "Processes restarted",
    message: `ArcOS has restarted ${count} core process${count == 1 ? "" : "es"} that weren't running anymore. Do note that ArcOS might show behave unexpectedly until you restart. Click Learn More for more information.`,
    image: ShutdownIcon,
    timeout: 2500,
    buttons: [
      {
        caption: "Learn More",
        action: moreInfo
      }
    ]
  });
  function moreInfo() {
    createErrorDialog(
      {
        title: "Processes restarted",
        message: "When restarting core services, certain components such as the Action Center and System Tray might behave unexpectedly because of misfiring intervals. ArcOS could behave normally, or it could not, completely depending on when and how the processes were stopped. To ensure that ArcOS remains stable, it is advised to restart.",
        buttons: [
          {
            caption: "Ignore",
            action() {
            }
          },
          {
            caption: "Restart Now",
            action() {
              restart$3();
            },
            suggested: true
          }
        ],
        image: ErrorIcon
      },
      0
    );
  }
}
async function StartCoreProcesses(restart2 = false, handler = ProcessStack) {
  Log("process/startup", `Starting ${StartupProcesses.length} core processes.`);
  let startCount = 0;
  for (const service of StartupProcesses) {
    const processes = [...handler.processes.get()];
    const sameNames = processes.filter(([_2, proc]) => {
      return proc.name == service.name && !proc._disposed;
    });
    const isRunning = !!sameNames.length;
    if (isRunning)
      continue;
    startCount++;
    await handler.spawn(service);
  }
  if (restart2 && startCount) {
    CoreRestartNotification(startCount);
  }
}
async function authPrompt(term, usr = "", keep = false) {
  const udata = UserName.get();
  if (udata)
    return true;
  let api2 = getServer();
  if (!api2)
    api2 = await serverConnect(term);
  await doRememberedAuth();
  await sleep(0);
  if (get_store_value(UserName))
    return true;
  if (!keep) {
    term.std.clear();
    term.std.writeLine(`ArcTerm ${ArcOSVersion} ${ARCOS_MODE} ${api2} atm1

`);
  }
  const { username, password } = await authPromptFields(term, api2, usr);
  await Authenticate(username, password);
  if (!get_store_value(UserName)) {
    term.std.writeLine("\nLogin incorrect");
    localStorage.removeItem("arcos-remembered-token");
    return await authPrompt(term, usr, true);
  }
  return true;
}
async function authPromptFields(term, api2, usr) {
  const username = await term.std.read(`${api2} login: `, "", 100, false, usr);
  if (!username) {
    term.std.writeLine("\nLogin incorrect");
    return await authPromptFields(term, api2, usr);
  }
  const password = await term.std.read("Password: ", "", 100, true);
  return { username, password };
}
async function serverConnect(term) {
  term.std.clear();
  term.std.writeLine(`ArcTerm ${ArcOSVersion} - Connect to server

`);
  const server = await term.std.read("Server: ", "", 50);
  const authCode = await term.std.read("Code (optional): ", "", 64, true);
  term.std.writeLine(`Connecting to ${server}...`);
  if (!await testConnection(server, authCode))
    return await serverConnect(term);
  addServer(server);
  setAuthcode(server, authCode);
  return server;
}
async function arcTermModeIntro(a2, cb) {
  Log(`ArcTerm ${a2.referenceId}`, "Viewing ArcTermMode intro");
  if (!await authPrompt(a2))
    return;
  UserCache.clear();
  const server = getServer();
  const user = UserName.get();
  const platform2 = ConnectedServer.get().meta.name;
  a2.std.clear();
  if (cb)
    cb();
  if (a2.app)
    return;
  await StartCoreProcesses();
  disclaimer(a2);
  auth(a2, user, platform2);
  api(a2, server);
  usage(a2);
}
function disclaimer(term) {
  term.std.writeColor(
    `[█] You are currently in [ArcTerm mode].
[█] Commands that require the ArcOS desktop have been disabled.

`,
    "orange"
  );
  term.std.writeColor(`ArcTerm reference ID: [${term.referenceId}]`, "blue");
}
function auth(term, user, platform2) {
  term.std.writeColor(`
Authenticated as [${user}] at [${platform2}]`, "aqua", "white", true);
}
function api(term, server) {
  term.std.writeColor(` [(${server})]`, "gray", "white", true);
}
async function usage(term) {
  const quota = await getFSQuota();
  const used = formatBytes(quota.used);
  const max = formatBytes(quota.max);
  const percent = (100 / quota.max * quota.used).toFixed(2);
  term.std.writeColor(
    `
[ArcFS]: You are using [${used}] of [${max}] total (${percent}%)
`,
    "yellow"
  );
}
function create_fragment$E(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.textContent = "authenticating with ArcAPI...";
      attr(div, "id", "target");
      attr(div, "class", "terminal-renderer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[2](div);
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*focus*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[2](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$A($$self, $$props, $$invalidate) {
  let arcterm;
  let target;
  onMount(async () => {
    arcterm = new ArcTerm(target, arcCommands, null, null, arcTermModeIntro);
  });
  function focus() {
    if (!arcterm || !arcterm.input || !arcterm.input.current)
      return;
    arcterm.input.current.focus();
    if (!target)
      return;
    target.scrollTo(0, target.scrollHeight);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      target = $$value;
      $$invalidate(0, target);
    });
  }
  return [target, focus, div_binding];
}
class ArcTerm_1 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$A, create_fragment$E, safe_not_equal, {});
  }
}
const boot = "";
function create_else_block$3(ctx) {
  let div1;
  let glowinglogo;
  let t0;
  let div0;
  let spinner;
  let t1;
  let p2;
  let current;
  glowinglogo = new GlowingLogo({});
  spinner = new Spinner({
    props: {
      height: 30,
      stopped: !/*progress*/
      ctx[3]
    }
  });
  return {
    c() {
      div1 = element("div");
      create_component(glowinglogo.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(spinner.$$.fragment);
      t1 = space();
      p2 = element("p");
      attr(p2, "class", "status");
      attr(div0, "class", "bottom");
      attr(div1, "class", "content");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(glowinglogo, div1, null);
      append(div1, t0);
      append(div1, div0);
      mount_component(spinner, div0, null);
      append(div0, t1);
      append(div0, p2);
      p2.innerHTML = /*status*/
      ctx[0];
      current = true;
    },
    p(ctx2, dirty) {
      const spinner_changes = {};
      if (dirty & /*progress*/
      8)
        spinner_changes.stopped = !/*progress*/
        ctx2[3];
      spinner.$set(spinner_changes);
      if (!current || dirty & /*status*/
      1)
        p2.innerHTML = /*status*/
        ctx2[0];
    },
    i(local) {
      if (current)
        return;
      transition_in(glowinglogo.$$.fragment, local);
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(glowinglogo.$$.fragment, local);
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(glowinglogo);
      destroy_component(spinner);
    }
  };
}
function create_if_block$k(ctx) {
  let div;
  let img;
  let img_src_value;
  let t0;
  let h1;
  let t2;
  let p2;
  let t3;
  let b2;
  let t5;
  let br;
  let t6;
  let t7;
  let button0;
  let t9;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      img = element("img");
      t0 = space();
      h1 = element("h1");
      h1.textContent = "Connection failed!";
      t2 = space();
      p2 = element("p");
      t3 = text("ArcOS could not connect to ");
      b2 = element("b");
      b2.textContent = `${getServer()}`;
      t5 = text("!");
      br = element("br");
      t6 = text("\n        Please check your internet connection.");
      t7 = space();
      button0 = element("button");
      button0.textContent = "Change Server";
      t9 = space();
      button1 = element("button");
      button1.textContent = "Restart";
      if (!src_url_equal(img.src, img_src_value = BugReportIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(div, "class", "connection-failed");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
      append(div, t0);
      append(div, h1);
      append(div, t2);
      append(div, p2);
      append(p2, t3);
      append(p2, b2);
      append(p2, t5);
      append(p2, br);
      append(p2, t6);
      append(div, t7);
      append(div, button0);
      append(div, t9);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*changeServer*/
            ctx[6]
          ),
          listen(
            button1,
            "click",
            /*click_handler*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$D(ctx) {
  let div2;
  let current_block_type_index;
  let if_block;
  let t0;
  let div0;
  let t8;
  let div1;
  let t9_value = (
    /*targetState*/
    ctx[2] == "serverselect" ? "Loading Server Selector..." : "Press F8 to select server"
  );
  let t9;
  let div2_class_value;
  let current;
  const if_block_creators = [create_if_block$k, create_else_block$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*connectFailed*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div2 = element("div");
      if_block.c();
      t0 = space();
      div0 = element("div");
      div0.textContent = `v${ArcOSVersion}-${ARCOS_MODE} (${ARCOS_BUILD})`;
      t8 = space();
      div1 = element("div");
      t9 = text(t9_value);
      attr(div0, "class", "version");
      attr(div1, "class", "f8");
      attr(div2, "class", div2_class_value = "state-boot fullscreen center-flex " + /*bootClass*/
      ctx[1]);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if_blocks[current_block_type_index].m(div2, null);
      append(div2, t0);
      append(div2, div0);
      append(div2, t8);
      append(div2, div1);
      append(div1, t9);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div2, t0);
      }
      if ((!current || dirty & /*targetState*/
      4) && t9_value !== (t9_value = /*targetState*/
      ctx2[2] == "serverselect" ? "Loading Server Selector..." : "Press F8 to select server"))
        set_data(t9, t9_value);
      if (!current || dirty & /*bootClass*/
      2 && div2_class_value !== (div2_class_value = "state-boot fullscreen center-flex " + /*bootClass*/
      ctx2[1])) {
        attr(div2, "class", div2_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$z($$self, $$props, $$invalidate) {
  let $State;
  let { handler } = $$props;
  let status2 = "";
  let bootClass = "";
  let targetState = "login";
  let progress = false;
  let running = false;
  let connectFailed = false;
  let isSafeMode = false;
  const { current: State } = handler;
  component_subscribe($$self, State, (value) => $$invalidate(11, $State = value));
  onMount(async () => {
    if (isDesktop()) {
      await sleep(500);
      $$invalidate(1, bootClass = "fadein");
      return startBooting();
    }
    $$invalidate(0, status2 = "Press a key or click to start");
    document.addEventListener("click", startBooting, { once: true });
    document.addEventListener("keydown", startBooting, { once: true });
    document.addEventListener("keydown", safeMode);
    document.addEventListener("keydown", arcTermShortcut);
    await sleep(500);
    $$invalidate(1, bootClass = "fadein");
  });
  async function startBooting() {
    if (running)
      return;
    running = true;
    $$invalidate(0, status2 = "&nbsp;");
    $$invalidate(3, progress = true);
    if (targetState == "serverselect")
      return await redirect();
    if (!await checkServer() && !getAllServers().length)
      $$invalidate(0, status2 = "Welcome to ArcOS");
    if (!connectFailed)
      await redirect();
  }
  async function safeMode(e2) {
    if (!e2.key || $State.key !== "boot")
      return;
    const key2 = e2.key.toLowerCase();
    if (key2 != " " || !e2.shiftKey)
      return;
    $$invalidate(0, status2 = "Entering Safe Mode...");
    SafeMode.set(true);
    isSafeMode = true;
  }
  function arcTermShortcut(e2) {
    if (!e2.key || isSafeMode || $State.key !== "boot")
      return;
    const key2 = e2.key.toLowerCase();
    if (key2 == "f8" || targetState == "serverselect") {
      $$invalidate(0, status2 = "Waiting for Server Select...");
      return $$invalidate(2, targetState = "serverselect");
    }
    if (!e2.altKey || key2 != "a")
      return;
    $$invalidate(2, targetState = "arcterm");
    $$invalidate(0, status2 = "Loading ArcTerm");
  }
  async function checkServer() {
    const serverHost = getServer();
    const authCode = getAuthcode(serverHost);
    if (!serverHost)
      return;
    if (authCode)
      $$invalidate(0, status2 = "Connecting Securely");
    const connected = await testConnection(serverHost, authCode);
    if (!connected) {
      $$invalidate(4, connectFailed = true);
      $$invalidate(2, targetState = "boot");
      return (
        /* targetState == "serverselect" ? false : true; */
        false
      );
    }
    return connected;
  }
  async function redirect() {
    Log("Boot", "Redirecting");
    await sleep(2e3);
    $$invalidate(1, bootClass = "fadeout");
    await sleep(750);
    handler.navigate(targetState);
  }
  async function changeServer() {
    $$invalidate(2, targetState = "serverselect");
    await sleep(2e3);
    PrimaryState.navigate("serverselect");
  }
  const click_handler = () => location.reload();
  $$self.$$set = ($$props2) => {
    if ("handler" in $$props2)
      $$invalidate(7, handler = $$props2.handler);
  };
  return [
    status2,
    bootClass,
    targetState,
    progress,
    connectFailed,
    State,
    changeServer,
    handler,
    click_handler
  ];
}
class Boot extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$z, create_fragment$D, safe_not_equal, { handler: 7 });
  }
}
function create_fragment$C(ctx) {
  let div;
  let button0;
  let t1;
  let button1;
  let t2_value = (
    /*moreInfo*/
    ctx[0] ? "Go Back" : "More Info"
  );
  let t2;
  let t3;
  let button2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.textContent = "Open Logging";
      t1 = space();
      button1 = element("button");
      t2 = text(t2_value);
      t3 = space();
      button2 = element("button");
      button2.textContent = "Restart";
      attr(button2, "class", "restart");
      attr(div, "class", "actions");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      append(div, t3);
      append(div, button2);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*viewLogs*/
            ctx[2]
          ),
          listen(
            button1,
            "click",
            /*toggle*/
            ctx[1]
          ),
          listen(button2, "click", restart$1)
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*moreInfo*/
      1 && t2_value !== (t2_value = /*moreInfo*/
      ctx2[0] ? "Go Back" : "More Info"))
        set_data(t2, t2_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function restart$1() {
  location.reload();
}
function instance$y($$self, $$props, $$invalidate) {
  let { moreInfo } = $$props;
  let { handler } = $$props;
  function toggle() {
    $$invalidate(0, moreInfo = !moreInfo);
  }
  function viewLogs() {
    spawnApp("LoggerApp", 0, [LogLevel.error, "*"], handler, LoggerApp);
  }
  $$self.$$set = ($$props2) => {
    if ("moreInfo" in $$props2)
      $$invalidate(0, moreInfo = $$props2.moreInfo);
    if ("handler" in $$props2)
      $$invalidate(3, handler = $$props2.handler);
  };
  return [moreInfo, toggle, viewLogs, handler];
}
let Actions$2 = class Actions6 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$y, create_fragment$C, safe_not_equal, { moreInfo: 0, handler: 3 });
  }
};
function create_fragment$B(ctx) {
  let div;
  let span;
  let t1;
  let h1;
  let t3;
  let p0;
  let t6;
  let p1;
  let t7_value = (
    /*$CrashReport*/
    (ctx[2] ? (
      /*$CrashReport*/
      ctx[2].title
    ) : "No Crash Report!") + ""
  );
  let t7;
  let t8;
  let actions;
  let updating_moreInfo;
  let current;
  function actions_moreInfo_binding(value) {
    ctx[3](value);
  }
  let actions_props = { handler: (
    /*handler*/
    ctx[1]
  ) };
  if (
    /*moreInfo*/
    ctx[0] !== void 0
  ) {
    actions_props.moreInfo = /*moreInfo*/
    ctx[0];
  }
  actions = new Actions$2({ props: actions_props });
  binding_callbacks.push(() => bind$1(actions, "moreInfo", actions_moreInfo_binding));
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = "report";
      t1 = space();
      h1 = element("h1");
      h1.textContent = "ArcOS Crashed!";
      t3 = space();
      p0 = element("p");
      p0.innerHTML = `An error occured and ArcOS had to shut down. A Bug Report has been submitted, informing us of
    the crash.<br/><br/>
    This session can&#39;t continue. You can choose to restart.`;
      t6 = space();
      p1 = element("p");
      t7 = text(t7_value);
      t8 = space();
      create_component(actions.$$.fragment);
      attr(span, "class", "icon material-icons-round");
      attr(h1, "class", "title");
      attr(p0, "class", "info");
      attr(p1, "class", "error");
      attr(div, "class", "crash-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t1);
      append(div, h1);
      append(div, t3);
      append(div, p0);
      append(div, t6);
      append(div, p1);
      append(p1, t7);
      append(div, t8);
      mount_component(actions, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*$CrashReport*/
      4) && t7_value !== (t7_value = /*$CrashReport*/
      (ctx2[2] ? (
        /*$CrashReport*/
        ctx2[2].title
      ) : "No Crash Report!") + ""))
        set_data(t7, t7_value);
      const actions_changes = {};
      if (dirty & /*handler*/
      2)
        actions_changes.handler = /*handler*/
        ctx2[1];
      if (!updating_moreInfo && dirty & /*moreInfo*/
      1) {
        updating_moreInfo = true;
        actions_changes.moreInfo = /*moreInfo*/
        ctx2[0];
        add_flush_callback(() => updating_moreInfo = false);
      }
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(actions);
    }
  };
}
function instance$x($$self, $$props, $$invalidate) {
  let $CrashReport;
  component_subscribe($$self, CrashReport, ($$value) => $$invalidate(2, $CrashReport = $$value));
  let { moreInfo } = $$props;
  let { handler } = $$props;
  function actions_moreInfo_binding(value) {
    moreInfo = value;
    $$invalidate(0, moreInfo);
  }
  $$self.$$set = ($$props2) => {
    if ("moreInfo" in $$props2)
      $$invalidate(0, moreInfo = $$props2.moreInfo);
    if ("handler" in $$props2)
      $$invalidate(1, handler = $$props2.handler);
  };
  return [moreInfo, handler, $CrashReport, actions_moreInfo_binding];
}
class Content5 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$x, create_fragment$B, safe_not_equal, { moreInfo: 0, handler: 1 });
  }
}
function create_fragment$A(ctx) {
  let if_block_anchor;
  return {
    c() {
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, if_block_anchor, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
    }
  };
}
class ViteNotice extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$A, safe_not_equal, {});
  }
}
const CrashPrefix = "---! [ ArcOS crashed ] !---\n\nWhat did you mess up this time? I know v6 is early days, but still...\n\nBelow you'll find the log, which may contain information about the crash.\nA bug report has been sent to the Reports server informing it of the crash.\n\n";
const MoreInfo_svelte_svelte_type_style_lang = "";
function create_fragment$z(ctx) {
  let div;
  let textarea;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      textarea = element("textarea");
      textarea.readOnly = true;
      attr(textarea, "class", "svelte-vceii8");
      attr(div, "class", "more-info");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, textarea);
      set_input_value(
        textarea,
        /*log*/
        ctx[0]
      );
      if (!mounted) {
        dispose = listen(
          textarea,
          "input",
          /*textarea_input_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*log*/
      1) {
        set_input_value(
          textarea,
          /*log*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$w($$self, $$props, $$invalidate) {
  let $CrashReport;
  component_subscribe($$self, CrashReport, ($$value) => $$invalidate(2, $CrashReport = $$value));
  let log = "";
  LogStore.subscribe(() => {
    const Log2 = `
--- LOG ---

${compileStringLog().reverse().join("\n")}`;
    const report = $CrashReport;
    const reportStr = report ? `${report.title}

${report.body}
` : "";
    $$invalidate(0, log = `${CrashPrefix}${reportStr}${Log2}`);
  });
  function textarea_input_handler() {
    log = this.value;
    $$invalidate(0, log);
  }
  return [log, textarea_input_handler];
}
class MoreInfo extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$w, create_fragment$z, safe_not_equal, {});
  }
}
const main$2 = "";
function create_else_block$2(ctx) {
  let moreinfo;
  let current;
  moreinfo = new MoreInfo({});
  return {
    c() {
      create_component(moreinfo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(moreinfo, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(moreinfo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(moreinfo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(moreinfo, detaching);
    }
  };
}
function create_if_block_1$1(ctx) {
  let content;
  let updating_moreInfo;
  let current;
  function content_moreInfo_binding(value) {
    ctx[3](value);
  }
  let content_props = { handler: (
    /*handler*/
    ctx[2]
  ) };
  if (
    /*moreInfo*/
    ctx[0] !== void 0
  ) {
    content_props.moreInfo = /*moreInfo*/
    ctx[0];
  }
  content = new Content5({ props: content_props });
  binding_callbacks.push(() => bind$1(content, "moreInfo", content_moreInfo_binding));
  return {
    c() {
      create_component(content.$$.fragment);
    },
    m(target, anchor) {
      mount_component(content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const content_changes = {};
      if (!updating_moreInfo && dirty & /*moreInfo*/
      1) {
        updating_moreInfo = true;
        content_changes.moreInfo = /*moreInfo*/
        ctx2[0];
        add_flush_callback(() => updating_moreInfo = false);
      }
      content.$set(content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(content, detaching);
    }
  };
}
function create_if_block$j(ctx) {
  let vitenotice;
  let t2;
  let div;
  let actions;
  let updating_moreInfo;
  let current;
  vitenotice = new ViteNotice({});
  function actions_moreInfo_binding(value) {
    ctx[4](value);
  }
  let actions_props = { handler: (
    /*handler*/
    ctx[2]
  ) };
  if (
    /*moreInfo*/
    ctx[0] !== void 0
  ) {
    actions_props.moreInfo = /*moreInfo*/
    ctx[0];
  }
  actions = new Actions$2({ props: actions_props });
  binding_callbacks.push(() => bind$1(actions, "moreInfo", actions_moreInfo_binding));
  return {
    c() {
      create_component(vitenotice.$$.fragment);
      t2 = space();
      div = element("div");
      create_component(actions.$$.fragment);
      attr(div, "class", "actions-wrapper");
    },
    m(target, anchor) {
      mount_component(vitenotice, target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      mount_component(actions, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const actions_changes = {};
      if (!updating_moreInfo && dirty & /*moreInfo*/
      1) {
        updating_moreInfo = true;
        actions_changes.moreInfo = /*moreInfo*/
        ctx2[0];
        add_flush_callback(() => updating_moreInfo = false);
      }
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(vitenotice.$$.fragment, local);
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(vitenotice.$$.fragment, local);
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(div);
      }
      destroy_component(vitenotice, detaching);
      destroy_component(actions);
    }
  };
}
function create_fragment$y(ctx) {
  let div0;
  let current_block_type_index;
  let if_block0;
  let t0;
  let div1;
  let t1;
  let processrenderer2;
  let current;
  const if_block_creators = [create_if_block_1$1, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*moreInfo*/
    ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*moreInfo*/
    ctx[0] && create_if_block$j(ctx)
  );
  processrenderer2 = new ProcessRenderer({ props: { handler: (
    /*handler*/
    ctx[2]
  ) } });
  return {
    c() {
      div0 = element("div");
      if_block0.c();
      t0 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      create_component(processrenderer2.$$.fragment);
      attr(div0, "class", "top");
      toggle_class(
        div0,
        "show",
        /*show*/
        ctx[1]
      );
      attr(div1, "class", "bottom");
      toggle_class(
        div1,
        "show",
        /*show*/
        ctx[1]
      );
      toggle_class(
        div1,
        "more-info",
        /*moreInfo*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      if_blocks[current_block_type_index].m(div0, null);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      if (if_block1)
        if_block1.m(div1, null);
      insert(target, t1, anchor);
      mount_component(processrenderer2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div0, null);
      }
      if (!current || dirty & /*show*/
      2) {
        toggle_class(
          div0,
          "show",
          /*show*/
          ctx2[1]
        );
      }
      if (
        /*moreInfo*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*moreInfo*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$j(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*show*/
      2) {
        toggle_class(
          div1,
          "show",
          /*show*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*moreInfo*/
      1) {
        toggle_class(
          div1,
          "more-info",
          /*moreInfo*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(processrenderer2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(processrenderer2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div1);
        detach(t1);
      }
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      destroy_component(processrenderer2, detaching);
    }
  };
}
function instance$v($$self, $$props, $$invalidate) {
  let moreInfo = false;
  let show = false;
  let handler = new ProcessHandler("Crash");
  onMount(async () => {
    await sleep(500);
    $$invalidate(1, show = true);
  });
  function content_moreInfo_binding(value) {
    moreInfo = value;
    $$invalidate(0, moreInfo);
  }
  function actions_moreInfo_binding(value) {
    moreInfo = value;
    $$invalidate(0, moreInfo);
  }
  return [moreInfo, show, handler, content_moreInfo_binding, actions_moreInfo_binding];
}
class Crash extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$v, create_fragment$y, safe_not_equal, {});
  }
}
const observer = new MutationObserver(mutationCallback);
const registered = [];
function attachDisableAnchorRedirection() {
  const anchors = document.querySelectorAll("a");
  for (const anchor of anchors) {
    const href = anchor.getAttribute("href");
    if (registered.includes(anchor) || href.startsWith("@client/"))
      continue;
    registered.push(anchor);
    anchor.addEventListener("click", (e2) => {
      const currentState = PrimaryState.current.get().key;
      e2.preventDefault();
      if (currentState !== "desktop")
        return;
      const shellPid = ProcessStack.getAppPids("ArcShell")[0];
      createErrorDialog(
        {
          title: "Open this page?",
          message: `You're about to leave ArcOS to navigate to <code>${anchor.href}</code> in a <b>new tab</b>. Are you sure you want to continue?`,
          buttons: [
            {
              caption: "Stay here",
              action() {
              }
            },
            {
              caption: "Proceed",
              action() {
                window.open(anchor.href, "_blank");
              },
              suggested: true
            }
          ],
          image: GlobeIcon
        },
        shellPid || 0,
        !!shellPid
      );
    });
  }
}
function mutationCallback(mutationsList) {
  for (let i2 = 0; i2 < mutationsList.length; i2++) {
    const mutation = mutationsList[i2];
    if (mutation.type !== "childList")
      continue;
    attachDisableAnchorRedirection();
  }
}
function preventAnchorRedirects() {
  observer.observe(document.body, { childList: true, subtree: true });
}
function get_each_context$5(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list2[i2];
  return child_ctx;
}
function create_if_block$i(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*data*/
    ctx[0].subItems
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$5(get_each_context$5(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "sub-items shell-colored");
      attr(div, "style", style);
      toggle_class(
        div,
        "show",
        /*showSub*/
        ctx[4]
      );
      toggle_class(
        div,
        "colored",
        /*$UserDataStore*/
        ctx[8].sh.taskbar.colored
      );
      toggle_class(div, "left", screen.availWidth - 300 < /*x*/
      ctx[6] + /*mW*/
      ctx[5]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*data, scopeMap, scope, window, mW, x, hideSubs*/
      239) {
        each_value = ensure_array_like(
          /*data*/
          ctx2[0].subItems
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*showSub*/
      16) {
        toggle_class(
          div,
          "show",
          /*showSub*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*$UserDataStore*/
      256) {
        toggle_class(
          div,
          "colored",
          /*$UserDataStore*/
          ctx2[8].sh.taskbar.colored
        );
      }
      if (!current || dirty & /*screen, x, mW*/
      96) {
        toggle_class(div, "left", screen.availWidth - 300 < /*x*/
        ctx2[6] + /*mW*/
        ctx2[5]);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$5(ctx) {
  let item_1;
  let updating_hideSubs;
  let current;
  function item_1_hideSubs_binding(value) {
    ctx[9](value);
  }
  let item_1_props = {
    data: (
      /*item*/
      ctx[11]
    ),
    scopeMap: (
      /*scopeMap*/
      ctx[2]
    ),
    scope: (
      /*scope*/
      ctx[1]
    ),
    window: (
      /*window*/
      ctx[3]
    ),
    mW: (
      /*mW*/
      ctx[5]
    ),
    x: (
      /*x*/
      ctx[6]
    )
  };
  if (
    /*hideSubs*/
    ctx[7] !== void 0
  ) {
    item_1_props.hideSubs = /*hideSubs*/
    ctx[7];
  }
  item_1 = new Item2({ props: item_1_props });
  binding_callbacks.push(() => bind$1(item_1, "hideSubs", item_1_hideSubs_binding));
  return {
    c() {
      create_component(item_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(item_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const item_1_changes = {};
      if (dirty & /*data*/
      1)
        item_1_changes.data = /*item*/
        ctx2[11];
      if (dirty & /*scopeMap*/
      4)
        item_1_changes.scopeMap = /*scopeMap*/
        ctx2[2];
      if (dirty & /*scope*/
      2)
        item_1_changes.scope = /*scope*/
        ctx2[1];
      if (dirty & /*window*/
      8)
        item_1_changes.window = /*window*/
        ctx2[3];
      if (dirty & /*mW*/
      32)
        item_1_changes.mW = /*mW*/
        ctx2[5];
      if (dirty & /*x*/
      64)
        item_1_changes.x = /*x*/
        ctx2[6];
      if (!updating_hideSubs && dirty & /*hideSubs*/
      128) {
        updating_hideSubs = true;
        item_1_changes.hideSubs = /*hideSubs*/
        ctx2[7];
        add_flush_callback(() => updating_hideSubs = false);
      }
      item_1.$set(item_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(item_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(item_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(item_1, detaching);
    }
  };
}
function create_fragment$x(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*data*/
    ctx[0].subItems && create_if_block$i(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*data*/
        ctx2[0].subItems
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*data*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$i(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
let style = "";
function instance$u($$self, $$props, $$invalidate) {
  let $hideSubs, $$unsubscribe_hideSubs = noop$1, $$subscribe_hideSubs = () => ($$unsubscribe_hideSubs(), $$unsubscribe_hideSubs = subscribe(hideSubs, ($$value) => $$invalidate(10, $hideSubs = $$value)), hideSubs);
  let $UserDataStore;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(8, $UserDataStore = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_hideSubs());
  let { data: data2 } = $$props;
  let { scope = "" } = $$props;
  let { scopeMap } = $$props;
  let { window: window2 = null } = $$props;
  let { showSub = false } = $$props;
  let { mW } = $$props;
  let { x: x2 } = $$props;
  let hideSubs = Store$1(false);
  $$subscribe_hideSubs();
  hideSubs.subscribe((v2) => {
    if (!v2)
      return;
    set_store_value(hideSubs, $hideSubs = false, $hideSubs);
  });
  function item_1_hideSubs_binding(value) {
    hideSubs = value;
    $$subscribe_hideSubs($$invalidate(7, hideSubs));
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data2 = $$props2.data);
    if ("scope" in $$props2)
      $$invalidate(1, scope = $$props2.scope);
    if ("scopeMap" in $$props2)
      $$invalidate(2, scopeMap = $$props2.scopeMap);
    if ("window" in $$props2)
      $$invalidate(3, window2 = $$props2.window);
    if ("showSub" in $$props2)
      $$invalidate(4, showSub = $$props2.showSub);
    if ("mW" in $$props2)
      $$invalidate(5, mW = $$props2.mW);
    if ("x" in $$props2)
      $$invalidate(6, x2 = $$props2.x);
  };
  return [
    data2,
    scope,
    scopeMap,
    window2,
    showSub,
    mW,
    x2,
    hideSubs,
    $UserDataStore,
    item_1_hideSubs_binding
  ];
}
class SubItems extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$u, create_fragment$x, safe_not_equal, {
      data: 0,
      scope: 1,
      scopeMap: 2,
      window: 3,
      showSub: 4,
      mW: 5,
      x: 6
    });
  }
}
function create_else_block$1(ctx) {
  let button;
  let div;
  let t0;
  let span;
  let t1_value = (
    /*data*/
    ctx[0].caption + ""
  );
  let t1;
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*data*/
      ctx2[0].icon
    )
      return create_if_block_3;
    if (
      /*data*/
      ctx2[0].image
    )
      return create_if_block_4;
    return create_else_block_1;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*data*/
    ctx[0].accelerator && create_if_block_2(ctx)
  );
  let if_block2 = !/*disabled*/
  ctx[7] && create_if_block_1(ctx);
  return {
    c() {
      button = element("button");
      div = element("div");
      if_block0.c();
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      attr(div, "class", "inner");
      attr(button, "class", "menu-item");
      button.disabled = /*disabled*/
      ctx[7];
      toggle_class(
        button,
        "active",
        /*active*/
        ctx[6] && !/*data*/
        ctx[0].subItems
      );
      toggle_class(
        button,
        "subitems",
        /*data*/
        ctx[0].subItems && /*data*/
        ctx[0].subItems.length
      );
      toggle_class(
        button,
        "accelerator",
        /*data*/
        ctx[0].accelerator
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div);
      if_block0.m(div, null);
      append(div, t0);
      append(div, span);
      append(span, t1);
      append(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      append(button, t3);
      if (if_block2)
        if_block2.m(button, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*trigger*/
            ctx[9]
          ),
          listen(
            button,
            "mouseenter",
            /*mouseEnter*/
            ctx[10]
          ),
          listen(
            button,
            "mouseleave",
            /*mouseLeave*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div, t0);
        }
      }
      if ((!current || dirty & /*data*/
      1) && t1_value !== (t1_value = /*data*/
      ctx2[0].caption + ""))
        set_data(t1, t1_value);
      if (
        /*data*/
        ctx2[0].accelerator
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!/*disabled*/
      ctx2[7]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*disabled*/
          128) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(button, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*disabled*/
      128) {
        button.disabled = /*disabled*/
        ctx2[7];
      }
      if (!current || dirty & /*active, data*/
      65) {
        toggle_class(
          button,
          "active",
          /*active*/
          ctx2[6] && !/*data*/
          ctx2[0].subItems
        );
      }
      if (!current || dirty & /*data*/
      1) {
        toggle_class(
          button,
          "subitems",
          /*data*/
          ctx2[0].subItems && /*data*/
          ctx2[0].subItems.length
        );
      }
      if (!current || dirty & /*data*/
      1) {
        toggle_class(
          button,
          "accelerator",
          /*data*/
          ctx2[0].accelerator
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$h(ctx) {
  let hr;
  return {
    c() {
      hr = element("hr");
    },
    m(target, anchor) {
      insert(target, hr, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(hr);
      }
    }
  };
}
function create_else_block_1(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "icon");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_4(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      attr(img, "class", "icon");
      if (!src_url_equal(img.src, img_src_value = /*data*/
      ctx[0].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*data*/
      ctx[0].caption);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && !src_url_equal(img.src, img_src_value = /*data*/
      ctx2[0].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*data*/
      1 && img_alt_value !== (img_alt_value = /*data*/
      ctx2[0].caption)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_if_block_3(ctx) {
  let span;
  let t_value = (
    /*data*/
    ctx[0].icon + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "icon material-icons-round");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && t_value !== (t_value = /*data*/
      ctx2[0].icon + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_2(ctx) {
  let span;
  let t_value = (
    /*data*/
    ctx[0].accelerator + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "accelerator");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && t_value !== (t_value = /*data*/
      ctx2[0].accelerator + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1(ctx) {
  let subitems;
  let current;
  subitems = new SubItems({
    props: {
      data: (
        /*data*/
        ctx[0]
      ),
      scopeMap: (
        /*scopeMap*/
        ctx[2]
      ),
      scope: (
        /*scope*/
        ctx[1]
      ),
      window: (
        /*window*/
        ctx[3]
      ),
      showSub: (
        /*showSub*/
        ctx[8]
      ),
      mW: (
        /*mW*/
        ctx[4]
      ),
      x: (
        /*x*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      create_component(subitems.$$.fragment);
    },
    m(target, anchor) {
      mount_component(subitems, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const subitems_changes = {};
      if (dirty & /*data*/
      1)
        subitems_changes.data = /*data*/
        ctx2[0];
      if (dirty & /*scopeMap*/
      4)
        subitems_changes.scopeMap = /*scopeMap*/
        ctx2[2];
      if (dirty & /*scope*/
      2)
        subitems_changes.scope = /*scope*/
        ctx2[1];
      if (dirty & /*window*/
      8)
        subitems_changes.window = /*window*/
        ctx2[3];
      if (dirty & /*showSub*/
      256)
        subitems_changes.showSub = /*showSub*/
        ctx2[8];
      if (dirty & /*mW*/
      16)
        subitems_changes.mW = /*mW*/
        ctx2[4];
      if (dirty & /*x*/
      32)
        subitems_changes.x = /*x*/
        ctx2[5];
      subitems.$set(subitems_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(subitems.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(subitems.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(subitems, detaching);
    }
  };
}
function create_fragment$w(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$h, create_else_block$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*data*/
      ctx2[0].sep
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  let { data: data2 } = $$props;
  let { scope = "" } = $$props;
  let { scopeMap } = $$props;
  let { window: window2 = null } = $$props;
  let { hideSubs } = $$props;
  let { mW } = $$props;
  let { x: x2 } = $$props;
  let active = false;
  let disabled = false;
  let showSub = false;
  async function trigger() {
    if (data2.subItems)
      return;
    if (data2.action)
      data2.action(window2, scopeMap, scope);
    await sleep(50);
    contextData.set(null);
    update2();
  }
  onMount(async () => {
    update2();
    hideSubs.subscribe((v2) => v2 && $$invalidate(8, showSub = false));
    $$invalidate(7, disabled = data2.disabled ? await data2.disabled(window2, scopeMap, scope) : false);
  });
  async function update2() {
    if (!data2.isActive)
      return $$invalidate(6, active = false);
    $$invalidate(6, active = await data2.isActive(window2, scopeMap, scope));
  }
  let inactiveTimer;
  function mouseEnter() {
    hideSubs.set(true);
    clearTimeout(inactiveTimer);
    $$invalidate(8, showSub = true);
  }
  async function mouseLeave() {
    inactiveTimer = setTimeout(
      () => {
        $$invalidate(8, showSub = false);
      },
      1e3
    );
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data2 = $$props2.data);
    if ("scope" in $$props2)
      $$invalidate(1, scope = $$props2.scope);
    if ("scopeMap" in $$props2)
      $$invalidate(2, scopeMap = $$props2.scopeMap);
    if ("window" in $$props2)
      $$invalidate(3, window2 = $$props2.window);
    if ("hideSubs" in $$props2)
      $$invalidate(12, hideSubs = $$props2.hideSubs);
    if ("mW" in $$props2)
      $$invalidate(4, mW = $$props2.mW);
    if ("x" in $$props2)
      $$invalidate(5, x2 = $$props2.x);
  };
  return [
    data2,
    scope,
    scopeMap,
    window2,
    mW,
    x2,
    active,
    disabled,
    showSub,
    trigger,
    mouseEnter,
    mouseLeave,
    hideSubs
  ];
}
class Item2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$t, create_fragment$w, safe_not_equal, {
      data: 0,
      scope: 1,
      scopeMap: 2,
      window: 3,
      hideSubs: 12,
      mW: 4,
      x: 5
    });
  }
}
function get_each_context$4(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list2[i2];
  return child_ctx;
}
function create_if_block$g(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*data*/
    ctx[0].items
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$4(get_each_context$4(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*data, mW, x, hideSubs*/
      101) {
        each_value = ensure_array_like(
          /*data*/
          ctx2[0].items
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$4(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$4(ctx) {
  let item_1;
  let updating_hideSubs;
  let current;
  function item_1_hideSubs_binding(value) {
    ctx[9](value);
  }
  let item_1_props = {
    window: (
      /*data*/
      ctx[0].app
    ),
    scope: (
      /*data*/
      ctx[0].scope
    ),
    scopeMap: (
      /*data*/
      ctx[0].scopeMap
    ),
    data: (
      /*item*/
      ctx[13]
    ),
    mW: (
      /*mW*/
      ctx[6]
    ),
    x: (
      /*x*/
      ctx[2]
    )
  };
  if (
    /*hideSubs*/
    ctx[5] !== void 0
  ) {
    item_1_props.hideSubs = /*hideSubs*/
    ctx[5];
  }
  item_1 = new Item2({ props: item_1_props });
  binding_callbacks.push(() => bind$1(item_1, "hideSubs", item_1_hideSubs_binding));
  return {
    c() {
      create_component(item_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(item_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const item_1_changes = {};
      if (dirty & /*data*/
      1)
        item_1_changes.window = /*data*/
        ctx2[0].app;
      if (dirty & /*data*/
      1)
        item_1_changes.scope = /*data*/
        ctx2[0].scope;
      if (dirty & /*data*/
      1)
        item_1_changes.scopeMap = /*data*/
        ctx2[0].scopeMap;
      if (dirty & /*data*/
      1)
        item_1_changes.data = /*item*/
        ctx2[13];
      if (dirty & /*mW*/
      64)
        item_1_changes.mW = /*mW*/
        ctx2[6];
      if (dirty & /*x*/
      4)
        item_1_changes.x = /*x*/
        ctx2[2];
      if (!updating_hideSubs && dirty & /*hideSubs*/
      32) {
        updating_hideSubs = true;
        item_1_changes.hideSubs = /*hideSubs*/
        ctx2[5];
        add_flush_callback(() => updating_hideSubs = false);
      }
      item_1.$set(item_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(item_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(item_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(item_1, detaching);
    }
  };
}
function create_fragment$v(ctx) {
  let div;
  let current;
  let if_block = (
    /*data*/
    ctx[0] && /*hideSubs*/
    ctx[5] && create_if_block$g(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "context-menu shell-colored");
      set_style(
        div,
        "top",
        /*y*/
        ctx[3] + "px"
      );
      set_style(
        div,
        "left",
        /*x*/
        ctx[2] + "px"
      );
      set_style(
        div,
        "z-index",
        /*$maxZIndex*/
        ctx[8] + 10
      );
      toggle_class(
        div,
        "compact",
        /*$UserDataStore*/
        ctx[7].sh.compactContext
      );
      toggle_class(
        div,
        "colored",
        /*$UserDataStore*/
        ctx[7].sh.taskbar.colored
      );
      toggle_class(
        div,
        "show",
        /*visible*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      ctx[10](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*data*/
        ctx2[0] && /*hideSubs*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*data, hideSubs*/
          33) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$g(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*y*/
      8) {
        set_style(
          div,
          "top",
          /*y*/
          ctx2[3] + "px"
        );
      }
      if (!current || dirty & /*x*/
      4) {
        set_style(
          div,
          "left",
          /*x*/
          ctx2[2] + "px"
        );
      }
      if (!current || dirty & /*$maxZIndex*/
      256) {
        set_style(
          div,
          "z-index",
          /*$maxZIndex*/
          ctx2[8] + 10
        );
      }
      if (!current || dirty & /*$UserDataStore*/
      128) {
        toggle_class(
          div,
          "compact",
          /*$UserDataStore*/
          ctx2[7].sh.compactContext
        );
      }
      if (!current || dirty & /*$UserDataStore*/
      128) {
        toggle_class(
          div,
          "colored",
          /*$UserDataStore*/
          ctx2[7].sh.taskbar.colored
        );
      }
      if (!current || dirty & /*visible*/
      16) {
        toggle_class(
          div,
          "show",
          /*visible*/
          ctx2[4]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      ctx[10](null);
    }
  };
}
function instance$s($$self, $$props, $$invalidate) {
  let $hideSubs, $$unsubscribe_hideSubs = noop$1, $$subscribe_hideSubs = () => ($$unsubscribe_hideSubs(), $$unsubscribe_hideSubs = subscribe(hideSubs, ($$value) => $$invalidate(12, $hideSubs = $$value)), hideSubs);
  let $UserDataStore;
  let $maxZIndex;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(7, $UserDataStore = $$value));
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(8, $maxZIndex = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_hideSubs());
  let data2;
  let menu;
  let x2 = 0;
  let y2 = 0;
  let visible = false;
  let hideSubs = Store$1(false);
  $$subscribe_hideSubs();
  let [mW, mH] = [0, 0];
  hideSubs.subscribe((v2) => {
    v2 && set_store_value(hideSubs, $hideSubs = false, $hideSubs);
  });
  onMount(() => {
    assignContextMenuHooks();
  });
  contextData.subscribe(async (v2) => {
    const current = visible;
    $$invalidate(4, visible = false);
    await sleep(data2 && v2 && current ? 200 : 0);
    if (!v2)
      return;
    $$invalidate(0, data2 = null);
    await sleep();
    $$invalidate(0, data2 = v2);
    await sleep();
    if (!menu)
      return;
    $$invalidate(6, mW = menu.offsetWidth);
    mH = menu.offsetHeight;
    $$invalidate(2, [x2, y2] = composePosition(v2.x, v2.y, mW, mH), x2, $$invalidate(3, y2));
    await sleep();
    $$invalidate(4, visible = !!data2);
  });
  function item_1_hideSubs_binding(value) {
    hideSubs = value;
    $$subscribe_hideSubs($$invalidate(5, hideSubs));
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menu = $$value;
      $$invalidate(1, menu);
    });
  }
  return [
    data2,
    menu,
    x2,
    y2,
    visible,
    hideSubs,
    mW,
    $UserDataStore,
    $maxZIndex,
    item_1_hideSubs_binding,
    div_binding
  ];
}
class ContextMenuRenderer extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$s, create_fragment$v, safe_not_equal, {});
  }
}
const main$1 = "";
function t(t2, r2, n2, e2) {
  var o2, i2 = arguments.length, a2 = i2 < 3 ? r2 : null === e2 ? e2 = Object.getOwnPropertyDescriptor(r2, n2) : e2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    a2 = Reflect.decorate(t2, r2, n2, e2);
  else
    for (var u3 = t2.length - 1; u3 >= 0; u3--)
      (o2 = t2[u3]) && (a2 = (i2 < 3 ? o2(a2) : i2 > 3 ? o2(r2, n2, a2) : o2(r2, n2)) || a2);
  return i2 > 3 && a2 && Object.defineProperty(r2, n2, a2), a2;
}
function r(t2, r2, n2) {
  if (n2 || 2 === arguments.length)
    for (var e2, o2 = 0, i2 = r2.length; o2 < i2; o2++)
      !e2 && o2 in r2 || (e2 || (e2 = Array.prototype.slice.call(r2, 0, o2)), e2[o2] = r2[o2]);
  return t2.concat(e2 || Array.prototype.slice.call(r2));
}
var n = function(t2, r2, n2) {
  return [t2, r2, n2].map(function(t3) {
    return (t3 /= 255) > 0.04045 ? Math.pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92;
  });
}, e = function(t2, r2, n2) {
  return [t2, r2, n2].map(function(t3) {
    return 255 * (t3 <= 304e-5 ? 12.92 * t3 : 1.055 * Math.pow(t3, 1 / 2.4) - 0.055);
  });
}, o = function(t2, r2, n2) {
  return Math.min(Math.max(t2, r2), n2);
}, i = function(t2, r2) {
  return Math.round((t2 + Number.EPSILON) * Math.pow(10, r2)) / Math.pow(10, r2);
}, a = function(t2, r2) {
  return Math.floor(Math.random() * (r2 - t2 + 1) - t2);
}, u2 = function(t2, r2, n2, e2) {
  for (var i2, a2 = [t2, r2, n2], u3 = "#", h2 = 0; h2 < a2.length; h2++)
    u3 += (i2 = a2[h2], Math.round(o(i2, 0, 255)).toString(16).padStart(2, "0"));
  return null != e2 && (u3 += Math.round(o(e2, 0, 100) / 100 * 255).toString(16).padStart(2, "0")), u3;
}, h = function(t2) {
  var n2 = t2.length, e2 = (t2 = function(t3) {
    var r2 = (t3 = /^#/.test(t3) ? t3.slice(1) : t3).length;
    if (![3, 4, 6, 8].includes(r2))
      return "000000";
    if (6 === r2 || 8 === r2)
      return t3;
    if (3 === r2 || 4 === r2) {
      for (var n3 = "", e3 = 0; e3 < r2; e3++) {
        var o3 = t3[e3];
        n3 += "" + o3 + o3;
      }
      return n3;
    }
    return "000000";
  }(t2).padEnd(8, "ff")).match(/.{2}/g);
  if (!e2)
    return [0, 0, 0, 1];
  var o2 = [0, 0, 0], i2 = false;
  return e2.forEach(function(t3, r2) {
    r2 < 3 ? o2[r2] = parseInt(t3, 16) : i2 = 100 * parseInt(t3, 16) / 255;
  }), false === i2 || n2 < 8 ? o2 : r(r([], o2, true), [i2], false);
}, c = function(t2, r2, n2) {
  var e2;
  e2 = [t2, r2, n2].map(function(t3) {
    return t3 / 255;
  }), t2 = e2[0], r2 = e2[1], n2 = e2[2];
  var o2 = 1 - Math.max(t2, r2, n2), i2 = o2 < 1 ? 1 / (1 - o2) : 0;
  return [(1 - t2 - o2) * i2 * 100, (1 - r2 - o2) * i2 * 100, (1 - n2 - o2) * i2 * 100, 100 * o2];
}, l = function(t2, r2, n2, e2) {
  return 100 === e2 ? [0, 0, 0] : (e2 /= 100, [t2, r2, n2].map(function(t3) {
    return (t3 /= 100) >= 1 ? 0 : 255 * (1 - t3) * (1 - e2);
  }));
};
function p(t2, r2, n2, e2) {
  var o2;
  void 0 === e2 && (e2 = "l"), o2 = [t2, r2, n2].map(function(t3) {
    return t3 / 255;
  }), t2 = o2[0], r2 = o2[1], n2 = o2[2];
  var i2 = Math.max(t2, r2, n2), a2 = Math.min(t2, r2, n2), u3 = function(t3, r3, n3, e3) {
    var o3;
    void 0 === e3 && (e3 = false), o3 = [t3, r3, n3].map(function(t4) {
      return t4 / 255;
    }), t3 = o3[0], r3 = o3[1], n3 = o3[2];
    var i3 = Math.max(t3, r3, n3), a3 = Math.min(t3, r3, n3), u4 = 0;
    if (i3 !== a3)
      if (e3)
        u4 = (t3 - r3 + (t3 - n3)) / 2, u4 /= Math.sqrt((t3 - r3) * (t3 - r3) + (t3 - n3) * (r3 - n3)), u4 = Math.acos(u4), n3 > r3 && (u4 = 2 * Math.PI - u4), u4 /= 2 * Math.PI;
      else {
        var h3 = i3 - a3;
        u4 = i3 === t3 ? (r3 - n3) / h3 + (r3 < n3 ? 6 : 0) : i3 === r3 ? (n3 - t3) / h3 + 2 : (t3 - r3) / h3 + 4, u4 /= 6;
      }
    else
      u4 = NaN;
    return 360 * u4;
  }(t2, r2, n2, "i" === e2), h2 = 0, c2 = (i2 + a2) / 2, l2 = i2 - a2, p2 = i2, f2 = (t2 + r2 + n2) / 3;
  return "v" === e2 && (h2 = 0 === i2 ? 0 : l2 / i2), i2 !== a2 && "l" === e2 && (h2 = c2 > 0.5 ? l2 / (2 - i2 - a2) : l2 / (i2 + a2)), "i" === e2 && (h2 = f2 > 0 ? 1 - a2 / f2 : 0), h2 *= 100, c2 *= 100, f2 *= 100, "l" === e2 ? [u3, h2, c2] : "v" === e2 ? [u3, h2, p2 *= 100] : [u3, h2, f2];
}
var f = function(t2, r2, n2) {
  return p(t2, r2, n2, "l");
}, s = function(t2, r2, n2) {
  var e2, i2, a2 = function(t3) {
    return 6 * (t3 = t3 < 0 ? t3 + 1 : t3 > 1 ? t3 - 1 : t3) < 1 ? e2 + (i2 - e2) * t3 * 6 : 2 * t3 < 1 ? i2 : 3 * t3 < 2 ? e2 + (i2 - e2) * (2 / 3 - t3) * 6 : e2;
  };
  return t2 = t2 % 360 / 360, r2 = o(r2 / 100, 0, 1), n2 = o(n2 / 100, 0, 1), e2 = 2 * n2 - (i2 = n2 <= 0.5 ? n2 * (r2 + 1) : n2 + r2 - n2 * r2), [255 * a2(t2 + 1 / 3), 255 * a2(t2), 255 * a2(t2 - 1 / 3)];
}, v = function(t2, r2, n2) {
  return p(t2, r2, n2, "v");
}, b = function(t2, r2, n2) {
  var e2, o2, i2 = [n2 /= 100, n2 * (1 - (r2 /= 100)), n2 * (1 - (o2 = (t2 = t2 % 360 / 360 * 360) / 60 - (e2 = Math.floor(t2 / 60 % 6))) * r2), n2 * (1 - (1 - o2) * r2)], a2 = [[0, 3, 1], [2, 0, 1], [1, 0, 3], [1, 2, 0], [3, 1, 0], [0, 1, 2]];
  return [255 * i2[a2[e2][0]], 255 * i2[a2[e2][1]], 255 * i2[a2[e2][2]]];
}, y = function(t2, r2, n2) {
  return p(t2, r2, n2, "i");
}, d2 = function(t2, r2, n2) {
  var e2, i2, a2, u3;
  r2 /= 100, n2 /= 100, isNaN(t2) && (t2 = 0), isNaN(r2) && (r2 = 0);
  var h2 = function(t3) {
    return (1 + r2 * Math.cos(2 * Math.PI * t3) / Math.cos(Math.PI / 3 - 2 * Math.PI * t3)) / 3;
  };
  return (t2 = (360 + t2) % 360 / 360) < 1 / 3 ? a2 = 1 - ((u3 = (1 - r2) / 3) + (i2 = h2(t2))) : t2 < 2 / 3 ? u3 = 1 - ((i2 = (1 - r2) / 3) + (a2 = h2(t2 -= 1 / 3))) : i2 = 1 - ((a2 = (1 - r2) / 3) + (u3 = h2(t2 -= 2 / 3))), e2 = [i2, a2, u3].map(function(t3) {
    return 255 * o(n2 * t3 * 3, 0, 1);
  }), [i2 = e2[0], a2 = e2[1], u3 = e2[2]];
}, g = function(t2, r2, n2) {
  return [f(t2, r2, n2)[0], 100 * (Math.min(t2, r2, n2) / 255), 100 * (1 - Math.max(t2, r2, n2) / 255)];
};
function w(t2, r2, n2) {
  return r2 /= 100, n2 /= 100, s(t2, 100, 50).map(function(t3) {
    return 255 * (t3 / 255 * (1 - r2 - n2) + r2);
  });
}
var m2 = { x: [0.4124564, 0.3575761, 0.1804375], y: [0.2126729, 0.7151522, 0.072175], z: [0.0193339, 0.119192, 0.9503041] }, M = { r: [3.2404542, -1.5371385, -0.4985314], g: [-0.969266, 1.8760108, 0.041556], b: [0.0556434, -0.2040259, 1.0572252] }, x = 0.95047, _ = 1, C = 1.08883, I = 0.206896552, k = 8856452e-9, E = 24389 / 27, z = function(t2, r2, e2) {
  var o2 = n(t2, r2, e2);
  return [100 * m2.x.reduce(function(t3, r3, n2) {
    return t3 + r3 * o2[n2];
  }, 0), 100 * m2.y.reduce(function(t3, r3, n2) {
    return t3 + r3 * o2[n2];
  }, 0), 100 * m2.z.reduce(function(t3, r3, n2) {
    return t3 + r3 * o2[n2];
  }, 0)];
}, N = function(t2, r2, n2) {
  var o2 = [t2, r2, n2], i2 = M.r.reduce(function(t3, r3, n3) {
    return t3 + r3 * o2[n3];
  }, 0) / 100, a2 = M.g.reduce(function(t3, r3, n3) {
    return t3 + r3 * o2[n3];
  }, 0) / 100, u3 = M.b.reduce(function(t3, r3, n3) {
    return t3 + r3 * o2[n3];
  }, 0) / 100;
  return e(i2, a2, u3);
}, O = function(t2, r2, n2) {
  var e2;
  return e2 = [t2 = t2 / x / 100, r2 = r2 / _ / 100, n2 = n2 / C / 100].map(function(t3) {
    return t3 > k ? Math.pow(t3, 1 / 3) : (E * t3 + 16) / 116;
  }), t2 = e2[0], r2 = e2[1], n2 = e2[2], [Math.max(0, 116 * r2 - 16), 500 * (t2 - r2), 200 * (r2 - n2)];
}, P = function(t2, r2, n2) {
  var e2, o2 = (t2 + 16) / 116, i2 = isNaN(r2) ? o2 : o2 + r2 / 500, a2 = isNaN(n2) ? o2 : o2 - n2 / 200;
  return e2 = [i2, o2, a2].map(function(t3) {
    return t3 > I ? Math.pow(t3, 3) : (116 * t3 - 16) / E;
  }), i2 = e2[0], o2 = e2[1], a2 = e2[2], [i2 * x * 100, o2 * _ * 100, a2 * C * 100];
}, j = function(t2, r2, n2) {
  return N.apply(void 0, P(t2, r2, n2));
}, S = function(t2, r2, n2) {
  r2 = o(r2, -100, 100), n2 = o(n2, -100, 100);
  var e2 = Math.sqrt(r2 * r2 + n2 * n2), i2 = (180 * Math.atan2(n2, r2) / Math.PI + 360) % 360;
  return 0 === Math.round(1e4 * e2) && (i2 = Number.NaN), [t2, e2, i2];
}, A = function(t2, r2, n2) {
  return isNaN(n2) && (n2 = 0), n2 *= Math.PI / 180, [t2, Math.cos(n2) * r2, Math.sin(n2) * r2];
}, L = function(t2, r2, n2) {
  return P.apply(void 0, A(t2, r2, n2));
}, H = function(t2, r2, n2) {
  var e2 = t2 + r2 + n2, o2 = 0, i2 = 0;
  return e2 > 0 && (o2 = t2 / e2, i2 = r2 / e2), [o2, i2, r2];
}, Y = Object.freeze({ __proto__: null, linear2rgb: e, rgb2linear: n, rgb2hex: u2, hex2rgb: h, rgb2cmyk: c, cmyk2rgb: l, rgb2hsl: f, hsl2rgb: s, rgb2hsv: v, hsv2rgb: b, rgb2hsi: y, hsi2rgb: d2, rgb2hwb: g, hwb2rgb: w, rgb2xyz: z, xyz2rgb: N, xyz2lab: O, lab2xyz: P, rgb2lab: function(t2, r2, n2) {
  return O.apply(void 0, z(t2, r2, n2));
}, lab2rgb: j, lch2lab: A, lab2lch: S, xyz2lch: function(t2, r2, n2) {
  return S.apply(void 0, O(t2, r2, n2));
}, lch2xyz: L, xyY2xyz: function(t2, r2, n2) {
  return 0 === r2 ? [0, 0, 0] : [t2 * (n2 / r2), n2, n2 / r2 * (1 - t2 - r2)];
}, xyz2xyY: H });
function R(t2, n2) {
  return void 0 === n2 && (n2 = false), function(e2, o2, i2) {
    var a2 = i2.value;
    i2.value = function() {
      for (var e3 = [], o3 = 0; o3 < arguments.length; o3++)
        e3[o3] = arguments[o3];
      if (e3.length > 0 && n2) {
        var i3 = JSON.stringify(e3);
        t2 += i3;
      }
      if (this.cache.has(t2))
        return this.cache.get(t2);
      var u3 = a2.call.apply(a2, r([this], e3, false));
      return this.cache.set(t2, u3), u3;
    };
  };
}
function q(t2, n2, e2, o2) {
  return void 0 === t2 && (t2 = [0, 2, 2]), void 0 === n2 && (n2 = 0), void 0 === e2 && (e2 = true), void 0 === o2 && (o2 = 0), function(a2, u3, h2) {
    var c2 = h2.value;
    h2.value = function() {
      for (var a3 = [], u4 = 0; u4 < arguments.length; u4++)
        a3[u4] = arguments[u4];
      var h3 = void 0 === a3[o2] ? e2 : a3[o2], l2 = c2.call.apply(c2, r([this], a3, false));
      if (false === h3)
        return l2;
      var p2 = "number" == typeof h3 ? Math.round(h3) : 0, f2 = "number" == typeof t2 ? new Array(l2.length).fill(t2) : t2, s2 = f2.map(function(t3) {
        return 1 === n2 ? "number" == typeof h3 ? p2 : t3 : t3 + p2;
      });
      return l2.map(function(t3, r2) {
        return i(t3, s2[r2]);
      });
    };
  };
}
var D = function(t2, r2, n2) {
  var e2 = t2 instanceof ft ? t2 : new ft(t2), i2 = r2 instanceof ft ? r2 : new ft(r2), a2 = o(n2, 0, 100) / 100, u3 = 2 * a2 - 1, h2 = e2.alpha() - i2.alpha(), c2 = ((u3 * h2 == -1 ? u3 : (u3 + h2) / (1 + u3 * h2)) + 1) / 2, l2 = 1 - c2, p2 = [Math.round(o(e2.red() * c2 + i2.red() * l2, 0, 255)), Math.round(o(e2.green() * c2 + i2.green() * l2, 0, 255)), Math.round(o(e2.blue() * c2 + i2.blue() * l2, 0, 255))], f2 = e2.alpha() * a2 + i2.alpha() * (1 - a2);
  return new ft(p2, f2);
}, F = Math.sqrt, U = Math.pow, $ = Math.cos, J = Math.abs, Z = Math.sin, B = Math.exp, G = Math.atan2, K = Math.PI, Q = function(t2) {
  return K * t2 / 180;
}, T = function(t2, r2, n2) {
  void 0 === n2 && (n2 = true);
  var e2 = G(r2, t2);
  return n2 && (e2 = (e2 = (e2 = 180 * e2 / K) > 0 ? e2 : e2 + 360) > 360 ? e2 - 360 : e2), e2;
}, V = function(t2, r2) {
  void 0 === r2 && (r2 = true);
  var n2 = t2.lab(false), e2 = n2[0], o2 = n2[1], i2 = n2[2];
  return [e2, F(U(o2, 2) + U(i2, 2)), T(o2, i2, r2), o2, i2];
}, W = ["CMC", "CIE", "CIE2000", "CIE1994", "CIE1976"], X = "CMC", tt = "CIE2000", rt = "CIE1994", nt = "CIE1976", et = function(t2, r2, n2, e2) {
  void 0 === n2 && (n2 = "CIE");
  var o2 = function(t3) {
    var r3 = t3.toUpperCase();
    return W.includes(r3) && "CIE" !== r3 ? r3 : tt;
  }(n2);
  if (e2 = e2 || {}, o2 === X) {
    var i2 = Object.assign({}, { l: 1, c: 1 }, e2);
    return function(t3, r3, n3, e3) {
      void 0 === n3 && (n3 = 1), void 0 === e3 && (e3 = 1);
      var o3 = V(t3, true), i3 = o3[0], a3 = o3[1], u4 = o3[2], h3 = o3[3], c3 = o3[4], l2 = V(r3), p2 = l2[0], f2 = l2[1], s2 = l2[3], v2 = a3 - f2, b2 = i3 - p2, y2 = c3 - l2[4], d3 = F(U(h3 - s2, 2) + U(y2, 2) - U(v2, 2)), g2 = i3 < 16 ? 0.511 : 0.040975 * i3 / (1 + 0.01765 * i3), w2 = 0.0638 * a3 / (1 + 0.0131 * a3) + 0.638, m3 = 164 <= u4 && u4 <= 345 ? 0.56 + J(0.2 * $(Q(u4 + 168))) : 0.36 + J(0.4 * $(Q(u4 + 35))), M2 = F(U(a3, 4) / (U(a3, 4) + 1900)), x2 = w2 * (M2 * m3 + 1 - M2);
      return F(U(b2 / (n3 * g2), 2) + U(v2 / (e3 * w2), 2) + U(d3 / x2, 2));
    }(t2, r2, i2.l, i2.c);
  }
  if (o2 === rt) {
    var a2 = { kL: 1, kC: 1, kH: 1, cate: "graphic" }, u3 = Object.assign({}, a2, e2);
    return function(t3, r3, n3, e3, o3, i3) {
      void 0 === n3 && (n3 = 1), void 0 === e3 && (e3 = 1), void 0 === o3 && (o3 = 1), void 0 === i3 && (i3 = "graphic");
      var a3 = "textiles" === i3 ? 0.048 : 0.045, u4 = "textiles" === i3 ? 0.014 : 0.015;
      n3 = "textiles" === i3 ? 2 : n3;
      var h3 = V(t3), c3 = h3[0], l2 = h3[1], p2 = h3[3], f2 = h3[4], s2 = V(r3), v2 = s2[0], b2 = s2[1], y2 = s2[3], d3 = c3 - v2, g2 = l2 - b2, w2 = f2 - s2[4], m3 = 1 + a3 * l2, M2 = 1 + u4 * l2, x2 = F(U(p2 - y2, 2) + U(w2, 2) - U(g2, 2));
      return F(U(d3 / (1 * n3), 2) + U(g2 / (e3 * m3), 2) + U(x2 / (o3 * M2), 2));
    }(t2, r2, u3.kL, u3.kC, u3.kH, u3.cate);
  }
  if (o2 === nt)
    return function(t3, r3) {
      var n3 = t3.lab(false), e3 = n3[0], o3 = n3[1], i3 = n3[2], a3 = r3.lab(false), u4 = a3[0], h3 = a3[1], c3 = a3[2];
      return F(U(e3 - u4, 2) + U(o3 - h3, 2) + U(i3 - c3, 2));
    }(t2, r2);
  var h2 = { kL: 1, kC: 1, kH: 1 }, c2 = Object.assign({}, h2, e2);
  return function(t3, r3, n3, e3, o3) {
    void 0 === n3 && (n3 = 1), void 0 === e3 && (e3 = 1), void 0 === o3 && (o3 = 1);
    var i3 = V(t3), a3 = i3[0], u4 = i3[1], h3 = i3[3], c3 = i3[4], l2 = V(r3), p2 = l2[0], f2 = l2[1], s2 = l2[3], v2 = l2[4], b2 = (a3 + p2) / 2, y2 = (u4 + f2) / 2, d3 = (1 - F(U(y2, 7) / (U(y2, 7) + U(25, 7)))) / 2, g2 = h3 * (1 + d3), w2 = s2 * (1 + d3), m3 = F(U(g2, 2) + U(c3, 2)), M2 = F(U(w2, 2) + U(v2, 2)), x2 = T(g2, c3, true), _2 = T(w2, v2, true), C2 = (m3 + M2) / 2, I2 = J(x2 - _2) > 180 ? (x2 + _2 + 360) / 2 : (x2 + _2) / 2, k2 = 1 - 0.17 * $(Q(I2 - 30)) + 0.24 * $(Q(2 * I2)) + 0.32 * $(Q(3 * I2 + 6)) - 0.2 * $(Q(4 * I2 - 63)), E2 = J(_2 - x2) <= 180 ? _2 - x2 : J(_2 - x2) > 180 && _2 <= x2 ? _2 - x2 + 360 : _2 - x2 - 360, z2 = p2 - a3, N2 = f2 - u4, O2 = 2 * F(m3 * M2) * Z(Q(E2) / 2), P2 = 1 + 0.015 * U(b2 - 50, 2) / F(20 + U(b2 - 50, 2)), j2 = 1 + 0.045 * C2, S2 = 1 + 0.015 * C2 * k2, A2 = 30 * B(-U((I2 - 275) / 25, 2)), L2 = -2 * F(U(C2, 7) / (U(C2, 7) + U(25, 7))) * Z(2 * Q(A2));
    return F(U(z2 / (n3 * P2), 2) + U(N2 / (e3 * j2), 2) + U(O2 / (o3 * S2), 2) + L2 * (N2 / (e3 * j2)) * (O2 / (o3 * S2)));
  }(t2, r2, c2.kL, c2.kC, c2.kH);
}, ot = function(t2, r2, n2) {
  var e2 = Math.abs, o2 = Math.max, i2 = Math.min, a2 = t2 instanceof ft ? t2 : new ft(t2), u3 = r2 instanceof ft ? r2 : new ft(r2), h2 = Object.assign({}, { b: 125, c: 500 }, n2);
  return !(e2(255 * a2.brightness() / 100 - 255 * u3.brightness() / 100) <= h2.b) && !(o2(a2.red(), u3.red()) - i2(a2.red(), u3.red()) + (o2(a2.green(), u3.green()) - i2(a2.green(), u3.green())) + (o2(a2.blue(), u3.blue()) - i2(a2.blue(), u3.blue())) <= h2.c);
}, it = function(t2, r2, n2) {
  var e2, i2 = function(t3) {
    return o(t3, 0, 100);
  }, a2 = function(t3) {
    return o(t3, 0, 255);
  }, u3 = { h: [0, function(t3) {
    return t3 % 360;
  }], s: [1, i2], l: [2, i2], r: [0, a2], g: [1, a2], b: [2, a2] }, h2 = u3[r2][0];
  if (["h", "s", "l"].includes(r2)) {
    var c2 = t2.hsl();
    if (void 0 === n2)
      return c2[h2];
    n2 = u3[r2][1](n2), c2[h2] = n2, e2 = s.apply(void 0, c2);
  } else {
    if (e2 = t2.rgb(), void 0 === n2)
      return e2[h2];
    n2 = u3[r2][1](n2), e2[h2] = n2;
  }
  return new ft(e2, t2.alpha());
}, at = {}, ut = /* @__PURE__ */ new Set(["rgb", "rgba", "cmyk", "lab", "hsl", "hsla", "hsv", "hsva", "hsi", "hsia", "xyz", "lch", "hwb", "hwba"]), ht = /^([a-zA-Z]+)\(([\s\S]+)\)$/, ct = function(t2) {
  return "string" == typeof t2 ? -1 === t2.indexOf("%") ? ct(Number(t2.trim())) : (t2 = t2.split("%")[0], (t2 = Number(t2.trim())) || 0) : Math.abs(t2) < 1 ? 100 * t2 : t2;
}, lt = function(t2, r2) {
  void 0 === r2 && (r2 = /* @__PURE__ */ new Set());
  var n2 = "string" == typeof t2 ? t2 : t2.join(",");
  if (r2.has(n2))
    throw new Error("Invalid Color");
  r2.add(n2);
  var e2 = "rgb", o2 = [0, 0, 0], i2 = 100;
  if (Array.isArray(t2)) {
    if (t2.length < 3)
      throw new Error("Invalid Color");
    for (var a2 = 0; a2 < t2.length; a2++)
      if (a2 < 3)
        o2[a2] = t2[a2];
      else {
        if (3 !== a2 || void 0 === t2[3])
          break;
        i2 = t2[3];
      }
  } else {
    var u3 = false, c2 = t2.trim().match(ht);
    if (c2 || (u3 = true), c2) {
      var l2 = c2[1].toLocaleLowerCase();
      if (e2 = l2, ut.has(l2) || (u3 = true), c2[2] && !u3) {
        var p2 = c2[2], f2 = -1 !== p2.indexOf(",") ? "," : " ", s2 = p2.split(f2);
        for (a2 = 0; a2 < 3; a2++)
          void 0 !== s2[a2] && (["lch", "lab"].includes(e2) && 0 === a2 || ["hsl", "hsla", "hsv", "hsva", "hwb", "hwba", "hsi", "hsia"].includes(e2) && a2 > 0 ? o2[a2] = ct(s2[a2]) : o2[a2] = Number(s2[a2].trim()));
        ["rgba", "hsla", "hsva", "hwba", "hsia"].includes(e2) ? (e2 = e2.slice(0, -1), void 0 !== s2[3] && (i2 = ct(s2[3]))) : "cmyk" === e2 && o2.push(void 0 !== s2[3] ? ct(s2[3]) : 0);
      }
    }
    if (u3) {
      if (!/^#(([a-fA-F\d]{3}){1,2}|[a-fA-F\d]{8})$/.test(t2))
        try {
          return t2 = function(t3, r3) {
            if (void 0 === r3 && (r3 = false), t3 = t3.toLowerCase(), void 0 === at[t3]) {
              if (r3)
                throw new Error("Unknown color name: ".concat(t3, ")"));
              return t3;
            }
            return at[t3];
          }(t2, true), lt(t2, r2);
        } catch (t3) {
          throw new Error("Invalid Color");
        }
      o2 = h(t2);
    }
  }
  return [e2, o2, i2];
}, pt = { thowParseError: false }, ft = function() {
  function n2(t2, r2, n3) {
    this.cache = /* @__PURE__ */ new Map(), this._rgb = [0, 0, 0], this._alpha = 100;
    var e2 = { thowParseError: pt.thowParseError }, i2 = Object.assign({}, e2, null != n3 ? n3 : {});
    try {
      var a2 = function(t3) {
        var r3, n4 = { lab2rgb: j, hsl2rgb: s, hsv2rgb: b, xyz2rgb: N, hwb2rgb: w, hsi2rgb: d2 }, e3 = lt(t3), i3 = e3[0], a3 = e3[1], u4 = e3[2];
        if ("rgb" === i3)
          return [a3, u4];
        "lch" === i3 && (i3 = (r3 = ["xyz", L(a3[0], a3[1], a3[2])])[0], a3 = r3[1]);
        var h3 = a3[0], c2 = a3[1], p2 = a3[2], f2 = a3[3];
        if ("cmyk" === i3)
          return [l(h3, c2, p2, f2).map(function(t4) {
            return o(t4, 0, 255);
          }), u4];
        var v2 = "".concat(i3, "2rgb");
        if ("function" == typeof n4[v2])
          return [n4[v2](h3, c2, p2).map(function(t4) {
            return o(t4, 0, 255);
          }), u4];
        throw new Error("Invalid color");
      }(t2), u3 = a2[0], h2 = a2[1];
      this._alpha = h2, this._rgb = u3;
    } catch (t3) {
      if (i2.thowParseError)
        throw t3;
    }
    void 0 !== r2 && (this._alpha = o(r2, 0, 100));
  }
  return n2.prototype.red = function(t2) {
    return it(this, "r", t2);
  }, n2.prototype.green = function(t2) {
    return it(this, "g", t2);
  }, n2.prototype.blue = function(t2) {
    return it(this, "b", t2);
  }, n2.prototype.alpha = function(t2) {
    return void 0 === t2 ? this._alpha : (t2 = o(t2, 0, 100), new n2(this.rgb(), t2));
  }, n2.prototype.fadeIn = function(t2, r2) {
    return void 0 === t2 && (t2 = 10), t2 = r2 && "relative" === r2 ? this._alpha * t2 / 100 : t2, new n2(this.rgb(), o(this._alpha + t2, 0, 100));
  }, n2.prototype.fadeOut = function(t2, r2) {
    return void 0 === t2 && (t2 = 10), t2 = r2 && "relative" === r2 ? this._alpha * t2 / 100 : t2, new n2(this.rgb(), o(this._alpha - t2, 0, 100));
  }, n2.prototype.opacify = function(t2, r2) {
    return void 0 === t2 && (t2 = 10), this.fadeIn(t2, r2);
  }, n2.prototype.transparentize = function(t2, r2) {
    return void 0 === t2 && (t2 = 10), this.fadeOut(t2, r2);
  }, n2.prototype.hue = function(t2) {
    return it(this, "h", t2);
  }, n2.prototype.saturation = function(t2) {
    return it(this, "s", t2);
  }, n2.prototype.lightness = function(t2) {
    return it(this, "l", t2);
  }, n2.prototype.rgb = function(t2) {
    return r([], this._rgb, true);
  }, n2.prototype.rgba = function(t2) {
    return r(r([], this.rgb(false), true), [this._alpha], false);
  }, n2.prototype.cmyk = function(t2) {
    return c.apply(void 0, this._rgb);
  }, n2.prototype.hsl = function(t2) {
    return f.apply(void 0, this._rgb);
  }, n2.prototype.hsla = function(t2) {
    return r(r([], this.hsl(false), true), [this._alpha], false);
  }, n2.prototype.hsv = function(t2) {
    return v.apply(void 0, this._rgb);
  }, n2.prototype.hsi = function(t2) {
    return y.apply(void 0, this._rgb);
  }, n2.prototype.hwb = function(t2) {
    return g.apply(void 0, this._rgb);
  }, n2.prototype.xyz = function(t2) {
    return z.apply(void 0, this._rgb);
  }, n2.prototype.lab = function(t2) {
    return O.apply(void 0, this.xyz(false));
  }, n2.prototype.lch = function(t2) {
    return S.apply(void 0, this.lab(false));
  }, n2.prototype.xyY = function(t2) {
    return H.apply(void 0, this.xyz(false));
  }, n2.prototype.hex = function(t2) {
    void 0 === t2 && (t2 = 2);
    var n3 = 0 === t2 ? void 0 : 1 === t2 ? this._alpha : 100 === this._alpha ? void 0 : this._alpha, e2 = "color:hex:param_".concat(t2);
    if (this.cache.has(e2))
      return this.cache.get(e2);
    var o2 = u2.apply(void 0, r(r([], this._rgb, false), [n3], false));
    return this.cache.set(e2, o2), o2;
  }, n2.prototype.lighten = function(t2, r2) {
    void 0 === t2 && (t2 = 5);
    var e2 = this.hsl(false), i2 = e2[0], a2 = e2[1], u3 = e2[2];
    return u3 = o(u3 += void 0 !== r2 && "relative" === r2 ? u3 * (t2 / 100) : t2, 0, 100), new n2(s(i2, a2, u3), this._alpha);
  }, n2.prototype.darken = function(t2, r2) {
    return void 0 === t2 && (t2 = 5), this.lighten(-t2, r2);
  }, n2.prototype.saturate = function(t2, r2) {
    void 0 === t2 && (t2 = 5);
    var e2 = this.hsl(false), i2 = e2[0], a2 = e2[1], u3 = e2[2];
    return a2 = o(a2 += void 0 !== r2 && "relative" === r2 ? a2 * (t2 / 100) : t2, 0, 100), new n2(s(i2, a2, u3), this._alpha);
  }, n2.prototype.desaturate = function(t2, r2) {
    return void 0 === t2 && (t2 = 5), this.saturate(-t2, r2);
  }, n2.prototype.spin = function(t2) {
    var r2 = this.hsl(false), e2 = r2[0], o2 = r2[1], i2 = r2[2];
    return new n2(s(e2 = (e2 + t2 % 360 + 360) % 360, o2, i2), this._alpha);
  }, n2.prototype.adjustHue = function(t2) {
    return this.spin(t2);
  }, n2.prototype.complement = function() {
    return this.spin(180);
  }, n2.prototype.invert = function() {
    var t2 = this._rgb.map(function(t3) {
      return 255 - t3;
    });
    return new n2([t2[0], t2[1], t2[2]], this._alpha);
  }, n2.prototype.mix = function(t2, r2) {
    return void 0 === r2 && (r2 = 50), D(this, t2, 100 - o(r2, 0, 100));
  }, n2.prototype.luma = function() {
    var t2 = this._rgb.map(function(t3) {
      return (t3 /= 255) <= 0.03928 ? t3 / 12.92 : Math.pow((t3 + 0.055) / 1.055, 2.4);
    });
    return 0.2126 * t2[0] + 0.7152 * t2[1] + 0.0722 * t2[2];
  }, n2.prototype.brightness = function() {
    var t2 = this._rgb;
    return function(t3, r2, n3) {
      return (299 * t3 + 587 * r2 + 114 * n3) / 1e3 / 255 * 100;
    }(t2[0], t2[1], t2[2]);
  }, n2.prototype.deltaE = function(t2, r2, n3) {
    return void 0 === r2 && (r2 = "CMC"), et(this, t2, r2, n3);
  }, n2.prototype.visibility = function(t2, r2) {
    return ot(this, t2, r2);
  }, t([q(0, 1, true, 0), R("color:rgb")], n2.prototype, "rgb", null), t([q(0, 1, true, 0)], n2.prototype, "rgba", null), t([q(0, 1, true, 0), R("color:cmyk")], n2.prototype, "cmyk", null), t([q(0, 1, true, 0), R("color:hsl")], n2.prototype, "hsl", null), t([q(0, 1, true, 0)], n2.prototype, "hsla", null), t([q(0, 1, true, 0), R("color:hsv")], n2.prototype, "hsv", null), t([q(0, 1, true, 0), R("color:hsi")], n2.prototype, "hsi", null), t([q(0, 1, true, 0), R("color: hwb")], n2.prototype, "hwb", null), t([q(2, 1, true, 0), R("color:xyz")], n2.prototype, "xyz", null), t([q(2, 1, true, 0), R("color:lab")], n2.prototype, "lab", null), t([q(2, 1, true, 0), R("color:lch")], n2.prototype, "lch", null), t([q(2, 1, true, 0), R("color:xyY")], n2.prototype, "xyY", null), t([R("color:luma")], n2.prototype, "luma", null), n2;
}(), st = function(t2, r2, n2, e2) {
  return new ft([t2, r2, n2], e2);
}, vt = function(t2, r2, n2, e2) {
  return new ft(s(t2, r2, n2), e2);
}, bt = function(t2, r2, n2, e2) {
  return new ft(b(t2, r2, n2), e2);
}, yt = function(t2, r2, n2, e2) {
  return new ft(d2(t2, r2, n2), e2);
}, dt = function(t2, r2, n2, e2) {
  return new ft(w(t2, r2, n2), e2);
}, gt = function(t2, r2, n2, e2) {
  return new ft(N(t2, r2, n2), e2);
}, wt = function(t2, r2, n2, e2) {
  return new ft(j(t2, r2, n2), e2);
}, mt = function(t2, r2, n2, e2) {
  return new ft(N.apply(void 0, L(t2, r2, n2)), e2);
};
function Mt(t2, r2, n2) {
  return new ft(t2, r2, n2);
}
Mt.config = function(t2) {
  Object.assign(pt, t2);
}, Mt.random = function() {
  var t2 = a(0, 255), r2 = a(0, 255), n2 = a(0, 255);
  return new ft([t2, r2, n2]);
}, Mt.convertor = Y, Mt.Color = ft, Mt.rgb = st, Mt.hsl = vt, Mt.hsv = bt, Mt.hsi = yt, Mt.hwb = dt, Mt.xyz = gt, Mt.lab = wt, Mt.lch = mt, Mt.mix = D, Mt.deltaE = et, Mt.utils = { roundDecimal: i, randomRange: a }, Mt.useNames = function(t2, r2) {
  return function(t3, r3) {
    if (void 0 !== r3 && "function" == typeof r3) {
      var n2 = {};
      for (var e2 in t3) {
        var o2 = r3(e2, t3[e2]), i2 = o2[0], a2 = o2[1];
        n2[i2] = a2;
      }
      Object.assign(at, n2);
    } else
      Object.assign(at, t3);
  }(t2, r2), Mt;
};
function lightenColor(color, modifier = 5) {
  return Mt(`#${color}`).lighten(modifier, "relative").hex();
}
function hex3to6(color) {
  return Mt(`#${color}`).hex();
}
function darkenColor(color, modifier = 5) {
  return Mt(`#${color}`).darken(modifier, "relative").hex();
}
function invertColor(hex) {
  hex = hex.replace("#", "");
  if (hex.length !== 6)
    return hex;
  return `#${(Number(`0x1${hex}`) ^ 16777215).toString(16).substring(1).toUpperCase()}`;
}
function DesktopStyle() {
  const style2 = Store$1();
  const accent = Store$1();
  const theme = Store$1();
  let previous = "";
  let bgUrl = "";
  async function getWall(data2) {
    if (!data2)
      return;
    const wallpaper = data2.sh.desktop.wallpaper;
    if (previous == wallpaper)
      return;
    previous = wallpaper;
    const u3 = (await getWallpaper(wallpaper)).url;
    if (u3 != bgUrl)
      bgUrl = u3;
    return bgUrl;
  }
  function getStyle(data2) {
    if (!data2)
      return;
    const a2 = data2.sh.desktop.accent || "70D6FF";
    const t2 = data2.sh.desktop.theme || "dark";
    accent.set(a2);
    theme.set(t2);
    const css = `
    --accent: ${hex3to6(a2)} !important;
    --accent-transparent: ${hex3to6(a2)}44 !important;
    --accent-light: ${lightenColor(a2)} !important;
    --accent-lighter: ${lightenColor(a2, 6.5)} !important;
    --accent-dark: ${darkenColor(a2, 75)} !important;
    --accent-darkest: ${darkenColor(a2, 85)} !important;
    --accent-light-transparent: ${lightenColor(a2)}77 !important;
    --accent-light-invert: ${invertColor(lightenColor(a2))} !important;
    --wallpaper: url(${bgUrl});`;
    return css;
  }
  UserDataStore.subscribe(async (v2) => {
    await getWall(v2);
    const css = getStyle(v2);
    style2.set(css);
  });
  return { style: style2, accent, theme };
}
function create_if_block$f(ctx) {
  let div;
  let processrenderer2;
  let t2;
  let contextmenurenderer;
  let div_class_value;
  let div_style_value;
  let current;
  processrenderer2 = new ProcessRenderer({});
  contextmenurenderer = new ContextMenuRenderer({});
  return {
    c() {
      div = element("div");
      create_component(processrenderer2.$$.fragment);
      t2 = space();
      create_component(contextmenurenderer.$$.fragment);
      attr(div, "class", div_class_value = "desktop theme-" + /*$SafeMode*/
      (ctx[3] ? "dark" : (
        /*$theme*/
        ctx[4]
      )) + " cursor-" + /*$UserDataStore*/
      (ctx[2].sh.desktop.noCustomCursor ? "" : "custom"));
      attr(div, "style", div_style_value = /*$SafeMode*/
      ctx[3] ? SafeModeStyle : (
        /*$style*/
        ctx[5]
      ));
      toggle_class(
        div,
        "safemode",
        /*$SafeMode*/
        ctx[3]
      );
      toggle_class(
        div,
        "show",
        /*show*/
        ctx[1]
      );
      toggle_class(
        div,
        "sharp",
        /*$SafeMode*/
        ctx[3] || /*$UserDataStore*/
        ctx[2].sh.desktop.sharp
      );
      toggle_class(
        div,
        "noani",
        /*$SafeMode*/
        ctx[3] || !/*$UserDataStore*/
        ctx[2].sh.anim
      );
      toggle_class(
        div,
        "noglass",
        /*$SafeMode*/
        ctx[3] || /*$UserDataStore*/
        ctx[2].sh.noGlass
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(processrenderer2, div, null);
      append(div, t2);
      mount_component(contextmenurenderer, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*$SafeMode, $theme, $UserDataStore*/
      28 && div_class_value !== (div_class_value = "desktop theme-" + /*$SafeMode*/
      (ctx2[3] ? "dark" : (
        /*$theme*/
        ctx2[4]
      )) + " cursor-" + /*$UserDataStore*/
      (ctx2[2].sh.desktop.noCustomCursor ? "" : "custom"))) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*$SafeMode, $style*/
      40 && div_style_value !== (div_style_value = /*$SafeMode*/
      ctx2[3] ? SafeModeStyle : (
        /*$style*/
        ctx2[5]
      ))) {
        attr(div, "style", div_style_value);
      }
      if (!current || dirty & /*$SafeMode, $theme, $UserDataStore, $SafeMode*/
      28) {
        toggle_class(
          div,
          "safemode",
          /*$SafeMode*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*$SafeMode, $theme, $UserDataStore, show*/
      30) {
        toggle_class(
          div,
          "show",
          /*show*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*$SafeMode, $theme, $UserDataStore, $SafeMode, $UserDataStore*/
      28) {
        toggle_class(
          div,
          "sharp",
          /*$SafeMode*/
          ctx2[3] || /*$UserDataStore*/
          ctx2[2].sh.desktop.sharp
        );
      }
      if (!current || dirty & /*$SafeMode, $theme, $UserDataStore, $SafeMode, $UserDataStore*/
      28) {
        toggle_class(
          div,
          "noani",
          /*$SafeMode*/
          ctx2[3] || !/*$UserDataStore*/
          ctx2[2].sh.anim
        );
      }
      if (!current || dirty & /*$SafeMode, $theme, $UserDataStore, $SafeMode, $UserDataStore*/
      28) {
        toggle_class(
          div,
          "noglass",
          /*$SafeMode*/
          ctx2[3] || /*$UserDataStore*/
          ctx2[2].sh.noGlass
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(processrenderer2.$$.fragment, local);
      transition_in(contextmenurenderer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(processrenderer2.$$.fragment, local);
      transition_out(contextmenurenderer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(processrenderer2);
      destroy_component(contextmenurenderer);
    }
  };
}
function create_fragment$u(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$UserDataStore*/
    ctx[2] && /*render*/
    ctx[0] && create_if_block$f(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$UserDataStore*/
        ctx2[2] && /*render*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$UserDataStore, render*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$f(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$r($$self, $$props, $$invalidate) {
  let $UserDataStore;
  let $SafeMode;
  let $theme;
  let $style;
  component_subscribe($$self, UserDataStore, ($$value) => $$invalidate(2, $UserDataStore = $$value));
  component_subscribe($$self, SafeMode, ($$value) => $$invalidate(3, $SafeMode = $$value));
  let render = false;
  let show = false;
  let { style: style2, theme } = DesktopStyle();
  component_subscribe($$self, style2, (value) => $$invalidate(5, $style = value));
  component_subscribe($$self, theme, (value) => $$invalidate(4, $theme = value));
  onMount(async () => {
    await loadBuiltinApps();
    await StartCoreProcesses();
    await startInitialServices();
    preventAnchorRedirects();
    ArcSoundBus.playSound("arcos.system.logon");
    $$invalidate(0, render = true);
    await sleep(200);
    $$invalidate(1, show = true);
    if (!$UserDataStore.acc.v6) {
      await alignDesktopIcons();
      sendNotification({
        title: "Welcome to ArcOS v6!",
        message: "Your ArcOS account has been updated to work with ArcOS v6. In order to accomplish this, we had to reset your desktop icons to work with the new apps.",
        image: GlowingLogo$1
      });
      set_store_value(UserDataStore, $UserDataStore.acc.v6 = true, $UserDataStore);
    }
  });
  GlobalDispatch.subscribe("desktop-hide", () => {
    $$invalidate(1, show = false);
  });
  GlobalDispatch.subscribe("desktop-show", () => $$invalidate(1, show = true));
  return [render, show, $UserDataStore, $SafeMode, $theme, $style, style2, theme];
}
class Desktop2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$r, create_fragment$u, safe_not_equal, {});
  }
}
const advancedOptions = [
  {
    action: async () => {
      await loadApp("ArcTerm", ArcTermApp);
      spawnApp("ArcTerm", 0);
    },
    description: "Debug technical problems using ArcOS' terminal",
    name: "Launch ArcTerm",
    image: ArcTermIcon
  },
  {
    action: async () => {
      await loadApp("SubmitBugReport", { ...Creator2, isOverlay: false, glass: true });
      spawnApp("SubmitBugReport", 0);
    },
    description: "Found something wrong? Tell us about it!",
    name: "Submit a bug report",
    image: BugReportIcon
  },
  {
    action: (handler) => {
      handler.navigate("welcome");
    },
    description: "Return to the Welcome page",
    name: "Go back",
    image: HomeIcon
  }
];
function create_if_block$e(ctx) {
  let img_1;
  let img_1_src_value;
  return {
    c() {
      img_1 = element("img");
      if (!src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx[0]))
        attr(img_1, "src", img_1_src_value);
      attr(img_1, "alt", "");
      attr(img_1, "class", "image");
    },
    m(target, anchor) {
      insert(target, img_1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*img*/
      1 && !src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx2[0])) {
        attr(img_1, "src", img_1_src_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img_1);
      }
    }
  };
}
function create_fragment$t(ctx) {
  let div1;
  let t2;
  let div0;
  let current;
  let if_block = (
    /*img*/
    ctx[0] && create_if_block$e(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t2 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "slot");
      toggle_class(
        div0,
        "flex",
        /*flex*/
        ctx[2]
      );
      attr(div1, "class", "header");
      toggle_class(
        div1,
        "noMargin",
        /*noMargin*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t2);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*img*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$e(ctx2);
          if_block.c();
          if_block.m(div1, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*flex*/
      4) {
        toggle_class(
          div0,
          "flex",
          /*flex*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*noMargin*/
      2) {
        toggle_class(
          div1,
          "noMargin",
          /*noMargin*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$q($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { img = "" } = $$props;
  let { noMargin = false } = $$props;
  let { flex = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("img" in $$props2)
      $$invalidate(0, img = $$props2.img);
    if ("noMargin" in $$props2)
      $$invalidate(1, noMargin = $$props2.noMargin);
    if ("flex" in $$props2)
      $$invalidate(2, flex = $$props2.flex);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [img, noMargin, flex, $$scope, slots];
}
class Header13 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$q, create_fragment$t, safe_not_equal, { img: 0, noMargin: 1, flex: 2 });
  }
}
function create_if_block$d(ctx) {
  let button;
  let img;
  let img_src_value;
  let t0;
  let div;
  let p0;
  let t1_value = (
    /*option*/
    ctx[0].name + ""
  );
  let t1;
  let t2;
  let p1;
  let t3_value = (
    /*option*/
    ctx[0].description + ""
  );
  let t3;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      div = element("div");
      p0 = element("p");
      t1 = text(t1_value);
      t2 = space();
      p1 = element("p");
      t3 = text(t3_value);
      if (!src_url_equal(img.src, img_src_value = /*option*/
      ctx[0].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(p0, "class", "title");
      attr(p1, "class", "description");
      attr(button, "class", "advanced-option");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, div);
      append(div, p0);
      append(p0, t1);
      append(div, t2);
      append(div, p1);
      append(p1, t3);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*option*/
      1 && !src_url_equal(img.src, img_src_value = /*option*/
      ctx2[0].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*option*/
      1 && t1_value !== (t1_value = /*option*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*option*/
      1 && t3_value !== (t3_value = /*option*/
      ctx2[0].description + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$s(ctx) {
  let if_block_anchor;
  let if_block = (
    /*option*/
    ctx[0] && create_if_block$d(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*option*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$d(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  let { option } = $$props;
  let { handler } = $$props;
  const click_handler = async () => await option.action(handler);
  $$self.$$set = ($$props2) => {
    if ("option" in $$props2)
      $$invalidate(0, option = $$props2.option);
    if ("handler" in $$props2)
      $$invalidate(1, handler = $$props2.handler);
  };
  return [option, handler, click_handler];
}
class AdvancedOption extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$p, create_fragment$s, safe_not_equal, { option: 0, handler: 1 });
  }
}
function get_each_context$3(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2];
  return child_ctx;
}
function create_default_slot$6(ctx) {
  let h1;
  let t1;
  let p2;
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Advanced Options";
      t1 = space();
      p2 = element("p");
      p2.textContent = "Choose one of the following options to continue:";
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      insert(target, t1, anchor);
      insert(target, p2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(h1);
        detach(t1);
        detach(p2);
      }
    }
  };
}
function create_each_block$3(ctx) {
  let advancedoption;
  let current;
  advancedoption = new AdvancedOption({
    props: {
      option: (
        /*option*/
        ctx[1]
      ),
      handler: (
        /*handler*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(advancedoption.$$.fragment);
    },
    m(target, anchor) {
      mount_component(advancedoption, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const advancedoption_changes = {};
      if (dirty & /*handler*/
      1)
        advancedoption_changes.handler = /*handler*/
        ctx2[0];
      advancedoption.$set(advancedoption_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(advancedoption.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(advancedoption.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(advancedoption, detaching);
    }
  };
}
function create_fragment$r(ctx) {
  let div1;
  let header2;
  let t2;
  let div0;
  let current;
  header2 = new Header13({
    props: {
      noMargin: true,
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    }
  });
  let each_value = ensure_array_like(advancedOptions);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$3(get_each_context$3(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div1 = element("div");
      create_component(header2.$$.fragment);
      t2 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div0, "class", "options");
      attr(div1, "class", "advanced-content");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(header2, div1, null);
      append(div1, t2);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const header_changes = {};
      if (dirty & /*$$scope*/
      16) {
        header_changes.$$scope = { dirty, ctx: ctx2 };
      }
      header2.$set(header_changes);
      if (dirty & /*handler*/
      1) {
        each_value = ensure_array_like(advancedOptions);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(header2);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  let { handler } = $$props;
  $$self.$$set = ($$props2) => {
    if ("handler" in $$props2)
      $$invalidate(0, handler = $$props2.handler);
  };
  return [handler];
}
class Advanced extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$o, create_fragment$r, safe_not_equal, { handler: 0 });
  }
}
function create_fragment$q(ctx) {
  let div1;
  let div0;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "inner");
      attr(div1, "class", "actions");
      toggle_class(
        div1,
        "right",
        /*right*/
        ctx[0]
      );
      toggle_class(
        div1,
        "inline",
        /*inline*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*right*/
      1) {
        toggle_class(
          div1,
          "right",
          /*right*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*inline*/
      2) {
        toggle_class(
          div1,
          "inline",
          /*inline*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { right = false } = $$props;
  let { inline: inline2 = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("right" in $$props2)
      $$invalidate(0, right = $$props2.right);
    if ("inline" in $$props2)
      $$invalidate(1, inline2 = $$props2.inline);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [right, inline2, $$scope, slots];
}
let Actions$1 = class Actions7 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$n, create_fragment$q, safe_not_equal, { right: 0, inline: 1 });
  }
};
function create_fragment$p(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(button, "class", "action");
      button.disabled = /*disabled*/
      ctx[1];
      toggle_class(
        button,
        "suggested",
        /*suggested*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*fun*/
            ctx[2]
          ))
            ctx[2].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*disabled*/
      2) {
        button.disabled = /*disabled*/
        ctx[1];
      }
      if (!current || dirty & /*suggested*/
      1) {
        toggle_class(
          button,
          "suggested",
          /*suggested*/
          ctx[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$m($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { suggested = false } = $$props;
  let { disabled = false } = $$props;
  let { fun } = $$props;
  $$self.$$set = ($$props2) => {
    if ("suggested" in $$props2)
      $$invalidate(0, suggested = $$props2.suggested);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("fun" in $$props2)
      $$invalidate(2, fun = $$props2.fun);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [suggested, disabled, fun, $$scope, slots];
}
class Action extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$m, create_fragment$p, safe_not_equal, { suggested: 0, disabled: 1, fun: 2 });
  }
}
function create_default_slot_2$5(ctx) {
  let h1;
  let t1;
  let p2;
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Couldn't connect";
      t1 = space();
      p2 = element("p");
      p2.textContent = "We didn't hear back from our server";
      attr(p2, "class", "subheader");
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      insert(target, t1, anchor);
      insert(target, p2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(h1);
        detach(t1);
        detach(p2);
      }
    }
  };
}
function create_default_slot_1$5(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Retry");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$5(ctx) {
  let action;
  let current;
  action = new Action({
    props: {
      fun: (
        /*retry*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot_1$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(action.$$.fragment);
    },
    m(target, anchor) {
      mount_component(action, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const action_changes = {};
      if (dirty & /*$$scope*/
      4) {
        action_changes.$$scope = { dirty, ctx: ctx2 };
      }
      action.$set(action_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(action.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(action.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(action, detaching);
    }
  };
}
function create_fragment$o(ctx) {
  let header2;
  let t0;
  let p2;
  let t3;
  let actions;
  let current;
  header2 = new Header13({
    props: {
      img: WarningIcon,
      $$slots: { default: [create_default_slot_2$5] },
      $$scope: { ctx }
    }
  });
  actions = new Actions$1({
    props: {
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(header2.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.innerHTML = `Connecting to our Community API failed. Please check your<br/>
  internet connection, and then try again.`;
      t3 = space();
      create_component(actions.$$.fragment);
      attr(p2, "class", "spaced");
    },
    m(target, anchor) {
      mount_component(header2, target, anchor);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      insert(target, t3, anchor);
      mount_component(actions, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const header_changes = {};
      if (dirty & /*$$scope*/
      4) {
        header_changes.$$scope = { dirty, ctx: ctx2 };
      }
      header2.$set(header_changes);
      const actions_changes = {};
      if (dirty & /*$$scope*/
      4) {
        actions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(p2);
        detach(t3);
      }
      destroy_component(header2, detaching);
      destroy_component(actions, detaching);
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let { errored } = $$props;
  async function retry() {
    $$invalidate(1, errored = false);
  }
  $$self.$$set = ($$props2) => {
    if ("errored" in $$props2)
      $$invalidate(1, errored = $$props2.errored);
  };
  return [retry, errored];
}
let Error$1 = class Error2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$l, create_fragment$o, safe_not_equal, { errored: 1 });
  }
};
async function attemptConnection(host, ac = "") {
  host = host.trim();
  const testSuccess = await testConnection(host, ac, true);
  if (!testSuccess)
    return false;
  addServer(host);
  setAuthcode(host, ac);
  return true;
}
function create_default_slot_3$2(ctx) {
  let h1;
  let t1;
  let p2;
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Connect to ArcAPI";
      t1 = space();
      p2 = element("p");
      p2.textContent = "Quite a useful thing";
      attr(p2, "class", "subheader");
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      insert(target, t1, anchor);
      insert(target, p2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(h1);
        detach(t1);
        detach(p2);
      }
    }
  };
}
function create_default_slot_2$4(ctx) {
  let t_value = (
    /*connecting*/
    ctx[0] ? "Connecting..." : "Use Community"
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*connecting*/
      1 && t_value !== (t_value = /*connecting*/
      ctx2[0] ? "Connecting..." : "Use Community"))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$4(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Custom...");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$4(ctx) {
  let action0;
  let t2;
  let action1;
  let current;
  action0 = new Action({
    props: {
      fun: (
        /*community*/
        ctx[1]
      ),
      disabled: (
        /*connecting*/
        ctx[0]
      ),
      suggested: true,
      $$slots: { default: [create_default_slot_2$4] },
      $$scope: { ctx }
    }
  });
  action1 = new Action({
    props: {
      fun: (
        /*custom*/
        ctx[2]
      ),
      disabled: (
        /*connecting*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot_1$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(action0.$$.fragment);
      t2 = space();
      create_component(action1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(action0, target, anchor);
      insert(target, t2, anchor);
      mount_component(action1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const action0_changes = {};
      if (dirty & /*connecting*/
      1)
        action0_changes.disabled = /*connecting*/
        ctx2[0];
      if (dirty & /*$$scope, connecting*/
      33) {
        action0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      action0.$set(action0_changes);
      const action1_changes = {};
      if (dirty & /*connecting*/
      1)
        action1_changes.disabled = /*connecting*/
        ctx2[0];
      if (dirty & /*$$scope*/
      32) {
        action1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      action1.$set(action1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(action0.$$.fragment, local);
      transition_in(action1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(action0.$$.fragment, local);
      transition_out(action1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(action0, detaching);
      destroy_component(action1, detaching);
    }
  };
}
function create_fragment$n(ctx) {
  let header2;
  let t0;
  let p2;
  let t3;
  let actions;
  let current;
  header2 = new Header13({
    props: {
      img: ConnectIcon,
      $$slots: { default: [create_default_slot_3$2] },
      $$scope: { ctx }
    }
  });
  actions = new Actions$1({
    props: {
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(header2.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.innerHTML = `Do you want to connect using the Community API, or<br/>
  a custom one?`;
      t3 = space();
      create_component(actions.$$.fragment);
      attr(p2, "class", "spaced");
    },
    m(target, anchor) {
      mount_component(header2, target, anchor);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      insert(target, t3, anchor);
      mount_component(actions, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const header_changes = {};
      if (dirty & /*$$scope*/
      32) {
        header_changes.$$scope = { dirty, ctx: ctx2 };
      }
      header2.$set(header_changes);
      const actions_changes = {};
      if (dirty & /*$$scope, connecting*/
      33) {
        actions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(p2);
        detach(t3);
      }
      destroy_component(header2, detaching);
      destroy_component(actions, detaching);
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let { errored } = $$props;
  let { handler } = $$props;
  let connecting = false;
  async function community() {
    $$invalidate(0, connecting = true);
    const success = await attemptConnection("community.arcapi.nl", "");
    $$invalidate(0, connecting = false);
    if (!success)
      return $$invalidate(3, errored = true);
    handler.navigate("finish");
  }
  function custom() {
    handler.navigate("connect-custom");
  }
  $$self.$$set = ($$props2) => {
    if ("errored" in $$props2)
      $$invalidate(3, errored = $$props2.errored);
    if ("handler" in $$props2)
      $$invalidate(4, handler = $$props2.handler);
  };
  return [connecting, community, custom, errored, handler];
}
class Normal extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$k, create_fragment$n, safe_not_equal, { errored: 3, handler: 4 });
  }
}
function create_else_block(ctx) {
  let error;
  let updating_errored;
  let current;
  function error_errored_binding(value) {
    ctx[3](value);
  }
  let error_props = {};
  if (
    /*errored*/
    ctx[1] !== void 0
  ) {
    error_props.errored = /*errored*/
    ctx[1];
  }
  error = new Error$1({ props: error_props });
  binding_callbacks.push(() => bind$1(error, "errored", error_errored_binding));
  return {
    c() {
      create_component(error.$$.fragment);
    },
    m(target, anchor) {
      mount_component(error, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const error_changes = {};
      if (!updating_errored && dirty & /*errored*/
      2) {
        updating_errored = true;
        error_changes.errored = /*errored*/
        ctx2[1];
        add_flush_callback(() => updating_errored = false);
      }
      error.$set(error_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(error.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(error.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(error, detaching);
    }
  };
}
function create_if_block$c(ctx) {
  let normal;
  let updating_errored;
  let current;
  function normal_errored_binding(value) {
    ctx[2](value);
  }
  let normal_props = { handler: (
    /*handler*/
    ctx[0]
  ) };
  if (
    /*errored*/
    ctx[1] !== void 0
  ) {
    normal_props.errored = /*errored*/
    ctx[1];
  }
  normal = new Normal({ props: normal_props });
  binding_callbacks.push(() => bind$1(normal, "errored", normal_errored_binding));
  return {
    c() {
      create_component(normal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(normal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const normal_changes = {};
      if (dirty & /*handler*/
      1)
        normal_changes.handler = /*handler*/
        ctx2[0];
      if (!updating_errored && dirty & /*errored*/
      2) {
        updating_errored = true;
        normal_changes.errored = /*errored*/
        ctx2[1];
        add_flush_callback(() => updating_errored = false);
      }
      normal.$set(normal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(normal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(normal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(normal, detaching);
    }
  };
}
function create_fragment$m(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$c, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*errored*/
    ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "connect-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let { handler } = $$props;
  let errored = false;
  function normal_errored_binding(value) {
    errored = value;
    $$invalidate(1, errored);
  }
  function error_errored_binding(value) {
    errored = value;
    $$invalidate(1, errored);
  }
  $$self.$$set = ($$props2) => {
    if ("handler" in $$props2)
      $$invalidate(0, handler = $$props2.handler);
  };
  return [handler, errored, normal_errored_binding, error_errored_binding];
}
class Connect extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$j, create_fragment$m, safe_not_equal, { handler: 0 });
  }
}
function create_if_block$b(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "error";
      attr(span, "class", "material-icons-round");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot_3$1(ctx) {
  let t0;
  let p2;
  let t1_value = (
    /*errored*/
    ctx[3] ? "That didn't work! Please try entering the information again." : "Enter the following information to connect to your server"
  );
  let t1;
  let if_block = (
    /*errored*/
    ctx[3] && create_if_block$b()
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      p2 = element("p");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      append(p2, t1);
    },
    p(ctx2, dirty) {
      if (
        /*errored*/
        ctx2[3]
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$b();
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*errored*/
      8 && t1_value !== (t1_value = /*errored*/
      ctx2[3] ? "That didn't work! Please try entering the information again." : "Enter the following information to connect to your server"))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(p2);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_default_slot_2$3(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Go Back");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$3(ctx) {
  let t_value = (
    /*connecting*/
    ctx[2] ? "Connecting..." : "Connect"
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*connecting*/
      4 && t_value !== (t_value = /*connecting*/
      ctx2[2] ? "Connecting..." : "Connect"))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$3(ctx) {
  let action0;
  let t2;
  let action1;
  let current;
  action0 = new Action({
    props: {
      fun: (
        /*back*/
        ctx[4]
      ),
      disabled: (
        /*connecting*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_2$3] },
      $$scope: { ctx }
    }
  });
  action1 = new Action({
    props: {
      fun: (
        /*connect*/
        ctx[5]
      ),
      suggested: true,
      disabled: !/*host*/
      ctx[0] || /*connecting*/
      ctx[2],
      $$slots: { default: [create_default_slot_1$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(action0.$$.fragment);
      t2 = space();
      create_component(action1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(action0, target, anchor);
      insert(target, t2, anchor);
      mount_component(action1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const action0_changes = {};
      if (dirty & /*connecting*/
      4)
        action0_changes.disabled = /*connecting*/
        ctx2[2];
      if (dirty & /*$$scope*/
      4096) {
        action0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      action0.$set(action0_changes);
      const action1_changes = {};
      if (dirty & /*host, connecting*/
      5)
        action1_changes.disabled = !/*host*/
        ctx2[0] || /*connecting*/
        ctx2[2];
      if (dirty & /*$$scope, connecting*/
      4100) {
        action1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      action1.$set(action1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(action0.$$.fragment, local);
      transition_in(action1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(action0.$$.fragment, local);
      transition_out(action1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(action0, detaching);
      destroy_component(action1, detaching);
    }
  };
}
function create_fragment$l(ctx) {
  let div2;
  let header2;
  let t0;
  let form;
  let div0;
  let input0;
  let t1;
  let span0;
  let t3;
  let div1;
  let input1;
  let t4;
  let span1;
  let t6;
  let actions;
  let current;
  let mounted;
  let dispose;
  header2 = new Header13({
    props: {
      img: ConnectIcon,
      flex: (
        /*errored*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx }
    }
  });
  actions = new Actions$1({
    props: {
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      create_component(header2.$$.fragment);
      t0 = space();
      form = element("form");
      div0 = element("div");
      input0 = element("input");
      t1 = space();
      span0 = element("span");
      span0.textContent = "dns";
      t3 = space();
      div1 = element("div");
      input1 = element("input");
      t4 = space();
      span1 = element("span");
      span1.textContent = "vpn_key";
      t6 = space();
      create_component(actions.$$.fragment);
      attr(input0, "type", "text");
      attr(input0, "placeholder", "Server");
      attr(input0, "autocomplete", "off");
      input0.disabled = /*connecting*/
      ctx[2];
      attr(span0, "class", "icon material-icons-round");
      attr(div0, "class", "input");
      toggle_class(
        div0,
        "errored",
        /*errored*/
        ctx[3]
      );
      attr(input1, "type", "password");
      attr(input1, "placeholder", "Authentication Code");
      attr(input1, "autocomplete", "new-password");
      input1.disabled = /*connecting*/
      ctx[2];
      attr(span1, "class", "icon material-icons-round");
      attr(div1, "class", "input");
      toggle_class(
        div1,
        "errored",
        /*errored*/
        ctx[3]
      );
      attr(form, "autocomplete", "off");
      attr(div2, "class", "connect-custom-content");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(header2, div2, null);
      append(div2, t0);
      append(div2, form);
      append(form, div0);
      append(div0, input0);
      set_input_value(
        input0,
        /*host*/
        ctx[0]
      );
      append(div0, t1);
      append(div0, span0);
      append(form, t3);
      append(form, div1);
      append(div1, input1);
      set_input_value(
        input1,
        /*ac*/
        ctx[1]
      );
      append(div1, t4);
      append(div1, span1);
      append(div2, t6);
      mount_component(actions, div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[8]
          ),
          listen(
            input0,
            "input",
            /*input_handler*/
            ctx[9]
          ),
          listen(
            input0,
            "keydown",
            /*checkSubmit*/
            ctx[6]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[10]
          ),
          listen(
            input1,
            "input",
            /*input_handler_1*/
            ctx[11]
          ),
          listen(
            input1,
            "keydown",
            /*checkSubmit*/
            ctx[6]
          ),
          listen(
            form,
            "submit",
            /*connect*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const header_changes = {};
      if (dirty & /*errored*/
      8)
        header_changes.flex = /*errored*/
        ctx2[3];
      if (dirty & /*$$scope, errored*/
      4104) {
        header_changes.$$scope = { dirty, ctx: ctx2 };
      }
      header2.$set(header_changes);
      if (!current || dirty & /*connecting*/
      4) {
        input0.disabled = /*connecting*/
        ctx2[2];
      }
      if (dirty & /*host*/
      1 && input0.value !== /*host*/
      ctx2[0]) {
        set_input_value(
          input0,
          /*host*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*errored*/
      8) {
        toggle_class(
          div0,
          "errored",
          /*errored*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*connecting*/
      4) {
        input1.disabled = /*connecting*/
        ctx2[2];
      }
      if (dirty & /*ac*/
      2 && input1.value !== /*ac*/
      ctx2[1]) {
        set_input_value(
          input1,
          /*ac*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*errored*/
      8) {
        toggle_class(
          div1,
          "errored",
          /*errored*/
          ctx2[3]
        );
      }
      const actions_changes = {};
      if (dirty & /*$$scope, host, connecting*/
      4101) {
        actions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(header2);
      destroy_component(actions);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let { handler } = $$props;
  let host = "";
  let ac = "";
  let connecting = false;
  let errored = false;
  function back() {
    handler.navigate("connect");
  }
  async function connect(e2) {
    if (e2)
      e2.preventDefault();
    if (!host)
      return;
    $$invalidate(2, connecting = true);
    const success = await attemptConnection(host, ac);
    $$invalidate(2, connecting = false);
    if (!success)
      return $$invalidate(3, errored = true);
    handler.navigate("finish");
  }
  function checkSubmit(e2) {
    const key2 = (e2.key || "").toLowerCase();
    if (key2 !== "enter")
      return;
    connect();
  }
  function input0_input_handler() {
    host = this.value;
    $$invalidate(0, host);
  }
  const input_handler = () => $$invalidate(3, errored = false);
  function input1_input_handler() {
    ac = this.value;
    $$invalidate(1, ac);
  }
  const input_handler_1 = () => $$invalidate(3, errored = false);
  $$self.$$set = ($$props2) => {
    if ("handler" in $$props2)
      $$invalidate(7, handler = $$props2.handler);
  };
  return [
    host,
    ac,
    connecting,
    errored,
    back,
    connect,
    checkSubmit,
    handler,
    input0_input_handler,
    input_handler,
    input1_input_handler,
    input_handler_1
  ];
}
class CustomServer extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$i, create_fragment$l, safe_not_equal, { handler: 7 });
  }
}
function create_default_slot_2$2(ctx) {
  let h1;
  let t1;
  let p2;
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "All finished!";
      t1 = space();
      p2 = element("p");
      p2.textContent = "We have everything we need";
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      insert(target, t1, anchor);
      insert(target, p2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(h1);
        detach(t1);
        detach(p2);
      }
    }
  };
}
function create_default_slot_1$2(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Let's go!");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$2(ctx) {
  let action;
  let current;
  action = new Action({
    props: {
      fun: finish,
      suggested: true,
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(action.$$.fragment);
    },
    m(target, anchor) {
      mount_component(action, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const action_changes = {};
      if (dirty & /*$$scope*/
      1) {
        action_changes.$$scope = { dirty, ctx: ctx2 };
      }
      action.$set(action_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(action.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(action.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(action, detaching);
    }
  };
}
function create_fragment$k(ctx) {
  let header2;
  let t0;
  let p2;
  let t5;
  let actions;
  let current;
  header2 = new Header13({
    props: {
      img: FlagIcon,
      $$slots: { default: [create_default_slot_2$2] },
      $$scope: { ctx }
    }
  });
  actions = new Actions$1({
    props: {
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(header2.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.innerHTML = `We&#39;ve collected all the info we need. <br/>
  Click <b>Let&#39;s go!</b> to start using ArcOS.`;
      t5 = space();
      create_component(actions.$$.fragment);
      attr(p2, "class", "spaced");
    },
    m(target, anchor) {
      mount_component(header2, target, anchor);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      insert(target, t5, anchor);
      mount_component(actions, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const header_changes = {};
      if (dirty & /*$$scope*/
      1) {
        header_changes.$$scope = { dirty, ctx: ctx2 };
      }
      header2.$set(header_changes);
      const actions_changes = {};
      if (dirty & /*$$scope*/
      1) {
        actions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(p2);
        detach(t5);
      }
      destroy_component(header2, detaching);
      destroy_component(actions, detaching);
    }
  };
}
function finish() {
  location.reload();
}
class Finish extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$k, safe_not_equal, {});
  }
}
function create_fragment$j(ctx) {
  let p0;
  let t1;
  let h40;
  let t3;
  let ul0;
  let t17;
  let h41;
  let t19;
  let ul1;
  let t25;
  let p1;
  return {
    c() {
      p0 = element("p");
      p0.textContent = "ArcOS has the GNU Public License, version 3.0. This means that there are certain things ArcOS\n  users can and cannot do to the ArcOS Codebase. This protects us from unrightful copying of our\n  code and/or assets. By using ArcOS, you must agree to this License.";
      t1 = space();
      h40 = element("h4");
      h40.textContent = "What are the limitations?";
      t3 = space();
      ul0 = element("ul");
      ul0.innerHTML = `<li>This software is provided without any warranty.</li> <li>The software author or license cannot be held accountable for any damage inflicted by the
    software.</li> <li>If you dare to build your business solely from this code, you risk open-sourcing the whole code
    base.</li> <li>If you modify it, you have to indicate changes made to the code.</li> <li>You have to include the license and copyright notice with each and every distribution</li> <li>Any modifications of this code base <b>must</b> be distributed with the same license, GPLv3.</li>`;
      t17 = space();
      h41 = element("h4");
      h41.textContent = "What are the rights?";
      t19 = space();
      ul1 = element("ul");
      ul1.innerHTML = `<li>Anyone can copy, modify and distribute this software.</li> <li>You can use this software privately</li> <li>You can use this software for commercial purposes</li>`;
      t25 = space();
      p1 = element("p");
      p1.textContent = "For more information about the licensing situation of ArcOS, and what to do in case of a License\n  Violation, please contact the ArcOS Team using the information found on the website.";
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      insert(target, t1, anchor);
      insert(target, h40, anchor);
      insert(target, t3, anchor);
      insert(target, ul0, anchor);
      insert(target, t17, anchor);
      insert(target, h41, anchor);
      insert(target, t19, anchor);
      insert(target, ul1, anchor);
      insert(target, t25, anchor);
      insert(target, p1, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p0);
        detach(t1);
        detach(h40);
        detach(t3);
        detach(ul0);
        detach(t17);
        detach(h41);
        detach(t19);
        detach(ul1);
        detach(t25);
        detach(p1);
      }
    }
  };
}
class Help2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$j, safe_not_equal, {});
  }
}
function create_default_slot_2$1(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Go Back");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$1(ctx) {
  let t2;
  return {
    c() {
      t2 = text("I Accept");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$1(ctx) {
  let action0;
  let t2;
  let action1;
  let current;
  action0 = new Action({
    props: {
      fun: (
        /*back*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  action1 = new Action({
    props: {
      fun: (
        /*accept*/
        ctx[2]
      ),
      suggested: true,
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(action0.$$.fragment);
      t2 = space();
      create_component(action1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(action0, target, anchor);
      insert(target, t2, anchor);
      mount_component(action1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const action0_changes = {};
      if (dirty & /*$$scope*/
      64) {
        action0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      action0.$set(action0_changes);
      const action1_changes = {};
      if (dirty & /*$$scope*/
      64) {
        action1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      action1.$set(action1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(action0.$$.fragment, local);
      transition_in(action1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(action0.$$.fragment, local);
      transition_out(action1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(action0, detaching);
      destroy_component(action1, detaching);
    }
  };
}
function create_fragment$i(ctx) {
  let div4;
  let div2;
  let t4;
  let textarea;
  let t5;
  let div3;
  let button;
  let t7;
  let actions;
  let current;
  let mounted;
  let dispose;
  actions = new Actions$1({
    props: {
      inline: true,
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="text"><h1>License Agreement</h1> <p class="sub">By using ArcOS, you agree to the GPLv3 License.</p></div> <div class="right"><img src="${SecureIcon}" alt=""/></div>`;
      t4 = space();
      textarea = element("textarea");
      t5 = space();
      div3 = element("div");
      button = element("button");
      button.textContent = "info";
      t7 = space();
      create_component(actions.$$.fragment);
      attr(div2, "class", "license-header");
      textarea.value = /*license*/
      ctx[0];
      attr(textarea, "class", "license");
      attr(textarea, "spellcheck", "false");
      textarea.readOnly = true;
      attr(button, "class", "material-icons-round");
      attr(div3, "class", "bottom");
      attr(div4, "class", "license-content");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div4, t4);
      append(div4, textarea);
      append(div4, t5);
      append(div4, div3);
      append(div3, button);
      append(div3, t7);
      mount_component(actions, div3, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*help*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*license*/
      1) {
        textarea.value = /*license*/
        ctx2[0];
      }
      const actions_changes = {};
      if (dirty & /*$$scope*/
      64) {
        actions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      destroy_component(actions);
      mounted = false;
      dispose();
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let { handler } = $$props;
  let license = "";
  let licensePid = 0;
  onMount(async () => {
    try {
      const response = await axios$1.get("./LICENSE");
      $$invalidate(0, license = response.data);
    } catch {
      $$invalidate(0, license = "404 NOT FOUND");
    }
  });
  async function back() {
    await ProcessStack.kill(licensePid, true);
    handler.navigate("welcome");
  }
  async function accept() {
    await ProcessStack.kill(licensePid, true);
    handler.navigate("connect");
  }
  async function help() {
    if (licensePid)
      return;
    licensePid = await createErrorDialog(
      {
        title: "License info",
        component: Help2,
        buttons: [
          {
            caption: "Okay",
            action() {
              licensePid = 0;
            }
          }
        ],
        image: SecureIcon,
        sound: "arcos.dialog.info"
      },
      0,
      true
    );
  }
  $$self.$$set = ($$props2) => {
    if ("handler" in $$props2)
      $$invalidate(4, handler = $$props2.handler);
  };
  return [license, back, accept, help, handler];
}
class License extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$h, create_fragment$i, safe_not_equal, { handler: 4 });
  }
}
function create_default_slot_3(ctx) {
  let h1;
  let t1;
  let p2;
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Welcome";
      t1 = space();
      p2 = element("p");
      p2.textContent = "Let's get ArcOS set up.";
      attr(p2, "class", "subheader");
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      insert(target, t1, anchor);
      insert(target, p2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(h1);
        detach(t1);
        detach(p2);
      }
    }
  };
}
function create_default_slot_2(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Get Started");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Advanced...");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot(ctx) {
  let action0;
  let t2;
  let action1;
  let current;
  action0 = new Action({
    props: {
      fun: (
        /*getStarted*/
        ctx[0]
      ),
      suggested: true,
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  action1 = new Action({
    props: {
      fun: (
        /*advanced*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(action0.$$.fragment);
      t2 = space();
      create_component(action1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(action0, target, anchor);
      insert(target, t2, anchor);
      mount_component(action1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const action0_changes = {};
      if (dirty & /*$$scope*/
      8) {
        action0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      action0.$set(action0_changes);
      const action1_changes = {};
      if (dirty & /*$$scope*/
      8) {
        action1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      action1.$set(action1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(action0.$$.fragment, local);
      transition_in(action1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(action0.$$.fragment, local);
      transition_out(action1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(action0, detaching);
      destroy_component(action1, detaching);
    }
  };
}
function create_fragment$h(ctx) {
  let header2;
  let t0;
  let p2;
  let t2;
  let actions;
  let current;
  header2 = new Header13({
    props: {
      img: Logo(),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  actions = new Actions$1({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(header2.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.textContent = "To set up this installation of ArcOS, click Get Started.";
      t2 = space();
      create_component(actions.$$.fragment);
      attr(p2, "class", "spaced");
    },
    m(target, anchor) {
      mount_component(header2, target, anchor);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      insert(target, t2, anchor);
      mount_component(actions, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const header_changes = {};
      if (dirty & /*$$scope*/
      8) {
        header_changes.$$scope = { dirty, ctx: ctx2 };
      }
      header2.$set(header_changes);
      const actions_changes = {};
      if (dirty & /*$$scope*/
      8) {
        actions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(p2);
        detach(t2);
      }
      destroy_component(header2, detaching);
      destroy_component(actions, detaching);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let { handler } = $$props;
  function getStarted() {
    handler.navigate("license");
  }
  function advanced() {
    handler.navigate("advanced");
  }
  $$self.$$set = ($$props2) => {
    if ("handler" in $$props2)
      $$invalidate(2, handler = $$props2.handler);
  };
  return [getStarted, advanced, handler];
}
class Welcome extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$g, create_fragment$h, safe_not_equal, { handler: 2 });
  }
}
const firstTimeSetupStates = /* @__PURE__ */ new Map([
  [
    "welcome",
    {
      attribs: {},
      content: Welcome,
      key: "welcome",
      name: "Welcome",
      image: WaveIcon
    }
  ],
  [
    "advanced",
    {
      attribs: { hideBar: true },
      content: Advanced,
      key: "advanced",
      name: "Advanced Options"
      /*  image: SettingsIcon, */
    }
  ],
  [
    "license",
    {
      attribs: {},
      content: License,
      key: "license",
      name: "License Agreement",
      image: SecureIcon
    }
  ],
  [
    "connect",
    {
      attribs: {},
      content: Connect,
      key: "connect",
      name: "Connect to ArcAPI",
      image: ConnectIcon
    }
  ],
  [
    "connect-custom",
    {
      attribs: {},
      content: CustomServer,
      key: "connect-custom",
      name: "Connect to Custom Server"
    }
  ],
  [
    "finish",
    {
      attribs: {},
      content: Finish,
      key: "finish",
      name: "All finished!",
      image: FlagIcon
    }
  ]
]);
function create_if_block$a(ctx) {
  let div;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1_value = (
    /*state*/
    ctx[1].name + ""
  );
  let t1;
  return {
    c() {
      div = element("div");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      if (!src_url_equal(img.src, img_src_value = /*state*/
      ctx[1].image))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*key*/
        ctx[0]
      );
      attr(div, "class", "progress-state");
      toggle_class(
        div,
        "active",
        /*current*/
        ctx[2] == /*key*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
      append(div, t0);
      append(div, span);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*state*/
      2 && !src_url_equal(img.src, img_src_value = /*state*/
      ctx2[1].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*key*/
      1) {
        attr(
          img,
          "alt",
          /*key*/
          ctx2[0]
        );
      }
      if (dirty & /*state*/
      2 && t1_value !== (t1_value = /*state*/
      ctx2[1].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*current, key*/
      5) {
        toggle_class(
          div,
          "active",
          /*current*/
          ctx2[2] == /*key*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$g(ctx) {
  let if_block_anchor;
  let if_block = (
    /*state*/
    ctx[1].image && create_if_block$a(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*state*/
        ctx2[1].image
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$a(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let { key: key2 } = $$props;
  let { state } = $$props;
  let { current } = $$props;
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(0, key2 = $$props2.key);
    if ("state" in $$props2)
      $$invalidate(1, state = $$props2.state);
    if ("current" in $$props2)
      $$invalidate(2, current = $$props2.current);
  };
  return [key2, state, current];
}
class ProgressState extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$f, create_fragment$g, safe_not_equal, { key: 0, state: 1, current: 2 });
  }
}
function get_each_context$2(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2][0];
  child_ctx[3] = list2[i2][1];
  return child_ctx;
}
function create_if_block$9(ctx) {
  let div1;
  let t0;
  let div0;
  let current;
  let each_value = ensure_array_like([...firstTimeSetupStates]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$2(get_each_context$2(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      div0 = element("div");
      div0.textContent = `v${ArcOSVersion}-${ARCOS_MODE}`;
      attr(div0, "class", "build");
      attr(div1, "class", "progress");
      toggle_class(div1, "hidden", !/*current*/
      ctx[0].image);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      append(div1, t0);
      append(div1, div0);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*current*/
      1) {
        each_value = ensure_array_like([...firstTimeSetupStates]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, t0);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*current*/
      1) {
        toggle_class(div1, "hidden", !/*current*/
        ctx2[0].image);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$2(ctx) {
  let progressstate;
  let current;
  progressstate = new ProgressState({
    props: {
      key: (
        /*key*/
        ctx[2]
      ),
      state: (
        /*state*/
        ctx[3]
      ),
      current: (
        /*current*/
        ctx[0].key
      )
    }
  });
  return {
    c() {
      create_component(progressstate.$$.fragment);
    },
    m(target, anchor) {
      mount_component(progressstate, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const progressstate_changes = {};
      if (dirty & /*current*/
      1)
        progressstate_changes.current = /*current*/
        ctx2[0].key;
      progressstate.$set(progressstate_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(progressstate.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(progressstate.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(progressstate, detaching);
    }
  };
}
function create_fragment$f(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*current*/
    ctx[0] && create_if_block$9(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*current*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*current*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let current;
  let { handler } = $$props;
  handler.current.subscribe((v2) => $$invalidate(0, current = v2));
  $$self.$$set = ($$props2) => {
    if ("handler" in $$props2)
      $$invalidate(1, handler = $$props2.handler);
  };
  return [current, handler];
}
class Progress extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$e, create_fragment$f, safe_not_equal, { handler: 1 });
  }
}
const fts = "";
function create_if_block$8(ctx) {
  let div1;
  let div0;
  let staterenderer;
  let t2;
  let progress;
  let current;
  staterenderer = new StateRenderer({ props: { handler: (
    /*handler*/
    ctx[0]
  ) } });
  progress = new Progress({ props: { handler: (
    /*handler*/
    ctx[0]
  ) } });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(staterenderer.$$.fragment);
      t2 = space();
      create_component(progress.$$.fragment);
      attr(div0, "class", "content");
      attr(div1, "class", "fts-content fullscreen");
      toggle_class(
        div1,
        "show",
        /*show*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(staterenderer, div0, null);
      append(div1, t2);
      mount_component(progress, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const staterenderer_changes = {};
      if (dirty & /*handler*/
      1)
        staterenderer_changes.handler = /*handler*/
        ctx2[0];
      staterenderer.$set(staterenderer_changes);
      const progress_changes = {};
      if (dirty & /*handler*/
      1)
        progress_changes.handler = /*handler*/
        ctx2[0];
      progress.$set(progress_changes);
      if (!current || dirty & /*show*/
      2) {
        toggle_class(
          div1,
          "show",
          /*show*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(staterenderer.$$.fragment, local);
      transition_in(progress.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(staterenderer.$$.fragment, local);
      transition_out(progress.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(staterenderer);
      destroy_component(progress);
    }
  };
}
function create_fragment$e(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*handler*/
    ctx[0] && create_if_block$8(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*handler*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*handler*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let handler;
  let show = false;
  onMount(async () => {
    ArcSoundBus.playSound("arcos.system.logon");
    ProcessStack.processes.set(/* @__PURE__ */ new Map([]));
    await StartCoreProcesses();
    $$invalidate(0, handler = new StateHandler("fts", firstTimeSetupStates, "welcome"));
    await sleep(1e3);
    $$invalidate(1, show = true);
  });
  return [handler, show];
}
class FirstTimeSetup extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$d, create_fragment$e, safe_not_equal, {});
  }
}
function create_if_block$7(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "background fullscreen");
      attr(
        div,
        "style",
        /*style*/
        ctx[1]
      );
      toggle_class(
        div,
        "zoom",
        /*state*/
        ctx[0].attribs.darken
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*style*/
      2) {
        attr(
          div,
          "style",
          /*style*/
          ctx2[1]
        );
      }
      if (dirty & /*state*/
      1) {
        toggle_class(
          div,
          "zoom",
          /*state*/
          ctx2[0].attribs.darken
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$d(ctx) {
  let if_block_anchor;
  let if_block = (
    /*state*/
    ctx[0] && create_if_block$7(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*state*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$7(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  let { state } = $$props;
  let { runtime } = $$props;
  const { userBackground } = runtime;
  let style2 = "img15";
  userBackground.subscribe(async (v2) => {
    const wallpaper = await getWallpaper(v2 || "img15", "img15");
    $$invalidate(1, style2 = `--bg: url(${wallpaper.url});`);
  });
  $$self.$$set = ($$props2) => {
    if ("state" in $$props2)
      $$invalidate(0, state = $$props2.state);
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*style*/
    2)
      ;
  };
  return [state, style2, runtime];
}
class Background3 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$c, create_fragment$d, safe_not_equal, { state: 0, runtime: 2 });
  }
}
function create_if_block$6(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "fullscreen darken");
      toggle_class(
        div,
        "show",
        /*state*/
        ctx[0].attribs.darken
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*state*/
      1) {
        toggle_class(
          div,
          "show",
          /*state*/
          ctx2[0].attribs.darken
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$c(ctx) {
  let if_block_anchor;
  let if_block = (
    /*state*/
    ctx[0] && create_if_block$6(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*state*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let { state } = $$props;
  $$self.$$set = ($$props2) => {
    if ("state" in $$props2)
      $$invalidate(0, state = $$props2.state);
  };
  return [state];
}
class Darken extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$b, create_fragment$c, safe_not_equal, { state: 0 });
  }
}
function create_if_block$5(ctx) {
  let div;
  let switch_instance;
  let div_class_value;
  let current;
  var switch_value = (
    /*state*/
    ctx[0].content
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        runtime: (
          /*runtime*/
          ctx2[1]
        ),
        key: (
          /*state*/
          ctx2[0].key
        ),
        loginState: (
          /*state*/
          ctx2[0]
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "class", div_class_value = "login-page fullscreen page-" + /*state*/
      ctx[0].key + " " + /*state*/
      (ctx[0].attribs.className || ""));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*state*/
      1 && switch_value !== (switch_value = /*state*/
      ctx2[0].content)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*runtime*/
        2)
          switch_instance_changes.runtime = /*runtime*/
          ctx2[1];
        if (dirty & /*state*/
        1)
          switch_instance_changes.key = /*state*/
          ctx2[0].key;
        if (dirty & /*state*/
        1)
          switch_instance_changes.loginState = /*state*/
          ctx2[0];
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty & /*state*/
      1 && div_class_value !== (div_class_value = "login-page fullscreen page-" + /*state*/
      ctx2[0].key + " " + /*state*/
      (ctx2[0].attribs.className || ""))) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_fragment$b(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*state*/
    ctx[0] && create_if_block$5(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*state*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*state*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let { state } = $$props;
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("state" in $$props2)
      $$invalidate(0, state = $$props2.state);
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [state, runtime];
}
class Paging extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$a, create_fragment$b, safe_not_equal, { state: 0, runtime: 1 });
  }
}
function create_fragment$a(ctx) {
  let div;
  let t2;
  return {
    c() {
      div = element("div");
      t2 = text(
        /*time*/
        ctx[0]
      );
      attr(div, "class", "clock");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*time*/
      1)
        set_data(
          t2,
          /*time*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let time = "";
  setInterval(() => $$invalidate(0, time = dayjs().format("MMM D, HH:mm")), 500);
  return [time];
}
class Clock3 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$9, create_fragment$a, safe_not_equal, {});
  }
}
function get_each_context$1(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2];
  return child_ctx;
}
function create_each_block$1(ctx) {
  let option;
  let t_value = (
    /*server*/
    ctx[5] + ""
  );
  let t2;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t2 = text(t_value);
      option.__value = option_value_value = /*server*/
      ctx[5];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*servers*/
      2 && t_value !== (t_value = /*server*/
      ctx2[5] + ""))
        set_data(t2, t_value);
      if (dirty & /*servers*/
      2 && option_value_value !== (option_value_value = /*server*/
      ctx2[5])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_fragment$9(ctx) {
  let select;
  let option;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*servers*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1(get_each_context$1(ctx, each_value, i2));
  }
  return {
    c() {
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      option = element("option");
      option.textContent = "Add Server...";
      option.__value = "$new";
      set_input_value(option, option.__value);
      attr(select, "class", "host");
      if (
        /*selectedServer*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[4].call(select)
        ));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      append(select, option);
      select_option(
        select,
        /*selectedServer*/
        ctx[0],
        true
      );
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*changeServer*/
            ctx[2]
          ),
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*servers*/
      2) {
        each_value = ensure_array_like(
          /*servers*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, option);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*selectedServer, servers*/
      3) {
        select_option(
          select,
          /*selectedServer*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let selectedServer = getServer();
  let servers = [];
  onMount(() => {
    $$invalidate(1, servers = getAllServers());
  });
  async function changeServer() {
    await sleep();
    if (selectedServer == "$new")
      return PrimaryState.navigate("fts");
    setServer(selectedServer);
    runtime.UserName.set("ArcOS");
    runtime.stateHandler.navigate("restart");
  }
  function select_change_handler() {
    selectedServer = select_value(this);
    $$invalidate(0, selectedServer);
    $$invalidate(1, servers);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [selectedServer, servers, changeServer, runtime, select_change_handler];
}
class HostSelector extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$8, create_fragment$9, safe_not_equal, { runtime: 3 });
  }
}
function create_fragment$8(ctx) {
  let div;
  let button0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.innerHTML = `<span class="material-icons-round">power_settings_new</span>`;
      t1 = space();
      button1 = element("button");
      button1.innerHTML = `<span class="material-icons-round">restart_alt</span>`;
      attr(button0, "class", "nopad");
      attr(button1, "class", "nopad");
      attr(div, "class", "right");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, t1);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*shutdown*/
            ctx[0]
          ),
          listen(
            button1,
            "click",
            /*restart*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  function shutdown2() {
    runtime.UserName.set("ArcOS");
    runtime.stateHandler.navigate("shutdown");
  }
  function restart2() {
    runtime.UserName.set("ArcOS");
    runtime.stateHandler.navigate("restart");
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [shutdown2, restart2, runtime];
}
class Right extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$7, create_fragment$8, safe_not_equal, { runtime: 2 });
  }
}
function create_if_block$4(ctx) {
  let div;
  let hostselector;
  let t0;
  let clock;
  let t1;
  let right;
  let current;
  hostselector = new HostSelector({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  clock = new Clock3({});
  right = new Right({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(hostselector.$$.fragment);
      t0 = space();
      create_component(clock.$$.fragment);
      t1 = space();
      create_component(right.$$.fragment);
      attr(div, "class", "topbar");
      toggle_class(
        div,
        "show",
        /*state*/
        (ctx[1].attribs.topbar || false) && /*show*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(hostselector, div, null);
      append(div, t0);
      mount_component(clock, div, null);
      append(div, t1);
      mount_component(right, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const hostselector_changes = {};
      if (dirty & /*runtime*/
      1)
        hostselector_changes.runtime = /*runtime*/
        ctx2[0];
      hostselector.$set(hostselector_changes);
      const right_changes = {};
      if (dirty & /*runtime*/
      1)
        right_changes.runtime = /*runtime*/
        ctx2[0];
      right.$set(right_changes);
      if (!current || dirty & /*state, show*/
      6) {
        toggle_class(
          div,
          "show",
          /*state*/
          (ctx2[1].attribs.topbar || false) && /*show*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(hostselector.$$.fragment, local);
      transition_in(clock.$$.fragment, local);
      transition_in(right.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hostselector.$$.fragment, local);
      transition_out(clock.$$.fragment, local);
      transition_out(right.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(hostselector);
      destroy_component(clock);
      destroy_component(right);
    }
  };
}
function create_fragment$7(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*state*/
    ctx[1] && create_if_block$4(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*state*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*state*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { state } = $$props;
  let show = false;
  onMount(() => {
    setTimeout(() => $$invalidate(2, show = true), 750);
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("state" in $$props2)
      $$invalidate(1, state = $$props2.state);
  };
  return [runtime, state, show];
}
class Topbar extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$6, create_fragment$7, safe_not_equal, { runtime: 0, state: 1 });
  }
}
const newlogin = "";
function create_if_block$3(ctx) {
  let div;
  let background;
  let t0;
  let darken;
  let t1;
  let topbar;
  let t2;
  let paging;
  let current;
  background = new Background3({
    props: {
      state: (
        /*state*/
        ctx[1]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  darken = new Darken({ props: { state: (
    /*state*/
    ctx[1]
  ) } });
  topbar = new Topbar({
    props: {
      state: (
        /*state*/
        ctx[1]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  paging = new Paging({
    props: {
      state: (
        /*state*/
        ctx[1]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(background.$$.fragment);
      t0 = space();
      create_component(darken.$$.fragment);
      t1 = space();
      create_component(topbar.$$.fragment);
      t2 = space();
      create_component(paging.$$.fragment);
      attr(div, "class", "newlogin fullscreen");
      toggle_class(
        div,
        "show",
        /*show*/
        ctx[2]
      );
      toggle_class(
        div,
        "safemode",
        /*$SafeMode*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(background, div, null);
      append(div, t0);
      mount_component(darken, div, null);
      append(div, t1);
      mount_component(topbar, div, null);
      append(div, t2);
      mount_component(paging, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const background_changes = {};
      if (dirty & /*state*/
      2)
        background_changes.state = /*state*/
        ctx2[1];
      if (dirty & /*runtime*/
      1)
        background_changes.runtime = /*runtime*/
        ctx2[0];
      background.$set(background_changes);
      const darken_changes = {};
      if (dirty & /*state*/
      2)
        darken_changes.state = /*state*/
        ctx2[1];
      darken.$set(darken_changes);
      const topbar_changes = {};
      if (dirty & /*state*/
      2)
        topbar_changes.state = /*state*/
        ctx2[1];
      if (dirty & /*runtime*/
      1)
        topbar_changes.runtime = /*runtime*/
        ctx2[0];
      topbar.$set(topbar_changes);
      const paging_changes = {};
      if (dirty & /*state*/
      2)
        paging_changes.state = /*state*/
        ctx2[1];
      if (dirty & /*runtime*/
      1)
        paging_changes.runtime = /*runtime*/
        ctx2[0];
      paging.$set(paging_changes);
      if (!current || dirty & /*show*/
      4) {
        toggle_class(
          div,
          "show",
          /*show*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$SafeMode*/
      8) {
        toggle_class(
          div,
          "safemode",
          /*$SafeMode*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(background.$$.fragment, local);
      transition_in(darken.$$.fragment, local);
      transition_in(topbar.$$.fragment, local);
      transition_in(paging.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(background.$$.fragment, local);
      transition_out(darken.$$.fragment, local);
      transition_out(topbar.$$.fragment, local);
      transition_out(paging.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(background);
      destroy_component(darken);
      destroy_component(topbar);
      destroy_component(paging);
    }
  };
}
function create_fragment$6(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*runtime*/
    ctx[0] && create_if_block$3(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*runtime*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*runtime*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let $UserName;
  let $SafeMode;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(5, $UserName = $$value));
  component_subscribe($$self, SafeMode, ($$value) => $$invalidate(3, $SafeMode = $$value));
  let { thisState } = $$props;
  let runtime;
  let state;
  let show = false;
  onMount(async () => {
    $$invalidate(0, runtime = new Login3("autologin", !thisState.attribs.continuation));
    if (thisState.attribs.continuation) {
      runtime.setUser($UserName);
      runtime.stateHandler.navigate(thisState.attribs.continuation);
    }
    await sleep(500);
    $$invalidate(2, show = true);
    runtime.stateHandler.current.subscribe((v2) => {
      if (!v2)
        return;
      $$invalidate(1, state = v2);
      if (state.onload)
        state.onload(runtime);
    });
  });
  $$self.$$set = ($$props2) => {
    if ("thisState" in $$props2)
      $$invalidate(4, thisState = $$props2.thisState);
  };
  return [runtime, state, show, $SafeMode, thisState];
}
class Login_1 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$5, create_fragment$6, safe_not_equal, { thisState: 4 });
  }
}
function create_if_block$2(ctx) {
  let div;
  let button0;
  let t1;
  let button1;
  let t3;
  let button2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.textContent = "Add Server";
      t1 = space();
      button1 = element("button");
      button1.textContent = "Restart";
      t3 = space();
      button2 = element("button");
      button2.textContent = "Continue";
      attr(button2, "class", "suggested");
      attr(div, "class", "actions");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, t1);
      append(div, button1);
      append(div, t3);
      append(div, button2);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*fts*/
            ctx[1]
          ),
          listen(button1, "click", restart),
          listen(
            button2,
            "click",
            /*apply*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$5(ctx) {
  let if_block_anchor;
  let if_block = (
    /*servers*/
    ctx[0] && /*servers*/
    ctx[0].length && create_if_block$2(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*servers*/
        ctx2[0] && /*servers*/
        ctx2[0].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function restart() {
  location.reload();
}
function instance$4($$self, $$props, $$invalidate) {
  let { servers = [] } = $$props;
  let { selected = "" } = $$props;
  function fts2() {
    PrimaryState.navigate("fts");
  }
  function apply() {
    setServer(selected);
    restart();
  }
  $$self.$$set = ($$props2) => {
    if ("servers" in $$props2)
      $$invalidate(0, servers = $$props2.servers);
    if ("selected" in $$props2)
      $$invalidate(3, selected = $$props2.selected);
  };
  return [servers, fts2, apply, selected];
}
class Actions8 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4, create_fragment$5, safe_not_equal, { servers: 0, selected: 3 });
  }
}
function create_if_block$1(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "lock";
      attr(span, "class", "material-icons-round");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$4(ctx) {
  let button1;
  let img;
  let img_src_value;
  let t0;
  let p2;
  let t1_value = (
    /*server*/
    ctx[1].hostname + ""
  );
  let t1;
  let t2;
  let div;
  let button0;
  let t4;
  let mounted;
  let dispose;
  let if_block = (
    /*server*/
    ctx[1].private && create_if_block$1()
  );
  return {
    c() {
      button1 = element("button");
      img = element("img");
      t0 = space();
      p2 = element("p");
      t1 = text(t1_value);
      t2 = space();
      div = element("div");
      button0 = element("button");
      button0.textContent = "delete";
      t4 = space();
      if (if_block)
        if_block.c();
      if (!src_url_equal(img.src, img_src_value = ConnectIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(img, "class", "icon");
      attr(p2, "class", "caption");
      attr(button0, "class", "delete material-icons-round");
      attr(div, "class", "right");
      attr(button1, "class", "option");
      toggle_class(
        button1,
        "selected",
        /*selected*/
        ctx[0] == /*server*/
        ctx[1].hostname
      );
    },
    m(target, anchor) {
      insert(target, button1, anchor);
      append(button1, img);
      append(button1, t0);
      append(button1, p2);
      append(p2, t1);
      append(button1, t2);
      append(button1, div);
      append(div, button0);
      append(div, t4);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*remove*/
            ctx[3]
          ),
          listen(
            button1,
            "click",
            /*select*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*server*/
      2 && t1_value !== (t1_value = /*server*/
      ctx2[1].hostname + ""))
        set_data(t1, t1_value);
      if (
        /*server*/
        ctx2[1].private
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$1();
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*selected, server*/
      3) {
        toggle_class(
          button1,
          "selected",
          /*selected*/
          ctx2[0] == /*server*/
          ctx2[1].hostname
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button1);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let { server } = $$props;
  let { selected } = $$props;
  let { update: update2 } = $$props;
  function select() {
    $$invalidate(0, selected = server.hostname);
  }
  function remove() {
    removeServer(server.hostname);
    const servers = getAllServers();
    if (!servers.length)
      return PrimaryState.navigate("fts");
    $$invalidate(0, selected = servers[0]);
    update2();
  }
  $$self.$$set = ($$props2) => {
    if ("server" in $$props2)
      $$invalidate(1, server = $$props2.server);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("update" in $$props2)
      $$invalidate(4, update2 = $$props2.update);
  };
  return [selected, server, select, remove, update2];
}
class Option extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3, create_fragment$4, safe_not_equal, { server: 1, selected: 0, update: 4 });
  }
}
function get_each_context(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  return child_ctx;
}
function create_each_block(ctx) {
  let option;
  let updating_selected;
  let current;
  function option_selected_binding(value) {
    ctx[3](value);
  }
  let option_props = {
    server: (
      /*server*/
      ctx[4]
    ),
    update: (
      /*update*/
      ctx[2]
    )
  };
  if (
    /*selected*/
    ctx[0] !== void 0
  ) {
    option_props.selected = /*selected*/
    ctx[0];
  }
  option = new Option({ props: option_props });
  binding_callbacks.push(() => bind$1(option, "selected", option_selected_binding));
  return {
    c() {
      create_component(option.$$.fragment);
    },
    m(target, anchor) {
      mount_component(option, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const option_changes = {};
      if (dirty & /*servers*/
      2)
        option_changes.server = /*server*/
        ctx2[4];
      if (!updating_selected && dirty & /*selected*/
      1) {
        updating_selected = true;
        option_changes.selected = /*selected*/
        ctx2[0];
        add_flush_callback(() => updating_selected = false);
      }
      option.$set(option_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(option.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(option.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(option, detaching);
    }
  };
}
function create_fragment$3(ctx) {
  let div1;
  let div0;
  let t2;
  let actions;
  let current;
  let each_value = ensure_array_like(
    /*servers*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  actions = new Actions8({
    props: {
      selected: (
        /*selected*/
        ctx[0]
      ),
      servers: (
        /*servers*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      create_component(actions.$$.fragment);
      attr(div0, "class", "options");
      attr(div1, "class", "selector");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div1, t2);
      mount_component(actions, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*servers, update, selected*/
      7) {
        each_value = ensure_array_like(
          /*servers*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const actions_changes = {};
      if (dirty & /*selected*/
      1)
        actions_changes.selected = /*selected*/
        ctx2[0];
      if (dirty & /*servers*/
      2)
        actions_changes.servers = /*servers*/
        ctx2[1];
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      destroy_component(actions);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let { selected = "" } = $$props;
  let { servers = [] } = $$props;
  async function update2() {
    $$invalidate(1, servers = []);
    const list2 = getAllServers().sort();
    for (let i2 = 0; i2 < list2.length; i2++) {
      const ac = getAuthcode(list2[i2]);
      servers.push({
        hostname: list2[i2],
        private: !!ac,
        authCode: ac
      });
    }
  }
  onMount(update2);
  function option_selected_binding(value) {
    selected = value;
    $$invalidate(0, selected);
  }
  $$self.$$set = ($$props2) => {
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("servers" in $$props2)
      $$invalidate(1, servers = $$props2.servers);
  };
  return [selected, servers, update2, option_selected_binding];
}
class Selector2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2, create_fragment$3, safe_not_equal, { selected: 0, servers: 1 });
  }
}
const main = "";
function create_fragment$2(ctx) {
  let div3;
  let window2;
  let div1;
  let t2;
  let div2;
  let selector;
  let updating_selected;
  let updating_servers;
  let current;
  function selector_selected_binding(value) {
    ctx[3](value);
  }
  function selector_servers_binding(value) {
    ctx[4](value);
  }
  let selector_props = {};
  if (
    /*selected*/
    ctx[0] !== void 0
  ) {
    selector_props.selected = /*selected*/
    ctx[0];
  }
  if (
    /*servers*/
    ctx[1] !== void 0
  ) {
    selector_props.servers = /*servers*/
    ctx[1];
  }
  selector = new Selector2({ props: selector_props });
  binding_callbacks.push(() => bind$1(selector, "selected", selector_selected_binding));
  binding_callbacks.push(() => bind$1(selector, "servers", selector_servers_binding));
  return {
    c() {
      div3 = element("div");
      window2 = element("window");
      div1 = element("div");
      div1.innerHTML = `<div class="title"><span class="title-wrapper"><img src="${ConnectIcon}" alt=""/> <span class="title-text">Choose Server</span></span></div>`;
      t2 = space();
      div2 = element("div");
      create_component(selector.$$.fragment);
      attr(div1, "class", "titlebar");
      attr(div2, "class", "body");
      attr(window2, "class", "ss-inner visible glass bigtb focused");
      attr(div3, "class", "serverselect theme-dark fullscreen");
      toggle_class(
        div3,
        "show",
        /*show*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, window2);
      append(window2, div1);
      append(window2, t2);
      append(window2, div2);
      mount_component(selector, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const selector_changes = {};
      if (!updating_selected && dirty & /*selected*/
      1) {
        updating_selected = true;
        selector_changes.selected = /*selected*/
        ctx2[0];
        add_flush_callback(() => updating_selected = false);
      }
      if (!updating_servers && dirty & /*servers*/
      2) {
        updating_servers = true;
        selector_changes.servers = /*servers*/
        ctx2[1];
        add_flush_callback(() => updating_servers = false);
      }
      selector.$set(selector_changes);
      if (!current || dirty & /*show*/
      4) {
        toggle_class(
          div3,
          "show",
          /*show*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(selector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(selector);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let selected = "";
  let servers = [];
  let show = false;
  onMount(async () => {
    if (!getAllServers().length) {
      PrimaryState.navigate("fts");
      return;
    }
    $$invalidate(0, selected = getServer());
    await sleep(500);
    $$invalidate(2, show = true);
  });
  function selector_selected_binding(value) {
    selected = value;
    $$invalidate(0, selected);
  }
  function selector_servers_binding(value) {
    servers = value;
    $$invalidate(1, servers);
  }
  return [selected, servers, show, selector_selected_binding, selector_servers_binding];
}
class ServerSelect extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1, create_fragment$2, safe_not_equal, {});
  }
}
const safetoturnoff = "" + new URL("safetoturnoff-1aac1218.png", import.meta.url).href;
const TurnedOff_svelte_svelte_type_style_lang = "";
function create_fragment$1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<img src="${safetoturnoff}" alt="It&#39;s now safe to turn off your ArcOS." class="svelte-1kzg8gn"/>`;
      attr(div, "class", "svelte-1kzg8gn");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
class TurnedOff extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$1, safe_not_equal, {});
  }
}
const primaryStates = /* @__PURE__ */ new Map([
  [
    "boot",
    {
      name: "Boot",
      key: "boot",
      content: Boot,
      attribs: {}
    }
  ],
  [
    "arcterm",
    {
      name: "ArcTerm",
      key: "arcterm",
      content: ArcTerm_1,
      attribs: {}
    }
  ],
  [
    "fts",
    {
      name: "First Time Setup",
      key: "fts",
      content: FirstTimeSetup,
      attribs: {}
    }
  ],
  [
    "login",
    {
      name: "Login",
      key: "login",
      content: Login_1,
      attribs: {
        noProcesssRenderer: true
      }
    }
  ],
  [
    "logoff",
    {
      name: "Logoff",
      content: Login_1,
      attribs: {
        continuation: "logoff",
        noProcesssRenderer: true
      },
      key: "logoff",
      onload() {
        ArcSoundBus.playSound("arcos.system.logoff");
      }
    }
  ],
  [
    "restart",
    {
      name: "Restart",
      content: Login_1,
      attribs: {
        continuation: "restart",
        noProcesssRenderer: true
      },
      key: "restart",
      onload() {
        ArcSoundBus.playSound("arcos.system.logoff");
      }
    }
  ],
  [
    "shutdown",
    {
      name: "Shutdown",
      content: Login_1,
      attribs: {
        continuation: "shutdown",
        noProcesssRenderer: true
      },
      key: "shutdown",
      onload() {
        ArcSoundBus.playSound("arcos.system.logoff");
      }
    }
  ],
  [
    "desktop",
    {
      name: "Desktop",
      key: "desktop",
      content: Desktop2,
      attribs: {
        noProcesssRenderer: true
      }
    }
  ],
  [
    "crash",
    {
      name: "Aw, Snap!",
      key: "crash",
      content: Crash,
      attribs: {
        noProcesssRenderer: true,
        classes: "sharp noani theme-amoled"
      }
    }
  ],
  [
    "turnedoff",
    {
      name: "Turned off",
      content: TurnedOff,
      attribs: {
        noProcesssRenderer: true
      },
      key: "turnedoff",
      onload() {
        window.close();
      }
    }
  ],
  [
    "serverselect",
    {
      name: "Choose Server",
      content: ServerSelect,
      attribs: {
        noProcesssRenderer: true
      },
      key: "serverselect"
    }
  ]
]);
const WATCHERS = [];
class StateWatcher {
  constructor(handler) {
    this.handler = handler;
    Log("states/watch", `Created new StateWatcher for handler ${handler.id}`);
    handler.current.subscribe((v2) => this.trigger(v2));
  }
  watch(event) {
    const id = this.handler.id;
    Log("state/watch", `StateWatcher.watch ${id}: Adding watcher: ${event.toString()}`);
    WATCHERS.push(event);
    event(this.handler.current.get());
  }
  async trigger(state) {
    const id = this.handler.id;
    for (const watcher of WATCHERS) {
      Log(
        "states/watch",
        `StateWatcher.trigger ${id}: Triggering watcher: state changing to ${state.key}`
      );
      await watcher(state);
    }
  }
}
class StateHandler {
  constructor(id, store, startState, preNavigate = true) {
    __publicField(this, "current", Store$1());
    __publicField(this, "watcher");
    __publicField(this, "store");
    __publicField(this, "startState");
    __publicField(this, "id");
    this.id = id;
    this.store = store;
    this.startState = startState;
    Log(
      "states",
      `Created StateHandler "${id}" with ${store.size} states (starts at ${startState})`
    );
    this.watcher = new StateWatcher(this);
    if (preNavigate)
      this.navigate(startState);
  }
  navigate(stateKey) {
    Log("states", `StateHandler.navigate[${this.id}]: Navigating to "${stateKey}"`);
    const has = this.store.has(stateKey);
    if (!has)
      Log(
        "states",
        `StateHandler.navigate[${this.id}]: No such state ${stateKey}, falling back to ${this.startState}`,
        LogLevel.warn
      );
    const state = this.store.get(has ? stateKey : this.startState);
    if (state.onload)
      state.onload();
    document.title = `ArcOS | ${state.name}`;
    this.current.set(state);
    return true;
  }
}
const PrimaryState = new StateHandler("ArcOS", primaryStates, "boot");
const bannedKeys = ["tab", "pagedown", "pageup"];
class AcceleratorHandler {
  constructor(process) {
    __publicField(this, "store", []);
    this.process = process;
    this.Log(`Creating new AcceleratorHandler for PID ${process.pid}`);
    if (!process.app || !process.app.accelerators) {
      this.Log("No app data to go off of! Assuming later injection.", LogLevel.warn);
    }
    this.store = this.process.app.accelerators || [];
    this.startListener();
  }
  Log(message, level) {
    Log("apps/keyboard", `AcceleratorHandler[${this.process.pid}]: ${message}`, level);
  }
  startListener() {
    this.Log("Starting listener!");
    document.addEventListener("keydown", (e2) => this.processor(e2));
  }
  stopListener() {
    this.Log("Stopping listener!", LogLevel.warn);
    document.removeEventListener("keydown", (e2) => this.processor(e2));
  }
  processor(e2) {
    if (!e2.key)
      return;
    if (bannedKeys.includes(e2.key.toLowerCase())) {
      e2.preventDefault();
      return false;
    }
    this.unfocusActiveElement();
    const state = PrimaryState.current.get().key;
    if (state != "desktop")
      return;
    for (const combo of this.store) {
      const alt = combo.alt ? e2.altKey : true;
      const ctrl = combo.ctrl ? e2.ctrlKey : true;
      const shift = combo.shift ? e2.shiftKey : true;
      const modifiers = alt && ctrl && shift;
      const pK = e2.key.toLowerCase().trim();
      const key2 = combo.key.trim().toLowerCase();
      const codedKey = String.fromCharCode(e2.keyCode).toLowerCase();
      const isFocused = focusedPid.get() == this.process.pid || combo.global;
      if (!modifiers || key2 != pK && key2 && key2 != codedKey || !isFocused)
        continue;
      combo.action(this.process);
      break;
    }
  }
  unfocusActiveElement() {
    const el = document.activeElement;
    if (!el || el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement)
      return;
    el.blur();
  }
}
function handleWindowError(e2) {
  var _a;
  if (CRASHING.get())
    return Log(
      "bugrep/crash/window",
      "Crash prevented because another crash is already in progress!",
      LogLevel.warn
    );
  const error = e2;
  const rejection = e2;
  const filename = error.filename || rejection.reason.name;
  const position = error.lineno ? `(${error.lineno}:${error.colno})` : "";
  const message = error.message || rejection.reason.message;
  const name = rejection.reason.name;
  const stack = ((_a = error.error) == null ? void 0 : _a.stack) || rejection.reason.stack;
  if (rejection && rejection.reason && isBlackListed(rejection.reason.name) || message && message.includes("dynamically imported module"))
    return Log(
      "bugrep/crash/window",
      `Not making a report for ${name} or failed app sideload`,
      LogLevel.warn
    );
  CRASHING.set(true);
  Log("ArcOS", `------(#! [ SYSTEM IS CRASHING ] !#)------`, LogLevel.error);
  const options2 = {
    includeUserData: false,
    includeApi: true,
    title: "Crash by irrecoverable unhandled exception",
    body: `File: ${filename} ${position}

${message}

${stack || "  at ArcOS (no stack)"}`
  };
  const report = createReport(options2);
  CrashReport.set(report);
  Log(`bugrep/crash/window`, `Error: ${filename}: ${message}`, LogLevel.error);
  PrimaryState.navigate("crash");
  sendReport(options2);
}
function isBlackListed(test) {
  if (!test)
    return false;
  for (const item of CRASH_BLACKLIST) {
    if (test.includes(item))
      return true;
  }
  return false;
}
async function setCrashHooks() {
  Log("bugrep/hooks", "Setting crash hooks");
  window.onunhandledrejection = (e2) => {
    handleWindowError(e2);
  };
}
function create_if_block(ctx) {
  let div;
  let staterenderer;
  let current;
  staterenderer = new StateRenderer({
    props: {
      handler: PrimaryState,
      renderProcesses: true
    }
  });
  return {
    c() {
      div = element("div");
      create_component(staterenderer.$$.fragment);
      attr(div, "class", "app theme-dark fullscreen");
      toggle_class(
        div,
        "safemode",
        /*$SafeMode*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(staterenderer, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*$SafeMode*/
      4) {
        toggle_class(
          div,
          "safemode",
          /*$SafeMode*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(staterenderer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(staterenderer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(staterenderer);
    }
  };
}
function create_fragment(ctx) {
  let link;
  let t2;
  let if_block_anchor;
  let current;
  let if_block = (
    /*render*/
    ctx[0] && create_if_block(ctx)
  );
  return {
    c() {
      link = element("link");
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(link, "rel", "icon");
      attr(
        link,
        "href",
        /*logo*/
        ctx[1]
      );
    },
    m(target, anchor) {
      append(document.head, link);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*logo*/
      2) {
        attr(
          link,
          "href",
          /*logo*/
          ctx2[1]
        );
      }
      if (
        /*render*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*render*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      detach(link);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $SafeMode;
  component_subscribe($$self, SafeMode, ($$value) => $$invalidate(2, $SafeMode = $$value));
  let render = false;
  let logo = ComponentIcon;
  onMount(async () => {
    $$invalidate(0, render = false);
    await getMode();
    await getBuild();
    await getDesktopMode();
    Log("ArcOS", `***** [v6 -> ArcOS Stable v${ArcOSVersion}-${ARCOS_MODE}_${ARCOS_BUILD} -> ${DESKTOP_MODE}] *****`);
    $$invalidate(1, logo = Logo());
    $$invalidate(0, render = true);
  });
  return [render, logo, $SafeMode];
}
class App31 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance, create_fragment, safe_not_equal, {});
  }
}
document.addEventListener("contextmenu", (e2) => e2.preventDefault());
setLoggingHooks();
setCrashHooks();
new App31({
  target: document.getElementById("app")
});

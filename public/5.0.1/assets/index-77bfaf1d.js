var wt = Object.defineProperty;
var kt = (k, r, p) =>
  r in k
    ? wt(k, r, { enumerable: !0, configurable: !0, writable: !0, value: p })
    : (k[r] = p);
var _e = (k, r, p) => (kt(k, typeof r != "symbol" ? r + "" : r, p), p);
(function () {
  const r = document.createElement("link").relList;
  if (r && r.supports && r.supports("modulepreload")) return;
  for (const $ of document.querySelectorAll('link[rel="modulepreload"]')) v($);
  new MutationObserver(($) => {
    for (const S of $)
      if (S.type === "childList")
        for (const x of S.addedNodes)
          x.tagName === "LINK" && x.rel === "modulepreload" && v(x);
  }).observe(document, { childList: !0, subtree: !0 });
  function p($) {
    const S = {};
    return (
      $.integrity && (S.integrity = $.integrity),
      $.referrerpolicy && (S.referrerPolicy = $.referrerpolicy),
      $.crossorigin === "use-credentials"
        ? (S.credentials = "include")
        : $.crossorigin === "anonymous"
        ? (S.credentials = "omit")
        : (S.credentials = "same-origin"),
      S
    );
  }
  function v($) {
    if ($.ep) return;
    $.ep = !0;
    const S = p($);
    fetch($.href, S);
  }
})();
function noop$1() {}
function assign(k, r) {
  for (const p in r) k[p] = r[p];
  return k;
}
function run(k) {
  return k();
}
function blank_object() {
  return Object.create(null);
}
function run_all(k) {
  k.forEach(run);
}
function is_function(k) {
  return typeof k == "function";
}
function safe_not_equal(k, r) {
  return k != k
    ? r == r
    : k !== r || (k && typeof k == "object") || typeof k == "function";
}
let src_url_equal_anchor;
function src_url_equal(k, r) {
  return (
    src_url_equal_anchor ||
      (src_url_equal_anchor = document.createElement("a")),
    (src_url_equal_anchor.href = r),
    k === src_url_equal_anchor.href
  );
}
function is_empty(k) {
  return Object.keys(k).length === 0;
}
function subscribe(k, ...r) {
  if (k == null) return noop$1;
  const p = k.subscribe(...r);
  return p.unsubscribe ? () => p.unsubscribe() : p;
}
function get_store_value(k) {
  let r;
  return subscribe(k, (p) => (r = p))(), r;
}
function component_subscribe(k, r, p) {
  k.$$.on_destroy.push(subscribe(r, p));
}
function create_slot(k, r, p, v) {
  if (k) {
    const $ = get_slot_context(k, r, p, v);
    return k[0]($);
  }
}
function get_slot_context(k, r, p, v) {
  return k[1] && v ? assign(p.ctx.slice(), k[1](v(r))) : p.ctx;
}
function get_slot_changes(k, r, p, v) {
  if (k[2] && v) {
    const $ = k[2](v(p));
    if (r.dirty === void 0) return $;
    if (typeof $ == "object") {
      const S = [],
        x = Math.max(r.dirty.length, $.length);
      for (let I = 0; I < x; I += 1) S[I] = r.dirty[I] | $[I];
      return S;
    }
    return r.dirty | $;
  }
  return r.dirty;
}
function update_slot_base(k, r, p, v, $, S) {
  if ($) {
    const x = get_slot_context(r, p, v, S);
    k.p(x, $);
  }
}
function get_all_dirty_from_scope(k) {
  if (k.ctx.length > 32) {
    const r = [],
      p = k.ctx.length / 32;
    for (let v = 0; v < p; v++) r[v] = -1;
    return r;
  }
  return -1;
}
function exclude_internal_props(k) {
  const r = {};
  for (const p in k) p[0] !== "$" && (r[p] = k[p]);
  return r;
}
function compute_rest_props(k, r) {
  const p = {};
  r = new Set(r);
  for (const v in k) !r.has(v) && v[0] !== "$" && (p[v] = k[v]);
  return p;
}
function set_store_value(k, r, p) {
  return k.set(p), r;
}
const is_client = typeof window < "u";
let raf = is_client ? (k) => requestAnimationFrame(k) : noop$1;
function append(k, r) {
  k.appendChild(r);
}
function insert(k, r, p) {
  k.insertBefore(r, p || null);
}
function detach(k) {
  k.parentNode && k.parentNode.removeChild(k);
}
function destroy_each(k, r) {
  for (let p = 0; p < k.length; p += 1) k[p] && k[p].d(r);
}
function element(k) {
  return document.createElement(k);
}
function svg_element(k) {
  return document.createElementNS("http://www.w3.org/2000/svg", k);
}
function text(k) {
  return document.createTextNode(k);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(k, r, p, v) {
  return k.addEventListener(r, p, v), () => k.removeEventListener(r, p, v);
}
function attr(k, r, p) {
  p == null
    ? k.removeAttribute(r)
    : k.getAttribute(r) !== p && k.setAttribute(r, p);
}
function children(k) {
  return Array.from(k.childNodes);
}
function set_data(k, r) {
  (r = "" + r), k.wholeText !== r && (k.data = r);
}
function set_input_value(k, r) {
  k.value = r ?? "";
}
function set_style(k, r, p, v) {
  p === null
    ? k.style.removeProperty(r)
    : k.style.setProperty(r, p, v ? "important" : "");
}
function select_option(k, r, p) {
  for (let v = 0; v < k.options.length; v += 1) {
    const $ = k.options[v];
    if ($.__value === r) {
      $.selected = !0;
      return;
    }
  }
  (!p || r !== void 0) && (k.selectedIndex = -1);
}
function select_value(k) {
  const r = k.querySelector(":checked");
  return r && r.__value;
}
function toggle_class(k, r, p) {
  k.classList[p ? "add" : "remove"](r);
}
function custom_event(k, r, { bubbles: p = !1, cancelable: v = !1 } = {}) {
  const $ = document.createEvent("CustomEvent");
  return $.initCustomEvent(k, p, v, r), $;
}
class HtmlTag {
  constructor(r = !1) {
    (this.is_svg = !1), (this.is_svg = r), (this.e = this.n = null);
  }
  c(r) {
    this.h(r);
  }
  m(r, p, v = null) {
    this.e ||
      (this.is_svg
        ? (this.e = svg_element(p.nodeName))
        : (this.e = element(p.nodeType === 11 ? "TEMPLATE" : p.nodeName)),
      (this.t = p.tagName !== "TEMPLATE" ? p : p.content),
      this.c(r)),
      this.i(v);
  }
  h(r) {
    (this.e.innerHTML = r),
      (this.n = Array.from(
        this.e.nodeName === "TEMPLATE"
          ? this.e.content.childNodes
          : this.e.childNodes
      ));
  }
  i(r) {
    for (let p = 0; p < this.n.length; p += 1) insert(this.t, this.n[p], r);
  }
  p(r) {
    this.d(), this.h(r), this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
}
function construct_svelte_component(k, r) {
  return new k(r);
}
let current_component;
function set_current_component(k) {
  current_component = k;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(k) {
  get_current_component().$$.on_mount.push(k);
}
function createEventDispatcher() {
  const k = get_current_component();
  return (r, p, { cancelable: v = !1 } = {}) => {
    const $ = k.$$.callbacks[r];
    if ($) {
      const S = custom_event(r, p, { cancelable: v });
      return (
        $.slice().forEach((x) => {
          x.call(k, S);
        }),
        !S.defaultPrevented
      );
    }
    return !0;
  };
}
function setContext(k, r) {
  return get_current_component().$$.context.set(k, r), r;
}
function getContext(k) {
  return get_current_component().$$.context.get(k);
}
const dirty_components = [],
  binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [],
  resolved_promise = Promise.resolve();
let update_scheduled = !1;
function schedule_update() {
  update_scheduled || ((update_scheduled = !0), resolved_promise.then(flush$1));
}
function add_render_callback(k) {
  render_callbacks.push(k);
}
function add_flush_callback(k) {
  flush_callbacks.push(k);
}
const seen_callbacks = new Set();
let flushidx = 0;
function flush$1() {
  if (flushidx !== 0) return;
  const k = current_component;
  do {
    try {
      for (; flushidx < dirty_components.length; ) {
        const r = dirty_components[flushidx];
        flushidx++, set_current_component(r), update(r.$$);
      }
    } catch (r) {
      throw ((dirty_components.length = 0), (flushidx = 0), r);
    }
    for (
      set_current_component(null), dirty_components.length = 0, flushidx = 0;
      binding_callbacks.length;

    )
      binding_callbacks.pop()();
    for (let r = 0; r < render_callbacks.length; r += 1) {
      const p = render_callbacks[r];
      seen_callbacks.has(p) || (seen_callbacks.add(p), p());
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  for (; flush_callbacks.length; ) flush_callbacks.pop()();
  (update_scheduled = !1), seen_callbacks.clear(), set_current_component(k);
}
function update(k) {
  if (k.fragment !== null) {
    k.update(), run_all(k.before_update);
    const r = k.dirty;
    (k.dirty = [-1]),
      k.fragment && k.fragment.p(k.ctx, r),
      k.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(k) {
  const r = [],
    p = [];
  render_callbacks.forEach((v) =>
    k.indexOf(v) === -1 ? r.push(v) : p.push(v)
  ),
    p.forEach((v) => v()),
    (render_callbacks = r);
}
const outroing = new Set();
let outros;
function group_outros() {
  outros = { r: 0, c: [], p: outros };
}
function check_outros() {
  outros.r || run_all(outros.c), (outros = outros.p);
}
function transition_in(k, r) {
  k && k.i && (outroing.delete(k), k.i(r));
}
function transition_out(k, r, p, v) {
  if (k && k.o) {
    if (outroing.has(k)) return;
    outroing.add(k),
      outros.c.push(() => {
        outroing.delete(k), v && (p && k.d(1), v());
      }),
      k.o(r);
  } else v && v();
}
function get_spread_update(k, r) {
  const p = {},
    v = {},
    $ = { $$scope: 1 };
  let S = k.length;
  for (; S--; ) {
    const x = k[S],
      I = r[S];
    if (I) {
      for (const F in x) F in I || (v[F] = 1);
      for (const F in I) $[F] || ((p[F] = I[F]), ($[F] = 1));
      k[S] = I;
    } else for (const F in x) $[F] = 1;
  }
  for (const x in v) x in p || (p[x] = void 0);
  return p;
}
function get_spread_object(k) {
  return typeof k == "object" && k !== null ? k : {};
}
function bind$1(k, r, p) {
  const v = k.$$.props[r];
  v !== void 0 && ((k.$$.bound[v] = p), p(k.$$.ctx[v]));
}
function create_component(k) {
  k && k.c();
}
function mount_component(k, r, p, v) {
  const { fragment: $, after_update: S } = k.$$;
  $ && $.m(r, p),
    v ||
      add_render_callback(() => {
        const x = k.$$.on_mount.map(run).filter(is_function);
        k.$$.on_destroy ? k.$$.on_destroy.push(...x) : run_all(x),
          (k.$$.on_mount = []);
      }),
    S.forEach(add_render_callback);
}
function destroy_component(k, r) {
  const p = k.$$;
  p.fragment !== null &&
    (flush_render_callbacks(p.after_update),
    run_all(p.on_destroy),
    p.fragment && p.fragment.d(r),
    (p.on_destroy = p.fragment = null),
    (p.ctx = []));
}
function make_dirty(k, r) {
  k.$$.dirty[0] === -1 &&
    (dirty_components.push(k), schedule_update(), k.$$.dirty.fill(0)),
    (k.$$.dirty[(r / 31) | 0] |= 1 << r % 31);
}
function init(k, r, p, v, $, S, x, I = [-1]) {
  const F = current_component;
  set_current_component(k);
  const O = (k.$$ = {
    fragment: null,
    ctx: [],
    props: S,
    update: noop$1,
    not_equal: $,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(r.context || (F ? F.$$.context : [])),
    callbacks: blank_object(),
    dirty: I,
    skip_bound: !1,
    root: r.target || F.$$.root,
  });
  x && x(O.root);
  let L = !1;
  if (
    ((O.ctx = p
      ? p(k, r.props || {}, (U, j, ...N) => {
          const q = N.length ? N[0] : j;
          return (
            O.ctx &&
              $(O.ctx[U], (O.ctx[U] = q)) &&
              (!O.skip_bound && O.bound[U] && O.bound[U](q),
              L && make_dirty(k, U)),
            j
          );
        })
      : []),
    O.update(),
    (L = !0),
    run_all(O.before_update),
    (O.fragment = v ? v(O.ctx) : !1),
    r.target)
  ) {
    if (r.hydrate) {
      const U = children(r.target);
      O.fragment && O.fragment.l(U), U.forEach(detach);
    } else O.fragment && O.fragment.c();
    r.intro && transition_in(k.$$.fragment),
      mount_component(k, r.target, r.anchor, r.customElement),
      flush$1();
  }
  set_current_component(F);
}
class SvelteComponent {
  $destroy() {
    destroy_component(this, 1), (this.$destroy = noop$1);
  }
  $on(r, p) {
    if (!is_function(p)) return noop$1;
    const v = this.$$.callbacks[r] || (this.$$.callbacks[r] = []);
    return (
      v.push(p),
      () => {
        const $ = v.indexOf(p);
        $ !== -1 && v.splice($, 1);
      }
    );
  }
  $set(r) {
    this.$$set &&
      !is_empty(r) &&
      ((this.$$.skip_bound = !0), this.$$set(r), (this.$$.skip_bound = !1));
  }
}
const main$1 = "",
  logo$c = "./assets/systemIcon-393c5507.svg",
  bugrep = "",
  subscriber_queue = [];
function writable(k, r = noop$1) {
  let p;
  const v = new Set();
  function $(I) {
    if (safe_not_equal(k, I) && ((k = I), p)) {
      const F = !subscriber_queue.length;
      for (const O of v) O[1](), subscriber_queue.push(O, k);
      if (F) {
        for (let O = 0; O < subscriber_queue.length; O += 2)
          subscriber_queue[O][0](subscriber_queue[O + 1]);
        subscriber_queue.length = 0;
      }
    }
  }
  function S(I) {
    $(I(k));
  }
  function x(I, F = noop$1) {
    const O = [I, F];
    return (
      v.add(O),
      v.size === 1 && (p = r($) || noop$1),
      I(k),
      () => {
        v.delete(O), v.size === 0 && p && (p(), (p = null));
      }
    );
  }
  return { set: $, update: S, subscribe: x };
}
var commonjsGlobal =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function getAugmentedNamespace(k) {
  if (k.__esModule) return k;
  var r = k.default;
  if (typeof r == "function") {
    var p = function v() {
      if (this instanceof v) {
        var $ = [null];
        $.push.apply($, arguments);
        var S = Function.bind.apply(r, $);
        return new S();
      }
      return r.apply(this, arguments);
    };
    p.prototype = r.prototype;
  } else p = {};
  return (
    Object.defineProperty(p, "__esModule", { value: !0 }),
    Object.keys(k).forEach(function (v) {
      var $ = Object.getOwnPropertyDescriptor(k, v);
      Object.defineProperty(
        p,
        v,
        $.get
          ? $
          : {
              enumerable: !0,
              get: function () {
                return k[v];
              },
            }
      );
    }),
    p
  );
}
var dayjs_minExports = {},
  dayjs_min = {
    get exports() {
      return dayjs_minExports;
    },
    set exports(k) {
      dayjs_minExports = k;
    },
  };
(function (k, r) {
  (function (p, v) {
    k.exports = v();
  })(commonjsGlobal, function () {
    var p = 1e3,
      v = 6e4,
      $ = 36e5,
      S = "millisecond",
      x = "second",
      I = "minute",
      F = "hour",
      O = "day",
      L = "week",
      U = "month",
      j = "quarter",
      N = "year",
      q = "date",
      R = "Invalid Date",
      Q =
        /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
      H =
        /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
      G = {
        name: "en",
        weekdays:
          "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months:
          "January_February_March_April_May_June_July_August_September_October_November_December".split(
            "_"
          ),
        ordinal: function (le) {
          var se = ["th", "st", "nd", "rd"],
            ae = le % 100;
          return "[" + le + (se[(ae - 20) % 10] || se[ae] || se[0]) + "]";
        },
      },
      V = function (le, se, ae) {
        var oe = String(le);
        return !oe || oe.length >= se
          ? le
          : "" + Array(se + 1 - oe.length).join(ae) + le;
      },
      K = {
        s: V,
        z: function (le) {
          var se = -le.utcOffset(),
            ae = Math.abs(se),
            oe = Math.floor(ae / 60),
            ie = ae % 60;
          return (se <= 0 ? "+" : "-") + V(oe, 2, "0") + ":" + V(ie, 2, "0");
        },
        m: function le(se, ae) {
          if (se.date() < ae.date()) return -le(ae, se);
          var oe = 12 * (ae.year() - se.year()) + (ae.month() - se.month()),
            ie = se.clone().add(oe, U),
            ne = ae - ie < 0,
            ce = se.clone().add(oe + (ne ? -1 : 1), U);
          return +(-(oe + (ae - ie) / (ne ? ie - ce : ce - ie)) || 0);
        },
        a: function (le) {
          return le < 0 ? Math.ceil(le) || 0 : Math.floor(le);
        },
        p: function (le) {
          return (
            { M: U, y: N, w: L, d: O, D: q, h: F, m: I, s: x, ms: S, Q: j }[
              le
            ] ||
            String(le || "")
              .toLowerCase()
              .replace(/s$/, "")
          );
        },
        u: function (le) {
          return le === void 0;
        },
      },
      Y = "en",
      J = {};
    J[Y] = G;
    var Z = function (le) {
        return le instanceof re;
      },
      X = function le(se, ae, oe) {
        var ie;
        if (!se) return Y;
        if (typeof se == "string") {
          var ne = se.toLowerCase();
          J[ne] && (ie = ne), ae && ((J[ne] = ae), (ie = ne));
          var ce = se.split("-");
          if (!ie && ce.length > 1) return le(ce[0]);
        } else {
          var ue = se.name;
          (J[ue] = se), (ie = ue);
        }
        return !oe && ie && (Y = ie), ie || (!oe && Y);
      },
      ee = function (le, se) {
        if (Z(le)) return le.clone();
        var ae = typeof se == "object" ? se : {};
        return (ae.date = le), (ae.args = arguments), new re(ae);
      },
      te = K;
    (te.l = X),
      (te.i = Z),
      (te.w = function (le, se) {
        return ee(le, {
          locale: se.$L,
          utc: se.$u,
          x: se.$x,
          $offset: se.$offset,
        });
      });
    var re = (function () {
        function le(ae) {
          (this.$L = X(ae.locale, null, !0)), this.parse(ae);
        }
        var se = le.prototype;
        return (
          (se.parse = function (ae) {
            (this.$d = (function (oe) {
              var ie = oe.date,
                ne = oe.utc;
              if (ie === null) return new Date(NaN);
              if (te.u(ie)) return new Date();
              if (ie instanceof Date) return new Date(ie);
              if (typeof ie == "string" && !/Z$/i.test(ie)) {
                var ce = ie.match(Q);
                if (ce) {
                  var ue = ce[2] - 1 || 0,
                    me = (ce[7] || "0").substring(0, 3);
                  return ne
                    ? new Date(
                        Date.UTC(
                          ce[1],
                          ue,
                          ce[3] || 1,
                          ce[4] || 0,
                          ce[5] || 0,
                          ce[6] || 0,
                          me
                        )
                      )
                    : new Date(
                        ce[1],
                        ue,
                        ce[3] || 1,
                        ce[4] || 0,
                        ce[5] || 0,
                        ce[6] || 0,
                        me
                      );
                }
              }
              return new Date(ie);
            })(ae)),
              (this.$x = ae.x || {}),
              this.init();
          }),
          (se.init = function () {
            var ae = this.$d;
            (this.$y = ae.getFullYear()),
              (this.$M = ae.getMonth()),
              (this.$D = ae.getDate()),
              (this.$W = ae.getDay()),
              (this.$H = ae.getHours()),
              (this.$m = ae.getMinutes()),
              (this.$s = ae.getSeconds()),
              (this.$ms = ae.getMilliseconds());
          }),
          (se.$utils = function () {
            return te;
          }),
          (se.isValid = function () {
            return this.$d.toString() !== R;
          }),
          (se.isSame = function (ae, oe) {
            var ie = ee(ae);
            return this.startOf(oe) <= ie && ie <= this.endOf(oe);
          }),
          (se.isAfter = function (ae, oe) {
            return ee(ae) < this.startOf(oe);
          }),
          (se.isBefore = function (ae, oe) {
            return this.endOf(oe) < ee(ae);
          }),
          (se.$g = function (ae, oe, ie) {
            return te.u(ae) ? this[oe] : this.set(ie, ae);
          }),
          (se.unix = function () {
            return Math.floor(this.valueOf() / 1e3);
          }),
          (se.valueOf = function () {
            return this.$d.getTime();
          }),
          (se.startOf = function (ae, oe) {
            var ie = this,
              ne = !!te.u(oe) || oe,
              ce = te.p(ae),
              ue = function (ve, be) {
                var xe = te.w(
                  ie.$u ? Date.UTC(ie.$y, be, ve) : new Date(ie.$y, be, ve),
                  ie
                );
                return ne ? xe : xe.endOf(O);
              },
              me = function (ve, be) {
                return te.w(
                  ie
                    .toDate()
                    [ve].apply(
                      ie.toDate("s"),
                      (ne ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(be)
                    ),
                  ie
                );
              },
              pe = this.$W,
              de = this.$M,
              ge = this.$D,
              Ae = "set" + (this.$u ? "UTC" : "");
            switch (ce) {
              case N:
                return ne ? ue(1, 0) : ue(31, 11);
              case U:
                return ne ? ue(1, de) : ue(0, de + 1);
              case L:
                var $e = this.$locale().weekStart || 0,
                  ke = (pe < $e ? pe + 7 : pe) - $e;
                return ue(ne ? ge - ke : ge + (6 - ke), de);
              case O:
              case q:
                return me(Ae + "Hours", 0);
              case F:
                return me(Ae + "Minutes", 1);
              case I:
                return me(Ae + "Seconds", 2);
              case x:
                return me(Ae + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }),
          (se.endOf = function (ae) {
            return this.startOf(ae, !1);
          }),
          (se.$set = function (ae, oe) {
            var ie,
              ne = te.p(ae),
              ce = "set" + (this.$u ? "UTC" : ""),
              ue = ((ie = {}),
              (ie[O] = ce + "Date"),
              (ie[q] = ce + "Date"),
              (ie[U] = ce + "Month"),
              (ie[N] = ce + "FullYear"),
              (ie[F] = ce + "Hours"),
              (ie[I] = ce + "Minutes"),
              (ie[x] = ce + "Seconds"),
              (ie[S] = ce + "Milliseconds"),
              ie)[ne],
              me = ne === O ? this.$D + (oe - this.$W) : oe;
            if (ne === U || ne === N) {
              var pe = this.clone().set(q, 1);
              pe.$d[ue](me),
                pe.init(),
                (this.$d = pe.set(q, Math.min(this.$D, pe.daysInMonth())).$d);
            } else ue && this.$d[ue](me);
            return this.init(), this;
          }),
          (se.set = function (ae, oe) {
            return this.clone().$set(ae, oe);
          }),
          (se.get = function (ae) {
            return this[te.p(ae)]();
          }),
          (se.add = function (ae, oe) {
            var ie,
              ne = this;
            ae = Number(ae);
            var ce = te.p(oe),
              ue = function (de) {
                var ge = ee(ne);
                return te.w(ge.date(ge.date() + Math.round(de * ae)), ne);
              };
            if (ce === U) return this.set(U, this.$M + ae);
            if (ce === N) return this.set(N, this.$y + ae);
            if (ce === O) return ue(1);
            if (ce === L) return ue(7);
            var me =
                ((ie = {}), (ie[I] = v), (ie[F] = $), (ie[x] = p), ie)[ce] || 1,
              pe = this.$d.getTime() + ae * me;
            return te.w(pe, this);
          }),
          (se.subtract = function (ae, oe) {
            return this.add(-1 * ae, oe);
          }),
          (se.format = function (ae) {
            var oe = this,
              ie = this.$locale();
            if (!this.isValid()) return ie.invalidDate || R;
            var ne = ae || "YYYY-MM-DDTHH:mm:ssZ",
              ce = te.z(this),
              ue = this.$H,
              me = this.$m,
              pe = this.$M,
              de = ie.weekdays,
              ge = ie.months,
              Ae = function (be, xe, Ce, Te) {
                return (be && (be[xe] || be(oe, ne))) || Ce[xe].slice(0, Te);
              },
              $e = function (be) {
                return te.s(ue % 12 || 12, be, "0");
              },
              ke =
                ie.meridiem ||
                function (be, xe, Ce) {
                  var Te = be < 12 ? "AM" : "PM";
                  return Ce ? Te.toLowerCase() : Te;
                },
              ve = {
                YY: String(this.$y).slice(-2),
                YYYY: this.$y,
                M: pe + 1,
                MM: te.s(pe + 1, 2, "0"),
                MMM: Ae(ie.monthsShort, pe, ge, 3),
                MMMM: Ae(ge, pe),
                D: this.$D,
                DD: te.s(this.$D, 2, "0"),
                d: String(this.$W),
                dd: Ae(ie.weekdaysMin, this.$W, de, 2),
                ddd: Ae(ie.weekdaysShort, this.$W, de, 3),
                dddd: de[this.$W],
                H: String(ue),
                HH: te.s(ue, 2, "0"),
                h: $e(1),
                hh: $e(2),
                a: ke(ue, me, !0),
                A: ke(ue, me, !1),
                m: String(me),
                mm: te.s(me, 2, "0"),
                s: String(this.$s),
                ss: te.s(this.$s, 2, "0"),
                SSS: te.s(this.$ms, 3, "0"),
                Z: ce,
              };
            return ne.replace(H, function (be, xe) {
              return xe || ve[be] || ce.replace(":", "");
            });
          }),
          (se.utcOffset = function () {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }),
          (se.diff = function (ae, oe, ie) {
            var ne,
              ce = te.p(oe),
              ue = ee(ae),
              me = (ue.utcOffset() - this.utcOffset()) * v,
              pe = this - ue,
              de = te.m(this, ue);
            return (
              (de =
                ((ne = {}),
                (ne[N] = de / 12),
                (ne[U] = de),
                (ne[j] = de / 3),
                (ne[L] = (pe - me) / 6048e5),
                (ne[O] = (pe - me) / 864e5),
                (ne[F] = pe / $),
                (ne[I] = pe / v),
                (ne[x] = pe / p),
                ne)[ce] || pe),
              ie ? de : te.a(de)
            );
          }),
          (se.daysInMonth = function () {
            return this.endOf(U).$D;
          }),
          (se.$locale = function () {
            return J[this.$L];
          }),
          (se.locale = function (ae, oe) {
            if (!ae) return this.$L;
            var ie = this.clone(),
              ne = X(ae, oe, !0);
            return ne && (ie.$L = ne), ie;
          }),
          (se.clone = function () {
            return te.w(this.$d, this);
          }),
          (se.toDate = function () {
            return new Date(this.valueOf());
          }),
          (se.toJSON = function () {
            return this.isValid() ? this.toISOString() : null;
          }),
          (se.toISOString = function () {
            return this.$d.toISOString();
          }),
          (se.toString = function () {
            return this.$d.toUTCString();
          }),
          le
        );
      })(),
      fe = re.prototype;
    return (
      (ee.prototype = fe),
      [
        ["$ms", S],
        ["$s", x],
        ["$m", I],
        ["$H", F],
        ["$W", O],
        ["$M", U],
        ["$y", N],
        ["$D", q],
      ].forEach(function (le) {
        fe[le[1]] = function (se) {
          return this.$g(se, le[0], le[1]);
        };
      }),
      (ee.extend = function (le, se) {
        return le.$i || (le(se, re, ee), (le.$i = !0)), ee;
      }),
      (ee.locale = X),
      (ee.isDayjs = Z),
      (ee.unix = function (le) {
        return ee(1e3 * le);
      }),
      (ee.en = J[Y]),
      (ee.Ls = J),
      (ee.p = {}),
      ee
    );
  });
})(dayjs_min);
const dayjs = dayjs_minExports;
var LogLevel = ((k) => (
  (k[(k.info = 0)] = "info"),
  (k[(k.warn = 1)] = "warn"),
  (k[(k.error = 2)] = "error"),
  (k[(k.critical = 3)] = "critical"),
  k
))(LogLevel || {});
const LogLevelData = {
    info: { capt: "INFO" },
    warn: { capt: "WARN" },
    error: { capt: "ERRR" },
    critical: { capt: "CRIT" },
  },
  log = writable([]);
function Log(k) {
  k.timestamp = new Date().getTime();
  const r = get_store_value(log),
    p = dayjs(k.timestamp || 0).format("HH:mm:ss.mmm");
  r.push(k), log.set(r);
  const v = LogLevelData[LogLevel[k.level]];
  console.log(`ArcOS: ${p} [${v.capt}] ${k.source}: ${k.msg}`);
}
const OpenedStore = writable([]),
  WindowStore = writable([]),
  isFullscreenWindow = writable(!1),
  maxZIndex = writable(1e9),
  focusedWindowId = writable(null);
function getWindow(k) {
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++) if (r[p] && r[p].id == k) return r[p];
  return null;
}
function getOpenedStore() {
  const k = get_store_value(WindowStore),
    r = [];
  for (let p = 0; p < k.length; p++) k[p].opened && r.push(k[p]);
  return r;
}
function updateStores() {
  Log({
    msg: "Flushing all stores",
    source: "store.ts: updateStores",
    level: LogLevel.info,
  });
  const k = get_store_value(WindowStore),
    r = getOpenedStore();
  isFullscreenWindow.set(!1);
  for (let p = 0; p < r.length; p++) {
    const v = getWindow(r[p].id);
    v && (r[p] = v),
      r[p] &&
        r[p] &&
        r[p].state.windowState.fll &&
        !r[p].state.windowState.min &&
        isFullscreenWindow.set(!0);
  }
  WindowStore.set(k);
}
WindowStore.subscribe(() => {
  OpenedStore.set(getOpenedStore());
});
var d$1 = Object.defineProperty,
  e = (k, r) => {
    for (var p in r) d$1(k, p, { get: r[p], enumerable: !0 });
  },
  f$1 = {};
e(f$1, {
  convertFileSrc: () => w,
  invoke: () => c$3,
  transformCallback: () => s$4,
});
function u$4() {
  return window.crypto.getRandomValues(new Uint32Array(1))[0];
}
function s$4(k, r = !1) {
  let p = u$4(),
    v = `_${p}`;
  return (
    Object.defineProperty(window, v, {
      value: ($) => (
        r && Reflect.deleteProperty(window, v), k == null ? void 0 : k($)
      ),
      writable: !1,
      configurable: !0,
    }),
    p
  );
}
async function c$3(k, r = {}) {
  return new Promise((p, v) => {
    let $ = s$4((x) => {
        p(x), Reflect.deleteProperty(window, `_${S}`);
      }, !0),
      S = s$4((x) => {
        v(x), Reflect.deleteProperty(window, `_${$}`);
      }, !0);
    window.__TAURI_IPC__({ cmd: k, callback: $, error: S, ...r });
  });
}
function w(k, r = "asset") {
  let p = encodeURIComponent(k);
  return navigator.userAgent.includes("Windows")
    ? `https://${r}.localhost/${p}`
    : `${r}://localhost/${p}`;
}
async function a$1(k) {
  return c$3("tauri", k);
}
var W$1 = {};
e(W$1, {
  TauriEvent: () => c$2,
  emit: () => D,
  listen: () => E$1,
  once: () => _,
});
async function s$3(k, r) {
  return a$1({
    __tauriModule: "Event",
    message: { cmd: "unlisten", event: k, eventId: r },
  });
}
async function m$1(k, r, p) {
  await a$1({
    __tauriModule: "Event",
    message: { cmd: "emit", event: k, windowLabel: r, payload: p },
  });
}
async function o$3(k, r, p) {
  return a$1({
    __tauriModule: "Event",
    message: { cmd: "listen", event: k, windowLabel: r, handler: s$4(p) },
  }).then((v) => async () => s$3(k, v));
}
async function u$3(k, r, p) {
  return o$3(k, r, (v) => {
    p(v), s$3(k, v.id).catch(() => {});
  });
}
var c$2 = ((k) => (
  (k.WINDOW_RESIZED = "tauri://resize"),
  (k.WINDOW_MOVED = "tauri://move"),
  (k.WINDOW_CLOSE_REQUESTED = "tauri://close-requested"),
  (k.WINDOW_CREATED = "tauri://window-created"),
  (k.WINDOW_DESTROYED = "tauri://destroyed"),
  (k.WINDOW_FOCUS = "tauri://focus"),
  (k.WINDOW_BLUR = "tauri://blur"),
  (k.WINDOW_SCALE_FACTOR_CHANGED = "tauri://scale-change"),
  (k.WINDOW_THEME_CHANGED = "tauri://theme-changed"),
  (k.WINDOW_FILE_DROP = "tauri://file-drop"),
  (k.WINDOW_FILE_DROP_HOVER = "tauri://file-drop-hover"),
  (k.WINDOW_FILE_DROP_CANCELLED = "tauri://file-drop-cancelled"),
  (k.MENU = "tauri://menu"),
  (k.CHECK_UPDATE = "tauri://update"),
  (k.UPDATE_AVAILABLE = "tauri://update-available"),
  (k.INSTALL_UPDATE = "tauri://update-install"),
  (k.STATUS_UPDATE = "tauri://update-status"),
  (k.DOWNLOAD_PROGRESS = "tauri://update-download-progress"),
  k
))(c$2 || {});
async function E$1(k, r) {
  return o$3(k, null, r);
}
async function _(k, r) {
  return u$3(k, null, r);
}
async function D(k, r) {
  return m$1(k, void 0, r);
}
var C = {};
e(C, {
  CloseRequestedEvent: () => y,
  LogicalPosition: () => c$1,
  LogicalSize: () => m,
  PhysicalPosition: () => o$2,
  PhysicalSize: () => l$1,
  UserAttentionType: () => W,
  WebviewWindow: () => s$2,
  WebviewWindowHandle: () => u$2,
  WindowManager: () => h,
  appWindow: () => b,
  availableMonitors: () => T,
  currentMonitor: () => E,
  getAll: () => M,
  getCurrent: () => f,
  primaryMonitor: () => z,
});
var m = class {
    constructor(k, r) {
      (this.type = "Logical"), (this.width = k), (this.height = r);
    }
  },
  l$1 = class {
    constructor(r, p) {
      (this.type = "Physical"), (this.width = r), (this.height = p);
    }
    toLogical(r) {
      return new m(this.width / r, this.height / r);
    }
  },
  c$1 = class {
    constructor(r, p) {
      (this.type = "Logical"), (this.x = r), (this.y = p);
    }
  },
  o$2 = class {
    constructor(r, p) {
      (this.type = "Physical"), (this.x = r), (this.y = p);
    }
    toLogical(r) {
      return new c$1(this.x / r, this.y / r);
    }
  },
  W = ((k) => (
    (k[(k.Critical = 1)] = "Critical"),
    (k[(k.Informational = 2)] = "Informational"),
    k
  ))(W || {});
function f() {
  return new s$2(window.__TAURI_METADATA__.__currentWindow.label, { skip: !0 });
}
function M() {
  return window.__TAURI_METADATA__.__windows.map(
    (k) => new s$2(k.label, { skip: !0 })
  );
}
var P = ["tauri://created", "tauri://error"],
  u$2 = class {
    constructor(r) {
      (this.label = r), (this.listeners = Object.create(null));
    }
    async listen(r, p) {
      return this._handleTauriEvent(r, p)
        ? Promise.resolve(() => {
            let v = this.listeners[r];
            v.splice(v.indexOf(p), 1);
          })
        : o$3(r, this.label, p);
    }
    async once(r, p) {
      return this._handleTauriEvent(r, p)
        ? Promise.resolve(() => {
            let v = this.listeners[r];
            v.splice(v.indexOf(p), 1);
          })
        : u$3(r, this.label, p);
    }
    async emit(r, p) {
      if (P.includes(r)) {
        for (let v of this.listeners[r] || [])
          v({ event: r, id: -1, windowLabel: this.label, payload: p });
        return Promise.resolve();
      }
      return m$1(r, this.label, p);
    }
    _handleTauriEvent(r, p) {
      return P.includes(r)
        ? (r in this.listeners
            ? this.listeners[r].push(p)
            : (this.listeners[r] = [p]),
          !0)
        : !1;
    }
  },
  h = class extends u$2 {
    async scaleFactor() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "scaleFactor" } },
        },
      });
    }
    async innerPosition() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "innerPosition" } },
        },
      }).then(({ x: k, y: r }) => new o$2(k, r));
    }
    async outerPosition() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "outerPosition" } },
        },
      }).then(({ x: k, y: r }) => new o$2(k, r));
    }
    async innerSize() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "innerSize" } },
        },
      }).then(({ width: k, height: r }) => new l$1(k, r));
    }
    async outerSize() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "outerSize" } },
        },
      }).then(({ width: k, height: r }) => new l$1(k, r));
    }
    async isFullscreen() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "isFullscreen" } },
        },
      });
    }
    async isMaximized() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "isMaximized" } },
        },
      });
    }
    async isDecorated() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "isDecorated" } },
        },
      });
    }
    async isResizable() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "isResizable" } },
        },
      });
    }
    async isVisible() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "isVisible" } },
        },
      });
    }
    async theme() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "theme" } },
        },
      });
    }
    async center() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "center" } },
        },
      });
    }
    async requestUserAttention(k) {
      let r = null;
      return (
        k &&
          (k === 1
            ? (r = { type: "Critical" })
            : (r = { type: "Informational" })),
        a$1({
          __tauriModule: "Window",
          message: {
            cmd: "manage",
            data: {
              label: this.label,
              cmd: { type: "requestUserAttention", payload: r },
            },
          },
        })
      );
    }
    async setResizable(k) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setResizable", payload: k },
          },
        },
      });
    }
    async setTitle(k) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "setTitle", payload: k } },
        },
      });
    }
    async maximize() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "maximize" } },
        },
      });
    }
    async unmaximize() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "unmaximize" } },
        },
      });
    }
    async toggleMaximize() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "toggleMaximize" } },
        },
      });
    }
    async minimize() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "minimize" } },
        },
      });
    }
    async unminimize() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "unminimize" } },
        },
      });
    }
    async show() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "show" } },
        },
      });
    }
    async hide() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "hide" } },
        },
      });
    }
    async close() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "close" } },
        },
      });
    }
    async setDecorations(k) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setDecorations", payload: k },
          },
        },
      });
    }
    async setAlwaysOnTop(k) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setAlwaysOnTop", payload: k },
          },
        },
      });
    }
    async setSize(k) {
      if (!k || (k.type !== "Logical" && k.type !== "Physical"))
        throw new Error(
          "the `size` argument must be either a LogicalSize or a PhysicalSize instance"
        );
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: {
              type: "setSize",
              payload: {
                type: k.type,
                data: { width: k.width, height: k.height },
              },
            },
          },
        },
      });
    }
    async setMinSize(k) {
      if (k && k.type !== "Logical" && k.type !== "Physical")
        throw new Error(
          "the `size` argument must be either a LogicalSize or a PhysicalSize instance"
        );
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: {
              type: "setMinSize",
              payload: k
                ? { type: k.type, data: { width: k.width, height: k.height } }
                : null,
            },
          },
        },
      });
    }
    async setMaxSize(k) {
      if (k && k.type !== "Logical" && k.type !== "Physical")
        throw new Error(
          "the `size` argument must be either a LogicalSize or a PhysicalSize instance"
        );
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: {
              type: "setMaxSize",
              payload: k
                ? { type: k.type, data: { width: k.width, height: k.height } }
                : null,
            },
          },
        },
      });
    }
    async setPosition(k) {
      if (!k || (k.type !== "Logical" && k.type !== "Physical"))
        throw new Error(
          "the `position` argument must be either a LogicalPosition or a PhysicalPosition instance"
        );
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: {
              type: "setPosition",
              payload: { type: k.type, data: { x: k.x, y: k.y } },
            },
          },
        },
      });
    }
    async setFullscreen(k) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setFullscreen", payload: k },
          },
        },
      });
    }
    async setFocus() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "setFocus" } },
        },
      });
    }
    async setIcon(k) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: {
              type: "setIcon",
              payload: { icon: typeof k == "string" ? k : Array.from(k) },
            },
          },
        },
      });
    }
    async setSkipTaskbar(k) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setSkipTaskbar", payload: k },
          },
        },
      });
    }
    async setCursorGrab(k) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setCursorGrab", payload: k },
          },
        },
      });
    }
    async setCursorVisible(k) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setCursorVisible", payload: k },
          },
        },
      });
    }
    async setCursorIcon(k) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setCursorIcon", payload: k },
          },
        },
      });
    }
    async setCursorPosition(k) {
      if (!k || (k.type !== "Logical" && k.type !== "Physical"))
        throw new Error(
          "the `position` argument must be either a LogicalPosition or a PhysicalPosition instance"
        );
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: {
              type: "setCursorPosition",
              payload: { type: k.type, data: { x: k.x, y: k.y } },
            },
          },
        },
      });
    }
    async setIgnoreCursorEvents(k) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setIgnoreCursorEvents", payload: k },
          },
        },
      });
    }
    async startDragging() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "startDragging" } },
        },
      });
    }
    async onResized(k) {
      return this.listen("tauri://resize", k);
    }
    async onMoved(k) {
      return this.listen("tauri://move", k);
    }
    async onCloseRequested(k) {
      return this.listen("tauri://close-requested", (r) => {
        let p = new y(r);
        Promise.resolve(k(p)).then(() => {
          if (!p.isPreventDefault()) return this.close();
        });
      });
    }
    async onFocusChanged(k) {
      let r = await this.listen("tauri://focus", (v) => {
          k({ ...v, payload: !0 });
        }),
        p = await this.listen("tauri://blur", (v) => {
          k({ ...v, payload: !1 });
        });
      return () => {
        r(), p();
      };
    }
    async onScaleChanged(k) {
      return this.listen("tauri://scale-change", k);
    }
    async onMenuClicked(k) {
      return this.listen("tauri://menu", k);
    }
    async onFileDropEvent(k) {
      let r = await this.listen("tauri://file-drop", ($) => {
          k({ ...$, payload: { type: "drop", paths: $.payload } });
        }),
        p = await this.listen("tauri://file-drop-hover", ($) => {
          k({ ...$, payload: { type: "hover", paths: $.payload } });
        }),
        v = await this.listen("tauri://file-drop-cancelled", ($) => {
          k({ ...$, payload: { type: "cancel" } });
        });
      return () => {
        r(), p(), v();
      };
    }
    async onThemeChanged(k) {
      return this.listen("tauri://theme-changed", k);
    }
  },
  y = class {
    constructor(k) {
      (this._preventDefault = !1),
        (this.event = k.event),
        (this.windowLabel = k.windowLabel),
        (this.id = k.id);
    }
    preventDefault() {
      this._preventDefault = !0;
    }
    isPreventDefault() {
      return this._preventDefault;
    }
  },
  s$2 = class extends h {
    constructor(r, p = {}) {
      super(r),
        (p != null && p.skip) ||
          a$1({
            __tauriModule: "Window",
            message: {
              cmd: "createWebview",
              data: { options: { label: r, ...p } },
            },
          })
            .then(async () => this.emit("tauri://created"))
            .catch(async (v) => this.emit("tauri://error", v));
    }
    static getByLabel(r) {
      return M().some((p) => p.label === r) ? new s$2(r, { skip: !0 }) : null;
    }
  },
  b;
"__TAURI_METADATA__" in window
  ? (b = new s$2(window.__TAURI_METADATA__.__currentWindow.label, { skip: !0 }))
  : (console.warn(`Could not find "window.__TAURI_METADATA__". The "appWindow" value will reference the "main" window label.
Note that this is not an issue if running this frontend on a browser instead of a Tauri window.`),
    (b = new s$2("main", { skip: !0 })));
function g(k) {
  return k === null
    ? null
    : {
        name: k.name,
        scaleFactor: k.scaleFactor,
        position: new o$2(k.position.x, k.position.y),
        size: new l$1(k.size.width, k.size.height),
      };
}
async function E() {
  return a$1({
    __tauriModule: "Window",
    message: { cmd: "manage", data: { cmd: { type: "currentMonitor" } } },
  }).then(g);
}
async function z() {
  return a$1({
    __tauriModule: "Window",
    message: { cmd: "manage", data: { cmd: { type: "primaryMonitor" } } },
  }).then(g);
}
async function T() {
  return a$1({
    __tauriModule: "Window",
    message: { cmd: "manage", data: { cmd: { type: "availableMonitors" } } },
  }).then((k) => k.map(g));
}
const UserData = writable(),
  UserName = writable("ArcOS"),
  UserToken = writable();
function generateParamStr(k) {
  let r = "?";
  const p = Object.entries(k);
  for (let v = 0; v < p.length; v++) r += `${p[v][0]}=${p[v][1]}&`;
  return r;
}
const ConnectedServer = writable(null);
async function apiCall(k, r, p, v, $, S, x) {
  const I = generateCredToken($),
    F = {
      headers: { Authorization: v ? `Bearer ${v}` : `Basic ${I}` },
      body: S,
      method: S ? "post" : "get",
    },
    O = !$ && !v,
    L = generateParamStr(p),
    U = await fetch(`${k}/${r}${L}`, O ? { body: S } : F),
    j = await U.text();
  if (!U.ok && v && !"200|304".includes(`${U.status}`)) return U.status, void 0;
  if (!x)
    try {
      return JSON.parse(j);
    } catch {
      return {};
    }
  return {};
}
function invalidServerResponse(k, r, p, v) {}
function generateCredToken(k) {
  return k ? btoa(`${k.username}:${k.password}`) : "";
}
async function changePassword(k, r, p, v) {
  if (p != v) return !1;
  const $ = await apiCall(
      get_store_value(ConnectedServer),
      "user/changepswd",
      { new: btoa(p) },
      null,
      { username: k, password: r }
    ),
    S = localStorage.getItem("arcos-remembered-token");
  return (
    !S ||
      !$.valid ||
      atob(S).split(":")[0] != k ||
      localStorage.setItem("arcos-remembered-token", btoa(`${k}:${p}`)),
    $.valid
  );
}
async function changeUsername(k, r) {
  if (get_store_value(UserName) != k) return !1;
  const p = await apiCall(
    get_store_value(ConnectedServer),
    "user/rename",
    { newname: btoa(r) },
    get_store_value(UserToken)
  );
  if ((UserName.set(r), !p.valid)) return !1;
  const v = localStorage.getItem("arcos-remembered-token");
  return (
    !v ||
      !p.valid ||
      atob(v).split(":")[0] != k ||
      localStorage.setItem(
        "arcos-remembered-token",
        btoa(`${r}:${atob(v).split(":")[1]}`)
      ),
    p.valid
  );
}
async function logoffToken() {
  const k = get_store_value(UserToken),
    r = get_store_value(ConnectedServer);
  if (!(!k || !r)) return await apiCall(r, "logoff", {}, k);
}
const ArcOSVersion = "5.0.1",
  arctermonly = "",
  main = "",
  defaultQuota = { used: 0, max: 0, free: 0, username: "ArcOS" };
async function getFSQuota() {
  const k = get_store_value(UserName),
    r = get_store_value(ConnectedServer);
  if (!r || !k) return defaultQuota;
  const p = await apiCall(r, "fs/quota", {}, get_store_value(UserToken));
  return p.valid ? p.data : defaultQuota;
}
const sizeUnits = ["bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
function formatBytes(k) {
  let r = 0,
    p = k;
  for (; p >= 1024 && ++r; ) p = p / 1024;
  return p.toFixed(p < 10 && r > 0 ? 1 : 0) + " " + sizeUnits[r];
}
const defaultDirectory = {
    files: [],
    directories: [],
    name: "",
    scopedPath: "",
  },
  warning = "./assets/error-3c4c2c86.svg";
async function getDirectory(k = "./") {
  Log({
    source: "fs/directory.ts: getDirectory",
    msg: `Requesting directory contents of "${k}" from ArcAPI`,
    level: LogLevel.info,
  });
  const r = get_store_value(ConnectedServer);
  if (!r) return !1;
  const p = await apiCall(
    r,
    "fs/dir/get",
    { path: k ? btoa(k) : null },
    get_store_value(UserToken)
  );
  return !p || !p.valid ? !1 : p.data;
}
async function createDirectory(k) {
  const r = get_store_value(ConnectedServer);
  return r
    ? (
        await apiCall(
          r,
          "fs/dir/create",
          { path: btoa(k) },
          get_store_value(UserToken)
        )
      ).valid
    : !1;
}
function bind(k, r) {
  return function () {
    return k.apply(r, arguments);
  };
}
const { toString: toString$1 } = Object.prototype,
  { getPrototypeOf } = Object,
  kindOf = ((k) => (r) => {
    const p = toString$1.call(r);
    return k[p] || (k[p] = p.slice(8, -1).toLowerCase());
  })(Object.create(null)),
  kindOfTest = (k) => ((k = k.toLowerCase()), (r) => kindOf(r) === k),
  typeOfTest = (k) => (r) => typeof r === k,
  { isArray: isArray$1 } = Array,
  isUndefined = typeOfTest("undefined");
function isBuffer(k) {
  return (
    k !== null &&
    !isUndefined(k) &&
    k.constructor !== null &&
    !isUndefined(k.constructor) &&
    isFunction(k.constructor.isBuffer) &&
    k.constructor.isBuffer(k)
  );
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(k) {
  let r;
  return (
    typeof ArrayBuffer < "u" && ArrayBuffer.isView
      ? (r = ArrayBuffer.isView(k))
      : (r = k && k.buffer && isArrayBuffer(k.buffer)),
    r
  );
}
const isString$1 = typeOfTest("string"),
  isFunction = typeOfTest("function"),
  isNumber$1 = typeOfTest("number"),
  isObject$1 = (k) => k !== null && typeof k == "object",
  isBoolean$1 = (k) => k === !0 || k === !1,
  isPlainObject = (k) => {
    if (kindOf(k) !== "object") return !1;
    const r = getPrototypeOf(k);
    return (
      (r === null ||
        r === Object.prototype ||
        Object.getPrototypeOf(r) === null) &&
      !(Symbol.toStringTag in k) &&
      !(Symbol.iterator in k)
    );
  },
  isDate = kindOfTest("Date"),
  isFile = kindOfTest("File"),
  isBlob = kindOfTest("Blob"),
  isFileList = kindOfTest("FileList"),
  isStream = (k) => isObject$1(k) && isFunction(k.pipe),
  isFormData = (k) => {
    const r = "[object FormData]";
    return (
      k &&
      ((typeof FormData == "function" && k instanceof FormData) ||
        toString$1.call(k) === r ||
        (isFunction(k.toString) && k.toString() === r))
    );
  },
  isURLSearchParams = kindOfTest("URLSearchParams"),
  trim = (k) =>
    k.trim ? k.trim() : k.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(k, r, { allOwnKeys: p = !1 } = {}) {
  if (k === null || typeof k > "u") return;
  let v, $;
  if ((typeof k != "object" && (k = [k]), isArray$1(k)))
    for (v = 0, $ = k.length; v < $; v++) r.call(null, k[v], v, k);
  else {
    const S = p ? Object.getOwnPropertyNames(k) : Object.keys(k),
      x = S.length;
    let I;
    for (v = 0; v < x; v++) (I = S[v]), r.call(null, k[I], I, k);
  }
}
function findKey(k, r) {
  r = r.toLowerCase();
  const p = Object.keys(k);
  let v = p.length,
    $;
  for (; v-- > 0; ) if ((($ = p[v]), r === $.toLowerCase())) return $;
  return null;
}
const _global = (() =>
    typeof globalThis < "u"
      ? globalThis
      : typeof self < "u"
      ? self
      : typeof window < "u"
      ? window
      : global)(),
  isContextDefined = (k) => !isUndefined(k) && k !== _global;
function merge$1() {
  const { caseless: k } = (isContextDefined(this) && this) || {},
    r = {},
    p = (v, $) => {
      const S = (k && findKey(r, $)) || $;
      isPlainObject(r[S]) && isPlainObject(v)
        ? (r[S] = merge$1(r[S], v))
        : isPlainObject(v)
        ? (r[S] = merge$1({}, v))
        : isArray$1(v)
        ? (r[S] = v.slice())
        : (r[S] = v);
    };
  for (let v = 0, $ = arguments.length; v < $; v++)
    arguments[v] && forEach(arguments[v], p);
  return r;
}
const extend = (k, r, p, { allOwnKeys: v } = {}) => (
    forEach(
      r,
      ($, S) => {
        p && isFunction($) ? (k[S] = bind($, p)) : (k[S] = $);
      },
      { allOwnKeys: v }
    ),
    k
  ),
  stripBOM = (k) => (k.charCodeAt(0) === 65279 && (k = k.slice(1)), k),
  inherits = (k, r, p, v) => {
    (k.prototype = Object.create(r.prototype, v)),
      (k.prototype.constructor = k),
      Object.defineProperty(k, "super", { value: r.prototype }),
      p && Object.assign(k.prototype, p);
  },
  toFlatObject = (k, r, p, v) => {
    let $, S, x;
    const I = {};
    if (((r = r || {}), k == null)) return r;
    do {
      for ($ = Object.getOwnPropertyNames(k), S = $.length; S-- > 0; )
        (x = $[S]), (!v || v(x, k, r)) && !I[x] && ((r[x] = k[x]), (I[x] = !0));
      k = p !== !1 && getPrototypeOf(k);
    } while (k && (!p || p(k, r)) && k !== Object.prototype);
    return r;
  },
  endsWith = (k, r, p) => {
    (k = String(k)),
      (p === void 0 || p > k.length) && (p = k.length),
      (p -= r.length);
    const v = k.indexOf(r, p);
    return v !== -1 && v === p;
  },
  toArray = (k) => {
    if (!k) return null;
    if (isArray$1(k)) return k;
    let r = k.length;
    if (!isNumber$1(r)) return null;
    const p = new Array(r);
    for (; r-- > 0; ) p[r] = k[r];
    return p;
  },
  isTypedArray = (
    (k) => (r) =>
      k && r instanceof k
  )(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array)),
  forEachEntry = (k, r) => {
    const v = (k && k[Symbol.iterator]).call(k);
    let $;
    for (; ($ = v.next()) && !$.done; ) {
      const S = $.value;
      r.call(k, S[0], S[1]);
    }
  },
  matchAll = (k, r) => {
    let p;
    const v = [];
    for (; (p = k.exec(r)) !== null; ) v.push(p);
    return v;
  },
  isHTMLForm = kindOfTest("HTMLFormElement"),
  toCamelCase = (k) =>
    k.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (p, v, $) {
      return v.toUpperCase() + $;
    }),
  hasOwnProperty = (
    ({ hasOwnProperty: k }) =>
    (r, p) =>
      k.call(r, p)
  )(Object.prototype),
  isRegExp = kindOfTest("RegExp"),
  reduceDescriptors = (k, r) => {
    const p = Object.getOwnPropertyDescriptors(k),
      v = {};
    forEach(p, ($, S) => {
      r($, S, k) !== !1 && (v[S] = $);
    }),
      Object.defineProperties(k, v);
  },
  freezeMethods = (k) => {
    reduceDescriptors(k, (r, p) => {
      if (isFunction(k) && ["arguments", "caller", "callee"].indexOf(p) !== -1)
        return !1;
      const v = k[p];
      if (isFunction(v)) {
        if (((r.enumerable = !1), "writable" in r)) {
          r.writable = !1;
          return;
        }
        r.set ||
          (r.set = () => {
            throw Error("Can not rewrite read-only method '" + p + "'");
          });
      }
    });
  },
  toObjectSet = (k, r) => {
    const p = {},
      v = ($) => {
        $.forEach((S) => {
          p[S] = !0;
        });
      };
    return isArray$1(k) ? v(k) : v(String(k).split(r)), p;
  },
  noop = () => {},
  toFiniteNumber = (k, r) => ((k = +k), Number.isFinite(k) ? k : r),
  ALPHA = "abcdefghijklmnopqrstuvwxyz",
  DIGIT = "0123456789",
  ALPHABET = { DIGIT, ALPHA, ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT },
  generateString = (k = 16, r = ALPHABET.ALPHA_DIGIT) => {
    let p = "";
    const { length: v } = r;
    for (; k--; ) p += r[(Math.random() * v) | 0];
    return p;
  };
function isSpecCompliantForm(k) {
  return !!(
    k &&
    isFunction(k.append) &&
    k[Symbol.toStringTag] === "FormData" &&
    k[Symbol.iterator]
  );
}
const toJSONObject = (k) => {
    const r = new Array(10),
      p = (v, $) => {
        if (isObject$1(v)) {
          if (r.indexOf(v) >= 0) return;
          if (!("toJSON" in v)) {
            r[$] = v;
            const S = isArray$1(v) ? [] : {};
            return (
              forEach(v, (x, I) => {
                const F = p(x, $ + 1);
                !isUndefined(F) && (S[I] = F);
              }),
              (r[$] = void 0),
              S
            );
          }
        }
        return v;
      };
    return p(k, 0);
  },
  utils = {
    isArray: isArray$1,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString: isString$1,
    isNumber: isNumber$1,
    isBoolean: isBoolean$1,
    isObject: isObject$1,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge: merge$1,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
  };
function AxiosError(k, r, p, v, $) {
  Error.call(this),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack),
    (this.message = k),
    (this.name = "AxiosError"),
    r && (this.code = r),
    p && (this.config = p),
    v && (this.request = v),
    $ && (this.response = $);
}
utils.inherits(AxiosError, Error, {
  toJSON: function () {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: utils.toJSONObject(this.config),
      code: this.code,
      status:
        this.response && this.response.status ? this.response.status : null,
    };
  },
});
const prototype$1 = AxiosError.prototype,
  descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL",
].forEach((k) => {
  descriptors[k] = { value: k };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: !0 });
AxiosError.from = (k, r, p, v, $, S) => {
  const x = Object.create(prototype$1);
  return (
    utils.toFlatObject(
      k,
      x,
      function (F) {
        return F !== Error.prototype;
      },
      (I) => I !== "isAxiosError"
    ),
    AxiosError.call(x, k.message, r, p, v, $),
    (x.cause = k),
    (x.name = k.name),
    S && Object.assign(x, S),
    x
  );
};
const httpAdapter = null;
function isVisitable(k) {
  return utils.isPlainObject(k) || utils.isArray(k);
}
function removeBrackets(k) {
  return utils.endsWith(k, "[]") ? k.slice(0, -2) : k;
}
function renderKey(k, r, p) {
  return k
    ? k
        .concat(r)
        .map(function ($, S) {
          return ($ = removeBrackets($)), !p && S ? "[" + $ + "]" : $;
        })
        .join(p ? "." : "")
    : r;
}
function isFlatArray(k) {
  return utils.isArray(k) && !k.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function (r) {
  return /^is[A-Z]/.test(r);
});
function toFormData(k, r, p) {
  if (!utils.isObject(k)) throw new TypeError("target must be an object");
  (r = r || new FormData()),
    (p = utils.toFlatObject(
      p,
      { metaTokens: !0, dots: !1, indexes: !1 },
      !1,
      function (R, Q) {
        return !utils.isUndefined(Q[R]);
      }
    ));
  const v = p.metaTokens,
    $ = p.visitor || L,
    S = p.dots,
    x = p.indexes,
    F = (p.Blob || (typeof Blob < "u" && Blob)) && utils.isSpecCompliantForm(r);
  if (!utils.isFunction($)) throw new TypeError("visitor must be a function");
  function O(q) {
    if (q === null) return "";
    if (utils.isDate(q)) return q.toISOString();
    if (!F && utils.isBlob(q))
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    return utils.isArrayBuffer(q) || utils.isTypedArray(q)
      ? F && typeof Blob == "function"
        ? new Blob([q])
        : Buffer.from(q)
      : q;
  }
  function L(q, R, Q) {
    let H = q;
    if (q && !Q && typeof q == "object") {
      if (utils.endsWith(R, "{}"))
        (R = v ? R : R.slice(0, -2)), (q = JSON.stringify(q));
      else if (
        (utils.isArray(q) && isFlatArray(q)) ||
        ((utils.isFileList(q) || utils.endsWith(R, "[]")) &&
          (H = utils.toArray(q)))
      )
        return (
          (R = removeBrackets(R)),
          H.forEach(function (V, K) {
            !(utils.isUndefined(V) || V === null) &&
              r.append(
                x === !0 ? renderKey([R], K, S) : x === null ? R : R + "[]",
                O(V)
              );
          }),
          !1
        );
    }
    return isVisitable(q) ? !0 : (r.append(renderKey(Q, R, S), O(q)), !1);
  }
  const U = [],
    j = Object.assign(predicates, {
      defaultVisitor: L,
      convertValue: O,
      isVisitable,
    });
  function N(q, R) {
    if (!utils.isUndefined(q)) {
      if (U.indexOf(q) !== -1)
        throw Error("Circular reference detected in " + R.join("."));
      U.push(q),
        utils.forEach(q, function (H, G) {
          (!(utils.isUndefined(H) || H === null) &&
            $.call(r, H, utils.isString(G) ? G.trim() : G, R, j)) === !0 &&
            N(H, R ? R.concat(G) : [G]);
        }),
        U.pop();
    }
  }
  if (!utils.isObject(k)) throw new TypeError("data must be an object");
  return N(k), r;
}
function encode$1(k) {
  const r = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0",
  };
  return encodeURIComponent(k).replace(/[!'()~]|%20|%00/g, function (v) {
    return r[v];
  });
}
function AxiosURLSearchParams(k, r) {
  (this._pairs = []), k && toFormData(k, this, r);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function (r, p) {
  this._pairs.push([r, p]);
};
prototype.toString = function (r) {
  const p = r
    ? function (v) {
        return r.call(this, v, encode$1);
      }
    : encode$1;
  return this._pairs
    .map(function ($) {
      return p($[0]) + "=" + p($[1]);
    }, "")
    .join("&");
};
function encode(k) {
  return encodeURIComponent(k)
    .replace(/%3A/gi, ":")
    .replace(/%24/g, "$")
    .replace(/%2C/gi, ",")
    .replace(/%20/g, "+")
    .replace(/%5B/gi, "[")
    .replace(/%5D/gi, "]");
}
function buildURL(k, r, p) {
  if (!r) return k;
  const v = (p && p.encode) || encode,
    $ = p && p.serialize;
  let S;
  if (
    ($
      ? (S = $(r, p))
      : (S = utils.isURLSearchParams(r)
          ? r.toString()
          : new AxiosURLSearchParams(r, p).toString(v)),
    S)
  ) {
    const x = k.indexOf("#");
    x !== -1 && (k = k.slice(0, x)),
      (k += (k.indexOf("?") === -1 ? "?" : "&") + S);
  }
  return k;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  use(r, p, v) {
    return (
      this.handlers.push({
        fulfilled: r,
        rejected: p,
        synchronous: v ? v.synchronous : !1,
        runWhen: v ? v.runWhen : null,
      }),
      this.handlers.length - 1
    );
  }
  eject(r) {
    this.handlers[r] && (this.handlers[r] = null);
  }
  clear() {
    this.handlers && (this.handlers = []);
  }
  forEach(r) {
    utils.forEach(this.handlers, function (v) {
      v !== null && r(v);
    });
  }
}
const InterceptorManager$1 = InterceptorManager,
  transitionalDefaults = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1,
  },
  URLSearchParams$1 =
    typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams,
  FormData$1 = FormData,
  isStandardBrowserEnv = (() => {
    let k;
    return typeof navigator < "u" &&
      ((k = navigator.product) === "ReactNative" ||
        k === "NativeScript" ||
        k === "NS")
      ? !1
      : typeof window < "u" && typeof document < "u";
  })(),
  isStandardBrowserWebWorkerEnv = (() =>
    typeof WorkerGlobalScope < "u" &&
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts == "function")(),
  platform = {
    isBrowser: !0,
    classes: { URLSearchParams: URLSearchParams$1, FormData: FormData$1, Blob },
    isStandardBrowserEnv,
    isStandardBrowserWebWorkerEnv,
    protocols: ["http", "https", "file", "blob", "url", "data"],
  };
function toURLEncodedForm(k, r) {
  return toFormData(
    k,
    new platform.classes.URLSearchParams(),
    Object.assign(
      {
        visitor: function (p, v, $, S) {
          return platform.isNode && utils.isBuffer(p)
            ? (this.append(v, p.toString("base64")), !1)
            : S.defaultVisitor.apply(this, arguments);
        },
      },
      r
    )
  );
}
function parsePropPath(k) {
  return utils
    .matchAll(/\w+|\[(\w*)]/g, k)
    .map((r) => (r[0] === "[]" ? "" : r[1] || r[0]));
}
function arrayToObject(k) {
  const r = {},
    p = Object.keys(k);
  let v;
  const $ = p.length;
  let S;
  for (v = 0; v < $; v++) (S = p[v]), (r[S] = k[S]);
  return r;
}
function formDataToJSON(k) {
  function r(p, v, $, S) {
    let x = p[S++];
    const I = Number.isFinite(+x),
      F = S >= p.length;
    return (
      (x = !x && utils.isArray($) ? $.length : x),
      F
        ? (utils.hasOwnProp($, x) ? ($[x] = [$[x], v]) : ($[x] = v), !I)
        : ((!$[x] || !utils.isObject($[x])) && ($[x] = []),
          r(p, v, $[x], S) &&
            utils.isArray($[x]) &&
            ($[x] = arrayToObject($[x])),
          !I)
    );
  }
  if (utils.isFormData(k) && utils.isFunction(k.entries)) {
    const p = {};
    return (
      utils.forEachEntry(k, (v, $) => {
        r(parsePropPath(v), $, p, 0);
      }),
      p
    );
  }
  return null;
}
const DEFAULT_CONTENT_TYPE = { "Content-Type": void 0 };
function stringifySafely(k, r, p) {
  if (utils.isString(k))
    try {
      return (r || JSON.parse)(k), utils.trim(k);
    } catch (v) {
      if (v.name !== "SyntaxError") throw v;
    }
  return (p || JSON.stringify)(k);
}
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [
    function (r, p) {
      const v = p.getContentType() || "",
        $ = v.indexOf("application/json") > -1,
        S = utils.isObject(r);
      if (
        (S && utils.isHTMLForm(r) && (r = new FormData(r)), utils.isFormData(r))
      )
        return $ && $ ? JSON.stringify(formDataToJSON(r)) : r;
      if (
        utils.isArrayBuffer(r) ||
        utils.isBuffer(r) ||
        utils.isStream(r) ||
        utils.isFile(r) ||
        utils.isBlob(r)
      )
        return r;
      if (utils.isArrayBufferView(r)) return r.buffer;
      if (utils.isURLSearchParams(r))
        return (
          p.setContentType(
            "application/x-www-form-urlencoded;charset=utf-8",
            !1
          ),
          r.toString()
        );
      let I;
      if (S) {
        if (v.indexOf("application/x-www-form-urlencoded") > -1)
          return toURLEncodedForm(r, this.formSerializer).toString();
        if (
          (I = utils.isFileList(r)) ||
          v.indexOf("multipart/form-data") > -1
        ) {
          const F = this.env && this.env.FormData;
          return toFormData(
            I ? { "files[]": r } : r,
            F && new F(),
            this.formSerializer
          );
        }
      }
      return S || $
        ? (p.setContentType("application/json", !1), stringifySafely(r))
        : r;
    },
  ],
  transformResponse: [
    function (r) {
      const p = this.transitional || defaults$1.transitional,
        v = p && p.forcedJSONParsing,
        $ = this.responseType === "json";
      if (r && utils.isString(r) && ((v && !this.responseType) || $)) {
        const x = !(p && p.silentJSONParsing) && $;
        try {
          return JSON.parse(r);
        } catch (I) {
          if (x)
            throw I.name === "SyntaxError"
              ? AxiosError.from(
                  I,
                  AxiosError.ERR_BAD_RESPONSE,
                  this,
                  null,
                  this.response
                )
              : I;
        }
      }
      return r;
    },
  ],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: { FormData: platform.classes.FormData, Blob: platform.classes.Blob },
  validateStatus: function (r) {
    return r >= 200 && r < 300;
  },
  headers: { common: { Accept: "application/json, text/plain, */*" } },
};
utils.forEach(["delete", "get", "head"], function (r) {
  defaults$1.headers[r] = {};
});
utils.forEach(["post", "put", "patch"], function (r) {
  defaults$1.headers[r] = utils.merge(DEFAULT_CONTENT_TYPE);
});
const defaults$2 = defaults$1,
  ignoreDuplicateOf = utils.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent",
  ]),
  parseHeaders = (k) => {
    const r = {};
    let p, v, $;
    return (
      k &&
        k
          .split(
            `
`
          )
          .forEach(function (x) {
            ($ = x.indexOf(":")),
              (p = x.substring(0, $).trim().toLowerCase()),
              (v = x.substring($ + 1).trim()),
              !(!p || (r[p] && ignoreDuplicateOf[p])) &&
                (p === "set-cookie"
                  ? r[p]
                    ? r[p].push(v)
                    : (r[p] = [v])
                  : (r[p] = r[p] ? r[p] + ", " + v : v));
          }),
      r
    );
  },
  $internals = Symbol("internals");
function normalizeHeader(k) {
  return k && String(k).trim().toLowerCase();
}
function normalizeValue(k) {
  return k === !1 || k == null
    ? k
    : utils.isArray(k)
    ? k.map(normalizeValue)
    : String(k);
}
function parseTokens(k) {
  const r = Object.create(null),
    p = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let v;
  for (; (v = p.exec(k)); ) r[v[1]] = v[2];
  return r;
}
function isValidHeaderName(k) {
  return /^[-_a-zA-Z]+$/.test(k.trim());
}
function matchHeaderValue(k, r, p, v) {
  if (utils.isFunction(v)) return v.call(this, r, p);
  if (utils.isString(r)) {
    if (utils.isString(v)) return r.indexOf(v) !== -1;
    if (utils.isRegExp(v)) return v.test(r);
  }
}
function formatHeader(k) {
  return k
    .trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (r, p, v) => p.toUpperCase() + v);
}
function buildAccessors(k, r) {
  const p = utils.toCamelCase(" " + r);
  ["get", "set", "has"].forEach((v) => {
    Object.defineProperty(k, v + p, {
      value: function ($, S, x) {
        return this[v].call(this, r, $, S, x);
      },
      configurable: !0,
    });
  });
}
class AxiosHeaders {
  constructor(r) {
    r && this.set(r);
  }
  set(r, p, v) {
    const $ = this;
    function S(I, F, O) {
      const L = normalizeHeader(F);
      if (!L) throw new Error("header name must be a non-empty string");
      const U = utils.findKey($, L);
      (!U || $[U] === void 0 || O === !0 || (O === void 0 && $[U] !== !1)) &&
        ($[U || F] = normalizeValue(I));
    }
    const x = (I, F) => utils.forEach(I, (O, L) => S(O, L, F));
    return (
      utils.isPlainObject(r) || r instanceof this.constructor
        ? x(r, p)
        : utils.isString(r) && (r = r.trim()) && !isValidHeaderName(r)
        ? x(parseHeaders(r), p)
        : r != null && S(p, r, v),
      this
    );
  }
  get(r, p) {
    if (((r = normalizeHeader(r)), r)) {
      const v = utils.findKey(this, r);
      if (v) {
        const $ = this[v];
        if (!p) return $;
        if (p === !0) return parseTokens($);
        if (utils.isFunction(p)) return p.call(this, $, v);
        if (utils.isRegExp(p)) return p.exec($);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(r, p) {
    if (((r = normalizeHeader(r)), r)) {
      const v = utils.findKey(this, r);
      return !!(
        v &&
        this[v] !== void 0 &&
        (!p || matchHeaderValue(this, this[v], v, p))
      );
    }
    return !1;
  }
  delete(r, p) {
    const v = this;
    let $ = !1;
    function S(x) {
      if (((x = normalizeHeader(x)), x)) {
        const I = utils.findKey(v, x);
        I && (!p || matchHeaderValue(v, v[I], I, p)) && (delete v[I], ($ = !0));
      }
    }
    return utils.isArray(r) ? r.forEach(S) : S(r), $;
  }
  clear(r) {
    const p = Object.keys(this);
    let v = p.length,
      $ = !1;
    for (; v--; ) {
      const S = p[v];
      (!r || matchHeaderValue(this, this[S], S, r)) &&
        (delete this[S], ($ = !0));
    }
    return $;
  }
  normalize(r) {
    const p = this,
      v = {};
    return (
      utils.forEach(this, ($, S) => {
        const x = utils.findKey(v, S);
        if (x) {
          (p[x] = normalizeValue($)), delete p[S];
          return;
        }
        const I = r ? formatHeader(S) : String(S).trim();
        I !== S && delete p[S], (p[I] = normalizeValue($)), (v[I] = !0);
      }),
      this
    );
  }
  concat(...r) {
    return this.constructor.concat(this, ...r);
  }
  toJSON(r) {
    const p = Object.create(null);
    return (
      utils.forEach(this, (v, $) => {
        v != null &&
          v !== !1 &&
          (p[$] = r && utils.isArray(v) ? v.join(", ") : v);
      }),
      p
    );
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([r, p]) => r + ": " + p).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(r) {
    return r instanceof this ? r : new this(r);
  }
  static concat(r, ...p) {
    const v = new this(r);
    return p.forEach(($) => v.set($)), v;
  }
  static accessor(r) {
    const v = (this[$internals] = this[$internals] = { accessors: {} })
        .accessors,
      $ = this.prototype;
    function S(x) {
      const I = normalizeHeader(x);
      v[I] || (buildAccessors($, x), (v[I] = !0));
    }
    return utils.isArray(r) ? r.forEach(S) : S(r), this;
  }
}
AxiosHeaders.accessor([
  "Content-Type",
  "Content-Length",
  "Accept",
  "Accept-Encoding",
  "User-Agent",
  "Authorization",
]);
utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(k, r) {
  const p = this || defaults$2,
    v = r || p,
    $ = AxiosHeaders$1.from(v.headers);
  let S = v.data;
  return (
    utils.forEach(k, function (I) {
      S = I.call(p, S, $.normalize(), r ? r.status : void 0);
    }),
    $.normalize(),
    S
  );
}
function isCancel(k) {
  return !!(k && k.__CANCEL__);
}
function CanceledError(k, r, p) {
  AxiosError.call(this, k ?? "canceled", AxiosError.ERR_CANCELED, r, p),
    (this.name = "CanceledError");
}
utils.inherits(CanceledError, AxiosError, { __CANCEL__: !0 });
function settle(k, r, p) {
  const v = p.config.validateStatus;
  !p.status || !v || v(p.status)
    ? k(p)
    : r(
        new AxiosError(
          "Request failed with status code " + p.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][
            Math.floor(p.status / 100) - 4
          ],
          p.config,
          p.request,
          p
        )
      );
}
const cookies = platform.isStandardBrowserEnv
  ? (function () {
      return {
        write: function (p, v, $, S, x, I) {
          const F = [];
          F.push(p + "=" + encodeURIComponent(v)),
            utils.isNumber($) && F.push("expires=" + new Date($).toGMTString()),
            utils.isString(S) && F.push("path=" + S),
            utils.isString(x) && F.push("domain=" + x),
            I === !0 && F.push("secure"),
            (document.cookie = F.join("; "));
        },
        read: function (p) {
          const v = document.cookie.match(
            new RegExp("(^|;\\s*)(" + p + ")=([^;]*)")
          );
          return v ? decodeURIComponent(v[3]) : null;
        },
        remove: function (p) {
          this.write(p, "", Date.now() - 864e5);
        },
      };
    })()
  : (function () {
      return {
        write: function () {},
        read: function () {
          return null;
        },
        remove: function () {},
      };
    })();
function isAbsoluteURL(k) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(k);
}
function combineURLs(k, r) {
  return r ? k.replace(/\/+$/, "") + "/" + r.replace(/^\/+/, "") : k;
}
function buildFullPath(k, r) {
  return k && !isAbsoluteURL(r) ? combineURLs(k, r) : r;
}
const isURLSameOrigin = platform.isStandardBrowserEnv
  ? (function () {
      const r = /(msie|trident)/i.test(navigator.userAgent),
        p = document.createElement("a");
      let v;
      function $(S) {
        let x = S;
        return (
          r && (p.setAttribute("href", x), (x = p.href)),
          p.setAttribute("href", x),
          {
            href: p.href,
            protocol: p.protocol ? p.protocol.replace(/:$/, "") : "",
            host: p.host,
            search: p.search ? p.search.replace(/^\?/, "") : "",
            hash: p.hash ? p.hash.replace(/^#/, "") : "",
            hostname: p.hostname,
            port: p.port,
            pathname:
              p.pathname.charAt(0) === "/" ? p.pathname : "/" + p.pathname,
          }
        );
      }
      return (
        (v = $(window.location.href)),
        function (x) {
          const I = utils.isString(x) ? $(x) : x;
          return I.protocol === v.protocol && I.host === v.host;
        }
      );
    })()
  : (function () {
      return function () {
        return !0;
      };
    })();
function parseProtocol(k) {
  const r = /^([-+\w]{1,25})(:?\/\/|:)/.exec(k);
  return (r && r[1]) || "";
}
function speedometer(k, r) {
  k = k || 10;
  const p = new Array(k),
    v = new Array(k);
  let $ = 0,
    S = 0,
    x;
  return (
    (r = r !== void 0 ? r : 1e3),
    function (F) {
      const O = Date.now(),
        L = v[S];
      x || (x = O), (p[$] = F), (v[$] = O);
      let U = S,
        j = 0;
      for (; U !== $; ) (j += p[U++]), (U = U % k);
      if ((($ = ($ + 1) % k), $ === S && (S = (S + 1) % k), O - x < r)) return;
      const N = L && O - L;
      return N ? Math.round((j * 1e3) / N) : void 0;
    }
  );
}
function progressEventReducer(k, r) {
  let p = 0;
  const v = speedometer(50, 250);
  return ($) => {
    const S = $.loaded,
      x = $.lengthComputable ? $.total : void 0,
      I = S - p,
      F = v(I),
      O = S <= x;
    p = S;
    const L = {
      loaded: S,
      total: x,
      progress: x ? S / x : void 0,
      bytes: I,
      rate: F || void 0,
      estimated: F && x && O ? (x - S) / F : void 0,
      event: $,
    };
    (L[r ? "download" : "upload"] = !0), k(L);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest < "u",
  xhrAdapter =
    isXHRAdapterSupported &&
    function (k) {
      return new Promise(function (p, v) {
        let $ = k.data;
        const S = AxiosHeaders$1.from(k.headers).normalize(),
          x = k.responseType;
        let I;
        function F() {
          k.cancelToken && k.cancelToken.unsubscribe(I),
            k.signal && k.signal.removeEventListener("abort", I);
        }
        utils.isFormData($) &&
          (platform.isStandardBrowserEnv ||
            platform.isStandardBrowserWebWorkerEnv) &&
          S.setContentType(!1);
        let O = new XMLHttpRequest();
        if (k.auth) {
          const N = k.auth.username || "",
            q = k.auth.password
              ? unescape(encodeURIComponent(k.auth.password))
              : "";
          S.set("Authorization", "Basic " + btoa(N + ":" + q));
        }
        const L = buildFullPath(k.baseURL, k.url);
        O.open(
          k.method.toUpperCase(),
          buildURL(L, k.params, k.paramsSerializer),
          !0
        ),
          (O.timeout = k.timeout);
        function U() {
          if (!O) return;
          const N = AxiosHeaders$1.from(
              "getAllResponseHeaders" in O && O.getAllResponseHeaders()
            ),
            R = {
              data:
                !x || x === "text" || x === "json"
                  ? O.responseText
                  : O.response,
              status: O.status,
              statusText: O.statusText,
              headers: N,
              config: k,
              request: O,
            };
          settle(
            function (H) {
              p(H), F();
            },
            function (H) {
              v(H), F();
            },
            R
          ),
            (O = null);
        }
        if (
          ("onloadend" in O
            ? (O.onloadend = U)
            : (O.onreadystatechange = function () {
                !O ||
                  O.readyState !== 4 ||
                  (O.status === 0 &&
                    !(O.responseURL && O.responseURL.indexOf("file:") === 0)) ||
                  setTimeout(U);
              }),
          (O.onabort = function () {
            O &&
              (v(
                new AxiosError("Request aborted", AxiosError.ECONNABORTED, k, O)
              ),
              (O = null));
          }),
          (O.onerror = function () {
            v(new AxiosError("Network Error", AxiosError.ERR_NETWORK, k, O)),
              (O = null);
          }),
          (O.ontimeout = function () {
            let q = k.timeout
              ? "timeout of " + k.timeout + "ms exceeded"
              : "timeout exceeded";
            const R = k.transitional || transitionalDefaults;
            k.timeoutErrorMessage && (q = k.timeoutErrorMessage),
              v(
                new AxiosError(
                  q,
                  R.clarifyTimeoutError
                    ? AxiosError.ETIMEDOUT
                    : AxiosError.ECONNABORTED,
                  k,
                  O
                )
              ),
              (O = null);
          }),
          platform.isStandardBrowserEnv)
        ) {
          const N =
            (k.withCredentials || isURLSameOrigin(L)) &&
            k.xsrfCookieName &&
            cookies.read(k.xsrfCookieName);
          N && S.set(k.xsrfHeaderName, N);
        }
        $ === void 0 && S.setContentType(null),
          "setRequestHeader" in O &&
            utils.forEach(S.toJSON(), function (q, R) {
              O.setRequestHeader(R, q);
            }),
          utils.isUndefined(k.withCredentials) ||
            (O.withCredentials = !!k.withCredentials),
          x && x !== "json" && (O.responseType = k.responseType),
          typeof k.onDownloadProgress == "function" &&
            O.addEventListener(
              "progress",
              progressEventReducer(k.onDownloadProgress, !0)
            ),
          typeof k.onUploadProgress == "function" &&
            O.upload &&
            O.upload.addEventListener(
              "progress",
              progressEventReducer(k.onUploadProgress)
            ),
          (k.cancelToken || k.signal) &&
            ((I = (N) => {
              O &&
                (v(!N || N.type ? new CanceledError(null, k, O) : N),
                O.abort(),
                (O = null));
            }),
            k.cancelToken && k.cancelToken.subscribe(I),
            k.signal &&
              (k.signal.aborted ? I() : k.signal.addEventListener("abort", I)));
        const j = parseProtocol(L);
        if (j && platform.protocols.indexOf(j) === -1) {
          v(
            new AxiosError(
              "Unsupported protocol " + j + ":",
              AxiosError.ERR_BAD_REQUEST,
              k
            )
          );
          return;
        }
        O.send($ || null);
      });
    },
  knownAdapters = { http: httpAdapter, xhr: xhrAdapter };
utils.forEach(knownAdapters, (k, r) => {
  if (k) {
    try {
      Object.defineProperty(k, "name", { value: r });
    } catch {}
    Object.defineProperty(k, "adapterName", { value: r });
  }
});
const adapters = {
  getAdapter: (k) => {
    k = utils.isArray(k) ? k : [k];
    const { length: r } = k;
    let p, v;
    for (
      let $ = 0;
      $ < r &&
      ((p = k[$]),
      !(v = utils.isString(p) ? knownAdapters[p.toLowerCase()] : p));
      $++
    );
    if (!v)
      throw v === !1
        ? new AxiosError(
            `Adapter ${p} is not supported by the environment`,
            "ERR_NOT_SUPPORT"
          )
        : new Error(
            utils.hasOwnProp(knownAdapters, p)
              ? `Adapter '${p}' is not available in the build`
              : `Unknown adapter '${p}'`
          );
    if (!utils.isFunction(v)) throw new TypeError("adapter is not a function");
    return v;
  },
  adapters: knownAdapters,
};
function throwIfCancellationRequested(k) {
  if (
    (k.cancelToken && k.cancelToken.throwIfRequested(),
    k.signal && k.signal.aborted)
  )
    throw new CanceledError(null, k);
}
function dispatchRequest(k) {
  return (
    throwIfCancellationRequested(k),
    (k.headers = AxiosHeaders$1.from(k.headers)),
    (k.data = transformData.call(k, k.transformRequest)),
    ["post", "put", "patch"].indexOf(k.method) !== -1 &&
      k.headers.setContentType("application/x-www-form-urlencoded", !1),
    adapters
      .getAdapter(k.adapter || defaults$2.adapter)(k)
      .then(
        function (v) {
          return (
            throwIfCancellationRequested(k),
            (v.data = transformData.call(k, k.transformResponse, v)),
            (v.headers = AxiosHeaders$1.from(v.headers)),
            v
          );
        },
        function (v) {
          return (
            isCancel(v) ||
              (throwIfCancellationRequested(k),
              v &&
                v.response &&
                ((v.response.data = transformData.call(
                  k,
                  k.transformResponse,
                  v.response
                )),
                (v.response.headers = AxiosHeaders$1.from(
                  v.response.headers
                )))),
            Promise.reject(v)
          );
        }
      )
  );
}
const headersToObject = (k) => (k instanceof AxiosHeaders$1 ? k.toJSON() : k);
function mergeConfig(k, r) {
  r = r || {};
  const p = {};
  function v(O, L, U) {
    return utils.isPlainObject(O) && utils.isPlainObject(L)
      ? utils.merge.call({ caseless: U }, O, L)
      : utils.isPlainObject(L)
      ? utils.merge({}, L)
      : utils.isArray(L)
      ? L.slice()
      : L;
  }
  function $(O, L, U) {
    if (utils.isUndefined(L)) {
      if (!utils.isUndefined(O)) return v(void 0, O, U);
    } else return v(O, L, U);
  }
  function S(O, L) {
    if (!utils.isUndefined(L)) return v(void 0, L);
  }
  function x(O, L) {
    if (utils.isUndefined(L)) {
      if (!utils.isUndefined(O)) return v(void 0, O);
    } else return v(void 0, L);
  }
  function I(O, L, U) {
    if (U in r) return v(O, L);
    if (U in k) return v(void 0, O);
  }
  const F = {
    url: S,
    method: S,
    data: S,
    baseURL: x,
    transformRequest: x,
    transformResponse: x,
    paramsSerializer: x,
    timeout: x,
    timeoutMessage: x,
    withCredentials: x,
    adapter: x,
    responseType: x,
    xsrfCookieName: x,
    xsrfHeaderName: x,
    onUploadProgress: x,
    onDownloadProgress: x,
    decompress: x,
    maxContentLength: x,
    maxBodyLength: x,
    beforeRedirect: x,
    transport: x,
    httpAgent: x,
    httpsAgent: x,
    cancelToken: x,
    socketPath: x,
    responseEncoding: x,
    validateStatus: I,
    headers: (O, L) => $(headersToObject(O), headersToObject(L), !0),
  };
  return (
    utils.forEach(Object.keys(k).concat(Object.keys(r)), function (L) {
      const U = F[L] || $,
        j = U(k[L], r[L], L);
      (utils.isUndefined(j) && U !== I) || (p[L] = j);
    }),
    p
  );
}
const VERSION = "1.3.2",
  validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(
  (k, r) => {
    validators$1[k] = function (v) {
      return typeof v === k || "a" + (r < 1 ? "n " : " ") + k;
    };
  }
);
const deprecatedWarnings = {};
validators$1.transitional = function (r, p, v) {
  function $(S, x) {
    return (
      "[Axios v" +
      VERSION +
      "] Transitional option '" +
      S +
      "'" +
      x +
      (v ? ". " + v : "")
    );
  }
  return (S, x, I) => {
    if (r === !1)
      throw new AxiosError(
        $(x, " has been removed" + (p ? " in " + p : "")),
        AxiosError.ERR_DEPRECATED
      );
    return (
      p &&
        !deprecatedWarnings[x] &&
        ((deprecatedWarnings[x] = !0),
        console.warn(
          $(
            x,
            " has been deprecated since v" +
              p +
              " and will be removed in the near future"
          )
        )),
      r ? r(S, x, I) : !0
    );
  };
};
function assertOptions(k, r, p) {
  if (typeof k != "object")
    throw new AxiosError(
      "options must be an object",
      AxiosError.ERR_BAD_OPTION_VALUE
    );
  const v = Object.keys(k);
  let $ = v.length;
  for (; $-- > 0; ) {
    const S = v[$],
      x = r[S];
    if (x) {
      const I = k[S],
        F = I === void 0 || x(I, S, k);
      if (F !== !0)
        throw new AxiosError(
          "option " + S + " must be " + F,
          AxiosError.ERR_BAD_OPTION_VALUE
        );
      continue;
    }
    if (p !== !0)
      throw new AxiosError("Unknown option " + S, AxiosError.ERR_BAD_OPTION);
  }
}
const validator = { assertOptions, validators: validators$1 },
  validators = validator.validators;
class Axios {
  constructor(r) {
    (this.defaults = r),
      (this.interceptors = {
        request: new InterceptorManager$1(),
        response: new InterceptorManager$1(),
      });
  }
  request(r, p) {
    typeof r == "string" ? ((p = p || {}), (p.url = r)) : (p = r || {}),
      (p = mergeConfig(this.defaults, p));
    const { transitional: v, paramsSerializer: $, headers: S } = p;
    v !== void 0 &&
      validator.assertOptions(
        v,
        {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean),
        },
        !1
      ),
      $ !== void 0 &&
        validator.assertOptions(
          $,
          { encode: validators.function, serialize: validators.function },
          !0
        ),
      (p.method = (p.method || this.defaults.method || "get").toLowerCase());
    let x;
    (x = S && utils.merge(S.common, S[p.method])),
      x &&
        utils.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (q) => {
            delete S[q];
          }
        ),
      (p.headers = AxiosHeaders$1.concat(x, S));
    const I = [];
    let F = !0;
    this.interceptors.request.forEach(function (R) {
      (typeof R.runWhen == "function" && R.runWhen(p) === !1) ||
        ((F = F && R.synchronous), I.unshift(R.fulfilled, R.rejected));
    });
    const O = [];
    this.interceptors.response.forEach(function (R) {
      O.push(R.fulfilled, R.rejected);
    });
    let L,
      U = 0,
      j;
    if (!F) {
      const q = [dispatchRequest.bind(this), void 0];
      for (
        q.unshift.apply(q, I),
          q.push.apply(q, O),
          j = q.length,
          L = Promise.resolve(p);
        U < j;

      )
        L = L.then(q[U++], q[U++]);
      return L;
    }
    j = I.length;
    let N = p;
    for (U = 0; U < j; ) {
      const q = I[U++],
        R = I[U++];
      try {
        N = q(N);
      } catch (Q) {
        R.call(this, Q);
        break;
      }
    }
    try {
      L = dispatchRequest.call(this, N);
    } catch (q) {
      return Promise.reject(q);
    }
    for (U = 0, j = O.length; U < j; ) L = L.then(O[U++], O[U++]);
    return L;
  }
  getUri(r) {
    r = mergeConfig(this.defaults, r);
    const p = buildFullPath(r.baseURL, r.url);
    return buildURL(p, r.params, r.paramsSerializer);
  }
}
utils.forEach(["delete", "get", "head", "options"], function (r) {
  Axios.prototype[r] = function (p, v) {
    return this.request(
      mergeConfig(v || {}, { method: r, url: p, data: (v || {}).data })
    );
  };
});
utils.forEach(["post", "put", "patch"], function (r) {
  function p(v) {
    return function (S, x, I) {
      return this.request(
        mergeConfig(I || {}, {
          method: r,
          headers: v ? { "Content-Type": "multipart/form-data" } : {},
          url: S,
          data: x,
        })
      );
    };
  }
  (Axios.prototype[r] = p()), (Axios.prototype[r + "Form"] = p(!0));
});
const Axios$1 = Axios;
class CancelToken {
  constructor(r) {
    if (typeof r != "function")
      throw new TypeError("executor must be a function.");
    let p;
    this.promise = new Promise(function (S) {
      p = S;
    });
    const v = this;
    this.promise.then(($) => {
      if (!v._listeners) return;
      let S = v._listeners.length;
      for (; S-- > 0; ) v._listeners[S]($);
      v._listeners = null;
    }),
      (this.promise.then = ($) => {
        let S;
        const x = new Promise((I) => {
          v.subscribe(I), (S = I);
        }).then($);
        return (
          (x.cancel = function () {
            v.unsubscribe(S);
          }),
          x
        );
      }),
      r(function (S, x, I) {
        v.reason || ((v.reason = new CanceledError(S, x, I)), p(v.reason));
      });
  }
  throwIfRequested() {
    if (this.reason) throw this.reason;
  }
  subscribe(r) {
    if (this.reason) {
      r(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(r) : (this._listeners = [r]);
  }
  unsubscribe(r) {
    if (!this._listeners) return;
    const p = this._listeners.indexOf(r);
    p !== -1 && this._listeners.splice(p, 1);
  }
  static source() {
    let r;
    return {
      token: new CancelToken(function ($) {
        r = $;
      }),
      cancel: r,
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(k) {
  return function (p) {
    return k.apply(null, p);
  };
}
function isAxiosError(k) {
  return utils.isObject(k) && k.isAxiosError === !0;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};
Object.entries(HttpStatusCode).forEach(([k, r]) => {
  HttpStatusCode[r] = k;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(k) {
  const r = new Axios$1(k),
    p = bind(Axios$1.prototype.request, r);
  return (
    utils.extend(p, Axios$1.prototype, r, { allOwnKeys: !0 }),
    utils.extend(p, r, null, { allOwnKeys: !0 }),
    (p.create = function ($) {
      return createInstance(mergeConfig(k, $));
    }),
    p
  );
}
const axios = createInstance(defaults$2);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function (r) {
  return Promise.all(r);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (k) =>
  formDataToJSON(utils.isHTMLForm(k) ? new FormData(k) : k);
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios,
  abortFileReader = writable(!1);
async function readFile(k) {
  Log({
    source: "fs/file.ts: readFile",
    msg: `Requesting file contents of "${k}" from ArcAPI`,
    level: LogLevel.info,
  });
  const r = get_store_value(ConnectedServer);
  if (!r) return !1;
  const p = {
    headers: { Authorization: `Bearer ${get_store_value(UserToken)}` },
  };
  let v = new AbortController();
  const $ = generateParamStr({ path: btoa(k) });
  let S = await fetch(`${r}/fs/file/get${$}`, { ...p, signal: v.signal });
  if (
    (abortFileReader.set(!1),
    abortFileReader.subscribe((I) => {
      I &&
        (Log({
          source: "fs/file.ts: readFile",
          msg: `Aborting readFile for "${k}" as requested by the user...`,
          level: LogLevel.error,
        }),
        v.abort(),
        FileBrowserOpenCancelled.set(!0),
        abortFileReader.set(!1));
    }),
    S.status != 200)
  )
    return !1;
  const x = await S.blob();
  return (S = null), await x.arrayBuffer();
}
async function deleteItem(k) {
  Log({
    source: "fs/file.ts: deleteItem",
    msg: `Deleting item "${k}" from ArcFS`,
    level: LogLevel.info,
  });
  const r = get_store_value(ConnectedServer);
  return r
    ? (
        await apiCall(
          r,
          "fs/rm",
          { path: btoa(k) },
          get_store_value(UserToken),
          null,
          null,
          !0
        )
      ).valid != !1
    : !1;
}
async function writeFile(k, r) {
  const p = get_store_value(ConnectedServer);
  if (!p) return !1;
  const v = generateParamStr({ path: btoa(k) });
  return (
    (
      await axios$1.post(`${p}/fs/file/write${v}`, r, {
        headers: { Authorization: `Bearer ${get_store_value(UserToken)}` },
        onUploadProgress(S) {
          const x = (S.loaded / S.total) * 100;
          FileBrowserUploadProgress.set(x);
        },
      })
    ).status == 200
  );
}
function createOverlayableError(k, r) {
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++) {
    const $ = p[v];
    if ($.id == r)
      return (
        $.errorOverlays || ($.errorOverlays = []),
        $.errorOverlays.push({
          ...k,
          id: `${Math.floor(Math.random() * 1e9)}`,
        }),
        WindowStore.set(p),
        !0
      );
  }
  return !1;
}
function destroyOverlayableError(k, r) {
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++) {
    const $ = p[v];
    if ($.id != r || !$.errorOverlays) continue;
    const S = $.errorOverlays;
    for (let x = 0; x < S.length; x++)
      if (S[x].id == k) return S.splice(x, 1), WindowStore.set(p), !0;
  }
  return !1;
}
function showOverlay(k, r) {
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++)
    if (p[v].id == r) {
      if (!p[v].overlays || !p[v].overlays[k]) return !1;
      p[v].overlays[k].show = !0;
    }
  WindowStore.set(p);
}
function hideOverlay(k, r) {
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++)
    if (p[v].id == r) {
      if (!p[v].overlays || !p[v].overlays[k]) return !1;
      p[v].overlays[k].show = !1;
    }
  WindowStore.set(p);
}
const clear$1 = "./assets/clear-675017c3.svg";
let FileBrowserCurrentDir = writable("./"),
  FileBrowserDirContents = writable(defaultDirectory),
  FileBrowserSelectedFilename = writable(null),
  FileBrowserOpeningFile = writable(null),
  FileBrowserDeletingFilename = writable(null),
  FileBrowserUploadFile = writable(null),
  FileBrowserOpenCancelled = writable(!1),
  FileBrowserRefreshing = writable(!1),
  FileBrowserUploadProgress = writable(0),
  FileBrowserCuttingFilename = writable(null),
  FileBrowserCopyingFilename = writable(null);
FileBrowserOpenCancelled.subscribe((k) => {
  k &&
    (createOverlayableError(
      {
        title: "Open cancelled",
        message: "The opening procedure was cancelled by the user.",
        buttons: [{ caption: "OK", action() {} }],
        image: warning,
      },
      "FileManager"
    ),
    FileBrowserOpenCancelled.set(!1));
});
class FileBrowserClass {
  async refresh(r = !0) {
    Log({
      source: "FileBrowser: refresh",
      msg: "Refreshing current directory contents",
      level: LogLevel.info,
    }),
      FileBrowserRefreshing.set(!0),
      r &&
        (FileBrowserDirContents.set(defaultDirectory),
        FileBrowserSelectedFilename.set(null));
    const p = get_store_value(FileBrowserCurrentDir),
      v = await getDirectory(p);
    FileBrowserDirContents.set(v || { ...defaultDirectory, scopedPath: p }),
      FileBrowserRefreshing.set(!1);
  }
  async goToDirectory(r) {
    Log({
      source: "FileBrowser: goToDirectory",
      msg: `Navigating to "${r}"`,
      level: LogLevel.info,
    }),
      FileBrowserSelectedFilename.set(null),
      FileBrowserCurrentDir.set(r),
      await this.refresh();
  }
  async deleteItem(r, p) {
    FileBrowserDeletingFilename.set(r),
      showOverlay("deletingItem", "FileManager"),
      (await deleteItem(p)) ||
        createOverlayableError(
          {
            title: "Unable to delete item",
            message:
              "ArcAPI was not able to delete the item from the file system. A permission error may have occured. Please try again later.",
            buttons: [{ caption: "OK", action() {} }],
            image: clear$1,
          },
          "FileManager"
        ),
      FileBrowserSelectedFilename.set(null),
      fbClass.refresh(),
      setTimeout(() => {
        hideOverlay("deletingItem", "FileManager");
      }, 100);
  }
}
const fbClass = new FileBrowserClass(),
  ActionCenterOpened = writable(!1);
function toggleActionCenter() {
  const k = !get_store_value(ActionCenterOpened);
  ActionCenterOpened.set(k);
}
const AppPokerData = writable(null),
  appShortcuts = [];
function registerAppShortcuts(k, r) {
  if (
    (Log({
      source: "keyboard: registerAppShortcuts",
      msg: `Registering app shortcuts for ${k}`,
      level: LogLevel.info,
    }),
    !r.events || !r.events.keyboardShortcuts || isRegistered(k))
  )
    return !1;
  appShortcuts.push([k, r.events.keyboardShortcuts]);
}
function registerShortcuts(k, r) {
  appShortcuts.push([r || "", k]);
}
function isRegistered(k) {
  for (let r = 0; r < appShortcuts.length; r++)
    if (appShortcuts[r][0] == k) return !0;
  return !1;
}
const CurrentNotification = writable(null),
  NotificationStore = writable({});
let globalNotifTimeout;
function makeNotification(k) {
  clearTimeout(globalNotifTimeout);
  const r = `${Math.floor(Math.random() * 1e9)}`,
    p = get_store_value(NotificationStore);
  return (
    (p[r] = k),
    NotificationStore.set(p),
    setTimeout(() => {
      CurrentNotification.set(r);
    }, 100),
    k.timeout &&
      (globalNotifTimeout = setTimeout(() => {
        CurrentNotification.set(null);
      }, k.timeout)),
    r
  );
}
function closeNotification() {
  CurrentNotification.set(null);
}
function deleteNotification(k) {
  const r = get_store_value(NotificationStore);
  delete r[k], NotificationStore.set(r);
}
function isArray(k) {
  return Array.isArray ? Array.isArray(k) : getTag(k) === "[object Array]";
}
const INFINITY = 1 / 0;
function baseToString(k) {
  if (typeof k == "string") return k;
  let r = k + "";
  return r == "0" && 1 / k == -INFINITY ? "-0" : r;
}
function toString(k) {
  return k == null ? "" : baseToString(k);
}
function isString(k) {
  return typeof k == "string";
}
function isNumber(k) {
  return typeof k == "number";
}
function isBoolean(k) {
  return (
    k === !0 || k === !1 || (isObjectLike(k) && getTag(k) == "[object Boolean]")
  );
}
function isObject(k) {
  return typeof k == "object";
}
function isObjectLike(k) {
  return isObject(k) && k !== null;
}
function isDefined(k) {
  return k != null;
}
function isBlank(k) {
  return !k.trim().length;
}
function getTag(k) {
  return k == null
    ? k === void 0
      ? "[object Undefined]"
      : "[object Null]"
    : Object.prototype.toString.call(k);
}
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available",
  INCORRECT_INDEX_TYPE = "Incorrect 'index' type",
  LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (k) => `Invalid value for key ${k}`,
  PATTERN_LENGTH_TOO_LARGE = (k) => `Pattern length exceeds max of ${k}.`,
  MISSING_KEY_PROPERTY = (k) => `Missing ${k} property in key`,
  INVALID_KEY_WEIGHT_VALUE = (k) =>
    `Property 'weight' in key '${k}' must be a positive integer`,
  hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
  constructor(r) {
    (this._keys = []), (this._keyMap = {});
    let p = 0;
    r.forEach((v) => {
      let $ = createKey(v);
      (p += $.weight),
        this._keys.push($),
        (this._keyMap[$.id] = $),
        (p += $.weight);
    }),
      this._keys.forEach((v) => {
        v.weight /= p;
      });
  }
  get(r) {
    return this._keyMap[r];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(k) {
  let r = null,
    p = null,
    v = null,
    $ = 1,
    S = null;
  if (isString(k) || isArray(k))
    (v = k), (r = createKeyPath(k)), (p = createKeyId(k));
  else {
    if (!hasOwn.call(k, "name")) throw new Error(MISSING_KEY_PROPERTY("name"));
    const x = k.name;
    if (((v = x), hasOwn.call(k, "weight") && (($ = k.weight), $ <= 0)))
      throw new Error(INVALID_KEY_WEIGHT_VALUE(x));
    (r = createKeyPath(x)), (p = createKeyId(x)), (S = k.getFn);
  }
  return { path: r, id: p, weight: $, src: v, getFn: S };
}
function createKeyPath(k) {
  return isArray(k) ? k : k.split(".");
}
function createKeyId(k) {
  return isArray(k) ? k.join(".") : k;
}
function get(k, r) {
  let p = [],
    v = !1;
  const $ = (S, x, I) => {
    if (isDefined(S))
      if (!x[I]) p.push(S);
      else {
        let F = x[I];
        const O = S[F];
        if (!isDefined(O)) return;
        if (I === x.length - 1 && (isString(O) || isNumber(O) || isBoolean(O)))
          p.push(toString(O));
        else if (isArray(O)) {
          v = !0;
          for (let L = 0, U = O.length; L < U; L += 1) $(O[L], x, I + 1);
        } else x.length && $(O, x, I + 1);
      }
  };
  return $(k, isString(r) ? r.split(".") : r, 0), v ? p : p[0];
}
const MatchOptions = {
    includeMatches: !1,
    findAllMatches: !1,
    minMatchCharLength: 1,
  },
  BasicOptions = {
    isCaseSensitive: !1,
    includeScore: !1,
    keys: [],
    shouldSort: !0,
    sortFn: (k, r) =>
      k.score === r.score
        ? k.idx < r.idx
          ? -1
          : 1
        : k.score < r.score
        ? -1
        : 1,
  },
  FuzzyOptions = { location: 0, threshold: 0.6, distance: 100 },
  AdvancedOptions = {
    useExtendedSearch: !1,
    getFn: get,
    ignoreLocation: !1,
    ignoreFieldNorm: !1,
    fieldNormWeight: 1,
  };
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions,
};
const SPACE = /[^ ]+/g;
function norm(k = 1, r = 3) {
  const p = new Map(),
    v = Math.pow(10, r);
  return {
    get($) {
      const S = $.match(SPACE).length;
      if (p.has(S)) return p.get(S);
      const x = 1 / Math.pow(S, 0.5 * k),
        I = parseFloat(Math.round(x * v) / v);
      return p.set(S, I), I;
    },
    clear() {
      p.clear();
    },
  };
}
class FuseIndex {
  constructor({
    getFn: r = Config.getFn,
    fieldNormWeight: p = Config.fieldNormWeight,
  } = {}) {
    (this.norm = norm(p, 3)),
      (this.getFn = r),
      (this.isCreated = !1),
      this.setIndexRecords();
  }
  setSources(r = []) {
    this.docs = r;
  }
  setIndexRecords(r = []) {
    this.records = r;
  }
  setKeys(r = []) {
    (this.keys = r),
      (this._keysMap = {}),
      r.forEach((p, v) => {
        this._keysMap[p.id] = v;
      });
  }
  create() {
    this.isCreated ||
      !this.docs.length ||
      ((this.isCreated = !0),
      isString(this.docs[0])
        ? this.docs.forEach((r, p) => {
            this._addString(r, p);
          })
        : this.docs.forEach((r, p) => {
            this._addObject(r, p);
          }),
      this.norm.clear());
  }
  add(r) {
    const p = this.size();
    isString(r) ? this._addString(r, p) : this._addObject(r, p);
  }
  removeAt(r) {
    this.records.splice(r, 1);
    for (let p = r, v = this.size(); p < v; p += 1) this.records[p].i -= 1;
  }
  getValueForItemAtKeyId(r, p) {
    return r[this._keysMap[p]];
  }
  size() {
    return this.records.length;
  }
  _addString(r, p) {
    if (!isDefined(r) || isBlank(r)) return;
    let v = { v: r, i: p, n: this.norm.get(r) };
    this.records.push(v);
  }
  _addObject(r, p) {
    let v = { i: p, $: {} };
    this.keys.forEach(($, S) => {
      let x = $.getFn ? $.getFn(r) : this.getFn(r, $.path);
      if (isDefined(x)) {
        if (isArray(x)) {
          let I = [];
          const F = [{ nestedArrIndex: -1, value: x }];
          for (; F.length; ) {
            const { nestedArrIndex: O, value: L } = F.pop();
            if (isDefined(L))
              if (isString(L) && !isBlank(L)) {
                let U = { v: L, i: O, n: this.norm.get(L) };
                I.push(U);
              } else
                isArray(L) &&
                  L.forEach((U, j) => {
                    F.push({ nestedArrIndex: j, value: U });
                  });
          }
          v.$[S] = I;
        } else if (isString(x) && !isBlank(x)) {
          let I = { v: x, n: this.norm.get(x) };
          v.$[S] = I;
        }
      }
    }),
      this.records.push(v);
  }
  toJSON() {
    return { keys: this.keys, records: this.records };
  }
}
function createIndex(
  k,
  r,
  { getFn: p = Config.getFn, fieldNormWeight: v = Config.fieldNormWeight } = {}
) {
  const $ = new FuseIndex({ getFn: p, fieldNormWeight: v });
  return $.setKeys(k.map(createKey)), $.setSources(r), $.create(), $;
}
function parseIndex(
  k,
  { getFn: r = Config.getFn, fieldNormWeight: p = Config.fieldNormWeight } = {}
) {
  const { keys: v, records: $ } = k,
    S = new FuseIndex({ getFn: r, fieldNormWeight: p });
  return S.setKeys(v), S.setIndexRecords($), S;
}
function computeScore$1(
  k,
  {
    errors: r = 0,
    currentLocation: p = 0,
    expectedLocation: v = 0,
    distance: $ = Config.distance,
    ignoreLocation: S = Config.ignoreLocation,
  } = {}
) {
  const x = r / k.length;
  if (S) return x;
  const I = Math.abs(v - p);
  return $ ? x + I / $ : I ? 1 : x;
}
function convertMaskToIndices(k = [], r = Config.minMatchCharLength) {
  let p = [],
    v = -1,
    $ = -1,
    S = 0;
  for (let x = k.length; S < x; S += 1) {
    let I = k[S];
    I && v === -1
      ? (v = S)
      : !I &&
        v !== -1 &&
        (($ = S - 1), $ - v + 1 >= r && p.push([v, $]), (v = -1));
  }
  return k[S - 1] && S - v >= r && p.push([v, S - 1]), p;
}
const MAX_BITS = 32;
function search(
  k,
  r,
  p,
  {
    location: v = Config.location,
    distance: $ = Config.distance,
    threshold: S = Config.threshold,
    findAllMatches: x = Config.findAllMatches,
    minMatchCharLength: I = Config.minMatchCharLength,
    includeMatches: F = Config.includeMatches,
    ignoreLocation: O = Config.ignoreLocation,
  } = {}
) {
  if (r.length > MAX_BITS) throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  const L = r.length,
    U = k.length,
    j = Math.max(0, Math.min(v, U));
  let N = S,
    q = j;
  const R = I > 1 || F,
    Q = R ? Array(U) : [];
  let H;
  for (; (H = k.indexOf(r, q)) > -1; ) {
    let Z = computeScore$1(r, {
      currentLocation: H,
      expectedLocation: j,
      distance: $,
      ignoreLocation: O,
    });
    if (((N = Math.min(Z, N)), (q = H + L), R)) {
      let X = 0;
      for (; X < L; ) (Q[H + X] = 1), (X += 1);
    }
  }
  q = -1;
  let G = [],
    V = 1,
    K = L + U;
  const Y = 1 << (L - 1);
  for (let Z = 0; Z < L; Z += 1) {
    let X = 0,
      ee = K;
    for (; X < ee; )
      computeScore$1(r, {
        errors: Z,
        currentLocation: j + ee,
        expectedLocation: j,
        distance: $,
        ignoreLocation: O,
      }) <= N
        ? (X = ee)
        : (K = ee),
        (ee = Math.floor((K - X) / 2 + X));
    K = ee;
    let te = Math.max(1, j - ee + 1),
      re = x ? U : Math.min(j + ee, U) + L,
      fe = Array(re + 2);
    fe[re + 1] = (1 << Z) - 1;
    for (let se = re; se >= te; se -= 1) {
      let ae = se - 1,
        oe = p[k.charAt(ae)];
      if (
        (R && (Q[ae] = +!!oe),
        (fe[se] = ((fe[se + 1] << 1) | 1) & oe),
        Z && (fe[se] |= ((G[se + 1] | G[se]) << 1) | 1 | G[se + 1]),
        fe[se] & Y &&
          ((V = computeScore$1(r, {
            errors: Z,
            currentLocation: ae,
            expectedLocation: j,
            distance: $,
            ignoreLocation: O,
          })),
          V <= N))
      ) {
        if (((N = V), (q = ae), q <= j)) break;
        te = Math.max(1, 2 * j - q);
      }
    }
    if (
      computeScore$1(r, {
        errors: Z + 1,
        currentLocation: j,
        expectedLocation: j,
        distance: $,
        ignoreLocation: O,
      }) > N
    )
      break;
    G = fe;
  }
  const J = { isMatch: q >= 0, score: Math.max(0.001, V) };
  if (R) {
    const Z = convertMaskToIndices(Q, I);
    Z.length ? F && (J.indices = Z) : (J.isMatch = !1);
  }
  return J;
}
function createPatternAlphabet(k) {
  let r = {};
  for (let p = 0, v = k.length; p < v; p += 1) {
    const $ = k.charAt(p);
    r[$] = (r[$] || 0) | (1 << (v - p - 1));
  }
  return r;
}
class BitapSearch {
  constructor(
    r,
    {
      location: p = Config.location,
      threshold: v = Config.threshold,
      distance: $ = Config.distance,
      includeMatches: S = Config.includeMatches,
      findAllMatches: x = Config.findAllMatches,
      minMatchCharLength: I = Config.minMatchCharLength,
      isCaseSensitive: F = Config.isCaseSensitive,
      ignoreLocation: O = Config.ignoreLocation,
    } = {}
  ) {
    if (
      ((this.options = {
        location: p,
        threshold: v,
        distance: $,
        includeMatches: S,
        findAllMatches: x,
        minMatchCharLength: I,
        isCaseSensitive: F,
        ignoreLocation: O,
      }),
      (this.pattern = F ? r : r.toLowerCase()),
      (this.chunks = []),
      !this.pattern.length)
    )
      return;
    const L = (j, N) => {
        this.chunks.push({
          pattern: j,
          alphabet: createPatternAlphabet(j),
          startIndex: N,
        });
      },
      U = this.pattern.length;
    if (U > MAX_BITS) {
      let j = 0;
      const N = U % MAX_BITS,
        q = U - N;
      for (; j < q; ) L(this.pattern.substr(j, MAX_BITS), j), (j += MAX_BITS);
      if (N) {
        const R = U - MAX_BITS;
        L(this.pattern.substr(R), R);
      }
    } else L(this.pattern, 0);
  }
  searchIn(r) {
    const { isCaseSensitive: p, includeMatches: v } = this.options;
    if ((p || (r = r.toLowerCase()), this.pattern === r)) {
      let q = { isMatch: !0, score: 0 };
      return v && (q.indices = [[0, r.length - 1]]), q;
    }
    const {
      location: $,
      distance: S,
      threshold: x,
      findAllMatches: I,
      minMatchCharLength: F,
      ignoreLocation: O,
    } = this.options;
    let L = [],
      U = 0,
      j = !1;
    this.chunks.forEach(({ pattern: q, alphabet: R, startIndex: Q }) => {
      const {
        isMatch: H,
        score: G,
        indices: V,
      } = search(r, q, R, {
        location: $ + Q,
        distance: S,
        threshold: x,
        findAllMatches: I,
        minMatchCharLength: F,
        includeMatches: v,
        ignoreLocation: O,
      });
      H && (j = !0), (U += G), H && V && (L = [...L, ...V]);
    });
    let N = { isMatch: j, score: j ? U / this.chunks.length : 1 };
    return j && v && (N.indices = L), N;
  }
}
class BaseMatch {
  constructor(r) {
    this.pattern = r;
  }
  static isMultiMatch(r) {
    return getMatch(r, this.multiRegex);
  }
  static isSingleMatch(r) {
    return getMatch(r, this.singleRegex);
  }
  search() {}
}
function getMatch(k, r) {
  const p = k.match(r);
  return p ? p[1] : null;
}
class ExactMatch extends BaseMatch {
  constructor(r) {
    super(r);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(r) {
    const p = r === this.pattern;
    return {
      isMatch: p,
      score: p ? 0 : 1,
      indices: [0, this.pattern.length - 1],
    };
  }
}
class InverseExactMatch extends BaseMatch {
  constructor(r) {
    super(r);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(r) {
    const v = r.indexOf(this.pattern) === -1;
    return { isMatch: v, score: v ? 0 : 1, indices: [0, r.length - 1] };
  }
}
class PrefixExactMatch extends BaseMatch {
  constructor(r) {
    super(r);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(r) {
    const p = r.startsWith(this.pattern);
    return {
      isMatch: p,
      score: p ? 0 : 1,
      indices: [0, this.pattern.length - 1],
    };
  }
}
class InversePrefixExactMatch extends BaseMatch {
  constructor(r) {
    super(r);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(r) {
    const p = !r.startsWith(this.pattern);
    return { isMatch: p, score: p ? 0 : 1, indices: [0, r.length - 1] };
  }
}
class SuffixExactMatch extends BaseMatch {
  constructor(r) {
    super(r);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(r) {
    const p = r.endsWith(this.pattern);
    return {
      isMatch: p,
      score: p ? 0 : 1,
      indices: [r.length - this.pattern.length, r.length - 1],
    };
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  constructor(r) {
    super(r);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(r) {
    const p = !r.endsWith(this.pattern);
    return { isMatch: p, score: p ? 0 : 1, indices: [0, r.length - 1] };
  }
}
class FuzzyMatch extends BaseMatch {
  constructor(
    r,
    {
      location: p = Config.location,
      threshold: v = Config.threshold,
      distance: $ = Config.distance,
      includeMatches: S = Config.includeMatches,
      findAllMatches: x = Config.findAllMatches,
      minMatchCharLength: I = Config.minMatchCharLength,
      isCaseSensitive: F = Config.isCaseSensitive,
      ignoreLocation: O = Config.ignoreLocation,
    } = {}
  ) {
    super(r),
      (this._bitapSearch = new BitapSearch(r, {
        location: p,
        threshold: v,
        distance: $,
        includeMatches: S,
        findAllMatches: x,
        minMatchCharLength: I,
        isCaseSensitive: F,
        ignoreLocation: O,
      }));
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(r) {
    return this._bitapSearch.searchIn(r);
  }
}
class IncludeMatch extends BaseMatch {
  constructor(r) {
    super(r);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(r) {
    let p = 0,
      v;
    const $ = [],
      S = this.pattern.length;
    for (; (v = r.indexOf(this.pattern, p)) > -1; )
      (p = v + S), $.push([v, p - 1]);
    const x = !!$.length;
    return { isMatch: x, score: x ? 0 : 1, indices: $ };
  }
}
const searchers = [
    ExactMatch,
    IncludeMatch,
    PrefixExactMatch,
    InversePrefixExactMatch,
    InverseSuffixExactMatch,
    SuffixExactMatch,
    InverseExactMatch,
    FuzzyMatch,
  ],
  searchersLen = searchers.length,
  SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,
  OR_TOKEN = "|";
function parseQuery(k, r = {}) {
  return k.split(OR_TOKEN).map((p) => {
    let v = p
        .trim()
        .split(SPACE_RE)
        .filter((S) => S && !!S.trim()),
      $ = [];
    for (let S = 0, x = v.length; S < x; S += 1) {
      const I = v[S];
      let F = !1,
        O = -1;
      for (; !F && ++O < searchersLen; ) {
        const L = searchers[O];
        let U = L.isMultiMatch(I);
        U && ($.push(new L(U, r)), (F = !0));
      }
      if (!F)
        for (O = -1; ++O < searchersLen; ) {
          const L = searchers[O];
          let U = L.isSingleMatch(I);
          if (U) {
            $.push(new L(U, r));
            break;
          }
        }
    }
    return $;
  });
}
const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
  constructor(
    r,
    {
      isCaseSensitive: p = Config.isCaseSensitive,
      includeMatches: v = Config.includeMatches,
      minMatchCharLength: $ = Config.minMatchCharLength,
      ignoreLocation: S = Config.ignoreLocation,
      findAllMatches: x = Config.findAllMatches,
      location: I = Config.location,
      threshold: F = Config.threshold,
      distance: O = Config.distance,
    } = {}
  ) {
    (this.query = null),
      (this.options = {
        isCaseSensitive: p,
        includeMatches: v,
        minMatchCharLength: $,
        findAllMatches: x,
        ignoreLocation: S,
        location: I,
        threshold: F,
        distance: O,
      }),
      (this.pattern = p ? r : r.toLowerCase()),
      (this.query = parseQuery(this.pattern, this.options));
  }
  static condition(r, p) {
    return p.useExtendedSearch;
  }
  searchIn(r) {
    const p = this.query;
    if (!p) return { isMatch: !1, score: 1 };
    const { includeMatches: v, isCaseSensitive: $ } = this.options;
    r = $ ? r : r.toLowerCase();
    let S = 0,
      x = [],
      I = 0;
    for (let F = 0, O = p.length; F < O; F += 1) {
      const L = p[F];
      (x.length = 0), (S = 0);
      for (let U = 0, j = L.length; U < j; U += 1) {
        const N = L[U],
          { isMatch: q, indices: R, score: Q } = N.search(r);
        if (q) {
          if (((S += 1), (I += Q), v)) {
            const H = N.constructor.type;
            MultiMatchSet.has(H) ? (x = [...x, ...R]) : x.push(R);
          }
        } else {
          (I = 0), (S = 0), (x.length = 0);
          break;
        }
      }
      if (S) {
        let U = { isMatch: !0, score: I / S };
        return v && (U.indices = x), U;
      }
    }
    return { isMatch: !1, score: 1 };
  }
}
const registeredSearchers = [];
function register(...k) {
  registeredSearchers.push(...k);
}
function createSearcher(k, r) {
  for (let p = 0, v = registeredSearchers.length; p < v; p += 1) {
    let $ = registeredSearchers[p];
    if ($.condition(k, r)) return new $(k, r);
  }
  return new BitapSearch(k, r);
}
const LogicalOperator = { AND: "$and", OR: "$or" },
  KeyType = { PATH: "$path", PATTERN: "$val" },
  isExpression = (k) => !!(k[LogicalOperator.AND] || k[LogicalOperator.OR]),
  isPath = (k) => !!k[KeyType.PATH],
  isLeaf = (k) => !isArray(k) && isObject(k) && !isExpression(k),
  convertToExplicit = (k) => ({
    [LogicalOperator.AND]: Object.keys(k).map((r) => ({ [r]: k[r] })),
  });
function parse(k, r, { auto: p = !0 } = {}) {
  const v = ($) => {
    let S = Object.keys($);
    const x = isPath($);
    if (!x && S.length > 1 && !isExpression($)) return v(convertToExplicit($));
    if (isLeaf($)) {
      const F = x ? $[KeyType.PATH] : S[0],
        O = x ? $[KeyType.PATTERN] : $[F];
      if (!isString(O))
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(F));
      const L = { keyId: createKeyId(F), pattern: O };
      return p && (L.searcher = createSearcher(O, r)), L;
    }
    let I = { children: [], operator: S[0] };
    return (
      S.forEach((F) => {
        const O = $[F];
        isArray(O) &&
          O.forEach((L) => {
            I.children.push(v(L));
          });
      }),
      I
    );
  };
  return isExpression(k) || (k = convertToExplicit(k)), v(k);
}
function computeScore(k, { ignoreFieldNorm: r = Config.ignoreFieldNorm }) {
  k.forEach((p) => {
    let v = 1;
    p.matches.forEach(({ key: $, norm: S, score: x }) => {
      const I = $ ? $.weight : null;
      v *= Math.pow(x === 0 && I ? Number.EPSILON : x, (I || 1) * (r ? 1 : S));
    }),
      (p.score = v);
  });
}
function transformMatches(k, r) {
  const p = k.matches;
  (r.matches = []),
    isDefined(p) &&
      p.forEach((v) => {
        if (!isDefined(v.indices) || !v.indices.length) return;
        const { indices: $, value: S } = v;
        let x = { indices: $, value: S };
        v.key && (x.key = v.key.src),
          v.idx > -1 && (x.refIndex = v.idx),
          r.matches.push(x);
      });
}
function transformScore(k, r) {
  r.score = k.score;
}
function format(
  k,
  r,
  {
    includeMatches: p = Config.includeMatches,
    includeScore: v = Config.includeScore,
  } = {}
) {
  const $ = [];
  return (
    p && $.push(transformMatches),
    v && $.push(transformScore),
    k.map((S) => {
      const { idx: x } = S,
        I = { item: r[x], refIndex: x };
      return (
        $.length &&
          $.forEach((F) => {
            F(S, I);
          }),
        I
      );
    })
  );
}
class Fuse {
  constructor(r, p = {}, v) {
    (this.options = { ...Config, ...p }),
      this.options.useExtendedSearch,
      (this._keyStore = new KeyStore(this.options.keys)),
      this.setCollection(r, v);
  }
  setCollection(r, p) {
    if (((this._docs = r), p && !(p instanceof FuseIndex)))
      throw new Error(INCORRECT_INDEX_TYPE);
    this._myIndex =
      p ||
      createIndex(this.options.keys, this._docs, {
        getFn: this.options.getFn,
        fieldNormWeight: this.options.fieldNormWeight,
      });
  }
  add(r) {
    isDefined(r) && (this._docs.push(r), this._myIndex.add(r));
  }
  remove(r = () => !1) {
    const p = [];
    for (let v = 0, $ = this._docs.length; v < $; v += 1) {
      const S = this._docs[v];
      r(S, v) && (this.removeAt(v), (v -= 1), ($ -= 1), p.push(S));
    }
    return p;
  }
  removeAt(r) {
    this._docs.splice(r, 1), this._myIndex.removeAt(r);
  }
  getIndex() {
    return this._myIndex;
  }
  search(r, { limit: p = -1 } = {}) {
    const {
      includeMatches: v,
      includeScore: $,
      shouldSort: S,
      sortFn: x,
      ignoreFieldNorm: I,
    } = this.options;
    let F = isString(r)
      ? isString(this._docs[0])
        ? this._searchStringList(r)
        : this._searchObjectList(r)
      : this._searchLogical(r);
    return (
      computeScore(F, { ignoreFieldNorm: I }),
      S && F.sort(x),
      isNumber(p) && p > -1 && (F = F.slice(0, p)),
      format(F, this._docs, { includeMatches: v, includeScore: $ })
    );
  }
  _searchStringList(r) {
    const p = createSearcher(r, this.options),
      { records: v } = this._myIndex,
      $ = [];
    return (
      v.forEach(({ v: S, i: x, n: I }) => {
        if (!isDefined(S)) return;
        const { isMatch: F, score: O, indices: L } = p.searchIn(S);
        F &&
          $.push({
            item: S,
            idx: x,
            matches: [{ score: O, value: S, norm: I, indices: L }],
          });
      }),
      $
    );
  }
  _searchLogical(r) {
    const p = parse(r, this.options),
      v = (I, F, O) => {
        if (!I.children) {
          const { keyId: U, searcher: j } = I,
            N = this._findMatches({
              key: this._keyStore.get(U),
              value: this._myIndex.getValueForItemAtKeyId(F, U),
              searcher: j,
            });
          return N && N.length ? [{ idx: O, item: F, matches: N }] : [];
        }
        const L = [];
        for (let U = 0, j = I.children.length; U < j; U += 1) {
          const N = I.children[U],
            q = v(N, F, O);
          if (q.length) L.push(...q);
          else if (I.operator === LogicalOperator.AND) return [];
        }
        return L;
      },
      $ = this._myIndex.records,
      S = {},
      x = [];
    return (
      $.forEach(({ $: I, i: F }) => {
        if (isDefined(I)) {
          let O = v(p, I, F);
          O.length &&
            (S[F] || ((S[F] = { idx: F, item: I, matches: [] }), x.push(S[F])),
            O.forEach(({ matches: L }) => {
              S[F].matches.push(...L);
            }));
        }
      }),
      x
    );
  }
  _searchObjectList(r) {
    const p = createSearcher(r, this.options),
      { keys: v, records: $ } = this._myIndex,
      S = [];
    return (
      $.forEach(({ $: x, i: I }) => {
        if (!isDefined(x)) return;
        let F = [];
        v.forEach((O, L) => {
          F.push(...this._findMatches({ key: O, value: x[L], searcher: p }));
        }),
          F.length && S.push({ idx: I, item: x, matches: F });
      }),
      S
    );
  }
  _findMatches({ key: r, value: p, searcher: v }) {
    if (!isDefined(p)) return [];
    let $ = [];
    if (isArray(p))
      p.forEach(({ v: S, i: x, n: I }) => {
        if (!isDefined(S)) return;
        const { isMatch: F, score: O, indices: L } = v.searchIn(S);
        F &&
          $.push({ score: O, key: r, value: S, idx: x, norm: I, indices: L });
      });
    else {
      const { v: S, n: x } = p,
        { isMatch: I, score: F, indices: O } = v.searchIn(S);
      I && $.push({ score: F, key: r, value: S, norm: x, indices: O });
    }
    return $;
  }
}
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
Fuse.parseQuery = parse;
register(ExtendedSearch);
const def = "./assets/unknown-41ebe866.svg";
function hotSwapAppIcon(k, r) {
  Log({
    msg: `Changing app icon for ${r} to ${k}`,
    source: "icon.ts: hotSwapAppIcon",
    level: LogLevel.info,
  });
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++)
    p[v].id == r &&
      (Originals$1[r] || (Originals$1[r] = `${getAppIcon(p[v])}`),
      (p[v].info.icon = k));
  WindowStore.set(p);
}
function getOriginalIcon(k) {
  return Originals$1[k];
}
function getAppIcon(k) {
  return k.info.builtin ? k.info.icon : def;
}
const Originals$1 = {};
function setTitleSuffix(k, r) {
  Log({
    msg: `Setting title suffix of ${r}`,
    source: "title.ts: setTitleSuffix",
    level: LogLevel.info,
  });
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++)
    p[v].id == r &&
      (Originals[r] || (Originals[r] = `${p[v].info.titleSuffix}`),
      (p[v].info.titleSuffix = k));
  WindowStore.set(p);
}
const Originals = {},
  currentSettingsPage = writable(null),
  currentCollapsibleT = writable(null);
function setSettingsPage(k) {
  Log({
    source: "apps/SettingsApp",
    level: LogLevel.info,
    msg: `Opening settings page '${k.name}'`,
  }),
    currentCollapsibleT.set(null),
    currentSettingsPage.set(k),
    hotSwapAppIcon(k.icon, "SettingsApp"),
    setTitleSuffix(` - ${k.name}`, "SettingsApp");
}
const accountIcon = "./assets/account-a7a14557.svg",
  appsIcon = "./assets/apps-5c65dab6.svg",
  desktopIcon = "./assets/desktop-2a5e3c36.svg",
  personalizationIcon = "./assets/personalization-61b4520f.svg",
  shellIcon = "./assets/taskbar-24d42588.svg",
  windowsIcon = "./assets/windows-2ef194f6.svg",
  about = "",
  dmMutators = [],
  dmProps = writable([]),
  DevModeOverride = writable(!1);
function updateDevModeProps() {
  dmProps.set([]);
  let k = [];
  for (let r = 0; r < dmMutators.length; r++) {
    const p = [],
      v = dmMutators[r],
      $ = get_store_value(dmMutators[r].store),
      S = v.fallback || "",
      x = v.value,
      I = v.suffix || "",
      F = $ ? `${x ? $[x] : $} ${I}` : `<${S}>`;
    p.push(v.caption, F), k.push(p);
  }
  dmProps.set(k);
}
const icon$3 = "./assets/errordialog-744772f4.svg",
  ErrorMessages = writable([]),
  ErrorWindowStore = writable([]);
function errorMessage(k, r, p, v, ...$) {
  Log({
    msg: `Generating "${k}"`,
    source: "errorlogic/main.ts: errorMessage",
    level: LogLevel.info,
  });
  const S = {
      title: k,
      message: r,
      opened: !1,
      buttons: $,
      id: Math.floor(Math.random() * 1e10),
      image: p,
      parentId: v,
    },
    x = get_store_value(ErrorMessages);
  x.push(S), ErrorMessages.set(x), createErrorAppData(S);
}
function closeError(k) {
  Log({
    msg: `Closing error ${k}`,
    source: "errorlogic/main.ts: closeError",
    level: LogLevel.info,
  });
  const r = get_store_value(ErrorWindowStore);
  for (let p = 0; p < r.length; p++)
    r[p].id == `error_${k}` &&
      ((r[p].opened = !1),
      setTimeout(() => {
        r.splice(p, 1), ErrorWindowStore.set(r);
      }, 500));
  ErrorWindowStore.set(r);
}
function openError(k) {
  Log({
    msg: `Opening error ${k}`,
    source: "errorlogic/main.ts: openError",
    level: LogLevel.info,
  });
  const r = get_store_value(ErrorWindowStore);
  for (let p = 0; p < r.length; p++)
    r[p].id == `error_${k}` && (r[p].opened = !0);
  ErrorWindowStore.set(r);
}
function createErrorAppData(k) {
  Log({
    msg: `Generating error appData for ${k.title}`,
    source: "errorlogic/main.ts: createErrorAppData",
    level: LogLevel.info,
  });
  const r = {
      info: {
        name: k.title,
        description: "ArcOS.Desktop.ErrorLogicwindow",
        builtin: !0,
        version: ArcOSVersion,
        author: "Generated by ArcOS",
        icon: k.image || icon$3,
      },
      size: { w: NaN, h: NaN },
      pos: { x: 60, y: 60 },
      minSize: { w: 200, h: NaN },
      maxSize: { w: 600, h: NaN },
      controls: { min: !1, max: !1, cls: !0 },
      state: {
        headless: !1,
        resizable: !1,
        windowState: { min: !1, max: !1, fll: !1 },
      },
      content: null,
      glass: !1,
      id: `error_${k.id}`,
      opened: !1,
      parentId: k.parentId,
    },
    p = get_store_value(ErrorWindowStore);
  p.push(r),
    ErrorWindowStore.set(p),
    setTimeout(() => {
      openError(k.id);
      const v = document.querySelector(`window#${r.id}`);
      if (!v)
        return Log({
          level: LogLevel.error,
          msg: `Can't bring window ${r.id} to front, no associated element could be found.`,
          source: "ErrorLogic: createErrorAppData",
        });
      maxZIndex.set(get_store_value(maxZIndex) + 1),
        (v.style.zIndex = `${get_store_value(maxZIndex)}`);
    }, 5);
}
function create_fragment$3K(k) {
  let r, p, v, $, S, x, I;
  const F = k[6].default,
    O = create_slot(F, k, k[5], null);
  return {
    c() {
      (r = element("section")),
        (p = element("h3")),
        (v = text(k[2])),
        ($ = space()),
        O && O.c(),
        attr(p, "class", "header"),
        toggle_class(r, "collapsible", k[1]),
        toggle_class(r, "collapsed", k[0]),
        toggle_class(r, "opt", k[3]);
    },
    m(L, U) {
      insert(L, r, U),
        append(r, p),
        append(p, v),
        append(r, $),
        O && O.m(r, null),
        (S = !0),
        x || ((I = listen(p, "click", k[4])), (x = !0));
    },
    p(L, [U]) {
      (!S || U & 4) && set_data(v, L[2]),
        O &&
          O.p &&
          (!S || U & 32) &&
          update_slot_base(
            O,
            F,
            L,
            L[5],
            S
              ? get_slot_changes(F, L[5], U, null)
              : get_all_dirty_from_scope(L[5]),
            null
          ),
        (!S || U & 2) && toggle_class(r, "collapsible", L[1]),
        (!S || U & 1) && toggle_class(r, "collapsed", L[0]),
        (!S || U & 8) && toggle_class(r, "opt", L[3]);
    },
    i(L) {
      S || (transition_in(O, L), (S = !0));
    },
    o(L) {
      transition_out(O, L), (S = !1);
    },
    d(L) {
      L && detach(r), O && O.d(L), (x = !1), I();
    },
  };
}
function instance$3x(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r,
    { collapsible: S = !1 } = r,
    { header: x } = r,
    { collapsed: I = !0 } = r,
    { opt: F = !1 } = r;
  currentCollapsibleT.subscribe((L) => {
    !L || !S || p(0, (I = x != L));
  });
  function O() {
    p(0, (I = !I)), I || currentCollapsibleT.set(x);
  }
  return (
    (k.$$set = (L) => {
      "collapsible" in L && p(1, (S = L.collapsible)),
        "header" in L && p(2, (x = L.header)),
        "collapsed" in L && p(0, (I = L.collapsed)),
        "opt" in L && p(3, (F = L.opt)),
        "$$scope" in L && p(5, ($ = L.$$scope));
    }),
    [I, S, x, F, O, $, v]
  );
}
class Section extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3x, create_fragment$3K, safe_not_equal, {
        collapsible: 1,
        header: 2,
        collapsed: 0,
        opt: 3,
      });
  }
}
function create_default_slot$8(k) {
  let r, p, v, $, S, x, I, F;
  return {
    c() {
      (r = text("The whole ArcOS project is licensed under GPLv3.")),
        (p = element("br")),
        (v = element("br")),
        ($ = text(`
    More information about the license and the project as a whole
    `)),
        (S = element("br")),
        (x = text(`
    can be found in the README file of the
    `)),
        (I = element("a")),
        (I.textContent = "ArcOS project page"),
        (F = text(".")),
        attr(I, "href", "https://github.com/IzK-ArcOS");
    },
    m(O, L) {
      insert(O, r, L),
        insert(O, p, L),
        insert(O, v, L),
        insert(O, $, L),
        insert(O, S, L),
        insert(O, x, L),
        insert(O, I, L),
        insert(O, F, L);
    },
    p: noop$1,
    d(O) {
      O && detach(r),
        O && detach(p),
        O && detach(v),
        O && detach($),
        O && detach(S),
        O && detach(x),
        O && detach(I),
        O && detach(F);
    },
  };
}
function create_fragment$3J(k) {
  let r, p, v, $, S, x, I, F, O, L;
  return (
    (O = new Section({
      props: {
        header: "License",
        $$slots: { default: [create_default_slot$8] },
        $$scope: { ctx: k },
      },
    })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          (v = element("div")),
          ($ = element("img")),
          (x = space()),
          (I = element("div")),
          (I.innerHTML = '<h1 class="name">ArcOS</h1>'),
          (F = space()),
          create_component(O.$$.fragment),
          src_url_equal($.src, (S = logo$c)) || attr($, "src", S),
          attr($, "alt", "ArcOS"),
          attr($, "class", "logo"),
          attr(I, "class", "text"),
          attr(p, "class", "product"),
          attr(r, "class", "about-page");
      },
      m(U, j) {
        insert(U, r, j),
          append(r, p),
          append(p, v),
          append(v, $),
          append(p, x),
          append(p, I),
          append(r, F),
          mount_component(O, r, null),
          (L = !0);
      },
      p(U, [j]) {
        const N = {};
        j & 16 && (N.$$scope = { dirty: j, ctx: U }), O.$set(N);
      },
      i(U) {
        L || (transition_in(O.$$.fragment, U), (L = !0));
      },
      o(U) {
        transition_out(O.$$.fragment, U), (L = !1);
      },
      d(U) {
        U && detach(r), destroy_component(O);
      },
    }
  );
}
function instance$3w(k, r, p) {
  return (
    component_subscribe(k, UserData, (v) => p(0, v)),
    component_subscribe(k, UserName, (v) => p(1, v)),
    []
  );
}
class About extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3w, create_fragment$3J, safe_not_equal, {});
  }
}
const account = "";
function create_fragment$3I(k) {
  let r, p, v, $, S, x, I, F, O, L;
  const U = k[3].default,
    j = create_slot(U, k, k[2], null);
  return {
    c() {
      (r = element("section")),
        (p = element("div")),
        (v = element("h3")),
        ($ = text(k[0])),
        (S = space()),
        (x = element("p")),
        (I = text(k[1])),
        (F = space()),
        (O = element("div")),
        j && j.c(),
        attr(v, "class", "header"),
        attr(x, "class", "context"),
        attr(O, "class", "opt-sel"),
        attr(r, "class", "opt");
    },
    m(N, q) {
      insert(N, r, q),
        append(r, p),
        append(p, v),
        append(v, $),
        append(p, S),
        append(p, x),
        append(x, I),
        append(r, F),
        append(r, O),
        j && j.m(O, null),
        (L = !0);
    },
    p(N, [q]) {
      (!L || q & 1) && set_data($, N[0]),
        (!L || q & 2) && set_data(I, N[1]),
        j &&
          j.p &&
          (!L || q & 4) &&
          update_slot_base(
            j,
            U,
            N,
            N[2],
            L
              ? get_slot_changes(U, N[2], q, null)
              : get_all_dirty_from_scope(N[2]),
            null
          );
    },
    i(N) {
      L || (transition_in(j, N), (L = !0));
    },
    o(N) {
      transition_out(j, N), (L = !1);
    },
    d(N) {
      N && detach(r), j && j.d(N);
    },
  };
}
function instance$3v(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r,
    { title: S } = r,
    { context: x } = r;
  return (
    (k.$$set = (I) => {
      "title" in I && p(0, (S = I.title)),
        "context" in I && p(1, (x = I.context)),
        "$$scope" in I && p(2, ($ = I.$$scope));
    }),
    [S, x, $, v]
  );
}
class OptionSection extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3v, create_fragment$3I, safe_not_equal, {
        title: 0,
        context: 1,
      });
  }
}
function create_default_slot_2$3(k) {
  let r, p, v;
  return {
    c() {
      (r = element("button")), (r.textContent = "Change...");
    },
    m($, S) {
      insert($, r, S), p || ((v = listen(r, "click", k[1])), (p = !0));
    },
    p: noop$1,
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_1$4(k) {
  let r, p, v;
  return {
    c() {
      (r = element("button")), (r.textContent = "Change...");
    },
    m($, S) {
      insert($, r, S), p || ((v = listen(r, "click", k[2])), (p = !0));
    },
    p: noop$1,
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot$7(k) {
  let r, p, v;
  return {
    c() {
      (r = element("button")), (r.textContent = "Delete account...");
    },
    m($, S) {
      insert($, r, S), p || ((v = listen(r, "click", k[0])), (p = !0));
    },
    p: noop$1,
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_fragment$3H(k) {
  let r, p, v, $, S, x;
  return (
    (r = new OptionSection({
      props: {
        title: "Change username",
        context: "Migrate your userdata to another username.",
        $$slots: { default: [create_default_slot_2$3] },
        $$scope: { ctx: k },
      },
    })),
    (v = new OptionSection({
      props: {
        title: "Change password",
        context: "Change the password you use to log in.",
        $$slots: { default: [create_default_slot_1$4] },
        $$scope: { ctx: k },
      },
    })),
    (S = new OptionSection({
      props: {
        title: "Delete account",
        context: "Delete your ArcOS account",
        $$slots: { default: [create_default_slot$7] },
        $$scope: { ctx: k },
      },
    })),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          create_component(v.$$.fragment),
          ($ = space()),
          create_component(S.$$.fragment);
      },
      m(I, F) {
        mount_component(r, I, F),
          insert(I, p, F),
          mount_component(v, I, F),
          insert(I, $, F),
          mount_component(S, I, F),
          (x = !0);
      },
      p(I, [F]) {
        const O = {};
        F & 8 && (O.$$scope = { dirty: F, ctx: I }), r.$set(O);
        const L = {};
        F & 8 && (L.$$scope = { dirty: F, ctx: I }), v.$set(L);
        const U = {};
        F & 8 && (U.$$scope = { dirty: F, ctx: I }), S.$set(U);
      },
      i(I) {
        x ||
          (transition_in(r.$$.fragment, I),
          transition_in(v.$$.fragment, I),
          transition_in(S.$$.fragment, I),
          (x = !0));
      },
      o(I) {
        transition_out(r.$$.fragment, I),
          transition_out(v.$$.fragment, I),
          transition_out(S.$$.fragment, I),
          (x = !1);
      },
      d(I) {
        destroy_component(r, I),
          I && detach(p),
          destroy_component(v, I),
          I && detach($),
          destroy_component(S, I);
      },
    }
  );
}
function instance$3u(k) {
  function r() {
    createOverlayableError(
      {
        title: "Delete ArcOS Account",
        message:
          "Are you sure you want to delete your ArcOS account? This will delete any and all user data associated with this account. These changes cannot be reverted.",
        image: warning,
        buttons: [
          { action: () => deleteUser(), caption: "Proceed" },
          { action: () => {}, caption: "Back to safety" },
        ],
      },
      "SettingsApp"
    );
  }
  function p() {
    showOverlay("changeUsername", "SettingsApp");
  }
  function v() {
    showOverlay("changePswd", "SettingsApp");
  }
  return [r, p, v];
}
class DangerZone extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3u, create_fragment$3H, safe_not_equal, {});
  }
}
const pfp1 = "./assets/1-ce0ed19a.png",
  pfp10 = "./assets/10-a17f4986.png",
  pfp11 = "./assets/11-0772df5b.png",
  pfp12 = "./assets/12-e9d77a32.png",
  pfp13 = "./assets/13-0dcda114.png",
  pfp14 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAALdElEQVR42uzRMREAIAwEsAcZ+LfCgg8GXKCi1yWxkLHPu0lWWjBTAgECECAAAQIQIAABAhAgAAECECAAAQIQIIDP3llHt5F8Wfh7Vd0tNMiWZcbQMC0zMzMz47/LzMzMvDvMzMw8GQyzKZYtVne99bF0frYTZeJkd8jWPecmZnjfg6o6Ktnjg5YIp0m1XQHvddDVGFDFVCrYxSW8hTx2qYCpVEG18X6RNoD3ItuD49P03P0gI3/+D0z+8u+y7Wd/jW0/t+xf+g0mfvcPGf7nfyPz2OMEs7MAYEy7Bf1/BN8WimTueZDsrXcT33tgJdtFHRgBz4AnYAUNLC6dpDI+ysInfSILn/wpVIaGQARU2xVwPsH38osM/e2/MPJnf0dq95vYahVrBLEWXbFp/m9BZKU1pd55m6Frr2bqT/+A3N234y3mQUwbwLkGX+oRfdfcTPbGOxo93hiKIrxglD2iOAAF0BZzwpE4dJDhq/+T8X/6G9Jv7QbVd58PbQCCilmxCSv07H6UvjvvQOohIkIF+APf8TVBxLcGjkeMYgAQWPc/QAOERCFdLz3PxD//NX0P34uplM8EoQ3Aq+TpPP4qg6/dxI4Hf5+pZ/6SQOdBBAGmBW6wylGBF41yp3FEcnaoGCGYm2b45v9h+Jar8RfmW0FoAwhKc2T3PMjIi1fTu/dh/GgBkwUABTqAnQ4M0AnsVMGwQYnBVCv0PX4/Y9f/K/HjR06F0AZQ6pnk4Cd8D2997k9z7OKvptqZQ7IKnqJARuHX6obfWfaf1yxfHwkogG58OescXa89z9gN/0zq0J5TIbSHcOQnyQ9eyv5P/sEVEPNXfSakfVBFgV0q/GRo+OZI6ERQAIQNSwAgve8tRm/6t+X/3wCkDWBViqhDjWVx4BL2fdGPMfdZnw0iALimI0A5F+n6ShAheXQ/o7f9Bx37dgPSBnCqxDnqHd2c+KZvoLx9EpzjvCSAyOksxJCYPsLIXf9Nx4E3QKQNoBWEysQos1/+RWgQsGGJQs3BUh3ma3CyBqUIIj1tLsRnjjB839WkDr/TGkL7LAjyn/nJK1Ugzp21zUhCMX01WCjDiWUfX/bREhwpNV5eqn8MhNKshBOHGHngmuX/D54GoQ3AKbVcH/lP+QT0bAdsRrGjdaS7Dk7BrWETOShHcLLaqIhatK4Sksf2MfzwdcROnlgHoQ0AUGsoXHUZYWfHmQ/WVJCUIt0RCmBpLQWqESzWkYoD9GMQOg6/xdDjN+MX8mshtAGIUyojQ9T7+5AzAWi2H7UKFiR2lr4WKZRDqLrVtwFd+15i4Lk7sNUyiNAG0FSUTlHry8K7AfAUADwgdTaqgCpSc1B36wZ/z5tPkd39MBKFANAGoKjnEaWTZw2qGMAA3QqWs0sVCRWiJgQRTFgj98oDdO97AQDaAARUkXp4ljIRxDZBZIAEoGf/2qq6ZnenIIJXKTD44p2kp/eCSLsF2XIZf3YekDPucrUmiAhigBRIDpANAgZQXf2SIsTy08sQ7iBYmgORrQtARQhOzBA7dgKVFsFqSquAA/EBAzKikAKUDUpAZBWaCOkTexjYfS+2XgFkawJgBcA0tlKEhIWUB2kfkhYCA0ZAFKqClgUTAwToBJlQ8DYCQQFAAE+AplEy+5+nZ9/ToG6LAlDFKxaQuEAmBtkYDCRgOAVjaRhNQi6BxnzcosV4YAIAkBGQMQXDRpZFgICRJgQAMGGV3FsP0TGzB0S25gyQMETWHq4ZwBOIW+gKYCiBTnUQJTtRNdgEiAd4INsUGXNgAd3ALBAB36xCEENQPMnAm/eu/I/I1gOgnoe2mr+6JnYxg4slcS6OeGBTIBbwQSYcMhlCUgEFlTVdR4GmBQAwTbhmFUp6di+5vY9gojqIbK0ZEKWSYC3r1BKIIQo7ULWYAGy6CcGC5CLMZBXpq0EsAgEARaDpNVqtMKEppefwc/S+8yS2WETFgMjWmAH1TDcuFmxomEYuQaQdACsQvE5WB3PcIX1VTH8BySw7VkJMFagDEahbX1YJ27AIINh6maFXbmf8un+g+9UXMLUqKmZzAxCg3ttL2NkJ6IY+I9RuItIAiAdeR8MmAAzgOSReRZJLmOAkVmYx9ROY2iwSFoAQUBBZXXE1ZRKO7uKbjP/X3zJ6w7+TPvQO4hyIbOIK6O6iMjyE6EYAKIqlbvuIbCcgIGBijWrwO8GmwcRBfBDPISZEtIZEFcSVEa0gJgIDWIGUB3ELACLoWBqvK6T32YeZvPqvGXzk5sZRNoDI5gPgEgmKu3ahxgLKRqT41IN+6okcamMAIIr4YBPgpRswvK6mO8EmIqzUMK7SAGIVfK/hlAe+ARQCg27vgrRPsDBL/5N3MnnbP5Dd/Ri2UkBFNtkqyBgKl15C2N0Fyoal4hHGe6llxql3DxIlOlHPBxUQAQNiBLEG8Q1m2VZCvGoRm5/Hzs1i5heQQhXqCiIAoEC3j06kUWtBlcTMQYYfv47xx/6TzuNvIi4Ckc1xQUNUKU1MULjwQjLPPolybkcMzovjkknwcphaDdkzjxSrqBUwFsQ0Amksag2IBWegatBIoFIDzzQtAIDAUAIWa7AUgggmqtN16FWShaPMb/9EZic/mVqiB9CPNgBUiZJJ5j7zs+h48zVsvQRyHg9NsR4u7UNWYG4RhDWbLgMiQPNlBESacHyE6JT1r0LMwmga3VtA1AEKIviVRfr3PkS6eJATU5/FYs9OVCygH907YqLK0qWXsvDxnwgAel4gG87GoNMDtGlavAyoUuoZ4fhFX0AYS4Pq6V8vE1D4+CuYu+TTqHYPNGGxAiS9sI+xt24kd+gRbFgG5KMLAFVcPMH0l34ZpYmp1Yw7HwUGemMterSsAe6opXs4dukXcWLnZzM7+SmoOfVkT0AUm64z/SlfyJ4v+WEOfso3MTv1SZQ6hwj9FF69yODBB8gdeRzR6CMMAEAd5ZExjn7NN1Lt6z//E0oBugLw5EywV4J/9MovZ3HoQtR6zGz7NPKDF7f8YsnCcTKzr1DtzDK37RM5dNXXsfeTvpt9l30rh7d/GdPDn0I1ngF0E9ySVGXx0ss57L6N4duuIX7yOKqGc1bcgm+gthaigkIlM8zRT/hy8mOXAAKqKy3o2M7Px6/lSS0dBOy6xMhMv8xC9iJK6SHUWGqJDNVED0tsB9XNdk9YWLj84znwLd9H/oLLUGuRc6kGBaw0vOZxqc4GLExdyYHP/nby45eCyDrwlY6BZQhfRDWZXR9UEWKVeXqWIRgXAYA2viaqm/eidmFqFwe+8fs58oVfT3FwArUeotqEoatuNbWdIs41Au8FLA3v4PBnfSMHP/tbKPWNnZHcUu82jm3/QsJYB+DWAeqa202sPPOe7oY/fE9fLwKqBPk50ofeouPomyTyx/DDAtbUER8ITMOx5uU+Y3EVQ/2wUMqOsjR1EYXRndTTXRu6+C3q6D32HIP778ELS2sCLhyd+HxOjH7mFgKwFgSChDX88hJ+aYGgkl/ZM1hC1EC6O05oA/K1gNBLU7OdhMkOnOcj6Dm0C0E0JHvsWQYOPoBfaxw/iDqWuibZd9G3EPppQLcQgFNgKAKAAKCoQi4bJ3IwN18F4RyD3gpCRGbmZQYO3E+sPI8AoZ9kz8XfRmEZhKjbHEcR5yxVBG2xGW4GXB3C/1WKimE+dwW1WIbckcdI5/fjjMW48P28Kd9WoWuCcqqfRPE4oo5Sx3Cr7G8DUAWU90BK5CVY6p4COFPw2wBQBXkv77hp+wmbWsnzDNneGAO55LIT9GXjxAKLCO+12gASccvwQIKh/iS+J8R8s/xygtHhFD3dMax9Tym0W1C97jg+U+H4dKXF/q3hj5Laf8it3YL+tz06FgAAAAAY5G89in2lkAAECECAAAQIQIAABAhAgAAEDAQgQAACBCBAAAHVjZKnIJJ7jgAAAABJRU5ErkJggg==",
  pfp15 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAO9UlEQVR42u3cBXAcy3YG4P8/3TMLlgwyM+g+vMz4mJn5FYeZizlUGIaiYFGYmZmTy2BfEDMvDXT3iXekzZPKtsC5Wj3YX2MxfnvO6d7RyPyDH1X0cuMIeukB9YB6QD2gryygXnpAPaAeUA+oB9QD6gH1gHqx2NOQiiKq7AFtCAkN6hw1AICNQVFoIdUDIjWEttA97/8HEiNPv3Zh4njaNMbCRCC/jKTsXuloCPd96G9P3faCejlz6+Xa7MDUixcmrlxcnj7sc5oIxirahnvM1Dnl2n2dD//NqTde1mYFUBKIHKzTNF6cPDZx+dLUS+frC32qsDHE7GVB2S7rqG7QoQQU0dwiiyhh4OzEwIWx1zeqcyOnxl+4NDt8plUrkd0fUl2voEIHPue9H/7rM7e/oI1C55qoEkoajygHkCzvn3753MTli/PjJ7JW94dUAdRNnXs+8Hdn73y2UzubZXX60BZSwWwcUujWkCqAuqpz17M3qh2QAAGFFgdZOFGVpO7VkLJfJjqqQZ3XoBSRKII1cL74eCV174ZUUUF7qxNU1WXqs5CnvpXkjcxlWj54sHrqGLzfYkgRydKuDqkCaA91VMHYQ3JXy1vLmWulxrUkrTemV6IjpwbufC2cA7ndIXWlGFIzA6/iTsrusU4Zk8P4z3/E6MtSX4q8k3IUHRuIbh8Mh1deap04UjkxgPz6RhQtKtBqYgntP7zQf2L2lgee6Aypc/WFflXYCJQvMyASHZ2/PXvXc9fXCW2dZ/8r/PovuqSlRkhQPZczGR0qP/HEyffe3XjsoeRG5xtUV6d5UHVCIoqgJW0EmqtDanzgwujrG31zo+fGL79mdui4SwzILxsgopgqvOu9/1jUTvUGUxm0uPJsWFrEseP0ToOHelhBHOnMqJtxp+Mzh0Pq5LrlEwEm0KfaaDWXEp/6yqFD0aGD8EZdFXmwpnbi/N+eOPVLK0PxP/7FT3pfJhXgXgMR6OhcuO+pG+i0QwESvOODptHQF55sF1Fwql7VqQD3v7XygW8+hWAIxfWyOKvLKz5paDWSowcA35p9fK7/7NH+c31ojGo6rulMyBrG1EUvqhp2ocV2rrPZbpAEPPr6+flvjCaHzcjLfmU+eB/69vPcoD37mogK5EpeZz/AMv/tH/BXf2RKJaWGo0fitz+8fFKenPuHxepjVZocStDSRIxK+cpACIYEwJsD6r5OJ4Q6wOHkeTk5aIBOPDRRBTo62j7aMZCIYpD7936sdqBv9k9+U0Ub45fTX31OP/7m5tmDNe/3RXFFg3YGlXOupEFoFXrzQN3XKdIh0LQtgo4GCYp2aASMQAMofEuTaSTjmoxLmLn7Uvb38T21WlSphEa9/M+Pv+GLH/x3WxYNAWsRUL3bFxTFx99M7B7qrGfaWCwEbYFChAz5nKaTbZd0Cm4ZmgPiEJUrevpM64nHq3E1McbX6nHldJ8Y+Hz9khWc6ytsdBdarCs6gELXygaMAWkTuJpm00jG2jT5AkIKALTFEQFKBeAefWTs8gsHarU4beLN71nsO2t8snFBp7q8T9fou19BBKF5yjve888X7nuys2ZtJ1ocWOsgsUCAa2g+jmQc6bhmc/BNQEHTRpHKuo/S1aLzqbl4cfnbvv3xoVf6q5X8jbcthsyQig1pA0H3YKPY0Ul4+7v+9dL9T2xDZ/1Yse0DQEiQTrXLJB3TdAa+BvWAtMmkBLAjEq7bmD6XY0ebx07VoQwtc90eyl0/0H2gdTqDD/6PNss30lk3VkyBItAMbqk9UJKx9uN8EZp11KKiy3TdceN0jDQzAEQU1wld1tdloGt1irlzXRQIJAIM4IuxMlPM2gnk8/AtAGtqrK6rL935gFfcKMrclcEuAt1Y50YL81RnrMzCNYBQoJiNYyVsa2oRqlQFqeQ2x79xeZUAwK4AXdtZ9NcszCmyOc0miw6aRmdhLmZtvHGs7CC01ABjMsRQZ0PGLY24CuT2daeC1um8818GH/zvonYIKa1bmKc6HbR47cK87thxKEzms9ZU/YUXjy4mB+9508qJs4lPZQsjIrQraB/RHSBFlvCOq7XzyNPaHKD1cHVNZ5FMtF3yzRfmmw+F6YrL5pb/9YnBP/unWxH0X/8n/ZbvevbEyabPNzcK6mPvq2QXWowaHG99+5ODD/23LjaQPaPp+E4W5puPKkKW5VHf/7w0WO335bJbWiz/8z+d/PjnrmhmbjyhSQbfBmq3mO5qBZEhz+TY6X957eu+LbxSRZ5Ckx0uzDcfDRpXuVSv5N5GMQJsqYKVegmBW7VYCCH2rhjSusvXB5HwOXXpebqJtTVISqDpFIti10ICNho4mvfvd65tpLmzJ060IKq6iSsI9a7sQwnc9QuoSEGWnlI9StGNw6UrEVver+9+11AUa71eunBp5ZFHxpEaUjfzYXC+osHs+gxSBYk8G8jzvlJ5CV2PiIYsuv2u2WMnWvPzlQsXlquVfKsJDVCdKwVvunHSnoTLK0l6qFSdUQcS3Q7hU3v8WOP4yXrIzJY6nXMd+4LSUlW5yy1G9d6k6REw/38uSXqzrUmqz8W1rAZsQ6dosbxPFYB2YR8Ugpo0OVEAKcAdf1UFDcVQQSiCCxpUBDd/z2vrqHP7VLv1u3lVZK1ToL+5G0RiyWoumc9sSG3FxEdjVK1vGopil9KuuD50q4KUQKt1srOuy053w/PP1Jav1Hwanho6Nzp3tO+gPvaBpdfd2/AtS+6WUZ73A12qIIJIkiNQQ3hs/yy4gpYLz9eWXmrEffLnT9/39CvnIuv8Ap/48TNf/PqXHnjznG/a3akjdXm/dutCcnIVKMSg29HcyZbz5nw+cE6enbr0zMi5A/uTcsX178/L/fyD3764NFsyUdBd8ZHcVdk1ICGy9ERwFTIHuG1XZPW8tF9Yjl4YO10uexiBMSqmVNF6q/TsMwMo+d25/ElcXgG70mKqgCDPDru8P45zDdsjIjQAwlK/5D5qZGVbAg1NwUEDibC4WMauRKGSd86WdaGCIMRVnSw/CMl0J1/SlsVUTLyPUQyKiBEa0rL92IiNFPqq4xAqIcTF2bJutRio3tk0OQxmALd/O9qyYWT7D/rjx5tejbFo0wjFUAxOn20g8NVhUVE1qkKTm9IibdP7KrvSYp12CUyS45B8R5VuImMVtPrIwxPPvHDcB2OiNkm9Fp+/sPL61y2E1MjNr2JUFQCkN7YJkyKUkubJhfk7ZqYebdQuGWnDdQMIUFVkyUkgx45CRLHJPQdft/Sxj17+0z8bTFoWwLnztc985nlrg88NqTstFoCAiuQSJaAP2YGlxVvnZx6Ynbl/aeHOpNWviiju1HqXgICkdRpUQHdqZKz4XB58eGLwlqWx8f2l2F8aXCpFfic6VG0fIt5ELUiKYNPW8cWp22enH5yfva+2MuhyocAYRHEAVNUA3QMiiVbrSIETsPOQ8Gl0ZCA5crwJZUjNdnQKFCFVxEmcQHxIq/Nzt6wsXkV5YH7urlbzoAaIabvEJd9xFBTpNlDa3itGhAdk+5tphQBKtg/vRPO134WSukWxMBibIsoQJKkfnhq5e2zkntHRuxfmLwqPHOg3/X0olVQ1hMDio8xeXkheAB3XUKI41dLWQKqgpQkiNYTY+zIQVpk2KxZATC5xCnGaVxYWzo6P3T4yfO/ExBtrKydCiK3NoyhVTC/X2ExL/dVKtVI2hqpQxZ4BqZJEnh31+T5rc9Xy1qAmhl9MVuJG+lilMrbv4FBwFfWWDNcsz6vFkuHqAWSNg1Njt40O3z08ctfc7KWkdYCEjdIobgmbgBSHJZnnfmG5Xm8k1Wp5X6VkjABQ3bsKyvNDWX7ARrXCawue5uxLS9MHnnvlFydn70iz6Yu3/O2jb/7Zctz0PuqsRDDGSdSEydWVlhZPjY/fOjx0z/jYrctLJ50vGeMim1Yqy2AxVgKDCEES2ml7IUMItUazlaSVclwtl6w1HaauzyDv4iQ9VN03D3CzYjN2ZWIkmZt+fuRnXx6/O/hx1fjx//7UwuLZj378+w2V4hglgOatAzOTrxsduWt4+O6ZqcFm86ACkc1slMalRNf2xAY3vjlUlXI1hGorybLMleKoXI6tMSRUu1pBwQVJk6OQ53DDKI3JmvXW/ESuR0an7gh+gYwB9O+fHnrpocf/5+P3v/nnV6ZeNzn1+pGhe8bGbltcOJPnZUoe2bRcWekUF0MQ7GDPrhCRgjHNcud9ZO1VKWs7TF0AAlQDstZJbHKHXkFKWlsh4MOh3B0QWfv+vI/KlZWnn/jQxPitE2O3NRoHg4o1qbGpjRJVaqAG0+kd7Di61vdtJ9J730rUWhNH5mq6BQQkrVOAxw2ikBAsfG4NJiY/6EPVsBlAXW0F42q1o1dLxkStUrleiFOVQc3aR+88JNdESa63EoIaQshyNUGtkavZbSASSJJj1/7WcHVYkEFswlLDlPgfl3/oysQPGFlW5boLPmmMMyYLgRqk+MBtlz83MKy3AICggQSFAhaFtPqCMVKEXbrKlUTSOgo1QFh3X1GNSRG12ivRwi0jw2966cW3zc7cGtnlENZk1t+0CrOOeP1bCSg7ngS18yZtB4SCIFikABAaEWvaENashrIattPNVayzmU6PBVcGoGrEpGJbUFNfvjA2+sjwK2+bmb6t1eqnSeJoyQdRYJVyPcE6EoJKLQhWFdYefenLCSmy+vOLFWOtMda0H1kxIqb9iEU2SHd5mV8HJMjTo6AzpXlolDROTk0+NDL0junJexrNA4pgTKNSWfQBwVswUKFY27V0HKCqof0vaKdBWMS0w8KiDRFZa420OURkFULAjQTrH+ue/82q6uq9jZOTYx80Eo0OfWhq8sF6fSAEGJOVyyuFC4OaoEGhGgqIVYrVB1AIMfJ/RWEKC1NUx+q8IEGuQSg6tFo8CtDO6/ll+3fzqgihfTgHkQAm7ec9Q/BB0cbQtTohSaEhCw+x0mmJ9gPXKVxTDvjSgCL2MvZmUAlrtRjMzrelrAhjAjQsIlyNyGpH8Nqm6BxYy0aFjR/1lQbUWdRBkVjkBps6haJDoDe2RvfTFaBrvPAVkd5/0dUD6gH1gHpAPaAeUC89oB5QD6gH1APqAfWAekC9/C8SKX7bqPpkgQAAAABJRU5ErkJggg==",
  pfp16 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAANoklEQVR42uzRQQ2AQBAEwdkLHgDvaEIGTywcqwJ4VCetoOq6jzPJ1s/o9ZZ+7fd8kkYEAIAAABAAAAIAQAAACAAA/RVAAKqS0c+nvbOAbmNJFuitnhmRSWbHYXzMzJ+ZmZmZmZmZmZlxH3OWHmM48QuaZFmsga7/t4/XXp9EcdZe1lyfFh/qq+rqqtMaKw5JBbzvMEI8t0Dt/v3w2KtkXj2HzNdTAe8TBFqvHGHmF/+E+D/eQu+JFj2vNujZf5rgZBk0FfDeQQBV6vtfYOZX/hR7+Axj+64hO7iTzOSnkw9upvBCmWBq4YNOgs8HA1apPfEM83/4T8SzJTbfdCeFoVFsVEdtC3/4NljMw0tvpQFE2wdBUgHvMWpPP8/8H/4j0bkSPWPjDO3cB8ag0QLR9Jtg5F78gatAQ3jpGRqeIdo6kC5BG0aE5guvU/rjfyaeLmF84yY/09MHqoCgUYVo9jGS2hH8wSsJMnvJvziNP10DSQWsHyOEx08x/8f/QnRqGhXI9RcpbtoG1oIqDgSNa0RzT2FbM/jD1xEko+RfOItXbq1LQipAhKRUofQX/0H74HEwIALF8S1kMzkII4gTsHZFQrhANPdWIMEfvQ6/Ysi9dA5pxh/QErzv/N5P+U6gjw8UBDRKKP/T/VTf9CRYBYEgm2PTnqvJ5XvAKqK6ShgiaFQF4+EP7AQbwvQpBEjGekAkjYBLQ2g88wqV/3ocjRMQUIWeviHy2R60HUIYQRQhYQhuRBDHYGOShQPYxjRecRcmUyRzeI7g5GK6BF1ylTs9R/kf3kSyUAHBYYwwMDCCnyi0W9BuOwFYEBMgmTyS70d6hiCfJYmnkZ5+vPHLMARkX5/HW1wzH6TbUI0SKv/7JK3Xj4JhmSDI0VccRwbHkNFJZHwzMjyBFIfcRJMtIEEGPAMIiAd+AS/ejixeQ9CoIn6NKmdQolTABTGG9iuHqT6wHxILgkMt9F55Cz1f9UP42/YgfUXIZMF4rIXQgzc4DEBBQ6LGfprhEUBSAasQwTaaVP77cVfpIiwjnqH/7k8kuOle1kQV4IIJVyRDT+4qwniaxFYBSQWsLrgOUH/by6xCwe8v0nflLSwThWijBpUSuriA1hahWUOjNiQxCOAHkM1hBkYxoztQXyAw+Pke8sFuauHLoDYVsPztrzXc0mMrdTCrv9DZ8W3kBkbQV5/DHn0NfeMIOnsGrZVxk24TMIAxqGfA83DD95G+YTJXfDhKm2j2oFu+gtEi/q6IuN8DBSAV0HrlMM0XD4CwGoF8o4H8wS8Qz5zBffNR8DzU98H3cMNzjxHrgQVVQBWtzGPnT2GGNyGVCnZ6Cj0RELQniW/eAka6vBAT3L6+/Pf/S/u1Y2DOc8Ow5OirNSBsgyosISii4FBdGe51RQCsRYyHN7wFbVex1RKiYJoh8eQA2pPt8jpADOGJ067hhnAeRgz5IO8mEZGVyU4SiOKlYsyNpeJs9b1EEVqeRhtVTL4Iibr3TKlO5sgcWNvlAqyl8fZXiOfKFxTgG5+sn+m844mdiOXJluXJXx4uSWt5BskUEBMsvx4cmVkqzqRLBYiQlKs0nn0VrLIaUCDjBfhegKIXlYiLiAii1dHg5LRa2FoJKfRisj0Qhu49b7aCPzUP0L0CwmMnCadOg3BBMl4GTwxrogqJPT8awhCMj9xyL9z1kZhte5Glz9BsExyeQVoRSDcKsJbmy4ew1QYI5yFLAowYLpHV+cHlhhAxPmbrbhgaRfZeCxjESYrxT5XwZquAdJkAEWy9Qev1Y6B0JOMH65ZLHDsRlObRqcMAyOR2JNcDrSa025hyDX9qDlS7T0A8UyI6dQ6k00cMgQkQhHVjPFDQE4chSZDBUcwVN2H2XofZcTlYwT8+i4QxSJctQeHUWZeEO2FE3C5oXXg+5t6Pw//GH8H/zp/BfMSngAjkCvif87UE3/yT+F/7Q5h91+KdmscsNgDpokrYWsI3zqBh5wRoEHzj8W6jCn39eJ/weci+qzmPXB6iCOIY2iGmVMWbrpCMD4B2QwQIaBQTnZ4GS0dEDEbWIUAE6jXs/gexzz6NfeoB7P3/jE4dAUBPTxH/zk8R/+L3oi++FdNo451dAO2aJUiwrTbx7AIIF0QBIwZjDLqemYlCkv/6O+Jf/j7i3/xR4j/8eexzTy1Hn77yDHrgRWg0oB3hnStDnADdEgGNJrZSozNOwMYSsE2g2YAwhDhCZ6fBWqRvAAaGQAyoQhxj5ipIlIB0SwQ0WthmC+RiAsSNDSHiBgoszjsRZPNIb//qxl61ibQjQLojCdtm2yXgiyNsGOOBAIiLBpIYfB96+8HzQASwrhqWKOmOXZAIaByjSbLG5wRB1r8NveujMVffDAKowuAIBBknxXz8Z2NuvBMtz2Pf9M9IVIc4AQG0CyIABfS99P1Xhb4BvE/8XGTv1VwIJ+YdIwrRN47Dy4+D1S6qAwQQ2aCjDghQr2L3P4Sp10AABfI9yK7LwffRU8ehNIMuzKPHXkeNASPdIUAVTCZAfG+Nz61XgeC2of/5tyQP/CsIYC1m95X43/PzUOgj+d9/wD7232AttFowOYgGHmiXRIDkckgm4GIoiqpubBvaqC0/VhuD8dxjKmUXJXgeAJrPQOB3RwSgiunJYQp5UEA6fcyi6MYzvkOQQh/4PiRL9YEIIIDF9ubQrA9odzTjTD6HN9AH2nkZt2o3FgGqK/dqXWLGDyBsoZXyyvsIdrgPDfwu6QWpIrks/tggCB2xqk7Curainoe5/SPwvvRb8T7nqzGf+PmYm+4Cz0ejCBkYRIbHQAQ8cY04PAN0Sw4IfIItE2AuJsCSaLI+wb0DeJ/+Jci+awBWnX6Q4jDeN/4wTJ8h+fNfIznxGsmmQRC6JAIAjJDZPolks6CdBcR2HQIEtFnHPvMUevhVt+XUxRLLiDgJsnMfjExgBwrYiWI3dUMBhWDrJvyhftDOu6AoiViXgbBN8m9/TvTT30b8E9/kvuk062At9pH/cN3R+Pd/Fn3hLcTbRrHFAqh2kwDFHxkk2L75onVAmETr3wnFMSyW0Okz7kgK+QLUKySP/Cf2v/7WidBmlfiySTQTAHSXAFPIkb9yN3jSsRIOk9CJ2BCFXuTaW8F46KkT6Jk3wPNBDLbYQ7x3AqRLzwXlrt6L1995O9pOQqxaNoLkC8jIBAD2lWegWgYRUIh2T5CMF0G1CwWoktmxmezebR0FhHFIbOMNSdbaoms9JP/+lyvtBwXNBkTX70BzASjdKcD0Fijceg0SeBcsxmIbuzwgCOsmjrGP/hfJX/wmbvkRAVWSLUNEl02CAnTt6WjI33gV/qZRsJxHogmtuMV7BLUggsM3hDfvxg72gGoXC7BKMDlG4dZrQS68E2pEDdTGsI7uaKeji8lEkfCGnSACdPkvZCTw6b33ZuqPv91dCQtZPV/NwMfuuRJvYR6tliEKV/VxEOhgDxwKCPgB9PQh45sI79tJMtYPqqkA1JLds43C7ddR+a/HzssDLV+IP++ryQ5NuLM9evIYeu4UujAHtUVoNdE4Aqsrla7vQzaHm/DiMO53xVt2Ilt3E43laHvPA3U+EHjHP/E5DUzy/sQYWq8dYfqnfp94Zh6EZcTPsOf7fpfxT/mKZWGEIbRbaKsBzbp7jLXLAshkXeEluR7I5SGTAeOhJFQab6HRPoAjFbCCJgmlP/s3yv/4JlBdlTsnPvUr2P19v4MJsmyEVjTFYv1JrLYAgfRaEatzQf/H3k1251awrKL67OO03/SP6IGX0Nmz0Kgt5QJ78YQbR7gImZshPnuIeuOlTpOfRoBDcNeKmP+dv8O22iArp+R2je5heGQrDAy6Y+YMjiD9RbfOk80jmQwgaBRC2IJ6DZe0F+ZcN7Rx704ad+8EoTPpNePE7YhaLx6k+vBbVrWmF+slBv0epFxaPmgLAvLOYUAAq4CCWlAFq4Q37qJ17TgYAdVUwMWr4x6Kn/1xtI+dIvz/gcFRbVdpJSGFII+iFy60lBXELFW8gzQ/5RZc0WWVtUgv2GQtmd1bGfz8T8Ab6AXF0Y5DKu0Kil6yTO3N0fykm4h3jnWY/FRAR3ruupH+T/0Il5xRsCilZpnIxqyJAoFH86OuIbxlNwjvFqkAVSQTUPy0j6T3I24DI4hCPaxTbVXXbs4ZoX3HZbQ/6lrUCUwFrC8fDPQy9CWfSs/t1wNCYi1zzdKaLer2dVupffINxD0+1saoJqhaQAFNBVwyVvHHhxn+6s+icPNVCLgIWGxVOkiD+r4iZz9xC4v5BeqN0zRa52i2Z2lH87SjMlFcI0maWI2cGND0spUXRXGHuHKX73Q/a2qfOkuUxBRz/XjG412p7Rtg+lN3EY7nUbVugAWxgAIWRUGWXudd+kdIGgEdUSXYOsHIN34+/R93D3UJma3OoqqIAgKVK4uc+bQdtCYKoCCACMjyH4DAEoqCrtQLoKmAS1uOPpuhr/gMFrf0UsklNEeynLtzhJOfso3WaA5UAVBAFRRlZXq1wzF5N9JWxCUhAtYSz5dhsUaSSaj3JiQmAbVLhbHBvHMYDyO+uxfxlx77y49FPEDSXtD6f4CnqCpoglULKKoWlhAEWfqsYICl50jajHvvIuDQ9B84vH9QziMtxFJSAamAlFRAKiAlFZAKSEkFpAJS/g9M6LHIZJg5/AAAAABJRU5ErkJggg==",
  pfp17 = "./assets/17-662a7167.png",
  pfp18 = "./assets/18-240e69f8.png",
  pfp19 = "./assets/19-42714701.png",
  pfp2 = "./assets/2-73afb162.png",
  pfp20 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAOI0lEQVR42uychZPcSJaHv5eiwgYzz5hxGJeZmXkDjinwmIPv/oNjZr5bZmYettfUbWpjQ3FJyne9itqtCnVry/b2gOz6RWQolI31vkeZAtFfeaHydGmkWcPTqpFGAEYAniKNAIw0AjACMNIIwAjASCMAIwAjjQCMAIw0AjACMJJL3qQMkQUEREYRsOLygfHsoVVDZ+tewjWb+wBURxGwUtIDgj1oMkMjim9hdvz9BEcP4zQX8C6dITj1BBJ1kbDTgyIjANclAR0TmFw+DSke9eBFyMWI0uFv0Ljt+ajr09z/IMH0YxROPopZhGI6TRAzAnBdimM0UkRZRhGl1ucJp3cTrt3K+Bf/E6ylcfsiCMfjyqt+htKjXyI4cwR34TLSbV01iBEABVQh6kInREmnEgXAX/gOtruWxu4X4p87hn9hmrGv/B+2UE48X72AK6/+Wca++gH8mRM49TnQGJARgGWNjoJj0JKLTgbE6x206qLGA+Ni44i4VQMsgsUUY9zWI1QO15l/3luofPczFA9/HdOqU37o88TVSUyrQXfdNmp3v5TJT/wd7twFxMYjAIOGR0DHfeyWCvbWKnZjOTnXggNGAAEBG7YJQ0AtAFRB7rOorWErM7TCbSAxhemHkVaUeHzpsS/R3bgzgVK/5+UJgOo3PgKqT0vr+vTflpIyfOLp+1ctjkns2gJ4BhBA08U3AdCtXQK1LJVDJ3gNROOUpj9AcOQs3lQD01RAUdejdt+r0KCId+EUhZMPY5o1ELkJb0tRkjQT3buO7lt3Eb5oM3ZTGVzTz//KNSrG734GR75Nffe7qb3oXhovnSDcHqCuQaKIsa99EP/sUWr3v4pwzRYw5iZciCnYjSXCV99C+NIt2A0lkJVZQInO48RTuOHDxP5mmjtfT+PFa2jfX8RWDFhLMPUY45/9F+q3vYDmvgdB9SYCIBDvnSB8/XbiA5PgmhU2gEG0jhd+HmPnsDJJt3IHzbt20XxBlXiNh2m38GdO4rRqxJWJxTF5kwAQiA+uJnzlNuz6EihPogQ3+hZ+92NE7r1E3u10t08uQhgj2uRj2g3GvvK/dDdsX6wLr0RF8g9guPFXEb5kCzoePEVhbzF2lqDzP0BEx38b4cZVNJ9bJl7nYTotSr2WNVq18QYGoBDvGCd80RZ0zB9u/BWHcDapC0YvEzmHCDdsofnsMnYMghOPJi1q49BzQeQGBKBg1xWJXrgZnQiepp1KgxMfxQ2/SuTeRWz2EG2u0rq3gjhdyg99Fqc+jy1WQPUGAqCgBYfo2RuSrgdVnj5JLx39J2om6PivobuzQnePi2nVaB54Nt0NO4AbCYBAfGAV8b5JEFZAwk+mGGPPYeIzQJeweBet2zdBaY7ikW/izF8C5AbZilDQ1QWie9eCb0BXwKgiIAYRQVW4emmqO/o2orN0gjfCJNgHW3SD+3EXLuFdOgVI/gFgILp9Fbqu0E89CkgKUnsGbZ2/SucXbBgS12ugynBDKYiDlNcjbpG+BCc+Q6H9r0TuHbTX76H80KeTCzlI7iOgX3jj/RO9E7vUGUVAFTv3BPbKQz86B/2xgWEjsA2LKsOJCSAuzsZ7kUoJsPTVxdgzuJHFsSdxvIcx4SyogOQdgIF43zg64YK1y6cClR6cGNQCAequAXGAbKkoGijosOLThOgKYMFaUAvokig08VmIzxBtFMJNPv7xbs4jQEEnfOzuCmBBs/K99odabPEg3fV/CKYK6LDrNEPkILVvIif/AGwTVEFtdioE1BfCHT7eqRCJNN8RYLeV0Mme96MZxVZ6gDQZasaxwV5whvfiyHAAhFcAD1SXAgBIF3FRog0O8aSDeyECySsA3xDvKIMD0gv7bMspYhVREFWEGO3/zPXfJyTSN7iCaB909i8RbBGizQ7uxSinEaBgJz10gw82ThU0TQWD9OZ688qKSwZBLwGbykYKKkK0yUEfF6Sj+YwA3RSgRQFr0442YPQlXvrkSOkNXaYeaQoSCEI8KcTjBvd8DJI3AK5gFwHgaA+ApG0/MKeg9qoiwBjTv37bO6oqIoK19uoAZNejvlRRH+K1sgggbylIQcsOdk2v+KYLqcogiN65BbIjQETodLscmz5DsRDQbLUpFQu02h0qpSK1RpNdt2yh4PtYVbIhaH8ASDYIBOI1BnVB4rwBmHChbLJ7f9JRkF0DVJVavcGluXn++UMfZ+uGdUydneHWTRs5NXN+0fBbOXxiip9+2xuYHKtSrZQxIlkR0B+pxL+c4gnQgiB1BckLAAFd5aCegsbZvX86J9kBANr3/G4Y8g8f+CjVcpn3vO6VlAoBi56fREK706FULPLgHQf53hPf5+jUKX7+XW+mUiqhfSOnAKSKsGZ9CLBFxVbA1PMUAQ7YVQ7IYPoRYMhCTH84ABEU5RsPPc7lRc/ft+PWxLv377yl/7MDtUCMEMWWcrHAV7/7SJKeHrj9EMYBILUGSKdFAdHlF2Uu2DFgJk8APEHHDagFqymbZ8HQ3qB/VJg+O8PMpctJeikEfmJkAUT6EFQVtXBg13b2bN/GP/zvR/A8l/tvP7jUy1WXB7DcskBIRlwlR12QggYCJUAtoiwxKiJLG0BdvgYsGj3xaiApvB/4zBfYvmXzonEP0Ot+ktTz0OGjvP4lz08K8mJqwnPdIV0QaYsv/f8sYMCWFXVA4pxEgBYM+IrYuB/WOuhl9kfzMgBA7A8GiPaLo6KoKgBWlXqzRbfbZVDdMEzm1dqBbKNIyviSDAUd0usqDEaGFgFHIBcAFCiAOgP9tsrSNlQULAAgqQhg0LgR7cTgJN79/je+GiMCA2nonoP7uWv/XlzXIY5tAkjVHfxVfahWkQEAw5fzoJ4kQzqAPNMBCBAAYkGFVGXLWAtoVgpK0k+1XGKuViPo+Fhrk/TSDcPkGEZRcoziGNdx6HTDpCvyfRdZNgVZ0PgadvQUHEFdASQnKcgbBABgsz+wDkbA0pS8UG9w7uJl/vmDHyfwPWbna+y5dStHTp5i68b1TJ09x7aNGzg9cyE5P3fhUlI3Vo2PocMWYsJVgVCj4Dp5akMV1C7T5WT320AqBSkIHNi5nU3r1mCMwXWcpP9fPTnOutWrGK9WEuOPV8vcunljcr59y6YkFRWDACOyfKelNqP/z/4f1Wh+ImDwQw5fhGXvhgrCoT07kcFgGXoc5KnLpCCArAhIw0qlytxEgCponDJ8JowMAAZEltRlHXoclPTHYA1I784KqXNN702Dao4AxIBVMAqaYXzJSA0KxA2kew7isWHdynC7iAPtC2CjjK0IAc24MGDpHQWx5AeAdBVsyicF0BQEBSS1EMPg1B6m8PjPgfF/LAAbQ9SGoQzCeQhrgx1XZsyALJmWGIhyBICOIrHtG5fBay+pVlOlZ39FevMSt3AajwGgQyJNmoAyXCKA6UdA5m8Xlih0kFByFAEtoGvBTXlSpkUFUTDlCcSYq73km0C2fohqRlFPSwzG85FUg6BD/qLpGCSSHG1Ht0HaihYtaPZOaCo0kOIYUhhLtS0ABmTpz0sUEXtNUJuFaPkptf3oG2pXxTQMkpsUJCAdQRYUnbCgw4wiy1RTBfEg2AAIdGfAhiAp7152axnwxsEpQTgHcQtIX4HTflqywxfCpmbA5igFEYHMCmyx13eHs3jI2jcujjcDBr38QfT8v4DtDBhTlgdQ2YPZ8BrwJtDGcXTmA9C9ktHtKED2DWMCEgnOggNKjlKQglwyEAKuki1dfq6wDVn7NihsBUDWvgWd/wokhdkB6EcAtr+4Mj6y+tlQ3glqkYm7oHkCvfhZEGH4qnwpCGm5mAU3f7elyKyDLBh0dQx6jYs4HBB3gKaL4KCqIAoMbqyl210vlQ8dQEGzoGdwEQUFZ9bFtA1Inh7QEJCWYGYcUK5NItA5jV75CIRXkjyuVz6Otk+AGBiUKSDi9RcUtguzX4f2DNg21I+gC49eJfil5xIJ7oUAYsnhEzIWzGk3AYFcIz3bRs/9DXr01xbHr6Nn/hTixkD+d5BVL0O2/w6y9X1Q2t632/z3sCf/Aj3x59jpvyeBgVyXE5kFD/eKn+N3RTgQ3dvG7g5Buf4NPTGA9PN+5QBm5x9hTZXwBwZfHDr9NxDVBveVfrI3ZFmh8NgY/lQ5x++KiMA55iH168mhAuIkI71uEG89eKtAY0CRYA04xdTPmus3voA76+PNFEHz/JCegFx2MEc9iFkZiaCtY9A8CiKoxmj9KIQLK7iOMfjHy0hSfPMMAMCSADBn3BX6MCYp0nbqj9Ezf4me/Q905oNg2yvTqMeCf7KMeykAAcg1gH5H5DwUIBedlftQzSfQc/8AFz8F4Swr9Yu9s8UEAPZGelJeQGYN7rcC5NJKQZBkKLJyxj9XJDhcRboZZsn5g9pJBLhfDzDnHJ4xEsAK/nSJ4LExTMsBIecAhhRl52sFzPc9CAXkaTV+YvDC4SrBE9nGzz+ANISawf12gPv1AnLBAQvIU/w/RJKknOJ3JvFPVJDQgNws744WIBLMCRf3i8VFGD0QkYA8STCkd+ga3JkChYcmKHxvHOeyD3qzvrhVQBqCHPaQKRddG2M3ReiaGC0reJqGkf2gZdacJfFu03CTbQX3YoCZ95K5DNg38WsrARzQoqJjMTpp0TELFYsWEiCoCwhgwEYxYaMFqqCAFSSWxLjScTCNxVF3cRa8BIB0DSggPFM0+8wBkOXlDuAq6in49CAoGEAVG8egQNw3PpEgkUnOsQCA8P/t3QEGACAMQNFF9z9mAHWEAiDIION9doIHDNsdgCTKSy0qNCudr8/ng4YAABAAAAIAQAAACAAAAQCgfmaEfu131wYAeAuzlsd+jwAAAABJRU5ErkJggg==",
  pfp21 = "./assets/21-6ad724fd.png",
  pfp22 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAK60lEQVR42u2c9Vsbe9rG++v7rrsbrvVUca2gdcEtuFuBc07d3V3gCO6aAPGECe6QhHq7S/+KvadTo8bMwByydK7rwXU+1/3oVxaIYjt4+4zxgHhAPCAeEA+IB8QD4gHxgHjjAfGAeEDsjAfEAxJSxgOaQoQQxRCieE1rsrI1VdGaJm9NUYoT1K8+L/xSAVFoQER+qIG4+21P/eUB+akh4tgQcXRQebK36aL223uK47VtGbKX30x8YYCEBJ5cc60YLMYn8g3/zpqYzDTA/kMa3pkg38/SPcwb0h4l7hW257YD6JcBSNghjtcoT1UPao7rn+aABUAA0McNXwKv59nDvYc0V0rESSqQndeAhAQCjfa7u+MTBXhyIKBp+Gb9oz09NVfbMqUko/kJSNjRmqLorroG4TCj80ZNz7P6W8+1Z0vAaB4CEiequ0pvgQ7lU6ytT3QBmQ6M5hsg9ZUS3cM9lHZmYvpn2Z3FtxHI5hEgISEpEI8MHJg5HSoejRsKUAGQIpongOI0XRU3GCCgwahfcgb15P8iIEI81Sj5jI7spSEfBgFb9yBPebKGLLWNHxAJIk7bGqdtEarro6U1keLKiOaK8Ca8rooQ1UZK1LcKUcswQUBLRMj60KYxAyK54J3qSPGtnfcO+exPd4uNXLNlh8AzcImD3+LV/ovXbFnqGukU0Fyden8ya9YBjfQeosoiYwQENI0x8ts7i/K80ncKvL3tFjlbmTlY/AvmSJoJZQ7m//JdYyPTCCcmZ11BWbr7+fKDDcYGiEKjuLb9ZrxT8Hr7JY6WJiCC106Wph+ag7lJkM+y3tHkCbL2mWXTP8lRXywTxRgRIDLofhdcnuoaA8l8kstUQLG7Vg8aUrkAhLjWcfu7FiMBBDRNMcrTgac3L3UGl2nRvAGUFLZ2+H4aF4BgaPSNQkGgUxfVnu+d6WlrD+HQQUOZg5lJhtBp5GG6gRtAmBnNPSBxHIE8BbdytbKghEPf1pqZ7M/z0j/nhA5GJd1V1+c4zUM7NVFtKa5RzlbmTgzpwFxszG5d33L/RTZHgDBvI+tp4ZwBIpCwcjxTXKwsWNBBmg9wtJeqGOR4ppl+XP+VbH8TMv2cKeio32EPGxvKsxgDMjcpyHAfe5yBh+HOuspvop6eA0Cod+7u+g4FMaIyOzqBTvai9qj7zOXDqJ4eG/tGdrBx5iJawDhtRUuEjrtY0rEw9VhocfViIPPwzIbRgOz0zHuOBUzlcybwtLuNDavQY+pqa35k73pkd/blD8OKEatGWEECI+4BUZkrsjVklR87+cDy09wG9KiemToXe8MkF/NcTHU5B0TJ59zm8yzlY24Ss32Vtj+BfeZi3bs+2oOFth8DEFJ7vFMI+nIWed3fwa6hKZyTwEwjGI0O72Od9RfQr5u/D6n0XbSSRWp3sTY7c9xX/5z25JADRlgXokpHrgBhMHgy4LirlSVTOuhLwzcJOgcSqdAzV6Z/nKu+VAoRcQUIY9MM9zjG/mVh6mZnfufWVgahhzMRDXUcI7c8CDkARHXtyF8AxFg+gYKe4WRO5cNgkHaZFBEngMrDGgIWr0W4ZQQI89YLp/05rnoYNLED0tPYBMABoDhtUVDJOjtykMo0eUmUMVwnLwZNrKGAUf/BANCNHXe8bO0BiNFULDnCYfgBNTY0FtMW3Zt9QEhhV7Zd97SxY5rjz53y414+zLwMS6/YTzT3gNB5eS2xrKoJYTwV475obM9ph4i4cLGFTACRYw1VZxz3CZ7x2rT8SP3sAyoKKqVWu+gn+LCA5X1jKUYVgKj2Fckei0KznebDGwOWOEAX9CN0UrgD+4UdLk1bWDj7gOqiJKGr/VEo0geUk+hCzlWNDBDCUFfJrVl2MVhLrCbTPYERoPx09/Gn3DeoLBaFKm5w0qyeCjzpam3JAFAaAGUYIaAuAOJi3FEcWu23eBXCEE1A2Qkuo0bpYp0lt2ffxWBYg090Dse8lWYWSwxdOzTzII0uF4XCi5yXr8n3YTOETtwrQpDmZOR6ccslDxtbjFzpAArxndEGF4DQP8kY644ZrNrSe92754J77zWvgfJNo9oo/aN0EhPrnv5SKTeAYonaqLbw1YEI1TQ7VQURy6ZQhGqeZgy37tbmCxR+f5Y6/lKy8mcSwU8kK34qdfilfOMfiawlQ4079I/T8Z1stlcdauDExSgRnd98HiJCxThtq+G5yLK8PAitBlM6On1yzxlXuffvJct/IhHAfgo0r0wA+wk+L3P/TdehteOjCcwYodUY3N+eJeEIEIxoiJYlOIUAEB0RnTriw2xUBjq6JAhHsvrnlGQ+YSQmyIpIWzQ+FM+A0SQ5nBYnsm9W6c6GAsmq+l/ThqG4oDWDBrpxGvqH13QdcZCs+hmlGjoGmrr7qXTD9vNsnEFjPu5gbicDTnjaTtPcw8t8VtmI2iLpTjwmswert8hcf01ph5YJyKjUX+QDQLS24uu+ku1r5h7Qy213Bd5ZqBun9bWThzbSDZ+GFE2cjWQ5SYe+4ftVQaZ0ghH8qw/+RQ2DuFYQ1Z2h+XD57PYyeNmu9UuJPhoLqpPZw6JdMrffvJEPIxENVmyeNvFj5Ud1vgJb8zgGNCXrt2d5JLpZW4HRZzaTXT4fiDA0LaCei+5vQg9TEXUdXmt4Po1/kdvOyPNSP+4mzvpo2d4N+evsFn8qZmNVfue6JZicTROJnmaQyWvZ/7MD1JFkr3+Y9qlIRB1zVZ2t5GDhkAajZqHqwpaL25d7AsenpHSwwHv8ScZnHkD/KI1IXYRHZQdIHWmhMyR/5vf3Nl6iog8HgOhhKgmtyfZI2mC/DOXPVExkOlsvsC4t3Y1I9GlA6UTGYtYK0kRb6SZSPg4Ipzf6D0q/EkE+c3sUgZQSTmmkukb7LFxBRuh3ttzD0YI2LpOphZ9xtK4Da9gBwk8RWUtRQ32UDnoLxGbQMZbDLE1CJSrJvevzQlf5bbBfiv0OIEWa+b8Sw9ZoB5DRPgboRU5/oQ8KaBaAYD0XPZDmP1Z55mqLCqlzmlwCYo6JWs4v3F18IuB4rmdqnFNQ8EpfnIg6lRs8osv5SFKbzEabrvD9E/M0/xOZ5+9GJCFUmp9CB9vLym6SoUdo3AfqqM1XqAmqI8Q1USLV5eJx3dcQ/4eJjPQyAeNCkcheihgPIu96FrSDzXdYiafocACIA16UieI6lGeqRvrJs7wfiki59e94Zvp0FD5/GpFS8plyupe4WwTtcLQNmHsTEuiJBqRn9M9y3sUEFQxWbqYGHXToyFx/01/k++6P4/VwzyHVmUrsIuf+KALHjFDXEoWFWAsmH+wNpueZAyWBCt8/k4wEn4o7JB1w7LuzUf+ULK9Ig3Am8nFgVZLXSgpnXpybJ19Lv2nprr42Nv415R2vVNAe3JFsL3X+FYmJJPXKqA8xY9QIrYeadoCmYfJlLn+Q3992TnGihrpgaJ7d3UEgDcPjOktuwTuwaxcPPPEiS38/Zah2a+felaogE/mGP8i9fidf/wfVzn9q85cPVmzSGRLxPchTEGBP3RXcJyAm4zExj6/HIfAaJweUp6uRmweUJ0dH9ukeFuge5oyPpYz1xo4SUWM9sePDKeOG3DHd3iHiOLxJfamsfU8b+OLHv5QLlqhxBLbs4vIkTNdRBGuuFxN3vod13CxWXyxXHK2T5LcifiEM45spNF/oHWYUr5Z3jCICm8d3mPHXBPKAeEC88YB4QDwgHhAPiAfEA+IB8fZfZ/srY3Y0xdYAAAAASUVORK5CYII=",
  pfp23 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAC31BMVEXu7u7v7+/w8PDy8vL09PT19fX39/f4+Pjx8fH7+/v9/f3+/v7////29vb8/Pz6+vr5+fnz8/P//v7/+Pb/7+r/4Nf/0cP/xrT/vqv/u6b//Pv/7un/0sT/spv/mHj/glv/eE7/c0j/b0P/bUD/bD//9vP/1sn/qpD/hmD/bD7/az3/9fL/y7v/lnb/dUv/az7/+vn/08b/lnX/ckf/6uP/d03/bT///fz/1Mf/i2f/+ff/wKz/elH/9/T/s5z/r5b/cUX/+fj//f3/+/n/ckb/imb/pIj/kG3/noH/iGT/xbT/x7X/fVX/8u7/+vj/7Ob/wK3/hWD/bkH/m3z/5t//v6z/cET/uaT/49r/l3j/bUH/nH3/knD/jmr/mHn/jGn/6OH/wa3/b0L/vKf/5t7/59//gFn/flb/5Nz/zr//dkz/0sP/pYr/ooX/n4H/oob/eVD/3NH/5d7/2Mz/ybj/3tT/2c7/eE//8e3/sJj/f1j/dkv/glz/t6H/9PD/7+n/iGP/7ej/van/h2L/g13/tqD/+PX/mXr/cEP/xLH/p4z/qI3/uaP/rZP/rJL/9/X/wa7/fFP/xLL/r5f/6uT/6eL/dEj/yLf/4dj/elL/jmv/8Oz/vqr/xbP/w7H/dEn/j2z/8+//oYX/+/r/yrr///7/qo//zb7/oIL//v3/rZT/0MH/o4f/sJf/rpX/9PH/tJ3/e1L/zLz/f1f/tZ//3NL/qY//hV//qI7//Pz/eU//u6f/k3L/z8D/8Ov/3tP/0ML/3dP/lHT/kW//uKL/sZn/p4v/dEr/fFT/dUr/iWX/pYn/lXX/lHP/q5H/6+X/gVv/xrX/08X/jWr/noD/oIP/jGj/c0n/nX//nH7/0sX/l3f/2s7/4Nb/4df/2c3/5+D/6OL/v6v/rJP/flf/49v/t6D/5Nv/uqX/fVT/jmz/0cL/z8H/8u//m33/tp//8ez/yrn/18v/39b/iWSUsVjxAAAG0UlEQVR42uzR1QECQQwEUNYtl3Oj/z5x+MHWcF4BkZnFx/gjlHEhpdqQUnBGSc7hWihjnYMT56xRQpMs05k0Di5yRrLUHVocp1/bUeiU8RLhLpQ6erwFLzZqBREI3lAEd8FKCFKysPMLC4FsEfAErRwEcxX1jsdAFOMZU40QCWuf+dxCNMvj5zdt1w/jNM/TOPRd28RuqC/OX64pqwol12EYOMfMzJezwmldZmbuY2Zm/v95EzhwIhd2OBVU2tX66Pjk9OxcuCAA5EI4Pzs9OT46RDtsDOEX278oyYqgaioAsQCgaqqgyJKI8TCQ6UlEP7rh81MViAugUr/P0BEtDVDrxLonPBAMhSkQFEDDoWDAk7LOv7gVz31F5CiNES5iNCpHPBe3wiXATXA8kSRABgJIMhF3E82hYcLtb6l0hpKhoJl0yu18+JJmXGHZnKCSEaAKuawrdQZ9X1Zd9fMFICMBCnlXh1XsBZplY4o5vD7eIVdks2eRAViGS2kByMgAIV1ieZ4fNkAio5IxoGYS/BEwBiJJSsYCTUZwFnAJlWUyNuTyICFNsCYUjAIZExANspY0wR4xYxJ6iDpWoFJKYZBVaJpKbNCQzhjG1ACKjXDMpq5SrckhP/DFU681lIJqNwsbKM3IhkSfM0CztX1Y0tsdnptm0t3DXv/W7Zg9gk/k7mie2ZBk/+c7d+/ZJ3G/ghvqg4eH1mP66PETq59fYnY0z9NQXLYHeHrkfOg+o6j2n287Af0X9ghynKejuZs/HCmqmf7y1dWX1xcEwZu3VwHvqlaKcnSzzhyPgmMBTNXtXn95/wFhAT5+uo74/MXMEb5ySJhkfOhENdO/9W7c3XdkR/THjYjUTzBHOGH8aBK/gq3HGiHw67dV+c/fVyaRhpfmWOGfydd/RqwBSLIkiJ7CL9Rab+PnIn/HTJ369/mGwR2tbdu2bdu2bdvG2bcO66pX09c11VMdGBReV2Vl5nsvr8fnryLdsxdZll3HXXQmfBQP4PGzZYl6sS7Vu0/ffv0HDAQGZStH4MFDgApDhwWGj5ATMHKUnMF+TzzAR0U/Im9AfpfRYyCXj23KxDXHDYRrfNVEgKojXAhPyBJywsRJACbLh0ABr/KM1Dz2yRjTlNoApmZRLBo1p7kxfVjCEbjyDOS+7kk0cxaA2XNIRtmn5LIKUEJ+FTF3IDCvkXhTEOZHseD//Yc+W4iMyYvodbgX5wBLYrNDJRQANQ1KyiX20mVAmzcVSUZ8+Qr3yqpxCE7VcZOwag69GV/kAz5ebctfS6qJoACUIgnQB1izlt/dR6t16L0+9A6BmnaYh7J9343TBhewUQJQKUMAqgVMkjW7EGF56U2btzCT4xDzlu8GRrdu48KUKO8GBpACoL8iayjQezDH3Xlge050x86CyGefRXbt7rInZ8DeuFHOzgH2OcoV6YNMpYAhfo6Pamj/gXD04KHD644cjFZYd7RmfMx5eBmgFumDrDxT8V0CgPzwomPHKzb2eBpXHF9/kRxKBDgh9M9USTT7ZDR2RYls3Tp12u8/fcZK7KJ8Ngelz9n6RFNKhTg/Cd8eVSscETORWvdS5PQLQl8qlGLH/fMQ3WlMjcTFDFy6zPpip5RrWvQFsCBkClDzCnB1EanlWt9wqJwLrauYsutWXeE6QWrDSdIyxbUcpF83vCNxIxe9bwqlZSZr+hRcB7S5ZXQEWiTnHgiSpulraAvfdiOcYnQEUT6MkXdYQ1t0xIvafiIDZ0JRKfAFcLctaYiXljryvSXI3Fi1eICq3y/DkhTWUEc9+XXS5rtQZn+xMoQveOAamqYlv3r6Tq3uAw8SW6Xa+x8Cj1qRnr7rBQgvniHX7kp6Bq58H2i8mJMLEK2EqncQ6HKTHK08oEZdAE81J7mE0ovAqjc8QIvraZpDcFrHHwDP6qrFi0CNjHWq1vsR2DTfT0VxU6f/T2GgcbWqZjJWI8TnPsrAmtY/t7IEJfSGXya0XoNot7mORogbWglcpVQOUPrX3+ZGLFswyQ8L24rMHfB7aSDnjz9ZYyUYmyFU86hvEuBa0rNUp7/8Uzp3nuJf3KnZ/SUuYNLfF2qS1gwxt3M4td4/sf2wbNOQ5l5v8yGblgFw/XvgcSob2DkGhhRxcO6T+0+XFQ4se9rzydwgk4EhZWapyZhGznY6/uz5g4cPXzx/drzDy4iMuomlZm4KEtuUlhro1SuQmkY201tTMNfAFDS3Nem/gQHhYU36D8wSHlrORh9azsY1tEzXwXH6D+9TPkFB/ykW+k8SUT7NRf+JOvpPNVI+WTrw070IK3gJT1jTdcqd/osG6L/sgf5gFAAAwljXMphbLwMAAAAASUVORK5CYII=",
  pfp24 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAHDklEQVR42u3chXMbSRbH8WNmpoJjZiZ7mUGKzMwOMzOzMcyMZmYWS2NFG9X9O9/zW+iKXVqN7yxX7Yy66hdOJjWfeq1+3e6ZD2G8lSA6GkgDaSANpIE0kAbSQBpI54MNNP14bjQQysVvMO6hb4j2bkn/MBNeAoaSSjEgRRN6RO8gZ86xdTsVlRQUkpcvKSykqpodOzl/kYERwlHFlEJAUi+Hj1JSypIlOBw4nXMiv+lyUVbOiRoGR8UoFYDkPgPTXL1BZdU7EAKUIO/8haXLuH1PKk6YbAmkdHxh6hrIyZlLY8qUn8/ZC4IrRnYFCkaobyQrK76OmZGwnrsodWRboGu3yM0110lgVFDAvYdSRDYDklsaGJG5yVzHzGjlKkanlJFNgGRcHDu5IBoVl4vGMzaqIFU+ZeWqfBZYRDKpjUkR2QUoEuPiZVyuhdKoZGVx865c1iZAwWl278HhSBaQXOrwYcJROwDJQJjysXyFGl/JGWWrihjvkovbAWhonJLSpAItoeQN2rYSNmwB1DdEYWGSgQrf5OZruO9jxKwP1D9MYVGSgQocXH2a3pWEAhiPLQ40MklZWbIryMG1Z2h5nomr1gdyB1i9ZlGAmtLoKifoFiNLAqk2+uBhHI7kAzU/RfOzjJ6yOFAkxo07ZGYtClBTOh15+EfFyMJLjTG3aoWSDTSTpxk+hhG1+HbH2fNkZCwOUDptLnx9GDErb3dMeFm3PilFJEDFb3JDAYkRA7sJR6wJpIxaOyhNQkstQKtf497TQqOAWl/H0ypFZO1N+xu3F9hVi062k5oXVPkoI/o2EA5jPLYyUDjKzbv/996Q6OQ42fcy96V85gK1vMTkHSkiqwKpdHSzeQuZmTgd/4OUS0YWjc/zQETiJY2eZYT8UkTWBpL22s+V6/KxnZs7X6AsJw3P06I44qX5ecYvWRxIGQlTgOZ2du2Z135j1hvU/Jnm9ARAUkSdJQQmxcgmhxei/5nXhqzTRfFT1HyZu3+i6emERs8wWm+j4y+RGBeuJAJyOch+jZJ09nyDug9x6Xs0JS6idDpy8A9LEdkBaDpGSwd5eTid8Qun8m/s/zLHPzmjI2n8BHd+n7iIJEOHMKL2AHqMNyQnYByOOJN61mvs+hb1QqPChW/yMM2kiNqceLsxYhYHUkbd/axYOfv4i5PsTDb+npqPCMqTafgYt35tVkTpDOwgPG0LILUze+iInKTKL6CoiPUbuH6DvgZu/IOGT1I72+jcV3nwLxOg1tdwN0sRWR5IGQUjjE7S3S9YniDSCsQITNGznyu/of5jion6j3DjZ+ZF1LuWUAjjsfWBVOKc4xQmvEN0rOfCD6h7b8Sd+SL3/2EC1PIikzdtAWQeGSm4O2ku5+y3EKMPc+1HApEoaXRXEfSKkc2BVE8QfsT4Pe67OP0lTn2Ge38xGWjNzzF2PmWAFFMozPBFbj3H9Z/z8N9mi48iAhNilCpA6oMp6GP4NF1VND8vEO9r9DQjNbatIHOmkF9W8F2lsgqLvwpJpz0L36D8/ZQCUkySwBSjDXTkikhcpsH9GI9SE0gxvYV/hKHDtC0RI8mTi4838XZixFIWSDFF8fbIOqP1tdlM6fRvIWykMpBKjHBE1hm966RXbEp7r298hakHGDEN9B5TKMTkLbqrpRsSpjR6VhEKSqFpIPX5Ld3A+HnphpqeloZg4poGijvNTUg31J5JV4U6MaOB5k5z+AZlmpu8rSvo/ZnCEWT5GtVAZtWkgeYdDaSBNJAGmrsVrYEUSiRGOIovJGc9xz34wu98STolXyygRKRnC8tzcW1dXL7G0eNs3Ex5BRWVbN7K8ZPy6HhHD+Nu/IaJl1WAzEX8YcbdcttXrgvBDERlJXl5cvrV4VCvF3jn5/Kb+flUVbN1GydruXaTzl4mPCZeFgBSLiJiMOGlq1du70St3GpVldz2bJFEz4Upr8xM8guoXsq2HdTUyVnH7n4mfQSmlZR1gEKPeNhKTZ3cTHW1iMhpO6eJiGmUl9MpFywokIdXd+yitoHWTsJRiwDJ6xVCbNrCm2/OU2SBXvIf7d4rpWQZIG+IjZvUcZZFj8PBrt0aSANpoPlHA2mgDZtkclFT2OLNYk4Hb7xhJSBJMMKtexw4xNp1lJSQkyP3k4wpf9bbu3JyKS1l3QZ53vN+kzX6oLnvcPMEGRrjQTNnzrP/oDzaW1xC9vy9lIiMVoEuKRX0GfpzF2lqZXgCb1BoLNFJJ1iISWa83AEGRrnXxOmz7N3PqtUUF5OdPcvrCRGhnAFdvVZwZ4gftAi3JyiXisTmLMcsBmTuFYzg9sthzbsPaDwjrfCKlRQWUVQscDN8p88J5cCosJqIWBzI3Oud861T4sXAiIgEI/KbcUX0jqJE7yjqPWkNpIF0NJAG0kAaSANpIEvnvy7V3Oc1ANVFAAAAAElFTkSuQmCC",
  pfp25 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAILUlEQVR42u2cA9TkyhLHP1yba9u2bdu2bWUPnnmsZ+uzbc185tq2N5mk379vL8eTZDMzu33O/97VZLby2+rqqupKAo5UEyfi4oA4IA6IA+KAOCAOiAPigN5dcUAcEAfEAQlW4oAYhaM19Of7K8nuCrKjnGwrg+hPdlWQfZX4I3zAy7wCvIVmTyVZXUwm5ZK+6aRNImkQR76NJl9EQvQn9ePob/ZJpx9YVYwPew1TgMFoDlaRtSVkRBZplkA+iyTBYSQghFCF2iiEKiiMfBpJmsaT4VlkTTG9XHgrATE0y4pI91TyZRQJDGVQ3FYIvQTO1S2VLC1kmN4WQOxO1pWQXmlwGdytVn0aQXqmwQ3Zl/s5INwAYu3EXPJ9NO5NT30XTSbk0i8X/BcQTN9cRhfF+2E602HC13ZJIZtKieCPgGD0iiLSOF5/LlZqFEeWFxHB7wAtMJPvY3Rm4WS5zTf5FaB5JvJ1FEw3Tl9FkTkmfwAEV19kJt9E29mn3wsj74ezDd5K+jDCPwncVvBlQDAOWW9tm5X1YTgZlyP/+LjllyctB6st60vleSZ5TI7cO01plajUi1Vwb8gGP6D4NLGrFUNWFhPBNwHBrK3lyI+tjcY9LzDLZffFC0/E80/o/889EU8+EqseiKX3xII7YupNKeyK9Ifz0q9+wLcB+Mzy2By5VxplF+yhHyHn3lpGBB8EtL+K5m+BNhZjuUVclYDmzOPXdPa5wAs6/1znHj/Hd19MvCHNN8ueZgk9Umn1K/gUIFgzJQ9rxE7oaZ6gwE3OAoonYuzAq/Cu2C9d8WitwYxJub7kQaCzvgTr334N1SNNKbnHAKkRnGtjqcXTYITEHcWN4COADmJxpTosMkdly1gvWgAhKnkKiC20A1XeBsTcZ6GZfBLhENAck3zikUo6EOLRfLMaQB9HsF3f24BQLrZLctamWFcqq3YfXAjvw46mLldqm6RDNRug0X3mm8lH4c6s3F9lQaxVDQipANIldYCQf80zeRUQFnmnZGcmInX+xUlNgEx3xZaJKgFBHZJhpJcAsbzZeQ8M+fHvzyMJUh+h029KtWMU1fXHZxFkJWp9b3nQkEzX9RGy5HMaAOFyjXXv4ExveJBQjZMZ9GJcNJJRK6TeVA8Irvf7cxLcUAughnHUVMFgQEeryZJC8lGEC0CtElkarR4QQhgCmZa6H3vI4kIYbLgHjchyfRSBDahUQxqNyhabIL6qQZwyPleekCs3jFMCPWc0PMtwD0JpStOfEBeAkMJoSaNx4doSuU+6gkhU81CEUPcOzPAwZocgIYLBRgFi7rOtHPWOa8uQBJ/UkEYjBf/tKUv8dboPvihfEdQGZyqe9mRhsGAkoBVFyOVdA9pYKqve46HTj8Xjj8DFemtLuykN9YQRTF1eZCAgDBTMyEcL1bVl+6osFyggncUYDctyNx7B1On5MNtAQKOz3Vr8K4plFkreBKN0TxiNyjYQEHx1YIYbm24IzsWUf16keRDrt56jAi8mHRhl3JJGuMMohAzIMG6JQdi/GSB3msQKItFvTln+fF6KvCql35JQXqGdWv1APPVIfMGO4VPHaGS2HOgKECYDDhsG6FAVhjTcBcQGM9AGRdWG/nT9WKVtktI3neY1aOZvKpMPV1uA70/npairUtUDNYwyKSOnfhQCg2G2zwByzstKL/DNKpDRgT6raq1l3ZJGwY80ADJsiakQZTQiW8Hqe0FHHSOctQU6zOmxxLwUpLXTGZWt4PZwkxpjdvZtxsjbQRr75Zgc3dxnSKYVHU2Mcm5j77fNIZGXGJoHIV7oM/WDqbq/XHDSUVPTAPj7RenLKOtJopkFxuZBGFD9NEIzoBA0a7S7j60Tici/Xo0AMHVVsbG12M4KNMP0Gcn472WdPSj0imQ1XlI3luzUVKxq3+k1aFKeXHRP1CsGFd8Tp+bLVn7aje3xRgLCep6aR4L1CEOoJGebdGDE6GAyxKqKhpFT8mCw4R1FTE9+q9PsKu6BZYla2vtAPNdkTQeCkTDV6I4iW2W90mCBnozMqhjhEsCdY02HCUbCVC+di6Fv/0mEnoxmeM6I0cEitbveYR6MFLx5spoCO/RkND1fNlFGHtCB6zmKhp1TYKRXz+bx5MTnkTozmkYZITlyTQfuNtMxHRi2rMirZ/MsEqEuo+WPfgoKI9iqC+6AkQs6cDdHdGASDDvkC/NBW8v1n6gPCiWT8+R8ysg+HSzDaY7pQDCJnmT4yAgeji6/jDKGEaUD54KLBTmmA2NgkuBTU66T8nDIqz+jia8zYnSm5MlBTg55wkHW98aAMak4Mpt88AYY4cQZh4Wsz4+TjElO6cCAUdkwxicHybGh4sD+Qz0YYQOqH6ewEINw2z5ZWVYkLy+SOyQrTujAhUdmwwwDBsk1PHc5Pkfzk4UheBBMweJ6EdfceTgBf+n4XGqA4ONP+6D1O9dE6mhrhgBNk3jF/WIYDQ2MIx72l8eh6Gh5KbxATUhSManZNYVsQDnqd08c7q9E3UAHvJw7gpacu1EcpgTYkxl++1Dv9nJMCWECCn0ffRps7NEzcEew24FU0P8fC2eYUGFh5op26YPUkQrBhbgcOxock6GB3qIXC6Cnt5++dgF7DS2ya8egFwFfYDfvQLTfiI/hw4hoSIhwOXZxfJUvv1hAOymaDVAXWFlMfQGpU5903D/1r1aJEP0Jftk3nYzMoiFmVTFtuR9kXN7Bt79ALBFHrN1HBUdjqTD+yKfe/sLFAXFAHBAHxAFxQBwQB8TFAXFAHBAHxAFxQBwQB8TFAXFA2vR/9QcEJHdEdqEAAAAASUVORK5CYII=",
  pfp26 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAACfFBMVEUAiXsAiHsAiHoAinwBjH0Cjn8CkIADkoEDk4EBjX4DlIMHn4oKqZEMsZcOuJsQvp8RwaESw6MSxKMCj38GnIgLrJMPup0SxaQTyaYUy6gUzKkUzKgBi3wEl4QKq5IQvZ8TyKYFmocMspcSxKQTy6gSy6gRy6gRy6cQy6cAinsEl4UNspcSxqUVy6giy6syy61Jy7JgzLZxzLh8zLqBzLwKqpIdy6o7y69rzLiazMDCzMfgzc3uzc/2zdD7zdH+zdL/zdIFm4cPu50UyqhwzLmzzMTkzc35zdH/ztP/z9T/ytD/yc8Jp48Wy6g/y7CPzL7Zzcv6zdH/z9P+x839usT7pbT4j6P2fpb1cYz0aYbzZIMMsJYTyac1y67hzc3+xMv7qbf3gpnzXn7wQmnuNF7tLVntKFXtJlTtJ1QMsZYOtpofy6puzLjUzcr9zdL4jKHyWXrvN2DtKVYDk4IPuZw4y6+ozML1zdD3g5rwSG3tLFhWy7TPzcn+xcz4kaXxTHDtK1ftJ1UYy6ltzLjlzc3/zdP8sr70ZoTuMFvvKVcZy6l6zLr/zNH6m6zpKVXHJ0zwzdD+yc/4iZ7vOGHuKValJkM5ICb+yM72f5fuMlzqKVVyIzUeHx+KJDwiHyDCJ0s4ICbuMVynzMKoJkToKVW/J0ptIzR+IzjXKFDSKE96IzdwIzTFJ0uOzL7lKVRmIjJ9IzjnKVR0IzYhHx9vIzRwIzUgHx87ICbLJ03vKVbDJ0s1ICU+y7DOJ05uIzQzICQ0ICW3JkjwKVeuJkUxICTYzcvmKVTAJ0qvJkXgKFLdKFLgzcygJUKNJDzGJ0vrKVWLJDw8ICewJkagJUEqughNAAAFa0lEQVR42uzUU7zrWBQG8LVSJtlpjs+5tse2bdu2nsfzPLZt2zPXtm2zaXaS4nSv2Wmv2kkPrp7u93ROsf4L/QVhN2cvILMX2Au0/+O0WwBEUtAPkB+BRLsQUISKWwK0JZ4idgmAVLulNoLwOaAtygaknQWUjiiTQQqAY76xUuwMgJ0iiG6xuo4yIPwBZJzi6jSi3AraUQD7I+ImUSgeipTdIJcvIEo1Ec2mHQIwsv8C1S/PsAoDjkxJ4j7h9ZqSox0ABjQhzpb1WVyp33xi8DQJuCpsPvM6keZS6E+0elZ7AQydMS7sl++PMh6q/5vAI5X89fhE86G/5aldAEYuxX8F6HBkylyiasbW8hLYStiu181KjAIHlBONt3PUDgCjN3/rL/80RJybruuEiK4ABlvCQdGksGJ9vC8R/eGf4sK3s9RmAB/Cj/36FyBOAdYbcaNgUB6u1BDN57A/0Xe+cDU9Q20EMHqvrK+r5+HwmkEoY0FwTJKZsfEY+sFzpPBiltoEYOQWuR/9OkQcdhxipqR8I6wpIWJEQ4+VzAdSuPCtHLUFCF/+j6x/G37PTsH1G6BkOZ0RaHnJoqC2jv7i59MbUrjgzeY2AAN6Vf0t+1cjv50pl1+6nZ4oAVpYuid5il/PyHlyhpOTC2a1CuAJM8MC6i77nZ2POKHstv0LwOyyax9M9D0//Yv1oDQPHEytABg5Zo4Adpk6/MxYciGD0vRUJeAthDKhZ1Xm12O8Lzgo/YbnqGVgAEvMBHZBTI1FY+X9yxM3SGDtGigXjrayGS8jf60DU3xWiwAOWK0K/fTD34mfGp1WqN9zYcmOVPBKNlR8m++b/TN905jfHcVrmkUtAZ3NpAD9jCn1h9hxq1Cgys1uT/SEkv+iWrLwv5k2xq/b/zcHlCpreQuA0k3fAOyIqnmHaouK/Vcj4vqFEJye9Yi4ujhDD3dcn+RoDrXOElEZ6BzNCDjkhhfUw7TCgXt2xA1KzcLlFep3QVzTlCzMwHu6Y7373hsPSiy7vCKAnaMusAEbDDZIsYolwgiI+Hsg0Hgg5vJesngTU8zg9hN3ctCyy6niBF1zAHU9LTgintrc5ACUGb0mELgA0fO8dZsXmEiPBnPheoDI0ooT1LIcMe2Vp1if4oV94SBEHBd8hJ6HZTxv2Zb3zPQ8/shdLlfCfEMFQKlhGWDdDOyip7dVcY6cWvHI+43St70Xd5aRvYRDjG8UwQDUh0GvMUON1WkN2h83vmlN3troQPM6CAZUI0ysADhsBwCuFwCOzbYXCKBqKGBWmbpZDTuWTZZjJS0QtkdBgKIaCHVMAlENdiRuVgJ8PZDtiSAAdQN0jSWYGWI7BPC8xVPcdcB2AicIaQYx7a1HmansICAs/uQtLkfbzQcBYY2RoTHDMA3YsdiWbXPXRu42BwERjYmExljCZDsIcCvFuZtSuJsLAqKaLkyNKU2mXnwUd5u8BtqSRj1afKQ71mrBXUtx3GwAgFEtDqZuaGbCB47vNOkgxA+h9fTv3jAum1nuAynLtR0L0m6WAoCYFgMjwXQzocmuOnearxyMv7Y+w+lr80JkM1n5STdlOTxlQ8bN7FkgeEU9R7d1RREf+K89uzZYIAiDMPwrnl05dIOkSCNoIzRBDZRAjjtEuMuT3RawvvvNvHN3i/wh+2vKH5r7KsBn579rVXDW3esFx5dMX/S9bAlSixUQXkA6MvEbdHbiF8t3b0C8hfIm0NtYb8Tvo4R4+yGUkB4/gRIgDNm1v3yL4hwPpDhS81CQYs3dOWT7EsweouViU6BlA8fv4P16ebeCavEDeN8HFLuI5WcFIhYQEqmYywd1Pmr0YWkYWIcDhAPgtgHMWJmdVvJ1GgAAAABJRU5ErkJggg==",
  pfp27 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAFHUlEQVR42u3cA5zrShvH8a7x8tq2bdu2bdu2bdu2bSOdam3v1sr8bp9r34NumvTM//McrIpvMMlgffhN/V0ZAgNkgAyQATJABsgAGSBTBsgAGSADZIAMkAEyQKbcClRJcCpUPf4KVA0GSCD8VahGeg6g50DaNyfxDv2n0bUzIzfRvDSB/0hNoUCWj9Y1Gb6G3qPJ9WDHyIQB8kPkegGijxN7htF7CE495QFF5qN1dUbvBtBJsPljdP5Hr4FzGDiXyLxTBpDlI/B/Ys/JO88P8s+x0Vl0jt5Dfzw9lTlQ06J070vaz0RF50l+KAddywplDRT4D9En0Bl0lkmIzsm53CpXIFVF0yLEnmWSo9Py4z2HoOrLEah1DTJKWqvJTCZMaLZyBOrYAnuUyU/qEzo2J/Cv8gLq2JrYC8UB0hnyA3Rsg1U+QNUMX08Rkx+hcwdUTVkAqWraNmDsQXSOYkWnyQTpPQp/lfeBQrOQ9jMeGbkNVedxIFUt95zJDyh+8iRelyY/0OhZIMtH2/pkQthxxinZFrlH8+4eJKdSO8b4JfWltI+B/3gRqEJ04i9hRxm/SJM/ROcuWJ4DUrWM3IEDsWN07Y6q8RSQqqF9Y6KPQZ7xjs5Ik993IqraO0DhueXc7GTG7kc1eARI1UivTepTnItN4i16DyfwHy8AtW9GJiJNu8PJdUhvnOV+oK490SmcT9qic3sC/3UzUCVduxJ/WXYf56OzchPbvQ+Wa4FUg9yUljA6SfcBqFpXAqlaOfvEnga7dEBZafL7T0eM3AYUWUjujNyQ6OME/u0yIFVD66qkv6b00STfldHawP9cA2T56NhWdh87gUuS66V5GSzX7EFyatRZ3JNMkM6dCfzfBUCqiu69iL+CTuKe6Cx2lJ6DsUoP9G9puVwYnZGbD1VbUiBVT8eWxJ4HjdsiTX6YgfNQ9aUDal6SbAdoXJv4i3LzUSKgSlqWJ23h5iTfRzr2/1MKoLZ1RcdO8k954dOPjrvjxhPuvKmIVXjAwsNOeJPvNNCP1z72GBOQ4++40bfByr6NVytiFR6w8LBMSJLvEpnPcSBVJz3BE3ZvUdjg8pY2W7OIVXjAwsMyIbGjjD1McBpngZoWk9MzeAAIZOQyNJOzQMHpiD4KtgeAdJbBiwj821mg8BxEn/AEkCQ/QPtGWI4BWT7aN8GOeuQQs0m8S9PiDh9iUzN4CTrlkUPsUlSDw61YAyO3gvbGIZb2E57VWaDAv2WsTidBux0o/a3MzFZ1jgJJhWdn9F4vAFkluFCUCvxfxjPB1UB2XMZ4I/OXAkjVSFdZ7Dl00rVAch6ILIC/snQdZt17ozOuBLIRoAd+bL9KBtS6mqyCy4TAdheQDJCdIh0ype60r5QBlv4zXLQH6Qzk5f4rOC2WS4Z9Wlcn+pQsENTJ0gMl3pTu+rZ1ijKLungzEgONMi0oEybbTLYdSR70eALd/MsyKTQ6TfwFGbzsO0FoLDdOXqihZUWZGD1wDrk+WW6abUUnTrjlBN/GqxcbaPUTbj5OOsNA+hWiT8r/m5eUw0o1uH4KXnAqYQpOLXN0ew844YolfZsUU0dqk7VOuGJRmhen9whpyIP/JzQj/kpPLmY5/tK5fRutXXhLRazCAxYeFuXD8vxiFt8td860xhFLrn3UEkWswgPefOdMqLJYDpX6unL08+qiV+Fhy2hBnSp6uW5JpvnlJqYMkAEyQAbIABkgA2SATBkgA2SADJABMkAGyACZ+g5eG3xTXD3mYQAAAABJRU5ErkJggg==",
  pfp28 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAALQklEQVR42uzWA3crQRQA4Pfrn2qbR81xbLM2Ytt2ptPYdu56x/db/iL/QwMutOWM7fYO+YhJC1N0HCD+QbdX9oyDhjzk4uIjKVlK0p9Slb+IuZH0f4pxeljDZ2/FSX9/0vEWH8cMHOQlleviJWVjyC49pL811QNKES6WsjIkZz6cohe9Il9VLS/J/SKnr6UHj25GgC4AqC2Q9MILQAA0VKCgUghAbYFUAARAAARAfQOtA1AdELseyPcp6RbICndQR6BzAAIgAOoLSMtnb9cARfXcjkCszcSsAgmPg+MBCqkFswxEAKC2QHcEGwB1D9T2PwiAmgIx1lO+DwAaCpAXgLoAkpz7AAiAAAiAhg8UM3J4++EyED6Om9gAVALyknIuyhdTRV3O4lzqckbJUuKUSkUAwrkpO92sePykqy2Kh7SdjlMWEUjF+WoOVIqnsl1coL+1QO+S5iJNgc4ACIC6AvJSkI+Kt4WDuQMyM4VH3+SbBXAbyRKGj/keM8MxY1gyhJmZ4djMzBhmZjPLgjAzM4NZHDmcGLffv5rKbWmtbPIotuSqv1yj0Ux25nNPT3ev818AApSSDCoMoNlDacEo2hpPugJ0it5qoLFpXg0CKEcGlPvvAwKdU0vIrw25P08dn+LV41WaNYQqczmz5rSqRACUTPvXmoGmNQECHRhLdBeeS6enSPYU5/Jsfa9fcl1fpiwPqlahtn8g3bRuRgMiJjzCdPIAO32tBhDczdF51P8XoNPY7XXO/QVyeaah1y9I9jR5fwEjAouayk2GY4e0h4/eKdmGKc4G6OqOs8IU9hdQF3bZANqWQN1f4Vyfuz/hk7oBf2B2xBvUuH9QSbrVbfPbZnI6QBYlwsLN8+/BfcCO8PNghhF7w1e2FvRLwYJAB+rw1AMLss0/nAwQxJnV2kNHERBvXXgX3+Lvw1j/w3wQxDdAKsuT0XFuQEJ1Gck6/5UFH4Vti28xGA5I9Xyd3WKtCBBZIDSUZMolUw4aIkZwNw/ioNEsDmJ0WgkgJjUZ0qhqDlXNJf1ye5H0OrgkJtbZ+gBp55Mxm8wFpJ1LZoU0hVYJyLCKtPNIu4B0Sx6TRaNZVWdQtBJAkJKMmWRMJ3Px49Dhrqk2KqbNmRl4t6qQLGJAu5HHOhsg5mugx6FjVm0qni7v3u3TjvId62ZRtc2sBuO6k4ryLQvuGU8cJIsTAGJFDKOCtPn4ifYjMeFkhYV9+8+P2/zzkzapyT5NByAFQemj0cQ8essGhLVKAQILBDXFwRTfgwLaUWw3KvCj8iz0S1nZdc3yReFvfdbuHx+3CQ7+WuSJbCq2DgFox9JbDBCMX7zbK2kU05W6vMjiQP4nAuVQOZ1f2ZRRg0mpv5B5t7LAcDHzB8/xb3zSFhaUkuTDSZqbIwPCgZo5mOTPCJkEhDaU2JP0BSK/A688cPiAb78fO3zMkPfadHjj07afdXLZrmE+yPkAwdccX0CDfgPDYeloff/fk/xpxoj6/pz2z8CYH21t14Y58m5dcaaY64H5vP15+6io7+8Jt5gacjhAylrtRkQliiTCzWLjNREcK0Oo8wuNnV+u7/e7hp4/q+/zKwaIl+uzlO1J19f9COj47sUTpoyEybz7RYf323TEFTY1xffalWx2EvnYUr+aDKvRcChAFiVSdtT6UBvD/3azWS42jwzL7bm6/n+4823Hhp4/tzloLs9Q+vcCICuj6yW5ezbOyV4bp8hOOn9oea1BIfgp3VLSLbZqiYMBYiuDKbG2zRHbN516/5Rzex51QlTFUFEl2YMj1v1V5KUYYycguM5L7HcQhSPRhdC4pnQkQFJhYVUehbkwHwRMtcPf4NxfYjVD8v1SfNlLi+W6kGGtA1qQBCPUDL9+z3pzPdPY7TWSWW+0CW/AQ0vTsZrSOkgILJHomvPRcCJAjNHppXytZ+KbNPDXNP6fNG0Abjf0S03RF9KBmZTjRRnf4yQ+sDVI5XSA2IZNxVSaQRdXU0kG2o+gc3EVJfWmvj/DTQdfjqo++XxBe6eTxRkBiR0wL7VUnlGeTRGu8OU2VWr2nuPYfLJonBSQRcVZ1LfL8yvOpJWfXnuzLI9jOJr6naJA6vwio2MjMErth9DcAQAprdLMaMD7vMc8Yve0hUXZSYgD5d26deraddS4oRmrYm6W54sZmRSU0AP5GgICJChiQDCiK2lsijQgtsLmAaRObdySZNwZf2XL1Gs6AKp+NKBavWLurKCPO8hYDgGh8X7bjnGxHncqUJ8XOJIun4I6ci7P3R/7Qd3AP9kAgk0hazm3/JGAtk03YXmbk0yqVO5JAwKdE1Hrb/lNqPXufz3I4/bm1Wx7UqpWI9v8Qu6K3ArlizYubm3d3JFkIRH9sF2nwsxEmw3Dfyf2sg8IFjT+DbqaLglIdX/rshtB32F5N/0mHYveAkZPDhCMdkdCyV3fEeQpI08X8pBT9ADaO1saUL2hGKWvv334Jaxm3KQRx3YtPntgmYfXBPBC59ffjUFxQ6AMH6QKpa4vczhfkIw/a5zbC8QsaMYgEHwYGjIrafdMiuyHhWF5WORt37HbEiuVTxLQoZi9DV49rI935eXhQuF9aHMyfOfDXhMjF09K9B4xdsj4ySN2rp/N0ogTe5ZM/nr0iLFDQ0K/uVGah7k21bX47qDD4m9kcLVD/kadnqYp79Cpxfafgk4sYGMihfYmD7Y2yKXeq9f+uKPK5rAgOVYgMArsTnkhVGH/XShnVt6pLMC1das8r95YzDobTcpb5fnovF2R32hWind7NY1/uTro16gEcF1e4vr/ikJkdGTuQ+mU51B2EAV0E+jwkgsW9GR9kKbGe4CYkbc7zZ9MJ5eR3cvbYq9cz3okLOL4Qr5aUuhPe6chp7MzkvWcWEJzJ5GXm4hOjc/gY9GbnqAPEhg1wPnd8xlmw4hhiupPqhj8PoWd/zfiQ0qbXEwMtyybiqPgdGzRQHKY+ZGYHarUxuYKFLmDsQdu+U0UM2KmNHMc7ZpB2oL/EpNUSb8qn3ZOp+lj8LimdG76TTkQexiLbOZIelfCJWNgMOfpBncoxuTfleZNBiY4pv8Wk+iQwjx3TKO5E8mvaxM0LpynuyEwbGfCFWVLSDWwiE1J166ELa7z7stMSYwJe5g2mj8Fp1ewP9iwn4VJQ2FTMP30clJE0NRR5NelCRpIXuvd73LYsk3J1YxO8wNijDQptYdjdlX7fyc2JaYfXMjLlcJ607xJpIikQ/OpJJPfrVkJz8LEEDAWQg8GYNjVTDo4n4rCac5EXOGMe1M0eHS1vwdCEHVKHaPTQgAJmLYkGS6Fr7B6bhfIjjWBFBq4iaMH8gckzZe3rK0pfJx5eAEdXcQLDXzckkLFkZTmAygIRDGFgbaHxgWCP74YvhqJhYCmpQFijHC77Y6/UBYys8ZnENYtOnQCKR4WZP3WpzPvrQK6U2APXmjgo4+7lYjcCgVic0XCdJf7PkNKQ2fDFeLRjE6LBCQ+cXV74s+WhM676zsKLhM7ERnUw6gxSY9k3PHP3vEdczVswe7488KZaumAxNZUvz2x4kxkvikwEFGl1T3JpGFJQ8F0/CM13gNxb56OLER8LFiNowESMEHrk+/sjj93NjJXFxSNwL/eu7fVrGSMF0MmEutnYzC4zrv3bd9x2qCYM5F5OMLrU+4KtR6HBiQitS6lBo4cqSN+/1dD5+uConDv3PEdCz9S4zMQVgahgY/gaPH3ANCroQtORyowBeUnTUqNmIuzABKRYpvkwGtD8q1NSZatSfrtiWUI7SA08BGd+AoDMEyYwvSvduigBAAACAFY/9Z3CXyLDJZg20Gh7OWLuiAECRIkSJAgQYLGCBIkSJAgQYI4CBD5MYF/GSMAAAAASUVORK5CYII=",
  pfp29 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAKBklEQVR42u3bBVQbWRcH8Ky7L7Lui9XdWxLqtsbZeonggXq7UleCQ93d3d0V9yRIHHciZGLzvsukX85mXXlTzpzzrzf2y30yd2ZYftGIye+EAWKAGCAGiAFigBggBogBYsIAMUAMEAPEADFADFCrRESFAfpVmiGJdWP2nB++vtgvmmSAnGgGxxpH77o88d44ftGHU7MGfHV0y9CkGj8RA9RCYB2xKffbKzN5Eg+B3EUgc4Wf+cXvTrr/DVTT4LhmXEwsOugMW1P6zem4gNzuD2lkbvZQTG/ypJ+NuxY5cnOWX4yVYmqjQBwRYouQb5RT/BIaxh7cPzl9qKDkLUrH7dcCZC5T8zp9dWblkDVyXxFpfyw8G0fUFoCoTxKNvkiyBW83LTlmSL6g3XKtaeMVbfT5yvkpsdNKOgXCaJL9ug5f5goRyj9epO61tmz8dunmLTfL117UrTqpj9xN+K+xDo5BbGcmDuRRAbJ/w1M2WjZeacosrqqrLyX0atKoQiYVIlQWo1xnzCrRnj5VPX+xum+g7C2w+BnNXGWHPZXhuY376g1pJmMhaZIjk5IkVGaDuqlRI1VV7L/TELbDNDSWBCbIsFjzqDjDyDjDkBgr9cXQGAh0xiTaoF4UZeVWOwrl4hw1IjTwgWv0905Ufz9T4QWlZNcJk3+wrYKv1F2wEnJElML/hDg91tQSeGx1bene241Bm6tj9m+5cJF759qXt699deKccP7O0yNiDRx6AoHOhPWWC5m1hEFNufxhNACR07h3kboPT/bmLKX3tbo4wiiFv//jx5qgGDXV5TdNxT2QhOWILufVfad+GBWn49ANCHTGr7feFVeTf+zy82oq1p5KKB37oH6jjVA6lcwfM6mR9gySdUJilj1gZMx7Pmb/NnoBgc7YRBvUDqXzlwOP0jbnQDXZdf5iNKjxMCr+4KdGqTeHjYlv4tCqglZf0JoM1Mf7e6Fo/n6qlyPJMw4gTdrn45I1HBE9gNgiFLDZoigvp+YdLFGj5hykHOQAKnnQyT+pkkYVBHscmxGXjj2lqDYJSZ61A50+HwJrPy3mICjjr5JtefJKZMILpEH6FCTzBB35A5/QjelQ1/iB7OMrYhcB+zfcQJASg5x/68yQqUtv9l1I0mUf5BuFYs82Wppx60DMqtPXpb3C6j24qH0IGrAYO5AIDY43jN578mDhAUTQAujM7dqOQaQnD3nxUEch8l2BCwiGd4xl5Na0cTdCeYUfn6tdjAgNHYBupFd3DSU9uQDUkh5z8ACRw9fJ/c8t5+Z3FFBH5GdrltATqF0wGrisdYEGx5q/OLR/SqavQOZub+XAMdSRqjk0GWLHb9T7CNBnAchh1HNe6wJBa31K+pBAxRv/7064hUpcb94LQboS+1YYZ0yq2/cv/Ri/ZabogN8MeQsQF3USInZUKwINTaqdkuHnaAPy5W7rzn5WL5pIVmYhE14gNTJKbYrhlrzHTXnPZF3pPXZeDixn7YJglGECAp0Zee/kRvU2zBxhSTmMzBrMG0XteVTk/vBoQ8pau3UhDDRvAeq3EJYUHEA8ueuGsx4NMzg6Ice4cQ7ZKMVaRApULkTixxxAm3fMs6/3vX/ABBRa6H5rTXdDxGBdJEc3e6T5zj58QKWo8TgqegdJWmjgZ8Udj4kLbntQU3Wv73EAwfiam/WecsEAfYSfLtJPF8ExLJ9sK7qGTDhmH/0DpPSFwlHd+3T/vtDYDSL/H1K9+TYvjBUE4yv6+ic1s9l60LFHyDHtDEd6casvZ0pUMR2qpiHjDd6Sy148EpZ5e+1AYA7quwALkMJ102nPxukc3U+AiLXjUFNOaw80owxpvoXyacx8PXDZeR++FYAgn1O7IR9cqxgA7TrqTdE4gNjN8XyyoQAPUAELjMoefHD4oGDNlsUJG1fMEB3qG17VIRyxV9EEKILdHBtE1uMEsk/S9nmayH3u5pkR46LEVOMV3xCjF5BzgOnK5Qmj4vScaGyTtK+e3kB1We7BG7LYIpzLPH2BIPrcV2ZvuwZA+DaKwsF0rqCK9I8C1kkBCOehBj2BQMda8OT+U98NizHjPVjtA0cbNAGyiB8j8p8y5LxgyHmpKuP9g6fnfJ1YzYnG2+4451E7i62PwAs0DoCsYtb9oqdXXhwbtvK4MO48d614WCwBOpgbZmGFb13Y3JnaKGIGggqqK2StOMb35Js6RiLfh30yDC3XfVMyB4GOY6DNznk3JaGnXsjBDgTzTmXqO7wllzpNs1/HhbNpv6ylaS9z5VNG32W89yC+uyE2CNWLcQJRRjfPDB84r4HqtOI87WOG0z7B9/wjZC68lhXNbVb221cvfGNtLMAOpM16RZhwadAqfECOc6rxh5PTpM9FF78WLHMLkLmsVHP0zbmIwApEZcP+lb74gURozaFkUvxYk+TxS4XP/1jy2goNR0cHIAnryMlIPxFJA6DDSSTVBibFrFLJ47eVfYz0ADp4YiZHhGgEZA8p64wM2diBbAWPJ+xKHLSKfkCIDkASVk2aW0BUim8UDYDW0hLoyEF+71lGDh2AVu7dC/0EJMELJEea8Y6NYv71rqPn5GPcKDoFbgBYuvtwzu2BloKnsQERclQ6Hmhs4sczL/cZP/+uBxd1mU4PIA51CZ5/UsWGI3Hq1M9JAGrGUEHN8kDpDZ91Wxf6zZB7chGEFkDOd6+QvHV5526stRionbRJg4i/EOohKvj5rzxEhcwtsRHKTUdz+wtLvfnWh6fD6Abk2FgLthIZRVVyjdJYfwVpj6OmU38iJ+F/6mpuSGWKour7Cv0Zhe6cQnv+96I7K9dekKgludLKvMKKbElleGLzZ1OBBkJjIMjQ2JZLgr9dQ6w6cDb/7giLxAUVvYoKX//NFL1iFrulXPlqWvS1/tOJIasypl4OjyzuMEP52XSFx69E+Tn8U2gO+5s96wfMq+kTYesT2ZJOwSS40B3IMdwg7Cg0cqEqYeNy9b2PYB/wq91i+HvZbc9Va+P6Ccs9qInDIwC1C6sfmLx73F0OvwTaKW9St4/Z4yKQvxEg/mTMifDu89O9+Bb4/45QLvQHcmbqMgPeq/XLedkH9wc3ZL6BJE46NWnuO3fPGDlbAqfSnT4hF0J2mqkaujNqclYXgRxcXAOpO339r37dT3TOJ7j5V0QeRaCuM6mi4KKOgUY4ZX7jzEg41YmkLGgYXzzxzZRFN9oLTB7c3/yE3nxLj/mZY45HBOR7THgwgL1+c4eIGgdNGwHyoj6PJ6+FqWdY3cLEjReO+8+N3d0tpImi+YMAh0+wodeSO13mFEOhUc/WFoHsob58W+cggyfXaUz9GSYnmrYKZI8n/NwKeUSBnMMAzUCemIA8AWgavYEg/RainvNwhbr0l95AVGLw5Z/fN8+kDQExQAwQA8QAMUBMGCAGiAFigBggBogBYoCY/A/WHbioOxyUEwAAAABJRU5ErkJggg==",
  pfp3 = "./assets/3-f0871c58.png",
  pfp4 = "./assets/4-61f6a6d6.png",
  pfp5 = "./assets/5-17c42ca6.png",
  pfp6 = "./assets/6-ae5f3eff.png",
  pfp7 = "./assets/7-8a53975d.png",
  pfp8 = "./assets/8-0ff7188c.png",
  pfp9 = "./assets/9-fdbbb4a2.png",
  pfp =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIAAgMAAACJFjxpAAAADFBMVEXFxcX////p6enW1tbAmiBwAAAFiElEQVR4AezAgQAAAACAoP2pF6kAAAAAAAAAAAAAAIDbu2MkvY0jiuMWWQoUmI50BB+BgRTpCAz4G6C8CJDrC3AEXGKPoMTlYA/gAJfwETawI8cuBs5Nk2KtvfiLW+gLfK9m+r3X82G653+JP/zjF8afP1S//y+An4/i51//AsB4aH+/QPD6EQAY/zwZwN8BAP50bh786KP4+VT+3fs4/noigEc+jnHeJrzxX+NWMDDh4g8+EXcnLcC9T8U5S/CdT8bcUeBEIrwBOiI8ki7Ba5+NrePgWUy89/nYyxQ8Iw3f+pWY4h1gb3eAW7sDTPEOsLc7wK1TIeDuDB+I/OA1QOUHv/dFsZQkhKkh4QlEfOULYz2nGj2/Nn1LmwR/86VxlCoAW6kCsHRGANx1RgCMo5Qh2EsZgrXNQZZShp5Liv7Il8eIc5C91EHY2hxk6bwYmNscZIReDBwtCdhbErC1JGBpScBcOgFMLQsZMQs5Whayd+UQsLYsZGlZyNyykKllISNmIUfAwifw8NXvTojAjGFrdYi11SGWVoeYWx1i6lmQCiEjFkKOVgjZ+xxIhZCtFULWHkCqxCw9gNQKmP9vNHzipdEPrRcxtVbAeDkAvve0iM2QozVD9hfjhp4YP/UrkJYDbD2AtBxgfSkAvvHEeNcDSAsilgtAWxIy91J8AXgZAJ5e33+4tuACcAG4AFwALgBXRXQB6AFcB5MXAuA6nl9/0Vx/011/1V5/1/dfTPJvRtdnu/zL6beeFO/7r+fXBYbrEkt/j+i6ytXfpuvvE/ZXOnsA/a3a/l5xf7O6v1t+Xe/vOyz6HpO8yyboM8o7rfJes77bru83THk48p7TvOs27zvOO6/73vO++z7l4cgnMPQzKPopHC0N9noSSz6LJp/Gk88jyicy5TOp6qlc+VyyfDJbPpuuns6XzyfMJzTmMyrrKZ35nNJ8Ums+q7af1tvPK+4nNodEnPKp3fnc8npyez67/qVP7+/fL8hfcMjfsOhf8cjfMclfcnn9+BkOnLECP8Q58OYeyJ40eoyF6Ee/En/JHlP6mIlRVXprF4BxtAvArV0AxtEuALd2ARhHuwDc2gVgHPX/hFv9fMBddjIGeKg/WCxlCsI46u+Ga5mCcJd+sIG9UkGAW32ZbApFAHhod4Bb3eo04h3god0BbiUHYApVCNjbHeBW+QDAXT4a7qg7r7e214057vg0QhkEHkoSwq0kIdydXw4/Q3H8hjYJ3vL0WConBJhCHQaOToeBrU0BljYFmEoVgHGUKgAPnREAt84IgLuqFgAYSUEOAHszDwuAtSkHAZhLGYIpdCLgKGUIHtocZG1zkLmUIRhxDnJU1RDA1uYga5uDzKUOwhTnIEfnxcDe5iBrcyQAYGlzkKkUYhhxDrKXQgxbSwLWUohhbknA1JKAEZOAvSUBW0sC1pYEzC0JmFoSMMJyCDhaFrK3JGDtyiFgaVnI3LKQqWUhI2YhR8tC9paFrC0LWVoWMrcsZGpZyIhZyNGykL2rSIGtlQHWVgZYWhlgbmWAqZUBRiwDHK0MsLcywNbKAGsOoNUhllaHmFsdYmp1iBHrEEerQ+w5gFYI2VodYm11iKXVIeYcQCuETK0QMmIh5MgBtELI3gohWyuErDmAVolZWiFkzgG0SszUKjGjfj6gVmKOVonZcwCtFbB9HQC+ozWDbz1bvGu9iKW1AuYcQOtFTLEX1GbIaFegN0OOHEBrhuw5gNYM2XIArRuz5gDacoB3bTnAEktxXQ4wfw0AvveM8b4tiJjSJOwLIsbXsAKeNeKCiOO3D+AVbUl0AfjGs8ZPbUnIdgFoa1LWC0BblfMuB9AeC1j6gqQE0J9LmC8AOYD2ZMb7i4bt2ZTpWoHfPoB7Tj2fXzT8N1X41vkq/QHOAAAAAElFTkSuQmCC",
  ProfilePictures = {
    pfp1,
    pfp2,
    pfp3,
    pfp4,
    pfp5,
    pfp6,
    pfp7,
    pfp8,
    pfp9,
    pfp10,
    pfp11,
    pfp12,
    pfp13,
    pfp14,
    pfp15,
    pfp16,
    pfp17,
    pfp18,
    pfp19,
    pfp20,
    pfp21,
    pfp22,
    pfp23,
    pfp24,
    pfp25,
    pfp26,
    pfp27,
    pfp28,
    pfp29,
    def: pfp,
  };
function getProfilePicture(k) {
  return typeof k == "number"
    ? ProfilePictures[`pfp${k}`] || pfp
    : k.toString();
}
async function applyCustomPfp(k) {
  const r = get_store_value(UserData);
  (r.acc.profilePicture = k), UserData.set(r);
}
const ProfilePicture_svelte_svelte_type_style_lang$1 = "";
function create_fragment$3G(k) {
  let r, p;
  return {
    c() {
      (r = element("div")),
        attr(r, "class", (p = "pfprenderer " + k[2] + " pfp svelte-ypct2")),
        set_style(r, "background-image", "url('" + k[0] + "')"),
        set_style(r, "height", k[1] + "px");
    },
    m(v, $) {
      insert(v, r, $);
    },
    p(v, [$]) {
      $ & 4 &&
        p !== (p = "pfprenderer " + v[2] + " pfp svelte-ypct2") &&
        attr(r, "class", p),
        $ & 1 && set_style(r, "background-image", "url('" + v[0] + "')"),
        $ & 2 && set_style(r, "height", v[1] + "px");
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      v && detach(r);
    },
  };
}
function instance$3t(k, r, p) {
  let { src: v } = r,
    { height: $ } = r,
    { className: S = "" } = r;
  return (
    (k.$$set = (x) => {
      "src" in x && p(0, (v = x.src)),
        "height" in x && p(1, ($ = x.height)),
        "className" in x && p(2, (S = x.className));
    }),
    [v, $, S]
  );
}
let ProfilePicture$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3t, create_fragment$3G, safe_not_equal, {
        src: 0,
        height: 1,
        className: 2,
      });
  }
};
function create_if_block$1m(k) {
  let r;
  return {
    c() {
      r = text("(developer)");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$3F(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L,
    U,
    j = (localStorage.getItem("arcos-server") || location.hostname) + "",
    N,
    q,
    R,
    Q,
    H;
  v = new ProfilePicture$1({ props: { src: k[0], height: 52 } });
  let G = k[2] && create_if_block$1m();
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        create_component(v.$$.fragment),
        ($ = space()),
        (S = element("button")),
        (S.textContent = "edit"),
        (x = space()),
        (I = element("div")),
        (F = element("p")),
        (O = text(k[1])),
        (L = space()),
        (U = element("p")),
        (N = text(j)),
        (q = space()),
        G && G.c(),
        attr(S, "class", "change material-icons-round"),
        attr(F, "class", "username"),
        attr(U, "class", "host"),
        attr(U, "data-caller", "accountpage-hostname"),
        attr(r, "class", "info");
    },
    m(V, K) {
      insert(V, r, K),
        append(r, p),
        mount_component(v, p, null),
        append(p, $),
        append(p, S),
        append(r, x),
        append(r, I),
        append(I, F),
        append(F, O),
        append(I, L),
        append(I, U),
        append(U, N),
        append(U, q),
        G && G.m(U, null),
        (R = !0),
        Q || ((H = listen(S, "click", k[3])), (Q = !0));
    },
    p(V, [K]) {
      const Y = {};
      K & 1 && (Y.src = V[0]),
        v.$set(Y),
        (!R || K & 2) && set_data(O, V[1]),
        V[2]
          ? G || ((G = create_if_block$1m()), G.c(), G.m(U, null))
          : G && (G.d(1), (G = null));
    },
    i(V) {
      R || (transition_in(v.$$.fragment, V), (R = !0));
    },
    o(V) {
      transition_out(v.$$.fragment, V), (R = !1);
    },
    d(V) {
      V && detach(r), destroy_component(v), G && G.d(), (Q = !1), H();
    },
  };
}
function instance$3s(k, r, p) {
  let v, $;
  component_subscribe(k, UserName, (I) => p(1, (v = I))),
    component_subscribe(k, DevModeOverride, (I) => p(2, ($ = I)));
  let S = "";
  UserData.subscribe((I) => {
    p(0, (S = getProfilePicture(I.acc.profilePicture)));
  });
  function x() {
    showOverlay("pfpSel", "SettingsApp");
  }
  return [S, v, $, x];
}
class Profile extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3s, create_fragment$3F, safe_not_equal, {});
  }
}
function create_fragment$3E(k) {
  let r, p, v, $, S;
  return (
    (p = new Profile({})),
    ($ = new DangerZone({})),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          create_component($.$$.fragment),
          attr(r, "class", "settingspage-account");
      },
      m(x, I) {
        insert(x, r, I),
          mount_component(p, r, null),
          append(r, v),
          mount_component($, r, null),
          (S = !0);
      },
      p: noop$1,
      i(x) {
        S ||
          (transition_in(p.$$.fragment, x),
          transition_in($.$$.fragment, x),
          (S = !0));
      },
      o(x) {
        transition_out(p.$$.fragment, x),
          transition_out($.$$.fragment, x),
          (S = !1);
      },
      d(x) {
        x && detach(r), destroy_component(p), destroy_component($);
      },
    }
  );
}
class Account extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$3E, safe_not_equal, {});
  }
}
const apps = "",
  logo$b = "./assets/testapp-fd93573e.svg",
  AppInfo$3 = "";
function isLoaded(k) {
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++) if (r[p] && r[p].id == k) return !0;
  return !1;
}
function isOpened(k) {
  const r = getWindow(k);
  return r ? r.opened : !1;
}
function isMinimized(k) {
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++)
    if (r[p] && r[p].id == k && r[p].state.windowState.min) return !0;
  return !1;
}
function isDisabled(k) {
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++)
    if (r[p] && r[p].id == k && r[p].disabled) return !0;
  return !1;
}
function isPopulatable(k) {
  return !k.disabled && !k.info.hidden && !k.info.custom;
}
function disableApp(k) {
  if (
    (Log({
      msg: `Disabling app ${k}`,
      source: "enabling.ts: disableApp",
      level: LogLevel.info,
    }),
    SystemApps.includes(k))
  )
    return errorMessage(
      "Can't disable application",
      `App "${k}" is a system application. System applications are core to ArcOS and cannot be disabled without breaking certain functionality.`,
      null,
      "AppLogic",
      { caption: "OK", action: () => {} }
    );
  const r = get_store_value(UserData);
  closeWindow(k), r.disabledApps.includes(k) || r.disabledApps.push(k);
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++) p[v].id == k && (p[v].disabled = !0);
  UserData.set(r), WindowStore.set(p), updateStores();
}
function enableApp(k) {
  Log({
    msg: `Enabling app ${k}`,
    source: "enabling.ts: enableApp",
    level: LogLevel.info,
  });
  const r = get_store_value(UserData);
  for (let v = 0; v < r.disabledApps.length; v++)
    r.disabledApps[v] == k && r.disabledApps.splice(v, 1);
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++) p[v].id == k && (p[v].disabled = !1);
  WindowStore.set(p), UserData.set(r), updateStores();
}
function create_if_block$1l(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O = k[0].info.name + "",
    L,
    U,
    j,
    N = k[0].info.description + "",
    q,
    R,
    Q,
    H,
    G,
    V,
    K,
    Y,
    J,
    Z,
    X,
    ee,
    te = (k[0].size.w || d) + "",
    re,
    fe,
    le = (k[0].size.h || d) + "",
    se,
    ae,
    oe,
    ie,
    ne,
    ce,
    ue = (k[0].minSize.w || d) + "",
    me,
    pe,
    de = (k[0].minSize.h || d) + "",
    ge,
    Ae,
    $e,
    ke,
    ve,
    be,
    xe = (k[0].maxSize.w || d) + "",
    Ce,
    Te,
    Ue = (k[0].maxSize.h || d) + "",
    Ke,
    nt,
    it,
    at,
    Ee,
    Ye,
    ot,
    De,
    je = (k[0].pos.x || d) + "",
    Je,
    st,
    Ne = (k[0].pos.y || d) + "",
    Ze,
    rt,
    Ie,
    Xe,
    lt,
    We,
    Se,
    Fe,
    ct,
    qe,
    ut,
    Oe,
    pt,
    Re,
    ft,
    Be,
    dt,
    Qe,
    mt,
    Le,
    et,
    _t,
    Me,
    Pe,
    gt,
    He,
    ht,
    ze,
    bt,
    Ge,
    tt,
    At;
  function vt(he, we) {
    return he[0].parentId ? create_if_block_1$q : create_else_block$r;
  }
  let Ve = vt(k),
    ye = Ve(k);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (I = element("div")),
        (F = element("p")),
        (L = text(O)),
        (U = space()),
        (j = element("p")),
        (q = text(N)),
        (R = space()),
        ye.c(),
        (Q = space()),
        (H = element("div")),
        (G = element("input")),
        (K = space()),
        (Y = element("div")),
        (J = element("div")),
        (Z = element("div")),
        (Z.textContent = "Size:"),
        (X = space()),
        (ee = element("div")),
        (re = text(te)),
        (fe = text("x")),
        (se = text(le)),
        (ae = space()),
        (oe = element("div")),
        (ie = element("div")),
        (ie.textContent = "Minimal size:"),
        (ne = space()),
        (ce = element("div")),
        (me = text(ue)),
        (pe = text("x")),
        (ge = text(de)),
        (Ae = space()),
        ($e = element("div")),
        (ke = element("div")),
        (ke.textContent = "Maximal size:"),
        (ve = space()),
        (be = element("div")),
        (Ce = text(xe)),
        (Te = text("x")),
        (Ke = text(Ue)),
        (nt = space()),
        (it = element("hr")),
        (at = space()),
        (Ee = element("div")),
        (Ye = element("div")),
        (Ye.textContent = "Start position:"),
        (ot = space()),
        (De = element("div")),
        (Je = text(je)),
        (st = text("x")),
        (Ze = text(Ne)),
        (rt = space()),
        (Ie = element("div")),
        (Xe = element("div")),
        (Xe.textContent = "Window controls:"),
        (lt = space()),
        (We = element("div")),
        (Se = element("div")),
        (Fe = element("button")),
        (ct = text("minimize")),
        (ut = space()),
        (Oe = element("button")),
        (pt = text("crop_square")),
        (ft = space()),
        (Be = element("button")),
        (dt = text("close")),
        (mt = space()),
        (Le = element("div")),
        (et = element("div")),
        (et.textContent = "Actions"),
        (_t = space()),
        (Me = element("div")),
        (Pe = element("button")),
        (gt = text("Open")),
        (ht = space()),
        (ze = element("button")),
        (bt = text("Poke")),
        src_url_equal(v.src, ($ = getAppIcon(k[0]))) || attr(v, "src", $),
        attr(v, "alt", (S = k[0].info.name)),
        attr(F, "class", "appname"),
        attr(j, "class", "description"),
        attr(G, "type", "checkbox"),
        attr(G, "class", "switch"),
        (G.disabled = V = SystemApps.includes(k[3])),
        attr(H, "class", "actions"),
        attr(r, "class", "name"),
        attr(ee, "class", "value"),
        attr(J, "class", "property"),
        attr(ce, "class", "value"),
        attr(oe, "class", "property"),
        attr(be, "class", "value"),
        attr($e, "class", "property"),
        attr(De, "class", "value"),
        attr(Ee, "class", "property"),
        attr(Fe, "class", "material-icons-round"),
        (Fe.disabled = qe = !k[0].controls.min),
        attr(Oe, "class", "material-icons-round"),
        (Oe.disabled = Re = !k[0].controls.max),
        attr(Be, "class", "material-icons-round"),
        (Be.disabled = Qe = !k[0].controls.cls),
        attr(Se, "class", "controls"),
        attr(We, "class", "value"),
        attr(Ie, "class", "property"),
        (Pe.disabled = He = k[0].opened || k[0].disabled),
        (ze.disabled = Ge = k[0].disabled || k[2]),
        attr(Me, "class", "value"),
        attr(Le, "class", "property"),
        attr(Y, "class", "properties");
    },
    m(he, we) {
      insert(he, r, we),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, I),
        append(I, F),
        append(F, L),
        append(I, U),
        append(I, j),
        append(j, q),
        append(j, R),
        ye.m(j, null),
        append(r, Q),
        append(r, H),
        append(H, G),
        (G.checked = k[1]),
        insert(he, K, we),
        insert(he, Y, we),
        append(Y, J),
        append(J, Z),
        append(J, X),
        append(J, ee),
        append(ee, re),
        append(ee, fe),
        append(ee, se),
        append(Y, ae),
        append(Y, oe),
        append(oe, ie),
        append(oe, ne),
        append(oe, ce),
        append(ce, me),
        append(ce, pe),
        append(ce, ge),
        append(Y, Ae),
        append(Y, $e),
        append($e, ke),
        append($e, ve),
        append($e, be),
        append(be, Ce),
        append(be, Te),
        append(be, Ke),
        append(Y, nt),
        append(Y, it),
        append(Y, at),
        append(Y, Ee),
        append(Ee, Ye),
        append(Ee, ot),
        append(Ee, De),
        append(De, Je),
        append(De, st),
        append(De, Ze),
        append(Y, rt),
        append(Y, Ie),
        append(Ie, Xe),
        append(Ie, lt),
        append(Ie, We),
        append(We, Se),
        append(Se, Fe),
        append(Fe, ct),
        append(Se, ut),
        append(Se, Oe),
        append(Oe, pt),
        append(Se, ft),
        append(Se, Be),
        append(Be, dt),
        append(Y, mt),
        append(Y, Le),
        append(Le, et),
        append(Le, _t),
        append(Le, Me),
        append(Me, Pe),
        append(Pe, gt),
        append(Me, ht),
        append(Me, ze),
        append(ze, bt),
        tt ||
          ((At = [
            listen(G, "change", k[5]),
            listen(G, "change", k[4]),
            listen(Pe, "click", k[6]),
            listen(ze, "click", k[7]),
          ]),
          (tt = !0));
    },
    p(he, we) {
      we & 1 &&
        !src_url_equal(v.src, ($ = getAppIcon(he[0]))) &&
        attr(v, "src", $),
        we & 1 && S !== (S = he[0].info.name) && attr(v, "alt", S),
        we & 1 && O !== (O = he[0].info.name + "") && set_data(L, O),
        we & 1 && N !== (N = he[0].info.description + "") && set_data(q, N),
        Ve === (Ve = vt(he)) && ye
          ? ye.p(he, we)
          : (ye.d(1), (ye = Ve(he)), ye && (ye.c(), ye.m(j, null))),
        we & 8 && V !== (V = SystemApps.includes(he[3])) && (G.disabled = V),
        we & 2 && (G.checked = he[1]),
        we & 1 && te !== (te = (he[0].size.w || d) + "") && set_data(re, te),
        we & 1 && le !== (le = (he[0].size.h || d) + "") && set_data(se, le),
        we & 1 && ue !== (ue = (he[0].minSize.w || d) + "") && set_data(me, ue),
        we & 1 && de !== (de = (he[0].minSize.h || d) + "") && set_data(ge, de),
        we & 1 && xe !== (xe = (he[0].maxSize.w || d) + "") && set_data(Ce, xe),
        we & 1 && Ue !== (Ue = (he[0].maxSize.h || d) + "") && set_data(Ke, Ue),
        we & 1 && je !== (je = (he[0].pos.x || d) + "") && set_data(Je, je),
        we & 1 && Ne !== (Ne = (he[0].pos.y || d) + "") && set_data(Ze, Ne),
        we & 1 && qe !== (qe = !he[0].controls.min) && (Fe.disabled = qe),
        we & 1 && Re !== (Re = !he[0].controls.max) && (Oe.disabled = Re),
        we & 1 && Qe !== (Qe = !he[0].controls.cls) && (Be.disabled = Qe),
        we & 1 &&
          He !== (He = he[0].opened || he[0].disabled) &&
          (Pe.disabled = He),
        we & 5 && Ge !== (Ge = he[0].disabled || he[2]) && (ze.disabled = Ge);
    },
    d(he) {
      he && detach(r),
        ye.d(),
        he && detach(K),
        he && detach(Y),
        (tt = !1),
        run_all(At);
    },
  };
}
function create_else_block$r(k) {
  let r,
    p = k[0].id + "",
    v,
    $;
  return {
    c() {
      (r = text("(")), (v = text(p)), ($ = text(")"));
    },
    m(S, x) {
      insert(S, r, x), insert(S, v, x), insert(S, $, x);
    },
    p(S, x) {
      x & 1 && p !== (p = S[0].id + "") && set_data(v, p);
    },
    d(S) {
      S && detach(r), S && detach(v), S && detach($);
    },
  };
}
function create_if_block_1$q(k) {
  let r,
    p = k[0].parentId + "",
    v,
    $,
    S = k[0].id + "",
    x,
    I;
  return {
    c() {
      (r = text("(")),
        (v = text(p)),
        ($ = text(".")),
        (x = text(S)),
        (I = text(")"));
    },
    m(F, O) {
      insert(F, r, O),
        insert(F, v, O),
        insert(F, $, O),
        insert(F, x, O),
        insert(F, I, O);
    },
    p(F, O) {
      O & 1 && p !== (p = F[0].parentId + "") && set_data(v, p),
        O & 1 && S !== (S = F[0].id + "") && set_data(x, S);
    },
    d(F) {
      F && detach(r),
        F && detach(v),
        F && detach($),
        F && detach(x),
        F && detach(I);
    },
  };
}
function create_fragment$3D(k) {
  let r,
    p = k[0] && create_if_block$1l(k);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, $) {
      p && p.m(v, $), insert(v, r, $);
    },
    p(v, [$]) {
      v[0]
        ? p
          ? p.p(v, $)
          : ((p = create_if_block$1l(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
let d = "Auto";
function instance$3r(k, r, p) {
  let v;
  component_subscribe(k, AppInfoId, (j) => p(3, (v = j)));
  let $,
    S = !0,
    x = !1;
  function I() {
    S ? enableApp(v) : disableApp(v),
      p(0, ($ = getWindow(v))),
      $ && p(1, (S = !getWindow(v).disabled));
  }
  AppInfoId.subscribe(F), WindowStore.subscribe(F);
  function F() {
    v &&
      (p(0, ($ = getWindow(v))),
      $ &&
        (p(1, (S = !getWindow(v).disabled)),
        p(2, (x = isDisabled("AppPoker")))));
  }
  function O() {
    (S = this.checked), p(1, S);
  }
  return [$, S, x, v, I, O, () => openWindow(v), () => AppPokerData.set($)];
}
let AppInfo$2 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3r, create_fragment$3D, safe_not_equal, {});
  }
};
const AppInfo$1 = {
    info: {
      name: "Application Info",
      description: "View information about an application",
      builtin: !0,
      version: "1.0.0",
      author: "Izaak Kuipers",
      hidden: !0,
      icon: logo$b,
    },
    size: { w: 500, h: 450 },
    pos: { x: 30, y: 40 },
    minSize: { w: 500, h: 450 },
    maxSize: { w: 500, h: 450 },
    controls: { min: !0, max: !1, cls: !0 },
    state: {
      headless: !1,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: AppInfo$2,
    glass: !1,
    events: {
      close() {
        AppInfoId.set(null);
      },
    },
  },
  AppInfoId = writable(null),
  logo$a = "./assets/appmanager-60c1ea43.svg",
  AppManager$2 = "",
  AppPokerProperties = [
    {
      caption: "Minimize",
      action: (k) => {
        minimizeWindow(k);
      },
      getter: (k) => k.state.windowState.min,
    },
    {
      caption: "Maximize",
      action: (k) => {
        maximizeWindow(k);
      },
      getter: (k) => k.state.windowState.max,
    },
    {
      caption: "Close",
      action: (k) => {
        isOpened(k.id) ? closeWindow(k.id) : openWindow(k.id);
      },
      getter: (k) => !isOpened(k.id),
    },
    {
      caption: "Headless",
      action: (k) => {
        (k.state.headless = !k.state.headless), updateStores();
      },
      getter: (k) => k.state.headless,
    },
    {
      caption: "Fullscreen",
      action: (k) => {
        (k.state.windowState.fll = !k.state.windowState.fll), updateStores();
      },
      getter: (k) => k.state.windowState.fll,
    },
    {
      caption: "Resizable",
      action: (k) => {
        (k.state.resizable = !k.state.resizable), updateStores();
      },
      getter: (k) => k.state.resizable,
    },
    {
      caption: "Glass",
      action: (k) => {
        (k.glass = !k.glass), updateStores();
      },
      getter: (k) => k.glass,
    },
  ],
  staticAppManActions = [
    {
      caption: "Run...",
      icon: "directions_run",
      action: () => {
        showOverlay("run", "AppMan");
      },
    },
  ],
  appManSelected = writable();
function create_if_block$1k(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I = k[0].info.name + "",
    F,
    O,
    L,
    U,
    j,
    N,
    q = k[1] && create_if_block_2$7();
  function R(G, V) {
    return G[0].parentId ? create_if_block_1$p : create_else_block$q;
  }
  let Q = R(k),
    H = Q(k);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (x = element("div")),
        (F = text(I)),
        (O = space()),
        q && q.c(),
        (L = space()),
        (U = element("div")),
        H.c(),
        src_url_equal(
          v.src,
          ($ = getOriginalIcon(k[0].id) || getAppIcon(k[0]))
        ) || attr(v, "src", $),
        attr(v, "alt", ""),
        attr(x, "class", "appname"),
        attr(U, "class", "id"),
        attr(r, "class", "appinstance"),
        toggle_class(r, "closed", !k[0].opened),
        toggle_class(r, "selected", k[2] == k[0].id);
    },
    m(G, V) {
      insert(G, r, V),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, x),
        append(x, F),
        append(x, O),
        q && q.m(x, null),
        append(r, L),
        append(r, U),
        H.m(U, null),
        j || ((N = listen(r, "click", k[3])), (j = !0));
    },
    p(G, V) {
      V & 1 &&
        !src_url_equal(
          v.src,
          ($ = getOriginalIcon(G[0].id) || getAppIcon(G[0]))
        ) &&
        attr(v, "src", $),
        V & 1 && I !== (I = G[0].info.name + "") && set_data(F, I),
        G[1]
          ? q || ((q = create_if_block_2$7()), q.c(), q.m(x, null))
          : q && (q.d(1), (q = null)),
        Q === (Q = R(G)) && H
          ? H.p(G, V)
          : (H.d(1), (H = Q(G)), H && (H.c(), H.m(U, null))),
        V & 1 && toggle_class(r, "closed", !G[0].opened),
        V & 5 && toggle_class(r, "selected", G[2] == G[0].id);
    },
    d(G) {
      G && detach(r), q && q.d(), H.d(), (j = !1), N();
    },
  };
}
function create_if_block_2$7(k) {
  let r;
  return {
    c() {
      r = text("(Dialog)");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_else_block$q(k) {
  let r = k[0].id + "",
    p;
  return {
    c() {
      p = text(r);
    },
    m(v, $) {
      insert(v, p, $);
    },
    p(v, $) {
      $ & 1 && r !== (r = v[0].id + "") && set_data(p, r);
    },
    d(v) {
      v && detach(p);
    },
  };
}
function create_if_block_1$p(k) {
  let r = k[0].parentId + "",
    p,
    v,
    $ = k[0].id + "",
    S;
  return {
    c() {
      (p = text(r)), (v = text(".")), (S = text($));
    },
    m(x, I) {
      insert(x, p, I), insert(x, v, I), insert(x, S, I);
    },
    p(x, I) {
      I & 1 && r !== (r = x[0].parentId + "") && set_data(p, r),
        I & 1 && $ !== ($ = x[0].id + "") && set_data(S, $);
    },
    d(x) {
      x && detach(p), x && detach(v), x && detach(S);
    },
  };
}
function create_fragment$3C(k) {
  let r = k[0] && ((!isDisabled(k[0].id) && isOpened(k[0].id)) || k[1]),
    p,
    v = r && create_if_block$1k(k);
  return {
    c() {
      v && v.c(), (p = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, p, S);
    },
    p($, [S]) {
      S & 3 &&
        (r = $[0] && ((!isDisabled($[0].id) && isOpened($[0].id)) || $[1])),
        r
          ? v
            ? v.p($, S)
            : ((v = create_if_block$1k($)), v.c(), v.m(p.parentNode, p))
          : v && (v.d(1), (v = null));
    },
    i: noop$1,
    o: noop$1,
    d($) {
      v && v.d($), $ && detach(p);
    },
  };
}
function instance$3q(k, r, p) {
  let v;
  component_subscribe(k, appManSelected, (I) => p(2, (v = I)));
  let { app: $ } = r,
    { error: S = !1 } = r;
  function x() {
    set_store_value(appManSelected, (v = $.id), v);
  }
  return (
    (k.$$set = (I) => {
      "app" in I && p(0, ($ = I.app)), "error" in I && p(1, (S = I.error));
    }),
    [$, S, v, x]
  );
}
let App$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3q, create_fragment$3C, safe_not_equal, {
        app: 0,
        error: 1,
      });
  }
};
const dummyIcon = "./assets/default-fc91861d.svg";
function create_if_block$1j(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I = k[1].info.name + "",
    F,
    O,
    L,
    U = k[2].id + "",
    j,
    N,
    q;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (x = element("div")),
        (F = text(I)),
        (O = space()),
        (L = element("div")),
        (j = text(U)),
        (N = text(".")),
        (q = text(k[0])),
        src_url_equal(v.src, ($ = dummyIcon)) || attr(v, "src", $),
        attr(v, "alt", ""),
        attr(x, "class", "appname"),
        attr(L, "class", "id"),
        attr(r, "class", "appinstance"),
        toggle_class(r, "closed", !k[1].show);
    },
    m(R, Q) {
      insert(R, r, Q),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, x),
        append(x, F),
        append(r, O),
        append(r, L),
        append(L, j),
        append(L, N),
        append(L, q);
    },
    p(R, Q) {
      Q & 2 && I !== (I = R[1].info.name + "") && set_data(F, I),
        Q & 4 && U !== (U = R[2].id + "") && set_data(j, U),
        Q & 1 && set_data(q, R[0]),
        Q & 2 && toggle_class(r, "closed", !R[1].show);
    },
    d(R) {
      R && detach(r);
    },
  };
}
function create_fragment$3B(k) {
  let r,
    p = k[1] && isOpened(k[2].id),
    v = p && create_if_block$1j(k);
  return {
    c() {
      (r = element("div")), v && v.c(), attr(r, "class", "indent");
    },
    m($, S) {
      insert($, r, S), v && v.m(r, null);
    },
    p($, [S]) {
      S & 6 && (p = $[1] && isOpened($[2].id)),
        p
          ? v
            ? v.p($, S)
            : ((v = create_if_block$1j($)), v.c(), v.m(r, null))
          : v && (v.d(1), (v = null));
    },
    i: noop$1,
    o: noop$1,
    d($) {
      $ && detach(r), v && v.d();
    },
  };
}
function instance$3p(k, r, p) {
  let { id: v } = r,
    { overlay: $ } = r,
    { parent: S } = r;
  return (
    (k.$$set = (x) => {
      "id" in x && p(0, (v = x.id)),
        "overlay" in x && p(1, ($ = x.overlay)),
        "parent" in x && p(2, (S = x.parent));
    }),
    [v, $, S]
  );
}
class OverlayApp extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3p, create_fragment$3B, safe_not_equal, {
        id: 0,
        overlay: 1,
        parent: 2,
      });
  }
}
function get_each_context$O(k, r, p) {
  const v = k.slice();
  return (v[3] = r[p]), v;
}
function get_each_context_1$c(k, r, p) {
  const v = k.slice();
  return (v[6] = r[p]), v;
}
function create_if_block$1i(k) {
  let r, p, v, $, S;
  p = new App$1({ props: { app: k[0], error: k[2] } });
  let x = k[0].children && create_if_block_2$6(k),
    I = k[0].overlays && create_if_block_1$o(k);
  return {
    c() {
      (r = element("div")),
        create_component(p.$$.fragment),
        (v = space()),
        x && x.c(),
        ($ = space()),
        I && I.c(),
        toggle_class(r, "indent", !k[1]);
    },
    m(F, O) {
      insert(F, r, O),
        mount_component(p, r, null),
        append(r, v),
        x && x.m(r, null),
        append(r, $),
        I && I.m(r, null),
        (S = !0);
    },
    p(F, O) {
      const L = {};
      O & 1 && (L.app = F[0]),
        O & 4 && (L.error = F[2]),
        p.$set(L),
        F[0].children
          ? x
            ? (x.p(F, O), O & 1 && transition_in(x, 1))
            : ((x = create_if_block_2$6(F)),
              x.c(),
              transition_in(x, 1),
              x.m(r, $))
          : x &&
            (group_outros(),
            transition_out(x, 1, 1, () => {
              x = null;
            }),
            check_outros()),
        F[0].overlays
          ? I
            ? (I.p(F, O), O & 1 && transition_in(I, 1))
            : ((I = create_if_block_1$o(F)),
              I.c(),
              transition_in(I, 1),
              I.m(r, null))
          : I &&
            (group_outros(),
            transition_out(I, 1, 1, () => {
              I = null;
            }),
            check_outros()),
        (!S || O & 2) && toggle_class(r, "indent", !F[1]);
    },
    i(F) {
      S ||
        (transition_in(p.$$.fragment, F),
        transition_in(x),
        transition_in(I),
        (S = !0));
    },
    o(F) {
      transition_out(p.$$.fragment, F),
        transition_out(x),
        transition_out(I),
        (S = !1);
    },
    d(F) {
      F && detach(r), destroy_component(p), x && x.d(), I && I.d();
    },
  };
}
function create_if_block_2$6(k) {
  let r,
    p,
    v = Object.keys(k[0].children),
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block_1$c(get_each_context_1$c(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = empty();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 1) {
        v = Object.keys(x[0].children);
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_1$c(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block_1$c(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_each_block_1$c(k) {
  let r, p;
  return (
    (r = new Branch_1$1({ props: { window: getWindow(k[6]) } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.window = getWindow(v[6])), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_1$o(k) {
  let r,
    p,
    v = Object.entries(k[0].overlays),
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$O(get_each_context$O(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = empty();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 1) {
        v = Object.entries(x[0].overlays);
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$O(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$O(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_each_block$O(k) {
  let r, p;
  return (
    (r = new OverlayApp({
      props: { overlay: k[3][1], parent: k[0], id: k[3][0] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.overlay = v[3][1]),
          $ & 1 && (S.parent = v[0]),
          $ & 1 && (S.id = v[3][0]),
          r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$3A(k) {
  let r,
    p,
    v = k[0] && create_if_block$1i(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, [S]) {
      $[0]
        ? v
          ? (v.p($, S), S & 1 && transition_in(v, 1))
          : ((v = create_if_block$1i($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function instance$3o(k, r, p) {
  let { window: v } = r,
    { top: $ = !1 } = r,
    { error: S = !1 } = r;
  return (
    (k.$$set = (x) => {
      "window" in x && p(0, (v = x.window)),
        "top" in x && p(1, ($ = x.top)),
        "error" in x && p(2, (S = x.error));
    }),
    [v, $, S]
  );
}
let Branch_1$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3o, create_fragment$3A, safe_not_equal, {
        window: 0,
        top: 1,
        error: 2,
      });
  }
};
function get_each_context$N(k, r, p) {
  const v = k.slice();
  return (v[2] = r[p]), v;
}
function get_each_context_1$b(k, r, p) {
  const v = k.slice();
  return (v[5] = r[p]), v;
}
function create_if_block$1h(k) {
  let r, p;
  return (
    (r = new Branch_1$1({ props: { window: k[5], top: !0 } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 2 && (S.window = v[5]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block_1$b(k) {
  let r,
    p,
    v = !k[5].parentId && create_if_block$1h(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, S) {
      $[5].parentId
        ? v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros())
        : v
        ? (v.p($, S), S & 2 && transition_in(v, 1))
        : ((v = create_if_block$1h($)),
          v.c(),
          transition_in(v, 1),
          v.m(r.parentNode, r));
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function create_each_block$N(k) {
  let r, p;
  return (
    (r = new Branch_1$1({ props: { window: k[2], top: !0, error: !0 } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.window = v[2]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$3z(k) {
  let r,
    p,
    v,
    $ = k[1],
    S = [];
  for (let L = 0; L < $.length; L += 1)
    S[L] = create_each_block_1$b(get_each_context_1$b(k, $, L));
  const x = (L) =>
    transition_out(S[L], 1, 1, () => {
      S[L] = null;
    });
  let I = k[0],
    F = [];
  for (let L = 0; L < I.length; L += 1)
    F[L] = create_each_block$N(get_each_context$N(k, I, L));
  const O = (L) =>
    transition_out(F[L], 1, 1, () => {
      F[L] = null;
    });
  return {
    c() {
      r = element("div");
      for (let L = 0; L < S.length; L += 1) S[L].c();
      p = space();
      for (let L = 0; L < F.length; L += 1) F[L].c();
      attr(r, "class", "apps");
    },
    m(L, U) {
      insert(L, r, U);
      for (let j = 0; j < S.length; j += 1) S[j] && S[j].m(r, null);
      append(r, p);
      for (let j = 0; j < F.length; j += 1) F[j] && F[j].m(r, null);
      v = !0;
    },
    p(L, [U]) {
      if (U & 2) {
        $ = L[1];
        let j;
        for (j = 0; j < $.length; j += 1) {
          const N = get_each_context_1$b(L, $, j);
          S[j]
            ? (S[j].p(N, U), transition_in(S[j], 1))
            : ((S[j] = create_each_block_1$b(N)),
              S[j].c(),
              transition_in(S[j], 1),
              S[j].m(r, p));
        }
        for (group_outros(), j = $.length; j < S.length; j += 1) x(j);
        check_outros();
      }
      if (U & 1) {
        I = L[0];
        let j;
        for (j = 0; j < I.length; j += 1) {
          const N = get_each_context$N(L, I, j);
          F[j]
            ? (F[j].p(N, U), transition_in(F[j], 1))
            : ((F[j] = create_each_block$N(N)),
              F[j].c(),
              transition_in(F[j], 1),
              F[j].m(r, null));
        }
        for (group_outros(), j = I.length; j < F.length; j += 1) O(j);
        check_outros();
      }
    },
    i(L) {
      if (!v) {
        for (let U = 0; U < $.length; U += 1) transition_in(S[U]);
        for (let U = 0; U < I.length; U += 1) transition_in(F[U]);
        v = !0;
      }
    },
    o(L) {
      S = S.filter(Boolean);
      for (let U = 0; U < S.length; U += 1) transition_out(S[U]);
      F = F.filter(Boolean);
      for (let U = 0; U < F.length; U += 1) transition_out(F[U]);
      v = !1;
    },
    d(L) {
      L && detach(r), destroy_each(S, L), destroy_each(F, L);
    },
  };
}
function instance$3n(k, r, p) {
  let v;
  component_subscribe(k, WindowStore, (S) => p(1, (v = S)));
  let $ = [];
  return (
    ErrorWindowStore.subscribe((S) => {
      p(0, ($ = S));
    }),
    [$, v]
  );
}
let AppList$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3n, create_fragment$3z, safe_not_equal, {});
  }
};
function create_if_block$1g(k) {
  let r,
    p,
    v = getWindow(k[0]).snapped ? "yes" : "no",
    $;
  return {
    c() {
      (r = element("div")),
        (p = text("Snapped: ")),
        ($ = text(v)),
        attr(r, "class", "section");
    },
    m(S, x) {
      insert(S, r, x), append(r, p), append(r, $);
    },
    p(S, x) {
      x & 1 &&
        v !== (v = getWindow(S[0]).snapped ? "yes" : "no") &&
        set_data($, v);
    },
    d(S) {
      S && detach(r);
    },
  };
}
function create_fragment$3y(k) {
  let r,
    p,
    v = k[0] && !k[0].startsWith("error_"),
    $,
    S,
    x,
    I = k[1].length + "",
    F,
    O,
    L,
    U,
    j = k[2].length + "",
    N,
    q,
    R,
    Q,
    H = k[3].length + "",
    G,
    V = v && create_if_block$1g(k);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        V && V.c(),
        ($ = space()),
        (S = element("div")),
        (x = text("Running: ")),
        (F = text(I)),
        (O = space()),
        (L = element("div")),
        (U = text("Loaded: ")),
        (N = text(j)),
        (q = space()),
        (R = element("div")),
        (Q = text("Dialogs: ")),
        (G = text(H)),
        attr(S, "class", "section"),
        attr(L, "class", "section"),
        attr(R, "class", "section"),
        attr(p, "class", "right"),
        attr(r, "class", "bottombar");
    },
    m(K, Y) {
      insert(K, r, Y),
        append(r, p),
        V && V.m(p, null),
        append(p, $),
        append(p, S),
        append(S, x),
        append(S, F),
        append(p, O),
        append(p, L),
        append(L, U),
        append(L, N),
        append(p, q),
        append(p, R),
        append(R, Q),
        append(R, G);
    },
    p(K, [Y]) {
      Y & 1 && (v = K[0] && !K[0].startsWith("error_")),
        v
          ? V
            ? V.p(K, Y)
            : ((V = create_if_block$1g(K)), V.c(), V.m(p, $))
          : V && (V.d(1), (V = null)),
        Y & 2 && I !== (I = K[1].length + "") && set_data(F, I),
        Y & 4 && j !== (j = K[2].length + "") && set_data(N, j),
        Y & 8 && H !== (H = K[3].length + "") && set_data(G, H);
    },
    i: noop$1,
    o: noop$1,
    d(K) {
      K && detach(r), V && V.d();
    },
  };
}
function instance$3m(k, r, p) {
  let v, $, S, x;
  return (
    component_subscribe(k, appManSelected, (I) => p(0, (v = I))),
    component_subscribe(k, OpenedStore, (I) => p(1, ($ = I))),
    component_subscribe(k, WindowStore, (I) => p(2, (S = I))),
    component_subscribe(k, ErrorWindowStore, (I) => p(3, (x = I))),
    [v, $, S, x]
  );
}
class BottomBar extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3m, create_fragment$3y, safe_not_equal, {});
  }
}
function create_fragment$3x(k) {
  let r,
    p,
    v = k[0].icon + "",
    $,
    S,
    x,
    I = k[0].caption + "",
    F,
    O,
    L;
  return {
    c() {
      (r = element("button")),
        (p = element("span")),
        ($ = text(v)),
        (S = space()),
        (x = element("p")),
        (F = text(I)),
        attr(p, "class", "material-icons-round"),
        attr(x, "class", "caption"),
        attr(r, "class", "action");
    },
    m(U, j) {
      insert(U, r, j),
        append(r, p),
        append(p, $),
        append(r, S),
        append(r, x),
        append(x, F),
        O ||
          ((L = listen(r, "click", function () {
            is_function(k[0].action) && k[0].action.apply(this, arguments);
          })),
          (O = !0));
    },
    p(U, [j]) {
      (k = U),
        j & 1 && v !== (v = k[0].icon + "") && set_data($, v),
        j & 1 && I !== (I = k[0].caption + "") && set_data(F, I);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r), (O = !1), L();
    },
  };
}
function instance$3l(k, r, p) {
  let { action: v } = r;
  return (
    (k.$$set = ($) => {
      "action" in $ && p(0, (v = $.action));
    }),
    [v]
  );
}
let Action$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3l, create_fragment$3x, safe_not_equal, {
        action: 0,
      });
  }
};
function create_fragment$3w(k) {
  let r, p, v, $, S, x, I;
  return {
    c() {
      (r = element("button")),
        (p = element("span")),
        (p.textContent = "settings"),
        (v = space()),
        ($ = element("p")),
        ($.textContent = "App info"),
        attr(p, "class", "material-icons-round"),
        attr($, "class", "caption"),
        attr(r, "class", "action"),
        (r.disabled = S = !k[0]);
    },
    m(F, O) {
      insert(F, r, O),
        append(r, p),
        append(r, v),
        append(r, $),
        x || ((I = listen(r, "click", k[1])), (x = !0));
    },
    p(F, [O]) {
      O & 1 && S !== (S = !F[0]) && (r.disabled = S);
    },
    i: noop$1,
    o: noop$1,
    d(F) {
      F && detach(r), (x = !1), I();
    },
  };
}
function instance$3k(k, r, p) {
  let v;
  component_subscribe(k, appManSelected, (S) => p(0, (v = S)));
  function $() {
    AppInfoId.set(v), openWindow("AppInfo");
  }
  return [v, $];
}
class AppInfo extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3k, create_fragment$3w, safe_not_equal, {});
  }
}
function create_fragment$3v(k) {
  let r, p, v, $, S, x, I;
  return {
    c() {
      (r = element("button")),
        (p = element("span")),
        (p.textContent = "close"),
        (v = space()),
        ($ = element("p")),
        ($.textContent = "Close"),
        attr(p, "class", "material-icons-round"),
        attr($, "class", "caption"),
        attr(r, "class", "action"),
        (r.disabled = S = !k[0]);
    },
    m(F, O) {
      insert(F, r, O),
        append(r, p),
        append(r, v),
        append(r, $),
        x || ((I = listen(r, "click", k[1])), (x = !0));
    },
    p(F, [O]) {
      O & 1 && S !== (S = !F[0]) && (r.disabled = S);
    },
    i: noop$1,
    o: noop$1,
    d(F) {
      F && detach(r), (x = !1), I();
    },
  };
}
function instance$3j(k, r, p) {
  let v;
  component_subscribe(k, appManSelected, (S) => p(0, (v = S)));
  function $() {
    closeWindow(v), set_store_value(appManSelected, (v = null), v);
  }
  return [v, $];
}
class Close extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3j, create_fragment$3v, safe_not_equal, {});
  }
}
function create_fragment$3u(k) {
  let r, p, v, $, S, x, I;
  return {
    c() {
      (r = element("button")),
        (p = element("span")),
        (p.textContent = "block"),
        (v = space()),
        ($ = element("p")),
        ($.textContent = "Disable"),
        attr(p, "class", "material-icons-round"),
        attr($, "class", "caption"),
        attr(r, "class", "action"),
        (r.disabled = S = !k[0]);
    },
    m(F, O) {
      insert(F, r, O),
        append(r, p),
        append(r, v),
        append(r, $),
        x || ((I = listen(r, "click", k[1])), (x = !0));
    },
    p(F, [O]) {
      O & 1 && S !== (S = !F[0]) && (r.disabled = S);
    },
    i: noop$1,
    o: noop$1,
    d(F) {
      F && detach(r), (x = !1), I();
    },
  };
}
function instance$3i(k, r, p) {
  let v;
  component_subscribe(k, appManSelected, (S) => p(0, (v = S)));
  function $() {
    disableApp(v);
  }
  return [v, $];
}
class DisableApp extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3i, create_fragment$3u, safe_not_equal, {});
  }
}
function get_each_context$M(k, r, p) {
  const v = k.slice();
  return (v[0] = r[p]), v;
}
function create_each_block$M(k) {
  let r, p;
  return (
    (r = new Action$1({ props: { action: k[0] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$3t(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N;
  (v = new AppInfo({})), (I = new DisableApp({})), (O = new Close({}));
  let q = staticAppManActions,
    R = [];
  for (let H = 0; H < q.length; H += 1)
    R[H] = create_each_block$M(get_each_context$M(k, q, H));
  const Q = (H) =>
    transition_out(R[H], 1, 1, () => {
      R[H] = null;
    });
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        create_component(v.$$.fragment),
        ($ = space()),
        (S = element("div")),
        (x = space()),
        create_component(I.$$.fragment),
        (F = space()),
        create_component(O.$$.fragment),
        (L = space()),
        (U = element("div")),
        (j = space());
      for (let H = 0; H < R.length; H += 1) R[H].c();
      attr(S, "class", "sep"),
        attr(U, "class", "sep"),
        attr(p, "class", "actions"),
        attr(r, "class", "topbar");
    },
    m(H, G) {
      insert(H, r, G),
        append(r, p),
        mount_component(v, p, null),
        append(p, $),
        append(p, S),
        append(p, x),
        mount_component(I, p, null),
        append(p, F),
        mount_component(O, p, null),
        append(p, L),
        append(p, U),
        append(p, j);
      for (let V = 0; V < R.length; V += 1) R[V] && R[V].m(p, null);
      N = !0;
    },
    p(H, [G]) {
      if (G & 0) {
        q = staticAppManActions;
        let V;
        for (V = 0; V < q.length; V += 1) {
          const K = get_each_context$M(H, q, V);
          R[V]
            ? (R[V].p(K, G), transition_in(R[V], 1))
            : ((R[V] = create_each_block$M(K)),
              R[V].c(),
              transition_in(R[V], 1),
              R[V].m(p, null));
        }
        for (group_outros(), V = q.length; V < R.length; V += 1) Q(V);
        check_outros();
      }
    },
    i(H) {
      if (!N) {
        transition_in(v.$$.fragment, H),
          transition_in(I.$$.fragment, H),
          transition_in(O.$$.fragment, H);
        for (let G = 0; G < q.length; G += 1) transition_in(R[G]);
        N = !0;
      }
    },
    o(H) {
      transition_out(v.$$.fragment, H),
        transition_out(I.$$.fragment, H),
        transition_out(O.$$.fragment, H),
        (R = R.filter(Boolean));
      for (let G = 0; G < R.length; G += 1) transition_out(R[G]);
      N = !1;
    },
    d(H) {
      H && detach(r),
        destroy_component(v),
        destroy_component(I),
        destroy_component(O),
        destroy_each(R, H);
    },
  };
}
let TopBar$2 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$3t, safe_not_equal, {});
  }
};
function create_fragment$3s(k) {
  let r, p, v, $, S, x;
  return (
    (r = new TopBar$2({})),
    (v = new AppList$1({})),
    (S = new BottomBar({})),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          create_component(v.$$.fragment),
          ($ = space()),
          create_component(S.$$.fragment);
      },
      m(I, F) {
        mount_component(r, I, F),
          insert(I, p, F),
          mount_component(v, I, F),
          insert(I, $, F),
          mount_component(S, I, F),
          (x = !0);
      },
      p: noop$1,
      i(I) {
        x ||
          (transition_in(r.$$.fragment, I),
          transition_in(v.$$.fragment, I),
          transition_in(S.$$.fragment, I),
          (x = !0));
      },
      o(I) {
        transition_out(r.$$.fragment, I),
          transition_out(v.$$.fragment, I),
          transition_out(S.$$.fragment, I),
          (x = !1);
      },
      d(I) {
        destroy_component(r, I),
          I && detach(p),
          destroy_component(v, I),
          I && detach($),
          destroy_component(S, I);
      },
    }
  );
}
let AppManager$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$3s, safe_not_equal, {});
  }
};
const RunDialog_svelte_svelte_type_style_lang = "";
function get_each_context$L(k, r, p) {
  const v = k.slice();
  return (v[5] = r[p]), v;
}
function create_if_block$1f(k) {
  let r,
    p = k[5].id + "",
    v,
    $;
  return {
    c() {
      (r = element("option")),
        (v = text(p)),
        (r.__value = $ = k[5].id),
        (r.value = r.__value);
    },
    m(S, x) {
      insert(S, r, x), append(r, v);
    },
    p(S, x) {
      x & 2 && p !== (p = S[5].id + "") && set_data(v, p),
        x & 2 &&
          $ !== ($ = S[5].id) &&
          ((r.__value = $), (r.value = r.__value));
    },
    d(S) {
      S && detach(r);
    },
  };
}
function create_each_block$L(k) {
  let r = !isOpened(k[5].id) && !k[5].info.custom && !isDisabled(k[5].id),
    p,
    v = r && create_if_block$1f(k);
  return {
    c() {
      v && v.c(), (p = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, p, S);
    },
    p($, S) {
      S & 2 &&
        (r = !isOpened($[5].id) && !$[5].info.custom && !isDisabled($[5].id)),
        r
          ? v
            ? v.p($, S)
            : ((v = create_if_block$1f($)), v.c(), v.m(p.parentNode, p))
          : v && (v.d(1), (v = null));
    },
    d($) {
      v && v.d($), $ && detach(p);
    },
  };
}
function create_fragment$3r(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L,
    U,
    j,
    N,
    q,
    R,
    Q,
    H,
    G,
    V = k[1],
    K = [];
  for (let Y = 0; Y < V.length; Y += 1)
    K[Y] = create_each_block$L(get_each_context$L(k, V, Y));
  return {
    c() {
      (r = element("div")),
        (p = element("img")),
        ($ = space()),
        (S = element("div")),
        (x = element("p")),
        (x.textContent =
          "Select the ID of the app you want to run from the following list:"),
        (I = space()),
        (F = element("select"));
      for (let Y = 0; Y < K.length; Y += 1) K[Y].c();
      (O = space()),
        (L = element("div")),
        (U = element("div")),
        (j = element("button")),
        (N = text("Run")),
        (R = space()),
        (Q = element("button")),
        (Q.textContent = "Cancel"),
        src_url_equal(p.src, (v = appsIcon)) || attr(p, "src", v),
        attr(p, "alt", "Run"),
        attr(p, "class", "svelte-1pwxzgl"),
        attr(x, "class", "caption svelte-1pwxzgl"),
        attr(F, "class", "svelte-1pwxzgl"),
        k[0] === void 0 && add_render_callback(() => k[4].call(F)),
        attr(S, "class", "inner"),
        attr(r, "class", "wrapper svelte-1pwxzgl"),
        (j.disabled = q = !k[0]),
        attr(U, "class", "inner svelte-1pwxzgl"),
        attr(L, "class", "actions svelte-1pwxzgl");
    },
    m(Y, J) {
      insert(Y, r, J),
        append(r, p),
        append(r, $),
        append(r, S),
        append(S, x),
        append(S, I),
        append(S, F);
      for (let Z = 0; Z < K.length; Z += 1) K[Z] && K[Z].m(F, null);
      select_option(F, k[0], !0),
        insert(Y, O, J),
        insert(Y, L, J),
        append(L, U),
        append(U, j),
        append(j, N),
        append(U, R),
        append(U, Q),
        H ||
          ((G = [
            listen(F, "change", k[4]),
            listen(j, "click", k[2]),
            listen(Q, "click", k[3]),
          ]),
          (H = !0));
    },
    p(Y, [J]) {
      if (J & 2) {
        V = Y[1];
        let Z;
        for (Z = 0; Z < V.length; Z += 1) {
          const X = get_each_context$L(Y, V, Z);
          K[Z]
            ? K[Z].p(X, J)
            : ((K[Z] = create_each_block$L(X)), K[Z].c(), K[Z].m(F, null));
        }
        for (; Z < K.length; Z += 1) K[Z].d(1);
        K.length = V.length;
      }
      J & 3 && select_option(F, Y[0]),
        J & 3 && q !== (q = !Y[0]) && (j.disabled = q);
    },
    i: noop$1,
    o: noop$1,
    d(Y) {
      Y && detach(r),
        destroy_each(K, Y),
        Y && detach(O),
        Y && detach(L),
        (H = !1),
        run_all(G);
    },
  };
}
function instance$3h(k, r, p) {
  let v;
  component_subscribe(k, WindowStore, (F) => p(1, (v = F)));
  let $;
  function S() {
    openWindow($, !0), x();
  }
  function x() {
    hideOverlay("run", "AppMan");
  }
  function I() {
    ($ = select_value(this)), p(0, $);
  }
  return [$, v, S, x, I];
}
class RunDialog extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3h, create_fragment$3r, safe_not_equal, {});
  }
}
const trayIcons = writable([]);
function createTrayIcon(k) {
  if (trayExists(k.identifier)) return !1;
  const r = get_store_value(trayIcons);
  r.push(k), trayIcons.set(r);
}
function disposeTrayIcon(k) {
  const r = get_store_value(trayIcons);
  for (let p = 0; p < r.length; p++) r[p].identifier == k && r.splice(p, 1);
  trayIcons.set(r);
}
function trayExists(k) {
  const r = get_store_value(trayIcons);
  for (let p = 0; p < r.length; p++) if (r[p].identifier == k) return !0;
  return !1;
}
const AppManager = {
    info: {
      name: "Application Manager",
      description: "Manage Open Apps",
      builtin: !0,
      version: "1.5.0",
      author: "Izaak Kuipers",
      icon: logo$a,
    },
    size: { w: 600, h: 500 },
    pos: { x: 30, y: 40 },
    minSize: { w: 600, h: 500 },
    maxSize: { w: 600, h: 500 },
    controls: { min: !1, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: AppManager$1,
    glass: !0,
    events: {
      open() {
        createTrayIcon({
          image: AppManager.info.icon,
          identifier: "Application Manager",
          onOpen() {},
        });
      },
      close() {
        disposeTrayIcon("Application Manager");
      },
    },
    overlays: {
      run: {
        info: { name: "Run", author: "ArcOS Team", version: "1.0.0" },
        size: { w: NaN, h: NaN },
        show: !1,
        content: RunDialog,
      },
    },
  },
  logo$9 = "./assets/apppoker-d7ed29fe.svg",
  AppPoker$2 = "",
  notice = "";
function create_fragment$3q(k) {
  let r, p, v, $, S, x, I, F, O, L;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("span")),
        ($ = text(k[2])),
        (S = space()),
        (x = element("div")),
        (I = element("p")),
        (F = text(k[0])),
        (O = space()),
        (L = element("p")),
        attr(v, "class", "material-icons-round"),
        attr(I, "class", "title"),
        attr(L, "class", "message"),
        attr(r, "class", "notice");
    },
    m(U, j) {
      insert(U, r, j),
        append(r, p),
        append(p, v),
        append(v, $),
        append(r, S),
        append(r, x),
        append(x, I),
        append(I, F),
        append(x, O),
        append(x, L),
        (L.innerHTML = k[1]);
    },
    p(U, [j]) {
      j & 4 && set_data($, U[2]),
        j & 1 && set_data(F, U[0]),
        j & 2 && (L.innerHTML = U[1]);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r);
    },
  };
}
function instance$3g(k, r, p) {
  let { title: v } = r,
    { text: $ } = r,
    { icon: S } = r;
  return (
    (k.$$set = (x) => {
      "title" in x && p(0, (v = x.title)),
        "text" in x && p(1, ($ = x.text)),
        "icon" in x && p(2, (S = x.icon));
    }),
    [v, $, S]
  );
}
class Notice extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3g, create_fragment$3q, safe_not_equal, {
        title: 0,
        text: 1,
        icon: 2,
      });
  }
}
function get_each_context$K(k, r, p) {
  const v = k.slice();
  return (v[4] = r[p]), v;
}
function create_if_block$1e(k) {
  let r, p, v, $;
  r = new Notice({
    props: {
      icon: "warning",
      text: "You can alter properties for applications that are disabled by default. This can cause the UI to break, be careful!",
      title: "Hold up!",
    },
  });
  let S = AppPokerProperties,
    x = [];
  for (let I = 0; I < S.length; I += 1)
    x[I] = create_each_block$K(get_each_context$K(k, S, I));
  return {
    c() {
      create_component(r.$$.fragment), (p = space()), (v = element("div"));
      for (let I = 0; I < x.length; I += 1) x[I].c();
      attr(v, "class", "manager");
    },
    m(I, F) {
      mount_component(r, I, F), insert(I, p, F), insert(I, v, F);
      for (let O = 0; O < x.length; O += 1) x[O] && x[O].m(v, null);
      $ = !0;
    },
    p(I, F) {
      if (F & 2) {
        S = AppPokerProperties;
        let O;
        for (O = 0; O < S.length; O += 1) {
          const L = get_each_context$K(I, S, O);
          x[O]
            ? x[O].p(L, F)
            : ((x[O] = create_each_block$K(L)), x[O].c(), x[O].m(v, null));
        }
        for (; O < x.length; O += 1) x[O].d(1);
        x.length = S.length;
      }
    },
    i(I) {
      $ || (transition_in(r.$$.fragment, I), ($ = !0));
    },
    o(I) {
      transition_out(r.$$.fragment, I), ($ = !1);
    },
    d(I) {
      destroy_component(r, I),
        I && detach(p),
        I && detach(v),
        destroy_each(x, I);
    },
  };
}
function create_each_block$K(k) {
  let r,
    p = k[4].caption + "",
    v,
    $,
    S,
    x;
  function I() {
    return k[3](k[4]);
  }
  return {
    c() {
      (r = element("button")),
        (v = text(p)),
        ($ = space()),
        toggle_class(r, "off", !k[4].getter(k[1]));
    },
    m(F, O) {
      insert(F, r, O),
        append(r, v),
        append(r, $),
        S || ((x = listen(r, "click", I)), (S = !0));
    },
    p(F, O) {
      (k = F), O & 2 && toggle_class(r, "off", !k[4].getter(k[1]));
    },
    d(F) {
      F && detach(r), (S = !1), x();
    },
  };
}
function create_fragment$3p(k) {
  let r,
    p,
    v = k[1] && !k[0] && create_if_block$1e(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, [S]) {
      $[1] && !$[0]
        ? v
          ? (v.p($, S), S & 3 && transition_in(v, 1))
          : ((v = create_if_block$1e($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function instance$3f(k, r, p) {
  let v;
  component_subscribe(k, AppPokerData, (I) => p(1, (v = I)));
  let { app: $ } = r,
    S = !1;
  WindowStore.subscribe((I) => {
    I && (p(0, (S = !0)), p(0, (S = !1)));
  }),
    AppPokerData.subscribe((I) => {
      I &&
        (p(2, ($.info.titleSuffix = ` - Managing ${I.info.name}`), $),
        updateStores());
    });
  const x = (I) => I.action(v);
  return (
    (k.$$set = (I) => {
      "app" in I && p(2, ($ = I.app));
    }),
    [S, v, $, x]
  );
}
let AppPoker$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3f, create_fragment$3p, safe_not_equal, {
        app: 2,
      });
  }
};
const AppPoker = {
    info: {
      name: "App Poker",
      description: "Poke properties of applications",
      builtin: !0,
      version: "1.0.0",
      author: "Izaak Kuipers",
      hidden: !0,
      icon: logo$9,
    },
    size: { w: 500, h: 300 },
    pos: { x: 30, y: 40 },
    minSize: { w: 500, h: 300 },
    maxSize: { w: 500, h: 300 },
    controls: { min: !1, max: !1, cls: !0 },
    state: {
      headless: !1,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: AppPoker$1,
    glass: !1,
    events: {
      close() {
        AppPokerData.set(null);
      },
    },
    disabledWarning: {
      title: "Can't poke apps",
      message:
        "The app poker is disabled, so you won't be able to poke applications. Go to the Apps page in settings to re-enable it.",
    },
  },
  logo$8 = "./assets/calculator-a55e0dfc.svg",
  calculator = "";
class CS {
  constructor() {
    _e(this, "Source", "Calculator/main.ts:");
    _e(this, "AllowedKeys", [
      "+",
      "-",
      "/",
      "*",
      "7",
      "8",
      "9",
      "**",
      "4",
      "5",
      "6",
      "%",
      "1",
      "2",
      "3",
      "%%C",
      ".",
      "0",
      "00",
      "%%E",
    ]);
    _e(this, "Shortcuts", [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "/",
      "+",
      "-",
      "*",
    ]);
    _e(this, "Overrides", { "*": "x", "/": ":", "**": "^", "%": "mod()" });
    _e(this, "altClasses", ["+", "-", "/", "*", "**", "%", "."]);
  }
}
const CalculatorStore = new CS(),
  CalculatorValue = writable("");
class CL {
  constructor() {
    _e(this, "keys", []);
    _e(this, "Functions", {
      "%%C": ["C", () => CalculatorValue.set(""), "clear"],
      "%%E": ["=", this.evaluate, "process"],
    });
    this.keys = this.compileKeys(
      CalculatorStore.AllowedKeys,
      CalculatorStore.Overrides
    );
  }
  compileKeys(k, r) {
    const p = k.length,
      v = Object.values(r).length,
      $ = [];
    Log({
      source: `${CalculatorStore.Source} compileKeys`,
      msg: `Compiling CalculatorKeys[] array with ${p} keys and ${v} overrides.`,
      level: LogLevel.info,
    });
    for (let S = 0; S < k.length; S++) {
      let x = [null, null];
      (x[0] = r[k[S]] || k[S]), (x[1] = k[S]), $.push(x);
    }
    return $;
  }
  evaluate() {
    if (
      (Log({
        source: `${CalculatorStore.Source} evaluate`,
        msg: `Evaluating sum ("${get_store_value(CalculatorValue)}")`,
        level: LogLevel.info,
      }),
      !CalculatorClass.isValid(get_store_value(CalculatorValue)))
    )
      return !1;
    const value = eval(get_store_value(CalculatorValue));
    return CalculatorValue.set(value), value;
  }
  isValid(k) {
    if (
      (Log({
        source: `${CalculatorStore.Source} isValid`,
        msg: `Verifying input "${k}"...`,
        level: LogLevel.info,
      }),
      k.startsWith("%%"))
    )
      return !1;
    for (let r = 0; r < k.length; r++)
      if (!CalculatorStore.AllowedKeys.includes(k[r]))
        return (
          Log({
            source: `${CalculatorStore.Source} isValid`,
            msg: `Input "${k}" not valid.`,
            level: LogLevel.warn,
          }),
          !1
        );
    return !0;
  }
  generateKeyboardShortcuts() {
    Log({
      source: `${CalculatorStore.Source} processKey`,
      msg: "Generating keyboard shortcut array",
      level: LogLevel.info,
    });
    let k = [];
    for (let r = 0; r < CalculatorStore.Shortcuts.length; r++)
      k.push({
        key: CalculatorStore.Shortcuts[r],
        action: () => this.processKey(CalculatorStore.Shortcuts[r]),
      });
    return k;
  }
  processKey(key) {
    if (
      (Log({
        source: `${CalculatorStore.Source} processKey`,
        msg: `Processing key "${key}"`,
        level: LogLevel.info,
      }),
      !this.isValid(key))
    )
      return !1;
    const newValue = `${get_store_value(CalculatorValue)}${key}0`;
    try {
      eval(newValue);
    } catch {
      return (
        Log({
          source: `${CalculatorStore.Source} Calculator/main.ts: processKey`,
          msg: `Test sum "${newValue}" is not valid. Aborting.`,
          level: LogLevel.error,
        }),
        !1
      );
    }
    CalculatorValue.set(get_store_value(CalculatorValue) + key);
  }
}
const CalculatorClass = new CL();
function get_each_context$J(k, r, p) {
  const v = k.slice();
  return (v[4] = r[p]), v;
}
function create_else_block$p(k) {
  let r,
    p = CalculatorClass.Functions[k[4][1]][0] + "",
    v,
    $,
    S,
    x;
  return {
    c() {
      (r = element("button")),
        (v = text(p)),
        ($ = space()),
        attr(r, "class", CalculatorClass.Functions[k[4][1]][2]);
    },
    m(I, F) {
      insert(I, r, F),
        append(r, v),
        append(r, $),
        S ||
          ((x = listen(r, "click", CalculatorClass.Functions[k[4][0]][1])),
          (S = !0));
    },
    p(I, F) {
      k = I;
    },
    d(I) {
      I && detach(r), (S = !1), x();
    },
  };
}
function create_if_block$1d(k) {
  let r,
    p = k[4][0] + "",
    v,
    $,
    S,
    x;
  function I() {
    return k[1](k[4]);
  }
  return {
    c() {
      (r = element("button")),
        (v = text(p)),
        ($ = space()),
        toggle_class(r, "empty", !k[4][0]),
        toggle_class(r, "alt", CalculatorStore.altClasses.includes(k[4][1]));
    },
    m(F, O) {
      insert(F, r, O),
        append(r, v),
        append(r, $),
        S || ((x = listen(r, "click", I)), (S = !0));
    },
    p(F, O) {
      k = F;
    },
    d(F) {
      F && detach(r), (S = !1), x();
    },
  };
}
function create_each_block$J(k) {
  let r;
  function p(S, x) {
    return S[4][0].startsWith("%%") ? create_else_block$p : create_if_block$1d;
  }
  let $ = p(k)(k);
  return {
    c() {
      $.c(), (r = empty());
    },
    m(S, x) {
      $.m(S, x), insert(S, r, x);
    },
    p(S, x) {
      $.p(S, x);
    },
    d(S) {
      $.d(S), S && detach(r);
    },
  };
}
function create_fragment$3o(k) {
  let r,
    p,
    v,
    $ = CalculatorClass.keys,
    S = [];
  for (let x = 0; x < $.length; x += 1)
    S[x] = create_each_block$J(get_each_context$J(k, $, x));
  return {
    c() {
      (r = element("input")), (p = space()), (v = element("div"));
      for (let x = 0; x < S.length; x += 1) S[x].c();
      attr(r, "type", "text"),
        attr(r, "class", "display"),
        (r.readOnly = !0),
        (r.value = k[0]),
        attr(v, "class", "keys");
    },
    m(x, I) {
      insert(x, r, I), insert(x, p, I), insert(x, v, I);
      for (let F = 0; F < S.length; F += 1) S[F] && S[F].m(v, null);
    },
    p(x, [I]) {
      if ((I & 1 && r.value !== x[0] && (r.value = x[0]), I & 0)) {
        $ = CalculatorClass.keys;
        let F;
        for (F = 0; F < $.length; F += 1) {
          const O = get_each_context$J(x, $, F);
          S[F]
            ? S[F].p(O, I)
            : ((S[F] = create_each_block$J(O)), S[F].c(), S[F].m(v, null));
        }
        for (; F < S.length; F += 1) S[F].d(1);
        S.length = $.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r), x && detach(p), x && detach(v), destroy_each(S, x);
    },
  };
}
function instance$3e(k, r, p) {
  let v;
  component_subscribe(k, CalculatorValue, (x) => p(2, (v = x)));
  let $ = "";
  return (
    onMount(() => {
      CalculatorValue.subscribe((x) => {
        Log({
          source: "Calculator: CalculatorValue.subscribe",
          msg: `Value of CalculatorValue<string> changed to "${v}"`,
          level: LogLevel.info,
        }),
          p(0, ($ = x || "0"));
      });
    }),
    [$, (x) => CalculatorClass.processKey(x[1])]
  );
}
class Calculator extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3e, create_fragment$3o, safe_not_equal, {});
  }
}
const CalculatorApp = {
    info: {
      name: "Calculator",
      description: "ArcOS Calculator",
      builtin: !0,
      version: "2.0.0",
      author: "Izaak Kuipers",
      icon: logo$8,
    },
    size: { w: 340, h: NaN },
    pos: { x: 60, y: 60 },
    minSize: { w: 340, h: NaN },
    maxSize: { w: 340, h: NaN },
    controls: { min: !0, max: !1, cls: !0 },
    state: {
      headless: !1,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: Calculator,
    glass: !0,
    events: {
      close() {
        CalculatorValue.set("");
      },
      open() {
        CalculatorValue.set("");
      },
      keyboardShortcuts: [
        ...CalculatorClass.generateKeyboardShortcuts(),
        { key: "enter", action: () => CalculatorClass.evaluate() },
        { key: "escape", action: () => CalculatorValue.set("") },
      ],
    },
  },
  logo$7 = "./assets/donut-041054d9.png";
let A = 1,
  B = 1;
function tick$1() {
  const k = [],
    r = [];
  (A += 0.07), (B += 0.03);
  let p = Math.cos(A),
    v = Math.sin(A),
    $ = Math.cos(B),
    S = Math.sin(B);
  for (let x = 0; x < 1760; x++)
    (k[x] =
      x % 80 == 79
        ? `
`
        : " "),
      (r[x] = 0);
  for (let x = 0; x < 6.28; x += 0.07) {
    let I = Math.cos(x),
      F = Math.sin(x);
    for (let O = 0; O < 6.28; O += 0.02) {
      let L = Math.sin(O),
        U = Math.cos(O),
        j = I + 2,
        N = 1 / (L * j * v + F * p + 5),
        q = L * j * p - F * v,
        R = 0 | (40 + 30 * N * (U * j * $ - q * S)),
        Q = 0 | (12 + 15 * N * (U * j * S + q * $)),
        H = R + 80 * Q,
        G = 0 | (8 * ((F * v - L * I * p) * $ - L * I * v - F * p - U * I * S));
      Q < 22 &&
        Q >= 0 &&
        R >= 0 &&
        R < 79 &&
        N > r[H] &&
        ((r[H] = N), (k[H] = ".,-~:;=!*#$@"[G > 0 ? G : 0]));
      const V = {
        o: H,
        A,
        B,
        N: G,
        st: F,
        sA: v,
        sp: L,
        ct: I,
        cA: p,
        cB: $,
        cp: U,
        sB: S,
        D: N,
        t: q,
        h: j,
        i: O,
        j: x,
        x: R,
        y: Q,
        cycles: (A / 0.07 / 89.71428571428571).toFixed(2),
      };
      donutDebugInformation.set(V);
    }
  }
  return k.join("");
}
const donutDebugInformation = writable(),
  Donut_svelte_svelte_type_style_lang = "";
function get_each_context$I(k, r, p) {
  const v = k.slice();
  return (v[3] = r[p]), v;
}
function create_if_block$1c(k) {
  let r,
    p = Object.entries(k[1]),
    v = [];
  for (let $ = 0; $ < p.length; $ += 1)
    v[$] = create_each_block$I(get_each_context$I(k, p, $));
  return {
    c() {
      for (let $ = 0; $ < v.length; $ += 1) v[$].c();
      r = empty();
    },
    m($, S) {
      for (let x = 0; x < v.length; x += 1) v[x] && v[x].m($, S);
      insert($, r, S);
    },
    p($, S) {
      if (S & 2) {
        p = Object.entries($[1]);
        let x;
        for (x = 0; x < p.length; x += 1) {
          const I = get_each_context$I($, p, x);
          v[x]
            ? v[x].p(I, S)
            : ((v[x] = create_each_block$I(I)),
              v[x].c(),
              v[x].m(r.parentNode, r));
        }
        for (; x < v.length; x += 1) v[x].d(1);
        v.length = p.length;
      }
    },
    d($) {
      destroy_each(v, $), $ && detach(r);
    },
  };
}
function create_else_block$o(k) {
  let r = k[3][1] + "",
    p;
  return {
    c() {
      p = text(r);
    },
    m(v, $) {
      insert(v, p, $);
    },
    p(v, $) {
      $ & 2 && r !== (r = v[3][1] + "") && set_data(p, r);
    },
    d(v) {
      v && detach(p);
    },
  };
}
function create_if_block_1$n(k) {
  let r = k[3][1].toFixed(8) + "",
    p;
  return {
    c() {
      p = text(r);
    },
    m(v, $) {
      insert(v, p, $);
    },
    p(v, $) {
      $ & 2 && r !== (r = v[3][1].toFixed(8) + "") && set_data(p, r);
    },
    d(v) {
      v && detach(p);
    },
  };
}
function create_each_block$I(k) {
  let r,
    p,
    v = k[3][0] + "",
    $,
    S,
    x,
    I;
  function F(U, j) {
    return typeof U[3][1] == "number"
      ? create_if_block_1$n
      : create_else_block$o;
  }
  let O = F(k),
    L = O(k);
  return {
    c() {
      (r = element("tr")),
        (p = element("td")),
        ($ = text(v)),
        (S = space()),
        (x = element("td")),
        L.c(),
        (I = space()),
        attr(p, "class", "svelte-u78920"),
        attr(x, "class", "svelte-u78920"),
        attr(r, "class", "svelte-u78920");
    },
    m(U, j) {
      insert(U, r, j),
        append(r, p),
        append(p, $),
        append(r, S),
        append(r, x),
        L.m(x, null),
        append(r, I);
    },
    p(U, j) {
      j & 2 && v !== (v = U[3][0] + "") && set_data($, v),
        O === (O = F(U)) && L
          ? L.p(U, j)
          : (L.d(1), (L = O(U)), L && (L.c(), L.m(x, null)));
    },
    d(U) {
      U && detach(r), L.d();
    },
  };
}
function create_fragment$3n(k) {
  let r,
    p,
    v,
    $,
    S,
    x = k[1] && create_if_block$1c(k);
  return {
    c() {
      (r = element("div")),
        (p = element("pre")),
        (v = text(k[0])),
        ($ = space()),
        (S = element("table")),
        x && x.c(),
        attr(p, "class", "svelte-u78920"),
        attr(S, "class", "svelte-u78920"),
        attr(r, "data-caller", "donut-target"),
        attr(r, "class", "svelte-u78920");
    },
    m(I, F) {
      insert(I, r, F),
        append(r, p),
        append(p, v),
        append(r, $),
        append(r, S),
        x && x.m(S, null);
    },
    p(I, [F]) {
      F & 1 && set_data(v, I[0]),
        I[1]
          ? x
            ? x.p(I, F)
            : ((x = create_if_block$1c(I)), x.c(), x.m(S, null))
          : x && (x.d(1), (x = null));
    },
    i: noop$1,
    o: noop$1,
    d(I) {
      I && detach(r), x && x.d();
    },
  };
}
let fps = 30;
function instance$3d(k, r, p) {
  let v, $;
  component_subscribe(k, donutSpinning, (x) => p(2, (v = x))),
    component_subscribe(k, donutDebugInformation, (x) => p(1, ($ = x)));
  let S = "";
  return (
    setInterval(() => {
      v && p(0, (S = tick$1()));
    }, 1e3 / fps),
    [S, $]
  );
}
class Donut extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3d, create_fragment$3n, safe_not_equal, {});
  }
}
const DonutApp = {
    info: {
      name: "Donut",
      description: "A spinning ASCII donut",
      builtin: !0,
      version: ArcOSVersion,
      author: "Andy Sloane (ArcOS port by IzK)",
      icon: logo$7,
    },
    size: { w: 850, h: 520 },
    pos: { x: 30, y: 40 },
    minSize: { w: 850, h: 520 },
    maxSize: { w: 850, h: NaN },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: Donut,
    glass: !0,
    events: {
      open() {
        donutSpinning.set(!0);
      },
      close() {
        donutSpinning.set(!1);
      },
      blur() {
        donutSpinning.set(!1);
      },
      focus() {
        donutSpinning.set(!0);
      },
    },
  },
  donutSpinning = writable(!1);
function create_fragment$3m(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H;
  return {
    c() {
      (r = element("p")),
        (r.textContent =
          "Specify the title and message to create an error message:"),
        (p = space()),
        (v = element("br")),
        ($ = space()),
        (S = element("input")),
        (x = space()),
        (I = element("input")),
        (F = space()),
        (O = element("input")),
        (L = space()),
        (U = element("input")),
        (j = space()),
        (N = element("button")),
        (q = text("Create")),
        attr(S, "placeholder", "title"),
        attr(S, "class", "fullwidth"),
        attr(I, "placeholder", "message"),
        attr(I, "class", "fullwidth"),
        attr(O, "placeholder", "button caption 1"),
        attr(O, "class", "fullwidth"),
        attr(U, "placeholder", "button caption 2"),
        attr(U, "class", "fullwidth"),
        (N.disabled = R = !k[0] || !k[1]);
    },
    m(G, V) {
      insert(G, r, V),
        insert(G, p, V),
        insert(G, v, V),
        insert(G, $, V),
        insert(G, S, V),
        set_input_value(S, k[0]),
        insert(G, x, V),
        insert(G, I, V),
        set_input_value(I, k[1]),
        insert(G, F, V),
        insert(G, O, V),
        set_input_value(O, k[2]),
        insert(G, L, V),
        insert(G, U, V),
        set_input_value(U, k[3]),
        insert(G, j, V),
        insert(G, N, V),
        append(N, q),
        Q ||
          ((H = [
            listen(S, "input", k[5]),
            listen(I, "input", k[6]),
            listen(O, "input", k[7]),
            listen(U, "input", k[8]),
            listen(N, "click", k[4]),
          ]),
          (Q = !0));
    },
    p(G, [V]) {
      V & 1 && S.value !== G[0] && set_input_value(S, G[0]),
        V & 2 && I.value !== G[1] && set_input_value(I, G[1]),
        V & 4 && O.value !== G[2] && set_input_value(O, G[2]),
        V & 8 && U.value !== G[3] && set_input_value(U, G[3]),
        V & 3 && R !== (R = !G[0] || !G[1]) && (N.disabled = R);
    },
    i: noop$1,
    o: noop$1,
    d(G) {
      G && detach(r),
        G && detach(p),
        G && detach(v),
        G && detach($),
        G && detach(S),
        G && detach(x),
        G && detach(I),
        G && detach(F),
        G && detach(O),
        G && detach(L),
        G && detach(U),
        G && detach(j),
        G && detach(N),
        (Q = !1),
        run_all(H);
    },
  };
}
function instance$3c(k, r, p) {
  let v, $, S, x;
  function I() {
    errorMessage(
      v,
      $,
      null,
      "ErrCre",
      { caption: S, action: () => {} },
      { caption: x, action: () => {} }
    );
  }
  function F() {
    (v = this.value), p(0, v);
  }
  function O() {
    ($ = this.value), p(1, $);
  }
  function L() {
    (S = this.value), p(2, S);
  }
  function U() {
    (x = this.value), p(3, x);
  }
  return [v, $, S, x, I, F, O, L, U];
}
let ErrorCreator$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3c, create_fragment$3m, safe_not_equal, {});
  }
};
const ErrorCreator = {
    info: {
      name: "Error Message Summoner",
      description: "Use for testing only -- error message creator",
      builtin: !0,
      version: ArcOSVersion,
      author: "Izaak Kuipers",
      icon: warning,
      hidden: !0,
    },
    size: { w: 300, h: 267 },
    pos: { x: 30, y: 40 },
    minSize: { w: 300, h: 253 },
    maxSize: { w: 300, h: 253 },
    controls: { min: !0, max: !1, cls: !0 },
    state: {
      headless: !1,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: ErrorCreator$1,
    glass: !0,
  },
  shutdownIcon = "./assets/exit-ccaa87b5.svg",
  exit = "",
  selectedMessageId = writable(null),
  replyMessageId = writable(null),
  threadMessageId = writable(null),
  creatingMessage = writable(!1);
async function getMessages() {
  const k = get_store_value(ConnectedServer);
  if (!k) return [];
  const r = await apiCall(k, "messages/list", {}, get_store_value(UserToken));
  return r.valid ? r.data : [];
}
async function getMessage(k) {
  const r = get_store_value(ConnectedServer);
  if (!r) return !1;
  const p = await apiCall(
    r,
    "messages/get",
    { id: btoa(k) },
    get_store_value(UserToken)
  );
  return p.valid ? p.data : !1;
}
function create_if_block$1b(k) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.innerHTML = `<span class="material-icons-round">terminal</span> 
        <p class="caption">ArcTerm</p>`),
        attr(r, "class", "option");
    },
    m($, S) {
      insert($, r, S), p || ((v = listen(r, "click", k[2])), (p = !0));
    },
    p: noop$1,
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_fragment$3l(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L,
    U,
    j,
    N,
    q,
    R = k[0] && create_if_block$1b(k);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("h3")),
        (v.textContent = "ArcOS"),
        ($ = space()),
        (S = element("button")),
        (S.innerHTML = `<span class="material-icons-round">power_settings_new</span> 
      <p class="caption">Shutdown</p>`),
        (x = space()),
        (I = element("button")),
        (I.innerHTML = `<span class="material-icons-round">logout</span> 
      <p class="caption">Logoff</p>`),
        (F = space()),
        (O = element("button")),
        (O.innerHTML = `<span class="material-icons-round">refresh</span> 
      <p class="caption">Restart</p>`),
        (L = space()),
        R && R.c(),
        (U = space()),
        (j = element("button")),
        (j.textContent = "Cancel"),
        attr(v, "class", "header"),
        attr(S, "class", "option"),
        attr(I, "class", "option"),
        attr(O, "class", "option"),
        attr(j, "class", "cancel"),
        attr(p, "class", "flex-stop"),
        attr(r, "class", "center-flex");
    },
    m(Q, H) {
      insert(Q, r, H),
        append(r, p),
        append(p, v),
        append(p, $),
        append(p, S),
        append(p, x),
        append(p, I),
        append(p, F),
        append(p, O),
        append(p, L),
        R && R.m(p, null),
        append(p, U),
        append(p, j),
        N ||
          ((q = [
            listen(S, "click", shutdown),
            listen(I, "click", k[4]),
            listen(O, "click", k[5]),
            listen(j, "click", k[1]),
          ]),
          (N = !0));
    },
    p(Q, [H]) {
      Q[0]
        ? R
          ? R.p(Q, H)
          : ((R = create_if_block$1b(Q)), R.c(), R.m(p, U))
        : R && (R.d(1), (R = null));
    },
    i: noop$1,
    o: noop$1,
    d(Q) {
      Q && detach(r), R && R.d(), (N = !1), run_all(q);
    },
  };
}
function instance$3b(k, r, p) {
  let v;
  component_subscribe(k, ExitShowAT, (O) => p(0, (v = O)));
  let { app: $ } = r;
  function S() {
    isFullscreenWindow.set(!1), closeWindow($.id);
  }
  function x() {
    FileBrowserCurrentDir.set("./"),
      FileBrowserSelectedFilename.set(null),
      FileBrowserDirContents.set(defaultDirectory),
      FileBrowserDeletingFilename.set(null),
      NotificationStore.set({}),
      ErrorWindowStore.set([]),
      ErrorMessages.set([]),
      WindowStore.set([]),
      selectedMessageId.set(null),
      applyState("arcterm");
  }
  const I = () => restart(!0),
    F = () => restart(!1);
  return (
    (k.$$set = (O) => {
      "app" in O && p(3, ($ = O.app));
    }),
    [v, S, x, $, I, F]
  );
}
let Exit$2 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3b, create_fragment$3l, safe_not_equal, {
        app: 3,
      });
  }
};
const Exit$1 = {
    info: {
      name: "Exit",
      description: "ArcOS Exit Menu",
      builtin: !0,
      version: "2.0.0",
      author: "Izaak Kuipers",
      icon: shutdownIcon,
      hidden: !0,
    },
    size: { w: 280, h: 50 },
    pos: { x: 30, y: 40 },
    minSize: { w: 280, h: 50 },
    maxSize: { w: 280, h: 50 },
    controls: { min: !1, max: !1, cls: !0 },
    state: {
      headless: !0,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !0 },
    },
    content: Exit$2,
    glass: !1,
    events: {
      keyboardShortcuts: [
        {
          shift: !0,
          key: "",
          action() {
            ExitShowAT.set(!0);
          },
        },
      ],
      close(k) {
        ExitShowAT.set(!1);
      },
    },
  },
  ExitShowAT = writable(!1),
  logo$6 = "./assets/filemanager-cb441701.svg",
  filebrowser = "";
function getParentDirectory(k) {
  const r = k.split("/");
  return k == "./" || !r.length
    ? k
    : r.length == 1
    ? "./"
    : (r.splice(-1), r.join("/"));
}
function closeFile(k) {
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++) r[p].id == k && (r[p].openedFile = null);
  WindowStore.set(r);
}
const spinner$1 = "",
  spinner = "./assets/spinner-14f81f00.svg";
function create_fragment$3k(k) {
  let r, p;
  return {
    c() {
      (r = element("img")),
        src_url_equal(r.src, (p = spinner)) || attr(r, "src", p),
        attr(r, "alt", "spinner"),
        set_style(r, "height", k[0] + "px"),
        attr(r, "class", "spinner-svg");
    },
    m(v, $) {
      insert(v, r, $);
    },
    p(v, [$]) {
      $ & 1 && set_style(r, "height", v[0] + "px");
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      v && detach(r);
    },
  };
}
function instance$3a(k, r, p) {
  let { height: v } = r;
  return (
    (k.$$set = ($) => {
      "height" in $ && p(0, (v = $.height));
    }),
    [v]
  );
}
class Spinner extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3a, create_fragment$3k, safe_not_equal, {
        height: 0,
      });
  }
}
const folder = "./assets/folder-f520676e.svg";
function create_fragment$3j(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F = k[0].name + "",
    O,
    L,
    U,
    j,
    N,
    q,
    R,
    Q,
    H;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (I = element("div")),
        (O = text(F)),
        (L = space()),
        (U = element("div")),
        (U.textContent = "Folder"),
        (j = space()),
        (N = element("div")),
        (N.textContent = "-"),
        src_url_equal(v.src, ($ = folder)) || attr(v, "src", $),
        attr(v, "alt", (S = k[0].name)),
        attr(p, "class", "image"),
        attr(I, "class", "name"),
        attr(U, "class", "mime"),
        attr(N, "class", "size"),
        attr(r, "class", "item dir"),
        attr(r, "data-path", (q = k[0].scopedPath)),
        attr(r, "data-type", "dir"),
        attr(r, "data-name", (R = k[0].name)),
        attr(r, "data-caller", "listitem-dir"),
        toggle_class(r, "selected", k[1] == k[0].name),
        toggle_class(r, "cutting", k[2] && k[2].name == k[0].name);
    },
    m(G, V) {
      insert(G, r, V),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, I),
        append(I, O),
        append(r, L),
        append(r, U),
        append(r, j),
        append(r, N),
        Q ||
          ((H = [listen(r, "click", k[3]), listen(r, "dblclick", k[4])]),
          (Q = !0));
    },
    p(G, [V]) {
      V & 1 && S !== (S = G[0].name) && attr(v, "alt", S),
        V & 1 && F !== (F = G[0].name + "") && set_data(O, F),
        V & 1 && q !== (q = G[0].scopedPath) && attr(r, "data-path", q),
        V & 1 && R !== (R = G[0].name) && attr(r, "data-name", R),
        V & 3 && toggle_class(r, "selected", G[1] == G[0].name),
        V & 5 && toggle_class(r, "cutting", G[2] && G[2].name == G[0].name);
    },
    i: noop$1,
    o: noop$1,
    d(G) {
      G && detach(r), (Q = !1), run_all(H);
    },
  };
}
function instance$39(k, r, p) {
  let v, $;
  component_subscribe(k, FileBrowserSelectedFilename, (F) => p(1, (v = F))),
    component_subscribe(k, FileBrowserCuttingFilename, (F) => p(2, ($ = F)));
  let { dir: S } = r;
  function x() {
    set_store_value(FileBrowserSelectedFilename, (v = S.name), v);
  }
  function I() {
    fbClass.goToDirectory(S.scopedPath);
  }
  return (
    (k.$$set = (F) => {
      "dir" in F && p(0, (S = F.dir));
    }),
    [S, v, $, x, I]
  );
}
let Dir$4 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$39, create_fragment$3j, safe_not_equal, {
        dir: 0,
      });
  }
};
const icon$2 = "./assets/file-0d0c64f1.svg",
  file = "./assets/application-default-dbaaa566.svg",
  imgIcon = "./assets/image-x-generic-0c29fb59.svg",
  svgIcon = "./assets/application-svg-944fd245.svg",
  pdfIcon = "./assets/application-pdf-7a1f0afa.svg",
  fileIcon = "./assets/text-plain-19145840.svg",
  arcAppI = "./assets/application-arcapp-2a8df358.svg",
  jsonIcon = "./assets/application-json-e04d619a.svg",
  archiveIcon = "./assets/application-x-compress-98d85b80.svg",
  icon$1 = "./assets/markdownviewer-a03d6bb8.svg",
  soundIcon = "./assets/audio-x-generic-73f31c65.svg",
  loadThemeIcon = "./assets/personalization-61b4520f.svg",
  extensionIcons = [
    {
      extensions: [".png", ".jpg", ".bmp", ".gif", ".ico", ".webp"],
      image: imgIcon,
    },
    { extensions: [".svg"], image: svgIcon },
    { extensions: [".md"], image: icon$1 },
    { extensions: [".app", ".ealc", ".app.json"], image: arcAppI },
    { extensions: [".pdf"], image: pdfIcon },
    { extensions: [".txt"], image: fileIcon },
    { extensions: [".json"], image: jsonIcon },
    {
      extensions: [".zip", ".tar", ".tar.gz", ".7z", ".rar"],
      image: archiveIcon,
    },
    { extensions: [".flac", ".mp3", ".wav"], image: soundIcon },
    { extensions: [".arctheme"], image: loadThemeIcon },
  ];
function getMimeIcon(k) {
  for (let r = 0; r < extensionIcons.length; r++) {
    const p = extensionIcons[r].extensions;
    for (let v = 0; v < p.length; v++)
      if (k.endsWith(p[v])) return extensionIcons[r].image;
  }
  return file;
}
const openwith = "",
  apLoaderIcon = "./assets/apploader-cf8168a8.svg",
  pdfOpenerIcon = "./assets/pdfopener-7ec41537.svg",
  openInNewIcon = "./assets/openinnew-33fae09f.svg";
function loadExternalApp(k) {
  const r = document.createElement("style"),
    p = document.createElement("script"),
    v = document.createElement("div");
  (v.id = `SIDELOAD_${Math.floor(Math.random() * 1e4 * Math.PI)}`),
    (p.id = `hotLoaderJS_${k.id}`),
    (r.id = `hotLoaderCSS_${k.id}`),
    (r.textContent = k.css),
    (p.textContent = k.js.replace(".$$.root", "")),
    !(
      !k.meta ||
      !k.meta.author ||
      !k.meta.name ||
      !k.meta.version ||
      k.meta.version.split(".")[0] == "0"
    ) && (v.append(p, r), document.body.append(v));
}
function loadAppFile(k) {
  const r = String.fromCharCode.apply(null, new Uint8Array(k.data));
  let p;
  try {
    p = JSON.parse(r);
  } catch {
    return (
      errorMessage(
        "Unable to load app from file",
        "The imported file could not be parsed as a valid JSON object.",
        null,
        null,
        { caption: "OK", action() {} }
      ),
      !1
    );
  }
  if (isLoaded(p.id))
    return makeNotification({
      title: "Can't import app",
      message:
        "Another app with the same ID is already loaded. It is not possible to load apps with the same ID.",
      buttons: [],
      timeout: 3e3,
      image: apLoaderIcon,
    });
  const v = get_store_value(UserData),
    $ = v.askPresist,
    S = v.autoLoads && v.autoLoads.includes(k.path);
  return (
    $ &&
      !S &&
      makeNotification({
        title: "Always import?",
        message: `Do you want to import application file "${k.name}" every time you log in?`,
        buttons: [
          {
            capt: "Yes",
            action() {
              const x = get_store_value(UserData);
              x.autoLoads || (x.autoLoads = []),
                x.autoLoads.push(k.path),
                UserData.set(x);
            },
          },
          {
            capt: "Don't show again",
            action() {
              const x = get_store_value(UserData);
              (x.askPresist = !1), UserData.set(x);
            },
          },
        ],
        image: apLoaderIcon,
      }),
    loadExternalApp(p),
    !0
  );
}
const values = [
  "anim",
  "noGlass",
  "sharp",
  "theme",
  "wallpaper",
  "accent",
  "docked",
  "taskbarCentered",
  "taskbarLabels",
  "taskbarPosition",
  "taskbarColored",
  "smallStart",
  "titleButtons",
  "titlebarLarge",
  "titlebarLeft",
];
function loadTheme(k) {
  const r = get_store_value(UserData);
  (r.sh.anim = k.anim),
    (r.sh.noGlass = k.noGlass),
    (r.sh.desktop.sharp = k.sharp),
    (r.sh.desktop.theme = k.theme),
    (r.sh.desktop.wallpaper = k.wallpaper),
    (r.sh.desktop.accent = k.accent),
    (r.sh.taskbar.docked = k.docked),
    (r.sh.taskbar.centered = k.taskbarCentered),
    (r.sh.taskbar.labels = k.taskbarLabels),
    (r.sh.taskbar.pos = k.taskbarPosition),
    (r.sh.start.small = k.smallStart),
    (r.sh.window.buttons = k.titleButtons),
    (r.sh.window.bigtb = k.titlebarLarge),
    (r.sh.window.lefttb = k.titlebarLeft),
    (r.sh.taskbar.colored = k.taskbarColored),
    UserData.set(r);
}
function saveCurrentTheme(k) {
  const r = `${Math.floor(Math.random() * 1e6)}`,
    p = get_store_value(UserData),
    v = {
      version: "1.0.0",
      name: k,
      author: get_store_value(UserName),
      anim: p.sh.anim,
      noGlass: p.sh.noGlass,
      sharp: p.sh.desktop.sharp,
      theme: p.sh.desktop.theme,
      wallpaper: p.sh.desktop.wallpaper,
      accent: p.sh.desktop.accent,
      docked: p.sh.taskbar.docked,
      taskbarCentered: p.sh.taskbar.centered,
      taskbarLabels: p.sh.taskbar.labels,
      taskbarPosition: p.sh.taskbar.pos,
      smallStart: p.sh.start.small,
      titleButtons: p.sh.window.buttons,
      titlebarLarge: p.sh.window.bigtb,
      titlebarLeft: p.sh.window.lefttb,
      taskbarColored: p.sh.taskbar.colored,
    };
  p.sh.userThemes || (p.sh.userThemes = {}),
    (p.sh.userThemes[r] = v),
    UserData.set(p);
}
function deleteCustomTheme(k) {
  const r = get_store_value(UserData);
  return !r.sh.userThemes || !r.sh.userThemes[k]
    ? !1
    : (delete r.sh.userThemes[k], UserData.set(r), !0);
}
function verifyTheme(k) {
  const r = Object.keys(k);
  for (let p = 0; p < values.length; p++) if (!r.includes(values[p])) return !1;
  return !0;
}
const FileLoaders = {
  appLoader: {
    name: "Application Import",
    description: "Load a third-party application",
    icon: apLoaderIcon,
    loader: loadAppFile,
    extensions: [".app", ".ealc", ".app.json"],
  },
  pdfOpener: {
    name: "Open In New Tab",
    description: "Open a PDF file in a new browser tab",
    icon: pdfOpenerIcon,
    loader: (k) => {
      const r = new Blob([new Uint8Array(k.data)], { type: "application/pdf" });
      window.open(URL.createObjectURL(r), "_blank");
    },
    extensions: [".pdf"],
  },
  loadTheme: {
    name: "Load theme file",
    description: "Apply theme file to ArcOS",
    loader: (k) => {
      const r = String.fromCharCode.apply(null, new Uint8Array(k.data));
      let p;
      try {
        p = JSON.parse(r);
      } catch {
        p = !1;
      }
      if (!p || !verifyTheme(p))
        return errorMessage(
          "Unable to load theme",
          "The theme file is invalid, or it could not be parsed. Please make sure you are trying to load a theme, and then try again.",
          loadThemeIcon,
          null,
          { caption: "OK", action() {} }
        );
      loadTheme(p);
    },
    icon: loadThemeIcon,
    extensions: [".arctheme"],
  },
  editFile: {
    name: "Edit config file",
    description: "Open file in Text Editor",
    icon: logo$9,
    loader(k) {
      openWith("TextEditor", k, !0);
    },
    extensions: [".conf"],
  },
  openInNew: {
    name: "Download",
    description: "Open file in a new tab to download it",
    loader: (k) => {
      const r = new Blob([new Uint8Array(k.data)], {
        type: k.mime.split(";")[0],
      });
      window.open(URL.createObjectURL(r), "_blank");
    },
    icon: openInNewIcon,
    extensions: [],
  },
};
function create_fragment$3i(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O = k[1].name + "",
    L,
    U,
    j,
    N = k[1].description + "",
    q,
    R,
    Q;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (I = element("div")),
        (F = element("div")),
        (L = text(O)),
        (U = space()),
        (j = element("div")),
        (q = text(N)),
        src_url_equal(v.src, ($ = k[1].icon)) || attr(v, "src", $),
        attr(v, "alt", (S = k[1].name)),
        attr(p, "class", "icon"),
        attr(F, "class", "name"),
        attr(j, "class", "description"),
        attr(r, "class", "option loader"),
        toggle_class(r, "selected", k[0] == k[1].name);
    },
    m(H, G) {
      insert(H, r, G),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, I),
        append(I, F),
        append(F, L),
        append(I, U),
        append(I, j),
        append(j, q),
        R ||
          ((Q = [listen(r, "click", k[2]), listen(r, "dblclick", k[3])]),
          (R = !0));
    },
    p(H, [G]) {
      G & 2 && !src_url_equal(v.src, ($ = H[1].icon)) && attr(v, "src", $),
        G & 2 && S !== (S = H[1].name) && attr(v, "alt", S),
        G & 2 && O !== (O = H[1].name + "") && set_data(L, O),
        G & 2 && N !== (N = H[1].description + "") && set_data(q, N),
        G & 3 && toggle_class(r, "selected", H[0] == H[1].name);
    },
    i: noop$1,
    o: noop$1,
    d(H) {
      H && detach(r), (R = !1), run_all(Q);
    },
  };
}
function instance$38(k, r, p) {
  let { loader: v } = r,
    { file: $ } = r,
    { selected: S = "" } = r,
    { loaderOptions: x } = r,
    { options: I } = r;
  function F() {
    p(0, (S = v.name));
  }
  function O() {
    v.loader($),
      setTimeout(() => {
        OpenWithFile.set(null);
      }, 1e3),
      closeWindow("OpenWithApp"),
      p(4, (x = [])),
      p(5, (I = []));
  }
  return (
    (k.$$set = (L) => {
      "loader" in L && p(1, (v = L.loader)),
        "file" in L && p(6, ($ = L.file)),
        "selected" in L && p(0, (S = L.selected)),
        "loaderOptions" in L && p(4, (x = L.loaderOptions)),
        "options" in L && p(5, (I = L.options));
    }),
    [S, v, F, O, x, I, $]
  );
}
class LoaderOption extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$38, create_fragment$3i, safe_not_equal, {
        loader: 1,
        file: 6,
        selected: 0,
        loaderOptions: 4,
        options: 5,
      });
  }
}
function create_fragment$3h(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O = k[1].info.name + "",
    L,
    U,
    j,
    N = k[1].info.description + "",
    q,
    R,
    Q,
    H = k[1].id + "",
    G,
    V,
    K;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (I = element("div")),
        (F = element("div")),
        (L = text(O)),
        (U = space()),
        (j = element("div")),
        (q = text(N)),
        (R = space()),
        (Q = element("div")),
        (G = text(H)),
        src_url_equal(v.src, ($ = k[1].info.icon)) || attr(v, "src", $),
        attr(v, "alt", (S = k[1].info.name)),
        attr(p, "class", "icon"),
        attr(F, "class", "name"),
        attr(j, "class", "description"),
        attr(Q, "class", "id"),
        attr(r, "class", "option"),
        toggle_class(r, "selected", k[0] == k[1].id);
    },
    m(Y, J) {
      insert(Y, r, J),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, I),
        append(I, F),
        append(F, L),
        append(I, U),
        append(I, j),
        append(j, q),
        append(r, R),
        append(r, Q),
        append(Q, G),
        V ||
          ((K = [listen(r, "click", k[2]), listen(r, "dblclick", k[3])]),
          (V = !0));
    },
    p(Y, [J]) {
      J & 2 && !src_url_equal(v.src, ($ = Y[1].info.icon)) && attr(v, "src", $),
        J & 2 && S !== (S = Y[1].info.name) && attr(v, "alt", S),
        J & 2 && O !== (O = Y[1].info.name + "") && set_data(L, O),
        J & 2 && N !== (N = Y[1].info.description + "") && set_data(q, N),
        J & 2 && H !== (H = Y[1].id + "") && set_data(G, H),
        J & 3 && toggle_class(r, "selected", Y[0] == Y[1].id);
    },
    i: noop$1,
    o: noop$1,
    d(Y) {
      Y && detach(r), (V = !1), run_all(K);
    },
  };
}
function instance$37(k, r, p) {
  let { app: v } = r,
    { file: $ } = r,
    { selected: S = "" } = r,
    { loaderOptions: x } = r,
    { options: I } = r;
  function F() {
    p(0, (S = v.id));
  }
  function O() {
    openWith(v.id, $, $.anymime),
      setTimeout(() => {
        OpenWithFile.set(null);
      }, 1e3),
      closeWindow("OpenWithApp"),
      p(4, (x = [])),
      p(5, (I = []));
  }
  return (
    (k.$$set = (L) => {
      "app" in L && p(1, (v = L.app)),
        "file" in L && p(6, ($ = L.file)),
        "selected" in L && p(0, (S = L.selected)),
        "loaderOptions" in L && p(4, (x = L.loaderOptions)),
        "options" in L && p(5, (I = L.options));
    }),
    [S, v, F, O, x, I, $]
  );
}
class Option extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$37, create_fragment$3h, safe_not_equal, {
        app: 1,
        file: 6,
        selected: 0,
        loaderOptions: 4,
        options: 5,
      });
  }
}
function get_each_context$H(k, r, p) {
  const v = k.slice();
  return (v[13] = r[p]), v;
}
function get_each_context_1$a(k, r, p) {
  const v = k.slice();
  return (v[16] = r[p]), v;
}
function create_each_block_1$a(k) {
  let r, p, v, $, S;
  function x(L) {
    k[7](L);
  }
  function I(L) {
    k[8](L);
  }
  function F(L) {
    k[9](L);
  }
  let O = { file: k[4], app: k[16] };
  return (
    k[1] !== void 0 && (O.loaderOptions = k[1]),
    k[0] !== void 0 && (O.options = k[0]),
    k[2] !== void 0 && (O.selected = k[2]),
    (r = new Option({ props: O })),
    binding_callbacks.push(() => bind$1(r, "loaderOptions", x)),
    binding_callbacks.push(() => bind$1(r, "options", I)),
    binding_callbacks.push(() => bind$1(r, "selected", F)),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(L, U) {
        mount_component(r, L, U), (S = !0);
      },
      p(L, U) {
        const j = {};
        U & 16 && (j.file = L[4]),
          U & 1 && (j.app = L[16]),
          !p &&
            U & 2 &&
            ((p = !0),
            (j.loaderOptions = L[1]),
            add_flush_callback(() => (p = !1))),
          !v &&
            U & 1 &&
            ((v = !0), (j.options = L[0]), add_flush_callback(() => (v = !1))),
          !$ &&
            U & 4 &&
            (($ = !0), (j.selected = L[2]), add_flush_callback(() => ($ = !1))),
          r.$set(j);
      },
      i(L) {
        S || (transition_in(r.$$.fragment, L), (S = !0));
      },
      o(L) {
        transition_out(r.$$.fragment, L), (S = !1);
      },
      d(L) {
        destroy_component(r, L);
      },
    }
  );
}
function create_if_block_1$m(k) {
  let r;
  return {
    c() {
      (r = element("p")),
        (r.textContent = "No apps found"),
        attr(r, "class", "noitems");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_each_block$H(k) {
  let r, p, v, $, S;
  function x(L) {
    k[10](L);
  }
  function I(L) {
    k[11](L);
  }
  function F(L) {
    k[12](L);
  }
  let O = { loader: k[13], file: k[4] };
  return (
    k[1] !== void 0 && (O.loaderOptions = k[1]),
    k[0] !== void 0 && (O.options = k[0]),
    k[2] !== void 0 && (O.selected = k[2]),
    (r = new LoaderOption({ props: O })),
    binding_callbacks.push(() => bind$1(r, "loaderOptions", x)),
    binding_callbacks.push(() => bind$1(r, "options", I)),
    binding_callbacks.push(() => bind$1(r, "selected", F)),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(L, U) {
        mount_component(r, L, U), (S = !0);
      },
      p(L, U) {
        const j = {};
        U & 2 && (j.loader = L[13]),
          U & 16 && (j.file = L[4]),
          !p &&
            U & 2 &&
            ((p = !0),
            (j.loaderOptions = L[1]),
            add_flush_callback(() => (p = !1))),
          !v &&
            U & 1 &&
            ((v = !0), (j.options = L[0]), add_flush_callback(() => (v = !1))),
          !$ &&
            U & 4 &&
            (($ = !0), (j.selected = L[2]), add_flush_callback(() => ($ = !1))),
          r.$set(j);
      },
      i(L) {
        S || (transition_in(r.$$.fragment, L), (S = !0));
      },
      o(L) {
        transition_out(r.$$.fragment, L), (S = !1);
      },
      d(L) {
        destroy_component(r, L);
      },
    }
  );
}
function create_if_block$1a(k) {
  let r;
  return {
    c() {
      (r = element("p")),
        (r.textContent = "No handlers found"),
        attr(r, "class", "noitems");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$3g(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L,
    U,
    j,
    N,
    q,
    R,
    Q,
    H,
    G,
    V,
    K,
    Y,
    J,
    Z,
    X = k[0],
    ee = [];
  for (let oe = 0; oe < X.length; oe += 1)
    ee[oe] = create_each_block_1$a(get_each_context_1$a(k, X, oe));
  const te = (oe) =>
    transition_out(ee[oe], 1, 1, () => {
      ee[oe] = null;
    });
  let re = !k[0].length && create_if_block_1$m(),
    fe = k[1],
    le = [];
  for (let oe = 0; oe < fe.length; oe += 1)
    le[oe] = create_each_block$H(get_each_context$H(k, fe, oe));
  const se = (oe) =>
    transition_out(le[oe], 1, 1, () => {
      le[oe] = null;
    });
  let ae = !k[1].length && create_if_block$1a();
  return {
    c() {
      (r = element("div")),
        (p = element("p")),
        (v = text("Select an item to open ")),
        ($ = text(k[3])),
        (S = space()),
        (x = element("div")),
        (I = element("p")),
        (I.textContent = "Apps"),
        (F = space());
      for (let oe = 0; oe < ee.length; oe += 1) ee[oe].c();
      (O = space()),
        re && re.c(),
        (L = space()),
        (U = element("p")),
        (U.textContent = "Handlers"),
        (j = space());
      for (let oe = 0; oe < le.length; oe += 1) le[oe].c();
      (N = space()),
        ae && ae.c(),
        (q = space()),
        (R = element("div")),
        (Q = element("button")),
        (H = text("Open")),
        (V = space()),
        (K = element("button")),
        (K.textContent = "Cancel"),
        attr(p, "class", "title"),
        attr(I, "class", "category"),
        attr(U, "class", "category"),
        attr(x, "class", "options"),
        (Q.disabled = G = !k[2]),
        attr(R, "class", "actions"),
        attr(r, "class", "content");
    },
    m(oe, ie) {
      insert(oe, r, ie),
        append(r, p),
        append(p, v),
        append(p, $),
        append(r, S),
        append(r, x),
        append(x, I),
        append(x, F);
      for (let ne = 0; ne < ee.length; ne += 1) ee[ne] && ee[ne].m(x, null);
      append(x, O),
        re && re.m(x, null),
        append(x, L),
        append(x, U),
        append(x, j);
      for (let ne = 0; ne < le.length; ne += 1) le[ne] && le[ne].m(x, null);
      append(x, N),
        ae && ae.m(x, null),
        append(r, q),
        append(r, R),
        append(R, Q),
        append(Q, H),
        append(R, V),
        append(R, K),
        (Y = !0),
        J ||
          ((Z = [listen(Q, "click", k[5]), listen(K, "click", k[6])]),
          (J = !0));
    },
    p(oe, [ie]) {
      if (((!Y || ie & 8) && set_data($, oe[3]), ie & 23)) {
        X = oe[0];
        let ne;
        for (ne = 0; ne < X.length; ne += 1) {
          const ce = get_each_context_1$a(oe, X, ne);
          ee[ne]
            ? (ee[ne].p(ce, ie), transition_in(ee[ne], 1))
            : ((ee[ne] = create_each_block_1$a(ce)),
              ee[ne].c(),
              transition_in(ee[ne], 1),
              ee[ne].m(x, O));
        }
        for (group_outros(), ne = X.length; ne < ee.length; ne += 1) te(ne);
        check_outros();
      }
      if (
        (oe[0].length
          ? re && (re.d(1), (re = null))
          : re || ((re = create_if_block_1$m()), re.c(), re.m(x, L)),
        ie & 23)
      ) {
        fe = oe[1];
        let ne;
        for (ne = 0; ne < fe.length; ne += 1) {
          const ce = get_each_context$H(oe, fe, ne);
          le[ne]
            ? (le[ne].p(ce, ie), transition_in(le[ne], 1))
            : ((le[ne] = create_each_block$H(ce)),
              le[ne].c(),
              transition_in(le[ne], 1),
              le[ne].m(x, N));
        }
        for (group_outros(), ne = fe.length; ne < le.length; ne += 1) se(ne);
        check_outros();
      }
      oe[1].length
        ? ae && (ae.d(1), (ae = null))
        : ae || ((ae = create_if_block$1a()), ae.c(), ae.m(x, null)),
        (!Y || (ie & 4 && G !== (G = !oe[2]))) && (Q.disabled = G);
    },
    i(oe) {
      if (!Y) {
        for (let ie = 0; ie < X.length; ie += 1) transition_in(ee[ie]);
        for (let ie = 0; ie < fe.length; ie += 1) transition_in(le[ie]);
        Y = !0;
      }
    },
    o(oe) {
      ee = ee.filter(Boolean);
      for (let ie = 0; ie < ee.length; ie += 1) transition_out(ee[ie]);
      le = le.filter(Boolean);
      for (let ie = 0; ie < le.length; ie += 1) transition_out(le[ie]);
      Y = !1;
    },
    d(oe) {
      oe && detach(r),
        destroy_each(ee, oe),
        re && re.d(),
        destroy_each(le, oe),
        ae && ae.d(),
        (J = !1),
        run_all(Z);
    },
  };
}
function instance$36(k, r, p) {
  let v;
  component_subscribe(k, OpenWithFile, (Q) => p(4, (v = Q)));
  let $ = [],
    S = [],
    x = "",
    I = "";
  OpenWithFile.subscribe((Q) => {
    if (!Q) return p(3, (I = "file"));
    p(3, (I = Q.name)), p(0, ($ = [])), p(1, (S = []));
    let H = [];
    Q.anymime ? (H = getAllFileHandlers()) : (H = findAppToOpen(Q.mime));
    for (let V = 0; V < H.length; V++) $.push(getWindow(H[V]));
    p(2, (x = ""));
    const G = Object.entries(FileLoaders);
    for (let V = 0; V < G.length; V++) {
      const Y = G[V][1];
      for (let J = 0; J < Y.extensions.length; J++)
        I.endsWith(Y.extensions[J]) && S.push(Y);
      Y.extensions.length || S.push(Y);
    }
  });
  function F() {
    const Q = getWindow(x);
    if (Q) openWith(Q.id, v, v.anymime);
    else
      for (let H = 0; H < S.length; H++)
        S[H].name == x && S[H].loader(v),
          set_store_value(OpenWithFile, (v = null), v);
    setTimeout(() => {
      OpenWithFile.set(null);
    }, 1e3),
      O();
  }
  function O() {
    isFullscreenWindow.set(!1), closeWindow("OpenWithApp");
  }
  function L(Q) {
    (S = Q), p(1, S);
  }
  function U(Q) {
    ($ = Q), p(0, $);
  }
  function j(Q) {
    (x = Q), p(2, x);
  }
  function N(Q) {
    (S = Q), p(1, S);
  }
  function q(Q) {
    ($ = Q), p(0, $);
  }
  function R(Q) {
    (x = Q), p(2, x);
  }
  return [$, S, x, I, v, F, O, L, U, j, N, q, R];
}
class OpenWith extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$36, create_fragment$3g, safe_not_equal, {});
  }
}
const OpenWithApp = {
    info: {
      name: "Open With",
      description: "Open a file with an app",
      builtin: !0,
      version: "1.0.0",
      author: "Izaak Kuipers",
      hidden: !0,
      icon: appsIcon,
    },
    size: { w: 450, h: 550 },
    pos: { x: 30, y: 40 },
    minSize: { w: 450, h: 550 },
    maxSize: { w: 450, h: 550 },
    controls: { min: !1, max: !1, cls: !1 },
    state: {
      headless: !0,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !0 },
    },
    content: OpenWith,
    glass: !0,
    events: {
      close() {
        OpenWithFile.set(null);
      },
    },
  },
  OpenWithFile = writable(null);
function findAppToOpen(k) {
  Log({
    source: "fs/open.ts: findAppToOpen",
    msg: `Compiling a list of file handlers that can open mimtype "${k}"...`,
    level: LogLevel.info,
  });
  const r = [],
    p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++)
    p[v].fileMimes && p[v].fileMimes.includes(k) && r.push(p[v].id);
  return r;
}
function findLoaderToOpen(k) {
  let r = [];
  const p = Object.entries(FileLoaders);
  for (let v = 0; v < p.length; v++) {
    const S = p[v][1];
    for (let x = 0; x < S.extensions.length; x++)
      k.endsWith(S.extensions[x]) && r.push(S);
    S.extensions.length || r.push(S);
  }
  return r;
}
function getAllFileHandlers() {
  Log({
    source: "fs/open.ts: getAllFileHandlers",
    msg: "Compiling a list of file handler IDs...",
    level: LogLevel.info,
  });
  const k = [],
    r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++) r[p].fileMimes && k.push(r[p].id);
  return k;
}
function openWithDialog(k) {
  if (isDisabled("OpenWithApp"))
    return errorMessage(
      "Can't open file",
      `The OpenWithApp application is disabled, so you can't choose an app to open ${k.name}.`,
      null,
      null,
      { caption: "OK", action() {} },
      {
        caption: "Enable OpenWithApp",
        action() {
          enableApp("OpenWithApp"),
            OpenWithFile.set(k),
            openWindow("OpenWithApp");
        },
      }
    );
  Log({
    source: "fs/open.ts: openWithDialog",
    msg: `Opening ArcOS.OpenWith for "${k.name}"`,
    level: LogLevel.info,
  }),
    OpenWithFile.set(k),
    openWindow("OpenWithApp");
}
function openWith(k, r, p) {
  Log({
    source: "fs/open.ts: openWith",
    msg: `Opening ${r.name} with ArcOS.${k}`,
    level: LogLevel.info,
  });
  const v = get_store_value(WindowStore);
  for (let $ = 0; $ < v.length; $++) {
    const S = v[$];
    if (!(!S.fileMimes || (!S.fileMimes.includes(r.mime) && !p) || k != S.id))
      return (
        (S.openedFile = r),
        openWindow(k),
        focusedWindowId.set(k),
        S.events && S.events.openFile && S.events.openFile(S),
        !0
      );
  }
  return !1;
}
async function openUserFile(k) {
  Log({
    source: "fs/open.ts: openUserFile",
    msg: `Converting "${k.filename}": UserFile -> ArcFile: to make openable`,
    level: LogLevel.info,
  });
  let r = {
    data: await readFile(k.scopedPath),
    name: k.filename,
    path: k.scopedPath,
    mime: k.mime,
  };
  const p = findAppToOpen(k.mime),
    v = findLoaderToOpen(k.filename);
  return !(p.length > 0) && !(v.length > 1)
    ? r
    : p.length > 0
    ? openWith(p[0], r) || r
    : (v.length == 2 && v[0].loader(r), !0);
}
function create_fragment$3f(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F = k[0].filename + "",
    O,
    L,
    U,
    j = k[0].mime.split("; ")[0].split("/").join(" - ") + "",
    N,
    q,
    R,
    Q = formatBytes(k[0].size) + "",
    H,
    G,
    V,
    K,
    Y,
    J,
    Z,
    X,
    ee;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (I = element("div")),
        (O = text(F)),
        (L = space()),
        (U = element("div")),
        (N = text(j)),
        (q = space()),
        (R = element("div")),
        (H = text(Q)),
        (G = space()),
        (V = element("div")),
        (K = element("button")),
        (K.textContent = "launch"),
        src_url_equal(v.src, ($ = k[1])) || attr(v, "src", $),
        attr(v, "alt", (S = k[0].filename)),
        attr(p, "class", "image"),
        attr(I, "class", "name"),
        attr(U, "class", "mime"),
        attr(R, "class", "size"),
        attr(K, "class", "material-icons-round"),
        attr(V, "class", "options"),
        attr(r, "class", "item file"),
        attr(r, "title", (Y = k[0].scopedPath)),
        attr(r, "data-path", (J = k[0].scopedPath)),
        attr(r, "data-type", "file"),
        attr(r, "data-name", (Z = k[0].filename)),
        attr(r, "data-caller", "listitem-file"),
        toggle_class(r, "selected", k[2] == k[0].filename),
        toggle_class(r, "cutting", k[3] && k[3].name == k[0].filename);
    },
    m(te, re) {
      insert(te, r, re),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, I),
        append(I, O),
        append(r, L),
        append(r, U),
        append(U, N),
        append(r, q),
        append(r, R),
        append(R, H),
        append(r, G),
        append(r, V),
        append(V, K),
        X ||
          ((ee = [
            listen(K, "click", k[6]),
            listen(r, "click", k[4]),
            listen(r, "contextmenu", k[4]),
            listen(r, "dblclick", k[5]),
          ]),
          (X = !0));
    },
    p(te, [re]) {
      re & 2 && !src_url_equal(v.src, ($ = te[1])) && attr(v, "src", $),
        re & 1 && S !== (S = te[0].filename) && attr(v, "alt", S),
        re & 1 && F !== (F = te[0].filename + "") && set_data(O, F),
        re & 1 &&
          j !== (j = te[0].mime.split("; ")[0].split("/").join(" - ") + "") &&
          set_data(N, j),
        re & 1 && Q !== (Q = formatBytes(te[0].size) + "") && set_data(H, Q),
        re & 1 && Y !== (Y = te[0].scopedPath) && attr(r, "title", Y),
        re & 1 && J !== (J = te[0].scopedPath) && attr(r, "data-path", J),
        re & 1 && Z !== (Z = te[0].filename) && attr(r, "data-name", Z),
        re & 5 && toggle_class(r, "selected", te[2] == te[0].filename),
        re & 9 &&
          toggle_class(r, "cutting", te[3] && te[3].name == te[0].filename);
    },
    i: noop$1,
    o: noop$1,
    d(te) {
      te && detach(r), (X = !1), run_all(ee);
    },
  };
}
function instance$35(k, r, p) {
  let v, $, S;
  component_subscribe(k, FileBrowserOpeningFile, (j) => p(7, (v = j))),
    component_subscribe(k, FileBrowserSelectedFilename, (j) => p(2, ($ = j))),
    component_subscribe(k, FileBrowserCuttingFilename, (j) => p(3, (S = j)));
  let { file: x } = r,
    I = icon$2;
  function F() {
    set_store_value(FileBrowserSelectedFilename, ($ = x.filename), $);
  }
  async function O() {
    set_store_value(FileBrowserOpeningFile, (v = x), v),
      showOverlay("openingFile", "FileManager");
    let j = await openUserFile(x);
    if (
      (hideOverlay("openingFile", "FileManager"),
      set_store_value(FileBrowserOpeningFile, (v = null), v),
      j != !0)
    ) {
      const N = j;
      createOverlayableError(
        {
          title: `Unable to open ${x.filename}`,
          message:
            "You don't have an app or handler that can open this type of file.",
          buttons: [
            {
              caption: "Close",
              action: () => {
                j = null;
              },
            },
            { caption: "Open With...", action: () => L(N) },
          ],
          image: icon$2,
        },
        "FileManager"
      );
    }
    j = null;
  }
  function L(j) {
    openWithDialog({ ...j, anymime: !0 });
  }
  async function U() {
    set_store_value(FileBrowserOpeningFile, (v = x), v),
      showOverlay("openingFile", "FileManager");
    let j = {
      data: await readFile(x.scopedPath),
      name: x.filename,
      path: x.scopedPath,
      mime: x.mime,
    };
    L(j),
      hideOverlay("openingFile", "FileManager"),
      set_store_value(FileBrowserOpeningFile, (v = x), v);
  }
  return (
    onMount(() => {
      p(1, (I = getMimeIcon(x.filename)));
    }),
    FileBrowserDirContents.subscribe(() => p(1, (I = getMimeIcon(x.filename)))),
    (k.$$set = (j) => {
      "file" in j && p(0, (x = j.file));
    }),
    [x, I, $, S, F, O, U]
  );
}
let File$3 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$35, create_fragment$3f, safe_not_equal, {
        file: 0,
      });
  }
};
function create_fragment$3e(k) {
  let r;
  return {
    c() {
      (r = element("button")),
        (r.innerHTML = `<div class="image"></div> 
  <div class="name">Name</div> 
  <div class="mime">Type</div> 
  <div class="size">Size</div>`),
        attr(r, "class", "item head");
    },
    m(p, v) {
      insert(p, r, v);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
class TopRow extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$3e, safe_not_equal, {});
  }
}
function get_each_context$G(k, r, p) {
  const v = k.slice();
  return (v[3] = r[p]), v;
}
function get_each_context_1$9(k, r, p) {
  const v = k.slice();
  return (v[6] = r[p]), v;
}
function create_else_block_1$2(k) {
  let r, p, v, $, S, x;
  p = new TopRow({});
  let I = k[1],
    F = [];
  for (let N = 0; N < I.length; N += 1)
    F[N] = create_each_block_1$9(get_each_context_1$9(k, I, N));
  const O = (N) =>
    transition_out(F[N], 1, 1, () => {
      F[N] = null;
    });
  let L = k[0],
    U = [];
  for (let N = 0; N < L.length; N += 1)
    U[N] = create_each_block$G(get_each_context$G(k, L, N));
  const j = (N) =>
    transition_out(U[N], 1, 1, () => {
      U[N] = null;
    });
  return {
    c() {
      (r = element("div")),
        create_component(p.$$.fragment),
        (v = space()),
        ($ = element("div"));
      for (let N = 0; N < F.length; N += 1) F[N].c();
      S = space();
      for (let N = 0; N < U.length; N += 1) U[N].c();
      attr($, "class", "items"), attr(r, "class", "listview");
    },
    m(N, q) {
      insert(N, r, q), mount_component(p, r, null), append(r, v), append(r, $);
      for (let R = 0; R < F.length; R += 1) F[R] && F[R].m($, null);
      append($, S);
      for (let R = 0; R < U.length; R += 1) U[R] && U[R].m($, null);
      x = !0;
    },
    p(N, q) {
      if (q & 2) {
        I = N[1];
        let R;
        for (R = 0; R < I.length; R += 1) {
          const Q = get_each_context_1$9(N, I, R);
          F[R]
            ? (F[R].p(Q, q), transition_in(F[R], 1))
            : ((F[R] = create_each_block_1$9(Q)),
              F[R].c(),
              transition_in(F[R], 1),
              F[R].m($, S));
        }
        for (group_outros(), R = I.length; R < F.length; R += 1) O(R);
        check_outros();
      }
      if (q & 1) {
        L = N[0];
        let R;
        for (R = 0; R < L.length; R += 1) {
          const Q = get_each_context$G(N, L, R);
          U[R]
            ? (U[R].p(Q, q), transition_in(U[R], 1))
            : ((U[R] = create_each_block$G(Q)),
              U[R].c(),
              transition_in(U[R], 1),
              U[R].m($, null));
        }
        for (group_outros(), R = L.length; R < U.length; R += 1) j(R);
        check_outros();
      }
    },
    i(N) {
      if (!x) {
        transition_in(p.$$.fragment, N);
        for (let q = 0; q < I.length; q += 1) transition_in(F[q]);
        for (let q = 0; q < L.length; q += 1) transition_in(U[q]);
        x = !0;
      }
    },
    o(N) {
      transition_out(p.$$.fragment, N), (F = F.filter(Boolean));
      for (let q = 0; q < F.length; q += 1) transition_out(F[q]);
      U = U.filter(Boolean);
      for (let q = 0; q < U.length; q += 1) transition_out(U[q]);
      x = !1;
    },
    d(N) {
      N && detach(r),
        destroy_component(p),
        destroy_each(F, N),
        destroy_each(U, N);
    },
  };
}
function create_if_block$19(k) {
  let r, p, v, $;
  const S = [create_if_block_1$l, create_else_block$n],
    x = [];
  function I(F, O) {
    return F[2] ? 0 : 1;
  }
  return (
    (r = I(k)),
    (p = x[r] = S[r](k)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        x[r].m(F, O), insert(F, v, O), ($ = !0);
      },
      p(F, O) {
        let L = r;
        (r = I(F)),
          r !== L &&
            (group_outros(),
            transition_out(x[L], 1, 1, () => {
              x[L] = null;
            }),
            check_outros(),
            (p = x[r]),
            p || ((p = x[r] = S[r](F)), p.c()),
            transition_in(p, 1),
            p.m(v.parentNode, v));
      },
      i(F) {
        $ || (transition_in(p), ($ = !0));
      },
      o(F) {
        transition_out(p), ($ = !1);
      },
      d(F) {
        x[r].d(F), F && detach(v);
      },
    }
  );
}
function create_each_block_1$9(k) {
  let r, p;
  return (
    (r = new Dir$4({ props: { dir: k[6] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 2 && (S.dir = v[6]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$G(k) {
  let r, p;
  return (
    (r = new File$3({ props: { file: k[3] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.file = v[3]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_else_block$n(k) {
  let r;
  return {
    c() {
      (r = element("div")),
        (r.textContent = "This folder is empty."),
        attr(r, "class", "nofiles");
    },
    m(p, v) {
      insert(p, r, v);
    },
    i: noop$1,
    o: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
function create_if_block_1$l(k) {
  let r, p, v, $, S, x;
  return (
    (v = new Spinner({ props: { height: 32 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          create_component(v.$$.fragment),
          ($ = space()),
          (S = element("p")),
          (S.textContent = "Reading items..."),
          attr(S, "class", "caption"),
          attr(p, "class", "loading-inner"),
          attr(r, "class", "loading");
      },
      m(I, F) {
        insert(I, r, F),
          append(r, p),
          mount_component(v, p, null),
          append(p, $),
          append(p, S),
          (x = !0);
      },
      i(I) {
        x || (transition_in(v.$$.fragment, I), (x = !0));
      },
      o(I) {
        transition_out(v.$$.fragment, I), (x = !1);
      },
      d(I) {
        I && detach(r), destroy_component(v);
      },
    }
  );
}
function create_fragment$3d(k) {
  let r, p, v, $;
  const S = [create_if_block$19, create_else_block_1$2],
    x = [];
  function I(F, O) {
    return !F[1].length && !F[0].length ? 0 : 1;
  }
  return (
    (r = I(k)),
    (p = x[r] = S[r](k)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        x[r].m(F, O), insert(F, v, O), ($ = !0);
      },
      p(F, [O]) {
        let L = r;
        (r = I(F)),
          r === L
            ? x[r].p(F, O)
            : (group_outros(),
              transition_out(x[L], 1, 1, () => {
                x[L] = null;
              }),
              check_outros(),
              (p = x[r]),
              p ? p.p(F, O) : ((p = x[r] = S[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        $ || (transition_in(p), ($ = !0));
      },
      o(F) {
        transition_out(p), ($ = !1);
      },
      d(F) {
        x[r].d(F), F && detach(v);
      },
    }
  );
}
function instance$34(k, r, p) {
  let v;
  component_subscribe(k, FileBrowserRefreshing, (x) => p(2, (v = x)));
  let { files: $ = [] } = r,
    { dirs: S = [] } = r;
  return (
    (k.$$set = (x) => {
      "files" in x && p(0, ($ = x.files)), "dirs" in x && p(1, (S = x.dirs));
    }),
    [$, S, v]
  );
}
class ListView extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$34, create_fragment$3d, safe_not_equal, {
        files: 0,
        dirs: 1,
      });
  }
}
function create_if_block$18(k) {
  let r, p, v, $;
  return {
    c() {
      (r = element("button")), (p = text(k[0])), attr(r, "class", "crumb");
    },
    m(S, x) {
      insert(S, r, x),
        append(r, p),
        v || (($ = listen(r, "click", k[1])), (v = !0));
    },
    p(S, x) {
      x & 1 && set_data(p, S[0]);
    },
    d(S) {
      S && detach(r), (v = !1), $();
    },
  };
}
function create_fragment$3c(k) {
  let r,
    p = k[0] && k[0] != "." && create_if_block$18(k);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, $) {
      p && p.m(v, $), insert(v, r, $);
    },
    p(v, [$]) {
      v[0] && v[0] != "."
        ? p
          ? p.p(v, $)
          : ((p = create_if_block$18(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$33(k, r, p) {
  let { crumb: v } = r,
    { path: $ } = r;
  function S() {
    fbClass.goToDirectory($);
  }
  return (
    (k.$$set = (x) => {
      "crumb" in x && p(0, (v = x.crumb)), "path" in x && p(2, ($ = x.path));
    }),
    [v, S, $]
  );
}
let Crumb$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$33, create_fragment$3c, safe_not_equal, {
        crumb: 0,
        path: 2,
      });
  }
};
function get_each_context$F(k, r, p) {
  const v = k.slice();
  return (v[4] = r[p]), (v[6] = p), v;
}
function create_each_block$F(k) {
  let r, p;
  return (
    (r = new Crumb$1({ props: { crumb: k[4], path: k[2](k[4], k[6]) } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.crumb = v[4]),
          $ & 1 && (S.path = v[2](v[4], v[6])),
          r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$3b(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O = k[0],
    L = [];
  for (let j = 0; j < O.length; j += 1)
    L[j] = create_each_block$F(get_each_context$F(k, O, j));
  const U = (j) =>
    transition_out(L[j], 1, 1, () => {
      L[j] = null;
    });
  return {
    c() {
      (r = element("button")),
        (r.textContent = "home"),
        (p = space()),
        (v = element("div"));
      for (let j = 0; j < L.length; j += 1) L[j].c();
      ($ = space()),
        (S = element("button")),
        (S.textContent = "refresh"),
        attr(r, "class", "home material-icons-round"),
        attr(v, "class", "addressbar"),
        attr(S, "class", "refresh material-icons-round");
    },
    m(j, N) {
      insert(j, r, N), insert(j, p, N), insert(j, v, N);
      for (let q = 0; q < L.length; q += 1) L[q] && L[q].m(v, null);
      insert(j, $, N),
        insert(j, S, N),
        (x = !0),
        I ||
          ((F = [listen(r, "click", k[1]), listen(S, "click", k[3])]),
          (I = !0));
    },
    p(j, [N]) {
      if (N & 5) {
        O = j[0];
        let q;
        for (q = 0; q < O.length; q += 1) {
          const R = get_each_context$F(j, O, q);
          L[q]
            ? (L[q].p(R, N), transition_in(L[q], 1))
            : ((L[q] = create_each_block$F(R)),
              L[q].c(),
              transition_in(L[q], 1),
              L[q].m(v, null));
        }
        for (group_outros(), q = O.length; q < L.length; q += 1) U(q);
        check_outros();
      }
    },
    i(j) {
      if (!x) {
        for (let N = 0; N < O.length; N += 1) transition_in(L[N]);
        x = !0;
      }
    },
    o(j) {
      L = L.filter(Boolean);
      for (let N = 0; N < L.length; N += 1) transition_out(L[N]);
      x = !1;
    },
    d(j) {
      j && detach(r),
        j && detach(p),
        j && detach(v),
        destroy_each(L, j),
        j && detach($),
        j && detach(S),
        (I = !1),
        run_all(F);
    },
  };
}
function instance$32(k, r, p) {
  let v = [];
  FileBrowserCurrentDir.subscribe((I) => {
    p(0, (v = I.split("/")));
  });
  function $() {
    fbClass.goToDirectory("./");
  }
  function S(I, F) {
    let O = "";
    for (let L = 0; L < F; L++) O += `${v[L]}/`;
    return `${O}${I}`;
  }
  return [v, $, S, () => fbClass.refresh()];
}
class PathCrumbs extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$32, create_fragment$3b, safe_not_equal, {});
  }
}
function create_fragment$3a(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I = k[0].name + "",
    F,
    O,
    L;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (S = space()),
        (x = element("p")),
        (F = text(I)),
        src_url_equal(p.src, (v = folder)) || attr(p, "src", v),
        attr(p, "alt", ($ = k[0].name)),
        attr(x, "class", "name"),
        attr(r, "class", "folder"),
        toggle_class(r, "selected", k[1]);
    },
    m(U, j) {
      insert(U, r, j),
        append(r, p),
        append(r, S),
        append(r, x),
        append(x, F),
        O || ((L = listen(r, "click", k[2])), (O = !0));
    },
    p(U, [j]) {
      j & 1 && $ !== ($ = U[0].name) && attr(p, "alt", $),
        j & 1 && I !== (I = U[0].name + "") && set_data(F, I),
        j & 2 && toggle_class(r, "selected", U[1]);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r), (O = !1), L();
    },
  };
}
function instance$31(k, r, p) {
  let { folder: v } = r,
    $ = !1;
  async function S() {
    fbClass.goToDirectory(v.scopedPath);
  }
  return (
    FileBrowserCurrentDir.subscribe((x) => {
      const I = x.replace("./", "");
      p(1, ($ = I.startsWith(v.name)));
    }),
    (k.$$set = (x) => {
      "folder" in x && p(0, (v = x.folder));
    }),
    [v, $, S]
  );
}
class Folder extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$31, create_fragment$3a, safe_not_equal, {
        folder: 0,
      });
  }
}
function create_fragment$39(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I = formatBytes(k[0].used) + "",
    F,
    O,
    L,
    U,
    j = formatBytes(k[0].max) + "",
    N;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("div")),
        ($ = space()),
        (S = element("div")),
        (x = element("span")),
        (F = text(I)),
        (L = space()),
        (U = element("div")),
        (N = text(j)),
        attr(v, "class", "inner"),
        set_style(v, "width", k[1] + "%"),
        attr(p, "class", "bar"),
        attr(x, "title", (O = k[0].used + "B")),
        toggle_class(x, "invalid", k[0].used > k[0].max),
        attr(U, "class", "right"),
        attr(S, "class", "stat"),
        attr(r, "class", "quota-renderer");
    },
    m(q, R) {
      insert(q, r, R),
        append(r, p),
        append(p, v),
        append(r, $),
        append(r, S),
        append(S, x),
        append(x, F),
        append(S, L),
        append(S, U),
        append(U, N);
    },
    p(q, [R]) {
      R & 2 && set_style(v, "width", q[1] + "%"),
        R & 1 && I !== (I = formatBytes(q[0].used) + "") && set_data(F, I),
        R & 1 && O !== (O = q[0].used + "B") && attr(x, "title", O),
        R & 1 && toggle_class(x, "invalid", q[0].used > q[0].max),
        R & 1 && j !== (j = formatBytes(q[0].max) + "") && set_data(N, j);
    },
    i: noop$1,
    o: noop$1,
    d(q) {
      q && detach(r);
    },
  };
}
function instance$30(k, r, p) {
  let v = defaultQuota,
    $ = 0;
  FileBrowserDirContents.subscribe(S);
  async function S() {
    p(0, (v = await getFSQuota())),
      p(1, ($ = Math.round((100 / v.max) * v.used)));
  }
  return [v, $];
}
class QuotaRenderer extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$30, create_fragment$39, safe_not_equal, {});
  }
}
function get_each_context$E(k, r, p) {
  const v = k.slice();
  return (v[1] = r[p]), v;
}
function create_each_block$E(k) {
  let r, p;
  return (
    (r = new Folder({ props: { folder: k[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.folder = v[1]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$38(k) {
  let r,
    p,
    v,
    $,
    S,
    x = k[0],
    I = [];
  for (let O = 0; O < x.length; O += 1)
    I[O] = create_each_block$E(get_each_context$E(k, x, O));
  const F = (O) =>
    transition_out(I[O], 1, 1, () => {
      I[O] = null;
    });
  return (
    ($ = new QuotaRenderer({})),
    {
      c() {
        (r = element("div")), (p = element("div"));
        for (let O = 0; O < I.length; O += 1) I[O].c();
        (v = space()),
          create_component($.$$.fragment),
          attr(p, "class", "dirs"),
          attr(r, "class", "sidebar");
      },
      m(O, L) {
        insert(O, r, L), append(r, p);
        for (let U = 0; U < I.length; U += 1) I[U] && I[U].m(p, null);
        append(r, v), mount_component($, r, null), (S = !0);
      },
      p(O, [L]) {
        if (L & 1) {
          x = O[0];
          let U;
          for (U = 0; U < x.length; U += 1) {
            const j = get_each_context$E(O, x, U);
            I[U]
              ? (I[U].p(j, L), transition_in(I[U], 1))
              : ((I[U] = create_each_block$E(j)),
                I[U].c(),
                transition_in(I[U], 1),
                I[U].m(p, null));
          }
          for (group_outros(), U = x.length; U < I.length; U += 1) F(U);
          check_outros();
        }
      },
      i(O) {
        if (!S) {
          for (let L = 0; L < x.length; L += 1) transition_in(I[L]);
          transition_in($.$$.fragment, O), (S = !0);
        }
      },
      o(O) {
        I = I.filter(Boolean);
        for (let L = 0; L < I.length; L += 1) transition_out(I[L]);
        transition_out($.$$.fragment, O), (S = !1);
      },
      d(O) {
        O && detach(r), destroy_each(I, O), destroy_component($);
      },
    }
  );
}
function instance$2$(k, r, p) {
  let v = [];
  return (
    FileBrowserDirContents.subscribe(async ($) => {
      p(0, (v = (await getDirectory("./")).directories));
    }),
    [v]
  );
}
let SideBar$2 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2$, create_fragment$38, safe_not_equal, {});
  }
};
const tile = "";
function create_fragment$37(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I = k[0].name + "",
    F,
    O,
    L;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (S = space()),
        (x = element("p")),
        (F = text(I)),
        src_url_equal(p.src, (v = folder)) || attr(p, "src", v),
        attr(p, "alt", ($ = k[0].name)),
        attr(x, "class", "name"),
        attr(r, "class", "tile dir"),
        toggle_class(r, "selected", k[1] == k[0].name),
        toggle_class(r, "cutting", k[2] && k[2].name == k[0].name);
    },
    m(U, j) {
      insert(U, r, j),
        append(r, p),
        append(r, S),
        append(r, x),
        append(x, F),
        O ||
          ((L = [listen(r, "click", k[3]), listen(r, "dblclick", k[4])]),
          (O = !0));
    },
    p(U, [j]) {
      j & 1 && $ !== ($ = U[0].name) && attr(p, "alt", $),
        j & 1 && I !== (I = U[0].name + "") && set_data(F, I),
        j & 3 && toggle_class(r, "selected", U[1] == U[0].name),
        j & 5 && toggle_class(r, "cutting", U[2] && U[2].name == U[0].name);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r), (O = !1), run_all(L);
    },
  };
}
function instance$2_(k, r, p) {
  let v, $;
  component_subscribe(k, FileBrowserSelectedFilename, (F) => p(1, (v = F))),
    component_subscribe(k, FileBrowserCuttingFilename, (F) => p(2, ($ = F)));
  let { dir: S } = r;
  function x() {
    set_store_value(FileBrowserSelectedFilename, (v = S.name), v);
  }
  function I() {
    fbClass.goToDirectory(S.scopedPath);
  }
  return (
    (k.$$set = (F) => {
      "dir" in F && p(0, (S = F.dir));
    }),
    [S, v, $, x, I]
  );
}
let Dir$3 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2_, create_fragment$37, safe_not_equal, {
        dir: 0,
      });
  }
};
function create_fragment$36(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I = k[0].filename + "",
    F,
    O,
    L,
    U;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (S = space()),
        (x = element("p")),
        (F = text(I)),
        src_url_equal(p.src, (v = k[1])) || attr(p, "src", v),
        attr(p, "alt", ($ = k[0].filename)),
        attr(x, "class", "name"),
        attr(r, "class", "tile file"),
        attr(r, "title", (O = k[0].scopedPath)),
        toggle_class(r, "selected", k[2] == k[0].filename),
        toggle_class(r, "cutting", k[3] && k[3].name == k[0].filename);
    },
    m(j, N) {
      insert(j, r, N),
        append(r, p),
        append(r, S),
        append(r, x),
        append(x, F),
        L ||
          ((U = [listen(r, "click", k[4]), listen(r, "dblclick", k[5])]),
          (L = !0));
    },
    p(j, [N]) {
      N & 2 && !src_url_equal(p.src, (v = j[1])) && attr(p, "src", v),
        N & 1 && $ !== ($ = j[0].filename) && attr(p, "alt", $),
        N & 1 && I !== (I = j[0].filename + "") && set_data(F, I),
        N & 1 && O !== (O = j[0].scopedPath) && attr(r, "title", O),
        N & 5 && toggle_class(r, "selected", j[2] == j[0].filename),
        N & 9 && toggle_class(r, "cutting", j[3] && j[3].name == j[0].filename);
    },
    i: noop$1,
    o: noop$1,
    d(j) {
      j && detach(r), (L = !1), run_all(U);
    },
  };
}
function instance$2Z(k, r, p) {
  let v, $, S;
  component_subscribe(k, FileBrowserOpeningFile, (U) => p(6, (v = U))),
    component_subscribe(k, FileBrowserSelectedFilename, (U) => p(2, ($ = U))),
    component_subscribe(k, FileBrowserCuttingFilename, (U) => p(3, (S = U)));
  let { file: x } = r,
    I = icon$2;
  function F() {
    set_store_value(FileBrowserSelectedFilename, ($ = x.filename), $);
  }
  async function O() {
    set_store_value(FileBrowserOpeningFile, (v = x), v),
      showOverlay("openingFile", "FileManager");
    let U = await openUserFile(x);
    if (
      (hideOverlay("openingFile", "FileManager"),
      set_store_value(FileBrowserOpeningFile, (v = null), v),
      U != !0)
    ) {
      const j = U;
      createOverlayableError(
        {
          title: `Unable to open ${x.filename}`,
          message:
            "You don't have an app or handler that can open this type of file.",
          buttons: [
            {
              caption: "Close",
              action: () => {
                U = null;
              },
            },
            { caption: "Open With...", action: () => L(j) },
          ],
          image: icon$2,
        },
        "FileManager"
      );
    }
    U = null;
  }
  function L(U) {
    openWithDialog({ ...U, anymime: !0 });
  }
  return (
    onMount(() => {
      p(1, (I = getMimeIcon(x.filename)));
    }),
    FileBrowserDirContents.subscribe(() => p(1, (I = getMimeIcon(x.filename)))),
    (k.$$set = (U) => {
      "file" in U && p(0, (x = U.file));
    }),
    [x, I, $, S, F, O]
  );
}
let File$2 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2Z, create_fragment$36, safe_not_equal, {
        file: 0,
      });
  }
};
function get_each_context$D(k, r, p) {
  const v = k.slice();
  return (v[3] = r[p]), v;
}
function get_each_context_1$8(k, r, p) {
  const v = k.slice();
  return (v[6] = r[p]), v;
}
function create_else_block_1$1(k) {
  let r,
    p,
    v,
    $ = k[1].length && create_if_block_3$2(k),
    S = k[0].length && create_if_block_2$5(k);
  return {
    c() {
      (r = element("div")),
        $ && $.c(),
        (p = space()),
        S && S.c(),
        attr(r, "class", "tileview");
    },
    m(x, I) {
      insert(x, r, I),
        $ && $.m(r, null),
        append(r, p),
        S && S.m(r, null),
        (v = !0);
    },
    p(x, I) {
      x[1].length
        ? $
          ? ($.p(x, I), I & 2 && transition_in($, 1))
          : (($ = create_if_block_3$2(x)),
            $.c(),
            transition_in($, 1),
            $.m(r, p))
        : $ &&
          (group_outros(),
          transition_out($, 1, 1, () => {
            $ = null;
          }),
          check_outros()),
        x[0].length
          ? S
            ? (S.p(x, I), I & 1 && transition_in(S, 1))
            : ((S = create_if_block_2$5(x)),
              S.c(),
              transition_in(S, 1),
              S.m(r, null))
          : S &&
            (group_outros(),
            transition_out(S, 1, 1, () => {
              S = null;
            }),
            check_outros());
    },
    i(x) {
      v || (transition_in($), transition_in(S), (v = !0));
    },
    o(x) {
      transition_out($), transition_out(S), (v = !1);
    },
    d(x) {
      x && detach(r), $ && $.d(), S && S.d();
    },
  };
}
function create_if_block$17(k) {
  let r, p, v, $;
  const S = [create_if_block_1$k, create_else_block$m],
    x = [];
  function I(F, O) {
    return F[2] ? 0 : 1;
  }
  return (
    (r = I(k)),
    (p = x[r] = S[r](k)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        x[r].m(F, O), insert(F, v, O), ($ = !0);
      },
      p(F, O) {
        let L = r;
        (r = I(F)),
          r !== L &&
            (group_outros(),
            transition_out(x[L], 1, 1, () => {
              x[L] = null;
            }),
            check_outros(),
            (p = x[r]),
            p || ((p = x[r] = S[r](F)), p.c()),
            transition_in(p, 1),
            p.m(v.parentNode, v));
      },
      i(F) {
        $ || (transition_in(p), ($ = !0));
      },
      o(F) {
        transition_out(p), ($ = !1);
      },
      d(F) {
        x[r].d(F), F && detach(v);
      },
    }
  );
}
function create_if_block_3$2(k) {
  let r,
    p,
    v = k[1],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block_1$8(get_each_context_1$8(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      r = element("div");
      for (let x = 0; x < $.length; x += 1) $[x].c();
      attr(r, "class", "folders");
    },
    m(x, I) {
      insert(x, r, I);
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(r, null);
      p = !0;
    },
    p(x, I) {
      if (I & 2) {
        v = x[1];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_1$8(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block_1$8(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      x && detach(r), destroy_each($, x);
    },
  };
}
function create_each_block_1$8(k) {
  let r, p;
  return (
    (r = new Dir$3({ props: { dir: k[6] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 2 && (S.dir = v[6]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_2$5(k) {
  let r,
    p,
    v = k[0],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$D(get_each_context$D(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      r = element("div");
      for (let x = 0; x < $.length; x += 1) $[x].c();
      attr(r, "class", "files");
    },
    m(x, I) {
      insert(x, r, I);
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(r, null);
      p = !0;
    },
    p(x, I) {
      if (I & 1) {
        v = x[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$D(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$D(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      x && detach(r), destroy_each($, x);
    },
  };
}
function create_each_block$D(k) {
  let r, p;
  return (
    (r = new File$2({ props: { file: k[3] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.file = v[3]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_else_block$m(k) {
  let r;
  return {
    c() {
      (r = element("div")),
        (r.textContent = "This folder is empty."),
        attr(r, "class", "nofiles");
    },
    m(p, v) {
      insert(p, r, v);
    },
    i: noop$1,
    o: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
function create_if_block_1$k(k) {
  let r, p, v, $, S, x;
  return (
    (v = new Spinner({ props: { height: 32 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          create_component(v.$$.fragment),
          ($ = space()),
          (S = element("p")),
          (S.textContent = "Reading items..."),
          attr(S, "class", "caption"),
          attr(p, "class", "loading-inner"),
          attr(r, "class", "loading");
      },
      m(I, F) {
        insert(I, r, F),
          append(r, p),
          mount_component(v, p, null),
          append(p, $),
          append(p, S),
          (x = !0);
      },
      i(I) {
        x || (transition_in(v.$$.fragment, I), (x = !0));
      },
      o(I) {
        transition_out(v.$$.fragment, I), (x = !1);
      },
      d(I) {
        I && detach(r), destroy_component(v);
      },
    }
  );
}
function create_fragment$35(k) {
  let r, p, v, $;
  const S = [create_if_block$17, create_else_block_1$1],
    x = [];
  function I(F, O) {
    return !F[1].length && !F[0].length ? 0 : 1;
  }
  return (
    (r = I(k)),
    (p = x[r] = S[r](k)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        x[r].m(F, O), insert(F, v, O), ($ = !0);
      },
      p(F, [O]) {
        let L = r;
        (r = I(F)),
          r === L
            ? x[r].p(F, O)
            : (group_outros(),
              transition_out(x[L], 1, 1, () => {
                x[L] = null;
              }),
              check_outros(),
              (p = x[r]),
              p ? p.p(F, O) : ((p = x[r] = S[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        $ || (transition_in(p), ($ = !0));
      },
      o(F) {
        transition_out(p), ($ = !1);
      },
      d(F) {
        x[r].d(F), F && detach(v);
      },
    }
  );
}
function instance$2Y(k, r, p) {
  let v;
  component_subscribe(k, FileBrowserRefreshing, (x) => p(2, (v = x)));
  let { files: $ = [] } = r,
    { dirs: S = [] } = r;
  return (
    (k.$$set = (x) => {
      "files" in x && p(0, ($ = x.files)), "dirs" in x && p(1, (S = x.dirs));
    }),
    [$, S, v]
  );
}
class TileView extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2Y, create_fragment$35, safe_not_equal, {
        files: 0,
        dirs: 1,
      });
  }
}
function create_fragment$34(k) {
  let r, p, v, $, S;
  return {
    c() {
      (r = element("button")),
        (p = text("content_copy")),
        attr(r, "class", "material-icons-round copy"),
        (r.disabled = v = !k[0]);
    },
    m(x, I) {
      insert(x, r, I),
        append(r, p),
        $ || ((S = listen(r, "click", k[1])), ($ = !0));
    },
    p(x, [I]) {
      I & 1 && v !== (v = !x[0]) && (r.disabled = v);
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r), ($ = !1), S();
    },
  };
}
function instance$2X(k, r, p) {
  let v, $;
  component_subscribe(k, FileBrowserSelectedFilename, (x) => p(0, (v = x))),
    component_subscribe(k, FileBrowserCurrentDir, (x) => p(2, ($ = x)));
  function S() {
    FileBrowserCopyingFilename.set({ name: v, scopedPath: `${$}/${v}` });
  }
  return [v, S];
}
class CopyButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2X, create_fragment$34, safe_not_equal, {});
  }
}
function create_fragment$33(k) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.textContent = "add"),
        attr(r, "class", "material-icons-round create");
    },
    m($, S) {
      insert($, r, S), p || ((v = listen(r, "click", k[0])), (p = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function instance$2W(k) {
  function r() {
    showOverlay("createFile", "FileManager");
  }
  return [r];
}
let CreateButton$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2W, create_fragment$33, safe_not_equal, {});
  }
};
function create_fragment$32(k) {
  let r, p, v, $, S;
  return {
    c() {
      (r = element("button")),
        (p = text("content_cut")),
        attr(r, "class", "material-icons-round cut"),
        (r.disabled = v = !k[0]);
    },
    m(x, I) {
      insert(x, r, I),
        append(r, p),
        $ || ((S = listen(r, "click", k[1])), ($ = !0));
    },
    p(x, [I]) {
      I & 1 && v !== (v = !x[0]) && (r.disabled = v);
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r), ($ = !1), S();
    },
  };
}
function instance$2V(k, r, p) {
  let v, $;
  component_subscribe(k, FileBrowserSelectedFilename, (x) => p(0, (v = x))),
    component_subscribe(k, FileBrowserCurrentDir, (x) => p(2, ($ = x)));
  function S() {
    FileBrowserCuttingFilename.set({ name: v, scopedPath: `${$}/${v}` });
  }
  return [v, S];
}
class CutButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2V, create_fragment$32, safe_not_equal, {});
  }
}
function create_fragment$31(k) {
  let r, p, v, $, S;
  return {
    c() {
      (r = element("button")),
        (p = text("delete")),
        attr(r, "class", "material-icons-round"),
        (r.disabled = v = !k[0]),
        attr(r, "title", "Delete item");
    },
    m(x, I) {
      insert(x, r, I),
        append(r, p),
        $ || ((S = listen(r, "click", k[1])), ($ = !0));
    },
    p(x, [I]) {
      I & 1 && v !== (v = !x[0]) && (r.disabled = v);
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r), ($ = !1), S();
    },
  };
}
function instance$2U(k, r, p) {
  let v, $;
  component_subscribe(k, FileBrowserSelectedFilename, (I) => p(0, (v = I))),
    component_subscribe(k, FileBrowserCurrentDir, (I) => p(2, ($ = I)));
  function S() {
    createOverlayableError(
      {
        title: "Delete item?",
        message: `Are you sure you want to permanently delete ${v}?`,
        buttons: [
          { caption: "Delete", action: x },
          { caption: "Cancel", action() {} },
        ],
        image: clear$1,
      },
      "FileManager"
    );
  }
  async function x() {
    const I = `${$}/${v}`;
    FileBrowserDeletingFilename.set(v),
      showOverlay("deletingItem", "FileManager"),
      (await deleteItem(I)) ||
        createOverlayableError(
          {
            title: "Unable to delete item",
            message:
              "ArcAPI was not able to delete the item from the file system. A permission error may have occured. Please try again later.",
            buttons: [{ caption: "OK", action() {} }],
            image: warning,
          },
          "FileManager"
        ),
      FileBrowserSelectedFilename.set(null),
      fbClass.refresh(),
      setTimeout(() => {
        hideOverlay("deletingItem", "FileManager");
      }, 100);
  }
  return [v, S];
}
class DeleteButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2U, create_fragment$31, safe_not_equal, {});
  }
}
function create_fragment$30(k) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.textContent = "create_new_folder"),
        attr(r, "class", "material-icons-round"),
        attr(r, "title", "New folder");
    },
    m($, S) {
      insert($, r, S), p || ((v = listen(r, "click", k[0])), (p = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function instance$2T(k) {
  function r() {
    showOverlay("createFolder", "FileManager");
  }
  return [r];
}
class NewFolderButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2T, create_fragment$30, safe_not_equal, {});
  }
}
function create_fragment$2$(k) {
  let r, p, v, $, S;
  return {
    c() {
      (r = element("button")),
        (p = text("arrow_upward")),
        attr(r, "class", "material-icons-round parentdir"),
        (r.disabled = v = k[0] == "./"),
        attr(r, "title", "Parent folder");
    },
    m(x, I) {
      insert(x, r, I),
        append(r, p),
        $ || ((S = listen(r, "click", k[1])), ($ = !0));
    },
    p(x, [I]) {
      I & 1 && v !== (v = x[0] == "./") && (r.disabled = v);
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r), ($ = !1), S();
    },
  };
}
function instance$2S(k, r, p) {
  let v;
  component_subscribe(k, FileBrowserCurrentDir, (S) => p(0, (v = S)));
  function $() {
    fbClass.goToDirectory(getParentDirectory(v));
  }
  return [v, $];
}
class ParentDir extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2S, create_fragment$2$, safe_not_equal, {});
  }
}
async function copyItem(k, r) {
  const p = get_store_value(ConnectedServer);
  return p
    ? (await apiCall(
        p,
        "fs/cp",
        { path: btoa(k), target: btoa(r) },
        get_store_value(UserToken)
      ),
      !0)
    : !1;
}
async function renameItem(k, r) {
  const p = get_store_value(ConnectedServer);
  return p
    ? (
        await apiCall(
          p,
          "fs/rename",
          { oldpath: btoa(k), newpath: btoa(r) },
          get_store_value(UserToken)
        )
      ).valid
    : !1;
}
function create_fragment$2_(k) {
  let r, p, v, $, S;
  return {
    c() {
      (r = element("button")),
        (p = text("content_paste")),
        attr(r, "class", "material-icons-round paste"),
        (r.disabled = v = !k[0] && !k[1]);
    },
    m(x, I) {
      insert(x, r, I),
        append(r, p),
        $ || ((S = listen(r, "click", k[2])), ($ = !0));
    },
    p(x, [I]) {
      I & 3 && v !== (v = !x[0] && !x[1]) && (r.disabled = v);
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r), ($ = !1), S();
    },
  };
}
function instance$2R(k, r, p) {
  let v, $, S;
  component_subscribe(k, FileBrowserCurrentDir, (I) => p(3, (v = I))),
    component_subscribe(k, FileBrowserCuttingFilename, (I) => p(0, ($ = I))),
    component_subscribe(k, FileBrowserCopyingFilename, (I) => p(1, (S = I)));
  async function x() {
    if (S) {
      const I = S.name,
        F = S.scopedPath;
      await copyItem(F, `${v}/${I}`), FileBrowserCopyingFilename.set(null);
    }
    if ($) {
      const I = $.name,
        F = $.scopedPath;
      await renameItem(F, `${v}/${I}`), FileBrowserCuttingFilename.set(null);
    }
    fbClass.refresh();
  }
  return [$, S, x];
}
class PasteButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2R, create_fragment$2_, safe_not_equal, {});
  }
}
function create_fragment$2Z(k) {
  let r, p, v, $, S;
  return {
    c() {
      (r = element("button")),
        (p = text("drive_file_rename_outline")),
        attr(r, "class", "material-icons-round"),
        (r.disabled = v = !k[0]),
        attr(r, "title", "Rename item");
    },
    m(x, I) {
      insert(x, r, I),
        append(r, p),
        $ || ((S = listen(r, "click", k[1])), ($ = !0));
    },
    p(x, [I]) {
      I & 1 && v !== (v = !x[0]) && (r.disabled = v);
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r), ($ = !1), S();
    },
  };
}
function instance$2Q(k, r, p) {
  let v;
  component_subscribe(k, FileBrowserSelectedFilename, (S) => p(0, (v = S)));
  function $() {
    showOverlay("renameItem", "FileManager");
  }
  return [v, $];
}
class RenameButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2Q, create_fragment$2Z, safe_not_equal, {});
  }
}
var mimeTypes = {},
  mimeDbExports = {},
  mimeDb = {
    get exports() {
      return mimeDbExports;
    },
    set exports(k) {
      mimeDbExports = k;
    },
  };
const require$$0 = {
  "application/1d-interleaved-parityfec": { source: "iana" },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/3gpp-ims+xml": { source: "iana", compressible: !0 },
  "application/3gpphal+json": { source: "iana", compressible: !0 },
  "application/3gpphalforms+json": { source: "iana", compressible: !0 },
  "application/a2l": { source: "iana" },
  "application/ace+cbor": { source: "iana" },
  "application/activemessage": { source: "iana" },
  "application/activity+json": { source: "iana", compressible: !0 },
  "application/alto-costmap+json": { source: "iana", compressible: !0 },
  "application/alto-costmapfilter+json": { source: "iana", compressible: !0 },
  "application/alto-directory+json": { source: "iana", compressible: !0 },
  "application/alto-endpointcost+json": { source: "iana", compressible: !0 },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-endpointprop+json": { source: "iana", compressible: !0 },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-error+json": { source: "iana", compressible: !0 },
  "application/alto-networkmap+json": { source: "iana", compressible: !0 },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: !0,
  },
  "application/aml": { source: "iana" },
  "application/andrew-inset": { source: "iana", extensions: ["ez"] },
  "application/applefile": { source: "iana" },
  "application/applixware": { source: "apache", extensions: ["aw"] },
  "application/at+jwt": { source: "iana" },
  "application/atf": { source: "iana" },
  "application/atfx": { source: "iana" },
  "application/atom+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atom"],
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atomcat"],
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atomdeleted"],
  },
  "application/atomicmail": { source: "iana" },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atomsvc"],
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["dwd"],
  },
  "application/atsc-dynamic-event-message": { source: "iana" },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["held"],
  },
  "application/atsc-rdt+json": { source: "iana", compressible: !0 },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rsat"],
  },
  "application/atxml": { source: "iana" },
  "application/auth-policy+xml": { source: "iana", compressible: !0 },
  "application/bacnet-xdd+zip": { source: "iana", compressible: !1 },
  "application/batch-smtp": { source: "iana" },
  "application/bdoc": { compressible: !1, extensions: ["bdoc"] },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/calendar+json": { source: "iana", compressible: !0 },
  "application/calendar+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xcs"],
  },
  "application/call-completion": { source: "iana" },
  "application/cals-1840": { source: "iana" },
  "application/captive+json": { source: "iana", compressible: !0 },
  "application/cbor": { source: "iana" },
  "application/cbor-seq": { source: "iana" },
  "application/cccex": { source: "iana" },
  "application/ccmp+xml": { source: "iana", compressible: !0 },
  "application/ccxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ccxml"],
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["cdfx"],
  },
  "application/cdmi-capability": { source: "iana", extensions: ["cdmia"] },
  "application/cdmi-container": { source: "iana", extensions: ["cdmic"] },
  "application/cdmi-domain": { source: "iana", extensions: ["cdmid"] },
  "application/cdmi-object": { source: "iana", extensions: ["cdmio"] },
  "application/cdmi-queue": { source: "iana", extensions: ["cdmiq"] },
  "application/cdni": { source: "iana" },
  "application/cea": { source: "iana" },
  "application/cea-2018+xml": { source: "iana", compressible: !0 },
  "application/cellml+xml": { source: "iana", compressible: !0 },
  "application/cfw": { source: "iana" },
  "application/city+json": { source: "iana", compressible: !0 },
  "application/clr": { source: "iana" },
  "application/clue+xml": { source: "iana", compressible: !0 },
  "application/clue_info+xml": { source: "iana", compressible: !0 },
  "application/cms": { source: "iana" },
  "application/cnrp+xml": { source: "iana", compressible: !0 },
  "application/coap-group+json": { source: "iana", compressible: !0 },
  "application/coap-payload": { source: "iana" },
  "application/commonground": { source: "iana" },
  "application/conference-info+xml": { source: "iana", compressible: !0 },
  "application/cose": { source: "iana" },
  "application/cose-key": { source: "iana" },
  "application/cose-key-set": { source: "iana" },
  "application/cpl+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["cpl"],
  },
  "application/csrattrs": { source: "iana" },
  "application/csta+xml": { source: "iana", compressible: !0 },
  "application/cstadata+xml": { source: "iana", compressible: !0 },
  "application/csvm+json": { source: "iana", compressible: !0 },
  "application/cu-seeme": { source: "apache", extensions: ["cu"] },
  "application/cwt": { source: "iana" },
  "application/cybercash": { source: "iana" },
  "application/dart": { compressible: !0 },
  "application/dash+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpd"],
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpp"],
  },
  "application/dashdelta": { source: "iana" },
  "application/davmount+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["davmount"],
  },
  "application/dca-rft": { source: "iana" },
  "application/dcd": { source: "iana" },
  "application/dec-dx": { source: "iana" },
  "application/dialog-info+xml": { source: "iana", compressible: !0 },
  "application/dicom": { source: "iana" },
  "application/dicom+json": { source: "iana", compressible: !0 },
  "application/dicom+xml": { source: "iana", compressible: !0 },
  "application/dii": { source: "iana" },
  "application/dit": { source: "iana" },
  "application/dns": { source: "iana" },
  "application/dns+json": { source: "iana", compressible: !0 },
  "application/dns-message": { source: "iana" },
  "application/docbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["dbk"],
  },
  "application/dots+cbor": { source: "iana" },
  "application/dskpp+xml": { source: "iana", compressible: !0 },
  "application/dssc+der": { source: "iana", extensions: ["dssc"] },
  "application/dssc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xdssc"],
  },
  "application/dvcs": { source: "iana" },
  "application/ecmascript": {
    source: "iana",
    compressible: !0,
    extensions: ["es", "ecma"],
  },
  "application/edi-consent": { source: "iana" },
  "application/edi-x12": { source: "iana", compressible: !1 },
  "application/edifact": { source: "iana", compressible: !1 },
  "application/efi": { source: "iana" },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/elm+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.ecall.msd": { source: "iana" },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emma+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["emma"],
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["emotionml"],
  },
  "application/encaprtp": { source: "iana" },
  "application/epp+xml": { source: "iana", compressible: !0 },
  "application/epub+zip": {
    source: "iana",
    compressible: !1,
    extensions: ["epub"],
  },
  "application/eshop": { source: "iana" },
  "application/exi": { source: "iana", extensions: ["exi"] },
  "application/expect-ct-report+json": { source: "iana", compressible: !0 },
  "application/express": { source: "iana", extensions: ["exp"] },
  "application/fastinfoset": { source: "iana" },
  "application/fastsoap": { source: "iana" },
  "application/fdt+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["fdt"],
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/fido.trusted-apps+json": { compressible: !0 },
  "application/fits": { source: "iana" },
  "application/flexfec": { source: "iana" },
  "application/font-sfnt": { source: "iana" },
  "application/font-tdpfr": { source: "iana", extensions: ["pfr"] },
  "application/font-woff": { source: "iana", compressible: !1 },
  "application/framework-attributes+xml": { source: "iana", compressible: !0 },
  "application/geo+json": {
    source: "iana",
    compressible: !0,
    extensions: ["geojson"],
  },
  "application/geo+json-seq": { source: "iana" },
  "application/geopackage+sqlite3": { source: "iana" },
  "application/geoxacml+xml": { source: "iana", compressible: !0 },
  "application/gltf-buffer": { source: "iana" },
  "application/gml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["gml"],
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["gpx"],
  },
  "application/gxf": { source: "apache", extensions: ["gxf"] },
  "application/gzip": { source: "iana", compressible: !1, extensions: ["gz"] },
  "application/h224": { source: "iana" },
  "application/held+xml": { source: "iana", compressible: !0 },
  "application/hjson": { extensions: ["hjson"] },
  "application/http": { source: "iana" },
  "application/hyperstudio": { source: "iana", extensions: ["stk"] },
  "application/ibe-key-request+xml": { source: "iana", compressible: !0 },
  "application/ibe-pkg-reply+xml": { source: "iana", compressible: !0 },
  "application/ibe-pp-data": { source: "iana" },
  "application/iges": { source: "iana" },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/index": { source: "iana" },
  "application/index.cmd": { source: "iana" },
  "application/index.obj": { source: "iana" },
  "application/index.response": { source: "iana" },
  "application/index.vnd": { source: "iana" },
  "application/inkml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ink", "inkml"],
  },
  "application/iotp": { source: "iana" },
  "application/ipfix": { source: "iana", extensions: ["ipfix"] },
  "application/ipp": { source: "iana" },
  "application/isup": { source: "iana" },
  "application/its+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["its"],
  },
  "application/java-archive": {
    source: "apache",
    compressible: !1,
    extensions: ["jar", "war", "ear"],
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: !1,
    extensions: ["ser"],
  },
  "application/java-vm": {
    source: "apache",
    compressible: !1,
    extensions: ["class"],
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["js", "mjs"],
  },
  "application/jf2feed+json": { source: "iana", compressible: !0 },
  "application/jose": { source: "iana" },
  "application/jose+json": { source: "iana", compressible: !0 },
  "application/jrd+json": { source: "iana", compressible: !0 },
  "application/jscalendar+json": { source: "iana", compressible: !0 },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["json", "map"],
  },
  "application/json-patch+json": { source: "iana", compressible: !0 },
  "application/json-seq": { source: "iana" },
  "application/json5": { extensions: ["json5"] },
  "application/jsonml+json": {
    source: "apache",
    compressible: !0,
    extensions: ["jsonml"],
  },
  "application/jwk+json": { source: "iana", compressible: !0 },
  "application/jwk-set+json": { source: "iana", compressible: !0 },
  "application/jwt": { source: "iana" },
  "application/kpml-request+xml": { source: "iana", compressible: !0 },
  "application/kpml-response+xml": { source: "iana", compressible: !0 },
  "application/ld+json": {
    source: "iana",
    compressible: !0,
    extensions: ["jsonld"],
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lgr"],
  },
  "application/link-format": { source: "iana" },
  "application/load-control+xml": { source: "iana", compressible: !0 },
  "application/lost+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lostxml"],
  },
  "application/lostsync+xml": { source: "iana", compressible: !0 },
  "application/lpf+zip": { source: "iana", compressible: !1 },
  "application/lxf": { source: "iana" },
  "application/mac-binhex40": { source: "iana", extensions: ["hqx"] },
  "application/mac-compactpro": { source: "apache", extensions: ["cpt"] },
  "application/macwriteii": { source: "iana" },
  "application/mads+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mads"],
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["webmanifest"],
  },
  "application/marc": { source: "iana", extensions: ["mrc"] },
  "application/marcxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mrcx"],
  },
  "application/mathematica": { source: "iana", extensions: ["ma", "nb", "mb"] },
  "application/mathml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mathml"],
  },
  "application/mathml-content+xml": { source: "iana", compressible: !0 },
  "application/mathml-presentation+xml": { source: "iana", compressible: !0 },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbms-deregister+xml": { source: "iana", compressible: !0 },
  "application/mbms-envelope+xml": { source: "iana", compressible: !0 },
  "application/mbms-msk+xml": { source: "iana", compressible: !0 },
  "application/mbms-msk-response+xml": { source: "iana", compressible: !0 },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbms-reception-report+xml": { source: "iana", compressible: !0 },
  "application/mbms-register+xml": { source: "iana", compressible: !0 },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbms-schedule+xml": { source: "iana", compressible: !0 },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbox": { source: "iana", extensions: ["mbox"] },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpf"],
  },
  "application/media_control+xml": { source: "iana", compressible: !0 },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mscml"],
  },
  "application/merge-patch+json": { source: "iana", compressible: !0 },
  "application/metalink+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["metalink"],
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["meta4"],
  },
  "application/mets+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mets"],
  },
  "application/mf4": { source: "iana" },
  "application/mikey": { source: "iana" },
  "application/mipc": { source: "iana" },
  "application/missing-blocks+cbor-seq": { source: "iana" },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["maei"],
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["musd"],
  },
  "application/mods+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mods"],
  },
  "application/moss-keys": { source: "iana" },
  "application/moss-signature": { source: "iana" },
  "application/mosskey-data": { source: "iana" },
  "application/mosskey-request": { source: "iana" },
  "application/mp21": { source: "iana", extensions: ["m21", "mp21"] },
  "application/mp4": { source: "iana", extensions: ["mp4s", "m4p"] },
  "application/mpeg4-generic": { source: "iana" },
  "application/mpeg4-iod": { source: "iana" },
  "application/mpeg4-iod-xmt": { source: "iana" },
  "application/mrb-consumer+xml": { source: "iana", compressible: !0 },
  "application/mrb-publish+xml": { source: "iana", compressible: !0 },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/msword": {
    source: "iana",
    compressible: !1,
    extensions: ["doc", "dot"],
  },
  "application/mud+json": { source: "iana", compressible: !0 },
  "application/multipart-core": { source: "iana" },
  "application/mxf": { source: "iana", extensions: ["mxf"] },
  "application/n-quads": { source: "iana", extensions: ["nq"] },
  "application/n-triples": { source: "iana", extensions: ["nt"] },
  "application/nasdata": { source: "iana" },
  "application/news-checkgroups": { source: "iana", charset: "US-ASCII" },
  "application/news-groupinfo": { source: "iana", charset: "US-ASCII" },
  "application/news-transmission": { source: "iana" },
  "application/nlsml+xml": { source: "iana", compressible: !0 },
  "application/node": { source: "iana", extensions: ["cjs"] },
  "application/nss": { source: "iana" },
  "application/oauth-authz-req+jwt": { source: "iana" },
  "application/oblivious-dns-message": { source: "iana" },
  "application/ocsp-request": { source: "iana" },
  "application/ocsp-response": { source: "iana" },
  "application/octet-stream": {
    source: "iana",
    compressible: !1,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer",
    ],
  },
  "application/oda": { source: "iana", extensions: ["oda"] },
  "application/odm+xml": { source: "iana", compressible: !0 },
  "application/odx": { source: "iana" },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["opf"],
  },
  "application/ogg": { source: "iana", compressible: !1, extensions: ["ogx"] },
  "application/omdoc+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["omdoc"],
  },
  "application/onenote": {
    source: "apache",
    extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"],
  },
  "application/opc-nodeset+xml": { source: "iana", compressible: !0 },
  "application/oscore": { source: "iana" },
  "application/oxps": { source: "iana", extensions: ["oxps"] },
  "application/p21": { source: "iana" },
  "application/p21+zip": { source: "iana", compressible: !1 },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["relo"],
  },
  "application/parityfec": { source: "iana" },
  "application/passport": { source: "iana" },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xer"],
  },
  "application/pdf": { source: "iana", compressible: !1, extensions: ["pdf"] },
  "application/pdx": { source: "iana" },
  "application/pem-certificate-chain": { source: "iana" },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: !1,
    extensions: ["pgp"],
  },
  "application/pgp-keys": { source: "iana", extensions: ["asc"] },
  "application/pgp-signature": { source: "iana", extensions: ["asc", "sig"] },
  "application/pics-rules": { source: "apache", extensions: ["prf"] },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/pkcs10": { source: "iana", extensions: ["p10"] },
  "application/pkcs12": { source: "iana" },
  "application/pkcs7-mime": { source: "iana", extensions: ["p7m", "p7c"] },
  "application/pkcs7-signature": { source: "iana", extensions: ["p7s"] },
  "application/pkcs8": { source: "iana", extensions: ["p8"] },
  "application/pkcs8-encrypted": { source: "iana" },
  "application/pkix-attr-cert": { source: "iana", extensions: ["ac"] },
  "application/pkix-cert": { source: "iana", extensions: ["cer"] },
  "application/pkix-crl": { source: "iana", extensions: ["crl"] },
  "application/pkix-pkipath": { source: "iana", extensions: ["pkipath"] },
  "application/pkixcmp": { source: "iana", extensions: ["pki"] },
  "application/pls+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["pls"],
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/postscript": {
    source: "iana",
    compressible: !0,
    extensions: ["ai", "eps", "ps"],
  },
  "application/ppsp-tracker+json": { source: "iana", compressible: !0 },
  "application/problem+json": { source: "iana", compressible: !0 },
  "application/problem+xml": { source: "iana", compressible: !0 },
  "application/provenance+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["provx"],
  },
  "application/prs.alvestrand.titrax-sheet": { source: "iana" },
  "application/prs.cww": { source: "iana", extensions: ["cww"] },
  "application/prs.cyn": { source: "iana", charset: "7-BIT" },
  "application/prs.hpub+zip": { source: "iana", compressible: !1 },
  "application/prs.nprend": { source: "iana" },
  "application/prs.plucker": { source: "iana" },
  "application/prs.rdf-xml-crypt": { source: "iana" },
  "application/prs.xsf+xml": { source: "iana", compressible: !0 },
  "application/pskc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["pskcxml"],
  },
  "application/pvd+json": { source: "iana", compressible: !0 },
  "application/qsig": { source: "iana" },
  "application/raml+yaml": { compressible: !0, extensions: ["raml"] },
  "application/raptorfec": { source: "iana" },
  "application/rdap+json": { source: "iana", compressible: !0 },
  "application/rdf+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rdf", "owl"],
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rif"],
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: ["rnc"],
  },
  "application/remote-printing": { source: "iana" },
  "application/reputon+json": { source: "iana", compressible: !0 },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rl"],
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rld"],
  },
  "application/rfc+xml": { source: "iana", compressible: !0 },
  "application/riscos": { source: "iana" },
  "application/rlmi+xml": { source: "iana", compressible: !0 },
  "application/rls-services+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rs"],
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rapd"],
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sls"],
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rusd"],
  },
  "application/rpki-ghostbusters": { source: "iana", extensions: ["gbr"] },
  "application/rpki-manifest": { source: "iana", extensions: ["mft"] },
  "application/rpki-publication": { source: "iana" },
  "application/rpki-roa": { source: "iana", extensions: ["roa"] },
  "application/rpki-updown": { source: "iana" },
  "application/rsd+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["rsd"],
  },
  "application/rss+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["rss"],
  },
  "application/rtf": { source: "iana", compressible: !0, extensions: ["rtf"] },
  "application/rtploopback": { source: "iana" },
  "application/rtx": { source: "iana" },
  "application/samlassertion+xml": { source: "iana", compressible: !0 },
  "application/samlmetadata+xml": { source: "iana", compressible: !0 },
  "application/sarif+json": { source: "iana", compressible: !0 },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: !0,
  },
  "application/sbe": { source: "iana" },
  "application/sbml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sbml"],
  },
  "application/scaip+xml": { source: "iana", compressible: !0 },
  "application/scim+json": { source: "iana", compressible: !0 },
  "application/scvp-cv-request": { source: "iana", extensions: ["scq"] },
  "application/scvp-cv-response": { source: "iana", extensions: ["scs"] },
  "application/scvp-vp-request": { source: "iana", extensions: ["spq"] },
  "application/scvp-vp-response": { source: "iana", extensions: ["spp"] },
  "application/sdp": { source: "iana", extensions: ["sdp"] },
  "application/secevent+jwt": { source: "iana" },
  "application/senml+cbor": { source: "iana" },
  "application/senml+json": { source: "iana", compressible: !0 },
  "application/senml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["senmlx"],
  },
  "application/senml-etch+cbor": { source: "iana" },
  "application/senml-etch+json": { source: "iana", compressible: !0 },
  "application/senml-exi": { source: "iana" },
  "application/sensml+cbor": { source: "iana" },
  "application/sensml+json": { source: "iana", compressible: !0 },
  "application/sensml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sensmlx"],
  },
  "application/sensml-exi": { source: "iana" },
  "application/sep+xml": { source: "iana", compressible: !0 },
  "application/sep-exi": { source: "iana" },
  "application/session-info": { source: "iana" },
  "application/set-payment": { source: "iana" },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: ["setpay"],
  },
  "application/set-registration": { source: "iana" },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: ["setreg"],
  },
  "application/sgml": { source: "iana" },
  "application/sgml-open-catalog": { source: "iana" },
  "application/shf+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["shf"],
  },
  "application/sieve": { source: "iana", extensions: ["siv", "sieve"] },
  "application/simple-filter+xml": { source: "iana", compressible: !0 },
  "application/simple-message-summary": { source: "iana" },
  "application/simplesymbolcontainer": { source: "iana" },
  "application/sipc": { source: "iana" },
  "application/slate": { source: "iana" },
  "application/smil": { source: "iana" },
  "application/smil+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["smi", "smil"],
  },
  "application/smpte336m": { source: "iana" },
  "application/soap+fastinfoset": { source: "iana" },
  "application/soap+xml": { source: "iana", compressible: !0 },
  "application/sparql-query": { source: "iana", extensions: ["rq"] },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["srx"],
  },
  "application/spdx+json": { source: "iana", compressible: !0 },
  "application/spirits-event+xml": { source: "iana", compressible: !0 },
  "application/sql": { source: "iana" },
  "application/srgs": { source: "iana", extensions: ["gram"] },
  "application/srgs+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["grxml"],
  },
  "application/sru+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sru"],
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["ssdl"],
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ssml"],
  },
  "application/stix+json": { source: "iana", compressible: !0 },
  "application/swid+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["swidtag"],
  },
  "application/tamp-apex-update": { source: "iana" },
  "application/tamp-apex-update-confirm": { source: "iana" },
  "application/tamp-community-update": { source: "iana" },
  "application/tamp-community-update-confirm": { source: "iana" },
  "application/tamp-error": { source: "iana" },
  "application/tamp-sequence-adjust": { source: "iana" },
  "application/tamp-sequence-adjust-confirm": { source: "iana" },
  "application/tamp-status-query": { source: "iana" },
  "application/tamp-status-response": { source: "iana" },
  "application/tamp-update": { source: "iana" },
  "application/tamp-update-confirm": { source: "iana" },
  "application/tar": { compressible: !0 },
  "application/taxii+json": { source: "iana", compressible: !0 },
  "application/td+json": { source: "iana", compressible: !0 },
  "application/tei+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["tei", "teicorpus"],
  },
  "application/tetra_isi": { source: "iana" },
  "application/thraud+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["tfi"],
  },
  "application/timestamp-query": { source: "iana" },
  "application/timestamp-reply": { source: "iana" },
  "application/timestamped-data": { source: "iana", extensions: ["tsd"] },
  "application/tlsrpt+gzip": { source: "iana" },
  "application/tlsrpt+json": { source: "iana", compressible: !0 },
  "application/tnauthlist": { source: "iana" },
  "application/token-introspection+jwt": { source: "iana" },
  "application/toml": { compressible: !0, extensions: ["toml"] },
  "application/trickle-ice-sdpfrag": { source: "iana" },
  "application/trig": { source: "iana", extensions: ["trig"] },
  "application/ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ttml"],
  },
  "application/tve-trigger": { source: "iana" },
  "application/tzif": { source: "iana" },
  "application/tzif-leap": { source: "iana" },
  "application/ubjson": { compressible: !1, extensions: ["ubj"] },
  "application/ulpfec": { source: "iana" },
  "application/urc-grpsheet+xml": { source: "iana", compressible: !0 },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rsheet"],
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["td"],
  },
  "application/urc-uisocketdesc+xml": { source: "iana", compressible: !0 },
  "application/vcard+json": { source: "iana", compressible: !0 },
  "application/vcard+xml": { source: "iana", compressible: !0 },
  "application/vemmi": { source: "iana" },
  "application/vividence.scriptfile": { source: "apache" },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["1km"],
  },
  "application/vnd.3gpp-prose+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-prose-pc3ch+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-v2x-local-service-information": { source: "iana" },
  "application/vnd.3gpp.5gnas": { source: "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.bsf+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.gmop+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.gtpc": { source: "iana" },
  "application/vnd.3gpp.interworking-data": { source: "iana" },
  "application/vnd.3gpp.lpp": { source: "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { source: "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcdata-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-payload": { source: "iana" },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcdata-signalling": { source: "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-signed+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mid-call+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.ngap": { source: "iana" },
  "application/vnd.3gpp.pfcp": { source: "iana" },
  "application/vnd.3gpp.pic-bw-large": { source: "iana", extensions: ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { source: "iana", extensions: ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { source: "iana", extensions: ["pvb"] },
  "application/vnd.3gpp.s1ap": { source: "iana" },
  "application/vnd.3gpp.sms": { source: "iana" },
  "application/vnd.3gpp.sms+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.srvcc-ext+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.srvcc-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.ussd+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp2.bcmcsinfo+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp2.sms": { source: "iana" },
  "application/vnd.3gpp2.tcap": { source: "iana", extensions: ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { source: "iana" },
  "application/vnd.3m.post-it-notes": { source: "iana", extensions: ["pwn"] },
  "application/vnd.accpac.simply.aso": { source: "iana", extensions: ["aso"] },
  "application/vnd.accpac.simply.imp": { source: "iana", extensions: ["imp"] },
  "application/vnd.acucobol": { source: "iana", extensions: ["acu"] },
  "application/vnd.acucorp": { source: "iana", extensions: ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: !1,
    extensions: ["air"],
  },
  "application/vnd.adobe.flash.movie": { source: "iana" },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: ["fcdt"],
  },
  "application/vnd.adobe.fxp": { source: "iana", extensions: ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { source: "iana" },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xdp"],
  },
  "application/vnd.adobe.xfdf": { source: "iana", extensions: ["xfdf"] },
  "application/vnd.aether.imp": { source: "iana" },
  "application/vnd.afpc.afplinedata": { source: "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { source: "iana" },
  "application/vnd.afpc.cmoca-cmresource": { source: "iana" },
  "application/vnd.afpc.foca-charset": { source: "iana" },
  "application/vnd.afpc.foca-codedfont": { source: "iana" },
  "application/vnd.afpc.foca-codepage": { source: "iana" },
  "application/vnd.afpc.modca": { source: "iana" },
  "application/vnd.afpc.modca-cmtable": { source: "iana" },
  "application/vnd.afpc.modca-formdef": { source: "iana" },
  "application/vnd.afpc.modca-mediummap": { source: "iana" },
  "application/vnd.afpc.modca-objectcontainer": { source: "iana" },
  "application/vnd.afpc.modca-overlay": { source: "iana" },
  "application/vnd.afpc.modca-pagesegment": { source: "iana" },
  "application/vnd.age": { source: "iana", extensions: ["age"] },
  "application/vnd.ah-barcode": { source: "iana" },
  "application/vnd.ahead.space": { source: "iana", extensions: ["ahead"] },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: ["azf"],
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: ["azs"],
  },
  "application/vnd.amadeus+json": { source: "iana", compressible: !0 },
  "application/vnd.amazon.ebook": { source: "apache", extensions: ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { source: "iana" },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: ["acc"],
  },
  "application/vnd.amiga.ami": { source: "iana", extensions: ["ami"] },
  "application/vnd.amundsen.maze+xml": { source: "iana", compressible: !0 },
  "application/vnd.android.ota": { source: "iana" },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: !1,
    extensions: ["apk"],
  },
  "application/vnd.anki": { source: "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: ["cii"],
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: ["fti"],
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: ["atx"],
  },
  "application/vnd.apache.arrow.file": { source: "iana" },
  "application/vnd.apache.arrow.stream": { source: "iana" },
  "application/vnd.apache.thrift.binary": { source: "iana" },
  "application/vnd.apache.thrift.compact": { source: "iana" },
  "application/vnd.apache.thrift.json": { source: "iana" },
  "application/vnd.api+json": { source: "iana", compressible: !0 },
  "application/vnd.aplextor.warrp+json": { source: "iana", compressible: !0 },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpkg"],
  },
  "application/vnd.apple.keynote": { source: "iana", extensions: ["key"] },
  "application/vnd.apple.mpegurl": { source: "iana", extensions: ["m3u8"] },
  "application/vnd.apple.numbers": { source: "iana", extensions: ["numbers"] },
  "application/vnd.apple.pages": { source: "iana", extensions: ["pages"] },
  "application/vnd.apple.pkpass": { compressible: !1, extensions: ["pkpass"] },
  "application/vnd.arastra.swi": { source: "iana" },
  "application/vnd.aristanetworks.swi": { source: "iana", extensions: ["swi"] },
  "application/vnd.artisan+json": { source: "iana", compressible: !0 },
  "application/vnd.artsquare": { source: "iana" },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: ["iota"],
  },
  "application/vnd.audiograph": { source: "iana", extensions: ["aep"] },
  "application/vnd.autopackage": { source: "iana" },
  "application/vnd.avalon+json": { source: "iana", compressible: !0 },
  "application/vnd.avistar+xml": { source: "iana", compressible: !0 },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["bmml"],
  },
  "application/vnd.balsamiq.bmpr": { source: "iana" },
  "application/vnd.banana-accounting": { source: "iana" },
  "application/vnd.bbf.usp.error": { source: "iana" },
  "application/vnd.bbf.usp.msg": { source: "iana" },
  "application/vnd.bbf.usp.msg+json": { source: "iana", compressible: !0 },
  "application/vnd.bekitzur-stech+json": { source: "iana", compressible: !0 },
  "application/vnd.bint.med-content": { source: "iana" },
  "application/vnd.biopax.rdf+xml": { source: "iana", compressible: !0 },
  "application/vnd.blink-idb-value-wrapper": { source: "iana" },
  "application/vnd.blueice.multipass": { source: "iana", extensions: ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { source: "iana" },
  "application/vnd.bluetooth.le.oob": { source: "iana" },
  "application/vnd.bmi": { source: "iana", extensions: ["bmi"] },
  "application/vnd.bpf": { source: "iana" },
  "application/vnd.bpf3": { source: "iana" },
  "application/vnd.businessobjects": { source: "iana", extensions: ["rep"] },
  "application/vnd.byu.uapi+json": { source: "iana", compressible: !0 },
  "application/vnd.cab-jscript": { source: "iana" },
  "application/vnd.canon-cpdl": { source: "iana" },
  "application/vnd.canon-lips": { source: "iana" },
  "application/vnd.capasystems-pg+json": { source: "iana", compressible: !0 },
  "application/vnd.cendio.thinlinc.clientconf": { source: "iana" },
  "application/vnd.century-systems.tcp_stream": { source: "iana" },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["cdxml"],
  },
  "application/vnd.chess-pgn": { source: "iana" },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: ["mmd"],
  },
  "application/vnd.ciedi": { source: "iana" },
  "application/vnd.cinderella": { source: "iana", extensions: ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { source: "iana" },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["csl"],
  },
  "application/vnd.claymore": { source: "iana", extensions: ["cla"] },
  "application/vnd.cloanto.rp9": { source: "iana", extensions: ["rp9"] },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"],
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: ["c11amc"],
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: ["c11amz"],
  },
  "application/vnd.coffeescript": { source: "iana" },
  "application/vnd.collabio.xodocuments.document": { source: "iana" },
  "application/vnd.collabio.xodocuments.document-template": { source: "iana" },
  "application/vnd.collabio.xodocuments.presentation": { source: "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana",
  },
  "application/vnd.collabio.xodocuments.spreadsheet": { source: "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana",
  },
  "application/vnd.collection+json": { source: "iana", compressible: !0 },
  "application/vnd.collection.doc+json": { source: "iana", compressible: !0 },
  "application/vnd.collection.next+json": { source: "iana", compressible: !0 },
  "application/vnd.comicbook+zip": { source: "iana", compressible: !1 },
  "application/vnd.comicbook-rar": { source: "iana" },
  "application/vnd.commerce-battelle": { source: "iana" },
  "application/vnd.commonspace": { source: "iana", extensions: ["csp"] },
  "application/vnd.contact.cmsg": { source: "iana", extensions: ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { source: "iana", compressible: !0 },
  "application/vnd.cosmocaller": { source: "iana", extensions: ["cmc"] },
  "application/vnd.crick.clicker": { source: "iana", extensions: ["clkx"] },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: ["clkk"],
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: ["clkp"],
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: ["clkt"],
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: ["clkw"],
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wbs"],
  },
  "application/vnd.cryptii.pipe+json": { source: "iana", compressible: !0 },
  "application/vnd.crypto-shade-file": { source: "iana" },
  "application/vnd.cryptomator.encrypted": { source: "iana" },
  "application/vnd.cryptomator.vault": { source: "iana" },
  "application/vnd.ctc-posml": { source: "iana", extensions: ["pml"] },
  "application/vnd.ctct.ws+xml": { source: "iana", compressible: !0 },
  "application/vnd.cups-pdf": { source: "iana" },
  "application/vnd.cups-postscript": { source: "iana" },
  "application/vnd.cups-ppd": { source: "iana", extensions: ["ppd"] },
  "application/vnd.cups-raster": { source: "iana" },
  "application/vnd.cups-raw": { source: "iana" },
  "application/vnd.curl": { source: "iana" },
  "application/vnd.curl.car": { source: "apache", extensions: ["car"] },
  "application/vnd.curl.pcurl": { source: "apache", extensions: ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { source: "iana", compressible: !0 },
  "application/vnd.cybank": { source: "iana" },
  "application/vnd.cyclonedx+json": { source: "iana", compressible: !0 },
  "application/vnd.cyclonedx+xml": { source: "iana", compressible: !0 },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: !1,
  },
  "application/vnd.d3m-dataset": { source: "iana" },
  "application/vnd.d3m-problem": { source: "iana" },
  "application/vnd.dart": {
    source: "iana",
    compressible: !0,
    extensions: ["dart"],
  },
  "application/vnd.data-vision.rdz": { source: "iana", extensions: ["rdz"] },
  "application/vnd.datapackage+json": { source: "iana", compressible: !0 },
  "application/vnd.dataresource+json": { source: "iana", compressible: !0 },
  "application/vnd.dbf": { source: "iana", extensions: ["dbf"] },
  "application/vnd.debian.binary-package": { source: "iana" },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: ["uvf", "uvvf", "uvd", "uvvd"],
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["uvt", "uvvt"],
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: ["uvx", "uvvx"],
  },
  "application/vnd.dece.zip": { source: "iana", extensions: ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: ["fe_launch"],
  },
  "application/vnd.desmume.movie": { source: "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { source: "iana" },
  "application/vnd.dm.delegation+xml": { source: "iana", compressible: !0 },
  "application/vnd.dna": { source: "iana", extensions: ["dna"] },
  "application/vnd.document+json": { source: "iana", compressible: !0 },
  "application/vnd.dolby.mlp": { source: "apache", extensions: ["mlp"] },
  "application/vnd.dolby.mobile.1": { source: "iana" },
  "application/vnd.dolby.mobile.2": { source: "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { source: "iana" },
  "application/vnd.dpgraph": { source: "iana", extensions: ["dpg"] },
  "application/vnd.dreamfactory": { source: "iana", extensions: ["dfac"] },
  "application/vnd.drive+json": { source: "iana", compressible: !0 },
  "application/vnd.ds-keypoint": { source: "apache", extensions: ["kpxx"] },
  "application/vnd.dtg.local": { source: "iana" },
  "application/vnd.dtg.local.flash": { source: "iana" },
  "application/vnd.dtg.local.html": { source: "iana" },
  "application/vnd.dvb.ait": { source: "iana", extensions: ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.dvbj": { source: "iana" },
  "application/vnd.dvb.esgcontainer": { source: "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { source: "iana" },
  "application/vnd.dvb.ipdcesgaccess": { source: "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { source: "iana" },
  "application/vnd.dvb.ipdcesgpdd": { source: "iana" },
  "application/vnd.dvb.ipdcroaming": { source: "iana" },
  "application/vnd.dvb.iptv.alfec-base": { source: "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { source: "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-generic+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-init+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.pfr": { source: "iana" },
  "application/vnd.dvb.service": { source: "iana", extensions: ["svc"] },
  "application/vnd.dxr": { source: "iana" },
  "application/vnd.dynageo": { source: "iana", extensions: ["geo"] },
  "application/vnd.dzr": { source: "iana" },
  "application/vnd.easykaraoke.cdgdownload": { source: "iana" },
  "application/vnd.ecdis-update": { source: "iana" },
  "application/vnd.ecip.rlp": { source: "iana" },
  "application/vnd.eclipse.ditto+json": { source: "iana", compressible: !0 },
  "application/vnd.ecowin.chart": { source: "iana", extensions: ["mag"] },
  "application/vnd.ecowin.filerequest": { source: "iana" },
  "application/vnd.ecowin.fileupdate": { source: "iana" },
  "application/vnd.ecowin.series": { source: "iana" },
  "application/vnd.ecowin.seriesrequest": { source: "iana" },
  "application/vnd.ecowin.seriesupdate": { source: "iana" },
  "application/vnd.efi.img": { source: "iana" },
  "application/vnd.efi.iso": { source: "iana" },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.enliven": { source: "iana", extensions: ["nml"] },
  "application/vnd.enphase.envoy": { source: "iana" },
  "application/vnd.eprints.data+xml": { source: "iana", compressible: !0 },
  "application/vnd.epson.esf": { source: "iana", extensions: ["esf"] },
  "application/vnd.epson.msf": { source: "iana", extensions: ["msf"] },
  "application/vnd.epson.quickanime": { source: "iana", extensions: ["qam"] },
  "application/vnd.epson.salt": { source: "iana", extensions: ["slt"] },
  "application/vnd.epson.ssf": { source: "iana", extensions: ["ssf"] },
  "application/vnd.ericsson.quickcall": { source: "iana" },
  "application/vnd.espass-espass+zip": { source: "iana", compressible: !1 },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["es3", "et3"],
  },
  "application/vnd.etsi.aoc+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.asic-e+zip": { source: "iana", compressible: !1 },
  "application/vnd.etsi.asic-s+zip": { source: "iana", compressible: !1 },
  "application/vnd.etsi.cug+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvcommand+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.etsi.iptvprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-bc+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-cod+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-npvr+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvservice+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsync+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.etsi.mcid+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.mheg5": { source: "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.etsi.pstn+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.sci+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.simservs+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.timestamp-token": { source: "iana" },
  "application/vnd.etsi.tsl+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.tsl.der": { source: "iana" },
  "application/vnd.eu.kasparian.car+json": { source: "iana", compressible: !0 },
  "application/vnd.eudora.data": { source: "iana" },
  "application/vnd.evolv.ecig.profile": { source: "iana" },
  "application/vnd.evolv.ecig.settings": { source: "iana" },
  "application/vnd.evolv.ecig.theme": { source: "iana" },
  "application/vnd.exstream-empower+zip": { source: "iana", compressible: !1 },
  "application/vnd.exstream-package": { source: "iana" },
  "application/vnd.ezpix-album": { source: "iana", extensions: ["ez2"] },
  "application/vnd.ezpix-package": { source: "iana", extensions: ["ez3"] },
  "application/vnd.f-secure.mobile": { source: "iana" },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: !1,
  },
  "application/vnd.fastcopy-disk-image": { source: "iana" },
  "application/vnd.fdf": { source: "iana", extensions: ["fdf"] },
  "application/vnd.fdsn.mseed": { source: "iana", extensions: ["mseed"] },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: ["seed", "dataless"],
  },
  "application/vnd.ffsns": { source: "iana" },
  "application/vnd.ficlab.flb+zip": { source: "iana", compressible: !1 },
  "application/vnd.filmit.zfc": { source: "iana" },
  "application/vnd.fints": { source: "iana" },
  "application/vnd.firemonkeys.cloudcell": { source: "iana" },
  "application/vnd.flographit": { source: "iana", extensions: ["gph"] },
  "application/vnd.fluxtime.clip": { source: "iana", extensions: ["ftc"] },
  "application/vnd.font-fontforge-sfd": { source: "iana" },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: ["fm", "frame", "maker", "book"],
  },
  "application/vnd.frogans.fnc": { source: "iana", extensions: ["fnc"] },
  "application/vnd.frogans.ltf": { source: "iana", extensions: ["ltf"] },
  "application/vnd.fsc.weblaunch": { source: "iana", extensions: ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { source: "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { source: "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { source: "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { source: "iana", compressible: !0 },
  "application/vnd.fujitsu.oasys": { source: "iana", extensions: ["oas"] },
  "application/vnd.fujitsu.oasys2": { source: "iana", extensions: ["oa2"] },
  "application/vnd.fujitsu.oasys3": { source: "iana", extensions: ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { source: "iana", extensions: ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { source: "iana", extensions: ["bh2"] },
  "application/vnd.fujixerox.art-ex": { source: "iana" },
  "application/vnd.fujixerox.art4": { source: "iana" },
  "application/vnd.fujixerox.ddd": { source: "iana", extensions: ["ddd"] },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: ["xdw"],
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: ["xbd"],
  },
  "application/vnd.fujixerox.docuworks.container": { source: "iana" },
  "application/vnd.fujixerox.hbpl": { source: "iana" },
  "application/vnd.fut-misnet": { source: "iana" },
  "application/vnd.futoin+cbor": { source: "iana" },
  "application/vnd.futoin+json": { source: "iana", compressible: !0 },
  "application/vnd.fuzzysheet": { source: "iana", extensions: ["fzs"] },
  "application/vnd.genomatix.tuxedo": { source: "iana", extensions: ["txd"] },
  "application/vnd.gentics.grd+json": { source: "iana", compressible: !0 },
  "application/vnd.geo+json": { source: "iana", compressible: !0 },
  "application/vnd.geocube+xml": { source: "iana", compressible: !0 },
  "application/vnd.geogebra.file": { source: "iana", extensions: ["ggb"] },
  "application/vnd.geogebra.slides": { source: "iana" },
  "application/vnd.geogebra.tool": { source: "iana", extensions: ["ggt"] },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: ["gex", "gre"],
  },
  "application/vnd.geonext": { source: "iana", extensions: ["gxt"] },
  "application/vnd.geoplan": { source: "iana", extensions: ["g2w"] },
  "application/vnd.geospace": { source: "iana", extensions: ["g3w"] },
  "application/vnd.gerber": { source: "iana" },
  "application/vnd.globalplatform.card-content-mgt": { source: "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana",
  },
  "application/vnd.gmx": { source: "iana", extensions: ["gmx"] },
  "application/vnd.google-apps.document": {
    compressible: !1,
    extensions: ["gdoc"],
  },
  "application/vnd.google-apps.presentation": {
    compressible: !1,
    extensions: ["gslides"],
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: !1,
    extensions: ["gsheet"],
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["kml"],
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: !1,
    extensions: ["kmz"],
  },
  "application/vnd.gov.sk.e-form+xml": { source: "iana", compressible: !0 },
  "application/vnd.gov.sk.e-form+zip": { source: "iana", compressible: !1 },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.grafeq": { source: "iana", extensions: ["gqf", "gqs"] },
  "application/vnd.gridmp": { source: "iana" },
  "application/vnd.groove-account": { source: "iana", extensions: ["gac"] },
  "application/vnd.groove-help": { source: "iana", extensions: ["ghf"] },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: ["gim"],
  },
  "application/vnd.groove-injector": { source: "iana", extensions: ["grv"] },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: ["gtm"],
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: ["tpl"],
  },
  "application/vnd.groove-vcard": { source: "iana", extensions: ["vcg"] },
  "application/vnd.hal+json": { source: "iana", compressible: !0 },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["hal"],
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["zmm"],
  },
  "application/vnd.hbci": { source: "iana", extensions: ["hbci"] },
  "application/vnd.hc+json": { source: "iana", compressible: !0 },
  "application/vnd.hcl-bireports": { source: "iana" },
  "application/vnd.hdt": { source: "iana" },
  "application/vnd.heroku+json": { source: "iana", compressible: !0 },
  "application/vnd.hhe.lesson-player": { source: "iana", extensions: ["les"] },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.hp-hpgl": { source: "iana", extensions: ["hpgl"] },
  "application/vnd.hp-hpid": { source: "iana", extensions: ["hpid"] },
  "application/vnd.hp-hps": { source: "iana", extensions: ["hps"] },
  "application/vnd.hp-jlyt": { source: "iana", extensions: ["jlt"] },
  "application/vnd.hp-pcl": { source: "iana", extensions: ["pcl"] },
  "application/vnd.hp-pclxl": { source: "iana", extensions: ["pclxl"] },
  "application/vnd.httphone": { source: "iana" },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: ["sfd-hdstx"],
  },
  "application/vnd.hyper+json": { source: "iana", compressible: !0 },
  "application/vnd.hyper-item+json": { source: "iana", compressible: !0 },
  "application/vnd.hyperdrive+json": { source: "iana", compressible: !0 },
  "application/vnd.hzn-3d-crossword": { source: "iana" },
  "application/vnd.ibm.afplinedata": { source: "iana" },
  "application/vnd.ibm.electronic-media": { source: "iana" },
  "application/vnd.ibm.minipay": { source: "iana", extensions: ["mpy"] },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: ["afp", "listafp", "list3820"],
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: ["irm"],
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: ["sc"],
  },
  "application/vnd.iccprofile": { source: "iana", extensions: ["icc", "icm"] },
  "application/vnd.ieee.1905": { source: "iana" },
  "application/vnd.igloader": { source: "iana", extensions: ["igl"] },
  "application/vnd.imagemeter.folder+zip": { source: "iana", compressible: !1 },
  "application/vnd.imagemeter.image+zip": { source: "iana", compressible: !1 },
  "application/vnd.immervision-ivp": { source: "iana", extensions: ["ivp"] },
  "application/vnd.immervision-ivu": { source: "iana", extensions: ["ivu"] },
  "application/vnd.ims.imsccv1p1": { source: "iana" },
  "application/vnd.ims.imsccv1p2": { source: "iana" },
  "application/vnd.ims.imsccv1p3": { source: "iana" },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.informix-visionary": { source: "iana" },
  "application/vnd.infotech.project": { source: "iana" },
  "application/vnd.infotech.project+xml": { source: "iana", compressible: !0 },
  "application/vnd.innopath.wamp.notification": { source: "iana" },
  "application/vnd.insors.igm": { source: "iana", extensions: ["igm"] },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: ["xpw", "xpx"],
  },
  "application/vnd.intergeo": { source: "iana", extensions: ["i2g"] },
  "application/vnd.intertrust.digibox": { source: "iana" },
  "application/vnd.intertrust.nncp": { source: "iana" },
  "application/vnd.intu.qbo": { source: "iana", extensions: ["qbo"] },
  "application/vnd.intu.qfx": { source: "iana", extensions: ["qfx"] },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.newsitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: ["rcprofile"],
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["irp"],
  },
  "application/vnd.is-xpr": { source: "iana", extensions: ["xpr"] },
  "application/vnd.isac.fcs": { source: "iana", extensions: ["fcs"] },
  "application/vnd.iso11783-10+zip": { source: "iana", compressible: !1 },
  "application/vnd.jam": { source: "iana", extensions: ["jam"] },
  "application/vnd.japannet-directory-service": { source: "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { source: "iana" },
  "application/vnd.japannet-payment-wakeup": { source: "iana" },
  "application/vnd.japannet-registration": { source: "iana" },
  "application/vnd.japannet-registration-wakeup": { source: "iana" },
  "application/vnd.japannet-setstore-wakeup": { source: "iana" },
  "application/vnd.japannet-verification": { source: "iana" },
  "application/vnd.japannet-verification-wakeup": { source: "iana" },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: ["rms"],
  },
  "application/vnd.jisp": { source: "iana", extensions: ["jisp"] },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: ["joda"],
  },
  "application/vnd.jsk.isdn-ngn": { source: "iana" },
  "application/vnd.kahootz": { source: "iana", extensions: ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { source: "iana", extensions: ["karbon"] },
  "application/vnd.kde.kchart": { source: "iana", extensions: ["chrt"] },
  "application/vnd.kde.kformula": { source: "iana", extensions: ["kfo"] },
  "application/vnd.kde.kivio": { source: "iana", extensions: ["flw"] },
  "application/vnd.kde.kontour": { source: "iana", extensions: ["kon"] },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: ["kpr", "kpt"],
  },
  "application/vnd.kde.kspread": { source: "iana", extensions: ["ksp"] },
  "application/vnd.kde.kword": { source: "iana", extensions: ["kwd", "kwt"] },
  "application/vnd.kenameaapp": { source: "iana", extensions: ["htke"] },
  "application/vnd.kidspiration": { source: "iana", extensions: ["kia"] },
  "application/vnd.kinar": { source: "iana", extensions: ["kne", "knp"] },
  "application/vnd.koan": {
    source: "iana",
    extensions: ["skp", "skd", "skt", "skm"],
  },
  "application/vnd.kodak-descriptor": { source: "iana", extensions: ["sse"] },
  "application/vnd.las": { source: "iana" },
  "application/vnd.las.las+json": { source: "iana", compressible: !0 },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lasxml"],
  },
  "application/vnd.laszip": { source: "iana" },
  "application/vnd.leap+json": { source: "iana", compressible: !0 },
  "application/vnd.liberty-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: ["lbd"],
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lbe"],
  },
  "application/vnd.logipipe.circuit+zip": { source: "iana", compressible: !1 },
  "application/vnd.loom": { source: "iana" },
  "application/vnd.lotus-1-2-3": { source: "iana", extensions: ["123"] },
  "application/vnd.lotus-approach": { source: "iana", extensions: ["apr"] },
  "application/vnd.lotus-freelance": { source: "iana", extensions: ["pre"] },
  "application/vnd.lotus-notes": { source: "iana", extensions: ["nsf"] },
  "application/vnd.lotus-organizer": { source: "iana", extensions: ["org"] },
  "application/vnd.lotus-screencam": { source: "iana", extensions: ["scm"] },
  "application/vnd.lotus-wordpro": { source: "iana", extensions: ["lwp"] },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: ["portpkg"],
  },
  "application/vnd.mapbox-vector-tile": { source: "iana", extensions: ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.marlin.drm.mdcf": { source: "iana" },
  "application/vnd.mason+json": { source: "iana", compressible: !0 },
  "application/vnd.maxar.archive.3tz+zip": { source: "iana", compressible: !1 },
  "application/vnd.maxmind.maxmind-db": { source: "iana" },
  "application/vnd.mcd": { source: "iana", extensions: ["mcd"] },
  "application/vnd.medcalcdata": { source: "iana", extensions: ["mc1"] },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: ["cdkey"],
  },
  "application/vnd.meridian-slingshot": { source: "iana" },
  "application/vnd.mfer": { source: "iana", extensions: ["mwf"] },
  "application/vnd.mfmp": { source: "iana", extensions: ["mfm"] },
  "application/vnd.micro+json": { source: "iana", compressible: !0 },
  "application/vnd.micrografx.flo": { source: "iana", extensions: ["flo"] },
  "application/vnd.micrografx.igx": { source: "iana", extensions: ["igx"] },
  "application/vnd.microsoft.portable-executable": { source: "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { source: "iana" },
  "application/vnd.miele+json": { source: "iana", compressible: !0 },
  "application/vnd.mif": { source: "iana", extensions: ["mif"] },
  "application/vnd.minisoft-hp3000-save": { source: "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { source: "iana" },
  "application/vnd.mobius.daf": { source: "iana", extensions: ["daf"] },
  "application/vnd.mobius.dis": { source: "iana", extensions: ["dis"] },
  "application/vnd.mobius.mbk": { source: "iana", extensions: ["mbk"] },
  "application/vnd.mobius.mqy": { source: "iana", extensions: ["mqy"] },
  "application/vnd.mobius.msl": { source: "iana", extensions: ["msl"] },
  "application/vnd.mobius.plc": { source: "iana", extensions: ["plc"] },
  "application/vnd.mobius.txf": { source: "iana", extensions: ["txf"] },
  "application/vnd.mophun.application": { source: "iana", extensions: ["mpn"] },
  "application/vnd.mophun.certificate": { source: "iana", extensions: ["mpc"] },
  "application/vnd.motorola.flexsuite": { source: "iana" },
  "application/vnd.motorola.flexsuite.adsi": { source: "iana" },
  "application/vnd.motorola.flexsuite.fis": { source: "iana" },
  "application/vnd.motorola.flexsuite.gotap": { source: "iana" },
  "application/vnd.motorola.flexsuite.kmr": { source: "iana" },
  "application/vnd.motorola.flexsuite.ttc": { source: "iana" },
  "application/vnd.motorola.flexsuite.wem": { source: "iana" },
  "application/vnd.motorola.iprm": { source: "iana" },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xul"],
  },
  "application/vnd.ms-3mfdocument": { source: "iana" },
  "application/vnd.ms-artgalry": { source: "iana", extensions: ["cil"] },
  "application/vnd.ms-asf": { source: "iana" },
  "application/vnd.ms-cab-compressed": { source: "iana", extensions: ["cab"] },
  "application/vnd.ms-color.iccprofile": { source: "apache" },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: !1,
    extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: ["xlam"],
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: ["xlsb"],
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: ["xlsm"],
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: ["xltm"],
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: !0,
    extensions: ["eot"],
  },
  "application/vnd.ms-htmlhelp": { source: "iana", extensions: ["chm"] },
  "application/vnd.ms-ims": { source: "iana", extensions: ["ims"] },
  "application/vnd.ms-lrm": { source: "iana", extensions: ["lrm"] },
  "application/vnd.ms-office.activex+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-officetheme": { source: "iana", extensions: ["thmx"] },
  "application/vnd.ms-opentype": { source: "apache", compressible: !0 },
  "application/vnd.ms-outlook": { compressible: !1, extensions: ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { source: "apache" },
  "application/vnd.ms-pki.seccat": { source: "apache", extensions: ["cat"] },
  "application/vnd.ms-pki.stl": { source: "apache", extensions: ["stl"] },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: !1,
    extensions: ["ppt", "pps", "pot"],
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: ["ppam"],
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: ["pptm"],
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: ["sldm"],
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: ["ppsm"],
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: ["potm"],
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: !0,
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ms-project": { source: "iana", extensions: ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { source: "iana" },
  "application/vnd.ms-windows.devicepairing": { source: "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { source: "iana" },
  "application/vnd.ms-windows.printerpairing": { source: "iana" },
  "application/vnd.ms-windows.wsd.oob": { source: "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { source: "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { source: "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { source: "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { source: "iana" },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: ["docm"],
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: ["dotm"],
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: ["wps", "wks", "wcm", "wdb"],
  },
  "application/vnd.ms-wpl": { source: "iana", extensions: ["wpl"] },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: !1,
    extensions: ["xps"],
  },
  "application/vnd.msa-disk-image": { source: "iana" },
  "application/vnd.mseq": { source: "iana", extensions: ["mseq"] },
  "application/vnd.msign": { source: "iana" },
  "application/vnd.multiad.creator": { source: "iana" },
  "application/vnd.multiad.creator.cif": { source: "iana" },
  "application/vnd.music-niff": { source: "iana" },
  "application/vnd.musician": { source: "iana", extensions: ["mus"] },
  "application/vnd.muvee.style": { source: "iana", extensions: ["msty"] },
  "application/vnd.mynfc": { source: "iana", extensions: ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { source: "iana", compressible: !0 },
  "application/vnd.ncd.control": { source: "iana" },
  "application/vnd.ncd.reference": { source: "iana" },
  "application/vnd.nearst.inv+json": { source: "iana", compressible: !0 },
  "application/vnd.nebumind.line": { source: "iana" },
  "application/vnd.nervana": { source: "iana" },
  "application/vnd.netfpx": { source: "iana" },
  "application/vnd.neurolanguage.nlu": { source: "iana", extensions: ["nlu"] },
  "application/vnd.nimn": { source: "iana" },
  "application/vnd.nintendo.nitro.rom": { source: "iana" },
  "application/vnd.nintendo.snes.rom": { source: "iana" },
  "application/vnd.nitf": { source: "iana", extensions: ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { source: "iana", extensions: ["nnd"] },
  "application/vnd.noblenet-sealer": { source: "iana", extensions: ["nns"] },
  "application/vnd.noblenet-web": { source: "iana", extensions: ["nnw"] },
  "application/vnd.nokia.catalogs": { source: "iana" },
  "application/vnd.nokia.conml+wbxml": { source: "iana" },
  "application/vnd.nokia.conml+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.iptv.config+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.isds-radio-presets": { source: "iana" },
  "application/vnd.nokia.landmark+wbxml": { source: "iana" },
  "application/vnd.nokia.landmark+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ac"],
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: ["ngdat"],
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: ["n-gage"],
  },
  "application/vnd.nokia.ncd": { source: "iana" },
  "application/vnd.nokia.pcd+wbxml": { source: "iana" },
  "application/vnd.nokia.pcd+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: ["rpst"],
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: ["rpss"],
  },
  "application/vnd.novadigm.edm": { source: "iana", extensions: ["edm"] },
  "application/vnd.novadigm.edx": { source: "iana", extensions: ["edx"] },
  "application/vnd.novadigm.ext": { source: "iana", extensions: ["ext"] },
  "application/vnd.ntt-local.content-share": { source: "iana" },
  "application/vnd.ntt-local.file-transfer": { source: "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { source: "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { source: "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { source: "iana" },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: ["odc"],
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: ["otc"],
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: ["odb"],
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: ["odf"],
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: ["odft"],
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: !1,
    extensions: ["odg"],
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: ["otg"],
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: ["odi"],
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: ["oti"],
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: !1,
    extensions: ["odp"],
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: ["otp"],
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: !1,
    extensions: ["ods"],
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: ["ots"],
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: !1,
    extensions: ["odt"],
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: ["odm"],
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: ["ott"],
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: ["oth"],
  },
  "application/vnd.obn": { source: "iana" },
  "application/vnd.ocf+cbor": { source: "iana" },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oftn.l10n+json": { source: "iana", compressible: !0 },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oipf.cspg-hexbinary": { source: "iana" },
  "application/vnd.oipf.dae.svg+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.dae.xhtml+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oipf.pae.gem": { source: "iana" },
  "application/vnd.oipf.spdiscovery+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.spdlist+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.ueprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.userprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.olpc-sugar": { source: "iana", extensions: ["xo"] },
  "application/vnd.oma-scws-config": { source: "iana" },
  "application/vnd.oma-scws-http-request": { source: "iana" },
  "application/vnd.oma-scws-http-response": { source: "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.imd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.ltkm": { source: "iana" },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.provisioningtrigger": { source: "iana" },
  "application/vnd.oma.bcast.sgboot": { source: "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.sgdu": { source: "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { source: "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.sprov+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.stkm": { source: "iana" },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.cab-pcc+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.dcd": { source: "iana" },
  "application/vnd.oma.dcdc": { source: "iana" },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["dd2"],
  },
  "application/vnd.oma.drm.risd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.lwm2m+cbor": { source: "iana" },
  "application/vnd.oma.lwm2m+json": { source: "iana", compressible: !0 },
  "application/vnd.oma.lwm2m+tlv": { source: "iana" },
  "application/vnd.oma.pal+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.poc.groups+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.push": { source: "iana" },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.omaloc-supl-init": { source: "iana" },
  "application/vnd.onepager": { source: "iana" },
  "application/vnd.onepagertamp": { source: "iana" },
  "application/vnd.onepagertamx": { source: "iana" },
  "application/vnd.onepagertat": { source: "iana" },
  "application/vnd.onepagertatp": { source: "iana" },
  "application/vnd.onepagertatx": { source: "iana" },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["obgx"],
  },
  "application/vnd.openblox.game-binary": { source: "iana" },
  "application/vnd.openeye.oeb": { source: "iana" },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: ["oxt"],
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["osm"],
  },
  "application/vnd.opentimestamps.ots": { source: "iana" },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: !1,
    extensions: ["pptx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: ["sldx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: ["ppsx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: ["potx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: !1,
    extensions: ["xlsx"],
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: ["xltx"],
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana",
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: !1,
    extensions: ["docx"],
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: ["dotx"],
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oracle.resource+json": { source: "iana", compressible: !0 },
  "application/vnd.orange.indata": { source: "iana" },
  "application/vnd.osa.netdeploy": { source: "iana" },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: ["mgp"],
  },
  "application/vnd.osgi.bundle": { source: "iana" },
  "application/vnd.osgi.dp": { source: "iana", extensions: ["dp"] },
  "application/vnd.osgi.subsystem": { source: "iana", extensions: ["esa"] },
  "application/vnd.otps.ct-kip+xml": { source: "iana", compressible: !0 },
  "application/vnd.oxli.countgraph": { source: "iana" },
  "application/vnd.pagerduty+json": { source: "iana", compressible: !0 },
  "application/vnd.palm": {
    source: "iana",
    extensions: ["pdb", "pqa", "oprc"],
  },
  "application/vnd.panoply": { source: "iana" },
  "application/vnd.paos.xml": { source: "iana" },
  "application/vnd.patentdive": { source: "iana" },
  "application/vnd.patientecommsdoc": { source: "iana" },
  "application/vnd.pawaafile": { source: "iana", extensions: ["paw"] },
  "application/vnd.pcos": { source: "iana" },
  "application/vnd.pg.format": { source: "iana", extensions: ["str"] },
  "application/vnd.pg.osasli": { source: "iana", extensions: ["ei6"] },
  "application/vnd.piaccess.application-licence": { source: "iana" },
  "application/vnd.picsel": { source: "iana", extensions: ["efif"] },
  "application/vnd.pmi.widget": { source: "iana", extensions: ["wg"] },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.pocketlearn": { source: "iana", extensions: ["plf"] },
  "application/vnd.powerbuilder6": { source: "iana", extensions: ["pbd"] },
  "application/vnd.powerbuilder6-s": { source: "iana" },
  "application/vnd.powerbuilder7": { source: "iana" },
  "application/vnd.powerbuilder7-s": { source: "iana" },
  "application/vnd.powerbuilder75": { source: "iana" },
  "application/vnd.powerbuilder75-s": { source: "iana" },
  "application/vnd.preminet": { source: "iana" },
  "application/vnd.previewsystems.box": { source: "iana", extensions: ["box"] },
  "application/vnd.proteus.magazine": { source: "iana", extensions: ["mgz"] },
  "application/vnd.psfs": { source: "iana" },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: ["qps"],
  },
  "application/vnd.pvi.ptid1": { source: "iana", extensions: ["ptid"] },
  "application/vnd.pwg-multiplexed": { source: "iana" },
  "application/vnd.pwg-xhtml-print+xml": { source: "iana", compressible: !0 },
  "application/vnd.qualcomm.brew-app-res": { source: "iana" },
  "application/vnd.quarantainenet": { source: "iana" },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
  },
  "application/vnd.quobject-quoxdocument": { source: "iana" },
  "application/vnd.radisys.moml+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-conf+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.rainstor.data": { source: "iana" },
  "application/vnd.rapid": { source: "iana" },
  "application/vnd.rar": { source: "iana", extensions: ["rar"] },
  "application/vnd.realvnc.bed": { source: "iana", extensions: ["bed"] },
  "application/vnd.recordare.musicxml": { source: "iana", extensions: ["mxl"] },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["musicxml"],
  },
  "application/vnd.renlearn.rlprint": { source: "iana" },
  "application/vnd.resilient.logic": { source: "iana" },
  "application/vnd.restful+json": { source: "iana", compressible: !0 },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: ["cryptonote"],
  },
  "application/vnd.rim.cod": { source: "apache", extensions: ["cod"] },
  "application/vnd.rn-realmedia": { source: "apache", extensions: ["rm"] },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: ["rmvb"],
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["link66"],
  },
  "application/vnd.rs-274x": { source: "iana" },
  "application/vnd.ruckus.download": { source: "iana" },
  "application/vnd.s3sms": { source: "iana" },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: ["st"],
  },
  "application/vnd.sar": { source: "iana" },
  "application/vnd.sbm.cid": { source: "iana" },
  "application/vnd.sbm.mid2": { source: "iana" },
  "application/vnd.scribus": { source: "iana" },
  "application/vnd.sealed.3df": { source: "iana" },
  "application/vnd.sealed.csf": { source: "iana" },
  "application/vnd.sealed.doc": { source: "iana" },
  "application/vnd.sealed.eml": { source: "iana" },
  "application/vnd.sealed.mht": { source: "iana" },
  "application/vnd.sealed.net": { source: "iana" },
  "application/vnd.sealed.ppt": { source: "iana" },
  "application/vnd.sealed.tiff": { source: "iana" },
  "application/vnd.sealed.xls": { source: "iana" },
  "application/vnd.sealedmedia.softseal.html": { source: "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { source: "iana" },
  "application/vnd.seemail": { source: "iana", extensions: ["see"] },
  "application/vnd.seis+json": { source: "iana", compressible: !0 },
  "application/vnd.sema": { source: "iana", extensions: ["sema"] },
  "application/vnd.semd": { source: "iana", extensions: ["semd"] },
  "application/vnd.semf": { source: "iana", extensions: ["semf"] },
  "application/vnd.shade-save-file": { source: "iana" },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: ["ifm"],
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: ["itp"],
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: ["iif"],
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: ["ipk"],
  },
  "application/vnd.shootproof+json": { source: "iana", compressible: !0 },
  "application/vnd.shopkick+json": { source: "iana", compressible: !0 },
  "application/vnd.shp": { source: "iana" },
  "application/vnd.shx": { source: "iana" },
  "application/vnd.sigrok.session": { source: "iana" },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: ["twd", "twds"],
  },
  "application/vnd.siren+json": { source: "iana", compressible: !0 },
  "application/vnd.smaf": { source: "iana", extensions: ["mmf"] },
  "application/vnd.smart.notebook": { source: "iana" },
  "application/vnd.smart.teacher": { source: "iana", extensions: ["teacher"] },
  "application/vnd.snesdev-page-table": { source: "iana" },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["fo"],
  },
  "application/vnd.software602.filler.form-xml-zip": { source: "iana" },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sdkm", "sdkd"],
  },
  "application/vnd.spotfire.dxp": { source: "iana", extensions: ["dxp"] },
  "application/vnd.spotfire.sfs": { source: "iana", extensions: ["sfs"] },
  "application/vnd.sqlite3": { source: "iana" },
  "application/vnd.sss-cod": { source: "iana" },
  "application/vnd.sss-dtf": { source: "iana" },
  "application/vnd.sss-ntf": { source: "iana" },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: ["sdc"],
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: ["sda"],
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: ["sdd"],
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: ["smf"],
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: ["sdw", "vor"],
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: ["sgl"],
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: ["smzip"],
  },
  "application/vnd.stepmania.stepchart": { source: "iana", extensions: ["sm"] },
  "application/vnd.street-stream": { source: "iana" },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wadl"],
  },
  "application/vnd.sun.xml.calc": { source: "apache", extensions: ["sxc"] },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: ["stc"],
  },
  "application/vnd.sun.xml.draw": { source: "apache", extensions: ["sxd"] },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: ["std"],
  },
  "application/vnd.sun.xml.impress": { source: "apache", extensions: ["sxi"] },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: ["sti"],
  },
  "application/vnd.sun.xml.math": { source: "apache", extensions: ["sxm"] },
  "application/vnd.sun.xml.writer": { source: "apache", extensions: ["sxw"] },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: ["sxg"],
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: ["stw"],
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: ["sus", "susp"],
  },
  "application/vnd.svd": { source: "iana", extensions: ["svd"] },
  "application/vnd.swiftview-ics": { source: "iana" },
  "application/vnd.sycle+xml": { source: "iana", compressible: !0 },
  "application/vnd.syft+json": { source: "iana", compressible: !0 },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: ["sis", "sisx"],
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["xsm"],
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["bdm"],
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["xdm"],
  },
  "application/vnd.syncml.dm.notification": { source: "iana" },
  "application/vnd.syncml.dmddf+wbxml": { source: "iana" },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["ddf"],
  },
  "application/vnd.syncml.dmtnds+wbxml": { source: "iana" },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.syncml.ds.notification": { source: "iana" },
  "application/vnd.tableschema+json": { source: "iana", compressible: !0 },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: ["tao"],
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: ["pcap", "cap", "dmp"],
  },
  "application/vnd.think-cell.ppttc+json": { source: "iana", compressible: !0 },
  "application/vnd.tmd.mediaflex.api+xml": { source: "iana", compressible: !0 },
  "application/vnd.tml": { source: "iana" },
  "application/vnd.tmobile-livetv": { source: "iana", extensions: ["tmo"] },
  "application/vnd.tri.onesource": { source: "iana" },
  "application/vnd.trid.tpt": { source: "iana", extensions: ["tpt"] },
  "application/vnd.triscape.mxs": { source: "iana", extensions: ["mxs"] },
  "application/vnd.trueapp": { source: "iana", extensions: ["tra"] },
  "application/vnd.truedoc": { source: "iana" },
  "application/vnd.ubisoft.webplayer": { source: "iana" },
  "application/vnd.ufdl": { source: "iana", extensions: ["ufd", "ufdl"] },
  "application/vnd.uiq.theme": { source: "iana", extensions: ["utz"] },
  "application/vnd.umajin": { source: "iana", extensions: ["umj"] },
  "application/vnd.unity": { source: "iana", extensions: ["unityweb"] },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["uoml"],
  },
  "application/vnd.uplanet.alert": { source: "iana" },
  "application/vnd.uplanet.alert-wbxml": { source: "iana" },
  "application/vnd.uplanet.bearer-choice": { source: "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { source: "iana" },
  "application/vnd.uplanet.cacheop": { source: "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { source: "iana" },
  "application/vnd.uplanet.channel": { source: "iana" },
  "application/vnd.uplanet.channel-wbxml": { source: "iana" },
  "application/vnd.uplanet.list": { source: "iana" },
  "application/vnd.uplanet.list-wbxml": { source: "iana" },
  "application/vnd.uplanet.listcmd": { source: "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { source: "iana" },
  "application/vnd.uplanet.signal": { source: "iana" },
  "application/vnd.uri-map": { source: "iana" },
  "application/vnd.valve.source.material": { source: "iana" },
  "application/vnd.vcx": { source: "iana", extensions: ["vcx"] },
  "application/vnd.vd-study": { source: "iana" },
  "application/vnd.vectorworks": { source: "iana" },
  "application/vnd.vel+json": { source: "iana", compressible: !0 },
  "application/vnd.verimatrix.vcas": { source: "iana" },
  "application/vnd.veritone.aion+json": { source: "iana", compressible: !0 },
  "application/vnd.veryant.thin": { source: "iana" },
  "application/vnd.ves.encrypted": { source: "iana" },
  "application/vnd.vidsoft.vidconference": { source: "iana" },
  "application/vnd.visio": {
    source: "iana",
    extensions: ["vsd", "vst", "vss", "vsw"],
  },
  "application/vnd.visionary": { source: "iana", extensions: ["vis"] },
  "application/vnd.vividence.scriptfile": { source: "iana" },
  "application/vnd.vsf": { source: "iana", extensions: ["vsf"] },
  "application/vnd.wap.sic": { source: "iana" },
  "application/vnd.wap.slc": { source: "iana" },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["wbxml"],
  },
  "application/vnd.wap.wmlc": { source: "iana", extensions: ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { source: "iana", extensions: ["wmlsc"] },
  "application/vnd.webturbo": { source: "iana", extensions: ["wtb"] },
  "application/vnd.wfa.dpp": { source: "iana" },
  "application/vnd.wfa.p2p": { source: "iana" },
  "application/vnd.wfa.wsc": { source: "iana" },
  "application/vnd.windows.devicepairing": { source: "iana" },
  "application/vnd.wmc": { source: "iana" },
  "application/vnd.wmf.bootstrap": { source: "iana" },
  "application/vnd.wolfram.mathematica": { source: "iana" },
  "application/vnd.wolfram.mathematica.package": { source: "iana" },
  "application/vnd.wolfram.player": { source: "iana", extensions: ["nbp"] },
  "application/vnd.wordperfect": { source: "iana", extensions: ["wpd"] },
  "application/vnd.wqd": { source: "iana", extensions: ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { source: "iana" },
  "application/vnd.wt.stf": { source: "iana", extensions: ["stf"] },
  "application/vnd.wv.csp+wbxml": { source: "iana" },
  "application/vnd.wv.csp+xml": { source: "iana", compressible: !0 },
  "application/vnd.wv.ssp+xml": { source: "iana", compressible: !0 },
  "application/vnd.xacml+json": { source: "iana", compressible: !0 },
  "application/vnd.xara": { source: "iana", extensions: ["xar"] },
  "application/vnd.xfdl": { source: "iana", extensions: ["xfdl"] },
  "application/vnd.xfdl.webform": { source: "iana" },
  "application/vnd.xmi+xml": { source: "iana", compressible: !0 },
  "application/vnd.xmpie.cpkg": { source: "iana" },
  "application/vnd.xmpie.dpkg": { source: "iana" },
  "application/vnd.xmpie.plan": { source: "iana" },
  "application/vnd.xmpie.ppkg": { source: "iana" },
  "application/vnd.xmpie.xlim": { source: "iana" },
  "application/vnd.yamaha.hv-dic": { source: "iana", extensions: ["hvd"] },
  "application/vnd.yamaha.hv-script": { source: "iana", extensions: ["hvs"] },
  "application/vnd.yamaha.hv-voice": { source: "iana", extensions: ["hvp"] },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: ["osf"],
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["osfpvg"],
  },
  "application/vnd.yamaha.remote-setup": { source: "iana" },
  "application/vnd.yamaha.smaf-audio": { source: "iana", extensions: ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { source: "iana", extensions: ["spf"] },
  "application/vnd.yamaha.through-ngn": { source: "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { source: "iana" },
  "application/vnd.yaoweme": { source: "iana" },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: ["cmp"],
  },
  "application/vnd.youtube.yt": { source: "iana" },
  "application/vnd.zul": { source: "iana", extensions: ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["zaz"],
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["vxml"],
  },
  "application/voucher-cms+json": { source: "iana", compressible: !0 },
  "application/vq-rtcpxr": { source: "iana" },
  "application/wasm": {
    source: "iana",
    compressible: !0,
    extensions: ["wasm"],
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wif"],
  },
  "application/webpush-options+json": { source: "iana", compressible: !0 },
  "application/whoispp-query": { source: "iana" },
  "application/whoispp-response": { source: "iana" },
  "application/widget": { source: "iana", extensions: ["wgt"] },
  "application/winhlp": { source: "apache", extensions: ["hlp"] },
  "application/wita": { source: "iana" },
  "application/wordperfect5.1": { source: "iana" },
  "application/wsdl+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wsdl"],
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wspolicy"],
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: !1,
    extensions: ["7z"],
  },
  "application/x-abiword": { source: "apache", extensions: ["abw"] },
  "application/x-ace-compressed": { source: "apache", extensions: ["ace"] },
  "application/x-amf": { source: "apache" },
  "application/x-apple-diskimage": { source: "apache", extensions: ["dmg"] },
  "application/x-arj": { compressible: !1, extensions: ["arj"] },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: ["aab", "x32", "u32", "vox"],
  },
  "application/x-authorware-map": { source: "apache", extensions: ["aam"] },
  "application/x-authorware-seg": { source: "apache", extensions: ["aas"] },
  "application/x-bcpio": { source: "apache", extensions: ["bcpio"] },
  "application/x-bdoc": { compressible: !1, extensions: ["bdoc"] },
  "application/x-bittorrent": { source: "apache", extensions: ["torrent"] },
  "application/x-blorb": { source: "apache", extensions: ["blb", "blorb"] },
  "application/x-bzip": {
    source: "apache",
    compressible: !1,
    extensions: ["bz"],
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: !1,
    extensions: ["bz2", "boz"],
  },
  "application/x-cbr": {
    source: "apache",
    extensions: ["cbr", "cba", "cbt", "cbz", "cb7"],
  },
  "application/x-cdlink": { source: "apache", extensions: ["vcd"] },
  "application/x-cfs-compressed": { source: "apache", extensions: ["cfs"] },
  "application/x-chat": { source: "apache", extensions: ["chat"] },
  "application/x-chess-pgn": { source: "apache", extensions: ["pgn"] },
  "application/x-chrome-extension": { extensions: ["crx"] },
  "application/x-cocoa": { source: "nginx", extensions: ["cco"] },
  "application/x-compress": { source: "apache" },
  "application/x-conference": { source: "apache", extensions: ["nsc"] },
  "application/x-cpio": { source: "apache", extensions: ["cpio"] },
  "application/x-csh": { source: "apache", extensions: ["csh"] },
  "application/x-deb": { compressible: !1 },
  "application/x-debian-package": {
    source: "apache",
    extensions: ["deb", "udeb"],
  },
  "application/x-dgc-compressed": { source: "apache", extensions: ["dgc"] },
  "application/x-director": {
    source: "apache",
    extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"],
  },
  "application/x-doom": { source: "apache", extensions: ["wad"] },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["ncx"],
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["dtb"],
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["res"],
  },
  "application/x-dvi": {
    source: "apache",
    compressible: !1,
    extensions: ["dvi"],
  },
  "application/x-envoy": { source: "apache", extensions: ["evy"] },
  "application/x-eva": { source: "apache", extensions: ["eva"] },
  "application/x-font-bdf": { source: "apache", extensions: ["bdf"] },
  "application/x-font-dos": { source: "apache" },
  "application/x-font-framemaker": { source: "apache" },
  "application/x-font-ghostscript": { source: "apache", extensions: ["gsf"] },
  "application/x-font-libgrx": { source: "apache" },
  "application/x-font-linux-psf": { source: "apache", extensions: ["psf"] },
  "application/x-font-pcf": { source: "apache", extensions: ["pcf"] },
  "application/x-font-snf": { source: "apache", extensions: ["snf"] },
  "application/x-font-speedo": { source: "apache" },
  "application/x-font-sunos-news": { source: "apache" },
  "application/x-font-type1": {
    source: "apache",
    extensions: ["pfa", "pfb", "pfm", "afm"],
  },
  "application/x-font-vfont": { source: "apache" },
  "application/x-freearc": { source: "apache", extensions: ["arc"] },
  "application/x-futuresplash": { source: "apache", extensions: ["spl"] },
  "application/x-gca-compressed": { source: "apache", extensions: ["gca"] },
  "application/x-glulx": { source: "apache", extensions: ["ulx"] },
  "application/x-gnumeric": { source: "apache", extensions: ["gnumeric"] },
  "application/x-gramps-xml": { source: "apache", extensions: ["gramps"] },
  "application/x-gtar": { source: "apache", extensions: ["gtar"] },
  "application/x-gzip": { source: "apache" },
  "application/x-hdf": { source: "apache", extensions: ["hdf"] },
  "application/x-httpd-php": { compressible: !0, extensions: ["php"] },
  "application/x-install-instructions": {
    source: "apache",
    extensions: ["install"],
  },
  "application/x-iso9660-image": { source: "apache", extensions: ["iso"] },
  "application/x-iwork-keynote-sffkey": { extensions: ["key"] },
  "application/x-iwork-numbers-sffnumbers": { extensions: ["numbers"] },
  "application/x-iwork-pages-sffpages": { extensions: ["pages"] },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: ["jardiff"],
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: !1,
    extensions: ["jnlp"],
  },
  "application/x-javascript": { compressible: !0 },
  "application/x-keepass2": { extensions: ["kdbx"] },
  "application/x-latex": {
    source: "apache",
    compressible: !1,
    extensions: ["latex"],
  },
  "application/x-lua-bytecode": { extensions: ["luac"] },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: ["lzh", "lha"],
  },
  "application/x-makeself": { source: "nginx", extensions: ["run"] },
  "application/x-mie": { source: "apache", extensions: ["mie"] },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: ["prc", "mobi"],
  },
  "application/x-mpegurl": { compressible: !1 },
  "application/x-ms-application": {
    source: "apache",
    extensions: ["application"],
  },
  "application/x-ms-shortcut": { source: "apache", extensions: ["lnk"] },
  "application/x-ms-wmd": { source: "apache", extensions: ["wmd"] },
  "application/x-ms-wmz": { source: "apache", extensions: ["wmz"] },
  "application/x-ms-xbap": { source: "apache", extensions: ["xbap"] },
  "application/x-msaccess": { source: "apache", extensions: ["mdb"] },
  "application/x-msbinder": { source: "apache", extensions: ["obd"] },
  "application/x-mscardfile": { source: "apache", extensions: ["crd"] },
  "application/x-msclip": { source: "apache", extensions: ["clp"] },
  "application/x-msdos-program": { extensions: ["exe"] },
  "application/x-msdownload": {
    source: "apache",
    extensions: ["exe", "dll", "com", "bat", "msi"],
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: ["mvb", "m13", "m14"],
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: ["wmf", "wmz", "emf", "emz"],
  },
  "application/x-msmoney": { source: "apache", extensions: ["mny"] },
  "application/x-mspublisher": { source: "apache", extensions: ["pub"] },
  "application/x-msschedule": { source: "apache", extensions: ["scd"] },
  "application/x-msterminal": { source: "apache", extensions: ["trm"] },
  "application/x-mswrite": { source: "apache", extensions: ["wri"] },
  "application/x-netcdf": { source: "apache", extensions: ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": {
    compressible: !0,
    extensions: ["pac"],
  },
  "application/x-nzb": { source: "apache", extensions: ["nzb"] },
  "application/x-perl": { source: "nginx", extensions: ["pl", "pm"] },
  "application/x-pilot": { source: "nginx", extensions: ["prc", "pdb"] },
  "application/x-pkcs12": {
    source: "apache",
    compressible: !1,
    extensions: ["p12", "pfx"],
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: ["p7b", "spc"],
  },
  "application/x-pkcs7-certreqresp": { source: "apache", extensions: ["p7r"] },
  "application/x-pki-message": { source: "iana" },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: !1,
    extensions: ["rar"],
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: ["rpm"],
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: ["ris"],
  },
  "application/x-sea": { source: "nginx", extensions: ["sea"] },
  "application/x-sh": {
    source: "apache",
    compressible: !0,
    extensions: ["sh"],
  },
  "application/x-shar": { source: "apache", extensions: ["shar"] },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: !1,
    extensions: ["swf"],
  },
  "application/x-silverlight-app": { source: "apache", extensions: ["xap"] },
  "application/x-sql": { source: "apache", extensions: ["sql"] },
  "application/x-stuffit": {
    source: "apache",
    compressible: !1,
    extensions: ["sit"],
  },
  "application/x-stuffitx": { source: "apache", extensions: ["sitx"] },
  "application/x-subrip": { source: "apache", extensions: ["srt"] },
  "application/x-sv4cpio": { source: "apache", extensions: ["sv4cpio"] },
  "application/x-sv4crc": { source: "apache", extensions: ["sv4crc"] },
  "application/x-t3vm-image": { source: "apache", extensions: ["t3"] },
  "application/x-tads": { source: "apache", extensions: ["gam"] },
  "application/x-tar": {
    source: "apache",
    compressible: !0,
    extensions: ["tar"],
  },
  "application/x-tcl": { source: "apache", extensions: ["tcl", "tk"] },
  "application/x-tex": { source: "apache", extensions: ["tex"] },
  "application/x-tex-tfm": { source: "apache", extensions: ["tfm"] },
  "application/x-texinfo": {
    source: "apache",
    extensions: ["texinfo", "texi"],
  },
  "application/x-tgif": { source: "apache", extensions: ["obj"] },
  "application/x-ustar": { source: "apache", extensions: ["ustar"] },
  "application/x-virtualbox-hdd": { compressible: !0, extensions: ["hdd"] },
  "application/x-virtualbox-ova": { compressible: !0, extensions: ["ova"] },
  "application/x-virtualbox-ovf": { compressible: !0, extensions: ["ovf"] },
  "application/x-virtualbox-vbox": { compressible: !0, extensions: ["vbox"] },
  "application/x-virtualbox-vbox-extpack": {
    compressible: !1,
    extensions: ["vbox-extpack"],
  },
  "application/x-virtualbox-vdi": { compressible: !0, extensions: ["vdi"] },
  "application/x-virtualbox-vhd": { compressible: !0, extensions: ["vhd"] },
  "application/x-virtualbox-vmdk": { compressible: !0, extensions: ["vmdk"] },
  "application/x-wais-source": { source: "apache", extensions: ["src"] },
  "application/x-web-app-manifest+json": {
    compressible: !0,
    extensions: ["webapp"],
  },
  "application/x-www-form-urlencoded": { source: "iana", compressible: !0 },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: ["der", "crt", "pem"],
  },
  "application/x-x509-ca-ra-cert": { source: "iana" },
  "application/x-x509-next-ca-cert": { source: "iana" },
  "application/x-xfig": { source: "apache", extensions: ["fig"] },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xlf"],
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: !1,
    extensions: ["xpi"],
  },
  "application/x-xz": { source: "apache", extensions: ["xz"] },
  "application/x-zmachine": {
    source: "apache",
    extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
  },
  "application/x400-bp": { source: "iana" },
  "application/xacml+xml": { source: "iana", compressible: !0 },
  "application/xaml+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xaml"],
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xav"],
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xca"],
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xdf"],
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xel"],
  },
  "application/xcap-error+xml": { source: "iana", compressible: !0 },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xns"],
  },
  "application/xcon-conference-info+xml": { source: "iana", compressible: !0 },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xenc"],
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xhtml", "xht"],
  },
  "application/xhtml-voice+xml": { source: "apache", compressible: !0 },
  "application/xliff+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xlf"],
  },
  "application/xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xml", "xsl", "xsd", "rng"],
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: !0,
    extensions: ["dtd"],
  },
  "application/xml-external-parsed-entity": { source: "iana" },
  "application/xml-patch+xml": { source: "iana", compressible: !0 },
  "application/xmpp+xml": { source: "iana", compressible: !0 },
  "application/xop+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xop"],
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xpl"],
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xsl", "xslt"],
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xspf"],
  },
  "application/xv+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mxml", "xhvml", "xvml", "xvm"],
  },
  "application/yang": { source: "iana", extensions: ["yang"] },
  "application/yang-data+json": { source: "iana", compressible: !0 },
  "application/yang-data+xml": { source: "iana", compressible: !0 },
  "application/yang-patch+json": { source: "iana", compressible: !0 },
  "application/yang-patch+xml": { source: "iana", compressible: !0 },
  "application/yin+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["yin"],
  },
  "application/zip": { source: "iana", compressible: !1, extensions: ["zip"] },
  "application/zlib": { source: "iana" },
  "application/zstd": { source: "iana" },
  "audio/1d-interleaved-parityfec": { source: "iana" },
  "audio/32kadpcm": { source: "iana" },
  "audio/3gpp": { source: "iana", compressible: !1, extensions: ["3gpp"] },
  "audio/3gpp2": { source: "iana" },
  "audio/aac": { source: "iana" },
  "audio/ac3": { source: "iana" },
  "audio/adpcm": { source: "apache", extensions: ["adp"] },
  "audio/amr": { source: "iana", extensions: ["amr"] },
  "audio/amr-wb": { source: "iana" },
  "audio/amr-wb+": { source: "iana" },
  "audio/aptx": { source: "iana" },
  "audio/asc": { source: "iana" },
  "audio/atrac-advanced-lossless": { source: "iana" },
  "audio/atrac-x": { source: "iana" },
  "audio/atrac3": { source: "iana" },
  "audio/basic": {
    source: "iana",
    compressible: !1,
    extensions: ["au", "snd"],
  },
  "audio/bv16": { source: "iana" },
  "audio/bv32": { source: "iana" },
  "audio/clearmode": { source: "iana" },
  "audio/cn": { source: "iana" },
  "audio/dat12": { source: "iana" },
  "audio/dls": { source: "iana" },
  "audio/dsr-es201108": { source: "iana" },
  "audio/dsr-es202050": { source: "iana" },
  "audio/dsr-es202211": { source: "iana" },
  "audio/dsr-es202212": { source: "iana" },
  "audio/dv": { source: "iana" },
  "audio/dvi4": { source: "iana" },
  "audio/eac3": { source: "iana" },
  "audio/encaprtp": { source: "iana" },
  "audio/evrc": { source: "iana" },
  "audio/evrc-qcp": { source: "iana" },
  "audio/evrc0": { source: "iana" },
  "audio/evrc1": { source: "iana" },
  "audio/evrcb": { source: "iana" },
  "audio/evrcb0": { source: "iana" },
  "audio/evrcb1": { source: "iana" },
  "audio/evrcnw": { source: "iana" },
  "audio/evrcnw0": { source: "iana" },
  "audio/evrcnw1": { source: "iana" },
  "audio/evrcwb": { source: "iana" },
  "audio/evrcwb0": { source: "iana" },
  "audio/evrcwb1": { source: "iana" },
  "audio/evs": { source: "iana" },
  "audio/flexfec": { source: "iana" },
  "audio/fwdred": { source: "iana" },
  "audio/g711-0": { source: "iana" },
  "audio/g719": { source: "iana" },
  "audio/g722": { source: "iana" },
  "audio/g7221": { source: "iana" },
  "audio/g723": { source: "iana" },
  "audio/g726-16": { source: "iana" },
  "audio/g726-24": { source: "iana" },
  "audio/g726-32": { source: "iana" },
  "audio/g726-40": { source: "iana" },
  "audio/g728": { source: "iana" },
  "audio/g729": { source: "iana" },
  "audio/g7291": { source: "iana" },
  "audio/g729d": { source: "iana" },
  "audio/g729e": { source: "iana" },
  "audio/gsm": { source: "iana" },
  "audio/gsm-efr": { source: "iana" },
  "audio/gsm-hr-08": { source: "iana" },
  "audio/ilbc": { source: "iana" },
  "audio/ip-mr_v2.5": { source: "iana" },
  "audio/isac": { source: "apache" },
  "audio/l16": { source: "iana" },
  "audio/l20": { source: "iana" },
  "audio/l24": { source: "iana", compressible: !1 },
  "audio/l8": { source: "iana" },
  "audio/lpc": { source: "iana" },
  "audio/melp": { source: "iana" },
  "audio/melp1200": { source: "iana" },
  "audio/melp2400": { source: "iana" },
  "audio/melp600": { source: "iana" },
  "audio/mhas": { source: "iana" },
  "audio/midi": { source: "apache", extensions: ["mid", "midi", "kar", "rmi"] },
  "audio/mobile-xmf": { source: "iana", extensions: ["mxmf"] },
  "audio/mp3": { compressible: !1, extensions: ["mp3"] },
  "audio/mp4": {
    source: "iana",
    compressible: !1,
    extensions: ["m4a", "mp4a"],
  },
  "audio/mp4a-latm": { source: "iana" },
  "audio/mpa": { source: "iana" },
  "audio/mpa-robust": { source: "iana" },
  "audio/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
  },
  "audio/mpeg4-generic": { source: "iana" },
  "audio/musepack": { source: "apache" },
  "audio/ogg": {
    source: "iana",
    compressible: !1,
    extensions: ["oga", "ogg", "spx", "opus"],
  },
  "audio/opus": { source: "iana" },
  "audio/parityfec": { source: "iana" },
  "audio/pcma": { source: "iana" },
  "audio/pcma-wb": { source: "iana" },
  "audio/pcmu": { source: "iana" },
  "audio/pcmu-wb": { source: "iana" },
  "audio/prs.sid": { source: "iana" },
  "audio/qcelp": { source: "iana" },
  "audio/raptorfec": { source: "iana" },
  "audio/red": { source: "iana" },
  "audio/rtp-enc-aescm128": { source: "iana" },
  "audio/rtp-midi": { source: "iana" },
  "audio/rtploopback": { source: "iana" },
  "audio/rtx": { source: "iana" },
  "audio/s3m": { source: "apache", extensions: ["s3m"] },
  "audio/scip": { source: "iana" },
  "audio/silk": { source: "apache", extensions: ["sil"] },
  "audio/smv": { source: "iana" },
  "audio/smv-qcp": { source: "iana" },
  "audio/smv0": { source: "iana" },
  "audio/sofa": { source: "iana" },
  "audio/sp-midi": { source: "iana" },
  "audio/speex": { source: "iana" },
  "audio/t140c": { source: "iana" },
  "audio/t38": { source: "iana" },
  "audio/telephone-event": { source: "iana" },
  "audio/tetra_acelp": { source: "iana" },
  "audio/tetra_acelp_bb": { source: "iana" },
  "audio/tone": { source: "iana" },
  "audio/tsvcis": { source: "iana" },
  "audio/uemclip": { source: "iana" },
  "audio/ulpfec": { source: "iana" },
  "audio/usac": { source: "iana" },
  "audio/vdvi": { source: "iana" },
  "audio/vmr-wb": { source: "iana" },
  "audio/vnd.3gpp.iufp": { source: "iana" },
  "audio/vnd.4sb": { source: "iana" },
  "audio/vnd.audiokoz": { source: "iana" },
  "audio/vnd.celp": { source: "iana" },
  "audio/vnd.cisco.nse": { source: "iana" },
  "audio/vnd.cmles.radio-events": { source: "iana" },
  "audio/vnd.cns.anp1": { source: "iana" },
  "audio/vnd.cns.inf1": { source: "iana" },
  "audio/vnd.dece.audio": { source: "iana", extensions: ["uva", "uvva"] },
  "audio/vnd.digital-winds": { source: "iana", extensions: ["eol"] },
  "audio/vnd.dlna.adts": { source: "iana" },
  "audio/vnd.dolby.heaac.1": { source: "iana" },
  "audio/vnd.dolby.heaac.2": { source: "iana" },
  "audio/vnd.dolby.mlp": { source: "iana" },
  "audio/vnd.dolby.mps": { source: "iana" },
  "audio/vnd.dolby.pl2": { source: "iana" },
  "audio/vnd.dolby.pl2x": { source: "iana" },
  "audio/vnd.dolby.pl2z": { source: "iana" },
  "audio/vnd.dolby.pulse.1": { source: "iana" },
  "audio/vnd.dra": { source: "iana", extensions: ["dra"] },
  "audio/vnd.dts": { source: "iana", extensions: ["dts"] },
  "audio/vnd.dts.hd": { source: "iana", extensions: ["dtshd"] },
  "audio/vnd.dts.uhd": { source: "iana" },
  "audio/vnd.dvb.file": { source: "iana" },
  "audio/vnd.everad.plj": { source: "iana" },
  "audio/vnd.hns.audio": { source: "iana" },
  "audio/vnd.lucent.voice": { source: "iana", extensions: ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { source: "iana", extensions: ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { source: "iana" },
  "audio/vnd.nortel.vbk": { source: "iana" },
  "audio/vnd.nuera.ecelp4800": { source: "iana", extensions: ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { source: "iana", extensions: ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { source: "iana", extensions: ["ecelp9600"] },
  "audio/vnd.octel.sbc": { source: "iana" },
  "audio/vnd.presonus.multitrack": { source: "iana" },
  "audio/vnd.qcelp": { source: "iana" },
  "audio/vnd.rhetorex.32kadpcm": { source: "iana" },
  "audio/vnd.rip": { source: "iana", extensions: ["rip"] },
  "audio/vnd.rn-realaudio": { compressible: !1 },
  "audio/vnd.sealedmedia.softseal.mpeg": { source: "iana" },
  "audio/vnd.vmx.cvsd": { source: "iana" },
  "audio/vnd.wave": { compressible: !1 },
  "audio/vorbis": { source: "iana", compressible: !1 },
  "audio/vorbis-config": { source: "iana" },
  "audio/wav": { compressible: !1, extensions: ["wav"] },
  "audio/wave": { compressible: !1, extensions: ["wav"] },
  "audio/webm": { source: "apache", compressible: !1, extensions: ["weba"] },
  "audio/x-aac": { source: "apache", compressible: !1, extensions: ["aac"] },
  "audio/x-aiff": { source: "apache", extensions: ["aif", "aiff", "aifc"] },
  "audio/x-caf": { source: "apache", compressible: !1, extensions: ["caf"] },
  "audio/x-flac": { source: "apache", extensions: ["flac"] },
  "audio/x-m4a": { source: "nginx", extensions: ["m4a"] },
  "audio/x-matroska": { source: "apache", extensions: ["mka"] },
  "audio/x-mpegurl": { source: "apache", extensions: ["m3u"] },
  "audio/x-ms-wax": { source: "apache", extensions: ["wax"] },
  "audio/x-ms-wma": { source: "apache", extensions: ["wma"] },
  "audio/x-pn-realaudio": { source: "apache", extensions: ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { source: "apache", extensions: ["rmp"] },
  "audio/x-realaudio": { source: "nginx", extensions: ["ra"] },
  "audio/x-tta": { source: "apache" },
  "audio/x-wav": { source: "apache", extensions: ["wav"] },
  "audio/xm": { source: "apache", extensions: ["xm"] },
  "chemical/x-cdx": { source: "apache", extensions: ["cdx"] },
  "chemical/x-cif": { source: "apache", extensions: ["cif"] },
  "chemical/x-cmdf": { source: "apache", extensions: ["cmdf"] },
  "chemical/x-cml": { source: "apache", extensions: ["cml"] },
  "chemical/x-csml": { source: "apache", extensions: ["csml"] },
  "chemical/x-pdb": { source: "apache" },
  "chemical/x-xyz": { source: "apache", extensions: ["xyz"] },
  "font/collection": { source: "iana", extensions: ["ttc"] },
  "font/otf": { source: "iana", compressible: !0, extensions: ["otf"] },
  "font/sfnt": { source: "iana" },
  "font/ttf": { source: "iana", compressible: !0, extensions: ["ttf"] },
  "font/woff": { source: "iana", extensions: ["woff"] },
  "font/woff2": { source: "iana", extensions: ["woff2"] },
  "image/aces": { source: "iana", extensions: ["exr"] },
  "image/apng": { compressible: !1, extensions: ["apng"] },
  "image/avci": { source: "iana", extensions: ["avci"] },
  "image/avcs": { source: "iana", extensions: ["avcs"] },
  "image/avif": { source: "iana", compressible: !1, extensions: ["avif"] },
  "image/bmp": { source: "iana", compressible: !0, extensions: ["bmp"] },
  "image/cgm": { source: "iana", extensions: ["cgm"] },
  "image/dicom-rle": { source: "iana", extensions: ["drle"] },
  "image/emf": { source: "iana", extensions: ["emf"] },
  "image/fits": { source: "iana", extensions: ["fits"] },
  "image/g3fax": { source: "iana", extensions: ["g3"] },
  "image/gif": { source: "iana", compressible: !1, extensions: ["gif"] },
  "image/heic": { source: "iana", extensions: ["heic"] },
  "image/heic-sequence": { source: "iana", extensions: ["heics"] },
  "image/heif": { source: "iana", extensions: ["heif"] },
  "image/heif-sequence": { source: "iana", extensions: ["heifs"] },
  "image/hej2k": { source: "iana", extensions: ["hej2"] },
  "image/hsj2": { source: "iana", extensions: ["hsj2"] },
  "image/ief": { source: "iana", extensions: ["ief"] },
  "image/jls": { source: "iana", extensions: ["jls"] },
  "image/jp2": {
    source: "iana",
    compressible: !1,
    extensions: ["jp2", "jpg2"],
  },
  "image/jpeg": {
    source: "iana",
    compressible: !1,
    extensions: ["jpeg", "jpg", "jpe"],
  },
  "image/jph": { source: "iana", extensions: ["jph"] },
  "image/jphc": { source: "iana", extensions: ["jhc"] },
  "image/jpm": { source: "iana", compressible: !1, extensions: ["jpm"] },
  "image/jpx": { source: "iana", compressible: !1, extensions: ["jpx", "jpf"] },
  "image/jxr": { source: "iana", extensions: ["jxr"] },
  "image/jxra": { source: "iana", extensions: ["jxra"] },
  "image/jxrs": { source: "iana", extensions: ["jxrs"] },
  "image/jxs": { source: "iana", extensions: ["jxs"] },
  "image/jxsc": { source: "iana", extensions: ["jxsc"] },
  "image/jxsi": { source: "iana", extensions: ["jxsi"] },
  "image/jxss": { source: "iana", extensions: ["jxss"] },
  "image/ktx": { source: "iana", extensions: ["ktx"] },
  "image/ktx2": { source: "iana", extensions: ["ktx2"] },
  "image/naplps": { source: "iana" },
  "image/pjpeg": { compressible: !1 },
  "image/png": { source: "iana", compressible: !1, extensions: ["png"] },
  "image/prs.btif": { source: "iana", extensions: ["btif"] },
  "image/prs.pti": { source: "iana", extensions: ["pti"] },
  "image/pwg-raster": { source: "iana" },
  "image/sgi": { source: "apache", extensions: ["sgi"] },
  "image/svg+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["svg", "svgz"],
  },
  "image/t38": { source: "iana", extensions: ["t38"] },
  "image/tiff": {
    source: "iana",
    compressible: !1,
    extensions: ["tif", "tiff"],
  },
  "image/tiff-fx": { source: "iana", extensions: ["tfx"] },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: !0,
    extensions: ["psd"],
  },
  "image/vnd.airzip.accelerator.azv": { source: "iana", extensions: ["azv"] },
  "image/vnd.cns.inf2": { source: "iana" },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: ["uvi", "uvvi", "uvg", "uvvg"],
  },
  "image/vnd.djvu": { source: "iana", extensions: ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
  "image/vnd.dwg": { source: "iana", extensions: ["dwg"] },
  "image/vnd.dxf": { source: "iana", extensions: ["dxf"] },
  "image/vnd.fastbidsheet": { source: "iana", extensions: ["fbs"] },
  "image/vnd.fpx": { source: "iana", extensions: ["fpx"] },
  "image/vnd.fst": { source: "iana", extensions: ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { source: "iana", extensions: ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { source: "iana", extensions: ["rlc"] },
  "image/vnd.globalgraphics.pgb": { source: "iana" },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: !0,
    extensions: ["ico"],
  },
  "image/vnd.mix": { source: "iana" },
  "image/vnd.mozilla.apng": { source: "iana" },
  "image/vnd.ms-dds": { compressible: !0, extensions: ["dds"] },
  "image/vnd.ms-modi": { source: "iana", extensions: ["mdi"] },
  "image/vnd.ms-photo": { source: "apache", extensions: ["wdp"] },
  "image/vnd.net-fpx": { source: "iana", extensions: ["npx"] },
  "image/vnd.pco.b16": { source: "iana", extensions: ["b16"] },
  "image/vnd.radiance": { source: "iana" },
  "image/vnd.sealed.png": { source: "iana" },
  "image/vnd.sealedmedia.softseal.gif": { source: "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { source: "iana" },
  "image/vnd.svf": { source: "iana" },
  "image/vnd.tencent.tap": { source: "iana", extensions: ["tap"] },
  "image/vnd.valve.source.texture": { source: "iana", extensions: ["vtf"] },
  "image/vnd.wap.wbmp": { source: "iana", extensions: ["wbmp"] },
  "image/vnd.xiff": { source: "iana", extensions: ["xif"] },
  "image/vnd.zbrush.pcx": { source: "iana", extensions: ["pcx"] },
  "image/webp": { source: "apache", extensions: ["webp"] },
  "image/wmf": { source: "iana", extensions: ["wmf"] },
  "image/x-3ds": { source: "apache", extensions: ["3ds"] },
  "image/x-cmu-raster": { source: "apache", extensions: ["ras"] },
  "image/x-cmx": { source: "apache", extensions: ["cmx"] },
  "image/x-freehand": {
    source: "apache",
    extensions: ["fh", "fhc", "fh4", "fh5", "fh7"],
  },
  "image/x-icon": { source: "apache", compressible: !0, extensions: ["ico"] },
  "image/x-jng": { source: "nginx", extensions: ["jng"] },
  "image/x-mrsid-image": { source: "apache", extensions: ["sid"] },
  "image/x-ms-bmp": { source: "nginx", compressible: !0, extensions: ["bmp"] },
  "image/x-pcx": { source: "apache", extensions: ["pcx"] },
  "image/x-pict": { source: "apache", extensions: ["pic", "pct"] },
  "image/x-portable-anymap": { source: "apache", extensions: ["pnm"] },
  "image/x-portable-bitmap": { source: "apache", extensions: ["pbm"] },
  "image/x-portable-graymap": { source: "apache", extensions: ["pgm"] },
  "image/x-portable-pixmap": { source: "apache", extensions: ["ppm"] },
  "image/x-rgb": { source: "apache", extensions: ["rgb"] },
  "image/x-tga": { source: "apache", extensions: ["tga"] },
  "image/x-xbitmap": { source: "apache", extensions: ["xbm"] },
  "image/x-xcf": { compressible: !1 },
  "image/x-xpixmap": { source: "apache", extensions: ["xpm"] },
  "image/x-xwindowdump": { source: "apache", extensions: ["xwd"] },
  "message/cpim": { source: "iana" },
  "message/delivery-status": { source: "iana" },
  "message/disposition-notification": {
    source: "iana",
    extensions: ["disposition-notification"],
  },
  "message/external-body": { source: "iana" },
  "message/feedback-report": { source: "iana" },
  "message/global": { source: "iana", extensions: ["u8msg"] },
  "message/global-delivery-status": { source: "iana", extensions: ["u8dsn"] },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: ["u8mdn"],
  },
  "message/global-headers": { source: "iana", extensions: ["u8hdr"] },
  "message/http": { source: "iana", compressible: !1 },
  "message/imdn+xml": { source: "iana", compressible: !0 },
  "message/news": { source: "iana" },
  "message/partial": { source: "iana", compressible: !1 },
  "message/rfc822": {
    source: "iana",
    compressible: !0,
    extensions: ["eml", "mime"],
  },
  "message/s-http": { source: "iana" },
  "message/sip": { source: "iana" },
  "message/sipfrag": { source: "iana" },
  "message/tracking-status": { source: "iana" },
  "message/vnd.si.simp": { source: "iana" },
  "message/vnd.wfa.wsc": { source: "iana", extensions: ["wsc"] },
  "model/3mf": { source: "iana", extensions: ["3mf"] },
  "model/e57": { source: "iana" },
  "model/gltf+json": { source: "iana", compressible: !0, extensions: ["gltf"] },
  "model/gltf-binary": {
    source: "iana",
    compressible: !0,
    extensions: ["glb"],
  },
  "model/iges": {
    source: "iana",
    compressible: !1,
    extensions: ["igs", "iges"],
  },
  "model/mesh": {
    source: "iana",
    compressible: !1,
    extensions: ["msh", "mesh", "silo"],
  },
  "model/mtl": { source: "iana", extensions: ["mtl"] },
  "model/obj": { source: "iana", extensions: ["obj"] },
  "model/step": { source: "iana" },
  "model/step+xml": { source: "iana", compressible: !0, extensions: ["stpx"] },
  "model/step+zip": { source: "iana", compressible: !1, extensions: ["stpz"] },
  "model/step-xml+zip": {
    source: "iana",
    compressible: !1,
    extensions: ["stpxz"],
  },
  "model/stl": { source: "iana", extensions: ["stl"] },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["dae"],
  },
  "model/vnd.dwf": { source: "iana", extensions: ["dwf"] },
  "model/vnd.flatland.3dml": { source: "iana" },
  "model/vnd.gdl": { source: "iana", extensions: ["gdl"] },
  "model/vnd.gs-gdl": { source: "apache" },
  "model/vnd.gs.gdl": { source: "iana" },
  "model/vnd.gtw": { source: "iana", extensions: ["gtw"] },
  "model/vnd.moml+xml": { source: "iana", compressible: !0 },
  "model/vnd.mts": { source: "iana", extensions: ["mts"] },
  "model/vnd.opengex": { source: "iana", extensions: ["ogex"] },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: ["x_b"],
  },
  "model/vnd.parasolid.transmit.text": { source: "iana", extensions: ["x_t"] },
  "model/vnd.pytha.pyox": { source: "iana" },
  "model/vnd.rosette.annotated-data-model": { source: "iana" },
  "model/vnd.sap.vds": { source: "iana", extensions: ["vds"] },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: !1,
    extensions: ["usdz"],
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: ["bsp"],
  },
  "model/vnd.vtu": { source: "iana", extensions: ["vtu"] },
  "model/vrml": {
    source: "iana",
    compressible: !1,
    extensions: ["wrl", "vrml"],
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: !1,
    extensions: ["x3db", "x3dbz"],
  },
  "model/x3d+fastinfoset": { source: "iana", extensions: ["x3db"] },
  "model/x3d+vrml": {
    source: "apache",
    compressible: !1,
    extensions: ["x3dv", "x3dvz"],
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["x3d", "x3dz"],
  },
  "model/x3d-vrml": { source: "iana", extensions: ["x3dv"] },
  "multipart/alternative": { source: "iana", compressible: !1 },
  "multipart/appledouble": { source: "iana" },
  "multipart/byteranges": { source: "iana" },
  "multipart/digest": { source: "iana" },
  "multipart/encrypted": { source: "iana", compressible: !1 },
  "multipart/form-data": { source: "iana", compressible: !1 },
  "multipart/header-set": { source: "iana" },
  "multipart/mixed": { source: "iana" },
  "multipart/multilingual": { source: "iana" },
  "multipart/parallel": { source: "iana" },
  "multipart/related": { source: "iana", compressible: !1 },
  "multipart/report": { source: "iana" },
  "multipart/signed": { source: "iana", compressible: !1 },
  "multipart/vnd.bint.med-plus": { source: "iana" },
  "multipart/voice-message": { source: "iana" },
  "multipart/x-mixed-replace": { source: "iana" },
  "text/1d-interleaved-parityfec": { source: "iana" },
  "text/cache-manifest": {
    source: "iana",
    compressible: !0,
    extensions: ["appcache", "manifest"],
  },
  "text/calendar": { source: "iana", extensions: ["ics", "ifb"] },
  "text/calender": { compressible: !0 },
  "text/cmd": { compressible: !0 },
  "text/coffeescript": { extensions: ["coffee", "litcoffee"] },
  "text/cql": { source: "iana" },
  "text/cql-expression": { source: "iana" },
  "text/cql-identifier": { source: "iana" },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["css"],
  },
  "text/csv": { source: "iana", compressible: !0, extensions: ["csv"] },
  "text/csv-schema": { source: "iana" },
  "text/directory": { source: "iana" },
  "text/dns": { source: "iana" },
  "text/ecmascript": { source: "iana" },
  "text/encaprtp": { source: "iana" },
  "text/enriched": { source: "iana" },
  "text/fhirpath": { source: "iana" },
  "text/flexfec": { source: "iana" },
  "text/fwdred": { source: "iana" },
  "text/gff3": { source: "iana" },
  "text/grammar-ref-list": { source: "iana" },
  "text/html": {
    source: "iana",
    compressible: !0,
    extensions: ["html", "htm", "shtml"],
  },
  "text/jade": { extensions: ["jade"] },
  "text/javascript": { source: "iana", compressible: !0 },
  "text/jcr-cnd": { source: "iana" },
  "text/jsx": { compressible: !0, extensions: ["jsx"] },
  "text/less": { compressible: !0, extensions: ["less"] },
  "text/markdown": {
    source: "iana",
    compressible: !0,
    extensions: ["markdown", "md"],
  },
  "text/mathml": { source: "nginx", extensions: ["mml"] },
  "text/mdx": { compressible: !0, extensions: ["mdx"] },
  "text/mizar": { source: "iana" },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["n3"],
  },
  "text/parameters": { source: "iana", charset: "UTF-8" },
  "text/parityfec": { source: "iana" },
  "text/plain": {
    source: "iana",
    compressible: !0,
    extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
  },
  "text/provenance-notation": { source: "iana", charset: "UTF-8" },
  "text/prs.fallenstein.rst": { source: "iana" },
  "text/prs.lines.tag": { source: "iana", extensions: ["dsc"] },
  "text/prs.prop.logic": { source: "iana" },
  "text/raptorfec": { source: "iana" },
  "text/red": { source: "iana" },
  "text/rfc822-headers": { source: "iana" },
  "text/richtext": { source: "iana", compressible: !0, extensions: ["rtx"] },
  "text/rtf": { source: "iana", compressible: !0, extensions: ["rtf"] },
  "text/rtp-enc-aescm128": { source: "iana" },
  "text/rtploopback": { source: "iana" },
  "text/rtx": { source: "iana" },
  "text/sgml": { source: "iana", extensions: ["sgml", "sgm"] },
  "text/shaclc": { source: "iana" },
  "text/shex": { source: "iana", extensions: ["shex"] },
  "text/slim": { extensions: ["slim", "slm"] },
  "text/spdx": { source: "iana", extensions: ["spdx"] },
  "text/strings": { source: "iana" },
  "text/stylus": { extensions: ["stylus", "styl"] },
  "text/t140": { source: "iana" },
  "text/tab-separated-values": {
    source: "iana",
    compressible: !0,
    extensions: ["tsv"],
  },
  "text/troff": {
    source: "iana",
    extensions: ["t", "tr", "roff", "man", "me", "ms"],
  },
  "text/turtle": { source: "iana", charset: "UTF-8", extensions: ["ttl"] },
  "text/ulpfec": { source: "iana" },
  "text/uri-list": {
    source: "iana",
    compressible: !0,
    extensions: ["uri", "uris", "urls"],
  },
  "text/vcard": { source: "iana", compressible: !0, extensions: ["vcard"] },
  "text/vnd.a": { source: "iana" },
  "text/vnd.abc": { source: "iana" },
  "text/vnd.ascii-art": { source: "iana" },
  "text/vnd.curl": { source: "iana", extensions: ["curl"] },
  "text/vnd.curl.dcurl": { source: "apache", extensions: ["dcurl"] },
  "text/vnd.curl.mcurl": { source: "apache", extensions: ["mcurl"] },
  "text/vnd.curl.scurl": { source: "apache", extensions: ["scurl"] },
  "text/vnd.debian.copyright": { source: "iana", charset: "UTF-8" },
  "text/vnd.dmclientscript": { source: "iana" },
  "text/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { source: "iana", charset: "UTF-8" },
  "text/vnd.familysearch.gedcom": { source: "iana", extensions: ["ged"] },
  "text/vnd.ficlab.flt": { source: "iana" },
  "text/vnd.fly": { source: "iana", extensions: ["fly"] },
  "text/vnd.fmi.flexstor": { source: "iana", extensions: ["flx"] },
  "text/vnd.gml": { source: "iana" },
  "text/vnd.graphviz": { source: "iana", extensions: ["gv"] },
  "text/vnd.hans": { source: "iana" },
  "text/vnd.hgl": { source: "iana" },
  "text/vnd.in3d.3dml": { source: "iana", extensions: ["3dml"] },
  "text/vnd.in3d.spot": { source: "iana", extensions: ["spot"] },
  "text/vnd.iptc.newsml": { source: "iana" },
  "text/vnd.iptc.nitf": { source: "iana" },
  "text/vnd.latex-z": { source: "iana" },
  "text/vnd.motorola.reflex": { source: "iana" },
  "text/vnd.ms-mediapackage": { source: "iana" },
  "text/vnd.net2phone.commcenter.command": { source: "iana" },
  "text/vnd.radisys.msml-basic-layout": { source: "iana" },
  "text/vnd.senx.warpscript": { source: "iana" },
  "text/vnd.si.uricatalogue": { source: "iana" },
  "text/vnd.sosi": { source: "iana" },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["jad"],
  },
  "text/vnd.trolltech.linguist": { source: "iana", charset: "UTF-8" },
  "text/vnd.wap.si": { source: "iana" },
  "text/vnd.wap.sl": { source: "iana" },
  "text/vnd.wap.wml": { source: "iana", extensions: ["wml"] },
  "text/vnd.wap.wmlscript": { source: "iana", extensions: ["wmls"] },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["vtt"],
  },
  "text/x-asm": { source: "apache", extensions: ["s", "asm"] },
  "text/x-c": {
    source: "apache",
    extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
  },
  "text/x-component": { source: "nginx", extensions: ["htc"] },
  "text/x-fortran": {
    source: "apache",
    extensions: ["f", "for", "f77", "f90"],
  },
  "text/x-gwt-rpc": { compressible: !0 },
  "text/x-handlebars-template": { extensions: ["hbs"] },
  "text/x-java-source": { source: "apache", extensions: ["java"] },
  "text/x-jquery-tmpl": { compressible: !0 },
  "text/x-lua": { extensions: ["lua"] },
  "text/x-markdown": { compressible: !0, extensions: ["mkd"] },
  "text/x-nfo": { source: "apache", extensions: ["nfo"] },
  "text/x-opml": { source: "apache", extensions: ["opml"] },
  "text/x-org": { compressible: !0, extensions: ["org"] },
  "text/x-pascal": { source: "apache", extensions: ["p", "pas"] },
  "text/x-processing": { compressible: !0, extensions: ["pde"] },
  "text/x-sass": { extensions: ["sass"] },
  "text/x-scss": { extensions: ["scss"] },
  "text/x-setext": { source: "apache", extensions: ["etx"] },
  "text/x-sfv": { source: "apache", extensions: ["sfv"] },
  "text/x-suse-ymp": { compressible: !0, extensions: ["ymp"] },
  "text/x-uuencode": { source: "apache", extensions: ["uu"] },
  "text/x-vcalendar": { source: "apache", extensions: ["vcs"] },
  "text/x-vcard": { source: "apache", extensions: ["vcf"] },
  "text/xml": { source: "iana", compressible: !0, extensions: ["xml"] },
  "text/xml-external-parsed-entity": { source: "iana" },
  "text/yaml": { compressible: !0, extensions: ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { source: "iana" },
  "video/3gpp": { source: "iana", extensions: ["3gp", "3gpp"] },
  "video/3gpp-tt": { source: "iana" },
  "video/3gpp2": { source: "iana", extensions: ["3g2"] },
  "video/av1": { source: "iana" },
  "video/bmpeg": { source: "iana" },
  "video/bt656": { source: "iana" },
  "video/celb": { source: "iana" },
  "video/dv": { source: "iana" },
  "video/encaprtp": { source: "iana" },
  "video/ffv1": { source: "iana" },
  "video/flexfec": { source: "iana" },
  "video/h261": { source: "iana", extensions: ["h261"] },
  "video/h263": { source: "iana", extensions: ["h263"] },
  "video/h263-1998": { source: "iana" },
  "video/h263-2000": { source: "iana" },
  "video/h264": { source: "iana", extensions: ["h264"] },
  "video/h264-rcdo": { source: "iana" },
  "video/h264-svc": { source: "iana" },
  "video/h265": { source: "iana" },
  "video/iso.segment": { source: "iana", extensions: ["m4s"] },
  "video/jpeg": { source: "iana", extensions: ["jpgv"] },
  "video/jpeg2000": { source: "iana" },
  "video/jpm": { source: "apache", extensions: ["jpm", "jpgm"] },
  "video/jxsv": { source: "iana" },
  "video/mj2": { source: "iana", extensions: ["mj2", "mjp2"] },
  "video/mp1s": { source: "iana" },
  "video/mp2p": { source: "iana" },
  "video/mp2t": { source: "iana", extensions: ["ts"] },
  "video/mp4": {
    source: "iana",
    compressible: !1,
    extensions: ["mp4", "mp4v", "mpg4"],
  },
  "video/mp4v-es": { source: "iana" },
  "video/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"],
  },
  "video/mpeg4-generic": { source: "iana" },
  "video/mpv": { source: "iana" },
  "video/nv": { source: "iana" },
  "video/ogg": { source: "iana", compressible: !1, extensions: ["ogv"] },
  "video/parityfec": { source: "iana" },
  "video/pointer": { source: "iana" },
  "video/quicktime": {
    source: "iana",
    compressible: !1,
    extensions: ["qt", "mov"],
  },
  "video/raptorfec": { source: "iana" },
  "video/raw": { source: "iana" },
  "video/rtp-enc-aescm128": { source: "iana" },
  "video/rtploopback": { source: "iana" },
  "video/rtx": { source: "iana" },
  "video/scip": { source: "iana" },
  "video/smpte291": { source: "iana" },
  "video/smpte292m": { source: "iana" },
  "video/ulpfec": { source: "iana" },
  "video/vc1": { source: "iana" },
  "video/vc2": { source: "iana" },
  "video/vnd.cctv": { source: "iana" },
  "video/vnd.dece.hd": { source: "iana", extensions: ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { source: "iana", extensions: ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { source: "iana" },
  "video/vnd.dece.pd": { source: "iana", extensions: ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { source: "iana", extensions: ["uvs", "uvvs"] },
  "video/vnd.dece.video": { source: "iana", extensions: ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { source: "iana" },
  "video/vnd.directv.mpeg-tts": { source: "iana" },
  "video/vnd.dlna.mpeg-tts": { source: "iana" },
  "video/vnd.dvb.file": { source: "iana", extensions: ["dvb"] },
  "video/vnd.fvt": { source: "iana", extensions: ["fvt"] },
  "video/vnd.hns.video": { source: "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { source: "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { source: "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { source: "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { source: "iana" },
  "video/vnd.iptvforum.ttsavc": { source: "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { source: "iana" },
  "video/vnd.motorola.video": { source: "iana" },
  "video/vnd.motorola.videop": { source: "iana" },
  "video/vnd.mpegurl": { source: "iana", extensions: ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { source: "iana", extensions: ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { source: "iana" },
  "video/vnd.nokia.mp4vr": { source: "iana" },
  "video/vnd.nokia.videovoip": { source: "iana" },
  "video/vnd.objectvideo": { source: "iana" },
  "video/vnd.radgamettools.bink": { source: "iana" },
  "video/vnd.radgamettools.smacker": { source: "iana" },
  "video/vnd.sealed.mpeg1": { source: "iana" },
  "video/vnd.sealed.mpeg4": { source: "iana" },
  "video/vnd.sealed.swf": { source: "iana" },
  "video/vnd.sealedmedia.softseal.mov": { source: "iana" },
  "video/vnd.uvvu.mp4": { source: "iana", extensions: ["uvu", "uvvu"] },
  "video/vnd.vivo": { source: "iana", extensions: ["viv"] },
  "video/vnd.youtube.yt": { source: "iana" },
  "video/vp8": { source: "iana" },
  "video/vp9": { source: "iana" },
  "video/webm": { source: "apache", compressible: !1, extensions: ["webm"] },
  "video/x-f4v": { source: "apache", extensions: ["f4v"] },
  "video/x-fli": { source: "apache", extensions: ["fli"] },
  "video/x-flv": { source: "apache", compressible: !1, extensions: ["flv"] },
  "video/x-m4v": { source: "apache", extensions: ["m4v"] },
  "video/x-matroska": {
    source: "apache",
    compressible: !1,
    extensions: ["mkv", "mk3d", "mks"],
  },
  "video/x-mng": { source: "apache", extensions: ["mng"] },
  "video/x-ms-asf": { source: "apache", extensions: ["asf", "asx"] },
  "video/x-ms-vob": { source: "apache", extensions: ["vob"] },
  "video/x-ms-wm": { source: "apache", extensions: ["wm"] },
  "video/x-ms-wmv": { source: "apache", compressible: !1, extensions: ["wmv"] },
  "video/x-ms-wmx": { source: "apache", extensions: ["wmx"] },
  "video/x-ms-wvx": { source: "apache", extensions: ["wvx"] },
  "video/x-msvideo": { source: "apache", extensions: ["avi"] },
  "video/x-sgi-movie": { source: "apache", extensions: ["movie"] },
  "video/x-smv": { source: "apache", extensions: ["smv"] },
  "x-conference/x-cooltalk": { source: "apache", extensions: ["ice"] },
  "x-shader/x-fragment": { compressible: !0 },
  "x-shader/x-vertex": { compressible: !0 },
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (k) {
  k.exports = require$$0;
})(mimeDb);
const __viteBrowserExternal = {},
  __viteBrowserExternal$1 = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: __viteBrowserExternal },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  require$$1 = getAugmentedNamespace(__viteBrowserExternal$1);
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (k) {
  var r = mimeDbExports,
    p = require$$1.extname,
    v = /^\s*([^;\s]*)(?:;|\s|$)/,
    $ = /^text\//i;
  (k.charset = S),
    (k.charsets = { lookup: S }),
    (k.contentType = x),
    (k.extension = I),
    (k.extensions = Object.create(null)),
    (k.lookup = F),
    (k.types = Object.create(null)),
    O(k.extensions, k.types);
  function S(L) {
    if (!L || typeof L != "string") return !1;
    var U = v.exec(L),
      j = U && r[U[1].toLowerCase()];
    return j && j.charset ? j.charset : U && $.test(U[1]) ? "UTF-8" : !1;
  }
  function x(L) {
    if (!L || typeof L != "string") return !1;
    var U = L.indexOf("/") === -1 ? k.lookup(L) : L;
    if (!U) return !1;
    if (U.indexOf("charset") === -1) {
      var j = k.charset(U);
      j && (U += "; charset=" + j.toLowerCase());
    }
    return U;
  }
  function I(L) {
    if (!L || typeof L != "string") return !1;
    var U = v.exec(L),
      j = U && k.extensions[U[1].toLowerCase()];
    return !j || !j.length ? !1 : j[0];
  }
  function F(L) {
    if (!L || typeof L != "string") return !1;
    var U = p("x." + L)
      .toLowerCase()
      .substr(1);
    return (U && k.types[U]) || !1;
  }
  function O(L, U) {
    var j = ["nginx", "apache", void 0, "iana"];
    Object.keys(r).forEach(function (q) {
      var R = r[q],
        Q = R.extensions;
      if (!(!Q || !Q.length)) {
        L[q] = Q;
        for (var H = 0; H < Q.length; H++) {
          var G = Q[H];
          if (U[G]) {
            var V = j.indexOf(r[U[G]].source),
              K = j.indexOf(R.source);
            if (
              U[G] !== "application/octet-stream" &&
              (V > K || (V === K && U[G].substr(0, 12) === "application/"))
            )
              continue;
          }
          U[G] = q;
        }
      }
    });
  }
})(mimeTypes);
const icon = "./assets/upload-62f3bdf6.svg",
  UploadFileButton_svelte_svelte_type_style_lang = "";
function create_fragment$2Y(k) {
  let r, p, v, $, S;
  return {
    c() {
      (r = element("input")),
        (p = space()),
        (v = element("button")),
        (v.textContent = "upload"),
        attr(r, "type", "file"),
        attr(r, "name", "file"),
        (r.multiple = !0),
        attr(r, "class", "svelte-nn3gqf"),
        attr(v, "class", "material-icons-round"),
        attr(v, "title", "Upload file");
    },
    m(x, I) {
      insert(x, r, I),
        k[2](r),
        insert(x, p, I),
        insert(x, v, I),
        $ ||
          ((S = [listen(r, "change", k[1]), listen(v, "click", k[3])]),
          ($ = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r),
        k[2](null),
        x && detach(p),
        x && detach(v),
        ($ = !1),
        run_all(S);
    },
  };
}
function instance$2P(k, r, p) {
  let v;
  component_subscribe(k, FileBrowserCurrentDir, (O) => p(4, (v = O)));
  let $;
  async function S() {
    const O = $.files;
    if (O.length > 80)
      return createOverlayableError(
        {
          title: "Too many files",
          message:
            "You are only allowed to upload 80 files at a time to prevent overloading.",
          buttons: [{ caption: "Understood", action() {} }],
          image: icon,
        },
        "FileManager"
      );
    showOverlay("uploadingFile", "FileManager");
    let L = 50;
    for (let U = 0; U < O.length; U++) (L += 25), O[U] && (await x(O[U]));
    setTimeout(() => {
      hideOverlay("uploadingFile", "FileManager"), fbClass.refresh();
    }, L + 500);
  }
  async function x(O) {
    const L = new Blob([new Uint8Array(await O.arrayBuffer())]),
      U = `${v}/${O.name}`.split("//").join("/"),
      j = {
        name: O.name,
        path: U,
        data: await O.arrayBuffer(),
        mime: "ArcOS Uploadable",
      };
    FileBrowserUploadFile.set(j),
      (await writeFile(U, L)) ||
        makeNotification({
          title: "File upload failed",
          message:
            "The server could not parse the file or it could not be written to the ArcFS",
          buttons: [],
          image: icon,
        });
  }
  function I(O) {
    binding_callbacks[O ? "unshift" : "push"](() => {
      ($ = O), p(0, $);
    });
  }
  return [$, S, I, () => $.click()];
}
class UploadFileButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2P, create_fragment$2Y, safe_not_equal, {});
  }
}
function create_fragment$2X(k) {
  let r, p, v, $, S, x;
  return {
    c() {
      (r = element("div")),
        (p = element("button")),
        (p.textContent = "format_list_bulleted"),
        (v = space()),
        ($ = element("button")),
        ($.textContent = "grid_view"),
        attr(p, "class", "material-icons-round"),
        attr(p, "title", "List view"),
        toggle_class(p, "selected", !k[0].tiled),
        attr($, "class", "material-icons-round"),
        attr($, "title", "Tile view"),
        toggle_class($, "selected", k[0].tiled),
        attr(r, "class", "group");
    },
    m(I, F) {
      insert(I, r, F),
        append(r, p),
        append(r, v),
        append(r, $),
        S ||
          ((x = [listen(p, "click", k[1](!1)), listen($, "click", k[1](!0))]),
          (S = !0));
    },
    p(I, [F]) {
      F & 1 && toggle_class(p, "selected", !I[0].tiled),
        F & 1 && toggle_class($, "selected", I[0].tiled);
    },
    i: noop$1,
    o: noop$1,
    d(I) {
      I && detach(r), (S = !1), run_all(x);
    },
  };
}
function instance$2O(k, r, p) {
  let v;
  component_subscribe(k, UserData, (I) => p(3, (v = I)));
  let { appdata: $ } = r,
    { app: S } = r;
  function x(I) {
    return () => {
      p(0, ($.tiled = I), $),
        set_store_value(UserData, (v.appdata[S.id] = $), v);
    };
  }
  return (
    (k.$$set = (I) => {
      "appdata" in I && p(0, ($ = I.appdata)), "app" in I && p(2, (S = I.app));
    }),
    [$, x, S]
  );
}
class Views extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2O, create_fragment$2X, safe_not_equal, {
        appdata: 0,
        app: 2,
      });
  }
}
function create_fragment$2W(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L,
    U,
    j,
    N,
    q,
    R,
    Q,
    H,
    G,
    V,
    K,
    Y,
    J,
    Z,
    X,
    ee,
    te,
    re,
    fe,
    le,
    se;
  (p = new ParentDir({})),
    ($ = new PathCrumbs({})),
    (F = new CutButton({})),
    (L = new CopyButton({})),
    (j = new PasteButton({})),
    (Q = new DeleteButton({})),
    (G = new RenameButton({})),
    (Y = new NewFolderButton({})),
    (Z = new CreateButton$1({})),
    (ee = new UploadFileButton({}));
  function ae(ne) {
    k[2](ne);
  }
  function oe(ne) {
    k[3](ne);
  }
  let ie = {};
  return (
    k[0] !== void 0 && (ie.appdata = k[0]),
    k[1] !== void 0 && (ie.app = k[1]),
    (re = new Views({ props: ie })),
    binding_callbacks.push(() => bind$1(re, "appdata", ae)),
    binding_callbacks.push(() => bind$1(re, "app", oe)),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          create_component($.$$.fragment),
          (S = space()),
          (x = element("div")),
          (I = element("div")),
          create_component(F.$$.fragment),
          (O = space()),
          create_component(L.$$.fragment),
          (U = space()),
          create_component(j.$$.fragment),
          (N = space()),
          (q = element("div")),
          (R = space()),
          create_component(Q.$$.fragment),
          (H = space()),
          create_component(G.$$.fragment),
          (V = space()),
          (K = element("div")),
          create_component(Y.$$.fragment),
          (J = space()),
          create_component(Z.$$.fragment),
          (X = space()),
          create_component(ee.$$.fragment),
          (te = space()),
          create_component(re.$$.fragment),
          attr(q, "class", "sep"),
          attr(I, "class", "group"),
          attr(K, "class", "group"),
          attr(x, "class", "right"),
          attr(r, "class", "topbar");
      },
      m(ne, ce) {
        insert(ne, r, ce),
          mount_component(p, r, null),
          append(r, v),
          mount_component($, r, null),
          append(r, S),
          append(r, x),
          append(x, I),
          mount_component(F, I, null),
          append(I, O),
          mount_component(L, I, null),
          append(I, U),
          mount_component(j, I, null),
          append(I, N),
          append(I, q),
          append(I, R),
          mount_component(Q, I, null),
          append(I, H),
          mount_component(G, I, null),
          append(x, V),
          append(x, K),
          mount_component(Y, K, null),
          append(K, J),
          mount_component(Z, K, null),
          append(K, X),
          mount_component(ee, K, null),
          append(x, te),
          mount_component(re, x, null),
          (se = !0);
      },
      p(ne, [ce]) {
        const ue = {};
        !fe &&
          ce & 1 &&
          ((fe = !0),
          (ue.appdata = ne[0]),
          add_flush_callback(() => (fe = !1))),
          !le &&
            ce & 2 &&
            ((le = !0), (ue.app = ne[1]), add_flush_callback(() => (le = !1))),
          re.$set(ue);
      },
      i(ne) {
        se ||
          (transition_in(p.$$.fragment, ne),
          transition_in($.$$.fragment, ne),
          transition_in(F.$$.fragment, ne),
          transition_in(L.$$.fragment, ne),
          transition_in(j.$$.fragment, ne),
          transition_in(Q.$$.fragment, ne),
          transition_in(G.$$.fragment, ne),
          transition_in(Y.$$.fragment, ne),
          transition_in(Z.$$.fragment, ne),
          transition_in(ee.$$.fragment, ne),
          transition_in(re.$$.fragment, ne),
          (se = !0));
      },
      o(ne) {
        transition_out(p.$$.fragment, ne),
          transition_out($.$$.fragment, ne),
          transition_out(F.$$.fragment, ne),
          transition_out(L.$$.fragment, ne),
          transition_out(j.$$.fragment, ne),
          transition_out(Q.$$.fragment, ne),
          transition_out(G.$$.fragment, ne),
          transition_out(Y.$$.fragment, ne),
          transition_out(Z.$$.fragment, ne),
          transition_out(ee.$$.fragment, ne),
          transition_out(re.$$.fragment, ne),
          (se = !1);
      },
      d(ne) {
        ne && detach(r),
          destroy_component(p),
          destroy_component($),
          destroy_component(F),
          destroy_component(L),
          destroy_component(j),
          destroy_component(Q),
          destroy_component(G),
          destroy_component(Y),
          destroy_component(Z),
          destroy_component(ee),
          destroy_component(re);
      },
    }
  );
}
function instance$2N(k, r, p) {
  let { appdata: v } = r,
    { app: $ } = r;
  function S(I) {
    (v = I), p(0, v);
  }
  function x(I) {
    ($ = I), p(1, $);
  }
  return (
    (k.$$set = (I) => {
      "appdata" in I && p(0, (v = I.appdata)), "app" in I && p(1, ($ = I.app));
    }),
    [v, $, S, x]
  );
}
let TopBar$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2N, create_fragment$2W, safe_not_equal, {
        appdata: 0,
        app: 1,
      });
  }
};
function create_else_block$l(k) {
  let r, p;
  return (
    (r = new ListView({ props: { files: k[2], dirs: k[3] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 4 && (S.files = v[2]), $ & 8 && (S.dirs = v[3]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$16(k) {
  let r, p;
  return (
    (r = new TileView({ props: { files: k[2], dirs: k[3] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 4 && (S.files = v[2]), $ & 8 && (S.dirs = v[3]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$2V(k) {
  let r, p, v, $, S, x, I, F, O;
  function L(R) {
    k[5](R);
  }
  let U = { app: k[1] };
  k[0] !== void 0 && (U.appdata = k[0]),
    (r = new TopBar$1({ props: U })),
    binding_callbacks.push(() => bind$1(r, "appdata", L)),
    ($ = new SideBar$2({}));
  const j = [create_if_block$16, create_else_block$l],
    N = [];
  function q(R, Q) {
    return R[4] ? 0 : 1;
  }
  return (
    (I = q(k)),
    (F = N[I] = j[I](k)),
    {
      c() {
        create_component(r.$$.fragment),
          (v = space()),
          create_component($.$$.fragment),
          (S = space()),
          (x = element("div")),
          F.c(),
          attr(x, "class", "content");
      },
      m(R, Q) {
        mount_component(r, R, Q),
          insert(R, v, Q),
          mount_component($, R, Q),
          insert(R, S, Q),
          insert(R, x, Q),
          N[I].m(x, null),
          (O = !0);
      },
      p(R, [Q]) {
        const H = {};
        Q & 2 && (H.app = R[1]),
          !p &&
            Q & 1 &&
            ((p = !0), (H.appdata = R[0]), add_flush_callback(() => (p = !1))),
          r.$set(H);
        let G = I;
        (I = q(R)),
          I === G
            ? N[I].p(R, Q)
            : (group_outros(),
              transition_out(N[G], 1, 1, () => {
                N[G] = null;
              }),
              check_outros(),
              (F = N[I]),
              F ? F.p(R, Q) : ((F = N[I] = j[I](R)), F.c()),
              transition_in(F, 1),
              F.m(x, null));
      },
      i(R) {
        O ||
          (transition_in(r.$$.fragment, R),
          transition_in($.$$.fragment, R),
          transition_in(F),
          (O = !0));
      },
      o(R) {
        transition_out(r.$$.fragment, R),
          transition_out($.$$.fragment, R),
          transition_out(F),
          (O = !1);
      },
      d(R) {
        destroy_component(r, R),
          R && detach(v),
          destroy_component($, R),
          R && detach(S),
          R && detach(x),
          N[I].d();
      },
    }
  );
}
function instance$2M(k, r, p) {
  let v;
  component_subscribe(k, FileBrowserDirContents, (L) => p(6, (v = L)));
  let $ = [],
    S = [],
    x = !1,
    { app: I } = r,
    { appdata: F } = r;
  UserData.subscribe(() => {
    p(4, (x = F.tiled));
  }),
    onMount(async () => {
      await fbClass.refresh();
      const L = v || defaultDirectory;
      p(2, ($ = L.files)), p(3, (S = L.directories));
    }),
    FileBrowserDirContents.subscribe((L) => {
      p(3, (S = L.directories)), p(2, ($ = L.files));
    });
  function O(L) {
    (F = L), p(0, F);
  }
  return (
    (k.$$set = (L) => {
      "app" in L && p(1, (I = L.app)), "appdata" in L && p(0, (F = L.appdata));
    }),
    [F, I, $, S, x, O]
  );
}
class FileBrowser extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2M, create_fragment$2V, safe_not_equal, {
        app: 1,
        appdata: 0,
      });
  }
}
const SEP_ITEM = { sep: !0 },
  validCallerTags = [
    "button",
    "div",
    "span",
    "p",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
  ];
function composePosition(k, r, p) {
  const v = document.querySelectorAll("div.app > div.desktop")[0];
  if (!v) return;
  const $ = v.offsetWidth,
    S = v.offsetHeight;
  let x = k.clientX,
    I = k.clientY;
  return (
    x + r > $ && (x = $ - r),
    I + p > S && (I = S - p),
    x < 0 && (x = 0),
    I < 0 && (I = 0),
    [x, I]
  );
}
function getCallerScope(k) {
  const r = k.composedPath();
  for (let p = 0; p < r.length; p++) {
    const v = r[p].tagName;
    if (!v) continue;
    const $ = r[p].dataset.caller;
    if (validCallerTags.includes(v.toLowerCase()) && $) return r[p];
  }
  return null;
}
function getContextEntry(k, r) {
  const p = getWindow(k);
  if (!p || !p.contextMenu) return !1;
  const v = Object.entries(p.contextMenu);
  for (let $ = 0; $ < v.length; $++) if (r.includes(v[$][0])) return v[$][1];
  return !1;
}
const FileManagerContextMenu = {
    "listitem-dir": [
      {
        icon: "launch",
        caption: "Open",
        action: (k, r) => {
          const p = r.path;
          p && fbClass.goToDirectory(p);
        },
      },
      {
        icon: "drive_file_rename_outline",
        caption: "Rename",
        action: (k, r) => {
          FileBrowserSelectedFilename.set(r.name),
            showOverlay("renameItem", "FileManager");
        },
      },
      {
        icon: "content_copy",
        caption: "Copy",
        action: (k, r) => {
          FileBrowserSelectedFilename.set(r.name),
            FileBrowserCopyingFilename.set({
              name: r.name,
              scopedPath: `${r.path}`,
            });
        },
      },
      {
        icon: "content_cut",
        caption: "Cut",
        action: (k, r) => {
          FileBrowserSelectedFilename.set(r.name),
            FileBrowserCuttingFilename.set({
              name: r.name,
              scopedPath: `${r.path}`,
            });
        },
      },
    ],
    "listitem-file": [
      {
        caption: "Delete",
        action: (k, r) => {
          createOverlayableError(
            {
              title: "Delete item?",
              message: `Are you sure you want to permanently delete ${r.name}?`,
              buttons: [
                {
                  caption: "Delete",
                  action: async () => {
                    fbClass.deleteItem(r.name, r.path);
                  },
                },
                { caption: "Cancel", action() {} },
              ],
              image: clear$1,
            },
            "FileManager"
          );
        },
      },
    ],
  },
  mutator = "";
function create_fragment$2U(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H, G;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (x = element("div")),
        (I = element("p")),
        (I.textContent = "Enter a name for the new file:"),
        (F = space()),
        (O = element("input")),
        (L = space()),
        (U = element("div")),
        (j = element("div")),
        (N = element("button")),
        (q = text("Create")),
        (R = space()),
        (Q = element("button")),
        (Q.textContent = "Cancel"),
        src_url_equal(v.src, ($ = k[1] || fileIcon)) || attr(v, "src", $),
        attr(v, "alt", ""),
        attr(p, "class", "image"),
        attr(O, "type", "text"),
        (N.disabled = k[2]),
        attr(j, "class", "inner"),
        attr(U, "class", "actions"),
        attr(r, "class", "fb-overlay-mutator-wrapper");
    },
    m(V, K) {
      insert(V, r, K),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, x),
        append(x, I),
        append(x, F),
        append(x, O),
        set_input_value(O, k[0]),
        append(x, L),
        append(x, U),
        append(U, j),
        append(j, N),
        append(N, q),
        append(j, R),
        append(j, Q),
        H ||
          ((G = [
            listen(O, "input", k[6]),
            listen(O, "input", k[3]),
            listen(N, "click", k[4]),
            listen(Q, "click", k[5]),
          ]),
          (H = !0));
    },
    p(V, [K]) {
      K & 2 &&
        !src_url_equal(v.src, ($ = V[1] || fileIcon)) &&
        attr(v, "src", $),
        K & 1 && O.value !== V[0] && set_input_value(O, V[0]),
        K & 4 && (N.disabled = V[2]);
    },
    i: noop$1,
    o: noop$1,
    d(V) {
      V && detach(r), (H = !1), run_all(G);
    },
  };
}
function instance$2L(k, r, p) {
  let v, $;
  component_subscribe(k, FileBrowserCurrentDir, (j) => p(7, (v = j))),
    component_subscribe(k, FileBrowserDirContents, (j) => p(8, ($ = j)));
  let S = "",
    x = "",
    I = !1;
  function F() {
    const j = $.directories,
      N = $.files;
    for (let q = 0; q < j.length; q++)
      if (j[q].name == S) return p(2, (I = !0));
    for (let q = 0; q < N.length; q++)
      if (N[q].filename == S) return p(2, (I = !0));
    p(2, (I = !1)), p(1, (x = getMimeIcon(S) || fileIcon));
  }
  async function O() {
    await writeFile(`${v}/${S}`, new Blob([])),
      FileBrowserSelectedFilename.set(S),
      L(),
      fbClass.refresh();
  }
  function L() {
    hideOverlay("createFile", "FileManager"), p(0, (S = ""));
  }
  function U() {
    (S = this.value), p(0, S);
  }
  return [S, x, I, F, O, L, U];
}
class CreateFile extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2L, create_fragment$2U, safe_not_equal, {});
  }
}
function create_fragment$2T(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H, G;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (x = element("div")),
        (I = element("p")),
        (I.textContent = "Enter a name for the new folder:"),
        (F = space()),
        (O = element("input")),
        (L = space()),
        (U = element("div")),
        (j = element("div")),
        (N = element("button")),
        (q = text("Create")),
        (R = space()),
        (Q = element("button")),
        (Q.textContent = "Cancel"),
        src_url_equal(v.src, ($ = folder)) || attr(v, "src", $),
        attr(v, "alt", ""),
        attr(p, "class", "image"),
        attr(O, "type", "text"),
        (N.disabled = k[1]),
        attr(j, "class", "inner"),
        attr(U, "class", "actions"),
        attr(r, "class", "fb-overlay-mutator-wrapper");
    },
    m(V, K) {
      insert(V, r, K),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, x),
        append(x, I),
        append(x, F),
        append(x, O),
        set_input_value(O, k[0]),
        append(x, L),
        append(x, U),
        append(U, j),
        append(j, N),
        append(N, q),
        append(j, R),
        append(j, Q),
        H ||
          ((G = [
            listen(O, "input", k[5]),
            listen(O, "input", k[2]),
            listen(N, "click", k[3]),
            listen(Q, "click", k[4]),
          ]),
          (H = !0));
    },
    p(V, [K]) {
      K & 1 && O.value !== V[0] && set_input_value(O, V[0]),
        K & 2 && (N.disabled = V[1]);
    },
    i: noop$1,
    o: noop$1,
    d(V) {
      V && detach(r), (H = !1), run_all(G);
    },
  };
}
function instance$2K(k, r, p) {
  let v, $;
  component_subscribe(k, FileBrowserCurrentDir, (U) => p(6, (v = U))),
    component_subscribe(k, FileBrowserDirContents, (U) => p(7, ($ = U)));
  let S = "",
    x = !1;
  function I() {
    const U = $.directories,
      j = $.files;
    for (let N = 0; N < U.length; N++)
      if (U[N].name == S) return p(1, (x = !0));
    for (let N = 0; N < j.length; N++)
      if (j[N].filename == S) return p(1, (x = !0));
    p(1, (x = !1));
  }
  async function F() {
    await createDirectory(`${v}/${S}`),
      FileBrowserSelectedFilename.set(S),
      O(),
      fbClass.refresh();
  }
  function O() {
    hideOverlay("createFolder", "FileManager"), p(0, (S = ""));
  }
  function L() {
    (S = this.value), p(0, S);
  }
  return [S, x, I, F, O, L];
}
class CreateFolder extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2K, create_fragment$2T, safe_not_equal, {});
  }
}
const deletingfile = "";
function create_fragment$2S(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N;
  return (
    (j = new Spinner({ props: { height: 30 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          (v = element("img")),
          (S = space()),
          (x = element("div")),
          (I = text("Deleting ")),
          (F = text(k[0])),
          (O = text("...")),
          (L = space()),
          (U = element("div")),
          create_component(j.$$.fragment),
          src_url_equal(v.src, ($ = clear$1)) || attr(v, "src", $),
          attr(v, "alt", ""),
          attr(p, "class", "icon"),
          attr(x, "class", "caption"),
          attr(U, "class", "spin"),
          attr(r, "class", "deletingfile-wrapper");
      },
      m(q, R) {
        insert(q, r, R),
          append(r, p),
          append(p, v),
          append(r, S),
          append(r, x),
          append(x, I),
          append(x, F),
          append(x, O),
          append(r, L),
          append(r, U),
          mount_component(j, U, null),
          (N = !0);
      },
      p(q, [R]) {
        (!N || R & 1) && set_data(F, q[0]);
      },
      i(q) {
        N || (transition_in(j.$$.fragment, q), (N = !0));
      },
      o(q) {
        transition_out(j.$$.fragment, q), (N = !1);
      },
      d(q) {
        q && detach(r), destroy_component(j);
      },
    }
  );
}
function instance$2J(k, r, p) {
  let v;
  return (
    component_subscribe(k, FileBrowserDeletingFilename, ($) => p(0, (v = $))),
    [v]
  );
}
class DeletingItem extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2J, create_fragment$2S, safe_not_equal, {});
  }
}
const openingfile = "";
function create_if_block$15(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F = k[0].filename + "",
    O,
    L,
    U,
    j,
    N,
    q,
    R,
    Q,
    H,
    G,
    V,
    K = k[0].filename + "",
    Y,
    J,
    Z,
    X,
    ee,
    te,
    re = k[0].scopedPath + "",
    fe,
    le,
    se,
    ae,
    oe,
    ie,
    ne = k[0].mime + "",
    ce,
    ue,
    me,
    pe,
    de,
    ge,
    Ae = formatBytes(k[0].size) + "",
    $e,
    ke;
  return (
    (N = new Spinner({ props: { height: 30 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          (v = element("img")),
          (S = space()),
          (x = element("div")),
          (I = text("Loading file ")),
          (O = text(F)),
          (L = text("...")),
          (U = space()),
          (j = element("div")),
          create_component(N.$$.fragment),
          (q = space()),
          (R = element("table")),
          (Q = element("tr")),
          (H = element("td")),
          (H.textContent = "Name"),
          (G = space()),
          (V = element("td")),
          (Y = text(K)),
          (J = space()),
          (Z = element("tr")),
          (X = element("td")),
          (X.textContent = "Path"),
          (ee = space()),
          (te = element("td")),
          (fe = text(re)),
          (le = space()),
          (se = element("tr")),
          (ae = element("td")),
          (ae.textContent = "Mimetype"),
          (oe = space()),
          (ie = element("td")),
          (ce = text(ne)),
          (ue = space()),
          (me = element("tr")),
          (pe = element("td")),
          (pe.textContent = "Size"),
          (de = space()),
          (ge = element("td")),
          ($e = text(Ae)),
          src_url_equal(v.src, ($ = logo$6)) || attr(v, "src", $),
          attr(v, "alt", ""),
          attr(p, "class", "icon"),
          attr(x, "class", "caption"),
          attr(j, "class", "spin"),
          attr(r, "class", "openingfile-wrapper"),
          attr(H, "class", "key"),
          attr(X, "class", "key"),
          attr(ae, "class", "key"),
          attr(pe, "class", "key"),
          attr(R, "class", "openfile-details");
      },
      m(ve, be) {
        insert(ve, r, be),
          append(r, p),
          append(p, v),
          append(r, S),
          append(r, x),
          append(x, I),
          append(x, O),
          append(x, L),
          append(r, U),
          append(r, j),
          mount_component(N, j, null),
          insert(ve, q, be),
          insert(ve, R, be),
          append(R, Q),
          append(Q, H),
          append(Q, G),
          append(Q, V),
          append(V, Y),
          append(R, J),
          append(R, Z),
          append(Z, X),
          append(Z, ee),
          append(Z, te),
          append(te, fe),
          append(R, le),
          append(R, se),
          append(se, ae),
          append(se, oe),
          append(se, ie),
          append(ie, ce),
          append(R, ue),
          append(R, me),
          append(me, pe),
          append(me, de),
          append(me, ge),
          append(ge, $e),
          (ke = !0);
      },
      p(ve, be) {
        (!ke || be & 1) && F !== (F = ve[0].filename + "") && set_data(O, F),
          (!ke || be & 1) && K !== (K = ve[0].filename + "") && set_data(Y, K),
          (!ke || be & 1) &&
            re !== (re = ve[0].scopedPath + "") &&
            set_data(fe, re),
          (!ke || be & 1) && ne !== (ne = ve[0].mime + "") && set_data(ce, ne),
          (!ke || be & 1) &&
            Ae !== (Ae = formatBytes(ve[0].size) + "") &&
            set_data($e, Ae);
      },
      i(ve) {
        ke || (transition_in(N.$$.fragment, ve), (ke = !0));
      },
      o(ve) {
        transition_out(N.$$.fragment, ve), (ke = !1);
      },
      d(ve) {
        ve && detach(r), destroy_component(N), ve && detach(q), ve && detach(R);
      },
    }
  );
}
function create_fragment$2R(k) {
  let r,
    p,
    v,
    $,
    S,
    x = k[0] && create_if_block$15(k);
  return {
    c() {
      x && x.c(),
        (r = space()),
        (p = element("button")),
        (p.textContent = "Cancel"),
        attr(p, "class", "cancel");
    },
    m(I, F) {
      x && x.m(I, F),
        insert(I, r, F),
        insert(I, p, F),
        (v = !0),
        $ || ((S = listen(p, "click", k[1])), ($ = !0));
    },
    p(I, [F]) {
      I[0]
        ? x
          ? (x.p(I, F), F & 1 && transition_in(x, 1))
          : ((x = create_if_block$15(I)),
            x.c(),
            transition_in(x, 1),
            x.m(r.parentNode, r))
        : x &&
          (group_outros(),
          transition_out(x, 1, 1, () => {
            x = null;
          }),
          check_outros());
    },
    i(I) {
      v || (transition_in(x), (v = !0));
    },
    o(I) {
      transition_out(x), (v = !1);
    },
    d(I) {
      x && x.d(I), I && detach(r), I && detach(p), ($ = !1), S();
    },
  };
}
function instance$2I(k, r, p) {
  let v;
  component_subscribe(k, FileBrowserOpeningFile, (S) => p(0, (v = S)));
  function $() {
    abortFileReader.set(!0), hideOverlay("openingFile", "FileManager");
  }
  return [v, $];
}
class OpeningFile extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2I, create_fragment$2R, safe_not_equal, {});
  }
}
function create_fragment$2Q(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H, G, V, K, Y, J;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (x = element("div")),
        (I = element("p")),
        (F = text("Enter a new name for ")),
        (O = text(k[4])),
        (L = text(":")),
        (U = space()),
        (j = element("input")),
        (N = space()),
        (q = element("div")),
        (R = element("div")),
        (Q = element("button")),
        (H = text("Rename")),
        (V = space()),
        (K = element("button")),
        (K.textContent = "Cancel"),
        src_url_equal(v.src, ($ = k[2] ? folder : k[1])) || attr(v, "src", $),
        attr(v, "alt", ""),
        attr(p, "class", "image"),
        attr(j, "type", "text"),
        attr(j, "placeholder", k[4]),
        (Q.disabled = G = k[3] || !k[0]),
        attr(R, "class", "inner"),
        attr(q, "class", "actions"),
        attr(r, "class", "fb-overlay-mutator-wrapper");
    },
    m(Z, X) {
      insert(Z, r, X),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, x),
        append(x, I),
        append(I, F),
        append(I, O),
        append(I, L),
        append(x, U),
        append(x, j),
        set_input_value(j, k[0]),
        append(x, N),
        append(x, q),
        append(q, R),
        append(R, Q),
        append(Q, H),
        append(R, V),
        append(R, K),
        Y ||
          ((J = [
            listen(j, "input", k[8]),
            listen(j, "input", k[5]),
            listen(Q, "click", k[6]),
            listen(K, "click", k[7]),
          ]),
          (Y = !0));
    },
    p(Z, [X]) {
      X & 6 &&
        !src_url_equal(v.src, ($ = Z[2] ? folder : Z[1])) &&
        attr(v, "src", $),
        X & 16 && set_data(O, Z[4]),
        X & 16 && attr(j, "placeholder", Z[4]),
        X & 1 && j.value !== Z[0] && set_input_value(j, Z[0]),
        X & 9 && G !== (G = Z[3] || !Z[0]) && (Q.disabled = G);
    },
    i: noop$1,
    o: noop$1,
    d(Z) {
      Z && detach(r), (Y = !1), run_all(J);
    },
  };
}
function instance$2H(k, r, p) {
  let v, $, S;
  component_subscribe(k, FileBrowserCurrentDir, (R) => p(9, (v = R))),
    component_subscribe(k, FileBrowserSelectedFilename, (R) => p(4, ($ = R))),
    component_subscribe(k, FileBrowserDirContents, (R) => p(10, (S = R)));
  let x = "",
    I = "",
    F = !1,
    O = !1;
  function L() {
    const R = S.directories,
      Q = S.files;
    p(2, (F = U()));
    for (let H = 0; H < R.length; H++) R[H].name == v && p(2, (F = !0));
    for (let H = 0; H < Q.length; H++)
      if (Q[H].filename == x) return p(3, (O = !0));
    p(3, (O = !1));
  }
  FileBrowserSelectedFilename.subscribe((R) => {
    R && (p(2, (F = U())), p(1, (I = getMimeIcon(R))));
  });
  function U() {
    const R = S.directories;
    for (let Q = 0; Q < R.length; Q++) if (R[Q].name == $) return !0;
    return !1;
  }
  async function j() {
    await renameItem(`${v}/${$}`, `${v}/${x}`),
      FileBrowserSelectedFilename.set(x),
      N(),
      p(0, (x = "")),
      fbClass.refresh();
  }
  function N() {
    hideOverlay("renameItem", "FileManager");
  }
  function q() {
    (x = this.value), p(0, x);
  }
  return [x, I, F, O, $, L, j, N, q];
}
class RenameItem extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2H, create_fragment$2Q, safe_not_equal, {});
  }
}
const uploadingfile = "";
function create_if_block$14(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F = k[0].name + "",
    O,
    L,
    U,
    j,
    N,
    q,
    R,
    Q,
    H = k[1].toFixed(0) + "",
    G,
    V,
    K,
    Y,
    J,
    Z,
    X,
    ee,
    te = k[0].path + "",
    re,
    fe,
    le,
    se,
    ae,
    oe,
    ie = k[0].mime + "",
    ne,
    ce,
    ue,
    me,
    pe,
    de;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (x = element("div")),
        (I = text("Uploading ")),
        (O = text(F)),
        (L = text("...")),
        (U = space()),
        (j = element("div")),
        (N = element("div")),
        (q = element("div")),
        (R = space()),
        (Q = element("div")),
        (G = text(H)),
        (V = text("%")),
        (K = space()),
        (Y = element("table")),
        (J = element("tr")),
        (Z = element("td")),
        (Z.textContent = "Path"),
        (X = space()),
        (ee = element("td")),
        (re = text(te)),
        (fe = space()),
        (le = element("tr")),
        (se = element("td")),
        (se.textContent = "Type"),
        (ae = space()),
        (oe = element("td")),
        (ne = text(ie)),
        (ce = space()),
        (ue = element("tr")),
        (me = element("td")),
        (me.textContent = "Target"),
        (pe = space()),
        (de = element("td")),
        (de.textContent = `${localStorage.getItem("arcos-server")}`),
        src_url_equal(v.src, ($ = icon)) || attr(v, "src", $),
        attr(v, "alt", ""),
        attr(p, "class", "icon"),
        attr(x, "class", "caption"),
        attr(r, "class", "uploadingfile-wrapper"),
        attr(q, "class", "inner"),
        set_style(q, "width", Math.floor(k[1]) + "%"),
        attr(N, "class", "progress"),
        attr(Q, "class", "percentage"),
        attr(j, "class", "progress-wrapper"),
        attr(Z, "class", "key"),
        attr(se, "class", "key"),
        attr(me, "class", "key"),
        attr(Y, "class", "openfile-details");
    },
    m(ge, Ae) {
      insert(ge, r, Ae),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, x),
        append(x, I),
        append(x, O),
        append(x, L),
        insert(ge, U, Ae),
        insert(ge, j, Ae),
        append(j, N),
        append(N, q),
        append(j, R),
        append(j, Q),
        append(Q, G),
        append(Q, V),
        insert(ge, K, Ae),
        insert(ge, Y, Ae),
        append(Y, J),
        append(J, Z),
        append(J, X),
        append(J, ee),
        append(ee, re),
        append(Y, fe),
        append(Y, le),
        append(le, se),
        append(le, ae),
        append(le, oe),
        append(oe, ne),
        append(Y, ce),
        append(Y, ue),
        append(ue, me),
        append(ue, pe),
        append(ue, de);
    },
    p(ge, Ae) {
      Ae & 1 && F !== (F = ge[0].name + "") && set_data(O, F),
        Ae & 2 && set_style(q, "width", Math.floor(ge[1]) + "%"),
        Ae & 2 && H !== (H = ge[1].toFixed(0) + "") && set_data(G, H),
        Ae & 1 && te !== (te = ge[0].path + "") && set_data(re, te),
        Ae & 1 && ie !== (ie = ge[0].mime + "") && set_data(ne, ie);
    },
    d(ge) {
      ge && detach(r),
        ge && detach(U),
        ge && detach(j),
        ge && detach(K),
        ge && detach(Y);
    },
  };
}
function create_fragment$2P(k) {
  let r,
    p = k[0] && create_if_block$14(k);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, $) {
      p && p.m(v, $), insert(v, r, $);
    },
    p(v, [$]) {
      v[0]
        ? p
          ? p.p(v, $)
          : ((p = create_if_block$14(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$2G(k, r, p) {
  let v, $;
  return (
    component_subscribe(k, FileBrowserUploadFile, (S) => p(0, (v = S))),
    component_subscribe(k, FileBrowserUploadProgress, (S) => p(1, ($ = S))),
    [v, $]
  );
}
class UploadingFile extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2G, create_fragment$2P, safe_not_equal, {});
  }
}
const fbOverlays = {
    openingFile: {
      info: { name: "Opening File", version: "1.0.0", author: "ArcOS Team" },
      content: OpeningFile,
      size: { w: 430, h: 165 },
      show: !1,
    },
    deletingItem: {
      info: { name: "Deleting Item", version: "1.0.0", author: "ArcOS Team" },
      content: DeletingItem,
      size: { w: 430, h: 75 },
      show: !1,
    },
    createFolder: {
      info: { name: "Create Folder", version: "1.0.0", author: "ArcOS Team" },
      content: CreateFolder,
      size: { w: 350, h: 115 },
      show: !1,
    },
    createFile: {
      info: { name: "Create File", version: "1.0.0", author: "ArcOS Team" },
      content: CreateFile,
      size: { w: 350, h: 115 },
      show: !1,
    },
    uploadingFile: {
      info: { name: "Uploading File", version: "1.0.0", author: "ArcOS Team" },
      content: UploadingFile,
      size: { w: 430, h: 175 },
      show: !1,
    },
    renameItem: {
      info: { name: "Rename Item", version: "1.0.0", author: "ArcOS Team" },
      content: RenameItem,
      size: { w: 350, h: 115 },
      show: !1,
    },
  },
  FileBrowserApp = {
    info: {
      name: "File Manager",
      description: "Browse your files",
      builtin: !0,
      version: "2.5.1",
      author: "ArcOS Team",
      icon: logo$6,
    },
    size: { w: 700, h: 450 },
    pos: { x: 30, y: 40 },
    minSize: { w: 700, h: 450 },
    maxSize: { w: 1e3, h: 600 },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: FileBrowser,
    glass: !0,
    overlays: fbOverlays,
    contextMenu: FileManagerContextMenu,
  },
  logo$5 = "./assets/imageviewer-5b7c750b.svg",
  imageviewer = "";
function create_if_block$13(k) {
  let r, p, v;
  return {
    c() {
      (r = element("img")),
        src_url_equal(r.src, (p = k[1])) || attr(r, "src", p),
        attr(r, "alt", (v = k[0].openedFile.name));
    },
    m($, S) {
      insert($, r, S);
    },
    p($, S) {
      S & 2 && !src_url_equal(r.src, (p = $[1])) && attr(r, "src", p),
        S & 1 && v !== (v = $[0].openedFile.name) && attr(r, "alt", v);
    },
    d($) {
      $ && detach(r);
    },
  };
}
function create_fragment$2O(k) {
  let r,
    p = k[0].openedFile && k[1] && create_if_block$13(k);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, $) {
      p && p.m(v, $), insert(v, r, $);
    },
    p(v, [$]) {
      v[0].openedFile && v[1]
        ? p
          ? p.p(v, $)
          : ((p = create_if_block$13(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$2F(k, r, p) {
  let { app: v } = r,
    $ = "";
  return (
    WindowStore.subscribe(() => {
      if (!v.openedFile) return p(1, ($ = ""));
      const S = new Blob([new Uint8Array(v.openedFile.data)], {
        type: v.openedFile.mime,
      });
      p(1, ($ = URL.createObjectURL(S)));
    }),
    (k.$$set = (S) => {
      "app" in S && p(0, (v = S.app));
    }),
    [v, $]
  );
}
class ImageView extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2F, create_fragment$2O, safe_not_equal, {
        app: 0,
      });
  }
}
const textview = "",
  chooseTargets = writable({});
function setTargetFile(k, r) {
  const p = get_store_value(chooseTargets),
    v = p[k],
    $ = get_store_value(WindowStore);
  let S = null;
  for (let x = 0; x < $.length; x++) $[x].id == v && (S = x);
  return S == null
    ? !1
    : (($[S].openedFile = r),
      $[S].events && $[S].events.openFile && $[S].events.openFile($[S]),
      delete $[S].overlays[k],
      WindowStore.set($),
      delete p[k],
      chooseTargets.set(p),
      !0);
}
function getChooserTarget(k) {
  return get_store_value(chooseTargets)[k] || !1;
}
function assignTarget(k, r) {
  const p = get_store_value(chooseTargets);
  return p[k] ? !1 : ((p[k] = r), chooseTargets.set(p), !0);
}
function create_fragment$2N(k) {
  let r, p, v, $, S, x, I, F, O;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("button")),
        (v.textContent = "Cancel"),
        ($ = space()),
        (S = element("button")),
        (x = text("Open")),
        attr(v, "class", "cancel"),
        attr(S, "class", "confirm"),
        (S.disabled = I = !k[5] || !k[4]),
        attr(p, "class", "buttons"),
        attr(r, "class", "bottompane");
    },
    m(L, U) {
      insert(L, r, U),
        append(r, p),
        append(p, v),
        append(p, $),
        append(p, S),
        append(S, x),
        F ||
          ((O = [listen(v, "click", k[7]), listen(S, "click", k[6])]),
          (F = !0));
    },
    p(L, [U]) {
      U & 48 && I !== (I = !L[5] || !L[4]) && (S.disabled = I);
    },
    i: noop$1,
    o: noop$1,
    d(L) {
      L && detach(r), (F = !1), run_all(O);
    },
  };
}
function instance$2E(k, r, p) {
  let v,
    $ = noop$1,
    S = () => ($(), ($ = subscribe(G, (J) => p(9, (v = J)))), G),
    x,
    I = noop$1,
    F = () => (I(), (I = subscribe(R, (J) => p(10, (x = J)))), R),
    O,
    L = noop$1,
    U = () => (L(), (L = subscribe(H, (J) => p(4, (O = J)))), H),
    j,
    N = noop$1,
    q = () => (N(), (N = subscribe(Q, (J) => p(5, (j = J)))), Q);
  k.$$.on_destroy.push(() => $()),
    k.$$.on_destroy.push(() => I()),
    k.$$.on_destroy.push(() => L()),
    k.$$.on_destroy.push(() => N());
  let { currentDir: R } = r;
  F();
  let { currentPath: Q } = r;
  q();
  let { selected: H } = r;
  U();
  let { processing: G } = r;
  S();
  let { overlay: V } = r;
  async function K() {
    set_store_value(G, (v = !0), v);
    let J;
    for (let X = 0; X < x.files.length; X++)
      x.files[X].filename == O && (J = x.files[X]);
    const Z = {
      name: J.filename,
      path: J.scopedPath,
      data: await readFile(J.scopedPath),
      mime: J.mime,
    };
    hideOverlay(V.id, getChooserTarget(V.id)),
      setTargetFile(V.id, Z),
      set_store_value(G, (v = !1), v);
  }
  function Y() {
    const J = getChooserTarget(V.id),
      Z = getWindow(J);
    hideOverlay(V.id, J), setTargetFile(V.id, Z.openedFile);
  }
  return (
    (k.$$set = (J) => {
      "currentDir" in J && F(p(0, (R = J.currentDir))),
        "currentPath" in J && q(p(1, (Q = J.currentPath))),
        "selected" in J && U(p(2, (H = J.selected))),
        "processing" in J && S(p(3, (G = J.processing))),
        "overlay" in J && p(8, (V = J.overlay));
    }),
    [R, Q, H, G, O, j, K, Y, V]
  );
}
let BottomPane$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2E, create_fragment$2N, safe_not_equal, {
        currentDir: 0,
        currentPath: 1,
        selected: 2,
        processing: 3,
        overlay: 8,
      });
  }
};
function create_fragment$2M(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F = k[0].name + "",
    O,
    L,
    U,
    j,
    N,
    q,
    R;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (I = element("div")),
        (O = text(F)),
        (L = space()),
        (U = element("div")),
        (U.textContent = "Folder"),
        (j = space()),
        (N = element("div")),
        (N.textContent = "-"),
        src_url_equal(v.src, ($ = folder)) || attr(v, "src", $),
        attr(v, "alt", (S = k[0].name)),
        attr(p, "class", "image"),
        attr(I, "class", "name"),
        attr(U, "class", "mime"),
        attr(N, "class", "size"),
        attr(r, "class", "item dir");
    },
    m(Q, H) {
      insert(Q, r, H),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, I),
        append(I, O),
        append(r, L),
        append(r, U),
        append(r, j),
        append(r, N),
        q || ((R = listen(r, "dblclick", k[3])), (q = !0));
    },
    p(Q, [H]) {
      H & 1 && S !== (S = Q[0].name) && attr(v, "alt", S),
        H & 1 && F !== (F = Q[0].name + "") && set_data(O, F);
    },
    i: noop$1,
    o: noop$1,
    d(Q) {
      Q && detach(r), (q = !1), R();
    },
  };
}
function instance$2D(k, r, p) {
  let { dir: v } = r,
    { setDir: $ } = r,
    { selected: S } = r;
  const x = () => $(v.scopedPath);
  return (
    (k.$$set = (I) => {
      "dir" in I && p(0, (v = I.dir)),
        "setDir" in I && p(1, ($ = I.setDir)),
        "selected" in I && p(2, (S = I.selected));
    }),
    [v, $, S, x]
  );
}
let Dir$2 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2D, create_fragment$2M, safe_not_equal, {
        dir: 0,
        setDir: 1,
        selected: 2,
      });
  }
};
function create_fragment$2L(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F = k[2].filename + "",
    O,
    L,
    U,
    j = k[2].mime.split("; ")[0].split("/").join(" - ") + "",
    N,
    q,
    R,
    Q = formatBytes(k[2].size) + "",
    H,
    G,
    V;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (I = element("div")),
        (O = text(F)),
        (L = space()),
        (U = element("div")),
        (N = text(j)),
        (q = space()),
        (R = element("div")),
        (H = text(Q)),
        src_url_equal(v.src, ($ = k[3])) || attr(v, "src", $),
        attr(v, "alt", (S = k[2].filename)),
        attr(p, "class", "image"),
        attr(I, "class", "name"),
        attr(U, "class", "mime"),
        attr(R, "class", "size"),
        attr(r, "class", "item file"),
        toggle_class(r, "selected", k[4] == k[2].filename);
    },
    m(K, Y) {
      insert(K, r, Y),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, I),
        append(I, O),
        append(r, L),
        append(r, U),
        append(U, N),
        append(r, q),
        append(r, R),
        append(R, H),
        G ||
          ((V = [listen(r, "dblclick", k[5]), listen(r, "click", k[7])]),
          (G = !0));
    },
    p(K, [Y]) {
      Y & 8 && !src_url_equal(v.src, ($ = K[3])) && attr(v, "src", $),
        Y & 4 && S !== (S = K[2].filename) && attr(v, "alt", S),
        Y & 4 && F !== (F = K[2].filename + "") && set_data(O, F),
        Y & 4 &&
          j !== (j = K[2].mime.split("; ")[0].split("/").join(" - ") + "") &&
          set_data(N, j),
        Y & 4 && Q !== (Q = formatBytes(K[2].size) + "") && set_data(H, Q),
        Y & 20 && toggle_class(r, "selected", K[4] == K[2].filename);
    },
    i: noop$1,
    o: noop$1,
    d(K) {
      K && detach(r), (G = !1), run_all(V);
    },
  };
}
function instance$2C(k, r, p) {
  let v,
    $ = noop$1,
    S = () => ($(), ($ = subscribe(U, (Q) => p(8, (v = Q)))), U),
    x,
    I = noop$1,
    F = () => (I(), (I = subscribe(L, (Q) => p(4, (x = Q)))), L);
  k.$$.on_destroy.push(() => $()), k.$$.on_destroy.push(() => I());
  let { overlay: O } = r,
    { selected: L } = r;
  F();
  let { processing: U } = r;
  S();
  let j = "";
  onMount(() => {
    p(3, (j = getMimeIcon(q.filename)));
  });
  async function N() {
    set_store_value(U, (v = !0), v);
    const Q = {
      name: q.filename,
      path: q.scopedPath,
      data: await readFile(q.scopedPath),
      mime: q.mime,
    };
    setTargetFile(O.id, Q), set_store_value(U, (v = !1), v);
  }
  let { file: q } = r;
  const R = () => set_store_value(L, (x = q.filename), x);
  return (
    (k.$$set = (Q) => {
      "overlay" in Q && p(6, (O = Q.overlay)),
        "selected" in Q && F(p(0, (L = Q.selected))),
        "processing" in Q && S(p(1, (U = Q.processing))),
        "file" in Q && p(2, (q = Q.file));
    }),
    [L, U, q, j, x, N, O, R]
  );
}
let File$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2C, create_fragment$2L, safe_not_equal, {
        overlay: 6,
        selected: 0,
        processing: 1,
        file: 2,
      });
  }
};
function getAppPreference(k, r) {
  const p = get_store_value(UserData);
  if (!(!p.appdata || !p.appdata[k])) return p.appdata[k][r];
}
function setAppPreference(k, r, p) {
  const v = get_store_value(UserData);
  return !v.appdata || !v.appdata[k]
    ? !1
    : ((v.appdata[k][r] = p), UserData.set(v), !0);
}
function create_if_block$12(k) {
  let r, p, v, $;
  return {
    c() {
      (r = element("button")), (p = text(k[0])), attr(r, "class", "crumb");
    },
    m(S, x) {
      insert(S, r, x),
        append(r, p),
        v || (($ = listen(r, "click", k[1])), (v = !0));
    },
    p(S, x) {
      x & 1 && set_data(p, S[0]);
    },
    d(S) {
      S && detach(r), (v = !1), $();
    },
  };
}
function create_fragment$2K(k) {
  let r,
    p = k[0] && k[0] != "." && create_if_block$12(k);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, $) {
      p && p.m(v, $), insert(v, r, $);
    },
    p(v, [$]) {
      v[0] && v[0] != "."
        ? p
          ? p.p(v, $)
          : ((p = create_if_block$12(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$2B(k, r, p) {
  let { crumb: v } = r,
    { path: $ } = r,
    { setDir: S } = r;
  function x() {
    S($);
  }
  return (
    (k.$$set = (I) => {
      "crumb" in I && p(0, (v = I.crumb)),
        "path" in I && p(2, ($ = I.path)),
        "setDir" in I && p(3, (S = I.setDir));
    }),
    [v, x, $, S]
  );
}
class Crumb extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2B, create_fragment$2K, safe_not_equal, {
        crumb: 0,
        path: 2,
        setDir: 3,
      });
  }
}
function get_each_context$C(k, r, p) {
  const v = k.slice();
  return (v[10] = r[p]), (v[12] = p), v;
}
function create_each_block$C(k) {
  let r, p;
  return (
    (r = new Crumb({
      props: { crumb: k[10], path: k[6](k[10], k[12]), setDir: k[3] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 16 && (S.crumb = v[10]),
          $ & 16 && (S.path = v[6](v[10], v[12])),
          $ & 8 && (S.setDir = v[3]),
          r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$2J(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L,
    U,
    j,
    N,
    q,
    R,
    Q,
    H,
    G,
    V,
    K,
    Y,
    J = k[4],
    Z = [];
  for (let ee = 0; ee < J.length; ee += 1)
    Z[ee] = create_each_block$C(get_each_context$C(k, J, ee));
  const X = (ee) =>
    transition_out(Z[ee], 1, 1, () => {
      Z[ee] = null;
    });
  return {
    c() {
      (r = element("div")),
        (p = element("button")),
        (v = text("arrow_upward")),
        (S = space()),
        (x = element("button")),
        (x.textContent = "home"),
        (I = space()),
        (F = element("div"));
      for (let ee = 0; ee < Z.length; ee += 1) Z[ee].c();
      (O = space()),
        (L = element("button")),
        (L.textContent = "refresh"),
        (U = space()),
        (j = element("div")),
        (N = element("button")),
        (q = text("format_list_bulleted")),
        (Q = space()),
        (H = element("button")),
        (G = text("grid_view")),
        attr(p, "class", "parentdir material-icons-round"),
        (p.disabled = $ = k[4].length == 2 && k[4][0] == "." && !k[4][1]),
        attr(x, "class", "home material-icons-round"),
        attr(F, "class", "addressbar"),
        attr(L, "class", "refresh material-icons-round"),
        attr(N, "class", "material-icons-round"),
        (N.disabled = R = !k[0]),
        attr(N, "title", "List view"),
        toggle_class(N, "selected", k[0]),
        attr(H, "class", "material-icons-round"),
        (H.disabled = k[0]),
        attr(H, "title", "Tile view"),
        toggle_class(H, "selected", !k[0]),
        attr(j, "class", "group"),
        attr(r, "class", "topbar");
    },
    m(ee, te) {
      insert(ee, r, te),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, x),
        append(r, I),
        append(r, F);
      for (let re = 0; re < Z.length; re += 1) Z[re] && Z[re].m(F, null);
      append(r, O),
        append(r, L),
        append(r, U),
        append(r, j),
        append(j, N),
        append(N, q),
        append(j, Q),
        append(j, H),
        append(H, G),
        (V = !0),
        K ||
          ((Y = [
            listen(p, "click", k[7]),
            listen(x, "click", k[5]),
            listen(L, "click", function () {
              is_function(k[2]) && k[2].apply(this, arguments);
            }),
            listen(N, "click", k[8]),
            listen(H, "click", k[8]),
          ]),
          (K = !0));
    },
    p(ee, [te]) {
      if (
        ((k = ee),
        (!V ||
          (te & 16 &&
            $ !== ($ = k[4].length == 2 && k[4][0] == "." && !k[4][1]))) &&
          (p.disabled = $),
        te & 88)
      ) {
        J = k[4];
        let re;
        for (re = 0; re < J.length; re += 1) {
          const fe = get_each_context$C(k, J, re);
          Z[re]
            ? (Z[re].p(fe, te), transition_in(Z[re], 1))
            : ((Z[re] = create_each_block$C(fe)),
              Z[re].c(),
              transition_in(Z[re], 1),
              Z[re].m(F, null));
        }
        for (group_outros(), re = J.length; re < Z.length; re += 1) X(re);
        check_outros();
      }
      (!V || (te & 1 && R !== (R = !k[0]))) && (N.disabled = R),
        (!V || te & 1) && toggle_class(N, "selected", k[0]),
        (!V || te & 1) && (H.disabled = k[0]),
        (!V || te & 1) && toggle_class(H, "selected", !k[0]);
    },
    i(ee) {
      if (!V) {
        for (let te = 0; te < J.length; te += 1) transition_in(Z[te]);
        V = !0;
      }
    },
    o(ee) {
      Z = Z.filter(Boolean);
      for (let te = 0; te < Z.length; te += 1) transition_out(Z[te]);
      V = !1;
    },
    d(ee) {
      ee && detach(r), destroy_each(Z, ee), (K = !1), run_all(Y);
    },
  };
}
function instance$2A(k, r, p) {
  let v,
    $ = noop$1,
    S = () => ($(), ($ = subscribe(x, (R) => p(9, (v = R)))), x);
  k.$$.on_destroy.push(() => $());
  let { currentPath: x } = r;
  S();
  let { refresh: I } = r,
    { setDir: F } = r,
    O,
    { tiled: L } = r;
  x.subscribe((R) => {
    p(4, (O = R.split("/"))),
      I(),
      p(0, (L = !!getAppPreference("FileManager", "tiled")));
  });
  function U() {
    x.set("./");
  }
  function j(R, Q) {
    let H = "";
    for (let G = 0; G < Q; G++) H += `${O[G]}/`;
    return `${H}${R}`;
  }
  function N() {
    F(getParentDirectory(v));
  }
  function q() {
    p(0, (L = !L)), setAppPreference("FileManager", "tiled", L);
  }
  return (
    UserData.subscribe(() => {
      p(0, (L = !!getAppPreference("FileManager", "tiled")));
    }),
    (k.$$set = (R) => {
      "currentPath" in R && S(p(1, (x = R.currentPath))),
        "refresh" in R && p(2, (I = R.refresh)),
        "setDir" in R && p(3, (F = R.setDir)),
        "tiled" in R && p(0, (L = R.tiled));
    }),
    [L, x, I, F, O, U, j, N, q]
  );
}
class TopBar extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2A, create_fragment$2J, safe_not_equal, {
        currentPath: 1,
        refresh: 2,
        setDir: 3,
        tiled: 0,
      });
  }
}
const chooseroverlay = "";
function create_fragment$2I(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I = k[0].name + "",
    F,
    O,
    L;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (S = space()),
        (x = element("p")),
        (F = text(I)),
        src_url_equal(p.src, (v = folder)) || attr(p, "src", v),
        attr(p, "alt", ($ = k[0].name)),
        attr(x, "class", "caption"),
        attr(r, "class", "tile dir");
    },
    m(U, j) {
      insert(U, r, j),
        append(r, p),
        append(r, S),
        append(r, x),
        append(x, F),
        O || ((L = listen(r, "dblclick", k[1])), (O = !0));
    },
    p(U, [j]) {
      j & 1 && $ !== ($ = U[0].name) && attr(p, "alt", $),
        j & 1 && I !== (I = U[0].name + "") && set_data(F, I);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r), (O = !1), L();
    },
  };
}
function instance$2z(k, r, p) {
  let { dir: v } = r,
    { setDir: $ } = r;
  function S() {
    $(v.scopedPath);
  }
  return (
    (k.$$set = (x) => {
      "dir" in x && p(0, (v = x.dir)), "setDir" in x && p(2, ($ = x.setDir));
    }),
    [v, S, $]
  );
}
let Dir$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2z, create_fragment$2I, safe_not_equal, {
        dir: 0,
        setDir: 2,
      });
  }
};
function create_fragment$2H(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F = k[2].filename + "",
    O,
    L,
    U;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (I = element("p")),
        (O = text(F)),
        src_url_equal(v.src, ($ = k[3])) || attr(v, "src", $),
        attr(v, "alt", (S = k[2].filename)),
        attr(p, "class", "image"),
        attr(I, "class", "name"),
        attr(r, "class", "tile file"),
        toggle_class(r, "selected", k[4] == k[2].filename);
    },
    m(j, N) {
      insert(j, r, N),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, I),
        append(I, O),
        L ||
          ((U = [listen(r, "dblclick", k[5]), listen(r, "click", k[7])]),
          (L = !0));
    },
    p(j, [N]) {
      N & 8 && !src_url_equal(v.src, ($ = j[3])) && attr(v, "src", $),
        N & 4 && S !== (S = j[2].filename) && attr(v, "alt", S),
        N & 4 && F !== (F = j[2].filename + "") && set_data(O, F),
        N & 20 && toggle_class(r, "selected", j[4] == j[2].filename);
    },
    i: noop$1,
    o: noop$1,
    d(j) {
      j && detach(r), (L = !1), run_all(U);
    },
  };
}
function instance$2y(k, r, p) {
  let v,
    $ = noop$1,
    S = () => ($(), ($ = subscribe(U, (Q) => p(8, (v = Q)))), U),
    x,
    I = noop$1,
    F = () => (I(), (I = subscribe(L, (Q) => p(4, (x = Q)))), L);
  k.$$.on_destroy.push(() => $()), k.$$.on_destroy.push(() => I());
  let { overlay: O } = r,
    { selected: L } = r;
  F();
  let { processing: U } = r;
  S();
  let j = "";
  onMount(() => {
    p(3, (j = getMimeIcon(q.filename)));
  });
  async function N() {
    set_store_value(U, (v = !0), v);
    const Q = {
      name: q.filename,
      path: q.scopedPath,
      data: await readFile(q.scopedPath),
      mime: q.mime,
    };
    setTargetFile(O.id, Q), set_store_value(U, (v = !1), v);
  }
  let { file: q } = r;
  const R = () => set_store_value(L, (x = q.filename), x);
  return (
    (k.$$set = (Q) => {
      "overlay" in Q && p(6, (O = Q.overlay)),
        "selected" in Q && F(p(0, (L = Q.selected))),
        "processing" in Q && S(p(1, (U = Q.processing))),
        "file" in Q && p(2, (q = Q.file));
    }),
    [L, U, q, j, x, N, O, R]
  );
}
class File extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2y, create_fragment$2H, safe_not_equal, {
        overlay: 6,
        selected: 0,
        processing: 1,
        file: 2,
      });
  }
}
function get_each_context$B(k, r, p) {
  const v = k.slice();
  return (v[5] = r[p]), v;
}
function get_each_context_1$7(k, r, p) {
  const v = k.slice();
  return (v[8] = r[p]), v;
}
function create_if_block$11(k) {
  let r,
    p,
    v = k[3].directories,
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block_1$7(get_each_context_1$7(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      r = element("div");
      for (let x = 0; x < $.length; x += 1) $[x].c();
      attr(r, "class", "dirs");
    },
    m(x, I) {
      insert(x, r, I);
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(r, null);
      p = !0;
    },
    p(x, I) {
      if (I & 24) {
        v = x[3].directories;
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_1$7(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block_1$7(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      x && detach(r), destroy_each($, x);
    },
  };
}
function create_each_block_1$7(k) {
  let r, p;
  return (
    (r = new Dir$1({ props: { dir: k[8], setDir: k[4] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 8 && (S.dir = v[8]), $ & 16 && (S.setDir = v[4]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$B(k) {
  let r, p;
  return (
    (r = new File({
      props: { file: k[5], overlay: k[0], selected: k[1], processing: k[2] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 8 && (S.file = v[5]),
          $ & 1 && (S.overlay = v[0]),
          $ & 2 && (S.selected = v[1]),
          $ & 4 && (S.processing = v[2]),
          r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$2G(k) {
  let r,
    p,
    v,
    $,
    S = k[3].directories.length && create_if_block$11(k),
    x = k[3].files,
    I = [];
  for (let O = 0; O < x.length; O += 1)
    I[O] = create_each_block$B(get_each_context$B(k, x, O));
  const F = (O) =>
    transition_out(I[O], 1, 1, () => {
      I[O] = null;
    });
  return {
    c() {
      (r = element("div")), S && S.c(), (p = space()), (v = element("div"));
      for (let O = 0; O < I.length; O += 1) I[O].c();
      attr(v, "class", "files"), attr(r, "class", "tiled");
    },
    m(O, L) {
      insert(O, r, L), S && S.m(r, null), append(r, p), append(r, v);
      for (let U = 0; U < I.length; U += 1) I[U] && I[U].m(v, null);
      $ = !0;
    },
    p(O, [L]) {
      if (
        (O[3].directories.length
          ? S
            ? (S.p(O, L), L & 8 && transition_in(S, 1))
            : ((S = create_if_block$11(O)),
              S.c(),
              transition_in(S, 1),
              S.m(r, p))
          : S &&
            (group_outros(),
            transition_out(S, 1, 1, () => {
              S = null;
            }),
            check_outros()),
        L & 15)
      ) {
        x = O[3].files;
        let U;
        for (U = 0; U < x.length; U += 1) {
          const j = get_each_context$B(O, x, U);
          I[U]
            ? (I[U].p(j, L), transition_in(I[U], 1))
            : ((I[U] = create_each_block$B(j)),
              I[U].c(),
              transition_in(I[U], 1),
              I[U].m(v, null));
        }
        for (group_outros(), U = x.length; U < I.length; U += 1) F(U);
        check_outros();
      }
    },
    i(O) {
      if (!$) {
        transition_in(S);
        for (let L = 0; L < x.length; L += 1) transition_in(I[L]);
        $ = !0;
      }
    },
    o(O) {
      transition_out(S), (I = I.filter(Boolean));
      for (let L = 0; L < I.length; L += 1) transition_out(I[L]);
      $ = !1;
    },
    d(O) {
      O && detach(r), S && S.d(), destroy_each(I, O);
    },
  };
}
function instance$2x(k, r, p) {
  let { overlay: v } = r,
    { selected: $ } = r,
    { processing: S } = r,
    { data: x } = r,
    { setDir: I } = r;
  return (
    (k.$$set = (F) => {
      "overlay" in F && p(0, (v = F.overlay)),
        "selected" in F && p(1, ($ = F.selected)),
        "processing" in F && p(2, (S = F.processing)),
        "data" in F && p(3, (x = F.data)),
        "setDir" in F && p(4, (I = F.setDir));
    }),
    [v, $, S, x, I]
  );
}
class Tiled extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2x, create_fragment$2G, safe_not_equal, {
        overlay: 0,
        selected: 1,
        processing: 2,
        data: 3,
        setDir: 4,
      });
  }
}
function create_fragment$2F(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I = k[0].name + "",
    F,
    O,
    L;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (S = space()),
        (x = element("p")),
        (F = text(I)),
        src_url_equal(p.src, (v = folder)) || attr(p, "src", v),
        attr(p, "alt", ($ = k[0].name)),
        attr(x, "class", "caption"),
        attr(r, "class", "link"),
        toggle_class(r, "selected", k[1]);
    },
    m(U, j) {
      insert(U, r, j),
        append(r, p),
        append(r, S),
        append(r, x),
        append(x, F),
        O || ((L = listen(r, "click", k[2])), (O = !0));
    },
    p(U, [j]) {
      j & 1 && $ !== ($ = U[0].name) && attr(p, "alt", $),
        j & 1 && I !== (I = U[0].name + "") && set_data(F, I),
        j & 2 && toggle_class(r, "selected", U[1]);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r), (O = !1), L();
    },
  };
}
function instance$2w(k, r, p) {
  let { folder: v } = r,
    { setDir: $ } = r,
    { currentPath: S } = r,
    x = !1;
  function I() {
    $(v.scopedPath);
  }
  return (
    S.subscribe((F) => {
      p(1, (x = F == v.scopedPath));
    }),
    (k.$$set = (F) => {
      "folder" in F && p(0, (v = F.folder)),
        "setDir" in F && p(3, ($ = F.setDir)),
        "currentPath" in F && p(4, (S = F.currentPath));
    }),
    [v, x, I, $, S]
  );
}
let Link$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2w, create_fragment$2F, safe_not_equal, {
        folder: 0,
        setDir: 3,
        currentPath: 4,
      });
  }
};
function get_each_context$A(k, r, p) {
  const v = k.slice();
  return (v[4] = r[p]), v;
}
function create_each_block$A(k) {
  let r, p;
  return (
    (r = new Link$1({
      props: { setDir: k[1], currentPath: k[0], folder: k[4] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 2 && (S.setDir = v[1]),
          $ & 1 && (S.currentPath = v[0]),
          $ & 4 && (S.folder = v[4]),
          r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$2E(k) {
  let r,
    p,
    v = k[2],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$A(get_each_context$A(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      r = element("div");
      for (let x = 0; x < $.length; x += 1) $[x].c();
      attr(r, "class", "sidebar");
    },
    m(x, I) {
      insert(x, r, I);
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(r, null);
      p = !0;
    },
    p(x, [I]) {
      if (I & 7) {
        v = x[2];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$A(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$A(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      x && detach(r), destroy_each($, x);
    },
  };
}
function instance$2v(k, r, p) {
  let v = [],
    { currentDir: $ } = r,
    { currentPath: S } = r,
    { setDir: x } = r;
  return (
    $.subscribe(async (I) => {
      p(2, (v = (await getDirectory("./")).directories));
    }),
    (k.$$set = (I) => {
      "currentDir" in I && p(3, ($ = I.currentDir)),
        "currentPath" in I && p(0, (S = I.currentPath)),
        "setDir" in I && p(1, (x = I.setDir));
    }),
    [S, x, v, $]
  );
}
let SideBar$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2v, create_fragment$2E, safe_not_equal, {
        currentDir: 3,
        currentPath: 0,
        setDir: 1,
      });
  }
};
function get_each_context$z(k, r, p) {
  const v = k.slice();
  return (v[13] = r[p]), v;
}
function get_each_context_1$6(k, r, p) {
  const v = k.slice();
  return (v[16] = r[p]), v;
}
function create_if_block$10(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j;
  function N(V) {
    k[11](V);
  }
  let q = { currentPath: k[6], refresh: k[10], setDir: k[9] };
  k[1] !== void 0 && (q.tiled = k[1]),
    (r = new TopBar({ props: q })),
    binding_callbacks.push(() => bind$1(r, "tiled", N)),
    (S = new SideBar$1({
      props: { currentDir: k[5], setDir: k[9], currentPath: k[6] },
    }));
  const R = [create_if_block_2$4, create_else_block$k],
    Q = [];
  function H(V, K) {
    return V[1] ? 0 : 1;
  }
  (I = H(k)), (F = Q[I] = R[I](k));
  let G = k[3] && create_if_block_1$j(k);
  return (
    (U = new BottomPane$1({
      props: {
        currentDir: k[5],
        currentPath: k[6],
        selected: k[7],
        overlay: k[0],
        processing: k[8],
      },
    })),
    {
      c() {
        create_component(r.$$.fragment),
          (v = space()),
          ($ = element("div")),
          create_component(S.$$.fragment),
          (x = space()),
          F.c(),
          (O = space()),
          G && G.c(),
          (L = space()),
          create_component(U.$$.fragment),
          attr($, "class", "content");
      },
      m(V, K) {
        mount_component(r, V, K),
          insert(V, v, K),
          insert(V, $, K),
          mount_component(S, $, null),
          append($, x),
          Q[I].m($, null),
          append($, O),
          G && G.m($, null),
          insert(V, L, K),
          mount_component(U, V, K),
          (j = !0);
      },
      p(V, K) {
        const Y = {};
        !p &&
          K & 2 &&
          ((p = !0), (Y.tiled = V[1]), add_flush_callback(() => (p = !1))),
          r.$set(Y);
        let J = I;
        (I = H(V)),
          I === J
            ? Q[I].p(V, K)
            : (group_outros(),
              transition_out(Q[J], 1, 1, () => {
                Q[J] = null;
              }),
              check_outros(),
              (F = Q[I]),
              F ? F.p(V, K) : ((F = Q[I] = R[I](V)), F.c()),
              transition_in(F, 1),
              F.m($, O)),
          V[3]
            ? G
              ? (G.p(V, K), K & 8 && transition_in(G, 1))
              : ((G = create_if_block_1$j(V)),
                G.c(),
                transition_in(G, 1),
                G.m($, null))
            : G &&
              (group_outros(),
              transition_out(G, 1, 1, () => {
                G = null;
              }),
              check_outros());
        const Z = {};
        K & 1 && (Z.overlay = V[0]), U.$set(Z);
      },
      i(V) {
        j ||
          (transition_in(r.$$.fragment, V),
          transition_in(S.$$.fragment, V),
          transition_in(F),
          transition_in(G),
          transition_in(U.$$.fragment, V),
          (j = !0));
      },
      o(V) {
        transition_out(r.$$.fragment, V),
          transition_out(S.$$.fragment, V),
          transition_out(F),
          transition_out(G),
          transition_out(U.$$.fragment, V),
          (j = !1);
      },
      d(V) {
        destroy_component(r, V),
          V && detach(v),
          V && detach($),
          destroy_component(S),
          Q[I].d(),
          G && G.d(),
          V && detach(L),
          destroy_component(U, V);
      },
    }
  );
}
function create_else_block$k(k) {
  let r, p, v, $, S;
  p = new TopRow({});
  let x = k[2].directories,
    I = [];
  for (let j = 0; j < x.length; j += 1)
    I[j] = create_each_block_1$6(get_each_context_1$6(k, x, j));
  const F = (j) =>
    transition_out(I[j], 1, 1, () => {
      I[j] = null;
    });
  let O = k[2].files,
    L = [];
  for (let j = 0; j < O.length; j += 1)
    L[j] = create_each_block$z(get_each_context$z(k, O, j));
  const U = (j) =>
    transition_out(L[j], 1, 1, () => {
      L[j] = null;
    });
  return {
    c() {
      (r = element("div")), create_component(p.$$.fragment), (v = space());
      for (let j = 0; j < I.length; j += 1) I[j].c();
      $ = space();
      for (let j = 0; j < L.length; j += 1) L[j].c();
      attr(r, "class", "list");
    },
    m(j, N) {
      insert(j, r, N), mount_component(p, r, null), append(r, v);
      for (let q = 0; q < I.length; q += 1) I[q] && I[q].m(r, null);
      append(r, $);
      for (let q = 0; q < L.length; q += 1) L[q] && L[q].m(r, null);
      S = !0;
    },
    p(j, N) {
      if (N & 644) {
        x = j[2].directories;
        let q;
        for (q = 0; q < x.length; q += 1) {
          const R = get_each_context_1$6(j, x, q);
          I[q]
            ? (I[q].p(R, N), transition_in(I[q], 1))
            : ((I[q] = create_each_block_1$6(R)),
              I[q].c(),
              transition_in(I[q], 1),
              I[q].m(r, $));
        }
        for (group_outros(), q = x.length; q < I.length; q += 1) F(q);
        check_outros();
      }
      if (N & 389) {
        O = j[2].files;
        let q;
        for (q = 0; q < O.length; q += 1) {
          const R = get_each_context$z(j, O, q);
          L[q]
            ? (L[q].p(R, N), transition_in(L[q], 1))
            : ((L[q] = create_each_block$z(R)),
              L[q].c(),
              transition_in(L[q], 1),
              L[q].m(r, null));
        }
        for (group_outros(), q = O.length; q < L.length; q += 1) U(q);
        check_outros();
      }
    },
    i(j) {
      if (!S) {
        transition_in(p.$$.fragment, j);
        for (let N = 0; N < x.length; N += 1) transition_in(I[N]);
        for (let N = 0; N < O.length; N += 1) transition_in(L[N]);
        S = !0;
      }
    },
    o(j) {
      transition_out(p.$$.fragment, j), (I = I.filter(Boolean));
      for (let N = 0; N < I.length; N += 1) transition_out(I[N]);
      L = L.filter(Boolean);
      for (let N = 0; N < L.length; N += 1) transition_out(L[N]);
      S = !1;
    },
    d(j) {
      j && detach(r),
        destroy_component(p),
        destroy_each(I, j),
        destroy_each(L, j);
    },
  };
}
function create_if_block_2$4(k) {
  let r, p;
  return (
    (r = new Tiled({
      props: {
        data: k[2],
        setDir: k[9],
        overlay: k[0],
        selected: k[7],
        processing: k[8],
      },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 4 && (S.data = v[2]), $ & 1 && (S.overlay = v[0]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block_1$6(k) {
  let r, p;
  return (
    (r = new Dir$2({ props: { setDir: k[9], dir: k[16], selected: k[7] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 4 && (S.dir = v[16]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$z(k) {
  let r, p;
  return (
    (r = new File$1({
      props: { file: k[13], overlay: k[0], selected: k[7], processing: k[8] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 4 && (S.file = v[13]), $ & 1 && (S.overlay = v[0]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_1$j(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N;
  return (
    (j = new Spinner({ props: { height: 30 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          (v = element("div")),
          ($ = element("img")),
          (x = space()),
          (I = element("p")),
          (F = text("Opening ")),
          (O = text(k[4])),
          (L = text("...")),
          (U = space()),
          create_component(j.$$.fragment),
          src_url_equal($.src, (S = icon$2)) || attr($, "src", S),
          attr($, "alt", ""),
          attr(I, "class", "caption"),
          attr(v, "class", "processing"),
          attr(p, "class", "processing-content"),
          attr(r, "class", "processing-overlay");
      },
      m(q, R) {
        insert(q, r, R),
          append(r, p),
          append(p, v),
          append(v, $),
          append(v, x),
          append(v, I),
          append(I, F),
          append(I, O),
          append(I, L),
          append(v, U),
          mount_component(j, v, null),
          (N = !0);
      },
      p(q, R) {
        (!N || R & 16) && set_data(O, q[4]);
      },
      i(q) {
        N || (transition_in(j.$$.fragment, q), (N = !0));
      },
      o(q) {
        transition_out(j.$$.fragment, q), (N = !1);
      },
      d(q) {
        q && detach(r), destroy_component(j);
      },
    }
  );
}
function create_fragment$2D(k) {
  let r,
    p,
    v = k[0] && create_if_block$10(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, [S]) {
      $[0]
        ? v
          ? (v.p($, S), S & 1 && transition_in(v, 1))
          : ((v = create_if_block$10($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function instance$2u(k, r, p) {
  let v,
    $,
    S,
    x,
    { overlay: I } = r,
    F = !1,
    O = writable(defaultDirectory);
  component_subscribe(k, O, (Q) => p(2, ($ = Q)));
  let L = writable("./");
  component_subscribe(k, L, (Q) => p(12, (v = Q)));
  let U = writable(null);
  component_subscribe(k, U, (Q) => p(4, (x = Q)));
  let j = writable(!1);
  component_subscribe(k, j, (Q) => p(3, (S = Q)));
  async function N(Q) {
    set_store_value(L, (v = Q), v), await q();
  }
  async function q() {
    set_store_value(O, ($ = defaultDirectory), $),
      set_store_value(O, ($ = (await getDirectory(v)) || null), $);
  }
  function R(Q) {
    (F = Q), p(1, F);
  }
  return (
    (k.$$set = (Q) => {
      "overlay" in Q && p(0, (I = Q.overlay));
    }),
    [I, F, $, S, x, O, L, U, j, N, q, R]
  );
}
class ChooserOverlay extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2u, create_fragment$2D, safe_not_equal, {
        overlay: 0,
      });
  }
}
function generateChooserOverlayData(k = "Choose File") {
  return {
    info: { name: k, author: "ArcOS Generated", version: "1" },
    size: { w: NaN, h: NaN },
    show: !0,
    id: `CHOOSER#${Math.floor(Math.random() * 1e6)}`,
    content: ChooserOverlay,
  };
}
function showOpenFileDialog(k) {
  const r = get_store_value(WindowStore);
  let p = null;
  for (let $ = 0; $ < r.length; $++)
    if (r[$].id == k) {
      p = $;
      break;
    }
  if (p == null) return !1;
  const v = generateChooserOverlayData();
  assignTarget(v.id, k),
    r[p].overlays || (r[p].overlays = {}),
    (r[p].overlays[v.id] = v),
    WindowStore.set(r);
}
const TextEditorContent = writable(null);
async function saveTextEditorFile(k, r) {
  const p = new Blob([k]);
  await writeFile(r.path, p);
}
async function setShortcuts(k) {
  registerShortcuts(
    [
      {
        key: "o",
        alt: !0,
        action: () => {
          showOpenFileDialog(k.id);
        },
      },
      {
        key: "m",
        alt: !0,
        action: () => {
          !k.openedFile ||
            !k.openedFile.name.endsWith(".md") ||
            (openWindow("MarkDownViewer"), closeFile("MarkDownViewer"));
        },
      },
    ],
    "TextEditor"
  ),
    (k.events.close = () => {
      get_store_value(TextEditorContent) && closeWindow("MarkDownViewer");
    });
}
async function doLoadError(k, r) {
  return createOverlayableError(
    {
      title: k,
      message: r,
      buttons: [{ caption: "Close", action: () => closeWindow("TextEditor") }],
    },
    "TextEditor"
  );
}
function tryParse(k) {
  try {
    return JSON.parse(k);
  } catch {
    return !1;
  }
}
function create_fragment$2C(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q;
  return {
    c() {
      (r = element("div")),
        (p = element("button")),
        (p.textContent = "folder_open"),
        (v = space()),
        ($ = element("button")),
        (S = text("save")),
        (I = space()),
        (F = element("div")),
        (O = element("button")),
        (L = element("img")),
        attr(p, "class", "material-icons-round open"),
        attr($, "class", "material-icons-round save"),
        ($.disabled = x = !k[0].openedFile),
        src_url_equal(L.src, (U = icon$1)) || attr(L, "src", U),
        attr(L, "alt", "Markdown Viewer"),
        attr(O, "title", "Open Markdown Viewer"),
        (O.disabled = j =
          !k[0].openedFile || !k[0].openedFile.name.endsWith(".md")),
        attr(O, "class", "markdown-open"),
        attr(F, "class", "right"),
        attr(r, "class", "actions");
    },
    m(R, Q) {
      insert(R, r, Q),
        append(r, p),
        append(r, v),
        append(r, $),
        append($, S),
        append(r, I),
        append(r, F),
        append(F, O),
        append(O, L),
        N ||
          ((q = [
            listen(p, "click", k[2]),
            listen($, "click", function () {
              is_function(k[1]) && k[1].apply(this, arguments);
            }),
            listen(O, "click", k[3]),
          ]),
          (N = !0));
    },
    p(R, [Q]) {
      (k = R),
        Q & 1 && x !== (x = !k[0].openedFile) && ($.disabled = x),
        Q & 1 &&
          j !==
            (j = !k[0].openedFile || !k[0].openedFile.name.endsWith(".md")) &&
          (O.disabled = j);
    },
    i: noop$1,
    o: noop$1,
    d(R) {
      R && detach(r), (N = !1), run_all(q);
    },
  };
}
function instance$2t(k, r, p) {
  let { app: v } = r,
    { saveFile: $ } = r;
  const S = () => showOpenFileDialog(v.id),
    x = () => openWindow("MarkDownViewer");
  return (
    (k.$$set = (I) => {
      "app" in I && p(0, (v = I.app)),
        "saveFile" in I && p(1, ($ = I.saveFile));
    }),
    [v, $, S, x]
  );
}
let Actions$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2t, create_fragment$2C, safe_not_equal, {
        app: 0,
        saveFile: 1,
      });
  }
};
function create_fragment$2B(k) {
  let r,
    p,
    v,
    $,
    S = formatBytes(k[0].length) + "",
    x,
    I,
    F,
    O = k[1].openedFile.name + "",
    L,
    U,
    j,
    N = k[1].openedFile.mime.split(";")[0] + "",
    q;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("div")),
        ($ = text("Size: ")),
        (x = text(S)),
        (I = space()),
        (F = element("div")),
        (L = text(O)),
        (U = space()),
        (j = element("div")),
        (q = text(N)),
        attr(v, "class", "section"),
        attr(F, "class", "section"),
        attr(j, "class", "section"),
        attr(p, "class", "right"),
        attr(r, "class", "bottom");
    },
    m(R, Q) {
      insert(R, r, Q),
        append(r, p),
        append(p, v),
        append(v, $),
        append(v, x),
        append(p, I),
        append(p, F),
        append(F, L),
        append(p, U),
        append(p, j),
        append(j, q);
    },
    p(R, [Q]) {
      Q & 1 && S !== (S = formatBytes(R[0].length) + "") && set_data(x, S),
        Q & 2 && O !== (O = R[1].openedFile.name + "") && set_data(L, O),
        Q & 2 &&
          N !== (N = R[1].openedFile.mime.split(";")[0] + "") &&
          set_data(q, N);
    },
    i: noop$1,
    o: noop$1,
    d(R) {
      R && detach(r);
    },
  };
}
function instance$2s(k, r, p) {
  let { fileContents: v } = r,
    { app: $ } = r;
  return (
    (k.$$set = (S) => {
      "fileContents" in S && p(0, (v = S.fileContents)),
        "app" in S && p(1, ($ = S.app));
    }),
    [v, $]
  );
}
let Bottom$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2s, create_fragment$2B, safe_not_equal, {
        fileContents: 0,
        app: 1,
      });
  }
};
const save = "./assets/save-13107e70.svg";
function create_if_block$$(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F = k[1].openedFile.name + "",
    O,
    L,
    U,
    j,
    N;
  return (
    (j = new Spinner({ props: { height: 24 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          (v = element("img")),
          (S = space()),
          (x = element("p")),
          (I = text("Saving ")),
          (O = text(F)),
          (L = text("...")),
          (U = space()),
          create_component(j.$$.fragment),
          src_url_equal(v.src, ($ = save)) || attr(v, "src", $),
          attr(v, "alt", "Saving"),
          attr(x, "class", "caption"),
          attr(p, "class", "saving-content"),
          attr(r, "class", "saving-wrapper");
      },
      m(q, R) {
        insert(q, r, R),
          append(r, p),
          append(p, v),
          append(p, S),
          append(p, x),
          append(x, I),
          append(x, O),
          append(x, L),
          append(p, U),
          mount_component(j, p, null),
          (N = !0);
      },
      p(q, R) {
        (!N || R & 2) &&
          F !== (F = q[1].openedFile.name + "") &&
          set_data(O, F);
      },
      i(q) {
        N || (transition_in(j.$$.fragment, q), (N = !0));
      },
      o(q) {
        transition_out(j.$$.fragment, q), (N = !1);
      },
      d(q) {
        q && detach(r), destroy_component(j);
      },
    }
  );
}
function create_fragment$2A(k) {
  let r,
    p,
    v = k[0] && k[1].openedFile && create_if_block$$(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, [S]) {
      $[0] && $[1].openedFile
        ? v
          ? (v.p($, S), S & 3 && transition_in(v, 1))
          : ((v = create_if_block$$($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function instance$2r(k, r, p) {
  let { saving: v } = r,
    { app: $ } = r;
  return (
    (k.$$set = (S) => {
      "saving" in S && p(0, (v = S.saving)), "app" in S && p(1, ($ = S.app));
    }),
    [v, $]
  );
}
class Saving extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2r, create_fragment$2A, safe_not_equal, {
        saving: 0,
        app: 1,
      });
  }
}
function create_fragment$2z(k) {
  let r, p, v;
  return {
    c() {
      (r = element("textarea")), attr(r, "spellcheck", !1);
    },
    m($, S) {
      insert($, r, S),
        set_input_value(r, k[0]),
        p ||
          ((v = [
            listen(r, "input", k[2]),
            listen(r, "change", function () {
              is_function(k[1]) && k[1].apply(this, arguments);
            }),
            listen(r, "input", function () {
              is_function(k[1]) && k[1].apply(this, arguments);
            }),
            listen(r, "keydown", function () {
              is_function(k[1]) && k[1].apply(this, arguments);
            }),
          ]),
          (p = !0));
    },
    p($, [S]) {
      (k = $), S & 1 && set_input_value(r, k[0]);
    },
    i: noop$1,
    o: noop$1,
    d($) {
      $ && detach(r), (p = !1), run_all(v);
    },
  };
}
function instance$2q(k, r, p) {
  let { onchange: v } = r,
    { fileContents: $ } = r;
  function S() {
    ($ = this.value), p(0, $);
  }
  return (
    (k.$$set = (x) => {
      "onchange" in x && p(1, (v = x.onchange)),
        "fileContents" in x && p(0, ($ = x.fileContents));
    }),
    [$, v, S]
  );
}
class TextArea extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2q, create_fragment$2z, safe_not_equal, {
        onchange: 1,
        fileContents: 0,
      });
  }
}
function create_if_block$_(k) {
  let r, p, v, $, S;
  function x(F) {
    k[6](F);
  }
  let I = { onchange: k[5] };
  return (
    k[3] !== void 0 && (I.fileContents = k[3]),
    (r = new TextArea({ props: I })),
    binding_callbacks.push(() => bind$1(r, "fileContents", x)),
    ($ = new Bottom$1({ props: { fileContents: k[3], app: k[0] } })),
    {
      c() {
        create_component(r.$$.fragment),
          (v = space()),
          create_component($.$$.fragment);
      },
      m(F, O) {
        mount_component(r, F, O),
          insert(F, v, O),
          mount_component($, F, O),
          (S = !0);
      },
      p(F, O) {
        const L = {};
        !p &&
          O & 8 &&
          ((p = !0),
          (L.fileContents = F[3]),
          add_flush_callback(() => (p = !1))),
          r.$set(L);
        const U = {};
        O & 8 && (U.fileContents = F[3]), O & 1 && (U.app = F[0]), $.$set(U);
      },
      i(F) {
        S ||
          (transition_in(r.$$.fragment, F),
          transition_in($.$$.fragment, F),
          (S = !0));
      },
      o(F) {
        transition_out(r.$$.fragment, F),
          transition_out($.$$.fragment, F),
          (S = !1);
      },
      d(F) {
        destroy_component(r, F), F && detach(v), destroy_component($, F);
      },
    }
  );
}
function create_fragment$2y(k) {
  let r, p, v, $, S, x, I;
  r = new Actions$1({ props: { app: k[0], saveFile: k[4] } });
  let F = k[0].openedFile && !k[1] && create_if_block$_(k);
  function O(U) {
    k[7](U);
  }
  let L = { saving: k[2] };
  return (
    k[0] !== void 0 && (L.app = k[0]),
    (S = new Saving({ props: L })),
    binding_callbacks.push(() => bind$1(S, "app", O)),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          (v = element("div")),
          F && F.c(),
          ($ = space()),
          create_component(S.$$.fragment),
          attr(v, "class", "content"),
          toggle_class(v, "nofile", !k[0].openedFile);
      },
      m(U, j) {
        mount_component(r, U, j),
          insert(U, p, j),
          insert(U, v, j),
          F && F.m(v, null),
          insert(U, $, j),
          mount_component(S, U, j),
          (I = !0);
      },
      p(U, [j]) {
        const N = {};
        j & 1 && (N.app = U[0]),
          r.$set(N),
          U[0].openedFile && !U[1]
            ? F
              ? (F.p(U, j), j & 3 && transition_in(F, 1))
              : ((F = create_if_block$_(U)),
                F.c(),
                transition_in(F, 1),
                F.m(v, null))
            : F &&
              (group_outros(),
              transition_out(F, 1, 1, () => {
                F = null;
              }),
              check_outros()),
          (!I || j & 1) && toggle_class(v, "nofile", !U[0].openedFile);
        const q = {};
        j & 4 && (q.saving = U[2]),
          !x &&
            j & 1 &&
            ((x = !0), (q.app = U[0]), add_flush_callback(() => (x = !1))),
          S.$set(q);
      },
      i(U) {
        I ||
          (transition_in(r.$$.fragment, U),
          transition_in(F),
          transition_in(S.$$.fragment, U),
          (I = !0));
      },
      o(U) {
        transition_out(r.$$.fragment, U),
          transition_out(F),
          transition_out(S.$$.fragment, U),
          (I = !1);
      },
      d(U) {
        destroy_component(r, U),
          U && detach(p),
          U && detach(v),
          F && F.d(),
          U && detach($),
          destroy_component(S, U);
      },
    }
  );
}
function instance$2p(k, r, p) {
  let v;
  component_subscribe(k, TextEditorContent, (j) => p(9, (v = j)));
  let { app: $ } = r,
    S = !1,
    x = !1,
    I = "";
  onMount(() => {
    p(0, ($.events = {}), $),
      p(
        0,
        ($.events.openFile = (j) => {
          if ((p(1, (S = !1)), !j.openedFile)) return p(3, (I = ""));
          const N = new TextDecoder().decode(j.openedFile.data);
          p(3, (I = N)), j.openedFile.path, TextEditorContent.set(I);
          const q = tryParse(I);
          q &&
            q.error &&
            q.valid == !1 &&
            (p(1, (S = !0)), doLoadError(q.error.title, q.error.message));
        }),
        $
      ),
      setShortcuts($);
  });
  async function F() {
    p(2, (x = !0)), await saveTextEditorFile(I, $.openedFile), p(2, (x = !1));
  }
  async function O() {
    v != I && TextEditorContent.set(I);
  }
  function L(j) {
    (I = j), p(3, I);
  }
  function U(j) {
    ($ = j), p(0, $);
  }
  return (
    (k.$$set = (j) => {
      "app" in j && p(0, ($ = j.app));
    }),
    [$, S, x, I, F, O, L, U]
  );
}
class TextView extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2p, create_fragment$2y, safe_not_equal, {
        app: 0,
      });
  }
}
const ImageViewer = {
    info: {
      name: "Image Viewer",
      description: "Display images from the ArcAPI",
      builtin: !0,
      version: "2.0.1",
      author: "Izaak Kuipers",
      hidden: !0,
      icon: logo$5,
    },
    size: { w: 500, h: 400 },
    pos: { x: 30, y: 40 },
    minSize: { w: 500, h: 400 },
    maxSize: { w: 1e3, h: 700 },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: ImageView,
    glass: !0,
    fileMimes: [
      "image/png",
      "image/jpeg",
      "image/svg+xml",
      "image/vnd.microsoft.icon",
      "image/bmp",
      "image/jpeg",
      "image/webp",
      "image/gif",
    ],
    events: {
      openFile(k) {
        k.openedFile && setTitleSuffix(` - ${k.openedFile.name}`, k.id);
      },
    },
  },
  logo$4 = "./assets/logger-53b4bb5a.svg",
  logger = "";
function collectLogsBySource() {
  const k = get_store_value(log);
  let r = [],
    p = {};
  for (let v = 0; v < k.length; v++) {
    const $ = k[v];
    r.includes($.source) || r.push($.source),
      (p[$.source] = Array.prototype.concat(p[$.source] || [], [$]));
  }
  return p;
}
function create_fragment$2x(k) {
  let r,
    p,
    v = k[0][1] + "",
    $,
    S,
    x,
    I,
    F;
  return {
    c() {
      (r = element("button")),
        (p = element("span")),
        ($ = text(v)),
        attr(p, "class", "material-icons-round"),
        attr(r, "class", (S = "filter " + LogLevel[k[0][0]])),
        (r.disabled = x = !k[1] || k[4]),
        toggle_class(r, "selected", k[0][0] == k[2]);
    },
    m(O, L) {
      insert(O, r, L),
        append(r, p),
        append(p, $),
        I || ((F = listen(r, "click", k[5])), (I = !0));
    },
    p(O, [L]) {
      L & 1 && v !== (v = O[0][1] + "") && set_data($, v),
        L & 1 &&
          S !== (S = "filter " + LogLevel[O[0][0]]) &&
          attr(r, "class", S),
        L & 18 && x !== (x = !O[1] || O[4]) && (r.disabled = x),
        L & 5 && toggle_class(r, "selected", O[0][0] == O[2]);
    },
    i: noop$1,
    o: noop$1,
    d(O) {
      O && detach(r), (I = !1), F();
    },
  };
}
function instance$2o(k, r, p) {
  let v;
  component_subscribe(k, log, (L) => p(6, (v = L)));
  let { data: $ } = r,
    { currentSource: S } = r,
    { currentFilter: x } = r,
    { filter: I } = r,
    F = !1;
  log.subscribe(() => {
    setTimeout(() => {
      let L = 0;
      for (let U = 0; U < v.length; U++)
        v[U].level == $[0] && v[U].source == S && L++;
      p(4, (F = !L));
    }),
      p(4, (F = !1));
  });
  const O = () => I($[0]);
  return (
    (k.$$set = (L) => {
      "data" in L && p(0, ($ = L.data)),
        "currentSource" in L && p(1, (S = L.currentSource)),
        "currentFilter" in L && p(2, (x = L.currentFilter)),
        "filter" in L && p(3, (I = L.filter));
    }),
    [$, S, x, I, F, O]
  );
}
class Filter extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2o, create_fragment$2x, safe_not_equal, {
        data: 0,
        currentSource: 1,
        currentFilter: 2,
        filter: 3,
      });
  }
}
function get_each_context$y(k, r, p) {
  const v = k.slice();
  return (v[4] = r[p]), v;
}
function create_each_block$y(k) {
  let r, p;
  return (
    (r = new Filter({
      props: {
        data: k[4],
        currentSource: k[2],
        currentFilter: k[0],
        filter: k[1],
      },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 4 && (S.currentSource = v[2]),
          $ & 1 && (S.currentFilter = v[0]),
          $ & 2 && (S.filter = v[1]),
          r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$2w(k) {
  let r,
    p,
    v = k[3],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$y(get_each_context$y(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      r = element("div");
      for (let x = 0; x < $.length; x += 1) $[x].c();
      attr(r, "class", "filters");
    },
    m(x, I) {
      insert(x, r, I);
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(r, null);
      p = !0;
    },
    p(x, [I]) {
      if (I & 15) {
        v = x[3];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$y(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$y(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      x && detach(r), destroy_each($, x);
    },
  };
}
function instance$2n(k, r, p) {
  let { filter: v } = r,
    { currentFilter: $ } = r,
    { currentSource: S } = r;
  const x = [
    [LogLevel.error, "error"],
    [LogLevel.warn, "warning"],
    [LogLevel.info, "info"],
    [LogLevel.critical, "cancel"],
  ];
  return (
    log.subscribe(() => {
      p(0, ($ = null));
    }),
    (k.$$set = (I) => {
      "filter" in I && p(1, (v = I.filter)),
        "currentFilter" in I && p(0, ($ = I.currentFilter)),
        "currentSource" in I && p(2, (S = I.currentSource));
    }),
    [$, v, S, x]
  );
}
class Filters extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2n, create_fragment$2w, safe_not_equal, {
        filter: 1,
        currentFilter: 0,
        currentSource: 2,
      });
  }
}
function create_fragment$2v(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H;
  return {
    c() {
      (r = element("div")),
        (p = element("button")),
        (v = element("img")),
        (S = text(`
    Clear`)),
        (I = space()),
        (F = element("div")),
        (O = space()),
        (L = element("button")),
        (U = element("span")),
        (U.textContent = "refresh"),
        (j = text(`
    Refresh`)),
        (q = space()),
        (R = element("button")),
        (R.innerHTML = `<span class="material-icons-round">title</span>
    monospace`),
        src_url_equal(v.src, ($ = clear$1)) || attr(v, "src", $),
        attr(v, "alt", "Clear"),
        attr(p, "class", "action"),
        (p.disabled = x = !k[0]),
        attr(F, "class", "sep"),
        attr(U, "class", "material-icons-round"),
        attr(L, "class", "action"),
        (L.disabled = N = !k[0]),
        attr(R, "class", "action"),
        attr(r, "class", "static");
    },
    m(G, V) {
      insert(G, r, V),
        append(r, p),
        append(p, v),
        append(p, S),
        append(r, I),
        append(r, F),
        append(r, O),
        append(r, L),
        append(L, U),
        append(L, j),
        append(r, q),
        append(r, R),
        Q ||
          ((H = [
            listen(p, "click", k[10]),
            listen(L, "click", k[2]),
            listen(R, "click", k[3]),
          ]),
          (Q = !0));
    },
    p(G, [V]) {
      V & 1 && x !== (x = !G[0]) && (p.disabled = x),
        V & 1 && N !== (N = !G[0]) && (L.disabled = N);
    },
    i: noop$1,
    o: noop$1,
    d(G) {
      G && detach(r), (Q = !1), run_all(H);
    },
  };
}
function instance$2m(k, r, p) {
  let v, $;
  component_subscribe(k, UserData, (Q) => p(11, (v = Q))),
    component_subscribe(k, log, (Q) => p(12, ($ = Q)));
  let { currentSource: S } = r,
    { currentFilter: x } = r,
    { logItems: I } = r,
    { setView: F } = r,
    { filter: O } = r,
    { appdata: L } = r,
    { app: U } = r;
  function j(Q) {
    for (let H = 0; H < $.length; H++) $[H].source == Q && $.splice(H, 1);
    p(0, (S = "")), p(4, (I = [])), log.set($);
  }
  function N() {
    Log({
      source: "Logger: refresh",
      msg: "Refreshing current view",
      level: LogLevel.warn,
    }),
      F(S),
      x && O(x);
  }
  function q() {
    p(5, (L.monospace = !L.monospace), L),
      set_store_value(UserData, (v.appdata[U.id] = L), v);
  }
  const R = () => j(S);
  return (
    (k.$$set = (Q) => {
      "currentSource" in Q && p(0, (S = Q.currentSource)),
        "currentFilter" in Q && p(6, (x = Q.currentFilter)),
        "logItems" in Q && p(4, (I = Q.logItems)),
        "setView" in Q && p(7, (F = Q.setView)),
        "filter" in Q && p(8, (O = Q.filter)),
        "appdata" in Q && p(5, (L = Q.appdata)),
        "app" in Q && p(9, (U = Q.app));
    }),
    [S, j, N, q, I, L, x, F, O, U, R]
  );
}
class Static extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2m, create_fragment$2v, safe_not_equal, {
        currentSource: 0,
        currentFilter: 6,
        logItems: 4,
        setView: 7,
        filter: 8,
        appdata: 5,
        app: 9,
      });
  }
}
function create_fragment$2u(k) {
  let r, p, v, $, S, x, I, F;
  function O(N) {
    k[8](N);
  }
  function L(N) {
    k[9](N);
  }
  function U(N) {
    k[10](N);
  }
  let j = { currentFilter: k[5], filter: k[6], setView: k[4], app: k[3] };
  return (
    k[0] !== void 0 && (j.currentSource = k[0]),
    k[1] !== void 0 && (j.logItems = k[1]),
    k[2] !== void 0 && (j.appdata = k[2]),
    (p = new Static({ props: j })),
    binding_callbacks.push(() => bind$1(p, "currentSource", O)),
    binding_callbacks.push(() => bind$1(p, "logItems", L)),
    binding_callbacks.push(() => bind$1(p, "appdata", U)),
    (I = new Filters({
      props: { currentFilter: k[5], currentSource: k[0], filter: k[6] },
    })),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (x = space()),
          create_component(I.$$.fragment),
          attr(r, "class", "actions");
      },
      m(N, q) {
        insert(N, r, q),
          mount_component(p, r, null),
          append(r, x),
          mount_component(I, r, null),
          (F = !0);
      },
      p(N, [q]) {
        const R = {};
        q & 32 && (R.currentFilter = N[5]),
          q & 16 && (R.setView = N[4]),
          q & 8 && (R.app = N[3]),
          !v &&
            q & 1 &&
            ((v = !0),
            (R.currentSource = N[0]),
            add_flush_callback(() => (v = !1))),
          !$ &&
            q & 2 &&
            (($ = !0), (R.logItems = N[1]), add_flush_callback(() => ($ = !1))),
          !S &&
            q & 4 &&
            ((S = !0), (R.appdata = N[2]), add_flush_callback(() => (S = !1))),
          p.$set(R);
        const Q = {};
        q & 32 && (Q.currentFilter = N[5]),
          q & 1 && (Q.currentSource = N[0]),
          I.$set(Q);
      },
      i(N) {
        F ||
          (transition_in(p.$$.fragment, N),
          transition_in(I.$$.fragment, N),
          (F = !0));
      },
      o(N) {
        transition_out(p.$$.fragment, N),
          transition_out(I.$$.fragment, N),
          (F = !1);
      },
      d(N) {
        N && detach(r), destroy_component(p), destroy_component(I);
      },
    }
  );
}
function instance$2l(k, r, p) {
  let { app: v } = r,
    { currentSource: $ } = r,
    { logItems: S } = r,
    { setView: x } = r,
    { updating: I } = r,
    { appdata: F } = r,
    O = [],
    L;
  log.subscribe((R) => {
    p(7, (I = !0)), (O = []), p(5, (L = null));
    const Q = Object.entries(R);
    for (let H = 0; H < Q.length; H++) Q[H][0] == $ && O.push(Q[H][1]);
    setTimeout(() => {
      p(7, (I = !1));
    });
  });
  function U(R) {
    O.length || (O = S);
    const Q = [];
    for (let H = 0; H < O.length; H++) R == O[H].level && Q.push(O[H]);
    p(1, (S = Q)), p(5, (L = R));
  }
  function j(R) {
    ($ = R), p(0, $);
  }
  function N(R) {
    (S = R), p(1, S);
  }
  function q(R) {
    (F = R), p(2, F);
  }
  return (
    (k.$$set = (R) => {
      "app" in R && p(3, (v = R.app)),
        "currentSource" in R && p(0, ($ = R.currentSource)),
        "logItems" in R && p(1, (S = R.logItems)),
        "setView" in R && p(4, (x = R.setView)),
        "updating" in R && p(7, (I = R.updating)),
        "appdata" in R && p(2, (F = R.appdata));
    }),
    [$, S, F, v, x, L, U, I, j, N, q]
  );
}
class Actions extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2l, create_fragment$2u, safe_not_equal, {
        app: 3,
        currentSource: 0,
        logItems: 1,
        setView: 4,
        updating: 7,
        appdata: 2,
      });
  }
}
function create_fragment$2t(k) {
  let r,
    p,
    v = k[1][k[0].level] + "",
    $,
    S,
    x,
    I,
    F = dayjs(k[0].timestamp).format("HH:mm:ss.SSS") + "",
    O,
    L,
    U,
    j = k[0].msg + "",
    N;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        ($ = text(v)),
        (x = space()),
        (I = element("div")),
        (O = text(F)),
        (L = space()),
        (U = element("div")),
        (N = text(j)),
        attr(
          p,
          "class",
          (S = "level material-icons-round " + LogLevel[k[0].level])
        ),
        attr(I, "class", "timestamp"),
        attr(U, "class", "msg"),
        attr(r, "class", "logitem");
    },
    m(q, R) {
      insert(q, r, R),
        append(r, p),
        append(p, $),
        append(r, x),
        append(r, I),
        append(I, O),
        append(r, L),
        append(r, U),
        append(U, N);
    },
    p(q, [R]) {
      R & 1 && v !== (v = q[1][q[0].level] + "") && set_data($, v),
        R & 1 &&
          S !== (S = "level material-icons-round " + LogLevel[q[0].level]) &&
          attr(p, "class", S),
        R & 1 &&
          F !== (F = dayjs(q[0].timestamp).format("HH:mm:ss.SSS") + "") &&
          set_data(O, F),
        R & 1 && j !== (j = q[0].msg + "") && set_data(N, j);
    },
    i: noop$1,
    o: noop$1,
    d(q) {
      q && detach(r);
    },
  };
}
function instance$2k(k, r, p) {
  let { logItem: v } = r;
  const $ = { 0: "info", 1: "warning", 2: "error", 3: "cancel" };
  return (
    (k.$$set = (S) => {
      "logItem" in S && p(0, (v = S.logItem));
    }),
    [v, $]
  );
}
class LogItem extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2k, create_fragment$2t, safe_not_equal, {
        logItem: 0,
      });
  }
}
function get_each_context$x(k, r, p) {
  const v = k.slice();
  return (v[4] = r[p]), v;
}
function create_if_block_1$i(k) {
  let r,
    p,
    v = k[1],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$x(get_each_context$x(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = empty();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 2) {
        v = x[1];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$x(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$x(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_each_block$x(k) {
  let r, p;
  return (
    (r = new LogItem({ props: { logItem: k[4] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 2 && (S.logItem = v[4]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$Z(k) {
  let r, p, v, $, S, x;
  return {
    c() {
      (r = element("div")),
        (p = element("img")),
        (S = space()),
        (x = element("p")),
        (x.textContent = "No items found."),
        src_url_equal(p.src, (v = getAppIcon(k[0]))) || attr(p, "src", v),
        attr(p, "alt", ($ = k[0].info.name)),
        attr(r, "class", "noitems");
    },
    m(I, F) {
      insert(I, r, F), append(r, p), append(r, S), append(r, x);
    },
    p(I, F) {
      F & 1 &&
        !src_url_equal(p.src, (v = getAppIcon(I[0]))) &&
        attr(p, "src", v),
        F & 1 && $ !== ($ = I[0].info.name) && attr(p, "alt", $);
    },
    d(I) {
      I && detach(r);
    },
  };
}
function create_fragment$2s(k) {
  let r,
    p,
    v,
    $ = !k[2] && create_if_block_1$i(k),
    S = !k[1].length && create_if_block$Z(k);
  return {
    c() {
      (r = element("div")),
        $ && $.c(),
        (p = space()),
        S && S.c(),
        attr(r, "class", "items"),
        toggle_class(r, "cflex", !k[1].length),
        toggle_class(r, "monospace", !!k[3].monospace);
    },
    m(x, I) {
      insert(x, r, I),
        $ && $.m(r, null),
        append(r, p),
        S && S.m(r, null),
        (v = !0);
    },
    p(x, [I]) {
      x[2]
        ? $ &&
          (group_outros(),
          transition_out($, 1, 1, () => {
            $ = null;
          }),
          check_outros())
        : $
        ? ($.p(x, I), I & 4 && transition_in($, 1))
        : (($ = create_if_block_1$i(x)), $.c(), transition_in($, 1), $.m(r, p)),
        x[1].length
          ? S && (S.d(1), (S = null))
          : S
          ? S.p(x, I)
          : ((S = create_if_block$Z(x)), S.c(), S.m(r, null)),
        (!v || I & 2) && toggle_class(r, "cflex", !x[1].length),
        (!v || I & 8) && toggle_class(r, "monospace", !!x[3].monospace);
    },
    i(x) {
      v || (transition_in($), (v = !0));
    },
    o(x) {
      transition_out($), (v = !1);
    },
    d(x) {
      x && detach(r), $ && $.d(), S && S.d();
    },
  };
}
function instance$2j(k, r, p) {
  let { app: v } = r,
    { logItems: $ } = r,
    { updating: S } = r,
    { appdata: x } = r;
  return (
    (k.$$set = (I) => {
      "app" in I && p(0, (v = I.app)),
        "logItems" in I && p(1, ($ = I.logItems)),
        "updating" in I && p(2, (S = I.updating)),
        "appdata" in I && p(3, (x = I.appdata));
    }),
    [v, $, S, x]
  );
}
class Items extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2j, create_fragment$2s, safe_not_equal, {
        app: 0,
        logItems: 1,
        updating: 2,
        appdata: 3,
      });
  }
}
function create_fragment$2r(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N;
  function q(X) {
    k[6](X);
  }
  function R(X) {
    k[7](X);
  }
  function Q(X) {
    k[8](X);
  }
  function H(X) {
    k[9](X);
  }
  function G(X) {
    k[10](X);
  }
  function V(X) {
    k[11](X);
  }
  let K = {};
  k[1] !== void 0 && (K.currentSource = k[1]),
    k[2] !== void 0 && (K.logItems = k[2]),
    k[3] !== void 0 && (K.setView = k[3]),
    k[5] !== void 0 && (K.updating = k[5]),
    k[4] !== void 0 && (K.appdata = k[4]),
    k[0] !== void 0 && (K.app = k[0]),
    (p = new Actions({ props: K })),
    binding_callbacks.push(() => bind$1(p, "currentSource", q)),
    binding_callbacks.push(() => bind$1(p, "logItems", R)),
    binding_callbacks.push(() => bind$1(p, "setView", Q)),
    binding_callbacks.push(() => bind$1(p, "updating", H)),
    binding_callbacks.push(() => bind$1(p, "appdata", G)),
    binding_callbacks.push(() => bind$1(p, "app", V));
  function Y(X) {
    k[12](X);
  }
  function J(X) {
    k[13](X);
  }
  let Z = { app: k[0], appdata: k[4] };
  return (
    k[2] !== void 0 && (Z.logItems = k[2]),
    k[5] !== void 0 && (Z.updating = k[5]),
    (L = new Items({ props: Z })),
    binding_callbacks.push(() => bind$1(L, "logItems", Y)),
    binding_callbacks.push(() => bind$1(L, "updating", J)),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (O = space()),
          create_component(L.$$.fragment),
          attr(r, "class", "content");
      },
      m(X, ee) {
        insert(X, r, ee),
          mount_component(p, r, null),
          append(r, O),
          mount_component(L, r, null),
          (N = !0);
      },
      p(X, [ee]) {
        const te = {};
        !v &&
          ee & 2 &&
          ((v = !0),
          (te.currentSource = X[1]),
          add_flush_callback(() => (v = !1))),
          !$ &&
            ee & 4 &&
            (($ = !0),
            (te.logItems = X[2]),
            add_flush_callback(() => ($ = !1))),
          !S &&
            ee & 8 &&
            ((S = !0), (te.setView = X[3]), add_flush_callback(() => (S = !1))),
          !x &&
            ee & 32 &&
            ((x = !0),
            (te.updating = X[5]),
            add_flush_callback(() => (x = !1))),
          !I &&
            ee & 16 &&
            ((I = !0), (te.appdata = X[4]), add_flush_callback(() => (I = !1))),
          !F &&
            ee & 1 &&
            ((F = !0), (te.app = X[0]), add_flush_callback(() => (F = !1))),
          p.$set(te);
        const re = {};
        ee & 1 && (re.app = X[0]),
          ee & 16 && (re.appdata = X[4]),
          !U &&
            ee & 4 &&
            ((U = !0),
            (re.logItems = X[2]),
            add_flush_callback(() => (U = !1))),
          !j &&
            ee & 32 &&
            ((j = !0),
            (re.updating = X[5]),
            add_flush_callback(() => (j = !1))),
          L.$set(re);
      },
      i(X) {
        N ||
          (transition_in(p.$$.fragment, X),
          transition_in(L.$$.fragment, X),
          (N = !0));
      },
      o(X) {
        transition_out(p.$$.fragment, X),
          transition_out(L.$$.fragment, X),
          (N = !1);
      },
      d(X) {
        X && detach(r), destroy_component(p), destroy_component(L);
      },
    }
  );
}
function instance$2i(k, r, p) {
  let { app: v } = r,
    { currentSource: $ } = r,
    { logItems: S } = r,
    { setView: x } = r,
    { appdata: I } = r,
    F = !1;
  function O(H) {
    ($ = H), p(1, $);
  }
  function L(H) {
    (S = H), p(2, S);
  }
  function U(H) {
    (x = H), p(3, x);
  }
  function j(H) {
    (F = H), p(5, F);
  }
  function N(H) {
    (I = H), p(4, I);
  }
  function q(H) {
    (v = H), p(0, v);
  }
  function R(H) {
    (S = H), p(2, S);
  }
  function Q(H) {
    (F = H), p(5, F);
  }
  return (
    (k.$$set = (H) => {
      "app" in H && p(0, (v = H.app)),
        "currentSource" in H && p(1, ($ = H.currentSource)),
        "logItems" in H && p(2, (S = H.logItems)),
        "setView" in H && p(3, (x = H.setView)),
        "appdata" in H && p(4, (I = H.appdata));
    }),
    [v, $, S, x, I, F, O, L, U, j, N, q, R, Q]
  );
}
let Content$3 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2i, create_fragment$2r, safe_not_equal, {
        app: 0,
        currentSource: 1,
        logItems: 2,
        setView: 3,
        appdata: 4,
      });
  }
};
function create_fragment$2q(k) {
  let r,
    p,
    v = k[0][0] + "",
    $,
    S,
    x,
    I = k[0][1].length + "",
    F,
    O,
    L,
    U;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        ($ = text(v)),
        (S = space()),
        (x = element("div")),
        (F = text(I)),
        (O = text(" items")),
        attr(p, "class", "name"),
        attr(x, "class", "items"),
        toggle_class(r, "active", k[0][0] == k[1]);
    },
    m(j, N) {
      insert(j, r, N),
        append(r, p),
        append(p, $),
        append(r, S),
        append(r, x),
        append(x, F),
        append(x, O),
        L || ((U = listen(r, "click", k[2])), (L = !0));
    },
    p(j, [N]) {
      N & 1 && v !== (v = j[0][0] + "") && set_data($, v),
        N & 1 && I !== (I = j[0][1].length + "") && set_data(F, I),
        N & 3 && toggle_class(r, "active", j[0][0] == j[1]);
    },
    i: noop$1,
    o: noop$1,
    d(j) {
      j && detach(r), (L = !1), U();
    },
  };
}
function instance$2h(k, r, p) {
  let { category: v } = r,
    { setView: $ } = r,
    { currentSource: S } = r;
  function x() {
    $ && $(v[0]);
  }
  return (
    (k.$$set = (I) => {
      "category" in I && p(0, (v = I.category)),
        "setView" in I && p(3, ($ = I.setView)),
        "currentSource" in I && p(1, (S = I.currentSource));
    }),
    [v, S, x, $]
  );
}
class Category extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2h, create_fragment$2q, safe_not_equal, {
        category: 0,
        setView: 3,
        currentSource: 1,
      });
  }
}
function get_each_context$w(k, r, p) {
  const v = k.slice();
  return (v[6] = r[p]), (v[7] = r), (v[8] = p), v;
}
function create_each_block$w(k) {
  let r, p, v, $, S;
  function x(L) {
    k[3](L);
  }
  function I(L) {
    k[4](L, k[6], k[7], k[8]);
  }
  function F(L) {
    k[5](L);
  }
  let O = {};
  return (
    k[1] !== void 0 && (O.setView = k[1]),
    k[6] !== void 0 && (O.category = k[6]),
    k[2] !== void 0 && (O.currentSource = k[2]),
    (r = new Category({ props: O })),
    binding_callbacks.push(() => bind$1(r, "setView", x)),
    binding_callbacks.push(() => bind$1(r, "category", I)),
    binding_callbacks.push(() => bind$1(r, "currentSource", F)),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(L, U) {
        mount_component(r, L, U), (S = !0);
      },
      p(L, U) {
        k = L;
        const j = {};
        !p &&
          U & 2 &&
          ((p = !0), (j.setView = k[1]), add_flush_callback(() => (p = !1))),
          !v &&
            U & 1 &&
            ((v = !0), (j.category = k[6]), add_flush_callback(() => (v = !1))),
          !$ &&
            U & 4 &&
            (($ = !0),
            (j.currentSource = k[2]),
            add_flush_callback(() => ($ = !1))),
          r.$set(j);
      },
      i(L) {
        S || (transition_in(r.$$.fragment, L), (S = !0));
      },
      o(L) {
        transition_out(r.$$.fragment, L), (S = !1);
      },
      d(L) {
        destroy_component(r, L);
      },
    }
  );
}
function create_fragment$2p(k) {
  let r,
    p,
    v = k[0],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$w(get_each_context$w(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      r = element("div");
      for (let x = 0; x < $.length; x += 1) $[x].c();
      attr(r, "class", "sidebar");
    },
    m(x, I) {
      insert(x, r, I);
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(r, null);
      p = !0;
    },
    p(x, [I]) {
      if (I & 7) {
        v = x[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$w(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$w(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      x && detach(r), destroy_each($, x);
    },
  };
}
function instance$2g(k, r, p) {
  let { logs: v } = r,
    { setView: $ } = r,
    { currentSource: S } = r;
  function x(O) {
    ($ = O), p(1, $);
  }
  function I(O, L, U, j) {
    (U[j] = O), p(0, v);
  }
  function F(O) {
    (S = O), p(2, S);
  }
  return (
    (k.$$set = (O) => {
      "logs" in O && p(0, (v = O.logs)),
        "setView" in O && p(1, ($ = O.setView)),
        "currentSource" in O && p(2, (S = O.currentSource));
    }),
    [v, $, S, x, I, F]
  );
}
let Sidebar$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2g, create_fragment$2p, safe_not_equal, {
        logs: 0,
        setView: 1,
        currentSource: 2,
      });
  }
};
function create_if_block$Y(k) {
  let r, p, v, $, S, x, I, F, O;
  function L(H) {
    k[6](H);
  }
  function U(H) {
    k[7](H);
  }
  let j = { setView: k[5] };
  k[4] !== void 0 && (j.currentSource = k[4]),
    k[2] !== void 0 && (j.logs = k[2]),
    (r = new Sidebar$1({ props: j })),
    binding_callbacks.push(() => bind$1(r, "currentSource", L)),
    binding_callbacks.push(() => bind$1(r, "logs", U));
  function N(H) {
    k[8](H);
  }
  function q(H) {
    k[9](H);
  }
  function R(H) {
    k[10](H);
  }
  let Q = { setView: k[5], app: k[0] };
  return (
    k[4] !== void 0 && (Q.currentSource = k[4]),
    k[3] !== void 0 && (Q.logItems = k[3]),
    k[1] !== void 0 && (Q.appdata = k[1]),
    (S = new Content$3({ props: Q })),
    binding_callbacks.push(() => bind$1(S, "currentSource", N)),
    binding_callbacks.push(() => bind$1(S, "logItems", q)),
    binding_callbacks.push(() => bind$1(S, "appdata", R)),
    {
      c() {
        create_component(r.$$.fragment),
          ($ = space()),
          create_component(S.$$.fragment);
      },
      m(H, G) {
        mount_component(r, H, G),
          insert(H, $, G),
          mount_component(S, H, G),
          (O = !0);
      },
      p(H, G) {
        const V = {};
        !p &&
          G & 16 &&
          ((p = !0),
          (V.currentSource = H[4]),
          add_flush_callback(() => (p = !1))),
          !v &&
            G & 4 &&
            ((v = !0), (V.logs = H[2]), add_flush_callback(() => (v = !1))),
          r.$set(V);
        const K = {};
        G & 1 && (K.app = H[0]),
          !x &&
            G & 16 &&
            ((x = !0),
            (K.currentSource = H[4]),
            add_flush_callback(() => (x = !1))),
          !I &&
            G & 8 &&
            ((I = !0), (K.logItems = H[3]), add_flush_callback(() => (I = !1))),
          !F &&
            G & 2 &&
            ((F = !0), (K.appdata = H[1]), add_flush_callback(() => (F = !1))),
          S.$set(K);
      },
      i(H) {
        O ||
          (transition_in(r.$$.fragment, H),
          transition_in(S.$$.fragment, H),
          (O = !0));
      },
      o(H) {
        transition_out(r.$$.fragment, H),
          transition_out(S.$$.fragment, H),
          (O = !1);
      },
      d(H) {
        destroy_component(r, H), H && detach($), destroy_component(S, H);
      },
    }
  );
}
function create_fragment$2o(k) {
  let r,
    p,
    v = k[0] && create_if_block$Y(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, [S]) {
      $[0]
        ? v
          ? (v.p($, S), S & 1 && transition_in(v, 1))
          : ((v = create_if_block$Y($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function instance$2f(k, r, p) {
  let v;
  component_subscribe(k, log, (R) => p(11, (v = R)));
  let $ = [],
    S = [],
    x = "",
    { app: I } = r,
    { appdata: F } = r;
  function O(R) {
    Log({
      source: "apps/Logger: setView",
      msg: `Setting source to "${R}"`,
      level: LogLevel.info,
    });
    for (let Q = 0; Q < $.length; Q++) $[Q][0] == R && p(3, (S = $[Q][1]));
    S.length ||
      Log({
        source: "apps/Logger: setView",
        msg: `Source "${R}" contains no items or could not be found.`,
        level: LogLevel.info,
      }),
      p(4, (x = R));
  }
  log.subscribe(() => {
    p(2, ($ = Object.entries(collectLogsBySource()))),
      p(0, (I.info.titleSuffix = ` - ${v.length} items`), I);
  });
  function L(R) {
    (x = R), p(4, x);
  }
  function U(R) {
    ($ = R), p(2, $);
  }
  function j(R) {
    (x = R), p(4, x);
  }
  function N(R) {
    (S = R), p(3, S);
  }
  function q(R) {
    (F = R), p(1, F);
  }
  return (
    (k.$$set = (R) => {
      "app" in R && p(0, (I = R.app)), "appdata" in R && p(1, (F = R.appdata));
    }),
    [I, F, $, S, x, O, L, U, j, N, q]
  );
}
class Logger extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2f, create_fragment$2o, safe_not_equal, {
        app: 0,
        appdata: 1,
      });
  }
}
const LoggerApp = {
  info: {
    name: "System Logger",
    description: "All the ArcOS logs in one place",
    builtin: !0,
    version: "1.0.0",
    author: "ArcOS Team",
    icon: logo$4,
  },
  size: { w: 900, h: 600 },
  pos: { x: 30, y: 40 },
  minSize: { w: 900, h: 600 },
  maxSize: { w: 901, h: 601 },
  controls: { min: !0, max: !0, cls: !0 },
  state: {
    headless: !1,
    resizable: !1,
    windowState: { min: !1, max: !1, fll: !1 },
  },
  content: Logger,
  glass: !0,
};
function supressWarnings() {
  const k = console.warn;
  (console.warn = (r) => {
    r.includes("unknown prop") || r.includes("unexpected slot") || k(r);
  }),
    onMount(() => {
      console.warn = k;
    });
}
function get_each_context_5(k, r, p) {
  const v = k.slice();
  return (v[18] = r[p]), v;
}
function get_each_context_4(k, r, p) {
  const v = k.slice();
  return (v[18] = r[p]), v;
}
function get_each_context_1$5(k, r, p) {
  const v = k.slice();
  return (v[10] = r[p]), v;
}
function get_each_context_2$1(k, r, p) {
  const v = k.slice();
  return (v[13] = r[p]), (v[15] = p), v;
}
function get_each_context_3(k, r, p) {
  const v = k.slice();
  return (v[16] = r[p]), (v[15] = p), v;
}
function get_each_context$v(k, r, p) {
  const v = k.slice();
  return (v[7] = r[p]), v;
}
function create_if_block_1$h(k) {
  let r, p, v, $;
  const S = [create_if_block_2$3, create_if_block_3$1, create_else_block_1],
    x = [];
  function I(F, O) {
    return F[0] === "table" ? 0 : F[0] === "list" ? 1 : 2;
  }
  return (
    (r = I(k)),
    (p = x[r] = S[r](k)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        x[r].m(F, O), insert(F, v, O), ($ = !0);
      },
      p(F, O) {
        let L = r;
        (r = I(F)),
          r === L
            ? x[r].p(F, O)
            : (group_outros(),
              transition_out(x[L], 1, 1, () => {
                x[L] = null;
              }),
              check_outros(),
              (p = x[r]),
              p ? p.p(F, O) : ((p = x[r] = S[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        $ || (transition_in(p), ($ = !0));
      },
      o(F) {
        transition_out(p), ($ = !1);
      },
      d(F) {
        x[r].d(F), F && detach(v);
      },
    }
  );
}
function create_if_block$X(k) {
  let r,
    p,
    v = k[1],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$v(get_each_context$v(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = empty();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 34) {
        v = x[1];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$v(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$v(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_else_block_1(k) {
  let r, p, v;
  const $ = [k[6]];
  var S = k[5][k[0]];
  function x(I) {
    let F = {
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx: I },
    };
    for (let O = 0; O < $.length; O += 1) F = assign(F, $[O]);
    return { props: F };
  }
  return (
    S && (r = construct_svelte_component(S, x(k))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(I, F) {
        r && mount_component(r, I, F), insert(I, p, F), (v = !0);
      },
      p(I, F) {
        const O = F & 64 ? get_spread_update($, [get_spread_object(I[6])]) : {};
        if (
          (F & 8388706 && (O.$$scope = { dirty: F, ctx: I }),
          F & 33 && S !== (S = I[5][I[0]]))
        ) {
          if (r) {
            group_outros();
            const L = r;
            transition_out(L.$$.fragment, 1, 0, () => {
              destroy_component(L, 1);
            }),
              check_outros();
          }
          S
            ? ((r = construct_svelte_component(S, x(I))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else S && r.$set(O);
      },
      i(I) {
        v || (r && transition_in(r.$$.fragment, I), (v = !0));
      },
      o(I) {
        r && transition_out(r.$$.fragment, I), (v = !1);
      },
      d(I) {
        I && detach(p), r && destroy_component(r, I);
      },
    }
  );
}
function create_if_block_3$1(k) {
  let r, p, v, $;
  const S = [create_if_block_4$1, create_else_block$j],
    x = [];
  function I(F, O) {
    return F[4] ? 0 : 1;
  }
  return (
    (r = I(k)),
    (p = x[r] = S[r](k)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        x[r].m(F, O), insert(F, v, O), ($ = !0);
      },
      p(F, O) {
        let L = r;
        (r = I(F)),
          r === L
            ? x[r].p(F, O)
            : (group_outros(),
              transition_out(x[L], 1, 1, () => {
                x[L] = null;
              }),
              check_outros(),
              (p = x[r]),
              p ? p.p(F, O) : ((p = x[r] = S[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        $ || (transition_in(p), ($ = !0));
      },
      o(F) {
        transition_out(p), ($ = !1);
      },
      d(F) {
        x[r].d(F), F && detach(v);
      },
    }
  );
}
function create_if_block_2$3(k) {
  let r, p, v;
  var $ = k[5].table;
  function S(x) {
    return {
      props: {
        $$slots: { default: [create_default_slot$6] },
        $$scope: { ctx: x },
      },
    };
  }
  return (
    $ && (r = construct_svelte_component($, S(k))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(x, I) {
        r && mount_component(r, x, I), insert(x, p, I), (v = !0);
      },
      p(x, I) {
        const F = {};
        if (
          (I & 8388716 && (F.$$scope = { dirty: I, ctx: x }),
          I & 32 && $ !== ($ = x[5].table))
        ) {
          if (r) {
            group_outros();
            const O = r;
            transition_out(O.$$.fragment, 1, 0, () => {
              destroy_component(O, 1);
            }),
              check_outros();
          }
          $
            ? ((r = construct_svelte_component($, S(x))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else $ && r.$set(F);
      },
      i(x) {
        v || (r && transition_in(r.$$.fragment, x), (v = !0));
      },
      o(x) {
        r && transition_out(r.$$.fragment, x), (v = !1);
      },
      d(x) {
        x && detach(p), r && destroy_component(r, x);
      },
    }
  );
}
function create_else_block_2(k) {
  let r = k[6].raw + "",
    p;
  return {
    c() {
      p = text(r);
    },
    m(v, $) {
      insert(v, p, $);
    },
    p(v, $) {
      $ & 64 && r !== (r = v[6].raw + "") && set_data(p, r);
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      v && detach(p);
    },
  };
}
function create_if_block_5$1(k) {
  let r, p;
  return (
    (r = new Parser$1({ props: { tokens: k[1], renderers: k[5] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 2 && (S.tokens = v[1]), $ & 32 && (S.renderers = v[5]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_default_slot_11(k) {
  let r, p, v, $;
  const S = [create_if_block_5$1, create_else_block_2],
    x = [];
  function I(F, O) {
    return F[1] ? 0 : 1;
  }
  return (
    (r = I(k)),
    (p = x[r] = S[r](k)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        x[r].m(F, O), insert(F, v, O), ($ = !0);
      },
      p(F, O) {
        let L = r;
        (r = I(F)),
          r === L
            ? x[r].p(F, O)
            : (group_outros(),
              transition_out(x[L], 1, 1, () => {
                x[L] = null;
              }),
              check_outros(),
              (p = x[r]),
              p ? p.p(F, O) : ((p = x[r] = S[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        $ || (transition_in(p), ($ = !0));
      },
      o(F) {
        transition_out(p), ($ = !1);
      },
      d(F) {
        x[r].d(F), F && detach(v);
      },
    }
  );
}
function create_else_block$j(k) {
  let r, p, v;
  const $ = [{ ordered: k[4] }, k[6]];
  var S = k[5].list;
  function x(I) {
    let F = {
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx: I },
    };
    for (let O = 0; O < $.length; O += 1) F = assign(F, $[O]);
    return { props: F };
  }
  return (
    S && (r = construct_svelte_component(S, x(k))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(I, F) {
        r && mount_component(r, I, F), insert(I, p, F), (v = !0);
      },
      p(I, F) {
        const O =
          F & 80
            ? get_spread_update($, [
                F & 16 && { ordered: I[4] },
                F & 64 && get_spread_object(I[6]),
              ])
            : {};
        if (
          (F & 8388704 && (O.$$scope = { dirty: F, ctx: I }),
          F & 32 && S !== (S = I[5].list))
        ) {
          if (r) {
            group_outros();
            const L = r;
            transition_out(L.$$.fragment, 1, 0, () => {
              destroy_component(L, 1);
            }),
              check_outros();
          }
          S
            ? ((r = construct_svelte_component(S, x(I))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else S && r.$set(O);
      },
      i(I) {
        v || (r && transition_in(r.$$.fragment, I), (v = !0));
      },
      o(I) {
        r && transition_out(r.$$.fragment, I), (v = !1);
      },
      d(I) {
        I && detach(p), r && destroy_component(r, I);
      },
    }
  );
}
function create_if_block_4$1(k) {
  let r, p, v;
  const $ = [{ ordered: k[4] }, k[6]];
  var S = k[5].list;
  function x(I) {
    let F = {
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx: I },
    };
    for (let O = 0; O < $.length; O += 1) F = assign(F, $[O]);
    return { props: F };
  }
  return (
    S && (r = construct_svelte_component(S, x(k))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(I, F) {
        r && mount_component(r, I, F), insert(I, p, F), (v = !0);
      },
      p(I, F) {
        const O =
          F & 80
            ? get_spread_update($, [
                F & 16 && { ordered: I[4] },
                F & 64 && get_spread_object(I[6]),
              ])
            : {};
        if (
          (F & 8388704 && (O.$$scope = { dirty: F, ctx: I }),
          F & 32 && S !== (S = I[5].list))
        ) {
          if (r) {
            group_outros();
            const L = r;
            transition_out(L.$$.fragment, 1, 0, () => {
              destroy_component(L, 1);
            }),
              check_outros();
          }
          S
            ? ((r = construct_svelte_component(S, x(I))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else S && r.$set(O);
      },
      i(I) {
        v || (r && transition_in(r.$$.fragment, I), (v = !0));
      },
      o(I) {
        r && transition_out(r.$$.fragment, I), (v = !1);
      },
      d(I) {
        I && detach(p), r && destroy_component(r, I);
      },
    }
  );
}
function create_default_slot_10(k) {
  let r, p, v;
  return (
    (r = new Parser$1({ props: { tokens: k[18].tokens, renderers: k[5] } })),
    {
      c() {
        create_component(r.$$.fragment), (p = space());
      },
      m($, S) {
        mount_component(r, $, S), insert($, p, S), (v = !0);
      },
      p($, S) {
        const x = {};
        S & 64 && (x.tokens = $[18].tokens),
          S & 32 && (x.renderers = $[5]),
          r.$set(x);
      },
      i($) {
        v || (transition_in(r.$$.fragment, $), (v = !0));
      },
      o($) {
        transition_out(r.$$.fragment, $), (v = !1);
      },
      d($) {
        destroy_component(r, $), $ && detach(p);
      },
    }
  );
}
function create_each_block_5(k) {
  let r, p, v;
  const $ = [k[18]];
  var S = k[5].unorderedlistitem || k[5].listitem;
  function x(I) {
    let F = {
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx: I },
    };
    for (let O = 0; O < $.length; O += 1) F = assign(F, $[O]);
    return { props: F };
  }
  return (
    S && (r = construct_svelte_component(S, x(k))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(I, F) {
        r && mount_component(r, I, F), insert(I, p, F), (v = !0);
      },
      p(I, F) {
        const O =
          F & 64 ? get_spread_update($, [get_spread_object(I[18])]) : {};
        if (
          (F & 8388704 && (O.$$scope = { dirty: F, ctx: I }),
          F & 32 && S !== (S = I[5].unorderedlistitem || I[5].listitem))
        ) {
          if (r) {
            group_outros();
            const L = r;
            transition_out(L.$$.fragment, 1, 0, () => {
              destroy_component(L, 1);
            }),
              check_outros();
          }
          S
            ? ((r = construct_svelte_component(S, x(I))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else S && r.$set(O);
      },
      i(I) {
        v || (r && transition_in(r.$$.fragment, I), (v = !0));
      },
      o(I) {
        r && transition_out(r.$$.fragment, I), (v = !1);
      },
      d(I) {
        I && detach(p), r && destroy_component(r, I);
      },
    }
  );
}
function create_default_slot_9(k) {
  let r,
    p,
    v = k[6].items,
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block_5(get_each_context_5(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = empty();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 96) {
        v = x[6].items;
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_5(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block_5(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_default_slot_8(k) {
  let r, p, v;
  return (
    (r = new Parser$1({ props: { tokens: k[18].tokens, renderers: k[5] } })),
    {
      c() {
        create_component(r.$$.fragment), (p = space());
      },
      m($, S) {
        mount_component(r, $, S), insert($, p, S), (v = !0);
      },
      p($, S) {
        const x = {};
        S & 64 && (x.tokens = $[18].tokens),
          S & 32 && (x.renderers = $[5]),
          r.$set(x);
      },
      i($) {
        v || (transition_in(r.$$.fragment, $), (v = !0));
      },
      o($) {
        transition_out(r.$$.fragment, $), (v = !1);
      },
      d($) {
        destroy_component(r, $), $ && detach(p);
      },
    }
  );
}
function create_each_block_4(k) {
  let r, p, v;
  const $ = [k[18]];
  var S = k[5].orderedlistitem || k[5].listitem;
  function x(I) {
    let F = {
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx: I },
    };
    for (let O = 0; O < $.length; O += 1) F = assign(F, $[O]);
    return { props: F };
  }
  return (
    S && (r = construct_svelte_component(S, x(k))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(I, F) {
        r && mount_component(r, I, F), insert(I, p, F), (v = !0);
      },
      p(I, F) {
        const O =
          F & 64 ? get_spread_update($, [get_spread_object(I[18])]) : {};
        if (
          (F & 8388704 && (O.$$scope = { dirty: F, ctx: I }),
          F & 32 && S !== (S = I[5].orderedlistitem || I[5].listitem))
        ) {
          if (r) {
            group_outros();
            const L = r;
            transition_out(L.$$.fragment, 1, 0, () => {
              destroy_component(L, 1);
            }),
              check_outros();
          }
          S
            ? ((r = construct_svelte_component(S, x(I))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else S && r.$set(O);
      },
      i(I) {
        v || (r && transition_in(r.$$.fragment, I), (v = !0));
      },
      o(I) {
        r && transition_out(r.$$.fragment, I), (v = !1);
      },
      d(I) {
        I && detach(p), r && destroy_component(r, I);
      },
    }
  );
}
function create_default_slot_7(k) {
  let r,
    p,
    v = k[6].items,
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block_4(get_each_context_4(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = empty();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 96) {
        v = x[6].items;
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_4(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block_4(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_default_slot_6$1(k) {
  let r, p, v;
  return (
    (r = new Parser$1({ props: { tokens: k[16].tokens, renderers: k[5] } })),
    {
      c() {
        create_component(r.$$.fragment), (p = space());
      },
      m($, S) {
        mount_component(r, $, S), insert($, p, S), (v = !0);
      },
      p($, S) {
        const x = {};
        S & 4 && (x.tokens = $[16].tokens),
          S & 32 && (x.renderers = $[5]),
          r.$set(x);
      },
      i($) {
        v || (transition_in(r.$$.fragment, $), (v = !0));
      },
      o($) {
        transition_out(r.$$.fragment, $), (v = !1);
      },
      d($) {
        destroy_component(r, $), $ && detach(p);
      },
    }
  );
}
function create_each_block_3(k) {
  let r, p, v;
  var $ = k[5].tablecell;
  function S(x) {
    return {
      props: {
        header: !0,
        align: x[6].align[x[15]] || "center",
        $$slots: { default: [create_default_slot_6$1] },
        $$scope: { ctx: x },
      },
    };
  }
  return (
    $ && (r = construct_svelte_component($, S(k))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(x, I) {
        r && mount_component(r, x, I), insert(x, p, I), (v = !0);
      },
      p(x, I) {
        const F = {};
        if (
          (I & 64 && (F.align = x[6].align[x[15]] || "center"),
          I & 8388644 && (F.$$scope = { dirty: I, ctx: x }),
          I & 32 && $ !== ($ = x[5].tablecell))
        ) {
          if (r) {
            group_outros();
            const O = r;
            transition_out(O.$$.fragment, 1, 0, () => {
              destroy_component(O, 1);
            }),
              check_outros();
          }
          $
            ? ((r = construct_svelte_component($, S(x))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else $ && r.$set(F);
      },
      i(x) {
        v || (r && transition_in(r.$$.fragment, x), (v = !0));
      },
      o(x) {
        r && transition_out(r.$$.fragment, x), (v = !1);
      },
      d(x) {
        x && detach(p), r && destroy_component(r, x);
      },
    }
  );
}
function create_default_slot_5$2(k) {
  let r,
    p,
    v = k[2],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block_3(get_each_context_3(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = empty();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 100) {
        v = x[2];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_3(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block_3(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_default_slot_4$2(k) {
  let r, p, v;
  var $ = k[5].tablerow;
  function S(x) {
    return {
      props: {
        $$slots: { default: [create_default_slot_5$2] },
        $$scope: { ctx: x },
      },
    };
  }
  return (
    $ && (r = construct_svelte_component($, S(k))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(x, I) {
        r && mount_component(r, x, I), insert(x, p, I), (v = !0);
      },
      p(x, I) {
        const F = {};
        if (
          (I & 8388708 && (F.$$scope = { dirty: I, ctx: x }),
          I & 32 && $ !== ($ = x[5].tablerow))
        ) {
          if (r) {
            group_outros();
            const O = r;
            transition_out(O.$$.fragment, 1, 0, () => {
              destroy_component(O, 1);
            }),
              check_outros();
          }
          $
            ? ((r = construct_svelte_component($, S(x))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else $ && r.$set(F);
      },
      i(x) {
        v || (r && transition_in(r.$$.fragment, x), (v = !0));
      },
      o(x) {
        r && transition_out(r.$$.fragment, x), (v = !1);
      },
      d(x) {
        x && detach(p), r && destroy_component(r, x);
      },
    }
  );
}
function create_default_slot_3$2(k) {
  let r, p;
  return (
    (r = new Parser$1({ props: { tokens: k[13].tokens, renderers: k[5] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 8 && (S.tokens = v[13].tokens),
          $ & 32 && (S.renderers = v[5]),
          r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block_2$1(k) {
  let r, p, v;
  var $ = k[5].tablecell;
  function S(x) {
    return {
      props: {
        header: !1,
        align: x[6].align[x[15]] || "center",
        $$slots: { default: [create_default_slot_3$2] },
        $$scope: { ctx: x },
      },
    };
  }
  return (
    $ && (r = construct_svelte_component($, S(k))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(x, I) {
        r && mount_component(r, x, I), insert(x, p, I), (v = !0);
      },
      p(x, I) {
        const F = {};
        if (
          (I & 64 && (F.align = x[6].align[x[15]] || "center"),
          I & 8388648 && (F.$$scope = { dirty: I, ctx: x }),
          I & 32 && $ !== ($ = x[5].tablecell))
        ) {
          if (r) {
            group_outros();
            const O = r;
            transition_out(O.$$.fragment, 1, 0, () => {
              destroy_component(O, 1);
            }),
              check_outros();
          }
          $
            ? ((r = construct_svelte_component($, S(x))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else $ && r.$set(F);
      },
      i(x) {
        v || (r && transition_in(r.$$.fragment, x), (v = !0));
      },
      o(x) {
        r && transition_out(r.$$.fragment, x), (v = !1);
      },
      d(x) {
        x && detach(p), r && destroy_component(r, x);
      },
    }
  );
}
function create_default_slot_2$2(k) {
  let r,
    p,
    v = k[10],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block_2$1(get_each_context_2$1(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = space();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 104) {
        v = x[10];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_2$1(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block_2$1(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_each_block_1$5(k) {
  let r, p, v;
  var $ = k[5].tablerow;
  function S(x) {
    return {
      props: {
        $$slots: { default: [create_default_slot_2$2] },
        $$scope: { ctx: x },
      },
    };
  }
  return (
    $ && (r = construct_svelte_component($, S(k))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(x, I) {
        r && mount_component(r, x, I), insert(x, p, I), (v = !0);
      },
      p(x, I) {
        const F = {};
        if (
          (I & 8388712 && (F.$$scope = { dirty: I, ctx: x }),
          I & 32 && $ !== ($ = x[5].tablerow))
        ) {
          if (r) {
            group_outros();
            const O = r;
            transition_out(O.$$.fragment, 1, 0, () => {
              destroy_component(O, 1);
            }),
              check_outros();
          }
          $
            ? ((r = construct_svelte_component($, S(x))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else $ && r.$set(F);
      },
      i(x) {
        v || (r && transition_in(r.$$.fragment, x), (v = !0));
      },
      o(x) {
        r && transition_out(r.$$.fragment, x), (v = !1);
      },
      d(x) {
        x && detach(p), r && destroy_component(r, x);
      },
    }
  );
}
function create_default_slot_1$3(k) {
  let r,
    p,
    v = k[3],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block_1$5(get_each_context_1$5(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = empty();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 104) {
        v = x[3];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_1$5(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block_1$5(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_default_slot$6(k) {
  let r, p, v, $, S;
  var x = k[5].tablehead;
  function I(L) {
    return {
      props: {
        $$slots: { default: [create_default_slot_4$2] },
        $$scope: { ctx: L },
      },
    };
  }
  x && (r = construct_svelte_component(x, I(k)));
  var F = k[5].tablebody;
  function O(L) {
    return {
      props: {
        $$slots: { default: [create_default_slot_1$3] },
        $$scope: { ctx: L },
      },
    };
  }
  return (
    F && (v = construct_svelte_component(F, O(k))),
    {
      c() {
        r && create_component(r.$$.fragment),
          (p = space()),
          v && create_component(v.$$.fragment),
          ($ = empty());
      },
      m(L, U) {
        r && mount_component(r, L, U),
          insert(L, p, U),
          v && mount_component(v, L, U),
          insert(L, $, U),
          (S = !0);
      },
      p(L, U) {
        const j = {};
        if (
          (U & 8388708 && (j.$$scope = { dirty: U, ctx: L }),
          U & 32 && x !== (x = L[5].tablehead))
        ) {
          if (r) {
            group_outros();
            const q = r;
            transition_out(q.$$.fragment, 1, 0, () => {
              destroy_component(q, 1);
            }),
              check_outros();
          }
          x
            ? ((r = construct_svelte_component(x, I(L))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else x && r.$set(j);
        const N = {};
        if (
          (U & 8388712 && (N.$$scope = { dirty: U, ctx: L }),
          U & 32 && F !== (F = L[5].tablebody))
        ) {
          if (v) {
            group_outros();
            const q = v;
            transition_out(q.$$.fragment, 1, 0, () => {
              destroy_component(q, 1);
            }),
              check_outros();
          }
          F
            ? ((v = construct_svelte_component(F, O(L))),
              create_component(v.$$.fragment),
              transition_in(v.$$.fragment, 1),
              mount_component(v, $.parentNode, $))
            : (v = null);
        } else F && v.$set(N);
      },
      i(L) {
        S ||
          (r && transition_in(r.$$.fragment, L),
          v && transition_in(v.$$.fragment, L),
          (S = !0));
      },
      o(L) {
        r && transition_out(r.$$.fragment, L),
          v && transition_out(v.$$.fragment, L),
          (S = !1);
      },
      d(L) {
        r && destroy_component(r, L),
          L && detach(p),
          L && detach($),
          v && destroy_component(v, L);
      },
    }
  );
}
function create_each_block$v(k) {
  let r, p;
  const v = [k[7], { renderers: k[5] }];
  let $ = {};
  for (let S = 0; S < v.length; S += 1) $ = assign($, v[S]);
  return (
    (r = new Parser$1({ props: $ })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(S, x) {
        mount_component(r, S, x), (p = !0);
      },
      p(S, x) {
        const I =
          x & 34
            ? get_spread_update(v, [
                x & 2 && get_spread_object(S[7]),
                x & 32 && { renderers: S[5] },
              ])
            : {};
        r.$set(I);
      },
      i(S) {
        p || (transition_in(r.$$.fragment, S), (p = !0));
      },
      o(S) {
        transition_out(r.$$.fragment, S), (p = !1);
      },
      d(S) {
        destroy_component(r, S);
      },
    }
  );
}
function create_fragment$2n(k) {
  let r, p, v, $;
  const S = [create_if_block$X, create_if_block_1$h],
    x = [];
  function I(F, O) {
    return F[0] ? (F[5][F[0]] ? 1 : -1) : 0;
  }
  return (
    ~(r = I(k)) && (p = x[r] = S[r](k)),
    {
      c() {
        p && p.c(), (v = empty());
      },
      m(F, O) {
        ~r && x[r].m(F, O), insert(F, v, O), ($ = !0);
      },
      p(F, [O]) {
        let L = r;
        (r = I(F)),
          r === L
            ? ~r && x[r].p(F, O)
            : (p &&
                (group_outros(),
                transition_out(x[L], 1, 1, () => {
                  x[L] = null;
                }),
                check_outros()),
              ~r
                ? ((p = x[r]),
                  p ? p.p(F, O) : ((p = x[r] = S[r](F)), p.c()),
                  transition_in(p, 1),
                  p.m(v.parentNode, v))
                : (p = null));
      },
      i(F) {
        $ || (transition_in(p), ($ = !0));
      },
      o(F) {
        transition_out(p), ($ = !1);
      },
      d(F) {
        ~r && x[r].d(F), F && detach(v);
      },
    }
  );
}
function instance$2e(k, r, p) {
  const v = ["type", "tokens", "header", "rows", "ordered", "renderers"];
  let $ = compute_rest_props(r, v),
    { type: S = void 0 } = r,
    { tokens: x = void 0 } = r,
    { header: I = void 0 } = r,
    { rows: F = void 0 } = r,
    { ordered: O = !1 } = r,
    { renderers: L } = r;
  return (
    supressWarnings(),
    (k.$$set = (U) => {
      (r = assign(assign({}, r), exclude_internal_props(U))),
        p(6, ($ = compute_rest_props(r, v))),
        "type" in U && p(0, (S = U.type)),
        "tokens" in U && p(1, (x = U.tokens)),
        "header" in U && p(2, (I = U.header)),
        "rows" in U && p(3, (F = U.rows)),
        "ordered" in U && p(4, (O = U.ordered)),
        "renderers" in U && p(5, (L = U.renderers));
    }),
    [S, x, I, F, O, L, $]
  );
}
let Parser$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2e, create_fragment$2n, safe_not_equal, {
        type: 0,
        tokens: 1,
        header: 2,
        rows: 3,
        ordered: 4,
        renderers: 5,
      });
  }
};
function getDefaults() {
  return {
    async: !1,
    baseUrl: null,
    breaks: !1,
    extensions: null,
    gfm: !0,
    headerIds: !0,
    headerPrefix: "",
    highlight: null,
    langPrefix: "language-",
    mangle: !0,
    pedantic: !1,
    renderer: null,
    sanitize: !1,
    sanitizer: null,
    silent: !1,
    smartypants: !1,
    tokenizer: null,
    walkTokens: null,
    xhtml: !1,
  };
}
let defaults = getDefaults();
function changeDefaults(k) {
  defaults = k;
}
const escapeTest = /[&<>"']/,
  escapeReplace = new RegExp(escapeTest.source, "g"),
  escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
  escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g"),
  escapeReplacements = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
  },
  getEscapeReplacement = (k) => escapeReplacements[k];
function escape(k, r) {
  if (r) {
    if (escapeTest.test(k))
      return k.replace(escapeReplace, getEscapeReplacement);
  } else if (escapeTestNoEncode.test(k))
    return k.replace(escapeReplaceNoEncode, getEscapeReplacement);
  return k;
}
const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;
function unescape$1(k) {
  return k.replace(
    unescapeTest,
    (r, p) => (
      (p = p.toLowerCase()),
      p === "colon"
        ? ":"
        : p.charAt(0) === "#"
        ? p.charAt(1) === "x"
          ? String.fromCharCode(parseInt(p.substring(2), 16))
          : String.fromCharCode(+p.substring(1))
        : ""
    )
  );
}
const caret = /(^|[^\[])\^/g;
function edit(k, r) {
  (k = typeof k == "string" ? k : k.source), (r = r || "");
  const p = {
    replace: (v, $) => (
      ($ = $.source || $),
      ($ = $.replace(caret, "$1")),
      (k = k.replace(v, $)),
      p
    ),
    getRegex: () => new RegExp(k, r),
  };
  return p;
}
const nonWordAndColonTest = /[^\w:]/g,
  originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(k, r, p) {
  if (k) {
    let v;
    try {
      v = decodeURIComponent(unescape$1(p))
        .replace(nonWordAndColonTest, "")
        .toLowerCase();
    } catch {
      return null;
    }
    if (
      v.indexOf("javascript:") === 0 ||
      v.indexOf("vbscript:") === 0 ||
      v.indexOf("data:") === 0
    )
      return null;
  }
  r && !originIndependentUrl.test(p) && (p = resolveUrl(r, p));
  try {
    p = encodeURI(p).replace(/%25/g, "%");
  } catch {
    return null;
  }
  return p;
}
const baseUrls = {},
  justDomain = /^[^:]+:\/*[^/]*$/,
  protocol = /^([^:]+:)[\s\S]*$/,
  domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl(k, r) {
  baseUrls[" " + k] ||
    (justDomain.test(k)
      ? (baseUrls[" " + k] = k + "/")
      : (baseUrls[" " + k] = rtrim(k, "/", !0))),
    (k = baseUrls[" " + k]);
  const p = k.indexOf(":") === -1;
  return r.substring(0, 2) === "//"
    ? p
      ? r
      : k.replace(protocol, "$1") + r
    : r.charAt(0) === "/"
    ? p
      ? r
      : k.replace(domain, "$1") + r
    : k + r;
}
const noopTest = { exec: function k() {} };
function merge(k) {
  let r = 1,
    p,
    v;
  for (; r < arguments.length; r++) {
    p = arguments[r];
    for (v in p) Object.prototype.hasOwnProperty.call(p, v) && (k[v] = p[v]);
  }
  return k;
}
function splitCells(k, r) {
  const p = k.replace(/\|/g, (S, x, I) => {
      let F = !1,
        O = x;
      for (; --O >= 0 && I[O] === "\\"; ) F = !F;
      return F ? "|" : " |";
    }),
    v = p.split(/ \|/);
  let $ = 0;
  if (
    (v[0].trim() || v.shift(),
    v.length > 0 && !v[v.length - 1].trim() && v.pop(),
    v.length > r)
  )
    v.splice(r);
  else for (; v.length < r; ) v.push("");
  for (; $ < v.length; $++) v[$] = v[$].trim().replace(/\\\|/g, "|");
  return v;
}
function rtrim(k, r, p) {
  const v = k.length;
  if (v === 0) return "";
  let $ = 0;
  for (; $ < v; ) {
    const S = k.charAt(v - $ - 1);
    if (S === r && !p) $++;
    else if (S !== r && p) $++;
    else break;
  }
  return k.slice(0, v - $);
}
function findClosingBracket(k, r) {
  if (k.indexOf(r[1]) === -1) return -1;
  const p = k.length;
  let v = 0,
    $ = 0;
  for (; $ < p; $++)
    if (k[$] === "\\") $++;
    else if (k[$] === r[0]) v++;
    else if (k[$] === r[1] && (v--, v < 0)) return $;
  return -1;
}
function checkSanitizeDeprecation(k) {
  k &&
    k.sanitize &&
    !k.silent &&
    console.warn(
      "marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options"
    );
}
function repeatString(k, r) {
  if (r < 1) return "";
  let p = "";
  for (; r > 1; ) r & 1 && (p += k), (r >>= 1), (k += k);
  return p + k;
}
function outputLink(k, r, p, v) {
  const $ = r.href,
    S = r.title ? escape(r.title) : null,
    x = k[1].replace(/\\([\[\]])/g, "$1");
  if (k[0].charAt(0) !== "!") {
    v.state.inLink = !0;
    const I = {
      type: "link",
      raw: p,
      href: $,
      title: S,
      text: x,
      tokens: v.inlineTokens(x),
    };
    return (v.state.inLink = !1), I;
  }
  return { type: "image", raw: p, href: $, title: S, text: escape(x) };
}
function indentCodeCompensation(k, r) {
  const p = k.match(/^(\s+)(?:```)/);
  if (p === null) return r;
  const v = p[1];
  return r
    .split(
      `
`
    )
    .map(($) => {
      const S = $.match(/^\s+/);
      if (S === null) return $;
      const [x] = S;
      return x.length >= v.length ? $.slice(v.length) : $;
    }).join(`
`);
}
class Tokenizer {
  constructor(r) {
    this.options = r || defaults;
  }
  space(r) {
    const p = this.rules.block.newline.exec(r);
    if (p && p[0].length > 0) return { type: "space", raw: p[0] };
  }
  code(r) {
    const p = this.rules.block.code.exec(r);
    if (p) {
      const v = p[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: p[0],
        codeBlockStyle: "indented",
        text: this.options.pedantic
          ? v
          : rtrim(
              v,
              `
`
            ),
      };
    }
  }
  fences(r) {
    const p = this.rules.block.fences.exec(r);
    if (p) {
      const v = p[0],
        $ = indentCodeCompensation(v, p[3] || "");
      return {
        type: "code",
        raw: v,
        lang: p[2]
          ? p[2].trim().replace(this.rules.inline._escapes, "$1")
          : p[2],
        text: $,
      };
    }
  }
  heading(r) {
    const p = this.rules.block.heading.exec(r);
    if (p) {
      let v = p[2].trim();
      if (/#$/.test(v)) {
        const $ = rtrim(v, "#");
        (this.options.pedantic || !$ || / $/.test($)) && (v = $.trim());
      }
      return {
        type: "heading",
        raw: p[0],
        depth: p[1].length,
        text: v,
        tokens: this.lexer.inline(v),
      };
    }
  }
  hr(r) {
    const p = this.rules.block.hr.exec(r);
    if (p) return { type: "hr", raw: p[0] };
  }
  blockquote(r) {
    const p = this.rules.block.blockquote.exec(r);
    if (p) {
      const v = p[0].replace(/^ *>[ \t]?/gm, ""),
        $ = this.lexer.state.top;
      this.lexer.state.top = !0;
      const S = this.lexer.blockTokens(v);
      return (
        (this.lexer.state.top = $),
        { type: "blockquote", raw: p[0], tokens: S, text: v }
      );
    }
  }
  list(r) {
    let p = this.rules.block.list.exec(r);
    if (p) {
      let v,
        $,
        S,
        x,
        I,
        F,
        O,
        L,
        U,
        j,
        N,
        q,
        R = p[1].trim();
      const Q = R.length > 1,
        H = {
          type: "list",
          raw: "",
          ordered: Q,
          start: Q ? +R.slice(0, -1) : "",
          loose: !1,
          items: [],
        };
      (R = Q ? `\\d{1,9}\\${R.slice(-1)}` : `\\${R}`),
        this.options.pedantic && (R = Q ? R : "[*+-]");
      const G = new RegExp(`^( {0,3}${R})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      for (
        ;
        r && ((q = !1), !(!(p = G.exec(r)) || this.rules.block.hr.test(r)));

      ) {
        if (
          ((v = p[0]),
          (r = r.substring(v.length)),
          (L = p[2]
            .split(
              `
`,
              1
            )[0]
            .replace(/^\t+/, (K) => " ".repeat(3 * K.length))),
          (U = r.split(
            `
`,
            1
          )[0]),
          this.options.pedantic
            ? ((x = 2), (N = L.trimLeft()))
            : ((x = p[2].search(/[^ ]/)),
              (x = x > 4 ? 1 : x),
              (N = L.slice(x)),
              (x += p[1].length)),
          (F = !1),
          !L &&
            /^ *$/.test(U) &&
            ((v +=
              U +
              `
`),
            (r = r.substring(U.length + 1)),
            (q = !0)),
          !q)
        ) {
          const K = new RegExp(
              `^ {0,${Math.min(
                3,
                x - 1
              )}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`
            ),
            Y = new RegExp(
              `^ {0,${Math.min(
                3,
                x - 1
              )}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`
            ),
            J = new RegExp(`^ {0,${Math.min(3, x - 1)}}(?:\`\`\`|~~~)`),
            Z = new RegExp(`^ {0,${Math.min(3, x - 1)}}#`);
          for (
            ;
            r &&
            ((j = r.split(
              `
`,
              1
            )[0]),
            (U = j),
            this.options.pedantic &&
              (U = U.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")),
            !(J.test(U) || Z.test(U) || K.test(U) || Y.test(r)));

          ) {
            if (U.search(/[^ ]/) >= x || !U.trim())
              N +=
                `
` + U.slice(x);
            else {
              if (
                F ||
                L.search(/[^ ]/) >= 4 ||
                J.test(L) ||
                Z.test(L) ||
                Y.test(L)
              )
                break;
              N +=
                `
` + U;
            }
            !F && !U.trim() && (F = !0),
              (v +=
                j +
                `
`),
              (r = r.substring(j.length + 1)),
              (L = U.slice(x));
          }
        }
        H.loose || (O ? (H.loose = !0) : /\n *\n *$/.test(v) && (O = !0)),
          this.options.gfm &&
            (($ = /^\[[ xX]\] /.exec(N)),
            $ && ((S = $[0] !== "[ ] "), (N = N.replace(/^\[[ xX]\] +/, "")))),
          H.items.push({
            type: "list_item",
            raw: v,
            task: !!$,
            checked: S,
            loose: !1,
            text: N,
          }),
          (H.raw += v);
      }
      (H.items[H.items.length - 1].raw = v.trimRight()),
        (H.items[H.items.length - 1].text = N.trimRight()),
        (H.raw = H.raw.trimRight());
      const V = H.items.length;
      for (I = 0; I < V; I++)
        if (
          ((this.lexer.state.top = !1),
          (H.items[I].tokens = this.lexer.blockTokens(H.items[I].text, [])),
          !H.loose)
        ) {
          const K = H.items[I].tokens.filter((J) => J.type === "space"),
            Y = K.length > 0 && K.some((J) => /\n.*\n/.test(J.raw));
          H.loose = Y;
        }
      if (H.loose) for (I = 0; I < V; I++) H.items[I].loose = !0;
      return H;
    }
  }
  html(r) {
    const p = this.rules.block.html.exec(r);
    if (p) {
      const v = {
        type: "html",
        raw: p[0],
        pre:
          !this.options.sanitizer &&
          (p[1] === "pre" || p[1] === "script" || p[1] === "style"),
        text: p[0],
      };
      if (this.options.sanitize) {
        const $ = this.options.sanitizer
          ? this.options.sanitizer(p[0])
          : escape(p[0]);
        (v.type = "paragraph"), (v.text = $), (v.tokens = this.lexer.inline($));
      }
      return v;
    }
  }
  def(r) {
    const p = this.rules.block.def.exec(r);
    if (p) {
      const v = p[1].toLowerCase().replace(/\s+/g, " "),
        $ = p[2]
          ? p[2]
              .replace(/^<(.*)>$/, "$1")
              .replace(this.rules.inline._escapes, "$1")
          : "",
        S = p[3]
          ? p[3]
              .substring(1, p[3].length - 1)
              .replace(this.rules.inline._escapes, "$1")
          : p[3];
      return { type: "def", tag: v, raw: p[0], href: $, title: S };
    }
  }
  table(r) {
    const p = this.rules.block.table.exec(r);
    if (p) {
      const v = {
        type: "table",
        header: splitCells(p[1]).map(($) => ({ text: $ })),
        align: p[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows:
          p[3] && p[3].trim()
            ? p[3].replace(/\n[ \t]*$/, "").split(`
`)
            : [],
      };
      if (v.header.length === v.align.length) {
        v.raw = p[0];
        let $ = v.align.length,
          S,
          x,
          I,
          F;
        for (S = 0; S < $; S++)
          /^ *-+: *$/.test(v.align[S])
            ? (v.align[S] = "right")
            : /^ *:-+: *$/.test(v.align[S])
            ? (v.align[S] = "center")
            : /^ *:-+ *$/.test(v.align[S])
            ? (v.align[S] = "left")
            : (v.align[S] = null);
        for ($ = v.rows.length, S = 0; S < $; S++)
          v.rows[S] = splitCells(v.rows[S], v.header.length).map((O) => ({
            text: O,
          }));
        for ($ = v.header.length, x = 0; x < $; x++)
          v.header[x].tokens = this.lexer.inline(v.header[x].text);
        for ($ = v.rows.length, x = 0; x < $; x++)
          for (F = v.rows[x], I = 0; I < F.length; I++)
            F[I].tokens = this.lexer.inline(F[I].text);
        return v;
      }
    }
  }
  lheading(r) {
    const p = this.rules.block.lheading.exec(r);
    if (p)
      return {
        type: "heading",
        raw: p[0],
        depth: p[2].charAt(0) === "=" ? 1 : 2,
        text: p[1],
        tokens: this.lexer.inline(p[1]),
      };
  }
  paragraph(r) {
    const p = this.rules.block.paragraph.exec(r);
    if (p) {
      const v =
        p[1].charAt(p[1].length - 1) ===
        `
`
          ? p[1].slice(0, -1)
          : p[1];
      return {
        type: "paragraph",
        raw: p[0],
        text: v,
        tokens: this.lexer.inline(v),
      };
    }
  }
  text(r) {
    const p = this.rules.block.text.exec(r);
    if (p)
      return {
        type: "text",
        raw: p[0],
        text: p[0],
        tokens: this.lexer.inline(p[0]),
      };
  }
  escape(r) {
    const p = this.rules.inline.escape.exec(r);
    if (p) return { type: "escape", raw: p[0], text: escape(p[1]) };
  }
  tag(r) {
    const p = this.rules.inline.tag.exec(r);
    if (p)
      return (
        !this.lexer.state.inLink && /^<a /i.test(p[0])
          ? (this.lexer.state.inLink = !0)
          : this.lexer.state.inLink &&
            /^<\/a>/i.test(p[0]) &&
            (this.lexer.state.inLink = !1),
        !this.lexer.state.inRawBlock &&
        /^<(pre|code|kbd|script)(\s|>)/i.test(p[0])
          ? (this.lexer.state.inRawBlock = !0)
          : this.lexer.state.inRawBlock &&
            /^<\/(pre|code|kbd|script)(\s|>)/i.test(p[0]) &&
            (this.lexer.state.inRawBlock = !1),
        {
          type: this.options.sanitize ? "text" : "html",
          raw: p[0],
          inLink: this.lexer.state.inLink,
          inRawBlock: this.lexer.state.inRawBlock,
          text: this.options.sanitize
            ? this.options.sanitizer
              ? this.options.sanitizer(p[0])
              : escape(p[0])
            : p[0],
        }
      );
  }
  link(r) {
    const p = this.rules.inline.link.exec(r);
    if (p) {
      const v = p[2].trim();
      if (!this.options.pedantic && /^</.test(v)) {
        if (!/>$/.test(v)) return;
        const x = rtrim(v.slice(0, -1), "\\");
        if ((v.length - x.length) % 2 === 0) return;
      } else {
        const x = findClosingBracket(p[2], "()");
        if (x > -1) {
          const F = (p[0].indexOf("!") === 0 ? 5 : 4) + p[1].length + x;
          (p[2] = p[2].substring(0, x)),
            (p[0] = p[0].substring(0, F).trim()),
            (p[3] = "");
        }
      }
      let $ = p[2],
        S = "";
      if (this.options.pedantic) {
        const x = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec($);
        x && (($ = x[1]), (S = x[3]));
      } else S = p[3] ? p[3].slice(1, -1) : "";
      return (
        ($ = $.trim()),
        /^</.test($) &&
          (this.options.pedantic && !/>$/.test(v)
            ? ($ = $.slice(1))
            : ($ = $.slice(1, -1))),
        outputLink(
          p,
          {
            href: $ && $.replace(this.rules.inline._escapes, "$1"),
            title: S && S.replace(this.rules.inline._escapes, "$1"),
          },
          p[0],
          this.lexer
        )
      );
    }
  }
  reflink(r, p) {
    let v;
    if (
      (v = this.rules.inline.reflink.exec(r)) ||
      (v = this.rules.inline.nolink.exec(r))
    ) {
      let $ = (v[2] || v[1]).replace(/\s+/g, " ");
      if ((($ = p[$.toLowerCase()]), !$)) {
        const S = v[0].charAt(0);
        return { type: "text", raw: S, text: S };
      }
      return outputLink(v, $, v[0], this.lexer);
    }
  }
  emStrong(r, p, v = "") {
    let $ = this.rules.inline.emStrong.lDelim.exec(r);
    if (!$ || ($[3] && v.match(/[\p{L}\p{N}]/u))) return;
    const S = $[1] || $[2] || "";
    if (!S || (S && (v === "" || this.rules.inline.punctuation.exec(v)))) {
      const x = $[0].length - 1;
      let I,
        F,
        O = x,
        L = 0;
      const U =
        $[0][0] === "*"
          ? this.rules.inline.emStrong.rDelimAst
          : this.rules.inline.emStrong.rDelimUnd;
      for (
        U.lastIndex = 0, p = p.slice(-1 * r.length + x);
        ($ = U.exec(p)) != null;

      ) {
        if (((I = $[1] || $[2] || $[3] || $[4] || $[5] || $[6]), !I)) continue;
        if (((F = I.length), $[3] || $[4])) {
          O += F;
          continue;
        } else if (($[5] || $[6]) && x % 3 && !((x + F) % 3)) {
          L += F;
          continue;
        }
        if (((O -= F), O > 0)) continue;
        F = Math.min(F, F + O + L);
        const j = r.slice(0, x + $.index + ($[0].length - I.length) + F);
        if (Math.min(x, F) % 2) {
          const q = j.slice(1, -1);
          return {
            type: "em",
            raw: j,
            text: q,
            tokens: this.lexer.inlineTokens(q),
          };
        }
        const N = j.slice(2, -2);
        return {
          type: "strong",
          raw: j,
          text: N,
          tokens: this.lexer.inlineTokens(N),
        };
      }
    }
  }
  codespan(r) {
    const p = this.rules.inline.code.exec(r);
    if (p) {
      let v = p[2].replace(/\n/g, " ");
      const $ = /[^ ]/.test(v),
        S = /^ /.test(v) && / $/.test(v);
      return (
        $ && S && (v = v.substring(1, v.length - 1)),
        (v = escape(v, !0)),
        { type: "codespan", raw: p[0], text: v }
      );
    }
  }
  br(r) {
    const p = this.rules.inline.br.exec(r);
    if (p) return { type: "br", raw: p[0] };
  }
  del(r) {
    const p = this.rules.inline.del.exec(r);
    if (p)
      return {
        type: "del",
        raw: p[0],
        text: p[2],
        tokens: this.lexer.inlineTokens(p[2]),
      };
  }
  autolink(r, p) {
    const v = this.rules.inline.autolink.exec(r);
    if (v) {
      let $, S;
      return (
        v[2] === "@"
          ? (($ = escape(this.options.mangle ? p(v[1]) : v[1])),
            (S = "mailto:" + $))
          : (($ = escape(v[1])), (S = $)),
        {
          type: "link",
          raw: v[0],
          text: $,
          href: S,
          tokens: [{ type: "text", raw: $, text: $ }],
        }
      );
    }
  }
  url(r, p) {
    let v;
    if ((v = this.rules.inline.url.exec(r))) {
      let $, S;
      if (v[2] === "@")
        ($ = escape(this.options.mangle ? p(v[0]) : v[0])), (S = "mailto:" + $);
      else {
        let x;
        do (x = v[0]), (v[0] = this.rules.inline._backpedal.exec(v[0])[0]);
        while (x !== v[0]);
        ($ = escape(v[0])),
          v[1] === "www." ? (S = "http://" + v[0]) : (S = v[0]);
      }
      return {
        type: "link",
        raw: v[0],
        text: $,
        href: S,
        tokens: [{ type: "text", raw: $, text: $ }],
      };
    }
  }
  inlineText(r, p) {
    const v = this.rules.inline.text.exec(r);
    if (v) {
      let $;
      return (
        this.lexer.state.inRawBlock
          ? ($ = this.options.sanitize
              ? this.options.sanitizer
                ? this.options.sanitizer(v[0])
                : escape(v[0])
              : v[0])
          : ($ = escape(this.options.smartypants ? p(v[0]) : v[0])),
        { type: "text", raw: v[0], text: $ }
      );
    }
  }
}
const block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences:
    /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  _paragraph:
    /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/,
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def)
  .replace("label", block._label)
  .replace("title", block._title)
  .getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */)
  .replace("bull", block.bullet)
  .getRegex();
block.list = edit(block.list)
  .replace(/bull/g, block.bullet)
  .replace(
    "hr",
    "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))"
  )
  .replace("def", "\\n+(?=" + block.def.source + ")")
  .getRegex();
block._tag =
  "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i")
  .replace("comment", block._comment)
  .replace("tag", block._tag)
  .replace(
    "attribute",
    / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/
  )
  .getRegex();
block.paragraph = edit(block._paragraph)
  .replace("hr", block.hr)
  .replace("heading", " {0,3}#{1,6} ")
  .replace("|lheading", "")
  .replace("|table", "")
  .replace("blockquote", " {0,3}>")
  .replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
  .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
  .replace(
    "html",
    "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)"
  )
  .replace("tag", block._tag)
  .getRegex();
block.blockquote = edit(block.blockquote)
  .replace("paragraph", block.paragraph)
  .getRegex();
block.normal = merge({}, block);
block.gfm = merge({}, block.normal, {
  table:
    "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)",
});
block.gfm.table = edit(block.gfm.table)
  .replace("hr", block.hr)
  .replace("heading", " {0,3}#{1,6} ")
  .replace("blockquote", " {0,3}>")
  .replace("code", " {4}[^\\n]")
  .replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
  .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
  .replace(
    "html",
    "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)"
  )
  .replace("tag", block._tag)
  .getRegex();
block.gfm.paragraph = edit(block._paragraph)
  .replace("hr", block.hr)
  .replace("heading", " {0,3}#{1,6} ")
  .replace("|lheading", "")
  .replace("table", block.gfm.table)
  .replace("blockquote", " {0,3}>")
  .replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
  .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
  .replace(
    "html",
    "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)"
  )
  .replace("tag", block._tag)
  .getRegex();
block.pedantic = merge({}, block.normal, {
  html: edit(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  )
    .replace("comment", block._comment)
    .replace(
      /tag/g,
      "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b"
    )
    .getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph)
    .replace("hr", block.hr)
    .replace(
      "heading",
      ` *#{1,6} *[^
]`
    )
    .replace("lheading", block.lheading)
    .replace("blockquote", " {0,3}>")
    .replace("|fences", "")
    .replace("|list", "")
    .replace("|html", "")
    .getRegex(),
});
const inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    rDelimAst:
      /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd:
      /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/,
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/,
};
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
inline.punctuation = edit(inline.punctuation)
  .replace(/punctuation/g, inline._punctuation)
  .getRegex();
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim)
  .replace(/punct/g, inline._punctuation)
  .getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g")
  .replace(/punct/g, inline._punctuation)
  .getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g")
  .replace(/punct/g, inline._punctuation)
  .getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email =
  /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink)
  .replace("scheme", inline._scheme)
  .replace("email", inline._email)
  .getRegex();
inline._attribute =
  /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag)
  .replace("comment", inline._comment)
  .replace("attribute", inline._attribute)
  .getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link)
  .replace("label", inline._label)
  .replace("href", inline._href)
  .replace("title", inline._title)
  .getRegex();
inline.reflink = edit(inline.reflink)
  .replace("label", inline._label)
  .replace("ref", block._label)
  .getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g")
  .replace("reflink", inline.reflink)
  .replace("nolink", inline.nolink)
  .getRegex();
inline.normal = merge({}, inline);
inline.pedantic = merge({}, inline.normal, {
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g,
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g,
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/)
    .replace("label", inline._label)
    .getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
    .replace("label", inline._label)
    .getRegex(),
});
inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email:
    /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal:
    /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
});
inline.gfm.url = edit(inline.gfm.url, "i")
  .replace("email", inline.gfm._extended_email)
  .getRegex();
inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text)
    .replace("\\b_", "\\b_| {2,}\\n")
    .replace(/\{2,\}/g, "*")
    .getRegex(),
});
function smartypants(k) {
  return k
    .replace(/---/g, "")
    .replace(/--/g, "")
    .replace(/(^|[-\u2014/(\[{"\s])'/g, "$1")
    .replace(/'/g, "")
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1")
    .replace(/"/g, "")
    .replace(/\.{3}/g, "");
}
function mangle(k) {
  let r = "",
    p,
    v;
  const $ = k.length;
  for (p = 0; p < $; p++)
    (v = k.charCodeAt(p)),
      Math.random() > 0.5 && (v = "x" + v.toString(16)),
      (r += "&#" + v + ";");
  return r;
}
class Lexer {
  constructor(r) {
    (this.tokens = []),
      (this.tokens.links = Object.create(null)),
      (this.options = r || defaults),
      (this.options.tokenizer = this.options.tokenizer || new Tokenizer()),
      (this.tokenizer = this.options.tokenizer),
      (this.tokenizer.options = this.options),
      (this.tokenizer.lexer = this),
      (this.inlineQueue = []),
      (this.state = { inLink: !1, inRawBlock: !1, top: !0 });
    const p = { block: block.normal, inline: inline.normal };
    this.options.pedantic
      ? ((p.block = block.pedantic), (p.inline = inline.pedantic))
      : this.options.gfm &&
        ((p.block = block.gfm),
        this.options.breaks
          ? (p.inline = inline.breaks)
          : (p.inline = inline.gfm)),
      (this.tokenizer.rules = p);
  }
  static get rules() {
    return { block, inline };
  }
  static lex(r, p) {
    return new Lexer(p).lex(r);
  }
  static lexInline(r, p) {
    return new Lexer(p).inlineTokens(r);
  }
  lex(r) {
    (r = r.replace(
      /\r\n|\r/g,
      `
`
    )),
      this.blockTokens(r, this.tokens);
    let p;
    for (; (p = this.inlineQueue.shift()); ) this.inlineTokens(p.src, p.tokens);
    return this.tokens;
  }
  blockTokens(r, p = []) {
    this.options.pedantic
      ? (r = r.replace(/\t/g, "    ").replace(/^ +$/gm, ""))
      : (r = r.replace(
          /^( *)(\t+)/gm,
          (I, F, O) => F + "    ".repeat(O.length)
        ));
    let v, $, S, x;
    for (; r; )
      if (
        !(
          this.options.extensions &&
          this.options.extensions.block &&
          this.options.extensions.block.some((I) =>
            (v = I.call({ lexer: this }, r, p))
              ? ((r = r.substring(v.raw.length)), p.push(v), !0)
              : !1
          )
        )
      ) {
        if ((v = this.tokenizer.space(r))) {
          (r = r.substring(v.raw.length)),
            v.raw.length === 1 && p.length > 0
              ? (p[p.length - 1].raw += `
`)
              : p.push(v);
          continue;
        }
        if ((v = this.tokenizer.code(r))) {
          (r = r.substring(v.raw.length)),
            ($ = p[p.length - 1]),
            $ && ($.type === "paragraph" || $.type === "text")
              ? (($.raw +=
                  `
` + v.raw),
                ($.text +=
                  `
` + v.text),
                (this.inlineQueue[this.inlineQueue.length - 1].src = $.text))
              : p.push(v);
          continue;
        }
        if ((v = this.tokenizer.fences(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.heading(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.hr(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.blockquote(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.list(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.html(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.def(r))) {
          (r = r.substring(v.raw.length)),
            ($ = p[p.length - 1]),
            $ && ($.type === "paragraph" || $.type === "text")
              ? (($.raw +=
                  `
` + v.raw),
                ($.text +=
                  `
` + v.raw),
                (this.inlineQueue[this.inlineQueue.length - 1].src = $.text))
              : this.tokens.links[v.tag] ||
                (this.tokens.links[v.tag] = { href: v.href, title: v.title });
          continue;
        }
        if ((v = this.tokenizer.table(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.lheading(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if (
          ((S = r),
          this.options.extensions && this.options.extensions.startBlock)
        ) {
          let I = 1 / 0;
          const F = r.slice(1);
          let O;
          this.options.extensions.startBlock.forEach(function (L) {
            (O = L.call({ lexer: this }, F)),
              typeof O == "number" && O >= 0 && (I = Math.min(I, O));
          }),
            I < 1 / 0 && I >= 0 && (S = r.substring(0, I + 1));
        }
        if (this.state.top && (v = this.tokenizer.paragraph(S))) {
          ($ = p[p.length - 1]),
            x && $.type === "paragraph"
              ? (($.raw +=
                  `
` + v.raw),
                ($.text +=
                  `
` + v.text),
                this.inlineQueue.pop(),
                (this.inlineQueue[this.inlineQueue.length - 1].src = $.text))
              : p.push(v),
            (x = S.length !== r.length),
            (r = r.substring(v.raw.length));
          continue;
        }
        if ((v = this.tokenizer.text(r))) {
          (r = r.substring(v.raw.length)),
            ($ = p[p.length - 1]),
            $ && $.type === "text"
              ? (($.raw +=
                  `
` + v.raw),
                ($.text +=
                  `
` + v.text),
                this.inlineQueue.pop(),
                (this.inlineQueue[this.inlineQueue.length - 1].src = $.text))
              : p.push(v);
          continue;
        }
        if (r) {
          const I = "Infinite loop on byte: " + r.charCodeAt(0);
          if (this.options.silent) {
            console.error(I);
            break;
          } else throw new Error(I);
        }
      }
    return (this.state.top = !0), p;
  }
  inline(r, p = []) {
    return this.inlineQueue.push({ src: r, tokens: p }), p;
  }
  inlineTokens(r, p = []) {
    let v,
      $,
      S,
      x = r,
      I,
      F,
      O;
    if (this.tokens.links) {
      const L = Object.keys(this.tokens.links);
      if (L.length > 0)
        for (
          ;
          (I = this.tokenizer.rules.inline.reflinkSearch.exec(x)) != null;

        )
          L.includes(I[0].slice(I[0].lastIndexOf("[") + 1, -1)) &&
            (x =
              x.slice(0, I.index) +
              "[" +
              repeatString("a", I[0].length - 2) +
              "]" +
              x.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (I = this.tokenizer.rules.inline.blockSkip.exec(x)) != null; )
      x =
        x.slice(0, I.index) +
        "[" +
        repeatString("a", I[0].length - 2) +
        "]" +
        x.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    for (; (I = this.tokenizer.rules.inline.escapedEmSt.exec(x)) != null; )
      (x =
        x.slice(0, I.index + I[0].length - 2) +
        "++" +
        x.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex)),
        this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    for (; r; )
      if (
        (F || (O = ""),
        (F = !1),
        !(
          this.options.extensions &&
          this.options.extensions.inline &&
          this.options.extensions.inline.some((L) =>
            (v = L.call({ lexer: this }, r, p))
              ? ((r = r.substring(v.raw.length)), p.push(v), !0)
              : !1
          )
        ))
      ) {
        if ((v = this.tokenizer.escape(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.tag(r))) {
          (r = r.substring(v.raw.length)),
            ($ = p[p.length - 1]),
            $ && v.type === "text" && $.type === "text"
              ? (($.raw += v.raw), ($.text += v.text))
              : p.push(v);
          continue;
        }
        if ((v = this.tokenizer.link(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.reflink(r, this.tokens.links))) {
          (r = r.substring(v.raw.length)),
            ($ = p[p.length - 1]),
            $ && v.type === "text" && $.type === "text"
              ? (($.raw += v.raw), ($.text += v.text))
              : p.push(v);
          continue;
        }
        if ((v = this.tokenizer.emStrong(r, x, O))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.codespan(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.br(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.del(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.autolink(r, mangle))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if (!this.state.inLink && (v = this.tokenizer.url(r, mangle))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if (
          ((S = r),
          this.options.extensions && this.options.extensions.startInline)
        ) {
          let L = 1 / 0;
          const U = r.slice(1);
          let j;
          this.options.extensions.startInline.forEach(function (N) {
            (j = N.call({ lexer: this }, U)),
              typeof j == "number" && j >= 0 && (L = Math.min(L, j));
          }),
            L < 1 / 0 && L >= 0 && (S = r.substring(0, L + 1));
        }
        if ((v = this.tokenizer.inlineText(S, smartypants))) {
          (r = r.substring(v.raw.length)),
            v.raw.slice(-1) !== "_" && (O = v.raw.slice(-1)),
            (F = !0),
            ($ = p[p.length - 1]),
            $ && $.type === "text"
              ? (($.raw += v.raw), ($.text += v.text))
              : p.push(v);
          continue;
        }
        if (r) {
          const L = "Infinite loop on byte: " + r.charCodeAt(0);
          if (this.options.silent) {
            console.error(L);
            break;
          } else throw new Error(L);
        }
      }
    return p;
  }
}
class Renderer {
  constructor(r) {
    this.options = r || defaults;
  }
  code(r, p, v) {
    const $ = (p || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const S = this.options.highlight(r, $);
      S != null && S !== r && ((v = !0), (r = S));
    }
    return (
      (r =
        r.replace(/\n$/, "") +
        `
`),
      $
        ? '<pre><code class="' +
          this.options.langPrefix +
          escape($) +
          '">' +
          (v ? r : escape(r, !0)) +
          `</code></pre>
`
        : "<pre><code>" +
          (v ? r : escape(r, !0)) +
          `</code></pre>
`
    );
  }
  blockquote(r) {
    return `<blockquote>
${r}</blockquote>
`;
  }
  html(r) {
    return r;
  }
  heading(r, p, v, $) {
    if (this.options.headerIds) {
      const S = this.options.headerPrefix + $.slug(v);
      return `<h${p} id="${S}">${r}</h${p}>
`;
    }
    return `<h${p}>${r}</h${p}>
`;
  }
  hr() {
    return this.options.xhtml
      ? `<hr/>
`
      : `<hr>
`;
  }
  list(r, p, v) {
    const $ = p ? "ol" : "ul",
      S = p && v !== 1 ? ' start="' + v + '"' : "";
    return (
      "<" +
      $ +
      S +
      `>
` +
      r +
      "</" +
      $ +
      `>
`
    );
  }
  listitem(r) {
    return `<li>${r}</li>
`;
  }
  checkbox(r) {
    return (
      "<input " +
      (r ? 'checked="" ' : "") +
      'disabled="" type="checkbox"' +
      (this.options.xhtml ? " /" : "") +
      "> "
    );
  }
  paragraph(r) {
    return `<p>${r}</p>
`;
  }
  table(r, p) {
    return (
      p && (p = `<tbody>${p}</tbody>`),
      `<table>
<thead>
` +
        r +
        `</thead>
` +
        p +
        `</table>
`
    );
  }
  tablerow(r) {
    return `<tr>
${r}</tr>
`;
  }
  tablecell(r, p) {
    const v = p.header ? "th" : "td";
    return (
      (p.align ? `<${v} align="${p.align}">` : `<${v}>`) +
      r +
      `</${v}>
`
    );
  }
  strong(r) {
    return `<strong>${r}</strong>`;
  }
  em(r) {
    return `<em>${r}</em>`;
  }
  codespan(r) {
    return `<code>${r}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  del(r) {
    return `<del>${r}</del>`;
  }
  link(r, p, v) {
    if (
      ((r = cleanUrl(this.options.sanitize, this.options.baseUrl, r)),
      r === null)
    )
      return v;
    let $ = '<a href="' + r + '"';
    return p && ($ += ' title="' + p + '"'), ($ += ">" + v + "</a>"), $;
  }
  image(r, p, v) {
    if (
      ((r = cleanUrl(this.options.sanitize, this.options.baseUrl, r)),
      r === null)
    )
      return v;
    let $ = `<img src="${r}" alt="${v}"`;
    return (
      p && ($ += ` title="${p}"`), ($ += this.options.xhtml ? "/>" : ">"), $
    );
  }
  text(r) {
    return r;
  }
}
class TextRenderer {
  strong(r) {
    return r;
  }
  em(r) {
    return r;
  }
  codespan(r) {
    return r;
  }
  del(r) {
    return r;
  }
  html(r) {
    return r;
  }
  text(r) {
    return r;
  }
  link(r, p, v) {
    return "" + v;
  }
  image(r, p, v) {
    return "" + v;
  }
  br() {
    return "";
  }
}
class Slugger {
  constructor() {
    this.seen = {};
  }
  serialize(r) {
    return r
      .toLowerCase()
      .trim()
      .replace(/<[!\/a-z].*?>/gi, "")
      .replace(
        /[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g,
        ""
      )
      .replace(/\s/g, "-");
  }
  getNextSafeSlug(r, p) {
    let v = r,
      $ = 0;
    if (this.seen.hasOwnProperty(v)) {
      $ = this.seen[r];
      do $++, (v = r + "-" + $);
      while (this.seen.hasOwnProperty(v));
    }
    return p || ((this.seen[r] = $), (this.seen[v] = 0)), v;
  }
  slug(r, p = {}) {
    const v = this.serialize(r);
    return this.getNextSafeSlug(v, p.dryrun);
  }
}
class Parser {
  constructor(r) {
    (this.options = r || defaults),
      (this.options.renderer = this.options.renderer || new Renderer()),
      (this.renderer = this.options.renderer),
      (this.renderer.options = this.options),
      (this.textRenderer = new TextRenderer()),
      (this.slugger = new Slugger());
  }
  static parse(r, p) {
    return new Parser(p).parse(r);
  }
  static parseInline(r, p) {
    return new Parser(p).parseInline(r);
  }
  parse(r, p = !0) {
    let v = "",
      $,
      S,
      x,
      I,
      F,
      O,
      L,
      U,
      j,
      N,
      q,
      R,
      Q,
      H,
      G,
      V,
      K,
      Y,
      J;
    const Z = r.length;
    for ($ = 0; $ < Z; $++) {
      if (
        ((N = r[$]),
        this.options.extensions &&
          this.options.extensions.renderers &&
          this.options.extensions.renderers[N.type] &&
          ((J = this.options.extensions.renderers[N.type].call(
            { parser: this },
            N
          )),
          J !== !1 ||
            ![
              "space",
              "hr",
              "heading",
              "code",
              "table",
              "blockquote",
              "list",
              "html",
              "paragraph",
              "text",
            ].includes(N.type)))
      ) {
        v += J || "";
        continue;
      }
      switch (N.type) {
        case "space":
          continue;
        case "hr": {
          v += this.renderer.hr();
          continue;
        }
        case "heading": {
          v += this.renderer.heading(
            this.parseInline(N.tokens),
            N.depth,
            unescape$1(this.parseInline(N.tokens, this.textRenderer)),
            this.slugger
          );
          continue;
        }
        case "code": {
          v += this.renderer.code(N.text, N.lang, N.escaped);
          continue;
        }
        case "table": {
          for (U = "", L = "", I = N.header.length, S = 0; S < I; S++)
            L += this.renderer.tablecell(this.parseInline(N.header[S].tokens), {
              header: !0,
              align: N.align[S],
            });
          for (
            U += this.renderer.tablerow(L), j = "", I = N.rows.length, S = 0;
            S < I;
            S++
          ) {
            for (O = N.rows[S], L = "", F = O.length, x = 0; x < F; x++)
              L += this.renderer.tablecell(this.parseInline(O[x].tokens), {
                header: !1,
                align: N.align[x],
              });
            j += this.renderer.tablerow(L);
          }
          v += this.renderer.table(U, j);
          continue;
        }
        case "blockquote": {
          (j = this.parse(N.tokens)), (v += this.renderer.blockquote(j));
          continue;
        }
        case "list": {
          for (
            q = N.ordered,
              R = N.start,
              Q = N.loose,
              I = N.items.length,
              j = "",
              S = 0;
            S < I;
            S++
          )
            (G = N.items[S]),
              (V = G.checked),
              (K = G.task),
              (H = ""),
              G.task &&
                ((Y = this.renderer.checkbox(V)),
                Q
                  ? G.tokens.length > 0 && G.tokens[0].type === "paragraph"
                    ? ((G.tokens[0].text = Y + " " + G.tokens[0].text),
                      G.tokens[0].tokens &&
                        G.tokens[0].tokens.length > 0 &&
                        G.tokens[0].tokens[0].type === "text" &&
                        (G.tokens[0].tokens[0].text =
                          Y + " " + G.tokens[0].tokens[0].text))
                    : G.tokens.unshift({ type: "text", text: Y })
                  : (H += Y)),
              (H += this.parse(G.tokens, Q)),
              (j += this.renderer.listitem(H, K, V));
          v += this.renderer.list(j, q, R);
          continue;
        }
        case "html": {
          v += this.renderer.html(N.text);
          continue;
        }
        case "paragraph": {
          v += this.renderer.paragraph(this.parseInline(N.tokens));
          continue;
        }
        case "text": {
          for (
            j = N.tokens ? this.parseInline(N.tokens) : N.text;
            $ + 1 < Z && r[$ + 1].type === "text";

          )
            (N = r[++$]),
              (j +=
                `
` + (N.tokens ? this.parseInline(N.tokens) : N.text));
          v += p ? this.renderer.paragraph(j) : j;
          continue;
        }
        default: {
          const X = 'Token with "' + N.type + '" type was not found.';
          if (this.options.silent) {
            console.error(X);
            return;
          } else throw new Error(X);
        }
      }
    }
    return v;
  }
  parseInline(r, p) {
    p = p || this.renderer;
    let v = "",
      $,
      S,
      x;
    const I = r.length;
    for ($ = 0; $ < I; $++) {
      if (
        ((S = r[$]),
        this.options.extensions &&
          this.options.extensions.renderers &&
          this.options.extensions.renderers[S.type] &&
          ((x = this.options.extensions.renderers[S.type].call(
            { parser: this },
            S
          )),
          x !== !1 ||
            ![
              "escape",
              "html",
              "link",
              "image",
              "strong",
              "em",
              "codespan",
              "br",
              "del",
              "text",
            ].includes(S.type)))
      ) {
        v += x || "";
        continue;
      }
      switch (S.type) {
        case "escape": {
          v += p.text(S.text);
          break;
        }
        case "html": {
          v += p.html(S.text);
          break;
        }
        case "link": {
          v += p.link(S.href, S.title, this.parseInline(S.tokens, p));
          break;
        }
        case "image": {
          v += p.image(S.href, S.title, S.text);
          break;
        }
        case "strong": {
          v += p.strong(this.parseInline(S.tokens, p));
          break;
        }
        case "em": {
          v += p.em(this.parseInline(S.tokens, p));
          break;
        }
        case "codespan": {
          v += p.codespan(S.text);
          break;
        }
        case "br": {
          v += p.br();
          break;
        }
        case "del": {
          v += p.del(this.parseInline(S.tokens, p));
          break;
        }
        case "text": {
          v += p.text(S.text);
          break;
        }
        default: {
          const F = 'Token with "' + S.type + '" type was not found.';
          if (this.options.silent) {
            console.error(F);
            return;
          } else throw new Error(F);
        }
      }
    }
    return v;
  }
}
function marked(k, r, p) {
  if (typeof k > "u" || k === null)
    throw new Error("marked(): input parameter is undefined or null");
  if (typeof k != "string")
    throw new Error(
      "marked(): input parameter is of type " +
        Object.prototype.toString.call(k) +
        ", string expected"
    );
  if (
    (typeof r == "function" && ((p = r), (r = null)),
    (r = merge({}, marked.defaults, r || {})),
    checkSanitizeDeprecation(r),
    p)
  ) {
    const $ = r.highlight;
    let S;
    try {
      S = Lexer.lex(k, r);
    } catch (F) {
      return p(F);
    }
    const x = function (F) {
      let O;
      if (!F)
        try {
          r.walkTokens && marked.walkTokens(S, r.walkTokens),
            (O = Parser.parse(S, r));
        } catch (L) {
          F = L;
        }
      return (r.highlight = $), F ? p(F) : p(null, O);
    };
    if (!$ || $.length < 3 || (delete r.highlight, !S.length)) return x();
    let I = 0;
    marked.walkTokens(S, function (F) {
      F.type === "code" &&
        (I++,
        setTimeout(() => {
          $(F.text, F.lang, function (O, L) {
            if (O) return x(O);
            L != null && L !== F.text && ((F.text = L), (F.escaped = !0)),
              I--,
              I === 0 && x();
          });
        }, 0));
    }),
      I === 0 && x();
    return;
  }
  function v($) {
    if (
      (($.message += `
Please report this to https://github.com/markedjs/marked.`),
      r.silent)
    )
      return (
        "<p>An error occurred:</p><pre>" + escape($.message + "", !0) + "</pre>"
      );
    throw $;
  }
  try {
    const $ = Lexer.lex(k, r);
    if (r.walkTokens) {
      if (r.async)
        return Promise.all(marked.walkTokens($, r.walkTokens))
          .then(() => Parser.parse($, r))
          .catch(v);
      marked.walkTokens($, r.walkTokens);
    }
    return Parser.parse($, r);
  } catch ($) {
    v($);
  }
}
marked.options = marked.setOptions = function (k) {
  return merge(marked.defaults, k), changeDefaults(marked.defaults), marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults;
marked.use = function (...k) {
  const r = marked.defaults.extensions || { renderers: {}, childTokens: {} };
  k.forEach((p) => {
    const v = merge({}, p);
    if (
      ((v.async = marked.defaults.async || v.async),
      p.extensions &&
        (p.extensions.forEach(($) => {
          if (!$.name) throw new Error("extension name required");
          if ($.renderer) {
            const S = r.renderers[$.name];
            S
              ? (r.renderers[$.name] = function (...x) {
                  let I = $.renderer.apply(this, x);
                  return I === !1 && (I = S.apply(this, x)), I;
                })
              : (r.renderers[$.name] = $.renderer);
          }
          if ($.tokenizer) {
            if (!$.level || ($.level !== "block" && $.level !== "inline"))
              throw new Error("extension level must be 'block' or 'inline'");
            r[$.level]
              ? r[$.level].unshift($.tokenizer)
              : (r[$.level] = [$.tokenizer]),
              $.start &&
                ($.level === "block"
                  ? r.startBlock
                    ? r.startBlock.push($.start)
                    : (r.startBlock = [$.start])
                  : $.level === "inline" &&
                    (r.startInline
                      ? r.startInline.push($.start)
                      : (r.startInline = [$.start])));
          }
          $.childTokens && (r.childTokens[$.name] = $.childTokens);
        }),
        (v.extensions = r)),
      p.renderer)
    ) {
      const $ = marked.defaults.renderer || new Renderer();
      for (const S in p.renderer) {
        const x = $[S];
        $[S] = (...I) => {
          let F = p.renderer[S].apply($, I);
          return F === !1 && (F = x.apply($, I)), F;
        };
      }
      v.renderer = $;
    }
    if (p.tokenizer) {
      const $ = marked.defaults.tokenizer || new Tokenizer();
      for (const S in p.tokenizer) {
        const x = $[S];
        $[S] = (...I) => {
          let F = p.tokenizer[S].apply($, I);
          return F === !1 && (F = x.apply($, I)), F;
        };
      }
      v.tokenizer = $;
    }
    if (p.walkTokens) {
      const $ = marked.defaults.walkTokens;
      v.walkTokens = function (S) {
        let x = [];
        return (
          x.push(p.walkTokens.call(this, S)),
          $ && (x = x.concat($.call(this, S))),
          x
        );
      };
    }
    marked.setOptions(v);
  });
};
marked.walkTokens = function (k, r) {
  let p = [];
  for (const v of k)
    switch (((p = p.concat(r.call(marked, v))), v.type)) {
      case "table": {
        for (const $ of v.header) p = p.concat(marked.walkTokens($.tokens, r));
        for (const $ of v.rows)
          for (const S of $) p = p.concat(marked.walkTokens(S.tokens, r));
        break;
      }
      case "list": {
        p = p.concat(marked.walkTokens(v.items, r));
        break;
      }
      default:
        marked.defaults.extensions &&
        marked.defaults.extensions.childTokens &&
        marked.defaults.extensions.childTokens[v.type]
          ? marked.defaults.extensions.childTokens[v.type].forEach(function (
              $
            ) {
              p = p.concat(marked.walkTokens(v[$], r));
            })
          : v.tokens && (p = p.concat(marked.walkTokens(v.tokens, r)));
    }
  return p;
};
marked.parseInline = function (k, r) {
  if (typeof k > "u" || k === null)
    throw new Error(
      "marked.parseInline(): input parameter is undefined or null"
    );
  if (typeof k != "string")
    throw new Error(
      "marked.parseInline(): input parameter is of type " +
        Object.prototype.toString.call(k) +
        ", string expected"
    );
  (r = merge({}, marked.defaults, r || {})), checkSanitizeDeprecation(r);
  try {
    const p = Lexer.lexInline(k, r);
    return (
      r.walkTokens && marked.walkTokens(p, r.walkTokens),
      Parser.parseInline(p, r)
    );
  } catch (p) {
    if (
      ((p.message += `
Please report this to https://github.com/markedjs/marked.`),
      r.silent)
    )
      return (
        "<p>An error occurred:</p><pre>" + escape(p.message + "", !0) + "</pre>"
      );
    throw p;
  }
};
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.parse = marked;
marked.options;
marked.setOptions;
marked.use;
marked.walkTokens;
marked.parseInline;
Parser.parse;
Lexer.lex;
const key = {};
function create_else_block$i(k) {
  let r;
  return {
    c() {
      r = text(k[1]);
    },
    m(p, v) {
      insert(p, r, v);
    },
    p(p, v) {
      v & 2 && set_data(r, p[1]);
    },
    i: noop$1,
    o: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
function create_if_block_5(k) {
  let r, p;
  const v = k[5].default,
    $ = create_slot(v, k, k[4], null);
  return {
    c() {
      (r = element("h6")), $ && $.c(), attr(r, "id", k[2]);
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, x) {
      $ &&
        $.p &&
        (!p || x & 16) &&
        update_slot_base(
          $,
          v,
          S,
          S[4],
          p
            ? get_slot_changes(v, S[4], x, null)
            : get_all_dirty_from_scope(S[4]),
          null
        ),
        (!p || x & 4) && attr(r, "id", S[2]);
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function create_if_block_4(k) {
  let r, p;
  const v = k[5].default,
    $ = create_slot(v, k, k[4], null);
  return {
    c() {
      (r = element("h5")), $ && $.c(), attr(r, "id", k[2]);
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, x) {
      $ &&
        $.p &&
        (!p || x & 16) &&
        update_slot_base(
          $,
          v,
          S,
          S[4],
          p
            ? get_slot_changes(v, S[4], x, null)
            : get_all_dirty_from_scope(S[4]),
          null
        ),
        (!p || x & 4) && attr(r, "id", S[2]);
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function create_if_block_3(k) {
  let r, p;
  const v = k[5].default,
    $ = create_slot(v, k, k[4], null);
  return {
    c() {
      (r = element("h4")), $ && $.c(), attr(r, "id", k[2]);
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, x) {
      $ &&
        $.p &&
        (!p || x & 16) &&
        update_slot_base(
          $,
          v,
          S,
          S[4],
          p
            ? get_slot_changes(v, S[4], x, null)
            : get_all_dirty_from_scope(S[4]),
          null
        ),
        (!p || x & 4) && attr(r, "id", S[2]);
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function create_if_block_2$2(k) {
  let r, p;
  const v = k[5].default,
    $ = create_slot(v, k, k[4], null);
  return {
    c() {
      (r = element("h3")), $ && $.c(), attr(r, "id", k[2]);
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, x) {
      $ &&
        $.p &&
        (!p || x & 16) &&
        update_slot_base(
          $,
          v,
          S,
          S[4],
          p
            ? get_slot_changes(v, S[4], x, null)
            : get_all_dirty_from_scope(S[4]),
          null
        ),
        (!p || x & 4) && attr(r, "id", S[2]);
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function create_if_block_1$g(k) {
  let r, p;
  const v = k[5].default,
    $ = create_slot(v, k, k[4], null);
  return {
    c() {
      (r = element("h2")), $ && $.c(), attr(r, "id", k[2]);
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, x) {
      $ &&
        $.p &&
        (!p || x & 16) &&
        update_slot_base(
          $,
          v,
          S,
          S[4],
          p
            ? get_slot_changes(v, S[4], x, null)
            : get_all_dirty_from_scope(S[4]),
          null
        ),
        (!p || x & 4) && attr(r, "id", S[2]);
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function create_if_block$W(k) {
  let r, p;
  const v = k[5].default,
    $ = create_slot(v, k, k[4], null);
  return {
    c() {
      (r = element("h1")), $ && $.c(), attr(r, "id", k[2]);
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, x) {
      $ &&
        $.p &&
        (!p || x & 16) &&
        update_slot_base(
          $,
          v,
          S,
          S[4],
          p
            ? get_slot_changes(v, S[4], x, null)
            : get_all_dirty_from_scope(S[4]),
          null
        ),
        (!p || x & 4) && attr(r, "id", S[2]);
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function create_fragment$2m(k) {
  let r, p, v, $;
  const S = [
      create_if_block$W,
      create_if_block_1$g,
      create_if_block_2$2,
      create_if_block_3,
      create_if_block_4,
      create_if_block_5,
      create_else_block$i,
    ],
    x = [];
  function I(F, O) {
    return F[0] === 1
      ? 0
      : F[0] === 2
      ? 1
      : F[0] === 3
      ? 2
      : F[0] === 4
      ? 3
      : F[0] === 5
      ? 4
      : F[0] === 6
      ? 5
      : 6;
  }
  return (
    (r = I(k)),
    (p = x[r] = S[r](k)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        x[r].m(F, O), insert(F, v, O), ($ = !0);
      },
      p(F, [O]) {
        let L = r;
        (r = I(F)),
          r === L
            ? x[r].p(F, O)
            : (group_outros(),
              transition_out(x[L], 1, 1, () => {
                x[L] = null;
              }),
              check_outros(),
              (p = x[r]),
              p ? p.p(F, O) : ((p = x[r] = S[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        $ || (transition_in(p), ($ = !0));
      },
      o(F) {
        transition_out(p), ($ = !1);
      },
      d(F) {
        x[r].d(F), F && detach(v);
      },
    }
  );
}
function instance$2d(k, r, p) {
  let v,
    { $$slots: $ = {}, $$scope: S } = r,
    { depth: x } = r,
    { raw: I } = r,
    { text: F } = r;
  const { slug: O, getOptions: L } = getContext(key),
    U = L();
  return (
    (k.$$set = (j) => {
      "depth" in j && p(0, (x = j.depth)),
        "raw" in j && p(1, (I = j.raw)),
        "text" in j && p(3, (F = j.text)),
        "$$scope" in j && p(4, (S = j.$$scope));
    }),
    (k.$$.update = () => {
      k.$$.dirty & 8 &&
        p(2, (v = U.headerIds ? U.headerPrefix + O(F) : void 0));
    }),
    [x, I, v, F, S, $]
  );
}
class Heading extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2d, create_fragment$2m, safe_not_equal, {
        depth: 0,
        raw: 1,
        text: 3,
      });
  }
}
function create_fragment$2l(k) {
  let r, p;
  const v = k[1].default,
    $ = create_slot(v, k, k[0], null);
  return {
    c() {
      (r = element("p")), $ && $.c();
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, [x]) {
      $ &&
        $.p &&
        (!p || x & 1) &&
        update_slot_base(
          $,
          v,
          S,
          S[0],
          p
            ? get_slot_changes(v, S[0], x, null)
            : get_all_dirty_from_scope(S[0]),
          null
        );
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function instance$2c(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r;
  return (
    (k.$$set = (S) => {
      "$$scope" in S && p(0, ($ = S.$$scope));
    }),
    [$, v]
  );
}
class Paragraph extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2c, create_fragment$2l, safe_not_equal, {});
  }
}
function create_fragment$2k(k) {
  let r;
  const p = k[3].default,
    v = create_slot(p, k, k[2], null);
  return {
    c() {
      v && v.c();
    },
    m($, S) {
      v && v.m($, S), (r = !0);
    },
    p($, [S]) {
      v &&
        v.p &&
        (!r || S & 4) &&
        update_slot_base(
          v,
          p,
          $,
          $[2],
          r
            ? get_slot_changes(p, $[2], S, null)
            : get_all_dirty_from_scope($[2]),
          null
        );
    },
    i($) {
      r || (transition_in(v, $), (r = !0));
    },
    o($) {
      transition_out(v, $), (r = !1);
    },
    d($) {
      v && v.d($);
    },
  };
}
function instance$2b(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r,
    { text: S } = r,
    { raw: x } = r;
  return (
    (k.$$set = (I) => {
      "text" in I && p(0, (S = I.text)),
        "raw" in I && p(1, (x = I.raw)),
        "$$scope" in I && p(2, ($ = I.$$scope));
    }),
    [S, x, $, v]
  );
}
class Text extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2b, create_fragment$2k, safe_not_equal, {
        text: 0,
        raw: 1,
      });
  }
}
function create_fragment$2j(k) {
  let r, p;
  return {
    c() {
      (r = element("img")),
        src_url_equal(r.src, (p = k[0])) || attr(r, "src", p),
        attr(r, "title", k[1]),
        attr(r, "alt", k[2]);
    },
    m(v, $) {
      insert(v, r, $);
    },
    p(v, [$]) {
      $ & 1 && !src_url_equal(r.src, (p = v[0])) && attr(r, "src", p),
        $ & 2 && attr(r, "title", v[1]),
        $ & 4 && attr(r, "alt", v[2]);
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      v && detach(r);
    },
  };
}
function instance$2a(k, r, p) {
  let { href: v = "" } = r,
    { title: $ = void 0 } = r,
    { text: S = "" } = r;
  return (
    (k.$$set = (x) => {
      "href" in x && p(0, (v = x.href)),
        "title" in x && p(1, ($ = x.title)),
        "text" in x && p(2, (S = x.text));
    }),
    [v, $, S]
  );
}
let Image$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2a, create_fragment$2j, safe_not_equal, {
        href: 0,
        title: 1,
        text: 2,
      });
  }
};
function create_fragment$2i(k) {
  let r, p;
  const v = k[3].default,
    $ = create_slot(v, k, k[2], null);
  return {
    c() {
      (r = element("a")),
        $ && $.c(),
        attr(r, "href", k[0]),
        attr(r, "title", k[1]);
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, [x]) {
      $ &&
        $.p &&
        (!p || x & 4) &&
        update_slot_base(
          $,
          v,
          S,
          S[2],
          p
            ? get_slot_changes(v, S[2], x, null)
            : get_all_dirty_from_scope(S[2]),
          null
        ),
        (!p || x & 1) && attr(r, "href", S[0]),
        (!p || x & 2) && attr(r, "title", S[1]);
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function instance$29(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r,
    { href: S = "" } = r,
    { title: x = void 0 } = r;
  return (
    (k.$$set = (I) => {
      "href" in I && p(0, (S = I.href)),
        "title" in I && p(1, (x = I.title)),
        "$$scope" in I && p(2, ($ = I.$$scope));
    }),
    [S, x, $, v]
  );
}
class Link extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$29, create_fragment$2i, safe_not_equal, {
        href: 0,
        title: 1,
      });
  }
}
function create_fragment$2h(k) {
  let r, p;
  const v = k[1].default,
    $ = create_slot(v, k, k[0], null);
  return {
    c() {
      (r = element("em")), $ && $.c();
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, [x]) {
      $ &&
        $.p &&
        (!p || x & 1) &&
        update_slot_base(
          $,
          v,
          S,
          S[0],
          p
            ? get_slot_changes(v, S[0], x, null)
            : get_all_dirty_from_scope(S[0]),
          null
        );
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function instance$28(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r;
  return (
    (k.$$set = (S) => {
      "$$scope" in S && p(0, ($ = S.$$scope));
    }),
    [$, v]
  );
}
class Em extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$28, create_fragment$2h, safe_not_equal, {});
  }
}
function create_fragment$2g(k) {
  let r, p;
  const v = k[1].default,
    $ = create_slot(v, k, k[0], null);
  return {
    c() {
      (r = element("del")), $ && $.c();
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, [x]) {
      $ &&
        $.p &&
        (!p || x & 1) &&
        update_slot_base(
          $,
          v,
          S,
          S[0],
          p
            ? get_slot_changes(v, S[0], x, null)
            : get_all_dirty_from_scope(S[0]),
          null
        );
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function instance$27(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r;
  return (
    (k.$$set = (S) => {
      "$$scope" in S && p(0, ($ = S.$$scope));
    }),
    [$, v]
  );
}
class Del extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$27, create_fragment$2g, safe_not_equal, {});
  }
}
function create_fragment$2f(k) {
  let r,
    p = k[0].replace(/`/g, "") + "",
    v;
  return {
    c() {
      (r = element("code")), (v = text(p));
    },
    m($, S) {
      insert($, r, S), append(r, v);
    },
    p($, [S]) {
      S & 1 && p !== (p = $[0].replace(/`/g, "") + "") && set_data(v, p);
    },
    i: noop$1,
    o: noop$1,
    d($) {
      $ && detach(r);
    },
  };
}
function instance$26(k, r, p) {
  let { raw: v } = r;
  return (
    (k.$$set = ($) => {
      "raw" in $ && p(0, (v = $.raw));
    }),
    [v]
  );
}
class Codespan extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$26, create_fragment$2f, safe_not_equal, {
        raw: 0,
      });
  }
}
function create_fragment$2e(k) {
  let r, p;
  const v = k[1].default,
    $ = create_slot(v, k, k[0], null);
  return {
    c() {
      (r = element("strong")), $ && $.c();
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, [x]) {
      $ &&
        $.p &&
        (!p || x & 1) &&
        update_slot_base(
          $,
          v,
          S,
          S[0],
          p
            ? get_slot_changes(v, S[0], x, null)
            : get_all_dirty_from_scope(S[0]),
          null
        );
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function instance$25(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r;
  return (
    (k.$$set = (S) => {
      "$$scope" in S && p(0, ($ = S.$$scope));
    }),
    [$, v]
  );
}
class Strong extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$25, create_fragment$2e, safe_not_equal, {});
  }
}
function create_fragment$2d(k) {
  let r, p;
  const v = k[1].default,
    $ = create_slot(v, k, k[0], null);
  return {
    c() {
      (r = element("table")), $ && $.c();
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, [x]) {
      $ &&
        $.p &&
        (!p || x & 1) &&
        update_slot_base(
          $,
          v,
          S,
          S[0],
          p
            ? get_slot_changes(v, S[0], x, null)
            : get_all_dirty_from_scope(S[0]),
          null
        );
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function instance$24(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r;
  return (
    (k.$$set = (S) => {
      "$$scope" in S && p(0, ($ = S.$$scope));
    }),
    [$, v]
  );
}
class Table extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$24, create_fragment$2d, safe_not_equal, {});
  }
}
function create_fragment$2c(k) {
  let r, p;
  const v = k[1].default,
    $ = create_slot(v, k, k[0], null);
  return {
    c() {
      (r = element("thead")), $ && $.c();
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, [x]) {
      $ &&
        $.p &&
        (!p || x & 1) &&
        update_slot_base(
          $,
          v,
          S,
          S[0],
          p
            ? get_slot_changes(v, S[0], x, null)
            : get_all_dirty_from_scope(S[0]),
          null
        );
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function instance$23(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r;
  return (
    (k.$$set = (S) => {
      "$$scope" in S && p(0, ($ = S.$$scope));
    }),
    [$, v]
  );
}
class TableHead extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$23, create_fragment$2c, safe_not_equal, {});
  }
}
function create_fragment$2b(k) {
  let r, p;
  const v = k[1].default,
    $ = create_slot(v, k, k[0], null);
  return {
    c() {
      (r = element("tbody")), $ && $.c();
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, [x]) {
      $ &&
        $.p &&
        (!p || x & 1) &&
        update_slot_base(
          $,
          v,
          S,
          S[0],
          p
            ? get_slot_changes(v, S[0], x, null)
            : get_all_dirty_from_scope(S[0]),
          null
        );
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function instance$22(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r;
  return (
    (k.$$set = (S) => {
      "$$scope" in S && p(0, ($ = S.$$scope));
    }),
    [$, v]
  );
}
class TableBody extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$22, create_fragment$2b, safe_not_equal, {});
  }
}
function create_fragment$2a(k) {
  let r, p;
  const v = k[1].default,
    $ = create_slot(v, k, k[0], null);
  return {
    c() {
      (r = element("tr")), $ && $.c();
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, [x]) {
      $ &&
        $.p &&
        (!p || x & 1) &&
        update_slot_base(
          $,
          v,
          S,
          S[0],
          p
            ? get_slot_changes(v, S[0], x, null)
            : get_all_dirty_from_scope(S[0]),
          null
        );
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function instance$21(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r;
  return (
    (k.$$set = (S) => {
      "$$scope" in S && p(0, ($ = S.$$scope));
    }),
    [$, v]
  );
}
class TableRow extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$21, create_fragment$2a, safe_not_equal, {});
  }
}
function create_else_block$h(k) {
  let r, p;
  const v = k[3].default,
    $ = create_slot(v, k, k[2], null);
  return {
    c() {
      (r = element("td")), $ && $.c(), attr(r, "align", k[1]);
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, x) {
      $ &&
        $.p &&
        (!p || x & 4) &&
        update_slot_base(
          $,
          v,
          S,
          S[2],
          p
            ? get_slot_changes(v, S[2], x, null)
            : get_all_dirty_from_scope(S[2]),
          null
        ),
        (!p || x & 2) && attr(r, "align", S[1]);
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function create_if_block$V(k) {
  let r, p;
  const v = k[3].default,
    $ = create_slot(v, k, k[2], null);
  return {
    c() {
      (r = element("th")), $ && $.c(), attr(r, "align", k[1]);
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, x) {
      $ &&
        $.p &&
        (!p || x & 4) &&
        update_slot_base(
          $,
          v,
          S,
          S[2],
          p
            ? get_slot_changes(v, S[2], x, null)
            : get_all_dirty_from_scope(S[2]),
          null
        ),
        (!p || x & 2) && attr(r, "align", S[1]);
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function create_fragment$29(k) {
  let r, p, v, $;
  const S = [create_if_block$V, create_else_block$h],
    x = [];
  function I(F, O) {
    return F[0] ? 0 : 1;
  }
  return (
    (r = I(k)),
    (p = x[r] = S[r](k)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        x[r].m(F, O), insert(F, v, O), ($ = !0);
      },
      p(F, [O]) {
        let L = r;
        (r = I(F)),
          r === L
            ? x[r].p(F, O)
            : (group_outros(),
              transition_out(x[L], 1, 1, () => {
                x[L] = null;
              }),
              check_outros(),
              (p = x[r]),
              p ? p.p(F, O) : ((p = x[r] = S[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        $ || (transition_in(p), ($ = !0));
      },
      o(F) {
        transition_out(p), ($ = !1);
      },
      d(F) {
        x[r].d(F), F && detach(v);
      },
    }
  );
}
function instance$20(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r,
    { header: S } = r,
    { align: x } = r;
  return (
    (k.$$set = (I) => {
      "header" in I && p(0, (S = I.header)),
        "align" in I && p(1, (x = I.align)),
        "$$scope" in I && p(2, ($ = I.$$scope));
    }),
    [S, x, $, v]
  );
}
class TableCell extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$20, create_fragment$29, safe_not_equal, {
        header: 0,
        align: 1,
      });
  }
}
function create_else_block$g(k) {
  let r, p;
  const v = k[3].default,
    $ = create_slot(v, k, k[2], null);
  return {
    c() {
      (r = element("ul")), $ && $.c();
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, x) {
      $ &&
        $.p &&
        (!p || x & 4) &&
        update_slot_base(
          $,
          v,
          S,
          S[2],
          p
            ? get_slot_changes(v, S[2], x, null)
            : get_all_dirty_from_scope(S[2]),
          null
        );
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function create_if_block$U(k) {
  let r, p;
  const v = k[3].default,
    $ = create_slot(v, k, k[2], null);
  return {
    c() {
      (r = element("ol")), $ && $.c(), attr(r, "start", k[1]);
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, x) {
      $ &&
        $.p &&
        (!p || x & 4) &&
        update_slot_base(
          $,
          v,
          S,
          S[2],
          p
            ? get_slot_changes(v, S[2], x, null)
            : get_all_dirty_from_scope(S[2]),
          null
        ),
        (!p || x & 2) && attr(r, "start", S[1]);
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function create_fragment$28(k) {
  let r, p, v, $;
  const S = [create_if_block$U, create_else_block$g],
    x = [];
  function I(F, O) {
    return F[0] ? 0 : 1;
  }
  return (
    (r = I(k)),
    (p = x[r] = S[r](k)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        x[r].m(F, O), insert(F, v, O), ($ = !0);
      },
      p(F, [O]) {
        let L = r;
        (r = I(F)),
          r === L
            ? x[r].p(F, O)
            : (group_outros(),
              transition_out(x[L], 1, 1, () => {
                x[L] = null;
              }),
              check_outros(),
              (p = x[r]),
              p ? p.p(F, O) : ((p = x[r] = S[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        $ || (transition_in(p), ($ = !0));
      },
      o(F) {
        transition_out(p), ($ = !1);
      },
      d(F) {
        x[r].d(F), F && detach(v);
      },
    }
  );
}
function instance$1$(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r,
    { ordered: S } = r,
    { start: x } = r;
  return (
    (k.$$set = (I) => {
      "ordered" in I && p(0, (S = I.ordered)),
        "start" in I && p(1, (x = I.start)),
        "$$scope" in I && p(2, ($ = I.$$scope));
    }),
    [S, x, $, v]
  );
}
class List extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1$, create_fragment$28, safe_not_equal, {
        ordered: 0,
        start: 1,
      });
  }
}
function create_fragment$27(k) {
  let r, p;
  const v = k[1].default,
    $ = create_slot(v, k, k[0], null);
  return {
    c() {
      (r = element("li")), $ && $.c();
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, [x]) {
      $ &&
        $.p &&
        (!p || x & 1) &&
        update_slot_base(
          $,
          v,
          S,
          S[0],
          p
            ? get_slot_changes(v, S[0], x, null)
            : get_all_dirty_from_scope(S[0]),
          null
        );
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function instance$1_(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r;
  return (
    (k.$$set = (S) => {
      "$$scope" in S && p(0, ($ = S.$$scope));
    }),
    [$, v]
  );
}
class ListItem extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1_, create_fragment$27, safe_not_equal, {});
  }
}
function create_fragment$26(k) {
  let r;
  return {
    c() {
      r = element("hr");
    },
    m(p, v) {
      insert(p, r, v);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
class Hr extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$26, safe_not_equal, {});
  }
}
function create_fragment$25(k) {
  let r, p;
  return {
    c() {
      (r = new HtmlTag(!1)), (p = empty()), (r.a = p);
    },
    m(v, $) {
      r.m(k[0], v, $), insert(v, p, $);
    },
    p(v, [$]) {
      $ & 1 && r.p(v[0]);
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      v && detach(p), v && r.d();
    },
  };
}
function instance$1Z(k, r, p) {
  let { text: v } = r;
  return (
    (k.$$set = ($) => {
      "text" in $ && p(0, (v = $.text));
    }),
    [v]
  );
}
class Html extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1Z, create_fragment$25, safe_not_equal, {
        text: 0,
      });
  }
}
function create_fragment$24(k) {
  let r, p;
  const v = k[1].default,
    $ = create_slot(v, k, k[0], null);
  return {
    c() {
      (r = element("blockquote")), $ && $.c();
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(r, null), (p = !0);
    },
    p(S, [x]) {
      $ &&
        $.p &&
        (!p || x & 1) &&
        update_slot_base(
          $,
          v,
          S,
          S[0],
          p
            ? get_slot_changes(v, S[0], x, null)
            : get_all_dirty_from_scope(S[0]),
          null
        );
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function instance$1Y(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r;
  return (
    (k.$$set = (S) => {
      "$$scope" in S && p(0, ($ = S.$$scope));
    }),
    [$, v]
  );
}
class Blockquote extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1Y, create_fragment$24, safe_not_equal, {});
  }
}
function create_fragment$23(k) {
  let r, p, v;
  return {
    c() {
      (r = element("pre")),
        (p = element("code")),
        (v = text(k[1])),
        attr(r, "class", k[0]);
    },
    m($, S) {
      insert($, r, S), append(r, p), append(p, v);
    },
    p($, [S]) {
      S & 2 && set_data(v, $[1]), S & 1 && attr(r, "class", $[0]);
    },
    i: noop$1,
    o: noop$1,
    d($) {
      $ && detach(r);
    },
  };
}
function instance$1X(k, r, p) {
  let { lang: v } = r,
    { text: $ } = r;
  return (
    (k.$$set = (S) => {
      "lang" in S && p(0, (v = S.lang)), "text" in S && p(1, ($ = S.text));
    }),
    [v, $]
  );
}
class Code extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1X, create_fragment$23, safe_not_equal, {
        lang: 0,
        text: 1,
      });
  }
}
function create_fragment$22(k) {
  let r, p;
  const v = k[1].default,
    $ = create_slot(v, k, k[0], null);
  return {
    c() {
      (r = element("br")), $ && $.c();
    },
    m(S, x) {
      insert(S, r, x), $ && $.m(S, x), (p = !0);
    },
    p(S, [x]) {
      $ &&
        $.p &&
        (!p || x & 1) &&
        update_slot_base(
          $,
          v,
          S,
          S[0],
          p
            ? get_slot_changes(v, S[0], x, null)
            : get_all_dirty_from_scope(S[0]),
          null
        );
    },
    i(S) {
      p || (transition_in($, S), (p = !0));
    },
    o(S) {
      transition_out($, S), (p = !1);
    },
    d(S) {
      S && detach(r), $ && $.d(S);
    },
  };
}
function instance$1W(k, r, p) {
  let { $$slots: v = {}, $$scope: $ } = r;
  return (
    (k.$$set = (S) => {
      "$$scope" in S && p(0, ($ = S.$$scope));
    }),
    [$, v]
  );
}
class Br extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1W, create_fragment$22, safe_not_equal, {});
  }
}
const defaultRenderers = {
    heading: Heading,
    paragraph: Paragraph,
    text: Text,
    image: Image$1,
    link: Link,
    em: Em,
    strong: Strong,
    codespan: Codespan,
    del: Del,
    table: Table,
    tablehead: TableHead,
    tablebody: TableBody,
    tablerow: TableRow,
    tablecell: TableCell,
    list: List,
    orderedlistitem: null,
    unorderedlistitem: null,
    listitem: ListItem,
    hr: Hr,
    html: Html,
    blockquote: Blockquote,
    code: Code,
    br: Br,
  },
  defaultOptions = {
    baseUrl: null,
    breaks: !1,
    gfm: !0,
    headerIds: !0,
    headerPrefix: "",
    highlight: null,
    langPrefix: "language-",
    mangle: !0,
    pedantic: !1,
    renderer: null,
    sanitize: !1,
    sanitizer: null,
    silent: !1,
    smartLists: !1,
    smartypants: !1,
    tokenizer: null,
    xhtml: !1,
  };
function create_fragment$21(k) {
  let r, p;
  return (
    (r = new Parser$1({ props: { tokens: k[0], renderers: k[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, [$]) {
        const S = {};
        $ & 1 && (S.tokens = v[0]), $ & 2 && (S.renderers = v[1]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function instance$1V(k, r, p) {
  let v,
    $,
    S,
    x,
    { source: I = [] } = r,
    { renderers: F = {} } = r,
    { options: O = {} } = r,
    { isInline: L = !1 } = r;
  const U = createEventDispatcher();
  let j, N, q;
  return (
    setContext(key, { slug: (R) => ($ ? $.slug(R) : ""), getOptions: () => S }),
    onMount(() => {
      p(7, (q = !0));
    }),
    (k.$$set = (R) => {
      "source" in R && p(2, (I = R.source)),
        "renderers" in R && p(3, (F = R.renderers)),
        "options" in R && p(4, (O = R.options)),
        "isInline" in R && p(5, (L = R.isInline));
    }),
    (k.$$.update = () => {
      k.$$.dirty & 4 && p(8, (v = Array.isArray(I))),
        k.$$.dirty & 4 && ($ = I ? new Slugger() : void 0),
        k.$$.dirty & 16 && p(9, (S = { ...defaultOptions, ...O })),
        k.$$.dirty & 869 &&
          (v
            ? p(0, (j = I))
            : (p(6, (N = new Lexer(S))),
              p(0, (j = L ? N.inlineTokens(I) : N.lex(I))),
              U("parsed", { tokens: j }))),
        k.$$.dirty & 8 && p(1, (x = { ...defaultRenderers, ...F })),
        k.$$.dirty & 385 && q && !v && U("parsed", { tokens: j });
    }),
    [j, x, I, F, O, L, N, q, v, S]
  );
}
class SvelteMarkdown extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1V, create_fragment$21, safe_not_equal, {
        source: 2,
        renderers: 3,
        options: 4,
        isInline: 5,
      });
  }
}
const markdownviewer = "";
function create_fragment$20(k) {
  let r, p, v, $, S, x, I, F;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (x = element("h3")),
        (x.textContent = "Render failed"),
        (I = space()),
        (F = element("p")),
        (F.textContent =
          "The markdown content could not be parsed. The opened file may be empty."),
        src_url_equal(v.src, ($ = warning)) || attr(v, "src", $),
        attr(v, "alt", "Error"),
        attr(p, "class", "content"),
        attr(r, "class", "unreadable");
    },
    m(O, L) {
      insert(O, r, L),
        append(r, p),
        append(p, v),
        append(p, S),
        append(p, x),
        append(p, I),
        append(p, F);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(O) {
      O && detach(r);
    },
  };
}
class Unreadable extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$20, safe_not_equal, {});
  }
}
function create_if_block$T(k) {
  let r, p, v, $;
  const S = [create_if_block_1$f, create_else_block$f],
    x = [];
  function I(F, O) {
    return F[1] ? 0 : 1;
  }
  return (
    (r = I(k)),
    (p = x[r] = S[r](k)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        x[r].m(F, O), insert(F, v, O), ($ = !0);
      },
      p(F, O) {
        let L = r;
        (r = I(F)),
          r === L
            ? x[r].p(F, O)
            : (group_outros(),
              transition_out(x[L], 1, 1, () => {
                x[L] = null;
              }),
              check_outros(),
              (p = x[r]),
              p ? p.p(F, O) : ((p = x[r] = S[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        $ || (transition_in(p), ($ = !0));
      },
      o(F) {
        transition_out(p), ($ = !1);
      },
      d(F) {
        x[r].d(F), F && detach(v);
      },
    }
  );
}
function create_else_block$f(k) {
  let r, p;
  return (
    (r = new Unreadable({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_1$f(k) {
  let r, p, v;
  return (
    (p = new SvelteMarkdown({ props: { source: k[1] } })),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          attr(r, "class", "markdownrenderer");
      },
      m($, S) {
        insert($, r, S), mount_component(p, r, null), (v = !0);
      },
      p($, S) {
        const x = {};
        S & 2 && (x.source = $[1]), p.$set(x);
      },
      i($) {
        v || (transition_in(p.$$.fragment, $), (v = !0));
      },
      o($) {
        transition_out(p.$$.fragment, $), (v = !1);
      },
      d($) {
        $ && detach(r), destroy_component(p);
      },
    }
  );
}
function create_fragment$1$(k) {
  let r,
    p,
    v = k[0] && create_if_block$T(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, [S]) {
      $[0]
        ? v
          ? (v.p($, S), S & 1 && transition_in(v, 1))
          : ((v = create_if_block$T($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function instance$1U(k, r, p) {
  let v;
  component_subscribe(k, TextEditorContent, (I) => p(3, (v = I)));
  let { app: $ } = r,
    S = "",
    x = "";
  return (
    WindowStore.subscribe(() => {
      if ((getWindow("TextEditor"), !$)) return;
      const I = $.openedFile;
      !I ||
        !I.mime.startsWith("text/") ||
        ((S = new TextDecoder().decode(I.data)),
        p(1, (x = $.openedFile ? S : v)));
    }),
    TextEditorContent.subscribe(() => {
      closeFile("MarkDownViewer"),
        setTitleSuffix("", "MarkDownViewer"),
        p(1, (x = $.openedFile ? S : v));
    }),
    (k.$$set = (I) => {
      "app" in I && p(0, ($ = I.app));
    }),
    [$, x]
  );
}
let MarkDownViewer$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1U, create_fragment$1$, safe_not_equal, {
        app: 0,
      });
  }
};
const MarkDownViewer = {
    info: {
      name: "Markdown Viewer",
      description: "View .MD files",
      author: "ArcOS Team",
      version: "1.0.0",
      icon: icon$1,
      builtin: !0,
      hidden: !0,
    },
    size: { w: 700, h: 550 },
    pos: { x: 30, y: 40 },
    minSize: { w: 400, h: 300 },
    maxSize: { w: 1e3, h: 800 },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: MarkDownViewer$1,
    glass: !1,
    fileMimes: ["text/plain; charset=utf-8", "text/markdown; charset=utf-8"],
    events: {
      openFile(k) {
        k.openedFile && setTitleSuffix(` - ${k.openedFile.path}`, k.id);
      },
    },
  },
  logo$3 = "./assets/mediaplayer-8f0c4cdf.svg",
  mediaplayer = "";
function create_if_block$S(k) {
  let r,
    p,
    v = !1,
    $,
    S,
    x,
    I,
    F;
  function O() {
    cancelAnimationFrame($),
      r.paused || (($ = raf(O)), (v = !0)),
      k[13].call(r);
  }
  let L = k[1] && create_if_block_1$e(k);
  return {
    c() {
      (r = element("audio")),
        (S = space()),
        L && L.c(),
        (x = empty()),
        src_url_equal(r.src, (p = k[5])) || attr(r, "src", p),
        (r.controls = !0),
        (r.autoplay = !0),
        k[3] === void 0 && add_render_callback(() => k[12].call(r));
    },
    m(U, j) {
      insert(U, r, j),
        k[11](r),
        insert(U, S, j),
        L && L.m(U, j),
        insert(U, x, j),
        I ||
          ((F = [
            listen(r, "durationchange", k[12]),
            listen(r, "timeupdate", O),
            listen(r, "timeupdate", k[9]),
          ]),
          (I = !0));
    },
    p(U, j) {
      j & 32 && !src_url_equal(r.src, (p = U[5])) && attr(r, "src", p),
        !v && j & 16 && !isNaN(U[4]) && (r.currentTime = U[4]),
        (v = !1),
        U[1]
          ? L
            ? L.p(U, j)
            : ((L = create_if_block_1$e(U)), L.c(), L.m(x.parentNode, x))
          : L && (L.d(1), (L = null));
    },
    d(U) {
      U && detach(r),
        k[11](null),
        U && detach(S),
        L && L.d(U),
        U && detach(x),
        (I = !1),
        run_all(F);
    },
  };
}
function create_if_block_1$e(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L,
    U,
    j,
    N,
    q,
    R,
    Q,
    H,
    G,
    V = formatTime(k[4]) + "",
    K,
    Y,
    J = formatTime(k[3]) + "",
    Z,
    X,
    ee,
    te,
    re,
    fe,
    le,
    se,
    ae,
    oe,
    ie = k[0].openedFile.path + "",
    ne,
    ce,
    ue,
    me;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("div")),
        ($ = element("button")),
        (S = text("play_arrow")),
        (I = space()),
        (F = element("button")),
        (O = text("pause")),
        (L = space()),
        (U = element("div")),
        (j = element("button")),
        (j.textContent = "fast_rewind"),
        (N = space()),
        (q = element("button")),
        (q.textContent = "fast_forward"),
        (R = space()),
        (Q = element("button")),
        (Q.textContent = "stop"),
        (H = space()),
        (G = element("div")),
        (K = text(V)),
        (Y = text(" / ")),
        (Z = text(J)),
        (X = space()),
        (ee = element("div")),
        (te = element("div")),
        (re = space()),
        (fe = element("div")),
        (le = element("img")),
        (oe = element("span")),
        (ne = text(ie)),
        attr($, "class", "material-icons-round"),
        ($.disabled = x = !k[6] && k[2] < 100),
        attr(F, "class", "material-icons-round"),
        (F.disabled = k[6]),
        attr(v, "class", "group"),
        attr(j, "class", "material-icons-round"),
        attr(q, "class", "material-icons-round"),
        attr(U, "class", "group"),
        attr(Q, "class", "material-icons-round"),
        attr(G, "class", "right"),
        attr(p, "class", "controls"),
        attr(te, "class", "inner"),
        set_style(te, "width", k[2] + "%"),
        attr(ee, "class", "bar"),
        src_url_equal(le.src, (se = getMimeIcon(k[0].openedFile.name))) ||
          attr(le, "src", se),
        attr(le, "alt", (ae = k[0].openedFile.name)),
        attr(fe, "class", "filename"),
        attr(fe, "title", (ce = k[0].openedFile.path)),
        attr(r, "class", "media-player");
    },
    m(pe, de) {
      insert(pe, r, de),
        append(r, p),
        append(p, v),
        append(v, $),
        append($, S),
        append(v, I),
        append(v, F),
        append(F, O),
        append(p, L),
        append(p, U),
        append(U, j),
        append(U, N),
        append(U, q),
        append(p, R),
        append(p, Q),
        append(p, H),
        append(p, G),
        append(G, K),
        append(G, Y),
        append(G, Z),
        append(r, X),
        append(r, ee),
        append(ee, te),
        append(r, re),
        append(r, fe),
        append(fe, le),
        append(fe, oe),
        append(oe, ne),
        ue ||
          ((me = [
            listen($, "click", k[14]),
            listen(F, "click", k[15]),
            listen(j, "click", k[7]),
            listen(q, "click", k[8]),
            listen(Q, "click", k[10]),
          ]),
          (ue = !0));
    },
    p(pe, de) {
      de & 68 && x !== (x = !pe[6] && pe[2] < 100) && ($.disabled = x),
        de & 64 && (F.disabled = pe[6]),
        de & 16 && V !== (V = formatTime(pe[4]) + "") && set_data(K, V),
        de & 8 && J !== (J = formatTime(pe[3]) + "") && set_data(Z, J),
        de & 4 && set_style(te, "width", pe[2] + "%"),
        de & 1 &&
          !src_url_equal(le.src, (se = getMimeIcon(pe[0].openedFile.name))) &&
          attr(le, "src", se),
        de & 1 && ae !== (ae = pe[0].openedFile.name) && attr(le, "alt", ae),
        de & 1 && ie !== (ie = pe[0].openedFile.path + "") && set_data(ne, ie),
        de & 1 && ce !== (ce = pe[0].openedFile.path) && attr(fe, "title", ce);
    },
    d(pe) {
      pe && detach(r), (ue = !1), run_all(me);
    },
  };
}
function create_fragment$1_(k) {
  let r,
    p = k[0].openedFile && create_if_block$S(k);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, $) {
      p && p.m(v, $), insert(v, r, $);
    },
    p(v, [$]) {
      v[0].openedFile
        ? p
          ? p.p(v, $)
          : ((p = create_if_block$S(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function formatTime(k) {
  const r = Math.floor(k / 60),
    p = Math.floor(k % 60);
  return `${r}:${p.toString().padStart(2, "0")}`;
}
function instance$1T(k, r, p) {
  let v,
    { app: $ } = r,
    S = 0,
    x = 0,
    I = 0,
    F = "",
    O = "",
    L = !0;
  WindowStore.subscribe(() => {
    !$.openedFile ||
      !v ||
      O == $.openedFile.name ||
      ((O = $.openedFile.name),
      p(
        5,
        (F = URL.createObjectURL(
          new Blob([$.openedFile.data], { type: $.openedFile.mime })
        ))
      ),
      setTimeout(() => {
        v.play();
      }));
  });
  function U() {
    p(1, (v.currentTime -= 10), v);
  }
  function j() {
    p(1, (v.currentTime += 10), v);
  }
  function N() {
    p(2, (S = (v.currentTime / v.duration) * 100)), p(6, (L = v.paused));
  }
  function q() {
    p(1, (v.currentTime = 0), v), v.pause();
  }
  onMount(() => {
    registerShortcuts([
      {
        key: "space",
        action: () => {
          v == null || v.pause();
        },
      },
    ]);
  });
  function R(K) {
    binding_callbacks[K ? "unshift" : "push"](() => {
      (v = K), p(1, v);
    });
  }
  function Q() {
    (x = this.duration), p(3, x);
  }
  function H() {
    (I = this.currentTime), p(4, I);
  }
  const G = () => v.play(),
    V = () => v.pause();
  return (
    (k.$$set = (K) => {
      "app" in K && p(0, ($ = K.app));
    }),
    [$, v, S, x, I, F, L, U, j, N, q, R, Q, H, G, V]
  );
}
class MediaPlayer extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1T, create_fragment$1_, safe_not_equal, {
        app: 0,
      });
  }
}
const MediaPlayerApp = {
    info: {
      name: "Media Player",
      description: "Play audio files",
      builtin: !0,
      version: "2.0.0",
      author: "Izaak Kuipers",
      icon: logo$3,
      hidden: !0,
    },
    size: { w: 442, h: NaN },
    pos: { x: 100, y: 100 },
    minSize: { w: 442, h: NaN },
    maxSize: { w: 442, h: NaN },
    controls: { min: !0, max: !1, cls: !0 },
    state: {
      headless: !1,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: MediaPlayer,
    glass: !0,
    fileMimes: ["audio/x-flac", "audio/wave", "audio/mpeg"],
    events: {
      open: (k) => {
        k.openedFile || closeWindow("MediaPlayerApp");
      },
    },
  },
  logo$2 = "./assets/messaging-9e309b2f.svg";
async function deleteMessage(k) {
  const r = get_store_value(ConnectedServer);
  return r
    ? !(await apiCall(
        r,
        "messages/delete",
        { id: btoa(k) },
        get_store_value(UserToken)
      ))
    : !1;
}
const MessagingUpdaters = writable([]);
function messageSubscribe(k) {
  const r = get_store_value(MessagingUpdaters);
  r.push(k), MessagingUpdaters.set(r);
}
function messageUpdateTrigger() {
  const k = get_store_value(MessagingUpdaters);
  for (let r = 0; r < k.length; r++) k[r]();
}
const messageSidebarActions = [
    {
      icon: "add",
      name: "New Message",
      action() {
        replyMessageId.set(null), creatingMessage.set(!0);
      },
    },
  ],
  messageItemActions = [
    {
      icon: "reply",
      name: "Reply",
      async action(k) {
        replyMessageId.set(k.id), creatingMessage.set(!0);
      },
    },
    {
      icon: "save",
      name: "Save to ArcFS",
      async action(k) {
        const r = new Blob([k.body], { type: "text/markdown" });
        await createDirectory("./Messages");
        const p = `Message from ${k.sender} - ${k.id}.md`,
          v = `./Messages/${p}`;
        await writeFile(v, r),
          openWindow("FileManager"),
          await fbClass.goToDirectory("./Messages"),
          setTimeout(() => {
            FileBrowserSelectedFilename.set(p);
          });
      },
    },
    {
      icon: "delete",
      name: "Delete message for everyone",
      async action(k) {
        createOverlayableError(
          {
            title: "Delete message?",
            message: `Are you sure you want to delete this message from ${k.sender}? This cannot be undone.`,
            image: warning,
            buttons: [
              {
                caption: "Delete",
                action: async () => {
                  await deleteMessage(k.id),
                    messageUpdateTrigger(),
                    selectedMessageId.set(null);
                },
              },
              { caption: "Cancel", action: () => {} },
            ],
          },
          "MessagingApp"
        );
      },
    },
  ];
async function getSentMessages() {
  const k = await getMessages();
  let r = [];
  for (let p = 0; p < k.length; p++)
    k[p].sender == get_store_value(UserName) && r.push(k[p]);
  return r;
}
async function getReceivedMessages() {
  const k = await getMessages();
  let r = [];
  for (let p = 0; p < k.length; p++)
    k[p].receiver == get_store_value(UserName) && r.push(k[p]);
  return r;
}
async function getUnreadMessages() {
  const k = await getReceivedMessages();
  let r = [];
  for (let p = 0; p < k.length; p++) k[p].read || r.push(k[p]);
  return r;
}
const messagingPage = writable(null);
messagingPage.subscribe(() => {
  setTimeout(messageUpdateTrigger, 100);
});
selectedMessageId.subscribe(() => {
  messageUpdateTrigger(), creatingMessage.set(!1);
});
const MessagingPages = {
  unread: {
    name: "Unread",
    icon: "mark_email_unread",
    msgGetter: getUnreadMessages,
  },
  inbox: { name: "Inbox", icon: "inbox", msgGetter: getReceivedMessages },
  sent: { name: "Sent", icon: "send", msgGetter: getSentMessages },
};
function create_fragment$1Z(k) {
  let r,
    p = k[0].icon + "",
    v,
    $,
    S,
    x;
  return {
    c() {
      (r = element("button")),
        (v = text(p)),
        attr(r, "class", "material-icons-round"),
        attr(r, "title", ($ = k[0].name));
    },
    m(I, F) {
      insert(I, r, F),
        append(r, v),
        S ||
          ((x = listen(r, "click", function () {
            is_function(k[0].action) && k[0].action.apply(this, arguments);
          })),
          (S = !0));
    },
    p(I, [F]) {
      (k = I),
        F & 1 && p !== (p = k[0].icon + "") && set_data(v, p),
        F & 1 && $ !== ($ = k[0].name) && attr(r, "title", $);
    },
    i: noop$1,
    o: noop$1,
    d(I) {
      I && detach(r), (S = !1), x();
    },
  };
}
function instance$1S(k, r, p) {
  let { action: v } = r;
  return (
    (k.$$set = ($) => {
      "action" in $ && p(0, (v = $.action));
    }),
    [v]
  );
}
class Action extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1S, create_fragment$1Z, safe_not_equal, {
        action: 0,
      });
  }
}
function create_fragment$1Y(k) {
  let r,
    p = k[0].icon + "",
    v,
    $,
    S,
    x;
  return {
    c() {
      (r = element("button")),
        (v = text(p)),
        attr(r, "class", "material-icons-round"),
        attr(r, "title", ($ = k[0].name)),
        toggle_class(r, "active", k[1] && k[0].name == k[1].name);
    },
    m(I, F) {
      insert(I, r, F),
        append(r, v),
        S || ((x = listen(r, "click", k[2])), (S = !0));
    },
    p(I, [F]) {
      F & 1 && p !== (p = I[0].icon + "") && set_data(v, p),
        F & 1 && $ !== ($ = I[0].name) && attr(r, "title", $),
        F & 3 && toggle_class(r, "active", I[1] && I[0].name == I[1].name);
    },
    i: noop$1,
    o: noop$1,
    d(I) {
      I && detach(r), (S = !1), x();
    },
  };
}
function instance$1R(k, r, p) {
  let v;
  component_subscribe(k, messagingPage, (I) => p(1, (v = I)));
  let { id: $ } = r,
    { data: S } = r;
  function x() {
    set_store_value(messagingPage, (v = S), v);
  }
  return (
    (k.$$set = (I) => {
      "id" in I && p(3, ($ = I.id)), "data" in I && p(0, (S = I.data));
    }),
    [S, v, x, $]
  );
}
let Page$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1R, create_fragment$1Y, safe_not_equal, {
        id: 3,
        data: 0,
      });
  }
};
function get_each_context$u(k, r, p) {
  const v = k.slice();
  return (v[2] = r[p]), v;
}
function get_each_context_1$4(k, r, p) {
  const v = k.slice();
  return (v[5] = r[p]), v;
}
function create_each_block_1$4(k) {
  let r, p;
  return (
    (r = new Page$1({ props: { id: k[5][0], data: k[5][1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$u(k) {
  let r, p;
  return (
    (r = new Action({ props: { action: k[2] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1X(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L = Object.entries(MessagingPages),
    U = [];
  for (let Q = 0; Q < L.length; Q += 1)
    U[Q] = create_each_block_1$4(get_each_context_1$4(k, L, Q));
  const j = (Q) =>
    transition_out(U[Q], 1, 1, () => {
      U[Q] = null;
    });
  let N = messageSidebarActions,
    q = [];
  for (let Q = 0; Q < N.length; Q += 1)
    q[Q] = create_each_block$u(get_each_context$u(k, N, Q));
  const R = (Q) =>
    transition_out(q[Q], 1, 1, () => {
      q[Q] = null;
    });
  return (
    (F = new ProfilePicture$1({ props: { src: k[0], height: 20 } })),
    {
      c() {
        (r = element("div")), (p = element("div"));
        for (let Q = 0; Q < U.length; Q += 1) U[Q].c();
        (v = space()), ($ = element("hr")), (S = space()), (x = element("div"));
        for (let Q = 0; Q < q.length; Q += 1) q[Q].c();
        (I = space()),
          create_component(F.$$.fragment),
          attr(p, "class", "pages"),
          attr(x, "class", "actions"),
          attr(r, "class", "sidebar");
      },
      m(Q, H) {
        insert(Q, r, H), append(r, p);
        for (let G = 0; G < U.length; G += 1) U[G] && U[G].m(p, null);
        append(r, v), append(r, $), append(r, S), append(r, x);
        for (let G = 0; G < q.length; G += 1) q[G] && q[G].m(x, null);
        append(r, I), mount_component(F, r, null), (O = !0);
      },
      p(Q, [H]) {
        if (H & 0) {
          L = Object.entries(MessagingPages);
          let V;
          for (V = 0; V < L.length; V += 1) {
            const K = get_each_context_1$4(Q, L, V);
            U[V]
              ? (U[V].p(K, H), transition_in(U[V], 1))
              : ((U[V] = create_each_block_1$4(K)),
                U[V].c(),
                transition_in(U[V], 1),
                U[V].m(p, null));
          }
          for (group_outros(), V = L.length; V < U.length; V += 1) j(V);
          check_outros();
        }
        if (H & 0) {
          N = messageSidebarActions;
          let V;
          for (V = 0; V < N.length; V += 1) {
            const K = get_each_context$u(Q, N, V);
            q[V]
              ? (q[V].p(K, H), transition_in(q[V], 1))
              : ((q[V] = create_each_block$u(K)),
                q[V].c(),
                transition_in(q[V], 1),
                q[V].m(x, null));
          }
          for (group_outros(), V = N.length; V < q.length; V += 1) R(V);
          check_outros();
        }
        const G = {};
        H & 1 && (G.src = Q[0]), F.$set(G);
      },
      i(Q) {
        if (!O) {
          for (let H = 0; H < L.length; H += 1) transition_in(U[H]);
          for (let H = 0; H < N.length; H += 1) transition_in(q[H]);
          transition_in(F.$$.fragment, Q), (O = !0);
        }
      },
      o(Q) {
        U = U.filter(Boolean);
        for (let H = 0; H < U.length; H += 1) transition_out(U[H]);
        q = q.filter(Boolean);
        for (let H = 0; H < q.length; H += 1) transition_out(q[H]);
        transition_out(F.$$.fragment, Q), (O = !1);
      },
      d(Q) {
        Q && detach(r),
          destroy_each(U, Q),
          destroy_each(q, Q),
          destroy_component(F);
      },
    }
  );
}
function instance$1Q(k, r, p) {
  let v;
  component_subscribe(k, UserData, (S) => p(1, (v = S)));
  let $;
  return (
    UserData.subscribe(() => {
      p(0, ($ = getProfilePicture(v.acc.profilePicture)));
    }),
    [$]
  );
}
class SideBar extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1Q, create_fragment$1X, safe_not_equal, {});
  }
}
const messaging = "",
  pfpCache = {};
async function getUserPfp(k) {
  if (!get_store_value(ConnectedServer)) return pfp;
  if (pfpCache[k]) return getProfilePicture(pfpCache[k]);
  const p = await getUsers();
  return p[k]
    ? ((pfpCache[k] = getProfilePicture(p[k].acc.profilePicture)), pfpCache[k])
    : pfp;
}
const partialFilters = ["#", "](", "![", "!", ">", "|", "(", ")"];
function filterPartial(k) {
  let r = k;
  for (let p = 0; p < partialFilters.length; p++)
    r = r.split(partialFilters[p]).join("");
  return r;
}
function create_if_block$R(k) {
  let r, p, v;
  return {
    c() {
      (r = element("span")),
        (p = text("reply")),
        attr(r, "class", "material-icons-round"),
        attr(r, "title", (v = k[0].replyingTo));
    },
    m($, S) {
      insert($, r, S), append(r, p);
    },
    p($, S) {
      S & 1 && v !== (v = $[0].replyingTo) && attr(r, "title", v);
    },
    d($) {
      $ && detach(r);
    },
  };
}
function create_fragment$1W(k) {
  let r,
    p,
    v,
    $,
    S,
    x = (k[1] ? k[0].receiver : k[0].sender) + "",
    I,
    F,
    O,
    L,
    U = (filterPartial(k[0].partialBody) || "(no content)") + "",
    j,
    N,
    q,
    R = dayjs(k[0].timestamp).format("DD-MM HH:mm") + "",
    Q,
    H,
    G,
    V;
  p = new ProfilePicture$1({ props: { src: k[2], height: 26 } });
  let K = k[0].replyingTo && create_if_block$R(k);
  return {
    c() {
      (r = element("button")),
        create_component(p.$$.fragment),
        (v = space()),
        ($ = element("div")),
        (S = element("p")),
        (I = text(x)),
        (F = space()),
        K && K.c(),
        (O = space()),
        (L = element("p")),
        (j = text(U)),
        (N = space()),
        (q = element("div")),
        (Q = text(R)),
        attr(S, "class", "username"),
        attr(L, "class", "partial"),
        attr($, "class", "content"),
        attr(q, "class", "timestamp"),
        attr(r, "class", "message"),
        toggle_class(r, "selected", k[3] == k[0].id);
    },
    m(Y, J) {
      insert(Y, r, J),
        mount_component(p, r, null),
        append(r, v),
        append(r, $),
        append($, S),
        append(S, I),
        append(S, F),
        K && K.m(S, null),
        append($, O),
        append($, L),
        append(L, j),
        append(r, N),
        append(r, q),
        append(q, Q),
        (H = !0),
        G || ((V = listen(r, "click", k[4])), (G = !0));
    },
    p(Y, [J]) {
      const Z = {};
      J & 4 && (Z.src = Y[2]),
        p.$set(Z),
        (!H || J & 3) &&
          x !== (x = (Y[1] ? Y[0].receiver : Y[0].sender) + "") &&
          set_data(I, x),
        Y[0].replyingTo
          ? K
            ? K.p(Y, J)
            : ((K = create_if_block$R(Y)), K.c(), K.m(S, null))
          : K && (K.d(1), (K = null)),
        (!H || J & 1) &&
          U !==
            (U = (filterPartial(Y[0].partialBody) || "(no content)") + "") &&
          set_data(j, U),
        (!H || J & 1) &&
          R !== (R = dayjs(Y[0].timestamp).format("DD-MM HH:mm") + "") &&
          set_data(Q, R),
        (!H || J & 9) && toggle_class(r, "selected", Y[3] == Y[0].id);
    },
    i(Y) {
      H || (transition_in(p.$$.fragment, Y), (H = !0));
    },
    o(Y) {
      transition_out(p.$$.fragment, Y), (H = !1);
    },
    d(Y) {
      Y && detach(r), destroy_component(p), K && K.d(), (G = !1), V();
    },
  };
}
function instance$1P(k, r, p) {
  let v;
  component_subscribe(k, selectedMessageId, (O) => p(3, (v = O)));
  let { item: $ } = r,
    S = !1,
    x = "";
  onMount(F), messageSubscribe(F);
  function I() {
    set_store_value(selectedMessageId, (v = $.id), v);
  }
  async function F() {
    p(2, (x = await getUserPfp(S ? $.receiver : $.sender)));
  }
  return (
    messagingPage.subscribe((O) => {
      p(1, (S = O.name == "Sent"));
    }),
    (k.$$set = (O) => {
      "item" in O && p(0, ($ = O.item));
    }),
    [$, S, x, v, I]
  );
}
class MessageItem extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1P, create_fragment$1W, safe_not_equal, {
        item: 0,
      });
  }
}
function get_each_context$t(k, r, p) {
  const v = k.slice();
  return (v[5] = r[p]), v;
}
function create_if_block$Q(k) {
  let r,
    p,
    v = k[2].name + "",
    $,
    S,
    x,
    I,
    F,
    O,
    L,
    U,
    j,
    N = k[0],
    q = [];
  for (let H = 0; H < N.length; H += 1)
    q[H] = create_each_block$t(get_each_context$t(k, N, H));
  const R = (H) =>
    transition_out(q[H], 1, 1, () => {
      q[H] = null;
    });
  let Q = !k[0].length && create_if_block_1$d(k);
  return {
    c() {
      (r = element("div")),
        (p = element("p")),
        ($ = text(v)),
        (S = space()),
        (x = element("button")),
        (x.textContent = "sync"),
        (I = space()),
        (F = element("div"));
      for (let H = 0; H < q.length; H += 1) q[H].c();
      (O = space()),
        Q && Q.c(),
        attr(p, "class", "title"),
        attr(x, "class", "material-icons-round refresh"),
        attr(r, "class", "header"),
        attr(F, "class", "list");
    },
    m(H, G) {
      insert(H, r, G),
        append(r, p),
        append(p, $),
        append(r, S),
        append(r, x),
        insert(H, I, G),
        insert(H, F, G);
      for (let V = 0; V < q.length; V += 1) q[V] && q[V].m(F, null);
      append(F, O),
        Q && Q.m(F, null),
        (L = !0),
        U || ((j = listen(x, "click", k[3])), (U = !0));
    },
    p(H, G) {
      if (
        ((!L || G & 4) && v !== (v = H[2].name + "") && set_data($, v), G & 1)
      ) {
        N = H[0];
        let V;
        for (V = 0; V < N.length; V += 1) {
          const K = get_each_context$t(H, N, V);
          q[V]
            ? (q[V].p(K, G), transition_in(q[V], 1))
            : ((q[V] = create_each_block$t(K)),
              q[V].c(),
              transition_in(q[V], 1),
              q[V].m(F, O));
        }
        for (group_outros(), V = N.length; V < q.length; V += 1) R(V);
        check_outros();
      }
      H[0].length
        ? Q && (Q.d(1), (Q = null))
        : Q
        ? Q.p(H, G)
        : ((Q = create_if_block_1$d(H)), Q.c(), Q.m(F, null));
    },
    i(H) {
      if (!L) {
        for (let G = 0; G < N.length; G += 1) transition_in(q[G]);
        L = !0;
      }
    },
    o(H) {
      q = q.filter(Boolean);
      for (let G = 0; G < q.length; G += 1) transition_out(q[G]);
      L = !1;
    },
    d(H) {
      H && detach(r),
        H && detach(I),
        H && detach(F),
        destroy_each(q, H),
        Q && Q.d(),
        (U = !1),
        j();
    },
  };
}
function create_each_block$t(k) {
  let r, p;
  return (
    (r = new MessageItem({ props: { item: k[5] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.item = v[5]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_1$d(k) {
  let r,
    p = k[1] ? "Loading..." : "No messages!",
    v;
  return {
    c() {
      (r = element("div")), (v = text(p)), attr(r, "class", "noitems");
    },
    m($, S) {
      insert($, r, S), append(r, v);
    },
    p($, S) {
      S & 2 &&
        p !== (p = $[1] ? "Loading..." : "No messages!") &&
        set_data(v, p);
    },
    d($) {
      $ && detach(r);
    },
  };
}
function create_fragment$1V(k) {
  let r,
    p,
    v = k[2] && create_if_block$Q(k);
  return {
    c() {
      (r = element("div")), v && v.c(), attr(r, "class", "listbar");
    },
    m($, S) {
      insert($, r, S), v && v.m(r, null), (p = !0);
    },
    p($, [S]) {
      $[2]
        ? v
          ? (v.p($, S), S & 4 && transition_in(v, 1))
          : ((v = create_if_block$Q($)),
            v.c(),
            transition_in(v, 1),
            v.m(r, null))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      $ && detach(r), v && v.d();
    },
  };
}
function sort(k) {
  return k.sort(function (r, p) {
    return new Date(p.timestamp).getTime() - new Date(r.timestamp).getTime();
  });
}
function isSame(k, r) {
  if (k.length != r.length) return !1;
  for (let p = 0; p < r.length; p++) {
    let v = !1;
    for (let $ = 0; $ < k.length; $++) k[$].id == r[p].id && (v = !0);
    if (!v) return !1;
  }
  return !0;
}
function instance$1O(k, r, p) {
  let v;
  component_subscribe(k, messagingPage, (F) => p(2, (v = F)));
  let $ = [],
    S = !1;
  onMount(() => {
    messageUpdateTrigger();
  }),
    messageSubscribe(x);
  async function x() {
    if ((p(1, (S = !0)), !v)) return;
    const F = await v.msgGetter();
    isSame($, F) || I(sort(F)), p(1, (S = !1));
  }
  function I(F) {
    p(0, ($ = [])),
      setTimeout(() => {
        p(0, ($ = F));
      });
  }
  return [$, S, v, x];
}
class ListBar extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1O, create_fragment$1V, safe_not_equal, {});
  }
}
async function sendMessage(k, r) {
  const p = await get_store_value(ConnectedServer);
  return p
    ? !(await apiCall(
        p,
        "messages/send",
        { target: btoa(k) },
        get_store_value(UserToken),
        null,
        r
      ))
    : !1;
}
async function replyToMessage(k, r, p) {
  const v = await get_store_value(ConnectedServer);
  return v
    ? !(await apiCall(
        v,
        "messages/reply",
        { target: btoa(r), id: k },
        get_store_value(UserToken),
        null,
        p
      ))
    : !1;
}
function create_if_block$P(k) {
  let r,
    p = 2e3 - k[1].length + "",
    v;
  return {
    c() {
      (r = element("div")),
        (v = text(p)),
        attr(r, "class", "counter"),
        toggle_class(r, "critical", k[1].length > 1980);
    },
    m($, S) {
      insert($, r, S), append(r, v);
    },
    p($, S) {
      S & 2 && p !== (p = 2e3 - $[1].length + "") && set_data(v, p),
        S & 2 && toggle_class(r, "critical", $[1].length > 1980);
    },
    d($) {
      $ && detach(r);
    },
  };
}
function create_fragment$1U(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L,
    U,
    j = k[3] ? "Reply" : "Send",
    N,
    q,
    R,
    Q,
    H = k[1].length > 1950 && create_if_block$P(k);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("button")),
        (v.textContent = "remove_red_eye"),
        ($ = space()),
        (S = element("button")),
        (S.textContent = "edit"),
        (x = space()),
        H && H.c(),
        (I = space()),
        (F = element("div")),
        (O = element("button")),
        (O.textContent = "Delete"),
        (L = space()),
        (U = element("button")),
        (N = text(j)),
        attr(v, "class", "material-icons-round"),
        toggle_class(v, "selected", k[0]),
        attr(S, "class", "material-icons-round"),
        toggle_class(S, "selected", !k[0]),
        attr(p, "class", "view-group"),
        (U.disabled = q = !k[1] || !k[2]),
        attr(F, "class", "right"),
        attr(r, "class", "editor-send");
    },
    m(G, V) {
      insert(G, r, V),
        append(r, p),
        append(p, v),
        append(p, $),
        append(p, S),
        append(r, x),
        H && H.m(r, null),
        append(r, I),
        append(r, F),
        append(F, O),
        append(F, L),
        append(F, U),
        append(U, N),
        R ||
          ((Q = [
            listen(v, "click", k[7]),
            listen(S, "click", k[6]),
            listen(O, "click", k[5]),
            listen(U, "click", k[4]),
          ]),
          (R = !0));
    },
    p(G, [V]) {
      V & 1 && toggle_class(v, "selected", G[0]),
        V & 1 && toggle_class(S, "selected", !G[0]),
        G[1].length > 1950
          ? H
            ? H.p(G, V)
            : ((H = create_if_block$P(G)), H.c(), H.m(r, I))
          : H && (H.d(1), (H = null)),
        V & 8 && j !== (j = G[3] ? "Reply" : "Send") && set_data(N, j),
        V & 6 && q !== (q = !G[1] || !G[2]) && (U.disabled = q);
    },
    i: noop$1,
    o: noop$1,
    d(G) {
      G && detach(r), H && H.d(), (R = !1), run_all(Q);
    },
  };
}
function instance$1N(k, r, p) {
  let v;
  component_subscribe(k, replyMessageId, (U) => p(3, (v = U)));
  let { content: $ } = r,
    { target: S } = r,
    { viewing: x } = r;
  async function I() {
    v ? await replyToMessage(v, S, $) : await sendMessage(S, $),
      creatingMessage.set(!1),
      messageUpdateTrigger();
  }
  function F() {
    createOverlayableError(
      {
        title: "Delete message?",
        message:
          "Are you sure you want to delete this draft? This cannot be undone.",
        image: warning,
        buttons: [
          {
            caption: "Delete",
            action: () => {
              creatingMessage.set(!1), messageUpdateTrigger();
            },
          },
          { caption: "Cancel", action: () => {} },
        ],
      },
      "MessagingApp"
    );
  }
  function O() {
    p(0, (x = !1));
  }
  function L() {
    p(0, (x = !0));
  }
  return (
    (k.$$set = (U) => {
      "content" in U && p(1, ($ = U.content)),
        "target" in U && p(2, (S = U.target)),
        "viewing" in U && p(0, (x = U.viewing));
    }),
    [x, $, S, v, I, F, O, L]
  );
}
class Bottom extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1N, create_fragment$1U, safe_not_equal, {
        content: 1,
        target: 2,
        viewing: 0,
      });
  }
}
function create_fragment$1T(k) {
  let r,
    p,
    v,
    $,
    S = (k[0][0] || "<unknown>") + "",
    x,
    I,
    F,
    O;
  return (
    (p = new ProfilePicture$1({ props: { src: k[1] || pfp, height: 24 } })),
    {
      c() {
        (r = element("button")),
          create_component(p.$$.fragment),
          (v = space()),
          ($ = element("p")),
          (x = text(S)),
          attr(r, "class", "user");
      },
      m(L, U) {
        insert(L, r, U),
          mount_component(p, r, null),
          append(r, v),
          append(r, $),
          append($, x),
          (I = !0),
          F || ((O = listen(r, "click", k[2])), (F = !0));
      },
      p(L, [U]) {
        const j = {};
        U & 2 && (j.src = L[1] || pfp),
          p.$set(j),
          (!I || U & 1) &&
            S !== (S = (L[0][0] || "<unknown>") + "") &&
            set_data(x, S);
      },
      i(L) {
        I || (transition_in(p.$$.fragment, L), (I = !0));
      },
      o(L) {
        transition_out(p.$$.fragment, L), (I = !1);
      },
      d(L) {
        L && detach(r), destroy_component(p), (F = !1), O();
      },
    }
  );
}
function instance$1M(k, r, p) {
  let { selecting: v } = r,
    { target: $ } = r,
    { entry: S } = r,
    { pfp: x } = r,
    I;
  onMount(async () => {
    p(1, (I = await getUserPfp(S[0])));
  });
  function F() {
    p(3, (v = !1)), p(4, ($ = S[0])), p(5, (x = I));
  }
  return (
    (k.$$set = (O) => {
      "selecting" in O && p(3, (v = O.selecting)),
        "target" in O && p(4, ($ = O.target)),
        "entry" in O && p(0, (S = O.entry)),
        "pfp" in O && p(5, (x = O.pfp));
    }),
    [S, I, F, v, $, x]
  );
}
let User$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1M, create_fragment$1T, safe_not_equal, {
        selecting: 3,
        target: 4,
        entry: 0,
        pfp: 5,
      });
  }
};
function get_each_context$s(k, r, p) {
  const v = k.slice();
  return (v[10] = r[p]), v;
}
function create_each_block$s(k) {
  let r, p, v, $, S;
  function x(L) {
    k[6](L);
  }
  function I(L) {
    k[7](L);
  }
  function F(L) {
    k[8](L);
  }
  let O = { entry: k[10] };
  return (
    k[0] !== void 0 && (O.target = k[0]),
    k[3] !== void 0 && (O.selecting = k[3]),
    k[2] !== void 0 && (O.pfp = k[2]),
    (r = new User$1({ props: O })),
    binding_callbacks.push(() => bind$1(r, "target", x)),
    binding_callbacks.push(() => bind$1(r, "selecting", I)),
    binding_callbacks.push(() => bind$1(r, "pfp", F)),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(L, U) {
        mount_component(r, L, U), (S = !0);
      },
      p(L, U) {
        const j = {};
        U & 2 && (j.entry = L[10]),
          !p &&
            U & 1 &&
            ((p = !0), (j.target = L[0]), add_flush_callback(() => (p = !1))),
          !v &&
            U & 8 &&
            ((v = !0),
            (j.selecting = L[3]),
            add_flush_callback(() => (v = !1))),
          !$ &&
            U & 4 &&
            (($ = !0), (j.pfp = L[2]), add_flush_callback(() => ($ = !1))),
          r.$set(j);
      },
      i(L) {
        S || (transition_in(r.$$.fragment, L), (S = !0));
      },
      o(L) {
        transition_out(r.$$.fragment, L), (S = !1);
      },
      d(L) {
        destroy_component(r, L);
      },
    }
  );
}
function create_fragment$1S(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F = k[4] ? "Reply" : "Send",
    O,
    L,
    U,
    j,
    N = (k[4] ? `#${k[4]} (${k[0]})` : k[0] || "Please select") + "",
    q,
    R,
    Q,
    H,
    G,
    V;
  $ = new ProfilePicture$1({ props: { src: k[2] || pfp, height: 32 } });
  let K = k[1],
    Y = [];
  for (let Z = 0; Z < K.length; Z += 1)
    Y[Z] = create_each_block$s(get_each_context$s(k, K, Z));
  const J = (Z) =>
    transition_out(Y[Z], 1, 1, () => {
      Y[Z] = null;
    });
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("div")),
        create_component($.$$.fragment),
        (S = space()),
        (x = element("div")),
        (I = element("p")),
        (O = text(F)),
        (L = text(" to:")),
        (U = space()),
        (j = element("p")),
        (q = text(N)),
        (R = space()),
        (Q = element("div"));
      for (let Z = 0; Z < Y.length; Z += 1) Y[Z].c();
      attr(I, "class", "header"),
        attr(v, "class", "current"),
        attr(p, "class", "target-selector"),
        attr(Q, "class", "target-options"),
        toggle_class(Q, "visible", k[3]),
        attr(r, "class", "target-wrapper");
    },
    m(Z, X) {
      insert(Z, r, X),
        append(r, p),
        append(p, v),
        mount_component($, v, null),
        append(v, S),
        append(v, x),
        append(x, I),
        append(I, O),
        append(I, L),
        append(x, U),
        append(x, j),
        append(j, q),
        append(r, R),
        append(r, Q);
      for (let ee = 0; ee < Y.length; ee += 1) Y[ee] && Y[ee].m(Q, null);
      (H = !0), G || ((V = listen(p, "click", k[5])), (G = !0));
    },
    p(Z, [X]) {
      const ee = {};
      if (
        (X & 4 && (ee.src = Z[2] || pfp),
        $.$set(ee),
        (!H || X & 16) && F !== (F = Z[4] ? "Reply" : "Send") && set_data(O, F),
        (!H || X & 17) &&
          N !==
            (N =
              (Z[4] ? `#${Z[4]} (${Z[0]})` : Z[0] || "Please select") + "") &&
          set_data(q, N),
        X & 15)
      ) {
        K = Z[1];
        let te;
        for (te = 0; te < K.length; te += 1) {
          const re = get_each_context$s(Z, K, te);
          Y[te]
            ? (Y[te].p(re, X), transition_in(Y[te], 1))
            : ((Y[te] = create_each_block$s(re)),
              Y[te].c(),
              transition_in(Y[te], 1),
              Y[te].m(Q, null));
        }
        for (group_outros(), te = K.length; te < Y.length; te += 1) J(te);
        check_outros();
      }
      (!H || X & 8) && toggle_class(Q, "visible", Z[3]);
    },
    i(Z) {
      if (!H) {
        transition_in($.$$.fragment, Z);
        for (let X = 0; X < K.length; X += 1) transition_in(Y[X]);
        H = !0;
      }
    },
    o(Z) {
      transition_out($.$$.fragment, Z), (Y = Y.filter(Boolean));
      for (let X = 0; X < Y.length; X += 1) transition_out(Y[X]);
      H = !1;
    },
    d(Z) {
      Z && detach(r), destroy_component($), destroy_each(Y, Z), (G = !1), V();
    },
  };
}
function instance$1L(k, r, p) {
  let v;
  component_subscribe(k, replyMessageId, (N) => p(4, (v = N)));
  let { users: $ } = r,
    { target: S } = r,
    x = "",
    I = !1;
  async function F() {
    p(2, (x = await getUserPfp(S)));
  }
  function O() {
    if (v) return p(3, (I = !1));
    p(3, (I = !I));
  }
  replyMessageId.subscribe(() => setTimeout(F, 500));
  function L(N) {
    (S = N), p(0, S);
  }
  function U(N) {
    (I = N), p(3, I);
  }
  function j(N) {
    (x = N), p(2, x);
  }
  return (
    (k.$$set = (N) => {
      "users" in N && p(1, ($ = N.users)),
        "target" in N && p(0, (S = N.target));
    }),
    [S, $, x, I, v, O, L, U, j]
  );
}
class TargetSelector extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1L, create_fragment$1S, safe_not_equal, {
        users: 1,
        target: 0,
      });
  }
}
function create_else_block$e(k) {
  let r, p, v;
  return (
    (p = new SvelteMarkdown({ props: { source: k[2] } })),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          attr(r, "class", "markdownrenderer");
      },
      m($, S) {
        insert($, r, S), mount_component(p, r, null), (v = !0);
      },
      p($, S) {
        const x = {};
        S & 4 && (x.source = $[2]), p.$set(x);
      },
      i($) {
        v || (transition_in(p.$$.fragment, $), (v = !0));
      },
      o($) {
        transition_out(p.$$.fragment, $), (v = !1);
      },
      d($) {
        $ && detach(r), destroy_component(p);
      },
    }
  );
}
function create_if_block$O(k) {
  let r, p, v;
  return {
    c() {
      (r = element("textarea")),
        attr(r, "placeholder", "New message"),
        attr(r, "maxlength", "2000");
    },
    m($, S) {
      insert($, r, S),
        set_input_value(r, k[2]),
        p || ((v = listen(r, "input", k[5])), (p = !0));
    },
    p($, S) {
      S & 4 && set_input_value(r, $[2]);
    },
    i: noop$1,
    o: noop$1,
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_fragment$1R(k) {
  let r, p, v, $, S, x, I, F, O, L;
  function U(G) {
    k[4](G);
  }
  let j = { users: k[0] };
  k[1] !== void 0 && (j.target = k[1]),
    (p = new TargetSelector({ props: j })),
    binding_callbacks.push(() => bind$1(p, "target", U));
  const N = [create_if_block$O, create_else_block$e],
    q = [];
  function R(G, V) {
    return G[3] ? 1 : 0;
  }
  (S = R(k)), (x = q[S] = N[S](k));
  function Q(G) {
    k[6](G);
  }
  let H = { target: k[1], content: k[2] };
  return (
    k[3] !== void 0 && (H.viewing = k[3]),
    (F = new Bottom({ props: H })),
    binding_callbacks.push(() => bind$1(F, "viewing", Q)),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          ($ = space()),
          x.c(),
          (I = space()),
          create_component(F.$$.fragment),
          attr(r, "class", "editor");
      },
      m(G, V) {
        insert(G, r, V),
          mount_component(p, r, null),
          insert(G, $, V),
          q[S].m(G, V),
          insert(G, I, V),
          mount_component(F, G, V),
          (L = !0);
      },
      p(G, [V]) {
        const K = {};
        V & 1 && (K.users = G[0]),
          !v &&
            V & 2 &&
            ((v = !0), (K.target = G[1]), add_flush_callback(() => (v = !1))),
          p.$set(K);
        let Y = S;
        (S = R(G)),
          S === Y
            ? q[S].p(G, V)
            : (group_outros(),
              transition_out(q[Y], 1, 1, () => {
                q[Y] = null;
              }),
              check_outros(),
              (x = q[S]),
              x ? x.p(G, V) : ((x = q[S] = N[S](G)), x.c()),
              transition_in(x, 1),
              x.m(I.parentNode, I));
        const J = {};
        V & 2 && (J.target = G[1]),
          V & 4 && (J.content = G[2]),
          !O &&
            V & 8 &&
            ((O = !0), (J.viewing = G[3]), add_flush_callback(() => (O = !1))),
          F.$set(J);
      },
      i(G) {
        L ||
          (transition_in(p.$$.fragment, G),
          transition_in(x),
          transition_in(F.$$.fragment, G),
          (L = !0));
      },
      o(G) {
        transition_out(p.$$.fragment, G),
          transition_out(x),
          transition_out(F.$$.fragment, G),
          (L = !1);
      },
      d(G) {
        G && detach(r),
          destroy_component(p),
          G && detach($),
          q[S].d(G),
          G && detach(I),
          destroy_component(F, G);
      },
    }
  );
}
function instance$1K(k, r, p) {
  let v = [],
    $ = "",
    S = "",
    x = !1;
  onMount(async () => {
    p(0, (v = Object.entries(await getUsers())));
  }),
    replyMessageId.subscribe(async (L) => {
      if (!L) return;
      const U = await getMessage(L);
      U && p(1, ($ = U.sender));
    });
  function I(L) {
    ($ = L), p(1, $);
  }
  function F() {
    (S = this.value), p(2, S);
  }
  function O(L) {
    (x = L), p(3, x);
  }
  return [v, $, S, x, I, F, O];
}
class Editor extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1K, create_fragment$1R, safe_not_equal, {});
  }
}
function create_fragment$1Q(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (x = element("p")),
        (x.textContent = "No content."),
        (I = space()),
        (F = element("p")),
        (F.textContent = "Please select a message or create a new one."),
        (O = space()),
        (L = element("br")),
        (U = space()),
        (j = element("button")),
        (j.textContent = "New Message"),
        src_url_equal(v.src, ($ = logo$2)) || attr(v, "src", $),
        attr(v, "alt", "Messaging"),
        attr(x, "class", "header"),
        attr(p, "class", "no-content"),
        attr(r, "class", "no-content-wrapper");
    },
    m(R, Q) {
      insert(R, r, Q),
        append(r, p),
        append(p, v),
        append(p, S),
        append(p, x),
        append(p, I),
        append(p, F),
        append(p, O),
        append(p, L),
        append(p, U),
        append(p, j),
        N || ((q = listen(j, "click", k[1])), (N = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(R) {
      R && detach(r), (N = !1), q();
    },
  };
}
function instance$1J(k, r, p) {
  let v;
  return (
    component_subscribe(k, creatingMessage, (S) => p(0, (v = S))),
    [v, () => set_store_value(creatingMessage, (v = !0), v)]
  );
}
class NoContent extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1J, create_fragment$1Q, safe_not_equal, {});
  }
}
const content = "";
async function getPartialTree(k) {
  const r = get_store_value(ConnectedServer);
  return r
    ? (
        await apiCall(
          r,
          "messages/thread",
          { id: btoa(k) },
          get_store_value(UserToken)
        )
      ).data
    : !1;
}
async function getParentMessage(k) {
  const r = await getMessages();
  let p;
  for (let $ = 0; $ < r.length; $++) r[$].id == k && (p = r[$].replyingTo);
  if (!p) return;
  const v = await getMessage(p);
  return v.replyingTo ? await getParentMessage(p) : v;
}
function get_each_context$r(k, r, p) {
  const v = k.slice();
  return (v[4] = r[p]), v;
}
function create_if_block$N(k) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        src_url_equal(p.src, (v = warning)) || attr(p, "src", v),
        attr(p, "alt", ""),
        attr(r, "class", "material-icons-round"),
        attr(r, "title", "Receiver no longer exists");
    },
    m($, S) {
      insert($, r, S), append(r, p);
    },
    p: noop$1,
    d($) {
      $ && detach(r);
    },
  };
}
function create_each_block$r(k) {
  let r,
    p = k[4].icon + "",
    v,
    $,
    S;
  function x() {
    return k[3](k[4]);
  }
  return {
    c() {
      (r = element("button")),
        (v = text(p)),
        attr(r, "class", "material-icons-round"),
        attr(r, "title", k[4].name);
    },
    m(I, F) {
      insert(I, r, F),
        append(r, v),
        $ || ((S = listen(r, "click", x)), ($ = !0));
    },
    p(I, F) {
      k = I;
    },
    d(I) {
      I && detach(r), ($ = !1), S();
    },
  };
}
function create_fragment$1P(k) {
  let r,
    p,
    v,
    $,
    S,
    x = k[0].sender + "",
    I,
    F,
    O,
    L = k[2](k[0].timestamp) + "",
    U,
    j,
    N,
    q = k[0].receiver.startsWith("deleted#"),
    R,
    Q;
  p = new ProfilePicture$1({ props: { height: 32, src: k[1] } });
  let H = q && create_if_block$N(),
    G = messageItemActions,
    V = [];
  for (let K = 0; K < G.length; K += 1)
    V[K] = create_each_block$r(get_each_context$r(k, G, K));
  return {
    c() {
      (r = element("div")),
        create_component(p.$$.fragment),
        (v = space()),
        ($ = element("div")),
        (S = element("p")),
        (I = text(x)),
        (F = space()),
        (O = element("p")),
        (U = text(L)),
        (j = space()),
        (N = element("div")),
        H && H.c(),
        (R = space());
      for (let K = 0; K < V.length; K += 1) V[K].c();
      attr(S, "class", "name"),
        attr(O, "class", "id"),
        attr($, "class", "context"),
        attr(N, "class", "actions"),
        attr(r, "class", "message-header");
    },
    m(K, Y) {
      insert(K, r, Y),
        mount_component(p, r, null),
        append(r, v),
        append(r, $),
        append($, S),
        append(S, I),
        append($, F),
        append($, O),
        append(O, U),
        append(r, j),
        append(r, N),
        H && H.m(N, null),
        append(N, R);
      for (let J = 0; J < V.length; J += 1) V[J] && V[J].m(N, null);
      Q = !0;
    },
    p(K, [Y]) {
      const J = {};
      if (
        (Y & 2 && (J.src = K[1]),
        p.$set(J),
        (!Q || Y & 1) && x !== (x = K[0].sender + "") && set_data(I, x),
        (!Q || Y & 1) &&
          L !== (L = K[2](K[0].timestamp) + "") &&
          set_data(U, L),
        Y & 1 && (q = K[0].receiver.startsWith("deleted#")),
        q
          ? H
            ? H.p(K, Y)
            : ((H = create_if_block$N()), H.c(), H.m(N, R))
          : H && (H.d(1), (H = null)),
        Y & 1)
      ) {
        G = messageItemActions;
        let Z;
        for (Z = 0; Z < G.length; Z += 1) {
          const X = get_each_context$r(K, G, Z);
          V[Z]
            ? V[Z].p(X, Y)
            : ((V[Z] = create_each_block$r(X)), V[Z].c(), V[Z].m(N, null));
        }
        for (; Z < V.length; Z += 1) V[Z].d(1);
        V.length = G.length;
      }
    },
    i(K) {
      Q || (transition_in(p.$$.fragment, K), (Q = !0));
    },
    o(K) {
      transition_out(p.$$.fragment, K), (Q = !1);
    },
    d(K) {
      K && detach(r), destroy_component(p), H && H.d(), destroy_each(V, K);
    },
  };
}
function instance$1I(k, r, p) {
  let { message: v } = r,
    $ = "";
  onMount(async () => {
    p(1, ($ = await getUserPfp(v.sender)));
  }),
    messageSubscribe(async () => {
      p(1, ($ = await getUserPfp(v.sender)));
    });
  function S(I) {
    return dayjs(I).format("DD MMM, HH:mm");
  }
  const x = (I) => I.action(v);
  return (
    (k.$$set = (I) => {
      "message" in I && p(0, (v = I.message));
    }),
    [v, $, S, x]
  );
}
class Header extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1I, create_fragment$1P, safe_not_equal, {
        message: 0,
      });
  }
}
function create_if_block$M(k) {
  let r,
    p,
    v,
    $,
    S,
    x = k[1] ? "Loading..." : "View Thread",
    I,
    F,
    O;
  return {
    c() {
      (r = element("div")),
        (p = element("p")),
        (p.textContent = "Message is part of a thread."),
        (v = space()),
        ($ = element("div")),
        (S = element("button")),
        (I = text(x)),
        attr(p, "class", "caption"),
        (S.disabled = k[1]),
        attr($, "class", "right"),
        attr(r, "class", "reply-wrapper");
    },
    m(L, U) {
      insert(L, r, U),
        append(r, p),
        append(r, v),
        append(r, $),
        append($, S),
        append(S, I),
        F || ((O = listen(S, "click", k[2])), (F = !0));
    },
    p(L, U) {
      U & 2 &&
        x !== (x = L[1] ? "Loading..." : "View Thread") &&
        set_data(I, x),
        U & 2 && (S.disabled = L[1]);
    },
    d(L) {
      L && detach(r), (F = !1), O();
    },
  };
}
function create_fragment$1O(k) {
  let r, p, v, $, S, x, I;
  (r = new Header({ props: { message: k[0] } })),
    ($ = new SvelteMarkdown({ props: { source: k[0].body } }));
  let F = (k[0].replyingTo || k[0].replies) && create_if_block$M(k);
  return {
    c() {
      create_component(r.$$.fragment),
        (p = space()),
        (v = element("div")),
        create_component($.$$.fragment),
        (S = space()),
        F && F.c(),
        (x = empty()),
        attr(v, "class", "markdownrenderer");
    },
    m(O, L) {
      mount_component(r, O, L),
        insert(O, p, L),
        insert(O, v, L),
        mount_component($, v, null),
        insert(O, S, L),
        F && F.m(O, L),
        insert(O, x, L),
        (I = !0);
    },
    p(O, [L]) {
      const U = {};
      L & 1 && (U.message = O[0]), r.$set(U);
      const j = {};
      L & 1 && (j.source = O[0].body),
        $.$set(j),
        O[0].replyingTo || O[0].replies
          ? F
            ? F.p(O, L)
            : ((F = create_if_block$M(O)), F.c(), F.m(x.parentNode, x))
          : F && (F.d(1), (F = null));
    },
    i(O) {
      I ||
        (transition_in(r.$$.fragment, O),
        transition_in($.$$.fragment, O),
        (I = !0));
    },
    o(O) {
      transition_out(r.$$.fragment, O),
        transition_out($.$$.fragment, O),
        (I = !1);
    },
    d(O) {
      destroy_component(r, O),
        O && detach(p),
        O && detach(v),
        destroy_component($),
        O && detach(S),
        F && F.d(O),
        O && detach(x);
    },
  };
}
function instance$1H(k, r, p) {
  let { message: v } = r,
    $ = !1;
  async function S() {
    p(1, ($ = !0));
    const x =
      v.replies && !v.replyingTo ? v.id : (await getParentMessage(v.id)).id;
    threadMessageId.set(x),
      showOverlay("thread", "MessagingApp"),
      p(1, ($ = !1));
  }
  return (
    (k.$$set = (x) => {
      "message" in x && p(0, (v = x.message));
    }),
    [v, $, S]
  );
}
class Viewer extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1H, create_fragment$1O, safe_not_equal, {
        message: 0,
      });
  }
}
function create_else_block$d(k) {
  let r, p;
  return (
    (r = new NoContent({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_1$c(k) {
  let r, p;
  return (
    (r = new Editor({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$L(k) {
  let r, p;
  return (
    (r = new Viewer({ props: { message: k[0] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.message = v[0]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1N(k) {
  let r, p, v, $;
  const S = [create_if_block$L, create_if_block_1$c, create_else_block$d],
    x = [];
  function I(F, O) {
    return F[0] && !F[1] ? 0 : F[1] ? 1 : 2;
  }
  return (
    (p = I(k)),
    (v = x[p] = S[p](k)),
    {
      c() {
        (r = element("div")), v.c(), attr(r, "class", "content");
      },
      m(F, O) {
        insert(F, r, O), x[p].m(r, null), ($ = !0);
      },
      p(F, [O]) {
        let L = p;
        (p = I(F)),
          p === L
            ? x[p].p(F, O)
            : (group_outros(),
              transition_out(x[L], 1, 1, () => {
                x[L] = null;
              }),
              check_outros(),
              (v = x[p]),
              v ? v.p(F, O) : ((v = x[p] = S[p](F)), v.c()),
              transition_in(v, 1),
              v.m(r, null));
      },
      i(F) {
        $ || (transition_in(v), ($ = !0));
      },
      o(F) {
        transition_out(v), ($ = !1);
      },
      d(F) {
        F && detach(r), x[p].d();
      },
    }
  );
}
function instance$1G(k, r, p) {
  let v;
  component_subscribe(k, creatingMessage, (S) => p(1, (v = S)));
  let $;
  return (
    selectedMessageId.subscribe(async (S) => {
      if (!S) return p(0, ($ = null));
      const x = await getMessage(S);
      if (!x)
        return createOverlayableError(
          {
            title: "Can't open message",
            message: `No message with ID ${S} could be found on ArcAPI.`,
            buttons: [{ caption: "OK", action() {} }],
            image: logo$2,
          },
          "MessagingApp"
        );
      p(0, ($ = null)),
        setTimeout(() => {
          p(0, ($ = x));
        });
    }),
    [$, v]
  );
}
let Content$2 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1G, create_fragment$1N, safe_not_equal, {});
  }
};
function create_if_block$K(k) {
  let r, p, v, $;
  return (
    (r = new ListBar({})),
    (v = new Content$2({})),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          create_component(v.$$.fragment);
      },
      m(S, x) {
        mount_component(r, S, x),
          insert(S, p, x),
          mount_component(v, S, x),
          ($ = !0);
      },
      i(S) {
        $ ||
          (transition_in(r.$$.fragment, S),
          transition_in(v.$$.fragment, S),
          ($ = !0));
      },
      o(S) {
        transition_out(r.$$.fragment, S),
          transition_out(v.$$.fragment, S),
          ($ = !1);
      },
      d(S) {
        destroy_component(r, S), S && detach(p), destroy_component(v, S);
      },
    }
  );
}
function create_fragment$1M(k) {
  let r, p, v, $;
  r = new SideBar({});
  let S = k[0] && create_if_block$K();
  return {
    c() {
      create_component(r.$$.fragment), (p = space()), S && S.c(), (v = empty());
    },
    m(x, I) {
      mount_component(r, x, I),
        insert(x, p, I),
        S && S.m(x, I),
        insert(x, v, I),
        ($ = !0);
    },
    p(x, [I]) {
      x[0]
        ? S
          ? I & 1 && transition_in(S, 1)
          : ((S = create_if_block$K()),
            S.c(),
            transition_in(S, 1),
            S.m(v.parentNode, v))
        : S &&
          (group_outros(),
          transition_out(S, 1, 1, () => {
            S = null;
          }),
          check_outros());
    },
    i(x) {
      $ || (transition_in(r.$$.fragment, x), transition_in(S), ($ = !0));
    },
    o(x) {
      transition_out(r.$$.fragment, x), transition_out(S), ($ = !1);
    },
    d(x) {
      destroy_component(r, x), x && detach(p), S && S.d(x), x && detach(v);
    },
  };
}
function instance$1F(k, r, p) {
  let v;
  return (
    component_subscribe(k, messagingPage, ($) => p(0, (v = $))),
    onMount(() => {
      set_store_value(messagingPage, (v = MessagingPages.inbox), v);
    }),
    [v]
  );
}
let MessagingApp$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1F, create_fragment$1M, safe_not_equal, {});
  }
};
const thread = "";
function create_fragment$1L(k) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.textContent = "close"),
        attr(r, "class", "overlay-close material-icons-round");
    },
    m($, S) {
      insert($, r, S), p || ((v = listen(r, "click", k[0])), (p = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function instance$1E(k, r, p) {
  let { app: v } = r,
    { id: $ } = r;
  function S() {
    hideOverlay($, v.id);
  }
  return (
    (k.$$set = (x) => {
      "app" in x && p(1, (v = x.app)), "id" in x && p(2, ($ = x.id));
    }),
    [S, v, $]
  );
}
class CloseButton extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1E, create_fragment$1L, safe_not_equal, {
        app: 1,
        id: 2,
      });
  }
}
function get_each_context$q(k, r, p) {
  const v = k.slice();
  return (v[1] = r[p]), v;
}
function create_if_block$J(k) {
  let r,
    p,
    v = k[0],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$q(get_each_context$q(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = empty();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 1) {
        v = x[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$q(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$q(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_each_block$q(k) {
  let r, p;
  return (
    (r = new Item$2({ props: { item: k[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.item = v[1]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1K(k) {
  let r,
    p,
    v = k[0] && create_if_block$J(k);
  return {
    c() {
      (r = element("div")), v && v.c(), attr(r, "class", "branch");
    },
    m($, S) {
      insert($, r, S), v && v.m(r, null), (p = !0);
    },
    p($, [S]) {
      $[0]
        ? v
          ? (v.p($, S), S & 1 && transition_in(v, 1))
          : ((v = create_if_block$J($)),
            v.c(),
            transition_in(v, 1),
            v.m(r, null))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      $ && detach(r), v && v.d();
    },
  };
}
function instance$1D(k, r, p) {
  let { items: v = [] } = r;
  return (
    (k.$$set = ($) => {
      "items" in $ && p(0, (v = $.items));
    }),
    [v]
  );
}
class Branch extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1D, create_fragment$1K, safe_not_equal, {
        items: 0,
      });
  }
}
function create_if_block$I(k) {
  let r,
    p,
    v,
    $,
    S,
    x = k[0].sender + "",
    I,
    F,
    O,
    L = k[0].partialBody + "",
    U,
    j = k[0].partialBody.length > 29 ? "..." : "",
    N,
    q,
    R,
    Q = k[0].id + "",
    H,
    G,
    V,
    K,
    Y,
    J;
  p = new ProfilePicture$1({ props: { src: k[1], height: 32 } });
  let Z = k[0].replies && create_if_block_1$b(k);
  return {
    c() {
      (r = element("button")),
        create_component(p.$$.fragment),
        (v = space()),
        ($ = element("div")),
        (S = element("p")),
        (I = text(x)),
        (F = space()),
        (O = element("p")),
        (U = text(L)),
        (N = text(j)),
        (q = space()),
        (R = element("div")),
        (H = text(Q)),
        (G = space()),
        Z && Z.c(),
        (V = empty()),
        attr(S, "class", "name"),
        attr(O, "class", "partial"),
        attr($, "class", "context"),
        attr(R, "class", "id"),
        attr(r, "class", "item");
    },
    m(X, ee) {
      insert(X, r, ee),
        mount_component(p, r, null),
        append(r, v),
        append(r, $),
        append($, S),
        append(S, I),
        append($, F),
        append($, O),
        append(O, U),
        append(O, N),
        append(r, q),
        append(r, R),
        append(R, H),
        insert(X, G, ee),
        Z && Z.m(X, ee),
        insert(X, V, ee),
        (K = !0),
        Y || ((J = listen(r, "click", k[2])), (Y = !0));
    },
    p(X, ee) {
      const te = {};
      ee & 2 && (te.src = X[1]),
        p.$set(te),
        (!K || ee & 1) && x !== (x = X[0].sender + "") && set_data(I, x),
        (!K || ee & 1) && L !== (L = X[0].partialBody + "") && set_data(U, L),
        (!K || ee & 1) &&
          j !== (j = X[0].partialBody.length > 29 ? "..." : "") &&
          set_data(N, j),
        (!K || ee & 1) && Q !== (Q = X[0].id + "") && set_data(H, Q),
        X[0].replies
          ? Z
            ? (Z.p(X, ee), ee & 1 && transition_in(Z, 1))
            : ((Z = create_if_block_1$b(X)),
              Z.c(),
              transition_in(Z, 1),
              Z.m(V.parentNode, V))
          : Z &&
            (group_outros(),
            transition_out(Z, 1, 1, () => {
              Z = null;
            }),
            check_outros());
    },
    i(X) {
      K || (transition_in(p.$$.fragment, X), transition_in(Z), (K = !0));
    },
    o(X) {
      transition_out(p.$$.fragment, X), transition_out(Z), (K = !1);
    },
    d(X) {
      X && detach(r),
        destroy_component(p),
        X && detach(G),
        Z && Z.d(X),
        X && detach(V),
        (Y = !1),
        J();
    },
  };
}
function create_if_block_1$b(k) {
  let r, p;
  return (
    (r = new Branch({ props: { items: k[0].replies } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.items = v[0].replies), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1J(k) {
  let r,
    p,
    v = k[0] && create_if_block$I(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, [S]) {
      $[0]
        ? v
          ? (v.p($, S), S & 1 && transition_in(v, 1))
          : ((v = create_if_block$I($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function instance$1C(k, r, p) {
  let v;
  component_subscribe(k, selectedMessageId, (I) => p(3, (v = I)));
  let { item: $ } = r,
    S = "";
  onMount(async () => {
    p(1, (S = await getUserPfp($.sender)));
  });
  function x() {
    set_store_value(selectedMessageId, (v = $.id), v),
      hideOverlay("thread", "MessagingApp"),
      threadMessageId.set(null);
  }
  return (
    (k.$$set = (I) => {
      "item" in I && p(0, ($ = I.item));
    }),
    [$, S, x]
  );
}
let Item$2 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1C, create_fragment$1J, safe_not_equal, {
        item: 0,
      });
  }
};
function create_fragment$1I(k) {
  let r, p, v, $, S, x, I, F;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (x = element("h3")),
        (x.textContent = "Unable to load thread"),
        (I = space()),
        (F = element("p")),
        (F.textContent = `The thread could not be found. Please make sure the owner exists and try
      again.`),
        src_url_equal(v.src, ($ = warning)) || attr(v, "src", $),
        attr(v, "alt", "Error"),
        attr(F, "class", "caption"),
        attr(p, "class", "content"),
        attr(r, "class", "notfound");
    },
    m(O, L) {
      insert(O, r, L),
        append(r, p),
        append(p, v),
        append(p, S),
        append(p, x),
        append(p, I),
        append(p, F);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(O) {
      O && detach(r);
    },
  };
}
class NotFound extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$1I, safe_not_equal, {});
  }
}
function create_else_block$c(k) {
  let r, p;
  return (
    (r = new NotFound({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$H(k) {
  let r,
    p,
    v = k[2].id + "",
    $,
    S,
    x,
    I;
  return (
    (x = new Item$2({ props: { item: k[2] } })),
    {
      c() {
        (r = element("h3")),
          (p = text("Thread of #")),
          ($ = text(v)),
          (S = space()),
          create_component(x.$$.fragment),
          attr(r, "class", "header");
      },
      m(F, O) {
        insert(F, r, O),
          append(r, p),
          append(r, $),
          insert(F, S, O),
          mount_component(x, F, O),
          (I = !0);
      },
      p(F, O) {
        (!I || O & 4) && v !== (v = F[2].id + "") && set_data($, v);
        const L = {};
        O & 4 && (L.item = F[2]), x.$set(L);
      },
      i(F) {
        I || (transition_in(x.$$.fragment, F), (I = !0));
      },
      o(F) {
        transition_out(x.$$.fragment, F), (I = !1);
      },
      d(F) {
        F && detach(r), F && detach(S), destroy_component(x, F);
      },
    }
  );
}
function create_fragment$1H(k) {
  let r, p, v, $, S, x;
  r = new CloseButton({ props: { app: k[0], id: k[1] } });
  const I = [create_if_block$H, create_else_block$c],
    F = [];
  function O(L, U) {
    return L[3] && L[2] ? 0 : 1;
  }
  return (
    (v = O(k)),
    ($ = F[v] = I[v](k)),
    {
      c() {
        create_component(r.$$.fragment), (p = space()), $.c(), (S = empty());
      },
      m(L, U) {
        mount_component(r, L, U),
          insert(L, p, U),
          F[v].m(L, U),
          insert(L, S, U),
          (x = !0);
      },
      p(L, [U]) {
        const j = {};
        U & 1 && (j.app = L[0]), U & 2 && (j.id = L[1]), r.$set(j);
        let N = v;
        (v = O(L)),
          v === N
            ? F[v].p(L, U)
            : (group_outros(),
              transition_out(F[N], 1, 1, () => {
                F[N] = null;
              }),
              check_outros(),
              ($ = F[v]),
              $ ? $.p(L, U) : (($ = F[v] = I[v](L)), $.c()),
              transition_in($, 1),
              $.m(S.parentNode, S));
      },
      i(L) {
        x || (transition_in(r.$$.fragment, L), transition_in($), (x = !0));
      },
      o(L) {
        transition_out(r.$$.fragment, L), transition_out($), (x = !1);
      },
      d(L) {
        destroy_component(r, L), L && detach(p), F[v].d(L), L && detach(S);
      },
    }
  );
}
function instance$1B(k, r, p) {
  let v;
  component_subscribe(k, threadMessageId, (I) => p(3, (v = I)));
  let $,
    { app: S } = r,
    { id: x } = r;
  return (
    threadMessageId.subscribe(async (I) => {
      if (!I) return;
      p(2, ($ = null));
      const F = await getPartialTree(v);
      F && p(2, ($ = F));
    }),
    (k.$$set = (I) => {
      "app" in I && p(0, (S = I.app)), "id" in I && p(1, (x = I.id));
    }),
    [S, x, $, v]
  );
}
class Thread extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1B, create_fragment$1H, safe_not_equal, {
        app: 0,
        id: 1,
      });
  }
}
const overlays = {
    thread: {
      info: { name: "Thread View", author: "ArcOS Team", version: "1.0.0" },
      size: { w: 550, h: 400 },
      show: !1,
      content: Thread,
    },
  },
  MessagingApp = {
    info: {
      name: "Messaging",
      description: "Send messages to other ArcOS users",
      builtin: !0,
      version: "1.0.7",
      author: "ArcOS Team",
      icon: logo$2,
    },
    size: { w: 700, h: 450 },
    pos: { x: 100, y: 100 },
    minSize: { w: 700, h: 450 },
    maxSize: { w: 1e3, h: 600 },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    overlays,
    content: MessagingApp$1,
    glass: !0,
  },
  logo$1 = "./assets/settings-ade5abd9.svg",
  SettingsApp$2 = "";
function create_if_block$G(k) {
  let r, p, v;
  var $ = k[2].content;
  function S(x) {
    return {};
  }
  return (
    $ && (r = construct_svelte_component($, S())),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(x, I) {
        r && mount_component(r, x, I), insert(x, p, I), (v = !0);
      },
      p(x, I) {
        if (I & 4 && $ !== ($ = x[2].content)) {
          if (r) {
            group_outros();
            const F = r;
            transition_out(F.$$.fragment, 1, 0, () => {
              destroy_component(F, 1);
            }),
              check_outros();
          }
          $
            ? ((r = construct_svelte_component($, S())),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        }
      },
      i(x) {
        v || (r && transition_in(r.$$.fragment, x), (v = !0));
      },
      o(x) {
        r && transition_out(r.$$.fragment, x), (v = !1);
      },
      d(x) {
        x && detach(p), r && destroy_component(r, x);
      },
    }
  );
}
function create_fragment$1G(k) {
  let r,
    p,
    v,
    $,
    S = k[2] && create_if_block$G(k);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        S && S.c(),
        attr(p, "class", (v = "inner " + k[1])),
        attr(r, "class", "content"),
        toggle_class(r, "collapsed", k[0].collapsed);
    },
    m(x, I) {
      insert(x, r, I), append(r, p), S && S.m(p, null), ($ = !0);
    },
    p(x, [I]) {
      x[2]
        ? S
          ? (S.p(x, I), I & 4 && transition_in(S, 1))
          : ((S = create_if_block$G(x)),
            S.c(),
            transition_in(S, 1),
            S.m(p, null))
        : S &&
          (group_outros(),
          transition_out(S, 1, 1, () => {
            S = null;
          }),
          check_outros()),
        (!$ || (I & 2 && v !== (v = "inner " + x[1]))) && attr(p, "class", v),
        (!$ || I & 1) && toggle_class(r, "collapsed", x[0].collapsed);
    },
    i(x) {
      $ || (transition_in(S), ($ = !0));
    },
    o(x) {
      transition_out(S), ($ = !1);
    },
    d(x) {
      x && detach(r), S && S.d();
    },
  };
}
function instance$1A(k, r, p) {
  let v;
  component_subscribe(k, UserData, (F) => p(4, (v = F)));
  let { appdata: $ } = r,
    S = "",
    x,
    I;
  return (
    currentSettingsPage.subscribe((F) => {
      if ((clearTimeout(I), p(1, (S = "static")), v && !v.sh.anim && F))
        return p(2, (x = F));
      !F ||
        (x && F.name == x.name) ||
        (p(1, (S = "slide-out-right")),
        (I = setTimeout(() => {
          p(2, (x = F)),
            p(1, (S = "slide-in-left")),
            (I = setTimeout(() => {
              p(1, (S = "static"));
            }, 301));
        }, 500)));
    }),
    (k.$$set = (F) => {
      "appdata" in F && p(0, ($ = F.appdata));
    }),
    [$, S, x]
  );
}
let Content$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1A, create_fragment$1G, safe_not_equal, {
        appdata: 0,
      });
  }
};
function create_if_block$F(k) {
  let r;
  return {
    c() {
      r = element("hr");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$1F(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I = k[0].name + "",
    F,
    O,
    L,
    U,
    j,
    N,
    q = k[0].sep && create_if_block$F();
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (S = space()),
        (x = element("span")),
        (F = text(I)),
        (L = space()),
        q && q.c(),
        (U = empty()),
        src_url_equal(p.src, (v = k[0].icon)) || attr(p, "src", v),
        attr(p, "alt", ($ = k[0].name)),
        attr(p, "class", "icon"),
        attr(x, "class", "caption"),
        attr(r, "class", "page"),
        (r.disabled = O = k[0].disabled),
        toggle_class(r, "selected", k[1] && k[0].name == k[1].name);
    },
    m(R, Q) {
      insert(R, r, Q),
        append(r, p),
        append(r, S),
        append(r, x),
        append(x, F),
        insert(R, L, Q),
        q && q.m(R, Q),
        insert(R, U, Q),
        j || ((N = listen(r, "click", k[2])), (j = !0));
    },
    p(R, [Q]) {
      Q & 1 && !src_url_equal(p.src, (v = R[0].icon)) && attr(p, "src", v),
        Q & 1 && $ !== ($ = R[0].name) && attr(p, "alt", $),
        Q & 1 && I !== (I = R[0].name + "") && set_data(F, I),
        Q & 1 && O !== (O = R[0].disabled) && (r.disabled = O),
        Q & 3 && toggle_class(r, "selected", R[1] && R[0].name == R[1].name),
        R[0].sep
          ? q || ((q = create_if_block$F()), q.c(), q.m(U.parentNode, U))
          : q && (q.d(1), (q = null));
    },
    i: noop$1,
    o: noop$1,
    d(R) {
      R && detach(r),
        R && detach(L),
        q && q.d(R),
        R && detach(U),
        (j = !1),
        N();
    },
  };
}
function instance$1z(k, r, p) {
  let v;
  component_subscribe(k, currentSettingsPage, (x) => p(1, (v = x)));
  let { page: $ } = r;
  const S = () => setSettingsPage($);
  return (
    (k.$$set = (x) => {
      "page" in x && p(0, ($ = x.page));
    }),
    [$, v, S]
  );
}
class Page extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1z, create_fragment$1F, safe_not_equal, {
        page: 0,
      });
  }
}
function create_if_block$E(k) {
  let r;
  return {
    c() {
      (r = element("span")),
        (r.textContent = "bug_report"),
        attr(r, "class", "material-icons-round developer");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$1E(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N;
  v = new ProfilePicture$1({ props: { src: k[0], height: 36 } });
  let q = k[2] && create_if_block$E();
  return {
    c() {
      (r = element("div")),
        (p = element("span")),
        create_component(v.$$.fragment),
        ($ = space()),
        (S = element("div")),
        (x = element("p")),
        (I = text(k[1])),
        (F = space()),
        q && q.c(),
        (O = space()),
        (L = element("p")),
        (L.textContent = `${
          localStorage.getItem("arcos-server") || location.hostname
        }`),
        attr(x, "class", "name"),
        attr(L, "class", "hostname"),
        attr(S, "class", "username"),
        attr(r, "class", "userprofile");
    },
    m(R, Q) {
      insert(R, r, Q),
        append(r, p),
        mount_component(v, p, null),
        append(r, $),
        append(r, S),
        append(S, x),
        append(x, I),
        append(x, F),
        q && q.m(x, null),
        append(S, O),
        append(S, L),
        (U = !0),
        j || ((N = listen(p, "click", k[3])), (j = !0));
    },
    p(R, [Q]) {
      const H = {};
      Q & 1 && (H.src = R[0]),
        v.$set(H),
        (!U || Q & 2) && set_data(I, R[1]),
        R[2]
          ? q || ((q = create_if_block$E()), q.c(), q.m(x, null))
          : q && (q.d(1), (q = null));
    },
    i(R) {
      U || (transition_in(v.$$.fragment, R), (U = !0));
    },
    o(R) {
      transition_out(v.$$.fragment, R), (U = !1);
    },
    d(R) {
      R && detach(r), destroy_component(v), q && q.d(), (j = !1), N();
    },
  };
}
function instance$1y(k, r, p) {
  let v, $, S;
  component_subscribe(k, UserData, (F) => p(4, (v = F))),
    component_subscribe(k, UserName, (F) => p(1, ($ = F))),
    component_subscribe(k, DevModeOverride, (F) => p(2, (S = F)));
  let x = "";
  UserData.subscribe(() => {
    p(0, (x = getProfilePicture(v.acc.profilePicture)));
  });
  function I() {
    typeof v.acc.profilePicture == "string" &&
      showOverlay("largePfp", "SettingsApp");
  }
  return [x, $, S, I];
}
class UserProfile extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1y, create_fragment$1E, safe_not_equal, {});
  }
}
function get_each_context$p(k, r, p) {
  const v = k.slice();
  return (v[4] = r[p]), v;
}
function create_if_block$D(k) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.innerHTML = '<span class="material-icons-round">menu</span>'),
        attr(r, "class", "page menu"),
        toggle_class(r, "active", k[0].collapsed);
    },
    m($, S) {
      insert($, r, S), p || ((v = listen(r, "click", k[1])), (p = !0));
    },
    p($, S) {
      S & 1 && toggle_class(r, "active", $[0].collapsed);
    },
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_each_block$p(k) {
  let r, p;
  return (
    (r = new Page({ props: { page: k[4] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1D(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I = k[0] && create_if_block$D(k),
    F = SettingsPages,
    O = [];
  for (let U = 0; U < F.length; U += 1)
    O[U] = create_each_block$p(get_each_context$p(k, F, U));
  const L = (U) =>
    transition_out(O[U], 1, 1, () => {
      O[U] = null;
    });
  return (
    (S = new UserProfile({})),
    {
      c() {
        (r = element("div")), (p = element("div")), I && I.c(), (v = space());
        for (let U = 0; U < O.length; U += 1) O[U].c();
        ($ = space()),
          create_component(S.$$.fragment),
          attr(p, "class", "pages"),
          attr(r, "class", "sidebar"),
          toggle_class(r, "collapsed", k[0].collapsed);
      },
      m(U, j) {
        insert(U, r, j), append(r, p), I && I.m(p, null), append(p, v);
        for (let N = 0; N < O.length; N += 1) O[N] && O[N].m(p, null);
        append(r, $), mount_component(S, r, null), (x = !0);
      },
      p(U, [j]) {
        if (
          (U[0]
            ? I
              ? I.p(U, j)
              : ((I = create_if_block$D(U)), I.c(), I.m(p, v))
            : I && (I.d(1), (I = null)),
          j & 0)
        ) {
          F = SettingsPages;
          let N;
          for (N = 0; N < F.length; N += 1) {
            const q = get_each_context$p(U, F, N);
            O[N]
              ? (O[N].p(q, j), transition_in(O[N], 1))
              : ((O[N] = create_each_block$p(q)),
                O[N].c(),
                transition_in(O[N], 1),
                O[N].m(p, null));
          }
          for (group_outros(), N = F.length; N < O.length; N += 1) L(N);
          check_outros();
        }
        (!x || j & 1) && toggle_class(r, "collapsed", U[0].collapsed);
      },
      i(U) {
        if (!x) {
          for (let j = 0; j < F.length; j += 1) transition_in(O[j]);
          transition_in(S.$$.fragment, U), (x = !0);
        }
      },
      o(U) {
        O = O.filter(Boolean);
        for (let j = 0; j < O.length; j += 1) transition_out(O[j]);
        transition_out(S.$$.fragment, U), (x = !1);
      },
      d(U) {
        U && detach(r), I && I.d(), destroy_each(O, U), destroy_component(S);
      },
    }
  );
}
function instance$1x(k, r, p) {
  let v;
  component_subscribe(k, UserData, (I) => p(3, (v = I)));
  let { appdata: $ } = r,
    { app: S } = r;
  function x() {
    p(0, ($.collapsed = !$.collapsed), $),
      set_store_value(UserData, (v.appdata[S.id] = $), v);
  }
  return (
    (k.$$set = (I) => {
      "appdata" in I && p(0, ($ = I.appdata)), "app" in I && p(2, (S = I.app));
    }),
    [$, x, S]
  );
}
class Sidebar extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1x, create_fragment$1D, safe_not_equal, {
        appdata: 0,
        app: 2,
      });
  }
}
function create_fragment$1C(k) {
  let r, p, v, $, S;
  function x(F) {
    k[2](F);
  }
  let I = { app: k[1] };
  return (
    k[0] !== void 0 && (I.appdata = k[0]),
    (r = new Sidebar({ props: I })),
    binding_callbacks.push(() => bind$1(r, "appdata", x)),
    ($ = new Content$1({ props: { appdata: k[0] } })),
    {
      c() {
        create_component(r.$$.fragment),
          (v = space()),
          create_component($.$$.fragment);
      },
      m(F, O) {
        mount_component(r, F, O),
          insert(F, v, O),
          mount_component($, F, O),
          (S = !0);
      },
      p(F, [O]) {
        const L = {};
        O & 2 && (L.app = F[1]),
          !p &&
            O & 1 &&
            ((p = !0), (L.appdata = F[0]), add_flush_callback(() => (p = !1))),
          r.$set(L);
        const U = {};
        O & 1 && (U.appdata = F[0]), $.$set(U);
      },
      i(F) {
        S ||
          (transition_in(r.$$.fragment, F),
          transition_in($.$$.fragment, F),
          (S = !0));
      },
      o(F) {
        transition_out(r.$$.fragment, F),
          transition_out($.$$.fragment, F),
          (S = !1);
      },
      d(F) {
        destroy_component(r, F), F && detach(v), destroy_component($, F);
      },
    }
  );
}
function instance$1w(k, r, p) {
  let { appdata: v } = r,
    { app: $ } = r;
  function S(x) {
    (v = x), p(0, v);
  }
  return (
    (k.$$set = (x) => {
      "appdata" in x && p(0, (v = x.appdata)), "app" in x && p(1, ($ = x.app));
    }),
    [v, $, S]
  );
}
let SettingsApp$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1w, create_fragment$1C, safe_not_equal, {
        appdata: 0,
        app: 1,
      });
  }
};
const ProfilePicture_svelte_svelte_type_style_lang = "";
function get_each_context$o(k, r, p) {
  const v = k.slice();
  return (v[8] = r[p]), (v[10] = p), v;
}
function create_each_block$o(k) {
  let r, p, v, $, S, x;
  function I() {
    return k[7](k[10]);
  }
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        ($ = space()),
        src_url_equal(p.src, (v = k[8])) || attr(p, "src", v),
        attr(p, "alt", `${k[10] + 1}`),
        attr(p, "class", "svelte-2jlx4b"),
        attr(r, "class", "svelte-2jlx4b"),
        toggle_class(r, "selected", k[10] + 1 == k[1].acc.profilePicture);
    },
    m(F, O) {
      insert(F, r, O),
        append(r, p),
        append(r, $),
        S || ((x = listen(r, "click", I)), (S = !0));
    },
    p(F, O) {
      (k = F),
        O & 1 && !src_url_equal(p.src, (v = k[8])) && attr(p, "src", v),
        O & 2 &&
          toggle_class(r, "selected", k[10] + 1 == k[1].acc.profilePicture);
    },
    d(F) {
      F && detach(r), (S = !1), x();
    },
  };
}
function create_fragment$1B(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L,
    U = k[0],
    j = [];
  for (let N = 0; N < U.length; N += 1)
    j[N] = create_each_block$o(get_each_context$o(k, U, N));
  return {
    c() {
      (r = element("div")),
        (r.innerHTML = `<h2 class="header">Change Profile Picture</h2> 
  <p class="subheader">Choose one of the following profile pictures:</p>`),
        (p = space()),
        (v = element("div"));
      for (let N = 0; N < j.length; N += 1) j[N].c();
      ($ = space()),
        (S = element("div")),
        (x = element("button")),
        (x.textContent = "Custom..."),
        (I = space()),
        (F = element("button")),
        (F.textContent = "Cancel"),
        attr(r, "class", "overlay-head"),
        attr(v, "class", "wrapper svelte-2jlx4b"),
        attr(F, "class", "cancel svelte-2jlx4b"),
        attr(S, "class", "cancel-wrapper svelte-2jlx4b");
    },
    m(N, q) {
      insert(N, r, q), insert(N, p, q), insert(N, v, q);
      for (let R = 0; R < j.length; R += 1) j[R] && j[R].m(v, null);
      insert(N, $, q),
        insert(N, S, q),
        append(S, x),
        append(S, I),
        append(S, F),
        O ||
          ((L = [listen(x, "click", k[4]), listen(F, "click", k[3])]),
          (O = !0));
    },
    p(N, [q]) {
      if (q & 7) {
        U = N[0];
        let R;
        for (R = 0; R < U.length; R += 1) {
          const Q = get_each_context$o(N, U, R);
          j[R]
            ? j[R].p(Q, q)
            : ((j[R] = create_each_block$o(Q)), j[R].c(), j[R].m(v, null));
        }
        for (; R < j.length; R += 1) j[R].d(1);
        j.length = U.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(N) {
      N && detach(r),
        N && detach(p),
        N && detach(v),
        destroy_each(j, N),
        N && detach($),
        N && detach(S),
        (O = !1),
        run_all(L);
    },
  };
}
function instance$1v(k, r, p) {
  let v;
  component_subscribe(k, UserData, (U) => p(1, (v = U)));
  let $ = [],
    { id: S } = r,
    { app: x } = r;
  onMount(() => {
    p(0, ($ = Object.values(ProfilePictures)));
  });
  function I(U) {
    set_store_value(UserData, (v.acc.profilePicture = U), v), F();
  }
  function F() {
    hideOverlay(S, x.id);
  }
  function O() {
    showOverlay("customPfp", "SettingsApp");
  }
  const L = (U) => I(U + 1);
  return (
    (k.$$set = (U) => {
      "id" in U && p(5, (S = U.id)), "app" in U && p(6, (x = U.app));
    }),
    [$, v, I, F, O, S, x, L]
  );
}
class ProfilePicture extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1v, create_fragment$1B, safe_not_equal, {
        id: 5,
        app: 6,
      });
  }
}
const customPfp = "";
function create_fragment$1A(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H, G, V;
  return (
    (v = new ProfilePicture$1({
      props: { src: k[1] ? k[0] : pfp, height: 50 },
    })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          create_component(v.$$.fragment),
          ($ = space()),
          (S = element("div")),
          (x = element("p")),
          (x.textContent = "Enter the URL to a custom profile picture:"),
          (I = space()),
          (F = element("input")),
          (O = space()),
          (L = element("div")),
          (U = element("div")),
          (j = element("button")),
          (j.textContent = "Cancel"),
          (N = space()),
          (q = element("button")),
          (R = text("Apply")),
          attr(F, "type", "url"),
          attr(F, "placeholder", "https://example.com/image.png"),
          (q.disabled = Q = !k[0] || !k[1]),
          attr(L, "class", "apply"),
          attr(S, "class", "field"),
          attr(r, "class", "custompfp-wrapper");
      },
      m(K, Y) {
        insert(K, r, Y),
          append(r, p),
          mount_component(v, p, null),
          append(r, $),
          append(r, S),
          append(S, x),
          append(S, I),
          append(S, F),
          set_input_value(F, k[0]),
          append(S, O),
          append(S, L),
          append(L, U),
          append(U, j),
          append(U, N),
          append(U, q),
          append(q, R),
          (H = !0),
          G ||
            ((V = [
              listen(F, "input", k[5]),
              listen(F, "input", k[2]),
              listen(j, "click", k[4]),
              listen(q, "click", k[3]),
            ]),
            (G = !0));
      },
      p(K, [Y]) {
        const J = {};
        Y & 3 && (J.src = K[1] ? K[0] : pfp),
          v.$set(J),
          Y & 1 && F.value !== K[0] && set_input_value(F, K[0]),
          (!H || (Y & 3 && Q !== (Q = !K[0] || !K[1]))) && (q.disabled = Q);
      },
      i(K) {
        H || (transition_in(v.$$.fragment, K), (H = !0));
      },
      o(K) {
        transition_out(v.$$.fragment, K), (H = !1);
      },
      d(K) {
        K && detach(r), destroy_component(v), (G = !1), run_all(V);
      },
    }
  );
}
async function checkImage$1(k) {
  const r = new Image();
  return (
    (r.src = k),
    new Promise((p) => {
      (r.onload = () => p(!0)), (r.onerror = () => p(!1));
    })
  );
}
function instance$1u(k, r, p) {
  let v = "",
    $ = !1;
  async function S() {
    const O = await checkImage$1(v);
    p(1, ($ = O));
  }
  function x() {
    applyCustomPfp(v),
      hideOverlay("customPfp", "SettingsApp"),
      hideOverlay("pfpSel", "SettingsApp");
  }
  function I() {
    hideOverlay("customPfp", "SettingsApp");
  }
  UserData.subscribe((O) => {
    typeof O.acc.profilePicture == "string" && p(0, (v = O.acc.profilePicture)),
      S();
  });
  function F() {
    (v = this.value), p(0, v);
  }
  return [v, $, S, x, I, F];
}
class CustomProfilePicture extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1u, create_fragment$1A, safe_not_equal, {});
  }
}
const ProfilePictureView_svelte_svelte_type_style_lang = "";
function create_fragment$1z(k) {
  let r, p, v, $, S, x, I, F, O, L, U;
  return (
    (r = new CloseButton({ props: { id: k[0], app: k[1] } })),
    (S = new ProfilePicture$1({
      props: { src: k[2].acc.profilePicture.toString(), height: 150 },
    })),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          (v = element("div")),
          ($ = element("div")),
          create_component(S.$$.fragment),
          (x = space()),
          (I = element("h1")),
          (F = text(k[3])),
          (O = space()),
          (L = element("p")),
          (L.textContent = `${
            localStorage.getItem("arcos-server") || location.hostname
          }`),
          attr(I, "class", "svelte-1hdmb0y"),
          attr(L, "class", "hostname svelte-1hdmb0y"),
          attr($, "class", "flex-stop"),
          attr(v, "class", "center-flex text-center");
      },
      m(j, N) {
        mount_component(r, j, N),
          insert(j, p, N),
          insert(j, v, N),
          append(v, $),
          mount_component(S, $, null),
          append($, x),
          append($, I),
          append(I, F),
          append($, O),
          append($, L),
          (U = !0);
      },
      p(j, [N]) {
        const q = {};
        N & 1 && (q.id = j[0]), N & 2 && (q.app = j[1]), r.$set(q);
        const R = {};
        N & 4 && (R.src = j[2].acc.profilePicture.toString()),
          S.$set(R),
          (!U || N & 8) && set_data(F, j[3]);
      },
      i(j) {
        U ||
          (transition_in(r.$$.fragment, j),
          transition_in(S.$$.fragment, j),
          (U = !0));
      },
      o(j) {
        transition_out(r.$$.fragment, j),
          transition_out(S.$$.fragment, j),
          (U = !1);
      },
      d(j) {
        destroy_component(r, j),
          j && detach(p),
          j && detach(v),
          destroy_component(S);
      },
    }
  );
}
function instance$1t(k, r, p) {
  let v, $;
  component_subscribe(k, UserData, (I) => p(2, (v = I))),
    component_subscribe(k, UserName, (I) => p(3, ($ = I)));
  let { id: S } = r,
    { app: x } = r;
  return (
    (k.$$set = (I) => {
      "id" in I && p(0, (S = I.id)), "app" in I && p(1, (x = I.app));
    }),
    [S, x, v, $]
  );
}
class ProfilePictureView extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1t, create_fragment$1z, safe_not_equal, {
        id: 0,
        app: 1,
      });
  }
}
const udataExplorer = "";
function create_if_block$C(k) {
  let r, p, v;
  return {
    c() {
      (r = element("div")),
        (p = text(k[1])),
        attr(r, "class", "value"),
        attr(r, "data-type", (v = typeof k[1])),
        attr(r, "data-value", k[1]);
    },
    m($, S) {
      insert($, r, S), append(r, p);
    },
    p($, S) {
      S & 2 && set_data(p, $[1]),
        S & 2 && v !== (v = typeof $[1]) && attr(r, "data-type", v),
        S & 2 && attr(r, "data-value", $[1]);
    },
    d($) {
      $ && detach(r);
    },
  };
}
function create_fragment$1y(k) {
  let r,
    p,
    v,
    $,
    S = typeof k[1] != "object" && create_if_block$C(k);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = text(k[0])),
        ($ = space()),
        S && S.c(),
        attr(p, "class", "key"),
        attr(r, "class", "nodeinstance");
    },
    m(x, I) {
      insert(x, r, I),
        append(r, p),
        append(p, v),
        append(r, $),
        S && S.m(r, null);
    },
    p(x, [I]) {
      I & 1 && set_data(v, x[0]),
        typeof x[1] != "object"
          ? S
            ? S.p(x, I)
            : ((S = create_if_block$C(x)), S.c(), S.m(r, null))
          : S && (S.d(1), (S = null));
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r), S && S.d();
    },
  };
}
function instance$1s(k, r, p) {
  let { key: v } = r,
    { value: $ } = r;
  return (
    (k.$$set = (S) => {
      "key" in S && p(0, (v = S.key)), "value" in S && p(1, ($ = S.value));
    }),
    [v, $]
  );
}
class Node extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1s, create_fragment$1y, safe_not_equal, {
        key: 0,
        value: 1,
      });
  }
}
function get_each_context$n(k, r, p) {
  const v = k.slice();
  return (v[3] = r[p]), v;
}
function create_if_block$B(k) {
  let r,
    p,
    v = Object.entries(k[1]),
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$n(get_each_context$n(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = empty();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 2) {
        v = Object.entries(x[1]);
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$n(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$n(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_each_block$n(k) {
  let r, p;
  return (
    (r = new Branch_1({ props: { key: k[3][0], value: k[3][1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 2 && (S.key = v[3][0]), $ & 2 && (S.value = v[3][1]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1x(k) {
  let r, p, v, $;
  p = new Node({ props: { key: k[0], value: k[1] } });
  let S = typeof k[1] == "object" && create_if_block$B(k);
  return {
    c() {
      (r = element("div")),
        create_component(p.$$.fragment),
        (v = space()),
        S && S.c(),
        toggle_class(r, "indent", !k[2]);
    },
    m(x, I) {
      insert(x, r, I),
        mount_component(p, r, null),
        append(r, v),
        S && S.m(r, null),
        ($ = !0);
    },
    p(x, [I]) {
      const F = {};
      I & 1 && (F.key = x[0]),
        I & 2 && (F.value = x[1]),
        p.$set(F),
        typeof x[1] == "object"
          ? S
            ? (S.p(x, I), I & 2 && transition_in(S, 1))
            : ((S = create_if_block$B(x)),
              S.c(),
              transition_in(S, 1),
              S.m(r, null))
          : S &&
            (group_outros(),
            transition_out(S, 1, 1, () => {
              S = null;
            }),
            check_outros()),
        (!$ || I & 4) && toggle_class(r, "indent", !x[2]);
    },
    i(x) {
      $ || (transition_in(p.$$.fragment, x), transition_in(S), ($ = !0));
    },
    o(x) {
      transition_out(p.$$.fragment, x), transition_out(S), ($ = !1);
    },
    d(x) {
      x && detach(r), destroy_component(p), S && S.d();
    },
  };
}
function instance$1r(k, r, p) {
  let { key: v } = r,
    { value: $ } = r,
    { top: S = !1 } = r;
  return (
    (k.$$set = (x) => {
      "key" in x && p(0, (v = x.key)),
        "value" in x && p(1, ($ = x.value)),
        "top" in x && p(2, (S = x.top));
    }),
    [v, $, S]
  );
}
class Branch_1 extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1r, create_fragment$1x, safe_not_equal, {
        key: 0,
        value: 1,
        top: 2,
      });
  }
}
function get_each_context$m(k, r, p) {
  const v = k.slice();
  return (v[4] = r[p]), v;
}
function create_if_block$A(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L = Object.entries(k[2]),
    U = [];
  for (let N = 0; N < L.length; N += 1)
    U[N] = create_each_block$m(get_each_context$m(k, L, N));
  const j = (N) =>
    transition_out(U[N], 1, 1, () => {
      U[N] = null;
    });
  return {
    c() {
      (r = element("div")),
        (p = element("h2")),
        (v = text("User Data for ")),
        ($ = text(k[3])),
        (S = space()),
        (x = element("p")),
        (x.textContent = "Below is a tree view of your user data:"),
        (I = space());
      for (let N = 0; N < U.length; N += 1) U[N].c();
      (F = empty()),
        attr(p, "class", "header"),
        attr(x, "class", "subheader"),
        attr(r, "class", "overlay-head");
    },
    m(N, q) {
      insert(N, r, q),
        append(r, p),
        append(p, v),
        append(p, $),
        append(r, S),
        append(r, x),
        insert(N, I, q);
      for (let R = 0; R < U.length; R += 1) U[R] && U[R].m(N, q);
      insert(N, F, q), (O = !0);
    },
    p(N, q) {
      if (((!O || q & 8) && set_data($, N[3]), q & 4)) {
        L = Object.entries(N[2]);
        let R;
        for (R = 0; R < L.length; R += 1) {
          const Q = get_each_context$m(N, L, R);
          U[R]
            ? (U[R].p(Q, q), transition_in(U[R], 1))
            : ((U[R] = create_each_block$m(Q)),
              U[R].c(),
              transition_in(U[R], 1),
              U[R].m(F.parentNode, F));
        }
        for (group_outros(), R = L.length; R < U.length; R += 1) j(R);
        check_outros();
      }
    },
    i(N) {
      if (!O) {
        for (let q = 0; q < L.length; q += 1) transition_in(U[q]);
        O = !0;
      }
    },
    o(N) {
      U = U.filter(Boolean);
      for (let q = 0; q < U.length; q += 1) transition_out(U[q]);
      O = !1;
    },
    d(N) {
      N && detach(r), N && detach(I), destroy_each(U, N), N && detach(F);
    },
  };
}
function create_else_block$b(k) {
  let r, p;
  return (
    (r = new Node({ props: { key: k[4][0], value: k[4][1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 4 && (S.key = v[4][0]), $ & 4 && (S.value = v[4][1]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_1$a(k) {
  let r, p;
  return (
    (r = new Branch_1({ props: { key: k[4][0], value: k[4][1], top: !0 } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 4 && (S.key = v[4][0]), $ & 4 && (S.value = v[4][1]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$m(k) {
  let r, p, v, $, S;
  const x = [create_if_block_1$a, create_else_block$b],
    I = [];
  function F(O, L) {
    return typeof O[4][1] == "object" ? 0 : 1;
  }
  return (
    (p = F(k)),
    (v = I[p] = x[p](k)),
    {
      c() {
        (r = element("div")),
          v.c(),
          ($ = space()),
          attr(r, "class", "toplevel-item");
      },
      m(O, L) {
        insert(O, r, L), I[p].m(r, null), append(r, $), (S = !0);
      },
      p(O, L) {
        let U = p;
        (p = F(O)),
          p === U
            ? I[p].p(O, L)
            : (group_outros(),
              transition_out(I[U], 1, 1, () => {
                I[U] = null;
              }),
              check_outros(),
              (v = I[p]),
              v ? v.p(O, L) : ((v = I[p] = x[p](O)), v.c()),
              transition_in(v, 1),
              v.m(r, $));
      },
      i(O) {
        S || (transition_in(v), (S = !0));
      },
      o(O) {
        transition_out(v), (S = !1);
      },
      d(O) {
        O && detach(r), I[p].d();
      },
    }
  );
}
function create_fragment$1w(k) {
  let r, p, v, $;
  r = new CloseButton({ props: { app: k[0], id: k[1] } });
  let S = k[2] && create_if_block$A(k);
  return {
    c() {
      create_component(r.$$.fragment), (p = space()), S && S.c(), (v = empty());
    },
    m(x, I) {
      mount_component(r, x, I),
        insert(x, p, I),
        S && S.m(x, I),
        insert(x, v, I),
        ($ = !0);
    },
    p(x, [I]) {
      const F = {};
      I & 1 && (F.app = x[0]),
        I & 2 && (F.id = x[1]),
        r.$set(F),
        x[2]
          ? S
            ? (S.p(x, I), I & 4 && transition_in(S, 1))
            : ((S = create_if_block$A(x)),
              S.c(),
              transition_in(S, 1),
              S.m(v.parentNode, v))
          : S &&
            (group_outros(),
            transition_out(S, 1, 1, () => {
              S = null;
            }),
            check_outros());
    },
    i(x) {
      $ || (transition_in(r.$$.fragment, x), transition_in(S), ($ = !0));
    },
    o(x) {
      transition_out(r.$$.fragment, x), transition_out(S), ($ = !1);
    },
    d(x) {
      destroy_component(r, x), x && detach(p), S && S.d(x), x && detach(v);
    },
  };
}
function instance$1q(k, r, p) {
  let v, $;
  component_subscribe(k, UserData, (I) => p(2, (v = I))),
    component_subscribe(k, UserName, (I) => p(3, ($ = I)));
  let { app: S } = r,
    { id: x } = r;
  return (
    (k.$$set = (I) => {
      "app" in I && p(0, (S = I.app)), "id" in I && p(1, (x = I.id));
    }),
    [S, x, v, $]
  );
}
class UserDataExplorer extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1q, create_fragment$1w, safe_not_equal, {
        app: 0,
        id: 1,
      });
  }
}
const passwordIcon = "./assets/password-d04179f1.svg",
  changePswd = "";
function create_fragment$1v(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H, G, V, K, Y, J, Z;
  return (
    (v = new ProfilePicture$1({ props: { src: k[0], height: 50 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          create_component(v.$$.fragment),
          ($ = space()),
          (S = element("div")),
          (x = element("p")),
          (x.textContent = "Fill out this form to change your password:"),
          (I = space()),
          (F = element("input")),
          (O = space()),
          (L = element("input")),
          (U = space()),
          (j = element("input")),
          (N = space()),
          (q = element("div")),
          (R = element("div")),
          (Q = element("button")),
          (Q.textContent = "Cancel"),
          (H = space()),
          (G = element("button")),
          (V = text("Change")),
          attr(F, "type", "password"),
          attr(F, "name", "current"),
          attr(F, "placeholder", "Current password"),
          attr(L, "type", "password"),
          attr(L, "name", "current"),
          attr(L, "placeholder", "New password"),
          attr(j, "type", "password"),
          attr(j, "name", "current"),
          attr(j, "placeholder", "Confirm new password"),
          (G.disabled = K = k[2] != k[3] || !k[2] || !k[3]),
          attr(q, "class", "apply"),
          attr(S, "class", "field"),
          attr(r, "class", "changepswd-wrapper");
      },
      m(X, ee) {
        insert(X, r, ee),
          append(r, p),
          mount_component(v, p, null),
          append(r, $),
          append(r, S),
          append(S, x),
          append(S, I),
          append(S, F),
          set_input_value(F, k[1]),
          append(S, O),
          append(S, L),
          set_input_value(L, k[2]),
          append(S, U),
          append(S, j),
          set_input_value(j, k[3]),
          append(S, N),
          append(S, q),
          append(q, R),
          append(R, Q),
          append(R, H),
          append(R, G),
          append(G, V),
          (Y = !0),
          J ||
            ((Z = [
              listen(F, "input", k[8]),
              listen(L, "input", k[9]),
              listen(j, "input", k[10]),
              listen(Q, "click", k[4]),
              listen(G, "click", k[5]),
            ]),
            (J = !0));
      },
      p(X, [ee]) {
        const te = {};
        ee & 1 && (te.src = X[0]),
          v.$set(te),
          ee & 2 && F.value !== X[1] && set_input_value(F, X[1]),
          ee & 4 && L.value !== X[2] && set_input_value(L, X[2]),
          ee & 8 && j.value !== X[3] && set_input_value(j, X[3]),
          (!Y || (ee & 12 && K !== (K = X[2] != X[3] || !X[2] || !X[3]))) &&
            (G.disabled = K);
      },
      i(X) {
        Y || (transition_in(v.$$.fragment, X), (Y = !0));
      },
      o(X) {
        transition_out(v.$$.fragment, X), (Y = !1);
      },
      d(X) {
        X && detach(r), destroy_component(v), (J = !1), run_all(Z);
      },
    }
  );
}
function instance$1p(k, r, p) {
  let v;
  component_subscribe(k, UserName, (H) => p(11, (v = H)));
  let $ = "",
    { id: S } = r,
    { app: x } = r,
    I = "",
    F = "",
    O = "";
  UserData.subscribe((H) => {
    p(0, ($ = getProfilePicture(H.acc.profilePicture)));
  });
  function L() {
    hideOverlay(S, x.id);
  }
  function U() {
    N(), L();
  }
  async function j() {
    if (!(await changePassword(v, I, F, O)))
      return createOverlayableError(
        {
          title: "Couldn't change password",
          message:
            "An error occured while changing your password. Please make sure the entered information is correct, and then try again.",
          buttons: [{ caption: "OK", action: N }],
          image: passwordIcon,
        },
        x.id
      );
    createOverlayableError(
      {
        title: "Password changed.",
        message: "Your password has been updated successfully.",
        buttons: [{ caption: "OK", action: U }],
        image: passwordIcon,
      },
      x.id
    );
  }
  function N() {
    p(1, (I = "")), p(2, (F = "")), p(3, (O = ""));
  }
  function q() {
    (I = this.value), p(1, I);
  }
  function R() {
    (F = this.value), p(2, F);
  }
  function Q() {
    (O = this.value), p(3, O);
  }
  return (
    (k.$$set = (H) => {
      "id" in H && p(6, (S = H.id)), "app" in H && p(7, (x = H.app));
    }),
    [$, I, F, O, L, j, S, x, q, R, Q]
  );
}
class ChangePassword extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1p, create_fragment$1v, safe_not_equal, {
        id: 6,
        app: 7,
      });
  }
}
const changeUname = "";
function create_fragment$1u(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H, G, V, K, Y, J;
  return (
    (v = new ProfilePicture$1({ props: { src: k[0], height: 50 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          create_component(v.$$.fragment),
          ($ = space()),
          (S = element("div")),
          (x = element("p")),
          (I = text(k[2])),
          (F = space()),
          (O = element("p")),
          (O.textContent = "Enter a new username"),
          (L = space()),
          (U = element("input")),
          (j = space()),
          (N = element("div")),
          (q = element("div")),
          (R = element("button")),
          (R.textContent = "Cancel"),
          (Q = space()),
          (H = element("button")),
          (G = text("Change")),
          attr(x, "class", "username"),
          attr(U, "type", "text"),
          attr(U, "name", "current"),
          attr(U, "placeholder", "New username"),
          (H.disabled = V = !k[1]),
          attr(N, "class", "apply"),
          attr(S, "class", "field"),
          attr(r, "class", "changename-wrapper");
      },
      m(Z, X) {
        insert(Z, r, X),
          append(r, p),
          mount_component(v, p, null),
          append(r, $),
          append(r, S),
          append(S, x),
          append(x, I),
          append(S, F),
          append(S, O),
          append(S, L),
          append(S, U),
          set_input_value(U, k[1]),
          append(S, j),
          append(S, N),
          append(N, q),
          append(q, R),
          append(q, Q),
          append(q, H),
          append(H, G),
          (K = !0),
          Y ||
            ((J = [
              listen(U, "input", k[7]),
              listen(R, "click", k[4]),
              listen(H, "click", k[3]),
            ]),
            (Y = !0));
      },
      p(Z, [X]) {
        const ee = {};
        X & 1 && (ee.src = Z[0]),
          v.$set(ee),
          (!K || X & 4) && set_data(I, Z[2]),
          X & 2 && U.value !== Z[1] && set_input_value(U, Z[1]),
          (!K || (X & 2 && V !== (V = !Z[1]))) && (H.disabled = V);
      },
      i(Z) {
        K || (transition_in(v.$$.fragment, Z), (K = !0));
      },
      o(Z) {
        transition_out(v.$$.fragment, Z), (K = !1);
      },
      d(Z) {
        Z && detach(r), destroy_component(v), (Y = !1), run_all(J);
      },
    }
  );
}
function instance$1o(k, r, p) {
  let v;
  component_subscribe(k, UserName, (N) => p(2, (v = N)));
  let $ = "",
    { id: S } = r,
    { app: x } = r,
    I = "";
  UserData.subscribe((N) => {
    p(0, ($ = getProfilePicture(N.acc.profilePicture)));
  });
  async function F() {
    if (!(await changeUsername(v, I)))
      return createOverlayableError(
        {
          title: "Can't rename user",
          message:
            "An error occured while trying to rename your account. Please make sure the information is correct, and then try again.",
          buttons: [{ caption: "OK", action: L }],
          image: accountIcon,
        },
        "SettingsApp"
      );
    createOverlayableError(
      {
        title: "Username changed.",
        message: "Your username has been updated successfully.",
        buttons: [{ caption: "OK", action: U }],
        image: accountIcon,
      },
      "SettingsApp"
    );
  }
  function O() {
    hideOverlay(S, x.id);
  }
  function L() {
    p(1, (I = ""));
  }
  function U() {
    L(), O();
  }
  function j() {
    (I = this.value), p(1, I);
  }
  return (
    (k.$$set = (N) => {
      "id" in N && p(5, (S = N.id)), "app" in N && p(6, (x = N.app));
    }),
    [$, I, v, F, O, S, x, j]
  );
}
class ChangeUsername extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1o, create_fragment$1u, safe_not_equal, {
        id: 5,
        app: 6,
      });
  }
}
const changetitlebuttons = "",
  Default_svelte_svelte_type_style_lang = "";
function create_fragment$1t(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N;
  return {
    c() {
      (r = element("button")),
        (p = text("minimize")),
        ($ = space()),
        (S = element("button")),
        (x = text("crop_square")),
        (F = space()),
        (O = element("button")),
        (L = text("close")),
        attr(r, "class", "material-icons-round reset svelte-63zn7"),
        (r.disabled = v = !k[0].controls.min || k[1]),
        attr(S, "class", "material-icons-round reset svelte-63zn7"),
        (S.disabled = I = !k[0].controls.max || k[1]),
        attr(O, "class", "material-icons-round reset svelte-63zn7"),
        (O.disabled = U = !k[0].controls.cls || k[1]);
    },
    m(q, R) {
      insert(q, r, R),
        append(r, p),
        insert(q, $, R),
        insert(q, S, R),
        append(S, x),
        insert(q, F, R),
        insert(q, O, R),
        append(O, L),
        j ||
          ((N = [
            listen(r, "click", function () {
              is_function(k[2]) && k[2].apply(this, arguments);
            }),
            listen(S, "click", function () {
              is_function(k[3]) && k[3].apply(this, arguments);
            }),
            listen(O, "click", function () {
              is_function(k[4]) && k[4].apply(this, arguments);
            }),
          ]),
          (j = !0));
    },
    p(q, [R]) {
      (k = q),
        R & 3 && v !== (v = !k[0].controls.min || k[1]) && (r.disabled = v),
        R & 3 && I !== (I = !k[0].controls.max || k[1]) && (S.disabled = I),
        R & 3 && U !== (U = !k[0].controls.cls || k[1]) && (O.disabled = U);
    },
    i: noop$1,
    o: noop$1,
    d(q) {
      q && detach(r),
        q && detach($),
        q && detach(S),
        q && detach(F),
        q && detach(O),
        (j = !1),
        run_all(N);
    },
  };
}
function instance$1n(k, r, p) {
  let { app: v } = r,
    { isBoot: $ } = r,
    { min: S } = r,
    { max: x } = r,
    { cls: I } = r;
  return (
    (k.$$set = (F) => {
      "app" in F && p(0, (v = F.app)),
        "isBoot" in F && p(1, ($ = F.isBoot)),
        "min" in F && p(2, (S = F.min)),
        "max" in F && p(3, (x = F.max)),
        "cls" in F && p(4, (I = F.cls));
    }),
    [v, $, S, x, I]
  );
}
class Default extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1n, create_fragment$1t, safe_not_equal, {
        app: 0,
        isBoot: 1,
        min: 2,
        max: 3,
        cls: 4,
      });
  }
}
const Traffic_svelte_svelte_type_style_lang = "";
function create_fragment$1s(k) {
  let r, p, v, $, S, x, I, F, O, L;
  return {
    c() {
      (r = element("button")),
        (v = space()),
        ($ = element("button")),
        (x = space()),
        (I = element("button")),
        attr(r, "class", "traffic-cls reset svelte-1ti4j67"),
        (r.disabled = p = !k[0].controls.cls || k[1]),
        attr($, "class", "traffic-min reset svelte-1ti4j67"),
        ($.disabled = S = !k[0].controls.min || k[1]),
        attr(I, "class", "traffic-max reset svelte-1ti4j67"),
        (I.disabled = F = !k[0].controls.max || k[1]);
    },
    m(U, j) {
      insert(U, r, j),
        insert(U, v, j),
        insert(U, $, j),
        insert(U, x, j),
        insert(U, I, j),
        O ||
          ((L = [
            listen(r, "click", function () {
              is_function(k[4]) && k[4].apply(this, arguments);
            }),
            listen($, "click", function () {
              is_function(k[2]) && k[2].apply(this, arguments);
            }),
            listen(I, "click", function () {
              is_function(k[3]) && k[3].apply(this, arguments);
            }),
          ]),
          (O = !0));
    },
    p(U, [j]) {
      (k = U),
        j & 3 && p !== (p = !k[0].controls.cls || k[1]) && (r.disabled = p),
        j & 3 && S !== (S = !k[0].controls.min || k[1]) && ($.disabled = S),
        j & 3 && F !== (F = !k[0].controls.max || k[1]) && (I.disabled = F);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r),
        U && detach(v),
        U && detach($),
        U && detach(x),
        U && detach(I),
        (O = !1),
        run_all(L);
    },
  };
}
function instance$1m(k, r, p) {
  let { app: v } = r,
    { isBoot: $ } = r,
    { min: S } = r,
    { max: x } = r,
    { cls: I } = r;
  return (
    (k.$$set = (F) => {
      "app" in F && p(0, (v = F.app)),
        "isBoot" in F && p(1, ($ = F.isBoot)),
        "min" in F && p(2, (S = F.min)),
        "max" in F && p(3, (x = F.max)),
        "cls" in F && p(4, (I = F.cls));
    }),
    [v, $, S, x, I]
  );
}
class Traffic extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1m, create_fragment$1s, safe_not_equal, {
        app: 0,
        isBoot: 1,
        min: 2,
        max: 3,
        cls: 4,
      });
  }
}
const OG_svelte_svelte_type_style_lang = "";
function create_fragment$1r(k) {
  let r, p, v, $, S, x, I, F, O;
  return {
    c() {
      (r = element("button")),
        (p = text("")),
        ($ = space()),
        (S = element("button")),
        (x = text("")),
        attr(r, "class", "reset svelte-1f14mwt"),
        (r.disabled = v = k[1] || !k[0].controls.min),
        attr(S, "class", "reset close svelte-1f14mwt"),
        (S.disabled = I = k[1] || !k[0].controls.cls);
    },
    m(L, U) {
      insert(L, r, U),
        append(r, p),
        insert(L, $, U),
        insert(L, S, U),
        append(S, x),
        F ||
          ((O = [
            listen(r, "click", function () {
              is_function(k[2]) && k[2].apply(this, arguments);
            }),
            listen(S, "click", function () {
              is_function(k[3]) && k[3].apply(this, arguments);
            }),
          ]),
          (F = !0));
    },
    p(L, [U]) {
      (k = L),
        U & 3 && v !== (v = k[1] || !k[0].controls.min) && (r.disabled = v),
        U & 3 && I !== (I = k[1] || !k[0].controls.cls) && (S.disabled = I);
    },
    i: noop$1,
    o: noop$1,
    d(L) {
      L && detach(r), L && detach($), L && detach(S), (F = !1), run_all(O);
    },
  };
}
function instance$1l(k, r, p) {
  let { app: v } = r,
    { isBoot: $ } = r,
    { min: S } = r,
    { cls: x } = r;
  return (
    (k.$$set = (I) => {
      "app" in I && p(0, (v = I.app)),
        "isBoot" in I && p(1, ($ = I.isBoot)),
        "min" in I && p(2, (S = I.min)),
        "cls" in I && p(3, (x = I.cls));
    }),
    [v, $, S, x]
  );
}
class OG extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1l, create_fragment$1r, safe_not_equal, {
        app: 0,
        isBoot: 1,
        min: 2,
        cls: 3,
      });
  }
}
const titlebarButtons = {
    default: { caption: "Default", author: "ArcOS Team", content: Default },
    traffic: { caption: "Traffic Lights", author: "Apple", content: Traffic },
    og: { caption: "O.G.", author: "WebOSv3 Team", content: OG },
  },
  DummyApp = {
    info: {
      name: "Dummy",
      description: "I'm a dummy!",
      builtin: !0,
      version: "1.0.0",
      author: "Robots",
      icon: dummyIcon,
    },
    pos: { x: 0, y: 0 },
    minSize: { w: 0, h: 0 },
    maxSize: { w: 0, h: 0 },
    size: { w: 0, h: 0 },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { fll: !1, max: !1, min: !1 },
    },
    glass: !1,
    content: null,
  };
function create_fragment$1q(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F = k[0].caption + "",
    O,
    L,
    U,
    j,
    N = k[0].author + "",
    q,
    R,
    Q,
    H = k[2].sh.window.buttons == k[1] ? "Applied" : "Apply",
    G,
    V,
    K,
    Y,
    J;
  var Z = k[0].content;
  function X(ee) {
    return { props: { app: DummyApp } };
  }
  return (
    Z && ($ = construct_svelte_component(Z, X())),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          (v = element("div")),
          $ && create_component($.$$.fragment),
          (S = space()),
          (x = element("div")),
          (I = element("p")),
          (O = text(F)),
          (L = space()),
          (U = element("p")),
          (j = text("By: ")),
          (q = text(N)),
          (R = space()),
          (Q = element("button")),
          (G = text(H)),
          attr(v, "class", "tb"),
          attr(p, "class", "preview"),
          attr(I, "class", "title"),
          attr(U, "class", "author"),
          attr(x, "class", "details"),
          attr(Q, "class", "apply"),
          (Q.disabled = V = k[2].sh.window.buttons == k[1]),
          attr(r, "class", "item");
      },
      m(ee, te) {
        insert(ee, r, te),
          append(r, p),
          append(p, v),
          $ && mount_component($, v, null),
          append(r, S),
          append(r, x),
          append(x, I),
          append(I, O),
          append(x, L),
          append(x, U),
          append(U, j),
          append(U, q),
          append(r, R),
          append(r, Q),
          append(Q, G),
          (K = !0),
          Y || ((J = listen(Q, "click", k[3])), (Y = !0));
      },
      p(ee, [te]) {
        if (te & 1 && Z !== (Z = ee[0].content)) {
          if ($) {
            group_outros();
            const re = $;
            transition_out(re.$$.fragment, 1, 0, () => {
              destroy_component(re, 1);
            }),
              check_outros();
          }
          Z
            ? (($ = construct_svelte_component(Z, X())),
              create_component($.$$.fragment),
              transition_in($.$$.fragment, 1),
              mount_component($, v, null))
            : ($ = null);
        }
        (!K || te & 1) && F !== (F = ee[0].caption + "") && set_data(O, F),
          (!K || te & 1) && N !== (N = ee[0].author + "") && set_data(q, N),
          (!K || te & 6) &&
            H !==
              (H = ee[2].sh.window.buttons == ee[1] ? "Applied" : "Apply") &&
            set_data(G, H),
          (!K || (te & 6 && V !== (V = ee[2].sh.window.buttons == ee[1]))) &&
            (Q.disabled = V);
      },
      i(ee) {
        K || ($ && transition_in($.$$.fragment, ee), (K = !0));
      },
      o(ee) {
        $ && transition_out($.$$.fragment, ee), (K = !1);
      },
      d(ee) {
        ee && detach(r), $ && destroy_component($), (Y = !1), J();
      },
    }
  );
}
function instance$1k(k, r, p) {
  let v;
  component_subscribe(k, UserData, (I) => p(2, (v = I)));
  let { data: $ } = r,
    { id: S } = r;
  function x() {
    set_store_value(UserData, (v.sh.window.buttons = S), v);
  }
  return (
    (k.$$set = (I) => {
      "data" in I && p(0, ($ = I.data)), "id" in I && p(1, (S = I.id));
    }),
    [$, S, v, x]
  );
}
let Item$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1k, create_fragment$1q, safe_not_equal, {
        data: 0,
        id: 1,
      });
  }
};
function get_each_context$l(k, r, p) {
  const v = k.slice();
  return (v[2] = r[p]), v;
}
function create_each_block$l(k) {
  let r, p;
  return (
    (r = new Item$1({ props: { id: k[2][0], data: k[2][1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1p(k) {
  let r, p, v, $, S, x, I, F;
  r = new CloseButton({ props: { app: k[0], id: k[1] } });
  let O = Object.entries(titlebarButtons),
    L = [];
  for (let j = 0; j < O.length; j += 1)
    L[j] = create_each_block$l(get_each_context$l(k, O, j));
  const U = (j) =>
    transition_out(L[j], 1, 1, () => {
      L[j] = null;
    });
  return {
    c() {
      create_component(r.$$.fragment),
        (p = space()),
        (v = element("h3")),
        (v.textContent = "Titlebar buttons"),
        ($ = space()),
        (S = element("p")),
        (S.textContent = "Choose one of the titlebar button styles:"),
        (x = space());
      for (let j = 0; j < L.length; j += 1) L[j].c();
      (I = empty()), attr(v, "class", "header"), attr(S, "class", "subheader");
    },
    m(j, N) {
      mount_component(r, j, N),
        insert(j, p, N),
        insert(j, v, N),
        insert(j, $, N),
        insert(j, S, N),
        insert(j, x, N);
      for (let q = 0; q < L.length; q += 1) L[q] && L[q].m(j, N);
      insert(j, I, N), (F = !0);
    },
    p(j, [N]) {
      const q = {};
      if ((N & 1 && (q.app = j[0]), N & 2 && (q.id = j[1]), r.$set(q), N & 0)) {
        O = Object.entries(titlebarButtons);
        let R;
        for (R = 0; R < O.length; R += 1) {
          const Q = get_each_context$l(j, O, R);
          L[R]
            ? (L[R].p(Q, N), transition_in(L[R], 1))
            : ((L[R] = create_each_block$l(Q)),
              L[R].c(),
              transition_in(L[R], 1),
              L[R].m(I.parentNode, I));
        }
        for (group_outros(), R = O.length; R < L.length; R += 1) U(R);
        check_outros();
      }
    },
    i(j) {
      if (!F) {
        transition_in(r.$$.fragment, j);
        for (let N = 0; N < O.length; N += 1) transition_in(L[N]);
        F = !0;
      }
    },
    o(j) {
      transition_out(r.$$.fragment, j), (L = L.filter(Boolean));
      for (let N = 0; N < L.length; N += 1) transition_out(L[N]);
      F = !1;
    },
    d(j) {
      destroy_component(r, j),
        j && detach(p),
        j && detach(v),
        j && detach($),
        j && detach(S),
        j && detach(x),
        destroy_each(L, j),
        j && detach(I);
    },
  };
}
function instance$1j(k, r, p) {
  let { app: v } = r,
    { id: $ } = r;
  return (
    (k.$$set = (S) => {
      "app" in S && p(0, (v = S.app)), "id" in S && p(1, ($ = S.id));
    }),
    [v, $]
  );
}
class ChangeTitleButtons extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1j, create_fragment$1p, safe_not_equal, {
        app: 0,
        id: 1,
      });
  }
}
const customWallpaper = "";
function create_fragment$1o(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H, G, V;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (x = element("div")),
        (I = element("p")),
        (I.textContent = "Enter the URL to a custom wallpaper:"),
        (F = space()),
        (O = element("input")),
        (L = space()),
        (U = element("div")),
        (j = element("div")),
        (N = element("button")),
        (N.textContent = "Cancel"),
        (q = space()),
        (R = element("button")),
        (Q = text("Apply")),
        src_url_equal(v.src, ($ = desktopIcon)) || attr(v, "src", $),
        attr(v, "alt", ""),
        attr(O, "type", "url"),
        attr(O, "placeholder", "https://example.com/image.png"),
        (R.disabled = H = !k[1] || !k[0]),
        attr(U, "class", "apply"),
        attr(x, "class", "field"),
        attr(r, "class", "customwallpaper-wrapper");
    },
    m(K, Y) {
      insert(K, r, Y),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, x),
        append(x, I),
        append(x, F),
        append(x, O),
        set_input_value(O, k[1]),
        append(x, L),
        append(x, U),
        append(U, j),
        append(j, N),
        append(j, q),
        append(j, R),
        append(R, Q),
        G ||
          ((V = [
            listen(O, "input", k[5]),
            listen(O, "input", k[3]),
            listen(N, "click", k[4]),
            listen(R, "click", k[2]),
          ]),
          (G = !0));
    },
    p(K, [Y]) {
      Y & 2 && O.value !== K[1] && set_input_value(O, K[1]),
        Y & 3 && H !== (H = !K[1] || !K[0]) && (R.disabled = H);
    },
    i: noop$1,
    o: noop$1,
    d(K) {
      K && detach(r), (G = !1), run_all(V);
    },
  };
}
async function checkImage(k) {
  const r = new Image();
  return (
    (r.src = k),
    new Promise((p) => {
      (r.onload = () => p(!0)), (r.onerror = () => p(!1));
    })
  );
}
function instance$1i(k, r, p) {
  let v;
  component_subscribe(k, UserData, (L) => p(6, (v = L)));
  let $ = !1,
    S;
  function x() {
    set_store_value(UserData, (v.sh.desktop.wallpaper = S), v), F();
  }
  onMount(() => {
    v.sh.desktop.wallpaper.startsWith("img") ||
      p(1, (S = v.sh.desktop.wallpaper));
  });
  async function I() {
    const L = await checkImage(S);
    p(0, ($ = L));
  }
  function F() {
    hideOverlay("customWallpaper", "SettingsApp");
  }
  UserData.subscribe((L) => {
    typeof L.sh.desktop.wallpaper == "string" &&
      !L.sh.desktop.wallpaper.startsWith("img") &&
      p(1, (S = L.acc.profilePicture)),
      I();
  });
  function O() {
    (S = this.value), p(1, S);
  }
  return [$, S, x, I, F, O];
}
class CustomWallpaper extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1i, create_fragment$1o, safe_not_equal, {});
  }
}
const savetheme = "",
  img0 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABIAAAAKICAIAAACHSRZaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAiSSURBVHhe7cEBDQAAAMKg909tDjcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALhTAzCGAAGNmWH9AAAAAElFTkSuQmCC",
  img01 = "./assets/img01-bbc2eae0.png",
  img02 = "./assets/img02-6950200c.png",
  img03 = "./assets/img03-87b2d378.png",
  img04 = "./assets/img04-9d473c5a.png",
  img05 = "./assets/img05-3c6c1958.png",
  img06 = "./assets/img06-e2fa3f96.jpg",
  img07 = "./assets/img07-788d74d9.jpg",
  img08 = "./assets/img08-feb75f17.jpg",
  img09 = "./assets/img09-99f29be6.png",
  img10 = "./assets/img10-6840e15c.png",
  img11 = "./assets/img11-d41c172b.jpg",
  img12 = "./assets/img12-c9a4396e.png",
  img13 = "./assets/img13-0a31c489.png",
  img14 = "./assets/img14-54c8328b.jpg",
  Wallpapers = {
    img0,
    img04,
    img05,
    img01,
    img02,
    img03,
    img08,
    img13,
    img14,
    img06,
    img07,
    img09,
    img10,
    img11,
    img12,
  };
function getWallpaper(k) {
  return (
    Log({
      msg: `Getting wallpaper ${k.startsWith("img") ? k : "<custom>"}`,
      source: "userlogic/wallpapers.ts: getWallpaper",
      level: LogLevel.info,
    }),
    k && (k.startsWith("img") ? Wallpapers[k] || img04 : k)
  );
}
function create_fragment$1n(k) {
  let r, p, v, $;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = space()),
        ($ = element("div")),
        ($.innerHTML = `<div class="fake-titlebar">Window Title</div> 
    <div class="fake-body">Window body</div>`),
        attr(p, "class", "fake-taskbar"),
        toggle_class(p, "colored", k[0].sh.taskbar.colored),
        toggle_class(p, "docked", k[0].sh.taskbar.docked),
        attr($, "class", "fake-window"),
        attr(r, "class", "current"),
        set_style(
          r,
          "background-image",
          "url(" + getWallpaper(k[0].sh.desktop.wallpaper) + ")"
        );
    },
    m(S, x) {
      insert(S, r, x), append(r, p), append(r, v), append(r, $);
    },
    p(S, [x]) {
      x & 1 && toggle_class(p, "colored", S[0].sh.taskbar.colored),
        x & 1 && toggle_class(p, "docked", S[0].sh.taskbar.docked),
        x & 1 &&
          set_style(
            r,
            "background-image",
            "url(" + getWallpaper(S[0].sh.desktop.wallpaper) + ")"
          );
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r);
    },
  };
}
function instance$1h(k, r, p) {
  let v;
  return component_subscribe(k, UserData, ($) => p(0, (v = $))), [v];
}
class Current extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1h, create_fragment$1n, safe_not_equal, {});
  }
}
function create_fragment$1m(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H, G, V;
  return (
    (Q = new Current({})),
    {
      c() {
        (r = element("div")),
          (p = element("h3")),
          (p.textContent = "Save theme"),
          (v = space()),
          ($ = element("p")),
          ($.textContent = "Choose a name for your theme:"),
          (S = space()),
          (x = element("input")),
          (I = space()),
          (F = element("div")),
          (O = element("button")),
          (L = text("Save")),
          (j = space()),
          (N = element("button")),
          (N.textContent = "Cancel"),
          (q = space()),
          (R = element("div")),
          create_component(Q.$$.fragment),
          attr(p, "class", "header"),
          attr(x, "type", "text"),
          (O.disabled = U = !k[0]),
          attr(F, "class", "actions"),
          attr(r, "class", "form"),
          attr(R, "class", "desktop-page");
      },
      m(K, Y) {
        insert(K, r, Y),
          append(r, p),
          append(r, v),
          append(r, $),
          append(r, S),
          append(r, x),
          set_input_value(x, k[0]),
          append(r, I),
          append(r, F),
          append(F, O),
          append(O, L),
          append(F, j),
          append(F, N),
          insert(K, q, Y),
          insert(K, R, Y),
          mount_component(Q, R, null),
          (H = !0),
          G ||
            ((V = [
              listen(x, "input", k[3]),
              listen(O, "click", k[2]),
              listen(N, "click", k[1]),
            ]),
            (G = !0));
      },
      p(K, [Y]) {
        Y & 1 && x.value !== K[0] && set_input_value(x, K[0]),
          (!H || (Y & 1 && U !== (U = !K[0]))) && (O.disabled = U);
      },
      i(K) {
        H || (transition_in(Q.$$.fragment, K), (H = !0));
      },
      o(K) {
        transition_out(Q.$$.fragment, K), (H = !1);
      },
      d(K) {
        K && detach(r),
          K && detach(q),
          K && detach(R),
          destroy_component(Q),
          (G = !1),
          run_all(V);
      },
    }
  );
}
function instance$1g(k, r, p) {
  let v;
  function $() {
    hideOverlay("saveTheme", "SettingsApp");
  }
  function S() {
    saveCurrentTheme(v), $();
  }
  function x() {
    (v = this.value), p(0, v);
  }
  return [v, $, S, x];
}
class SaveTheme extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1g, create_fragment$1m, safe_not_equal, {});
  }
}
const theme = "./assets/themes-1332e1fc.svg",
  saveToFS = {
    caption: "Save to ArcFS",
    action: async (k, r) => {
      const p = new Blob([r.json], { type: "application/json" });
      await createDirectory("./Themes");
      const v = `${r.name}.arctheme`,
        $ = `./Themes/${v}`;
      await writeFile($, p),
        openWindow("FileManager"),
        await fbClass.goToDirectory("./Themes"),
        setTimeout(() => {
          FileBrowserSelectedFilename.set(v);
        });
    },
    icon: "save",
  },
  SettingsAppContext = {
    "themerenderer-user": [
      {
        caption: "Delete",
        action: (k, r) => {
          createOverlayableError(
            {
              title: "Delete theme?",
              message: "Are you sure you want to delete this theme?",
              image: theme,
              buttons: [
                {
                  caption: "Delete",
                  action() {
                    deleteCustomTheme(r.id);
                  },
                },
                { caption: "Cancel", action() {} },
              ],
            },
            "SettingsApp"
          );
        },
        icon: "delete",
      },
      saveToFS,
    ],
    "themerenderer-system": [saveToFS],
    "accountpage-hostname": [
      {
        caption: "View user data",
        action: () => {
          showOverlay("udataExplorer", "SettingsApp");
        },
        icon: "account_tree",
      },
      {
        caption: "Copy server",
        action: () => {
          navigator.clipboard.writeText(
            localStorage.getItem("arcos-server") || "localhost"
          );
        },
        icon: "copy",
      },
    ],
    "appearance-accentselector": [
      {
        caption: "Copy color code",
        action: (k, r) => {
          navigator.clipboard.writeText(`#${r.hex}`);
        },
        icon: "copy",
      },
    ],
  },
  ProfilePictureOverlays = {
    pfpSel: {
      info: {
        name: "Profile Picture Selector",
        version: "1.0.0",
        author: "ArcOS Team",
      },
      content: ProfilePicture,
      size: { w: 382, h: 410 },
      show: !1,
    },
    customPfp: {
      info: {
        name: "Custom Profile Picture",
        version: "1.0.0",
        author: "ArcOS Team",
      },
      content: CustomProfilePicture,
      size: { w: 350, h: 125 },
      show: !1,
    },
    largePfp: {
      info: {
        name: "View Profile Picture",
        version: "1.0.0",
        author: "ArcOS Team",
      },
      content: ProfilePictureView,
      size: { w: 320, h: 360 },
      show: !1,
    },
    changeTitleButtons: {
      info: {
        name: "Change Titlebar Buttons",
        version: "1.0.0",
        author: "ArcOS Team",
      },
      content: ChangeTitleButtons,
      size: { w: 400, h: 300 },
      show: !1,
    },
  },
  AccountPageOverlays = {
    udataExplorer: {
      info: {
        name: "User Data Explorer",
        version: "1.0.0",
        author: "ArcOS Team",
      },
      content: UserDataExplorer,
      size: { w: 550, h: 400 },
      show: !1,
    },
    changePswd: {
      info: { name: "Change Password", version: "1.0.0", author: "ArcOS Team" },
      content: ChangePassword,
      size: { w: 370, h: 195 },
      show: !1,
    },
    changeUsername: {
      info: { name: "Change Username", version: "1.0.0", author: "ArcOS Team" },
      content: ChangeUsername,
      size: { w: 370, h: 155 },
      show: !1,
    },
  },
  DesktopOverlays = {
    customWallpaper: {
      info: {
        name: "Custom Wallpaper",
        version: "1.0.0",
        author: "ArcOS Team",
      },
      content: CustomWallpaper,
      size: { w: 370, h: 118 },
      show: !1,
    },
  },
  ThemeOverlays = {
    saveTheme: {
      info: { name: "Save Theme", version: "1.0.0", author: "ArcOS Team" },
      content: SaveTheme,
      size: { w: 450, h: 170 },
      show: !1,
    },
  },
  SettingsApp = {
    info: {
      name: "System Settings",
      description: "Change the way ArcOS works",
      builtin: !0,
      version: "4.0.0",
      author: "ArcOS Team",
      icon: logo$1,
    },
    size: { w: 730, h: 500 },
    pos: { x: 30, y: 40 },
    minSize: { w: 730, h: 500 },
    maxSize: { w: 1100, h: 600 },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: SettingsApp$1,
    glass: !0,
    overlays: {
      ...ProfilePictureOverlays,
      ...AccountPageOverlays,
      ...DesktopOverlays,
      ...ThemeOverlays,
    },
    events: {
      close() {
        currentSettingsPage.set(null);
      },
      open() {
        currentSettingsPage.set(SettingsPages[0]);
      },
    },
    contextMenu: SettingsAppContext,
  },
  actioncenter = "";
function get_each_context$k(k, r, p) {
  const v = k.slice();
  return (v[3] = r[p]), v;
}
function create_else_block$a(k) {
  let r,
    p = k[0][1].icon + "",
    v;
  return {
    c() {
      (r = element("span")),
        (v = text(p)),
        attr(r, "class", "material-icons-round");
    },
    m($, S) {
      insert($, r, S), append(r, v);
    },
    p($, S) {
      S & 1 && p !== (p = $[0][1].icon + "") && set_data(v, p);
    },
    d($) {
      $ && detach(r);
    },
  };
}
function create_if_block$z(k) {
  let r, p, v;
  return {
    c() {
      (r = element("img")),
        src_url_equal(r.src, (p = k[0][1].image)) || attr(r, "src", p),
        attr(r, "alt", (v = k[0][1].title));
    },
    m($, S) {
      insert($, r, S);
    },
    p($, S) {
      S & 1 && !src_url_equal(r.src, (p = $[0][1].image)) && attr(r, "src", p),
        S & 1 && v !== (v = $[0][1].title) && attr(r, "alt", v);
    },
    d($) {
      $ && detach(r);
    },
  };
}
function create_each_block$k(k) {
  let r,
    p = k[3].capt + "",
    v,
    $,
    S;
  return {
    c() {
      (r = element("button")), (v = text(p));
    },
    m(x, I) {
      insert(x, r, I),
        append(r, v),
        $ ||
          ((S = listen(r, "click", function () {
            is_function(k[2](k[3].action)) &&
              k[2](k[3].action).apply(this, arguments);
          })),
          ($ = !0));
    },
    p(x, I) {
      (k = x), I & 1 && p !== (p = k[3].capt + "") && set_data(v, p);
    },
    d(x) {
      x && detach(r), ($ = !1), S();
    },
  };
}
function create_fragment$1l(k) {
  let r,
    p,
    v,
    $ = k[0][1].title + "",
    S,
    x,
    I,
    F,
    O,
    L = k[0][1].message + "",
    U,
    j,
    N,
    q,
    R;
  function Q(Y, J) {
    return Y[0][1].image ? create_if_block$z : create_else_block$a;
  }
  let H = Q(k),
    G = H(k),
    V = k[0][1].buttons,
    K = [];
  for (let Y = 0; Y < V.length; Y += 1)
    K[Y] = create_each_block$k(get_each_context$k(k, V, Y));
  return {
    c() {
      (r = element("div")),
        (p = element("p")),
        G.c(),
        (v = space()),
        (S = text($)),
        (x = space()),
        (I = element("button")),
        (I.textContent = "close"),
        (F = space()),
        (O = element("p")),
        (U = space()),
        (j = element("div")),
        (N = element("div"));
      for (let Y = 0; Y < K.length; Y += 1) K[Y].c();
      attr(I, "class", "close material-icons-round"),
        attr(p, "class", "title"),
        attr(O, "class", "content"),
        attr(N, "class", "inner"),
        attr(j, "class", "buttons"),
        attr(r, "class", "notification ac");
    },
    m(Y, J) {
      insert(Y, r, J),
        append(r, p),
        G.m(p, null),
        append(p, v),
        append(p, S),
        append(p, x),
        append(p, I),
        append(r, F),
        append(r, O),
        (O.innerHTML = L),
        append(r, U),
        append(r, j),
        append(j, N);
      for (let Z = 0; Z < K.length; Z += 1) K[Z] && K[Z].m(N, null);
      q || ((R = listen(I, "click", k[1])), (q = !0));
    },
    p(Y, [J]) {
      if (
        (H === (H = Q(Y)) && G
          ? G.p(Y, J)
          : (G.d(1), (G = H(Y)), G && (G.c(), G.m(p, v))),
        J & 1 && $ !== ($ = Y[0][1].title + "") && set_data(S, $),
        J & 1 && L !== (L = Y[0][1].message + "") && (O.innerHTML = L),
        J & 5)
      ) {
        V = Y[0][1].buttons;
        let Z;
        for (Z = 0; Z < V.length; Z += 1) {
          const X = get_each_context$k(Y, V, Z);
          K[Z]
            ? K[Z].p(X, J)
            : ((K[Z] = create_each_block$k(X)), K[Z].c(), K[Z].m(N, null));
        }
        for (; Z < K.length; Z += 1) K[Z].d(1);
        K.length = V.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(Y) {
      Y && detach(r), G.d(), destroy_each(K, Y), (q = !1), R();
    },
  };
}
function instance$1f(k, r, p) {
  let { notification: v } = r;
  function $() {
    deleteNotification(v[0]), CurrentNotification.set(null);
  }
  function S(x) {
    return () => {
      x(), $(), ActionCenterOpened.set(!1);
    };
  }
  return (
    (k.$$set = (x) => {
      "notification" in x && p(0, (v = x.notification));
    }),
    [v, $, S]
  );
}
class Notification extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1f, create_fragment$1l, safe_not_equal, {
        notification: 0,
      });
  }
}
function get_each_context$j(k, r, p) {
  const v = k.slice();
  return (v[1] = r[p]), v;
}
function create_each_block$j(k) {
  let r, p;
  return (
    (r = new Notification({ props: { notification: k[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.notification = v[1]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$y(k) {
  let r;
  return {
    c() {
      (r = element("p")),
        (r.textContent = "You have no notifications"),
        attr(r, "class", "none");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$1k(k) {
  let r,
    p,
    v = Object.entries(k[0]).length == 0,
    $,
    S = Object.entries(k[0]),
    x = [];
  for (let O = 0; O < S.length; O += 1)
    x[O] = create_each_block$j(get_each_context$j(k, S, O));
  const I = (O) =>
    transition_out(x[O], 1, 1, () => {
      x[O] = null;
    });
  let F = v && create_if_block$y();
  return {
    c() {
      r = element("div");
      for (let O = 0; O < x.length; O += 1) x[O].c();
      (p = space()), F && F.c(), attr(r, "class", "notifications");
    },
    m(O, L) {
      insert(O, r, L);
      for (let U = 0; U < x.length; U += 1) x[U] && x[U].m(r, null);
      append(r, p), F && F.m(r, null), ($ = !0);
    },
    p(O, [L]) {
      if (L & 1) {
        S = Object.entries(O[0]);
        let U;
        for (U = 0; U < S.length; U += 1) {
          const j = get_each_context$j(O, S, U);
          x[U]
            ? (x[U].p(j, L), transition_in(x[U], 1))
            : ((x[U] = create_each_block$j(j)),
              x[U].c(),
              transition_in(x[U], 1),
              x[U].m(r, p));
        }
        for (group_outros(), U = S.length; U < x.length; U += 1) I(U);
        check_outros();
      }
      L & 1 && (v = Object.entries(O[0]).length == 0),
        v
          ? F || ((F = create_if_block$y()), F.c(), F.m(r, null))
          : F && (F.d(1), (F = null));
    },
    i(O) {
      if (!$) {
        for (let L = 0; L < S.length; L += 1) transition_in(x[L]);
        $ = !0;
      }
    },
    o(O) {
      x = x.filter(Boolean);
      for (let L = 0; L < x.length; L += 1) transition_out(x[L]);
      $ = !1;
    },
    d(O) {
      O && detach(r), destroy_each(x, O), F && F.d();
    },
  };
}
function instance$1e(k, r, p) {
  let v;
  return component_subscribe(k, NotificationStore, ($) => p(0, (v = $))), [v];
}
class Notifications extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1e, create_fragment$1k, safe_not_equal, {});
  }
}
function reloadApps() {
  const k = get_store_value(WindowStore);
  for (let r = 0; r < k.length; r++) k[r].info.builtin && k.splice(r, 1);
  WindowStore.set(k),
    setTimeout(() => {
      importDefault(),
        makeNotification({
          title: "Reloaded",
          message:
            "All applications have been reloaded. Any unsaved information across all apps has been lost.",
          icon: "autorenew",
          buttons: [
            {
              capt: "Open Apps Settings",
              action: () => {
                openByKey("Apps");
              },
            },
          ],
        });
    }, 100);
}
const QuickSettings = [
  {
    icon: "motion_photos_on",
    iconOff: "motion_photos_off",
    getter(k) {
      return k.sh.anim;
    },
    setter(k) {
      return (k.sh.anim = !k.sh.anim), UserData.set(k), k.sh.anim;
    },
    caption: "Animations",
  },
  {
    icon: "blur_on",
    iconOff: "blur_off",
    getter(k) {
      return !k.sh.noGlass;
    },
    setter(k) {
      return (k.sh.noGlass = !k.sh.noGlass), UserData.set(k), !k.sh.noGlass;
    },
    caption: "Transparency",
  },
  {
    icon: "call_to_action",
    iconOff: "call_to_action",
    getter(k) {
      return k.sh.taskbar.docked;
    },
    setter(k) {
      return (
        (k.sh.taskbar.docked = !k.sh.taskbar.docked),
        UserData.set(k),
        k.sh.taskbar.docked
      );
    },
    caption: "Dock Taskbar",
  },
  {
    icon: "dark_mode",
    iconOff: "light_mode",
    getter(k) {
      return k.sh.desktop.theme == "dark";
    },
    setter(k) {
      const r = k.sh.desktop.theme;
      return (
        (k.sh.desktop.theme = r == "dark" ? "light" : "dark"),
        UserData.set(k),
        k.sh.desktop.theme == "dark"
      );
    },
    caption: "Dark mode",
  },
  {
    icon: "",
    iconOff: "",
    getter() {
      return !1;
    },
    setter() {
      return !1;
    },
    caption: "",
  },
  {
    icon: "",
    iconOff: "",
    getter() {
      return !1;
    },
    setter() {
      return !1;
    },
    caption: "",
  },
  {
    icon: "",
    iconOff: "",
    getter() {
      return !1;
    },
    setter() {
      return !1;
    },
    caption: "",
  },
  {
    icon: "",
    iconOff: "",
    getter() {
      return !1;
    },
    setter() {
      return !1;
    },
    caption: "",
  },
  {
    icon: "",
    iconOff: "",
    getter() {
      return !1;
    },
    setter() {
      return !1;
    },
    caption: "",
  },
];
function create_fragment$1j(k) {
  let r,
    p = (k[1] ? k[0].icon : k[0].iconOff) + "",
    v,
    $,
    S,
    x = k[0].caption + "",
    I,
    F,
    O;
  return {
    c() {
      (r = element("button")),
        (v = text(p)),
        ($ = space()),
        (S = element("p")),
        (I = text(x)),
        attr(S, "class", "caption"),
        attr(r, "class", "setting material-icons-round"),
        toggle_class(r, "active", k[1]);
    },
    m(L, U) {
      insert(L, r, U),
        append(r, v),
        append(r, $),
        append(r, S),
        append(S, I),
        F || ((O = listen(r, "click", k[2])), (F = !0));
    },
    p(L, [U]) {
      U & 3 &&
        p !== (p = (L[1] ? L[0].icon : L[0].iconOff) + "") &&
        set_data(v, p),
        U & 1 && x !== (x = L[0].caption + "") && set_data(I, x),
        U & 2 && toggle_class(r, "active", L[1]);
    },
    i: noop$1,
    o: noop$1,
    d(L) {
      L && detach(r), (F = !1), O();
    },
  };
}
function instance$1d(k, r, p) {
  let v;
  component_subscribe(k, UserData, (I) => p(3, (v = I)));
  let $ = !1,
    { setting: S } = r;
  function x() {
    S.setter(v), p(1, ($ = S.getter(v)));
  }
  return (
    onMount(() => {
      p(1, ($ = S.getter(v)));
    }),
    UserData.subscribe((I) => {
      p(1, ($ = S.getter(I)));
    }),
    (k.$$set = (I) => {
      "setting" in I && p(0, (S = I.setting));
    }),
    [S, $, x]
  );
}
class Setting extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1d, create_fragment$1j, safe_not_equal, {
        setting: 0,
      });
  }
}
function get_each_context$i(k, r, p) {
  const v = k.slice();
  return (v[0] = r[p]), v;
}
function create_each_block$i(k) {
  let r, p;
  return (
    (r = new Setting({ props: { setting: k[0] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1i(k) {
  let r,
    p,
    v = QuickSettings,
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$i(get_each_context$i(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      r = element("div");
      for (let x = 0; x < $.length; x += 1) $[x].c();
      attr(r, "class", "quicksettings");
    },
    m(x, I) {
      insert(x, r, I);
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(r, null);
      p = !0;
    },
    p(x, [I]) {
      if (I & 0) {
        v = QuickSettings;
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$i(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$i(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      x && detach(r), destroy_each($, x);
    },
  };
}
class QuickSettings_1 extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$1i, safe_not_equal, {});
  }
}
function create_fragment$1h(k) {
  let r,
    p,
    v = k[0].sh.noQuickSettings ? "Expand" : "Collapse",
    $,
    S,
    x;
  return {
    c() {
      (r = element("div")),
        (p = element("button")),
        ($ = text(v)),
        attr(p, "class", "toggle"),
        attr(r, "class", "quicksettings-toggle");
    },
    m(I, F) {
      insert(I, r, F),
        append(r, p),
        append(p, $),
        S || ((x = listen(p, "click", k[1])), (S = !0));
    },
    p(I, [F]) {
      F & 1 &&
        v !== (v = I[0].sh.noQuickSettings ? "Expand" : "Collapse") &&
        set_data($, v);
    },
    i: noop$1,
    o: noop$1,
    d(I) {
      I && detach(r), (S = !1), x();
    },
  };
}
function instance$1c(k, r, p) {
  let v;
  component_subscribe(k, UserData, (S) => p(0, (v = S)));
  function $() {
    set_store_value(
      UserData,
      (v.sh.noQuickSettings = !v.sh.noQuickSettings),
      v
    );
  }
  return [v, $];
}
class QuickSettingsToggle extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1c, create_fragment$1h, safe_not_equal, {});
  }
}
function create_fragment$1g(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H;
  return (
    (L = new Notifications({})),
    (j = new QuickSettingsToggle({})),
    (q = new QuickSettings_1({})),
    {
      c() {
        (r = element("div")),
          (p = space()),
          (v = element("div")),
          ($ = element("h3")),
          (S = text("Notifications ")),
          (x = element("button")),
          (I = text("Clear")),
          (O = space()),
          create_component(L.$$.fragment),
          (U = space()),
          create_component(j.$$.fragment),
          (N = space()),
          create_component(q.$$.fragment),
          attr(r, "class", "actioncenter-shade"),
          set_style(r, "z-index", k[2] + 3),
          toggle_class(r, "opened", k[0]),
          attr(x, "class", "clear"),
          (x.disabled = F = !Object.entries(k[4]).length),
          attr($, "class", "title"),
          attr(v, "class", "actioncenter"),
          set_style(v, "z-index", k[2] + 4),
          toggle_class(v, "docked", k[3].sh.taskbar.docked),
          toggle_class(v, "opened", k[0]),
          toggle_class(v, "noquick", k[3].sh.noQuickSettings),
          toggle_class(v, "colored", k[3].sh.taskbar.colored);
      },
      m(G, V) {
        insert(G, r, V),
          insert(G, p, V),
          insert(G, v, V),
          append(v, $),
          append($, S),
          append($, x),
          append(x, I),
          append(v, O),
          mount_component(L, v, null),
          append(v, U),
          mount_component(j, v, null),
          append(v, N),
          mount_component(q, v, null),
          (R = !0),
          Q ||
            ((H = [listen(r, "click", k[6]), listen(x, "click", k[5])]),
            (Q = !0));
      },
      p(G, [V]) {
        (!R || V & 4) && set_style(r, "z-index", G[2] + 3),
          (!R || V & 1) && toggle_class(r, "opened", G[0]),
          (!R || (V & 16 && F !== (F = !Object.entries(G[4]).length))) &&
            (x.disabled = F),
          (!R || V & 4) && set_style(v, "z-index", G[2] + 4),
          (!R || V & 8) && toggle_class(v, "docked", G[3].sh.taskbar.docked),
          (!R || V & 1) && toggle_class(v, "opened", G[0]),
          (!R || V & 8) && toggle_class(v, "noquick", G[3].sh.noQuickSettings),
          (!R || V & 8) && toggle_class(v, "colored", G[3].sh.taskbar.colored);
      },
      i(G) {
        R ||
          (transition_in(L.$$.fragment, G),
          transition_in(j.$$.fragment, G),
          transition_in(q.$$.fragment, G),
          (R = !0));
      },
      o(G) {
        transition_out(L.$$.fragment, G),
          transition_out(j.$$.fragment, G),
          transition_out(q.$$.fragment, G),
          (R = !1);
      },
      d(G) {
        G && detach(r),
          G && detach(p),
          G && detach(v),
          destroy_component(L),
          destroy_component(j),
          destroy_component(q),
          (Q = !1),
          run_all(H);
      },
    }
  );
}
function instance$1b(k, r, p) {
  let v, $, S, x;
  component_subscribe(k, ActionCenterOpened, (L) => p(1, (v = L))),
    component_subscribe(k, maxZIndex, (L) => p(2, ($ = L))),
    component_subscribe(k, UserData, (L) => p(3, (S = L))),
    component_subscribe(k, NotificationStore, (L) => p(4, (x = L)));
  let I = !1;
  ActionCenterOpened.subscribe((L) => p(0, (I = L)));
  function F() {
    NotificationStore.set({}), CurrentNotification.set(null);
  }
  return [
    I,
    v,
    $,
    S,
    x,
    F,
    () => set_store_value(ActionCenterOpened, (v = !1), v),
  ];
}
class ActionCenter extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1b, create_fragment$1g, safe_not_equal, {});
  }
}
const desktopicons = "";
function create_fragment$1f(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I = k[0].info.name + "",
    F,
    O,
    L;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (S = space()),
        (x = element("p")),
        (F = text(I)),
        src_url_equal(
          p.src,
          (v = getOriginalIcon(k[0].id) || k[0].info.icon)
        ) || attr(p, "src", v),
        attr(p, "alt", ($ = k[0].info.name)),
        attr(x, "class", "name"),
        attr(r, "class", "desktopIcon");
    },
    m(U, j) {
      insert(U, r, j),
        append(r, p),
        append(r, S),
        append(r, x),
        append(x, F),
        O || ((L = listen(r, "dblclick", k[1])), (O = !0));
    },
    p(U, [j]) {
      j & 1 &&
        !src_url_equal(
          p.src,
          (v = getOriginalIcon(U[0].id) || U[0].info.icon)
        ) &&
        attr(p, "src", v),
        j & 1 && $ !== ($ = U[0].info.name) && attr(p, "alt", $),
        j & 1 && I !== (I = U[0].info.name + "") && set_data(F, I);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r), (O = !1), L();
    },
  };
}
function instance$1a(k, r, p) {
  let { app: v } = r;
  function $() {
    openWindow(v.id);
  }
  return (
    (k.$$set = (S) => {
      "app" in S && p(0, (v = S.app));
    }),
    [v, $]
  );
}
class DesktopIcon extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1a, create_fragment$1f, safe_not_equal, {
        app: 0,
      });
  }
}
function get_each_context$h(k, r, p) {
  const v = k.slice();
  return (v[2] = r[p]), v;
}
function create_if_block$x(k) {
  let r,
    p,
    v = k[1],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$h(get_each_context$h(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      r = element("div");
      for (let x = 0; x < $.length; x += 1) $[x].c();
      attr(r, "class", "desktopIcons");
    },
    m(x, I) {
      insert(x, r, I);
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(r, null);
      p = !0;
    },
    p(x, I) {
      if (I & 2) {
        v = x[1];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$h(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$h(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      x && detach(r), destroy_each($, x);
    },
  };
}
function create_if_block_1$9(k) {
  let r, p;
  return (
    (r = new DesktopIcon({ props: { app: k[2] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 2 && (S.app = v[2]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$h(k) {
  let r = isPopulatable(k[2]),
    p,
    v,
    $ = r && create_if_block_1$9(k);
  return {
    c() {
      $ && $.c(), (p = empty());
    },
    m(S, x) {
      $ && $.m(S, x), insert(S, p, x), (v = !0);
    },
    p(S, x) {
      x & 2 && (r = isPopulatable(S[2])),
        r
          ? $
            ? ($.p(S, x), x & 2 && transition_in($, 1))
            : (($ = create_if_block_1$9(S)),
              $.c(),
              transition_in($, 1),
              $.m(p.parentNode, p))
          : $ &&
            (group_outros(),
            transition_out($, 1, 1, () => {
              $ = null;
            }),
            check_outros());
    },
    i(S) {
      v || (transition_in($), (v = !0));
    },
    o(S) {
      transition_out($), (v = !1);
    },
    d(S) {
      $ && $.d(S), S && detach(p);
    },
  };
}
function create_fragment$1e(k) {
  let r,
    p,
    v = k[0].sh.desktop.icons && create_if_block$x(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, [S]) {
      $[0].sh.desktop.icons
        ? v
          ? (v.p($, S), S & 1 && transition_in(v, 1))
          : ((v = create_if_block$x($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function instance$19(k, r, p) {
  let v, $;
  return (
    component_subscribe(k, UserData, (S) => p(0, (v = S))),
    component_subscribe(k, WindowStore, (S) => p(1, ($ = S))),
    [v, $]
  );
}
class DesktopIcons extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$19, create_fragment$1e, safe_not_equal, {});
  }
}
function getWindowElement(k) {
  return document.querySelector(`window#${k.id}`);
}
function getWindowElementByEvent(k) {
  const r = k.composedPath();
  for (let p = 0; p < r.length; p++) {
    const v = r[p].tagName;
    if (v && v.toLowerCase() == "window") return r[p];
  }
}
function create_if_block$w(k) {
  let r,
    p = k[0].info.name + "",
    v;
  return {
    c() {
      (r = element("span")), (v = text(p));
    },
    m($, S) {
      insert($, r, S), append(r, v);
    },
    p($, S) {
      S & 1 && p !== (p = $[0].info.name + "") && set_data(v, p);
    },
    d($) {
      $ && detach(r);
    },
  };
}
function create_fragment$1d(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F = k[1] && create_if_block$w(k);
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (S = space()),
        F && F.c(),
        src_url_equal(
          p.src,
          (v = getOriginalIcon(k[0].id) || getAppIcon(k[0]))
        ) || attr(p, "src", v),
        attr(p, "alt", ($ = k[0].info.name)),
        attr(p, "class", "icon"),
        attr(r, "class", "appbutton"),
        toggle_class(r, "minimized", k[2]),
        toggle_class(r, "activated", k[0].id == k[3]);
    },
    m(O, L) {
      insert(O, r, L),
        append(r, p),
        append(r, S),
        F && F.m(r, null),
        x || ((I = listen(r, "click", k[4])), (x = !0));
    },
    p(O, [L]) {
      L & 1 &&
        !src_url_equal(
          p.src,
          (v = getOriginalIcon(O[0].id) || getAppIcon(O[0]))
        ) &&
        attr(p, "src", v),
        L & 1 && $ !== ($ = O[0].info.name) && attr(p, "alt", $),
        O[1]
          ? F
            ? F.p(O, L)
            : ((F = create_if_block$w(O)), F.c(), F.m(r, null))
          : F && (F.d(1), (F = null)),
        L & 4 && toggle_class(r, "minimized", O[2]),
        L & 9 && toggle_class(r, "activated", O[0].id == O[3]);
    },
    i: noop$1,
    o: noop$1,
    d(O) {
      O && detach(r), F && F.d(), (x = !1), I();
    },
  };
}
function instance$18(k, r, p) {
  let v, $;
  component_subscribe(k, maxZIndex, (O) => p(5, (v = O))),
    component_subscribe(k, focusedWindowId, (O) => p(3, ($ = O)));
  let { app: S } = r,
    x = !1,
    I = !1;
  UserData.subscribe((O) => {
    p(1, (x = O.sh.taskbar.labels));
  }),
    WindowStore.subscribe(() => {
      p(2, (I = isMinimized(S.id)));
    });
  function F() {
    $ == S.id
      ? p(0, (S.state.windowState.min = !S.state.windowState.min), S)
      : p(0, (S.state.windowState.min = !1), S),
      updateStores(),
      set_store_value(maxZIndex, v++, v),
      set_store_value(focusedWindowId, ($ = S.id), $);
    const O = getWindowElement(S);
    O.style.zIndex = v.toString();
  }
  return (
    (k.$$set = (O) => {
      "app" in O && p(0, (S = O.app));
    }),
    [S, x, I, $, F]
  );
}
class TaskbarButton extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$18, create_fragment$1d, safe_not_equal, {
        app: 0,
      });
  }
}
const upload = "./assets/upload-54369c84.svg";
function get_each_context$g(k, r, p) {
  const v = k.slice();
  return (v[5] = r[p]), v;
}
function create_else_block$9(k) {
  let r, p, v;
  return {
    c() {
      (r = element("img")),
        src_url_equal(r.src, (p = k[5].image)) || attr(r, "src", p),
        attr(r, "alt", (v = k[5].identifier));
    },
    m($, S) {
      insert($, r, S);
    },
    p($, S) {
      S & 2 && !src_url_equal(r.src, (p = $[5].image)) && attr(r, "src", p),
        S & 2 && v !== (v = $[5].identifier) && attr(r, "alt", v);
    },
    d($) {
      $ && detach(r);
    },
  };
}
function create_if_block$v(k) {
  let r,
    p = k[5].icon + "",
    v;
  return {
    c() {
      (r = element("span")),
        (v = text(p)),
        attr(r, "class", "material-icons-round");
    },
    m($, S) {
      insert($, r, S), append(r, v);
    },
    p($, S) {
      S & 2 && p !== (p = $[5].icon + "") && set_data(v, p);
    },
    d($) {
      $ && detach(r);
    },
  };
}
function create_each_block$g(k) {
  let r, p, v;
  function $(F, O) {
    return F[5].icon ? create_if_block$v : create_else_block$9;
  }
  let S = $(k),
    x = S(k);
  function I() {
    return k[4](k[5]);
  }
  return {
    c() {
      (r = element("button")), x.c(), attr(r, "class", "icon");
    },
    m(F, O) {
      insert(F, r, O),
        x.m(r, null),
        p || ((v = listen(r, "click", I)), (p = !0));
    },
    p(F, O) {
      (k = F),
        S === (S = $(k)) && x
          ? x.p(k, O)
          : (x.d(1), (x = S(k)), x && (x.c(), x.m(r, null)));
    },
    d(F) {
      F && detach(r), x.d(), (p = !1), v();
    },
  };
}
function create_fragment$1c(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L,
    U,
    j,
    N = k[1],
    q = [];
  for (let R = 0; R < N.length; R += 1)
    q[R] = create_each_block$g(get_each_context$g(k, N, R));
  return {
    c() {
      r = element("div");
      for (let R = 0; R < q.length; R += 1) q[R].c();
      (p = space()),
        (v = element("button")),
        ($ = element("img")),
        (x = space()),
        (I = element("div")),
        (F = text(k[0])),
        (O = space()),
        (L = element("button")),
        (L.textContent = "notifications"),
        src_url_equal($.src, (S = upload)) || attr($, "src", S),
        attr($, "alt", "Committing"),
        attr(v, "class", "icon committer"),
        toggle_class(v, "inactive", !k[2]),
        attr(I, "class", "clock"),
        attr(L, "class", "material-icons-round ac-open"),
        toggle_class(L, "opened", k[3]),
        attr(r, "class", "tray");
    },
    m(R, Q) {
      insert(R, r, Q);
      for (let H = 0; H < q.length; H += 1) q[H] && q[H].m(r, null);
      append(r, p),
        append(r, v),
        append(v, $),
        append(r, x),
        append(r, I),
        append(I, F),
        append(r, O),
        append(r, L),
        U || ((j = listen(L, "click", toggleActionCenter)), (U = !0));
    },
    p(R, [Q]) {
      if (Q & 2) {
        N = R[1];
        let H;
        for (H = 0; H < N.length; H += 1) {
          const G = get_each_context$g(R, N, H);
          q[H]
            ? q[H].p(G, Q)
            : ((q[H] = create_each_block$g(G)), q[H].c(), q[H].m(r, p));
        }
        for (; H < q.length; H += 1) q[H].d(1);
        q.length = N.length;
      }
      Q & 4 && toggle_class(v, "inactive", !R[2]),
        Q & 1 && set_data(F, R[0]),
        Q & 8 && toggle_class(L, "opened", R[3]);
    },
    i: noop$1,
    o: noop$1,
    d(R) {
      R && detach(r), destroy_each(q, R), (U = !1), j();
    },
  };
}
function instance$17(k, r, p) {
  let v, $, S;
  component_subscribe(k, trayIcons, (F) => p(1, (v = F))),
    component_subscribe(k, committingUserData, (F) => p(2, ($ = F))),
    component_subscribe(k, ActionCenterOpened, (F) => p(3, (S = F)));
  let x = "";
  return (
    onMount(() => {
      setInterval(() => {
        p(0, (x = dayjs().format("HH:mm")));
      });
    }),
    [x, v, $, S, (F) => F.onOpen(F)]
  );
}
class Tray extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$17, create_fragment$1c, safe_not_equal, {});
  }
}
const TaskbarContent_svelte_svelte_type_style_lang = "";
function get_each_context$f(k, r, p) {
  const v = k.slice();
  return (v[2] = r[p]), v;
}
function create_if_block_1$8(k) {
  let r, p;
  return (
    (r = new TaskbarButton({ props: { app: k[2] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 2 && (S.app = v[2]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$f(k) {
  let r,
    p,
    v = !k[2].disabled && create_if_block_1$8(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, S) {
      $[2].disabled
        ? v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros())
        : v
        ? (v.p($, S), S & 2 && transition_in(v, 1))
        : ((v = create_if_block_1$8($)),
          v.c(),
          transition_in(v, 1),
          v.m(r.parentNode, r));
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function create_else_block$8(k) {
  let r, p, v;
  return (
    (p = new Spinner({ props: { height: 24 } })),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          attr(r, "class", "tray svelte-1vsr6ui");
      },
      m($, S) {
        insert($, r, S), mount_component(p, r, null), (v = !0);
      },
      i($) {
        v || (transition_in(p.$$.fragment, $), (v = !0));
      },
      o($) {
        transition_out(p.$$.fragment, $), (v = !1);
      },
      d($) {
        $ && detach(r), destroy_component(p);
      },
    }
  );
}
function create_if_block$u(k) {
  let r, p;
  return (
    (r = new Tray({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1b(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I = k[1],
    F = [];
  for (let N = 0; N < I.length; N += 1)
    F[N] = create_each_block$f(get_each_context$f(k, I, N));
  const O = (N) =>
      transition_out(F[N], 1, 1, () => {
        F[N] = null;
      }),
    L = [create_if_block$u, create_else_block$8],
    U = [];
  function j(N, q) {
    return N[0] ? 0 : 1;
  }
  return (
    (v = j(k)),
    ($ = U[v] = L[v](k)),
    {
      c() {
        r = element("div");
        for (let N = 0; N < F.length; N += 1) F[N].c();
        (p = space()), $.c(), (S = empty()), attr(r, "class", "buttons");
      },
      m(N, q) {
        insert(N, r, q);
        for (let R = 0; R < F.length; R += 1) F[R] && F[R].m(r, null);
        insert(N, p, q), U[v].m(N, q), insert(N, S, q), (x = !0);
      },
      p(N, [q]) {
        if (q & 2) {
          I = N[1];
          let Q;
          for (Q = 0; Q < I.length; Q += 1) {
            const H = get_each_context$f(N, I, Q);
            F[Q]
              ? (F[Q].p(H, q), transition_in(F[Q], 1))
              : ((F[Q] = create_each_block$f(H)),
                F[Q].c(),
                transition_in(F[Q], 1),
                F[Q].m(r, null));
          }
          for (group_outros(), Q = I.length; Q < F.length; Q += 1) O(Q);
          check_outros();
        }
        let R = v;
        (v = j(N)),
          v !== R &&
            (group_outros(),
            transition_out(U[R], 1, 1, () => {
              U[R] = null;
            }),
            check_outros(),
            ($ = U[v]),
            $ || (($ = U[v] = L[v](N)), $.c()),
            transition_in($, 1),
            $.m(S.parentNode, S));
      },
      i(N) {
        if (!x) {
          for (let q = 0; q < I.length; q += 1) transition_in(F[q]);
          transition_in($), (x = !0);
        }
      },
      o(N) {
        F = F.filter(Boolean);
        for (let q = 0; q < F.length; q += 1) transition_out(F[q]);
        transition_out($), (x = !1);
      },
      d(N) {
        N && detach(r),
          destroy_each(F, N),
          N && detach(p),
          U[v].d(N),
          N && detach(S);
      },
    }
  );
}
function instance$16(k, r, p) {
  let v = !1,
    $ = [];
  return (
    WindowStore.subscribe(() => {
      p(1, ($ = getOpenedStore()));
    }),
    onMount(() => {
      p(0, (v = !1)),
        setTimeout(() => {
          p(0, (v = !0));
        }, 3e3);
    }),
    [v, $]
  );
}
class TaskbarContent extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$16, create_fragment$1b, safe_not_equal, {});
  }
}
function create_fragment$1a(k) {
  let r, p, v, $;
  const S = k[4].default,
    x = create_slot(S, k, k[3], null);
  return (
    (v = new TaskbarContent({})),
    {
      c() {
        (r = element("div")),
          x && x.c(),
          (p = space()),
          create_component(v.$$.fragment),
          attr(r, "class", "taskbar-h newtb"),
          set_style(r, "z-index", k[0] + 3),
          attr(r, "data-caller", "shell-taskbar"),
          toggle_class(r, "docked", k[1].sh.taskbar.docked),
          toggle_class(r, "centered", k[1].sh.taskbar.centered),
          toggle_class(r, "colored", k[1].sh.taskbar.colored),
          toggle_class(r, "visible", k[1].sh.taskbar.pos == "" && !k[2]);
      },
      m(I, F) {
        insert(I, r, F),
          x && x.m(r, null),
          append(r, p),
          mount_component(v, r, null),
          ($ = !0);
      },
      p(I, [F]) {
        x &&
          x.p &&
          (!$ || F & 8) &&
          update_slot_base(
            x,
            S,
            I,
            I[3],
            $
              ? get_slot_changes(S, I[3], F, null)
              : get_all_dirty_from_scope(I[3]),
            null
          ),
          (!$ || F & 1) && set_style(r, "z-index", I[0] + 3),
          (!$ || F & 2) && toggle_class(r, "docked", I[1].sh.taskbar.docked),
          (!$ || F & 2) &&
            toggle_class(r, "centered", I[1].sh.taskbar.centered),
          (!$ || F & 2) && toggle_class(r, "colored", I[1].sh.taskbar.colored),
          (!$ || F & 6) &&
            toggle_class(r, "visible", I[1].sh.taskbar.pos == "" && !I[2]);
      },
      i(I) {
        $ || (transition_in(x, I), transition_in(v.$$.fragment, I), ($ = !0));
      },
      o(I) {
        transition_out(x, I), transition_out(v.$$.fragment, I), ($ = !1);
      },
      d(I) {
        I && detach(r), x && x.d(I), destroy_component(v);
      },
    }
  );
}
function instance$15(k, r, p) {
  let v, $, S;
  component_subscribe(k, maxZIndex, (F) => p(0, (v = F))),
    component_subscribe(k, UserData, (F) => p(1, ($ = F))),
    component_subscribe(k, isFullscreenWindow, (F) => p(2, (S = F)));
  let { $$slots: x = {}, $$scope: I } = r;
  return (
    (k.$$set = (F) => {
      "$$scope" in F && p(3, (I = F.$$scope));
    }),
    [v, $, S, I, x]
  );
}
class HorizontalTaskbar extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$15, create_fragment$1a, safe_not_equal, {});
  }
}
function create_fragment$19(k) {
  let r, p, v, $;
  const S = k[4].default,
    x = create_slot(S, k, k[3], null);
  return (
    (v = new TaskbarContent({})),
    {
      c() {
        (r = element("div")),
          x && x.c(),
          (p = space()),
          create_component(v.$$.fragment),
          attr(r, "class", "taskbar-v newtb"),
          set_style(r, "z-index", k[0] + 3),
          attr(r, "data-caller", "shell-taskbar"),
          toggle_class(r, "docked", k[1].sh.taskbar.docked),
          toggle_class(r, "centered", k[1].sh.taskbar.centered),
          toggle_class(r, "colored", k[1].sh.taskbar.colored),
          toggle_class(r, "visible", k[1].sh.taskbar.pos != ""),
          toggle_class(
            r,
            "right",
            k[1].sh.taskbar.pos == "vertical-right" && !k[2]
          );
      },
      m(I, F) {
        insert(I, r, F),
          x && x.m(r, null),
          append(r, p),
          mount_component(v, r, null),
          ($ = !0);
      },
      p(I, [F]) {
        x &&
          x.p &&
          (!$ || F & 8) &&
          update_slot_base(
            x,
            S,
            I,
            I[3],
            $
              ? get_slot_changes(S, I[3], F, null)
              : get_all_dirty_from_scope(I[3]),
            null
          ),
          (!$ || F & 1) && set_style(r, "z-index", I[0] + 3),
          (!$ || F & 2) && toggle_class(r, "docked", I[1].sh.taskbar.docked),
          (!$ || F & 2) &&
            toggle_class(r, "centered", I[1].sh.taskbar.centered),
          (!$ || F & 2) && toggle_class(r, "colored", I[1].sh.taskbar.colored),
          (!$ || F & 2) &&
            toggle_class(r, "visible", I[1].sh.taskbar.pos != ""),
          (!$ || F & 6) &&
            toggle_class(
              r,
              "right",
              I[1].sh.taskbar.pos == "vertical-right" && !I[2]
            );
      },
      i(I) {
        $ || (transition_in(x, I), transition_in(v.$$.fragment, I), ($ = !0));
      },
      o(I) {
        transition_out(x, I), transition_out(v.$$.fragment, I), ($ = !1);
      },
      d(I) {
        I && detach(r), x && x.d(I), destroy_component(v);
      },
    }
  );
}
function instance$14(k, r, p) {
  let v, $, S;
  component_subscribe(k, maxZIndex, (F) => p(0, (v = F))),
    component_subscribe(k, UserData, (F) => p(1, ($ = F))),
    component_subscribe(k, isFullscreenWindow, (F) => p(2, (S = F)));
  let { $$slots: x = {}, $$scope: I } = r;
  return (
    (k.$$set = (F) => {
      "$$scope" in F && p(3, (I = F.$$scope));
    }),
    [v, $, S, I, x]
  );
}
class VerticalTaskbar extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$14, create_fragment$19, safe_not_equal, {});
  }
}
function create_fragment$18(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H;
  return (
    (v = new ProfilePicture$1({ props: { src: k[0], height: 21 } })),
    {
      c() {
        (r = element("div")),
          (p = element("h1")),
          create_component(v.$$.fragment),
          ($ = space()),
          (S = text(k[1])),
          (x = space()),
          (I = element("div")),
          (F = element("button")),
          (F.textContent = "search"),
          (O = space()),
          (L = element("button")),
          (L.textContent = "settings"),
          (U = space()),
          (j = element("div")),
          (N = space()),
          (q = element("button")),
          (q.textContent = "power_settings_new"),
          attr(p, "class", "username"),
          attr(F, "class", "material-icons-round"),
          attr(F, "title", "Search (Alt+Shift+S)"),
          attr(L, "class", "material-icons-round"),
          attr(j, "class", "sep"),
          attr(q, "class", "material-icons-round"),
          attr(I, "class", "options"),
          attr(r, "class", "bottom");
      },
      m(G, V) {
        insert(G, r, V),
          append(r, p),
          mount_component(v, p, null),
          append(p, $),
          append(p, S),
          append(r, x),
          append(r, I),
          append(I, F),
          append(I, O),
          append(I, L),
          append(I, U),
          append(I, j),
          append(I, N),
          append(I, q),
          (R = !0),
          Q ||
            ((H = [
              listen(F, "click", k[4]),
              listen(L, "click", k[3]),
              listen(q, "click", k[2]),
            ]),
            (Q = !0));
      },
      p(G, [V]) {
        const K = {};
        V & 1 && (K.src = G[0]), v.$set(K), (!R || V & 2) && set_data(S, G[1]);
      },
      i(G) {
        R || (transition_in(v.$$.fragment, G), (R = !0));
      },
      o(G) {
        transition_out(v.$$.fragment, G), (R = !1);
      },
      d(G) {
        G && detach(r), destroy_component(v), (Q = !1), run_all(H);
      },
    }
  );
}
function instance$13(k, r, p) {
  let v, $;
  component_subscribe(k, UserData, (O) => p(5, (v = O))),
    component_subscribe(k, UserName, (O) => p(1, ($ = O)));
  let S;
  function x() {
    openWindow("Exit"), startOpened.set(!1);
  }
  function I() {
    openWindow("SettingsApp"), startOpened.set(!1);
  }
  function F() {
    showArcFind.set(!0), startOpened.set(!1);
  }
  return (
    UserData.subscribe(() => {
      p(0, (S = getProfilePicture(v.acc.profilePicture)));
    }),
    [S, $, x, I, F]
  );
}
class BottomPane extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$13, create_fragment$18, safe_not_equal, {});
  }
}
function create_fragment$17(k) {
  let r, p, v;
  return {
    c() {
      (r = element("div")),
        attr(r, "class", "startframe fullscreen"),
        set_style(r, "z-index", k[1] + 1),
        toggle_class(r, "present", k[0]);
    },
    m($, S) {
      insert($, r, S), p || ((v = listen(r, "click", k[2])), (p = !0));
    },
    p($, [S]) {
      S & 2 && set_style(r, "z-index", $[1] + 1),
        S & 1 && toggle_class(r, "present", $[0]);
    },
    i: noop$1,
    o: noop$1,
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function instance$12(k, r, p) {
  let v, $;
  component_subscribe(k, startOpened, (x) => p(0, (v = x))),
    component_subscribe(k, maxZIndex, (x) => p(1, ($ = x)));
  function S() {
    set_store_value(startOpened, (v = !1), v);
  }
  return [v, $, S];
}
class Frame extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$12, create_fragment$17, safe_not_equal, {});
  }
}
function create_fragment$16(k) {
  let r,
    p,
    v,
    $,
    S,
    x = k[0].info.name + "",
    I,
    F,
    O,
    L;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (S = space()),
        (I = text(x)),
        src_url_equal(
          p.src,
          (v = getOriginalIcon(k[0].id) || getAppIcon(k[0]))
        ) || attr(p, "src", v),
        attr(p, "class", "icon"),
        attr(p, "alt", ($ = k[0].info.name)),
        attr(r, "class", "item"),
        (r.disabled = F = k[0].opened);
    },
    m(U, j) {
      insert(U, r, j),
        append(r, p),
        append(r, S),
        append(r, I),
        O || ((L = listen(r, "click", k[1])), (O = !0));
    },
    p(U, [j]) {
      j & 1 &&
        !src_url_equal(
          p.src,
          (v = getOriginalIcon(U[0].id) || getAppIcon(U[0]))
        ) &&
        attr(p, "src", v),
        j & 1 && $ !== ($ = U[0].info.name) && attr(p, "alt", $),
        j & 1 && x !== (x = U[0].info.name + "") && set_data(I, x),
        j & 1 && F !== (F = U[0].opened) && (r.disabled = F);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r), (O = !1), L();
    },
  };
}
function instance$11(k, r, p) {
  let { app: v } = r;
  function $() {
    openWindow(v.id), updateStores(), startOpened.set(!1);
  }
  return (
    (k.$$set = (S) => {
      "app" in S && p(0, (v = S.app));
    }),
    [v, $]
  );
}
class AppListItem extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$11, create_fragment$16, safe_not_equal, {
        app: 0,
      });
  }
}
function get_each_context$e(k, r, p) {
  const v = k.slice();
  return (v[1] = r[p]), v;
}
function create_if_block$t(k) {
  let r, p;
  return (
    (r = new AppListItem({ props: { app: k[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.app = v[1]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$e(k) {
  let r = isPopulatable(k[1]),
    p,
    v,
    $ = r && create_if_block$t(k);
  return {
    c() {
      $ && $.c(), (p = empty());
    },
    m(S, x) {
      $ && $.m(S, x), insert(S, p, x), (v = !0);
    },
    p(S, x) {
      x & 1 && (r = isPopulatable(S[1])),
        r
          ? $
            ? ($.p(S, x), x & 1 && transition_in($, 1))
            : (($ = create_if_block$t(S)),
              $.c(),
              transition_in($, 1),
              $.m(p.parentNode, p))
          : $ &&
            (group_outros(),
            transition_out($, 1, 1, () => {
              $ = null;
            }),
            check_outros());
    },
    i(S) {
      v || (transition_in($), (v = !0));
    },
    o(S) {
      transition_out($), (v = !1);
    },
    d(S) {
      $ && $.d(S), S && detach(p);
    },
  };
}
function create_fragment$15(k) {
  let r,
    p,
    v = k[0],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$e(get_each_context$e(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      r = element("div");
      for (let x = 0; x < $.length; x += 1) $[x].c();
      attr(r, "class", "left");
    },
    m(x, I) {
      insert(x, r, I);
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(r, null);
      p = !0;
    },
    p(x, [I]) {
      if (I & 1) {
        v = x[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$e(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$e(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      x && detach(r), destroy_each($, x);
    },
  };
}
function instance$10(k, r, p) {
  let v;
  return component_subscribe(k, WindowStore, ($) => p(0, (v = $))), [v];
}
class LeftPane extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$10, create_fragment$15, safe_not_equal, {});
  }
}
function create_fragment$14(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F = k[0].name + "",
    O,
    L,
    U;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (I = element("div")),
        (O = text(F)),
        src_url_equal(v.src, ($ = folder)) || attr(v, "src", $),
        attr(v, "alt", (S = k[0].name)),
        attr(p, "class", "image"),
        attr(I, "class", "caption"),
        attr(r, "class", "link dir");
    },
    m(j, N) {
      insert(j, r, N),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, I),
        append(I, O),
        L || ((U = listen(r, "click", k[1])), (L = !0));
    },
    p(j, [N]) {
      N & 1 && S !== (S = j[0].name) && attr(v, "alt", S),
        N & 1 && F !== (F = j[0].name + "") && set_data(O, F);
    },
    i: noop$1,
    o: noop$1,
    d(j) {
      j && detach(r), (L = !1), U();
    },
  };
}
function instance$$(k, r, p) {
  let { dir: v } = r;
  function $() {
    startOpened.set(!1),
      openWindow("FileManager"),
      setTimeout(() => {
        fbClass.goToDirectory(v.scopedPath);
      });
  }
  return (
    (k.$$set = (S) => {
      "dir" in S && p(0, (v = S.dir));
    }),
    [v, $]
  );
}
class DirLink extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$$, create_fragment$14, safe_not_equal, { dir: 0 });
  }
}
function get_each_context$d(k, r, p) {
  const v = k.slice();
  return (v[1] = r[p]), v;
}
function create_each_block$d(k) {
  let r, p;
  return (
    (r = new DirLink({ props: { dir: k[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.dir = v[1]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$13(k) {
  let r,
    p,
    v = k[0],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$d(get_each_context$d(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      r = element("div");
      for (let x = 0; x < $.length; x += 1) $[x].c();
      attr(r, "class", "right");
    },
    m(x, I) {
      insert(x, r, I);
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(r, null);
      p = !0;
    },
    p(x, [I]) {
      if (I & 1) {
        v = x[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$d(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$d(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      x && detach(r), destroy_each($, x);
    },
  };
}
function instance$_(k, r, p) {
  let v = [];
  return (
    FileBrowserDirContents.subscribe(async () => {
      p(0, (v = (await getDirectory("./")).directories));
    }),
    [v]
  );
}
class RightPane extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$_, create_fragment$13, safe_not_equal, {});
  }
}
function create_if_block$s(k) {
  let r, p, v, $, S, x, I, F, O;
  return (
    (r = new Frame({})),
    ($ = new LeftPane({})),
    (x = new RightPane({})),
    (F = new BottomPane({})),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          (v = element("div")),
          create_component($.$$.fragment),
          (S = space()),
          create_component(x.$$.fragment),
          (I = space()),
          create_component(F.$$.fragment),
          attr(v, "class", "startmenu"),
          set_style(v, "z-index", k[1] + 2),
          toggle_class(v, "open", k[2]),
          toggle_class(v, "small", k[0].sh.start.small),
          toggle_class(v, "colored", k[0].sh.taskbar.colored);
      },
      m(L, U) {
        mount_component(r, L, U),
          insert(L, p, U),
          insert(L, v, U),
          mount_component($, v, null),
          append(v, S),
          mount_component(x, v, null),
          append(v, I),
          mount_component(F, v, null),
          (O = !0);
      },
      p(L, U) {
        (!O || U & 2) && set_style(v, "z-index", L[1] + 2),
          (!O || U & 4) && toggle_class(v, "open", L[2]),
          (!O || U & 1) && toggle_class(v, "small", L[0].sh.start.small),
          (!O || U & 1) && toggle_class(v, "colored", L[0].sh.taskbar.colored);
      },
      i(L) {
        O ||
          (transition_in(r.$$.fragment, L),
          transition_in($.$$.fragment, L),
          transition_in(x.$$.fragment, L),
          transition_in(F.$$.fragment, L),
          (O = !0));
      },
      o(L) {
        transition_out(r.$$.fragment, L),
          transition_out($.$$.fragment, L),
          transition_out(x.$$.fragment, L),
          transition_out(F.$$.fragment, L),
          (O = !1);
      },
      d(L) {
        destroy_component(r, L),
          L && detach(p),
          L && detach(v),
          destroy_component($),
          destroy_component(x),
          destroy_component(F);
      },
    }
  );
}
function create_fragment$12(k) {
  let r,
    p,
    v = k[0] && create_if_block$s(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, [S]) {
      $[0]
        ? v
          ? (v.p($, S), S & 1 && transition_in(v, 1))
          : ((v = create_if_block$s($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function instance$Z(k, r, p) {
  let v, $, S;
  return (
    component_subscribe(k, UserData, (x) => p(0, (v = x))),
    component_subscribe(k, maxZIndex, (x) => p(1, ($ = x))),
    component_subscribe(k, startOpened, (x) => p(2, (S = x))),
    [v, $, S]
  );
}
class StartMenu extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$Z, create_fragment$12, safe_not_equal, {});
  }
}
function create_fragment$11(k) {
  let r, p, v, $, S;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        src_url_equal(p.src, (v = logo$c)) || attr(p, "src", v),
        attr(p, "alt", "ArcOS Logo"),
        attr(r, "class", "start"),
        toggle_class(r, "open", k[0]);
    },
    m(x, I) {
      insert(x, r, I),
        append(r, p),
        $ || ((S = listen(r, "click", k[1])), ($ = !0));
    },
    p(x, [I]) {
      I & 1 && toggle_class(r, "open", x[0]);
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r), ($ = !1), S();
    },
  };
}
function instance$Y(k, r, p) {
  let v;
  component_subscribe(k, startOpened, (S) => p(0, (v = S)));
  function $() {
    set_store_value(startOpened, (v = !v), v);
  }
  return [v, $];
}
class StartButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$Y, create_fragment$11, safe_not_equal, {});
  }
}
function create_default_slot_1$2(k) {
  let r, p;
  return (
    (r = new StartButton({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_default_slot$5(k) {
  let r, p;
  return (
    (r = new StartButton({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$10(k) {
  let r, p, v, $, S, x, I, F;
  return (
    (r = new StartMenu({})),
    (v = new HorizontalTaskbar({
      props: {
        $$slots: { default: [create_default_slot_1$2] },
        $$scope: { ctx: k },
      },
    })),
    (S = new VerticalTaskbar({
      props: {
        $$slots: { default: [create_default_slot$5] },
        $$scope: { ctx: k },
      },
    })),
    (I = new ActionCenter({})),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          create_component(v.$$.fragment),
          ($ = space()),
          create_component(S.$$.fragment),
          (x = space()),
          create_component(I.$$.fragment);
      },
      m(O, L) {
        mount_component(r, O, L),
          insert(O, p, L),
          mount_component(v, O, L),
          insert(O, $, L),
          mount_component(S, O, L),
          insert(O, x, L),
          mount_component(I, O, L),
          (F = !0);
      },
      p(O, [L]) {
        const U = {};
        L & 4 && (U.$$scope = { dirty: L, ctx: O }), v.$set(U);
        const j = {};
        L & 4 && (j.$$scope = { dirty: L, ctx: O }), S.$set(j);
      },
      i(O) {
        F ||
          (transition_in(r.$$.fragment, O),
          transition_in(v.$$.fragment, O),
          transition_in(S.$$.fragment, O),
          transition_in(I.$$.fragment, O),
          (F = !0));
      },
      o(O) {
        transition_out(r.$$.fragment, O),
          transition_out(v.$$.fragment, O),
          transition_out(S.$$.fragment, O),
          transition_out(I.$$.fragment, O),
          (F = !1);
      },
      d(O) {
        destroy_component(r, O),
          O && detach(p),
          destroy_component(v, O),
          O && detach($),
          destroy_component(S, O),
          O && detach(x),
          destroy_component(I, O);
      },
    }
  );
}
function instance$X(k, r, p) {
  return component_subscribe(k, startOpened, (v) => p(0, v)), [];
}
let Shell$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$X, create_fragment$10, safe_not_equal, {});
  }
};
const ArcShell = {
    info: {
      name: "ArcShell",
      description: "The ArcOS Shell",
      builtin: !0,
      version: ArcOSVersion,
      author: "ArcOS Team",
      icon: logo$c,
      custom: !0,
    },
    size: { w: NaN, h: NaN },
    pos: { x: 0, y: 0 },
    minSize: { w: NaN, h: NaN },
    maxSize: { w: NaN, h: NaN },
    controls: { min: !1, max: !1, cls: !1 },
    state: {
      headless: !0,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !0 },
    },
    content: Shell$1,
    glass: !1,
    events: {},
    disabledWarning: {
      title: "Limited functionality",
      message:
        "The ArcOS Shell is disabled, rendering the taskbar, start menu and action center unusable.<br><br>You can still access ArcFind using <b>Alt+Shift+S</b> or the Application Manager using <b>Alt+Shift+Z</b>.",
    },
    contextMenu: {
      "shell-taskbar": [
        {
          caption: "Application Manager",
          action: () => {
            openWindow("AppMan");
          },
        },
        SEP_ITEM,
        {
          icon: "settings",
          caption: "Shell settings",
          action: () => {
            openWindow("SettingsApp"),
              setTimeout(() => {
                openByKey("Shell");
              });
          },
        },
      ],
    },
  },
  TextEditor = {
    info: {
      name: "Text Editor",
      description: "Edit plain text files",
      builtin: !0,
      version: "1.0.0",
      author: "Izaak Kuipers",
      hidden: !1,
      icon: logo$9,
    },
    size: { w: 700, h: 550 },
    pos: { x: 30, y: 40, centered: !0 },
    minSize: { w: 400, h: 300 },
    maxSize: { w: 1e3, h: 800 },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: TextView,
    glass: !0,
    fileMimes: ["text/plain; charset=utf-8"],
  },
  snapzones = "",
  draggingId = writable(),
  leftZoneTriggered = writable(!1),
  rightZoneTriggered = writable(!1);
function create_fragment$$(k) {
  let r, p, v, $;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = space()),
        ($ = element("div")),
        attr(p, "class", "visualizer"),
        attr(p, "id", "snapZoneLeft"),
        toggle_class(p, "triggered", k[0]),
        attr($, "class", "trigger"),
        attr($, "id", "snapTriggerLeft"),
        attr(r, "class", "leftzone");
    },
    m(S, x) {
      insert(S, r, x), append(r, p), append(r, v), append(r, $);
    },
    p(S, [x]) {
      x & 1 && toggle_class(p, "triggered", S[0]);
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r);
    },
  };
}
function instance$W(k, r, p) {
  let v;
  return component_subscribe(k, leftZoneTriggered, ($) => p(0, (v = $))), [v];
}
class LeftZone extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$W, create_fragment$$, safe_not_equal, {});
  }
}
function create_fragment$_(k) {
  let r, p, v, $;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = space()),
        ($ = element("div")),
        attr(p, "class", "visualizer"),
        attr(p, "id", "snapZoneRight"),
        toggle_class(p, "triggered", k[0]),
        attr($, "class", "trigger"),
        attr($, "id", "snapTriggerRight"),
        attr(r, "class", "rightzone");
    },
    m(S, x) {
      insert(S, r, x), append(r, p), append(r, v), append(r, $);
    },
    p(S, [x]) {
      x & 1 && toggle_class(p, "triggered", S[0]);
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r);
    },
  };
}
function instance$V(k, r, p) {
  let v;
  return component_subscribe(k, rightZoneTriggered, ($) => p(0, (v = $))), [v];
}
class RightZone extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$V, create_fragment$_, safe_not_equal, {});
  }
}
function create_fragment$Z(k) {
  let r, p, v, $, S;
  return (
    (p = new LeftZone({})),
    ($ = new RightZone({})),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          create_component($.$$.fragment),
          attr(r, "class", "snapzones"),
          set_style(r, "z-index", k[1] + 5),
          toggle_class(r, "docked", k[0].sh.taskbar.docked);
      },
      m(x, I) {
        insert(x, r, I),
          mount_component(p, r, null),
          append(r, v),
          mount_component($, r, null),
          (S = !0);
      },
      p(x, [I]) {
        (!S || I & 2) && set_style(r, "z-index", x[1] + 5),
          (!S || I & 1) && toggle_class(r, "docked", x[0].sh.taskbar.docked);
      },
      i(x) {
        S ||
          (transition_in(p.$$.fragment, x),
          transition_in($.$$.fragment, x),
          (S = !0));
      },
      o(x) {
        transition_out(p.$$.fragment, x),
          transition_out($.$$.fragment, x),
          (S = !1);
      },
      d(x) {
        x && detach(r), destroy_component(p), destroy_component($);
      },
    }
  );
}
function instance$U(k, r, p) {
  let v, $;
  return (
    component_subscribe(k, UserData, (S) => p(0, (v = S))),
    component_subscribe(k, maxZIndex, (S) => p(1, ($ = S))),
    [v, $]
  );
}
class SnapZones extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$U, create_fragment$Z, safe_not_equal, {});
  }
}
function create_fragment$Y(k) {
  let r, p, v, $, S;
  return (
    (p = new DesktopIcons({})),
    ($ = new SnapZones({})),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          create_component($.$$.fragment),
          attr(r, "class", "wallpaper fullscreen"),
          set_style(
            r,
            "background-image",
            "url(" + getWallpaper(k[0].sh.desktop.wallpaper) + ")"
          ),
          attr(r, "data-caller", "shell-wallpaper");
      },
      m(x, I) {
        insert(x, r, I),
          mount_component(p, r, null),
          insert(x, v, I),
          mount_component($, x, I),
          (S = !0);
      },
      p(x, [I]) {
        (!S || I & 1) &&
          set_style(
            r,
            "background-image",
            "url(" + getWallpaper(x[0].sh.desktop.wallpaper) + ")"
          );
      },
      i(x) {
        S ||
          (transition_in(p.$$.fragment, x),
          transition_in($.$$.fragment, x),
          (S = !0));
      },
      o(x) {
        transition_out(p.$$.fragment, x),
          transition_out($.$$.fragment, x),
          (S = !1);
      },
      d(x) {
        x && detach(r),
          destroy_component(p),
          x && detach(v),
          destroy_component($, x);
      },
    }
  );
}
function instance$T(k, r, p) {
  let v;
  return component_subscribe(k, UserData, ($) => p(0, (v = $))), [v];
}
class Wallpaper extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$T, create_fragment$Y, safe_not_equal, {});
  }
}
const DesktopWallpaper = {
  info: {
    name: "Wallpaper",
    description: "The ArcOS wallpaper",
    builtin: !0,
    version: ArcOSVersion,
    author: "ArcOS Team",
    icon: desktopIcon,
    custom: !0,
  },
  size: { w: NaN, h: NaN },
  pos: { x: 0, y: 0 },
  minSize: { w: NaN, h: NaN },
  maxSize: { w: NaN, h: NaN },
  controls: { min: !1, max: !1, cls: !1 },
  state: {
    headless: !0,
    resizable: !1,
    windowState: { min: !1, max: !1, fll: !0 },
  },
  content: Wallpaper,
  glass: !1,
  events: {},
  contextMenu: {
    "shell-wallpaper": [
      {
        caption: "Toggle desktop icons",
        action: () => {
          const k = get_store_value(UserData);
          (k.sh.desktop.icons = !k.sh.desktop.icons), UserData.set(k);
        },
        icon: "apps",
      },
      SEP_ITEM,
      {
        caption: "File Manager",
        action: () => {
          openWindow("FileManager");
        },
        icon: "folder",
      },
      {
        caption: "Application Manager",
        action: () => {
          openWindow("AppMan");
        },
        icon: "widgets",
      },
      {
        caption: "App settings",
        action: () => {
          openByKey("Apps");
        },
        icon: "settings",
      },
      SEP_ITEM,
      { caption: "Shut down", action: shutdown, icon: "power_settings_new" },
      { caption: "Restart", action: restart, icon: "refresh" },
      SEP_ITEM,
      {
        caption: "Personalize",
        action: () => {
          openByKey("Appearance");
        },
        icon: "palette",
      },
    ],
  },
};
function generateCSS(k, r) {
  let p = "";
  return (
    (p += `min-width: ${k.minSize.w}px;`),
    (p += `min-height: ${k.minSize.h}px;`),
    (p += `max-width: ${k.maxSize.w}px;`),
    (p += `max-height: ${k.maxSize.h}px;`),
    r && ((p += `left: ${k.pos.x}px;`), (p += `top: ${k.pos.y}px;`)),
    (p += `width: ${k.size.w}px;`),
    (p += `height: ${k.size.h}px;`),
    p
  );
}
function generateOverlayCSS(k) {
  let r = "";
  return (
    (r += `min-width: ${k.size.w}px;`),
    (r += `min-height: ${k.size.h}px;`),
    (r += `max-width: ${k.size.w}px;`),
    (r += `max-height: ${k.size.h}px;`),
    (r += `width: ${k.size.w}px;`),
    (r += `height: ${k.size.h}px;`),
    r
  );
}
function centerWindow(k) {
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++)
    r[p].id == k && ((r[p].pos = calculatePos(r[p])), WindowStore.set(r));
}
function calculatePos(k) {
  const r = getWindowElement(k),
    p = r.offsetWidth,
    v = r.offsetHeight,
    $ = document.body.offsetWidth,
    S = document.body.offsetHeight,
    x = ($ - p) / 2,
    I = (S - v) / 2;
  return (
    (r.style.left = `${x}px`),
    (r.style.top = `${I}px`),
    { x, y: I, centered: !0 }
  );
}
function loadWindow(k, r) {
  if (isLoaded(k))
    return Log({
      level: LogLevel.error,
      msg: `Window ${k} already exists in WindowStore.`,
      source: "AppLogic: loadWindow",
    });
  const p = get_store_value(WindowStore),
    v = { ...r, id: k },
    $ = [],
    S = Object.entries(v.children || {});
  for (let F = 0; F < S.length; F++)
    $.push({
      ...S[F][1],
      id: S[F][0],
      parentId: k,
      opened: !1,
      info: { ...S[F][1].info, hidden: !0 },
    });
  const x = get_store_value(UserData);
  x.disabledApps || ((x.disabledApps = []), UserData.set(x)),
    x &&
      x.disabledApps.includes(k) &&
      !SystemApps.includes(k) &&
      (v.disabled = !0),
    p.push(v);
  for (let F = 0; F < $.length; F++) p.push($[F]);
  WindowStore.set(p), registerAppShortcuts(k, r);
  const I = get_store_value(UserData).disabledApps;
  r.disabledWarning &&
    I.includes(k) &&
    makeNotification({
      ...r.disabledWarning,
      buttons: [],
      image: r.info.icon,
      timeout: 6e3,
    }),
    setTimeout(() => {
      r.pos.centered && centerWindow(k);
    }, 300),
    Log({
      level: LogLevel.info,
      msg: `Loaded ${k} into WindowStore.`,
      source: "AppLogic: loadWindow",
    });
}
const logo = "./assets/arcterm-b608c3ab.svg",
  arcterm = "",
  AppList = {
    keyword: "applist",
    exec(k, r, p) {
      const v =
        r[0] == "opened" ? getOpenedStore() : get_store_value(WindowStore);
      header(p);
      for (let $ = 0; $ < v.length; $++) output(p, v[$]);
    },
    description: "List all- or opened ArcOS apps.",
    syntax: "([opened?])",
  };
function output(k, r) {
  const p = r.id.padEnd(30, " "),
    v = r.info.name.padEnd(30, " "),
    $ = r.info.version;
  k.util.writeColor(`${v}[${p}]${$}`, "gray");
}
function header(k) {
  const r = "Name".padEnd(30, " "),
    p = "ID".padEnd(30, " "),
    $ = `${r}${p}Version`;
  k.util.writeColor(`[${$}]`, "yellow"), k.util.writeSeperator($.length);
}
function getCPU() {
  return { cores: navigator.hardwareConcurrency || 4 };
}
const GPU_VENDOR_REGEX = /(intel|nvidia|sis|amd|apple|powervr)\W? (.+)/i,
  GPU_RENDERER_REGEX = /(((?:radeon|adreno|geforce|mali).+))/i,
  GPU_CLEANUP_REGEX = / ?(\(.+?\)| direct3d.+| opengl.+|\/.+$| gpu$)/gi;
function getGPU() {
  const k = {
      supported: "WebGLRenderingContext" in globalThis,
      active: !1,
      vendor: void 0,
      model: void 0,
    },
    r = document.createElement("canvas"),
    p =
      r.getContext("webgl2") ||
      r.getContext("webgl") ||
      r.getContext("experimental-webgl");
  if (!p) return k;
  k.active = !0;
  const v = p.getExtension("WEBGL_debug_renderer_info");
  k.vendor = p.getParameter(v.UNMASKED_VENDOR_WEBGL);
  const $ = p.getParameter(v.UNMASKED_RENDERER_WEBGL) ?? "",
    S = $.match(GPU_VENDOR_REGEX),
    x = $.match(GPU_RENDERER_REGEX);
  return (
    S && (k.vendor = S[1]),
    (k.model = x ? x[1] : $),
    (k.model = k.model.replace(GPU_CLEANUP_REGEX, "")),
    k
  );
}
function getMEM() {
  return { kb: (navigator.deviceMemory || 1) * 1024 ** 3 };
}
const defaultNetwork = {
  downlink: 0,
  effectiveType: "0G",
  rtt: 0,
  saveData: !1,
  online: !1,
};
function getNET() {
  const k = navigator.connection;
  return k || defaultNetwork;
}
function getDeviceInfo() {
  return { gpu: getGPU(), cpu: getCPU(), mem: getMEM(), net: getNET() };
}
var u$1 = {};
e(u$1, {
  getName: () => n$1,
  getTauriVersion: () => s$1,
  getVersion: () => i,
  hide: () => t,
  show: () => o$1,
});
async function i() {
  return a$1({ __tauriModule: "App", message: { cmd: "getAppVersion" } });
}
async function n$1() {
  return a$1({ __tauriModule: "App", message: { cmd: "getAppName" } });
}
async function s$1() {
  return a$1({ __tauriModule: "App", message: { cmd: "getTauriVersion" } });
}
async function o$1() {
  return a$1({ __tauriModule: "App", message: { cmd: "show" } });
}
async function t() {
  return a$1({ __tauriModule: "App", message: { cmd: "hide" } });
}
var c = {};
e(c, {
  isRegistered: () => u,
  register: () => s,
  registerAll: () => n,
  unregister: () => a,
  unregisterAll: () => l,
});
async function s(k, r) {
  return a$1({
    __tauriModule: "GlobalShortcut",
    message: { cmd: "register", shortcut: k, handler: s$4(r) },
  });
}
async function n(k, r) {
  return a$1({
    __tauriModule: "GlobalShortcut",
    message: { cmd: "registerAll", shortcuts: k, handler: s$4(r) },
  });
}
async function u(k) {
  return a$1({
    __tauriModule: "GlobalShortcut",
    message: { cmd: "isRegistered", shortcut: k },
  });
}
async function a(k) {
  return a$1({
    __tauriModule: "GlobalShortcut",
    message: { cmd: "unregister", shortcut: k },
  });
}
async function l() {
  return a$1({
    __tauriModule: "GlobalShortcut",
    message: { cmd: "unregisterAll" },
  });
}
async function define() {
  l(),
    s("Ctrl+R", unset),
    s("F5", unset),
    s("Ctrl+Shift+R", unset),
    s("Alt+Enter", async () => {
      const k = await b.isFullscreen();
      await b.setFullscreen(!k);
    });
}
function unset() {
  return !1;
}
async function inTauri() {
  try {
    return !!(await i());
  } catch {
    return !1;
  }
}
const ArcFetch = {
  keyword: "arcfetch",
  async exec(k, r, p) {
    p.util.writeLine(`
`),
      await graphic(p),
      p.util.writeLine(""),
      colorBar(p);
  },
  description: "Show system information",
};
async function getItems() {
  const k = getDeviceInfo(),
    r = await inTauri();
  return Object.entries({
    Server: localStorage.getItem("arcos-server"),
    Username: get_store_value(UserName),
    Processor: `${k.cpu.cores} cores`,
    GPU: `${k.gpu.vendor} ${k.gpu.model}`,
    Memory: `~ ${formatBytes(k.mem.kb)}`,
    Mode:
      (r ? "Desktop" : "Browser") +
      ` (state ${get_store_value(CurrentState).key})`,
  });
}
function colorBar(k) {
  const r = "red,orange,yellow,green,aqua,blue,purple".split(",");
  k.util.write(`
                        `);
  for (let p = 0; p < r.length; p++)
    k.util.writeColor("[ ]", r[p], "white", !0);
}
async function graphic(k) {
  const r = await getItems(),
    p = [
      "    _   ",
      "   /_\\  ",
      "  / _ \\ ",
      " /_/ \\_\\",
      "        ",
      "        ",
    ];
  for (let v = 0; v < p.length; v++)
    k.util.writeColor(`[${p[v]}]  `, "blue", "white", !0),
      r[v] &&
        k.util.writeColor(
          `[${r[v][0].padEnd(12, " ")}]: ${r[v][1]}`,
          "purple",
          "white",
          !0
        ),
      k.util.writeLine("");
}
const ATConf = {
    keyword: "atconf",
    async exec(k, r, p) {
      const v = {
        name: "arcterm.conf",
        path: p.env.config.configPath,
        data: await readFile(p.env.config.configPath),
        mime: "application/json",
      };
      FileLoaders.editFile.loader(v);
    },
    description: "Edit ArcTerm configuration",
  },
  Cd = {
    keyword: "cd",
    async exec(k, r, p) {
      const v = r.join(" "),
        $ = (p.path != "./" ? `${p.path}/${v}` : v).replaceAll("//", "/");
      if (v == "..") {
        p.path = getParentDirectory(p.path);
        return;
      }
      if (v != ".") {
        if (!(await getDirectory($)))
          return p.util.writeLine(`Can't change to "${v}": Path not found`);
        p.path = $;
      }
    },
    description: "Change directory",
    syntax: "[<path>]",
  },
  Clear = {
    keyword: "clear",
    exec(k, r, p) {
      (p.input.current = null),
        setTimeout(() => {
          (p.target.innerText = ""), p.input.unlock();
        });
    },
    description: "Clears the screen",
  },
  Colors = {
    keyword: "colors",
    exec(k, r, p) {
      const v =
          r.join(" ").trim() || "The quick brown fox jumps over the lazy dog.",
        $ = [
          "gray",
          "white",
          "red",
          "orange",
          "yellow",
          "green",
          "aqua",
          "blue",
          "purple",
        ];
      for (let S = 0; S < $.length; S++)
        p.util.writeColor(`${$[S].padEnd(10, " ")}: [${v}]`, $[S]);
    },
    description: "Print out all ArcTerm colors",
    syntax: "([sample?])",
  },
  Dir = {
    keyword: "dir",
    async exec(k, r, p) {
      const v = p.path,
        $ = await getDirectory(v),
        S = $.directories,
        x = $.files;
      let I = 0;
      p.util.writeColor(
        `
Directory contents of [${v}]
`,
        "blue"
      );
      for (let L = 0; L < S.length; L++) {
        const U = S[L].name,
          j = "     <DIR>";
        p.util.writeLine(`${j} ${U}`);
      }
      for (let L = 0; L < x.length; L++) {
        const U = x[L].filename,
          j = `${x[L].size}`.padStart(10, " ");
        (I += x[L].size), p.util.writeLine(`${j} ${U}`);
      }
      p.util.writeLine("");
      const F = formatBytes(I).padStart(10, " "),
        O = `(${I} bytes)`;
      p.util.writeLine(`${F} ${O}`);
    },
    description: "List the contents of the current directory",
    syntax: "<[path]>",
  },
  Echo = {
    keyword: "echo",
    exec(k, r, p) {
      const v = r.join(" ").match(/"(.*?)"/);
      if (v && v.length > 1) {
        const $ = v[1];
        p.util.writeLine($);
      } else p.util.Error("Unable to echo: syntax invalid!");
    },
    description: "Echo a string.",
    syntax: '"<[string]>"',
  },
  Env = {
    keyword: "env",
    exec(k, r, p) {
      const v = Object.entries(p.env.config.getConfig());
      for (let $ = 0; $ < v.length; $++) {
        const S = v[$][1].toString(),
          x = v[$][0].padEnd(20, " ");
        p.util.writeColor(`[${x}]: `, "blue", "white", !0),
          p.util.write(`${S}`),
          p.util.writeLine("");
      }
    },
    description: "List the environment variables",
  },
  Exit = {
    keyword: "exit",
    exec(k, r, p) {
      if (!p.app)
        return p.util.Error(
          "can't close ArcTerm: no associated app in constructor"
        );
      closeWindow(p.app.id);
    },
    description: "Quit ArcTerm",
  },
  Help = {
    keyword: "help",
    exec(k, r, p) {
      if (r[0]) return specific(r[0], p);
      all(p);
    },
    description: "Display a list of built-in commands",
    syntax: "([command?])",
  };
function all(k) {
  const r = k.commands.sort((p, v) => (v.keyword < p.keyword ? 1 : -1));
  for (let p = 0; p < r.length; p++) {
    const v = r[p].keyword.toUpperCase().padEnd(15, " "),
      $ = r[p].description;
    k.util.writeColor(`[${v}]${$}`, "orange");
  }
}
function specific(k, r) {
  const p = r.commandHandler.getCommand(k);
  if (!p || p.keyword == defaultCommand.keyword)
    return r.util.Error(`${k}: command not found.`);
  r.util.writeColor(`[${p.keyword.toUpperCase()}]: ${p.description}`, "blue"),
    r.util.writeLine(`
`),
    r.util.writeColor(`Usage: [${p.keyword}] ${p.syntax || ""}`, "blue");
}
const History = {
  keyword: "history",
  exec(k, r, p) {
    if (r.includes("clear")) return clear(p);
    const v = p.commandHandler.history;
    for (let $ = 0; $ < v.length; $++) {
      const S = `${$}`.padStart(3, "0");
      p.util.writeColor(`[${S}]: ${v[$]}`, "yellow");
    }
  },
  description: "Show the command history",
  syntax: "([clear?])",
};
function clear(k) {
  const r = k.commandHandler.history.length;
  (k.commandHandler.history = []),
    k.util.writeColor(
      `[SUCCESS]: History cleared, ${r} items removed.`,
      "green"
    );
}
const Kill = {
    keyword: "kill",
    exec(k, r, p) {
      const v = r[0];
      if (!v) return p.util.Error("Missing application ID.");
      const $ = getWindow(v);
      if (!$) return p.util.Error(`${v}: app not found.`);
      closeWindow(v), p.util.writeLine(`Closed ${$.info.name}`);
    },
    description: "Terminate a program",
    syntax: '"<[appId]>"',
  },
  LogDump = {
    keyword: "logdump",
    async exec(k, r, p) {
      const v = `./LogDump-${Math.floor(Math.random() * 1e9)}.txt`;
      p.util.writeColor(
        `Writing log to [${v}]...
`,
        "purple"
      );
      const $ = get_store_value(log);
      let S = `-- [START OF LOG] --
`;
      const x = $.length,
        I = p.util.writeColor(`Item [0] of [${x}] processed.`, "blue");
      for (let O = 0; O < $.length; O++) {
        const L = O + 1,
          U = Math.floor((100 / x) * (O + 1));
        p.util.updateColor(
          I,
          `Item [${L}] of [${x}] ([${U}%]) processed.`,
          "blue"
        ),
          (S += `[${$[O].timestamp} | ${$[O].source}] ${$[O].msg}
`),
          await sleep(25);
      }
      const F = new Blob([S], { type: "text/plain" });
      await writeFile(v, F),
        p.util.writeColor(
          `
Wrote [${S.length}] bytes.`,
          "purple"
        ),
        fbClass.refresh();
    },
    description: "Dump the log to a file",
  },
  sleep = (k) => new Promise((r) => setTimeout(r, k)),
  Mkdir = {
    keyword: "mkdir",
    async exec(k, r, p) {
      const v = p.path,
        $ = r.join(" "),
        S = (v != "./" ? `${v}/${$}` : $).replaceAll("//", "/");
      await createDirectory(S), p.util.writeLine(`Directory '${$}' created.`);
    },
    description: "Create a directory",
    syntax: '"<[name]>"',
  },
  oa = {
    keyword: "oa",
    exec(k, r, p) {
      const v = get_store_value(WindowStore);
      for (let $ = 0; $ < v.length; $++)
        v[$].info.custom ||
          (p.util.writeColor(`Opening [${v[$].id}]`, "orange"),
          openWindow(v[$].id, !0));
    },
    description: "Open all apps",
  },
  Open = {
    keyword: "open",
    exec(k, r, p) {
      const v = r[0],
        $ = getWindow(v);
      if (!$) return p.util.Error(`${v}: app not found.`);
      openWindow(v, !0), p.util.writeLine(`Opened ${$.info.name}`);
    },
    description: "Open a window",
    syntax: '"<[appId]>"',
  };
class ArcTermConfig {
  constructor(r) {
    _e(this, "env");
    _e(this, "configPath", "./arcterm.conf");
    _e(this, "configKeys", ["prompt", "greeting", "logo", "promptColor"]);
    (this.env = r), this.loadConfigFile();
  }
  getConfig() {
    const r = {};
    for (let p = 0; p < this.configKeys.length; p++) {
      const v = this.configKeys[p];
      r[v] = this.env[v];
    }
    return r;
  }
  loadConfig(r) {
    for (let p = 0; p < this.configKeys.length; p++) {
      const v = this.configKeys[p],
        $ = this.env[v] != null && r,
        S = typeof this.env[v] == typeof r[v];
      $ && S && (this.env[v] = r[v]);
    }
  }
  async loadConfigFile() {
    const r = await readFile(this.configPath);
    if (!r) return this.writeConfig();
    const v = new TextDecoder("utf-8").decode(new Uint8Array(r));
    let $;
    try {
      $ = JSON.parse(v);
    } catch {
      $ = {};
    }
    this.loadConfig($);
  }
  async writeConfig() {
    const r = {};
    for (let v = 0; v < this.configKeys.length; v++) {
      const $ = this.configKeys[v];
      r[$] = this.env[$];
    }
    const p = new Blob([JSON.stringify(r, null, 2)], {
      type: "application/json",
    });
    await writeFile(this.configPath, p);
  }
}
class ArcTermEnv {
  constructor() {
    _e(this, "config");
    _e(this, "prompt", "[&u]: [~/&p] $ ");
    _e(this, "promptColor", "green");
    _e(
      this,
      "greeting",
      `ArcTerm & ArcOS v${ArcOSVersion}

Licensed under GPLv3. Created by the ArcOS team.`
    );
    _e(this, "logo", !0);
    this.config = new ArcTermConfig(this);
  }
}
const Reload = {
    keyword: "reload",
    async exec(k, r, p) {
      p.dispose(),
        setTimeout(async () => {
          await p.initialize();
        });
    },
    description: "Reload the ArcTerm configuration",
  },
  Restart$1 = {
    keyword: "restart",
    exec(k, r, p) {
      if (get_store_value(CurrentState).key == "desktop") return restart();
      p.util.writeColor("[RESTART]: Terminating NOW.", "green"),
        setTimeout(() => {
          location.reload();
        }, 1e3);
    },
    description: "Restart ArcOS",
  },
  Rf = {
    keyword: "rf",
    async exec(k, r, p) {
      const v = p.path,
        $ = r.join(" ").trim(),
        S = await getDirectory(v);
      for (let x = 0; x < S.files.length; x++) {
        const I = S.files[x];
        if (I.filename == $) {
          const F = await readFile(I.scopedPath);
          if (!F) return p.util.Error("Could not read the file.");
          if (!I.mime.includes("text/"))
            return p.util.Error("Not attempting to read non-text file.");
          const L = new TextDecoder("utf-8").decode(new Uint8Array(F));
          p.util.writeLine(L);
          return;
        }
      }
      p.util.Error("The file doesn't exist on ArcFS.");
    },
    description: "Read a file from ArcFS",
    syntax: "<[filename]>",
  },
  Rm = {
    keyword: "rm",
    async exec(k, r, p) {
      const v = p.path,
        $ = r.join(" "),
        S = (v != "./" ? `${v}/${$}` : $).replaceAll("//", "/");
      try {
        await deleteItem(S);
      } catch {
        p.util.Error(`Unable to delete "${$}"`);
      }
    },
    description: "Delete a file or folder",
    syntax: '"<[name]>"',
  },
  Run = {
    keyword: "run",
    async exec(k, r, p) {
      const v = p.path,
        $ = r.join(" ").trim(),
        S = await getDirectory(v);
      for (let x = 0; x < S.files.length; x++) {
        const I = S.files[x];
        if (I.filename == $) {
          p.util.writeLine(`Opening ${$} (${I.size} Bytes)`), o(I);
          return;
        }
      }
      p.util.Error("The file doesn't exist on ArcFS.");
    },
    description: "Run a file from your ArcFS account.",
    syntax: '"<[filename]>"',
  };
async function o(k) {
  const r = k.scopedPath;
  r.startsWith("./") && (k.scopedPath = r.replace("./", ""));
  const p = await openUserFile(k);
  WindowStore.set(get_store_value(WindowStore)),
    p != !0 && openWithDialog({ ...p, anymime: !0 });
}
const Shutdown$1 = {
    keyword: "shutdown",
    exec(k, r, p) {
      if (get_store_value(CurrentState).key == "desktop") return shutdown();
      p.util.writeColor("[SHUTDOWN]: Terminating NOW.", "green"),
        setTimeout(() => {
          applyState("turnedoff");
        }, 1e3);
    },
    description: "Turn off ArcOS",
  },
  StateCommand = {
    keyword: "state",
    exec(k, r, p) {
      const v = r.join(" ");
      if (!v) {
        const $ = get_store_value(CurrentState);
        return p.util.writeColor(
          `Current state: [${$.name}] (ArcOS.state.[${$.key}])`,
          "purple"
        );
      }
      if (!States.get(v)) return p.util.Error(`${v}: State doesn't exist.`);
      applyState(v);
    },
    syntax: "<[stateId]>",
    description: "for debugging -- forcefully change the state",
  },
  Tauri = {
    keyword: "tauri",
    async exec(k, r, p) {
      const v = await inTauri();
      p.util.writeColor(
        `[STATUS]: You are ${v ? "in the Desktop app" : "in the Web version"}`,
        "aqua"
      );
    },
    description: "Check if you are in the desktop app or not",
  },
  UDD = {
    keyword: "udd",
    async exec(k, r, p) {
      const v = `./UserDump-${Math.floor(Math.random() * 1e9)}.txt`;
      p.util.writeColor(
        `Writing log to [${v}]...
`,
        "purple"
      );
      const $ = new Blob([JSON.stringify(get_store_value(UserData), null, 2)], {
        type: "text/plain",
      });
      await writeFile(v, $);
    },
    description: "Dump the userdata to a file",
  },
  Ver = {
    keyword: "ver",
    exec(k, r, p) {
      p.util.writeColor(`ArcOS & ArcTerm [v${ArcOSVersion}]`, "blue");
    },
    description: "Display the version number",
  },
  defaultCommand = {
    keyword: "default",
    exec: (k, r, p) => {
      k && p.util.Error(`${k}: command not found.`);
    },
    description: "Default command",
  },
  arcCommands = [
    ArcFetch,
    Cd,
    Clear,
    Colors,
    Dir,
    Echo,
    Env,
    Exit,
    Help,
    History,
    LogDump,
    Mkdir,
    Rm,
    Reload,
    Restart$1,
    Shutdown$1,
    StateCommand,
    Tauri,
    UDD,
    Ver,
    Rf,
  ],
  desktopSpecific = [AppList, ATConf, Kill, oa, Open, Run];
class ArcTermCommandHandler {
  constructor(r) {
    _e(this, "term");
    _e(this, "history", []);
    this.term = r;
  }
  async evaluate(r, p) {
    this.history.push(`${r} ${p.join(" ")}`);
    const v = this.getCommand(r);
    (this.term.input.current.disabled = !0),
      await v.exec(r, p, this.term),
      !(!this.term.util || !this.term.input) &&
        (this.term.util.writeLine(`
`),
        this.term.input.unlock());
  }
  getCommand(r) {
    const p = r.toLowerCase();
    for (let v = 0; v < this.term.commands.length; v++)
      if (this.term.commands[v].keyword.toLowerCase() == p)
        return this.term.commands[v];
    return defaultCommand;
  }
}
function initError(k) {
  createOverlayableError(
    {
      title: "Can't initialize terminal",
      message:
        "The terminal instance is missing a valid target element. Please restart and try again.",
      buttons: [
        {
          caption: "Close",
          action() {
            closeWindow(k);
          },
        },
      ],
      image: logo,
    },
    k
  );
}
class ArcTermInput {
  constructor(r) {
    _e(this, "lockInput", !1);
    _e(this, "target");
    _e(this, "env");
    _e(this, "term");
    _e(this, "current");
    (this.target = r.target),
      (this.env = r.env),
      (this.term = r),
      this.commandLoop();
  }
  commandLoop() {
    setInterval(() => {
      this.lockInput || (this.lock(), this.target.append(this.createPrompt()));
    });
  }
  lock() {
    this.lockInput = !0;
  }
  unlock() {
    this.lockInput = !1;
  }
  getPrompt() {
    const r = get_store_value(UserName),
      p = localStorage.getItem("arcos-server"),
      v = (this.term.path || "./").replace("./", "");
    return this.env.prompt.replace("&u", r).replace("&s", p).replace("&p", v);
  }
  createPrompt() {
    this.current && (this.current.disabled = !0);
    const r = document.createElement("div"),
      p = document.createElement("div"),
      v = document.createElement("input");
    return (
      (r.className = "prompt"),
      this.term.util.writeColor(
        this.getPrompt(),
        this.env.promptColor,
        "white",
        !0,
        r
      ),
      (v.id = `input#${Math.floor(Math.random() * 1e9)}`),
      v.addEventListener("keydown", ($) => this.processInputEvent($, v)),
      (this.current = v),
      (p.className = "inner"),
      p.append(v),
      r.append(p),
      setTimeout(() => {
        this.term.app &&
          get_store_value(focusedWindowId) == this.term.app.id &&
          v.focus();
      }),
      r
    );
  }
  processInputEvent(r, p) {
    const v = r.key.toLowerCase(),
      $ = p.value.split(" "),
      S = $[0];
    $.shift(), v == "enter" && this.term.commandHandler.evaluate(S, $);
  }
}
function ArcTermIntro(k) {
  if (!k.env.logo) return;
  const r = [
    "   [_]         _____            ",
    "  [/_\\]  _ _ _|_   _|__ _ _ _ __ ",
    " [/ _ \\]| '_/ _|| |/ -_) '_| '  \\",
    "[/_/ \\_\\]_| \\__||_|\\___|_| |_|_|_|",
  ];
  for (let p = 0; p < r.length; p++) k.util.writeColor(r[p], "blue");
  k.util.writeLine(`
`);
}
class ArcTermUtil {
  constructor(r) {
    _e(this, "target");
    _e(this, "app");
    _e(this, "term");
    _e(this, "env");
    (this.target = r.target),
      (this.app = r.app),
      (this.term = r),
      (this.env = r.env),
      (this.target.innerText = "");
  }
  writeLine(r, p = !1, v = this.target) {
    const $ = document.createElement("div");
    return (
      ($.className = "part"),
      p && ($.className += " inline"),
      ($.innerText = `${r}`),
      v.appendChild($),
      $
    );
  }
  writeSeperator(r) {
    this.writeLine("".padEnd(r, "-"));
  }
  Error(r) {
    this.writeColor(`[Error]: ${r}`, "red");
  }
  write(r, p = this.target) {
    return this.writeLine(r, !0, p);
  }
  update(r, p) {
    if (!r) return !1;
    (r.innerText = ""), this.write(p, this.target);
  }
  updateColor(r, p, v) {
    if (!r) return !1;
    (r.innerText = ""), this.writeColor(p, v, "white", !1, r);
  }
  writeColor(r, p, v = "white", $ = !1, S = this.target) {
    const x = r.split(/(\[[^\]]*\])/),
      I = document.createElement("div");
    (I.className = "part "), $ && (I.className += " inline");
    for (let F = 0; F < x.length; F++) {
      const O = document.createElement("span"),
        L = x[F].startsWith("[") && x[F].endsWith("]");
      (O.className = `clr-${L ? p : v}`),
        (O.innerText = x[F].replaceAll("[", "").replaceAll("]", "")),
        I.append(O);
    }
    return S.append(I), I;
  }
}
let ArcTerm$1 = class {
  constructor(r, p, v, $) {
    _e(this, "target");
    _e(this, "commands");
    _e(this, "app");
    _e(this, "util");
    _e(this, "env");
    _e(this, "input");
    _e(this, "path");
    _e(this, "commandHandler");
    _e(this, "cb");
    (this.target = r),
      (this.commands = p),
      (this.app = v),
      (this.cb = $),
      this.initialize();
  }
  async initialize() {
    if (!this.target) return initError(this.app.id);
    (this.path = "./"),
      (this.target.innerText = `v${ArcOSVersion}`),
      (this.commandHandler = new ArcTermCommandHandler(this)),
      (this.env = new ArcTermEnv()),
      setTimeout(() => {
        (this.util = new ArcTermUtil(this)),
          (this.input = new ArcTermInput(this)),
          this.cb && this.cb(this),
          this.intro(),
          this.app;
      }, 500);
  }
  dispose() {
    this.target &&
      ((this.target.innerText = ""),
      (this.util = null),
      (this.env = null),
      this.input.lock(),
      (this.input = null));
  }
  intro() {
    ArcTermIntro(this),
      this.util.writeColor(
        `${this.env.greeting}

`,
        this.env.promptColor
      );
  }
};
function create_fragment$X(k) {
  let r, p, v;
  return {
    c() {
      (r = element("div")), attr(r, "class", "terminal-renderer");
    },
    m($, S) {
      insert($, r, S), k[3](r), p || ((v = listen(r, "click", k[1])), (p = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d($) {
      $ && detach(r), k[3](null), (p = !1), v();
    },
  };
}
function instance$S(k, r, p) {
  let { app: v } = r,
    $,
    S;
  onMount(() => {
    p(
      2,
      (v.events.close = () => {
        $ && ($.dispose(), ($ = null));
      }),
      v
    ),
      p(
        2,
        (v.events.open = () => {
          $ || ($ = new ArcTerm$1(S, [...arcCommands, ...desktopSpecific], v)),
            v.state.windowState.fll && fullscreenToggle(v.id);
        }),
        v
      ),
      p(
        2,
        (v.events.blur = () => {
          $ && $.input && $.input.current && ($.input.current.disabled = !0);
        }),
        v
      ),
      p(
        2,
        (v.events.focus = () => {
          $ && $.input && $.input.current && ($.input.current.disabled = !1);
        }),
        v
      );
  });
  function x() {
    !$ || !$.input || !$.input.current || $.input.current.focus();
  }
  function I(F) {
    binding_callbacks[F ? "unshift" : "push"](() => {
      (S = F), p(0, S);
    });
  }
  return (
    (k.$$set = (F) => {
      "app" in F && p(2, (v = F.app));
    }),
    [S, x, v, I]
  );
}
let ArcTerm_1$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$S, create_fragment$X, safe_not_equal, { app: 2 });
  }
};
const ArcTerm = {
    info: {
      name: "ArcTerm",
      description: "ArcOS Terminal",
      builtin: !0,
      version: "2.0.0",
      author: "ArcOS Team",
      icon: logo,
    },
    size: { w: 640, h: 480 },
    pos: { x: 60, y: 60 },
    minSize: { w: 350, h: 250 },
    maxSize: { w: NaN, h: NaN },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: ArcTerm_1$1,
    glass: !0,
    events: {
      keyboardShortcuts: [
        {
          alt: !0,
          key: "f",
          action(k) {
            fullscreenToggle(k.id);
          },
        },
      ],
    },
  },
  DefaultApps = {
    ErrCre: ErrorCreator,
    FileManager: FileBrowserApp,
    TextEditor,
    CalculatorApp,
    MessagingApp,
    SettingsApp,
    AppMan: AppManager,
    LoggerApp,
    AppPoker,
    Exit: Exit$1,
    AppInfo: AppInfo$1,
    ImageViewer,
    OpenWithApp,
    MarkDownViewer,
    MediaPlayerApp,
    ArcShell,
    DesktopWallpaper,
    DonutApp,
    ArcTerm,
  },
  SystemApps = [
    "AppMan",
    "Exit",
    "SettingsApp",
    "PfpSelector",
    "AppInfo",
    "LoggerApp",
    "FileManager",
  ];
async function importDefault(k = !1) {
  Log({
    msg: "Importing default applications",
    source: "imports.ts: importDefault",
    level: LogLevel.info,
  });
  const r = Object.entries(DefaultApps);
  for (let p = 0; p < r.length; p++)
    Log({
      msg: `Importing default application "${r[p][0]}"...`,
      source: "imports.ts: importDefault",
      level: LogLevel.info,
    }),
      await loadWindow(r[p][0], r[p][1]),
      k && openWindow(r[p][0]);
  updateStores();
}
function create_fragment$W(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F = k[0].info.name + "",
    O,
    L,
    U,
    j = k[0].info.description + "",
    N,
    q,
    R;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (S = space()),
        (x = element("div")),
        (I = element("p")),
        (O = text(F)),
        (L = space()),
        (U = element("p")),
        (N = text(j)),
        src_url_equal(
          p.src,
          (v = getOriginalIcon(k[0].id) || getAppIcon(k[0]))
        ) || attr(p, "src", v),
        attr(p, "alt", ($ = k[0].info.name)),
        attr(p, "class", "icon"),
        attr(I, "class", "title"),
        attr(U, "class", "description"),
        attr(x, "class", "info"),
        attr(r, "class", "appbutton"),
        toggle_class(r, "disabled", k[0].disabled);
    },
    m(Q, H) {
      insert(Q, r, H),
        append(r, p),
        append(r, S),
        append(r, x),
        append(x, I),
        append(I, O),
        append(x, L),
        append(x, U),
        append(U, N),
        q || ((R = listen(r, "click", k[1])), (q = !0));
    },
    p(Q, [H]) {
      H & 1 &&
        !src_url_equal(
          p.src,
          (v = getOriginalIcon(Q[0].id) || getAppIcon(Q[0]))
        ) &&
        attr(p, "src", v),
        H & 1 && $ !== ($ = Q[0].info.name) && attr(p, "alt", $),
        H & 1 && F !== (F = Q[0].info.name + "") && set_data(O, F),
        H & 1 && j !== (j = Q[0].info.description + "") && set_data(N, j),
        H & 1 && toggle_class(r, "disabled", Q[0].disabled);
    },
    i: noop$1,
    o: noop$1,
    d(Q) {
      Q && detach(r), (q = !1), R();
    },
  };
}
function instance$R(k, r, p) {
  let { app: v } = r;
  function $() {
    closeWindow("AppInfo"),
      setTimeout(() => {
        AppInfoId.set(v.id), openWindow("AppInfo");
      }, 300);
  }
  return (
    (k.$$set = (S) => {
      "app" in S && p(0, (v = S.app));
    }),
    [v, $]
  );
}
class AppButton extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$R, create_fragment$W, safe_not_equal, { app: 0 });
  }
}
function create_else_block$7(k) {
  let r = k[0].id + "",
    p;
  return {
    c() {
      p = text(r);
    },
    m(v, $) {
      insert(v, p, $);
    },
    p(v, $) {
      $ & 1 && r !== (r = v[0].id + "") && set_data(p, r);
    },
    d(v) {
      v && detach(p);
    },
  };
}
function create_if_block$r(k) {
  let r = k[0].parentId + "",
    p,
    v,
    $ = k[0].id + "",
    S;
  return {
    c() {
      (p = text(r)), (v = text(".")), (S = text($));
    },
    m(x, I) {
      insert(x, p, I), insert(x, v, I), insert(x, S, I);
    },
    p(x, I) {
      I & 1 && r !== (r = x[0].parentId + "") && set_data(p, r),
        I & 1 && $ !== ($ = x[0].id + "") && set_data(S, $);
    },
    d(x) {
      x && detach(p), x && detach(v), x && detach(S);
    },
  };
}
function create_fragment$V(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L = k[0].info.name + "",
    U,
    j,
    N,
    q;
  function R(G, V) {
    return G[0].parentId ? create_if_block$r : create_else_block$7;
  }
  let Q = R(k),
    H = Q(k);
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (S = space()),
        (x = element("div")),
        (I = element("p")),
        H.c(),
        (F = space()),
        (O = element("p")),
        (U = text(L)),
        (j = text(" (hidden)")),
        src_url_equal(p.src, (v = getAppIcon(k[0]))) || attr(p, "src", v),
        attr(p, "alt", ($ = k[0].info.name)),
        attr(p, "class", "icon"),
        attr(I, "class", "title"),
        attr(O, "class", "description"),
        attr(x, "class", "info"),
        attr(r, "class", "appbutton"),
        toggle_class(r, "disabled", k[0].disabled);
    },
    m(G, V) {
      insert(G, r, V),
        append(r, p),
        append(r, S),
        append(r, x),
        append(x, I),
        H.m(I, null),
        append(x, F),
        append(x, O),
        append(O, U),
        append(O, j),
        N || ((q = listen(r, "click", k[1])), (N = !0));
    },
    p(G, [V]) {
      V & 1 &&
        !src_url_equal(p.src, (v = getAppIcon(G[0]))) &&
        attr(p, "src", v),
        V & 1 && $ !== ($ = G[0].info.name) && attr(p, "alt", $),
        Q === (Q = R(G)) && H
          ? H.p(G, V)
          : (H.d(1), (H = Q(G)), H && (H.c(), H.m(I, null))),
        V & 1 && L !== (L = G[0].info.name + "") && set_data(U, L),
        V & 1 && toggle_class(r, "disabled", G[0].disabled);
    },
    i: noop$1,
    o: noop$1,
    d(G) {
      G && detach(r), H.d(), (N = !1), q();
    },
  };
}
function instance$Q(k, r, p) {
  let { app: v } = r;
  function $() {
    closeWindow("AppInfo"),
      setTimeout(() => {
        AppInfoId.set(v.id), openWindow("AppInfo");
      }, 300);
  }
  return (
    (k.$$set = (S) => {
      "app" in S && p(0, (v = S.app));
    }),
    [v, $]
  );
}
class HiddenAppButton extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$Q, create_fragment$V, safe_not_equal, { app: 0 });
  }
}
function get_each_context$c(k, r, p) {
  const v = k.slice();
  return (v[2] = r[p]), v;
}
function get_each_context_1$3(k, r, p) {
  const v = k.slice();
  return (v[2] = r[p]), v;
}
function create_each_block_1$3(k) {
  let r, p;
  return (
    (r = new AppButton({ props: { app: k[2] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 2 && (S.app = v[2]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$c(k) {
  let r, p;
  return (
    (r = new HiddenAppButton({ props: { app: k[2] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.app = v[2]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$U(k) {
  let r,
    p,
    v,
    $,
    S,
    x = k[1],
    I = [];
  for (let j = 0; j < x.length; j += 1)
    I[j] = create_each_block_1$3(get_each_context_1$3(k, x, j));
  const F = (j) =>
    transition_out(I[j], 1, 1, () => {
      I[j] = null;
    });
  let O = k[0],
    L = [];
  for (let j = 0; j < O.length; j += 1)
    L[j] = create_each_block$c(get_each_context$c(k, O, j));
  const U = (j) =>
    transition_out(L[j], 1, 1, () => {
      L[j] = null;
    });
  return {
    c() {
      (r = element("h1")),
        (r.textContent = "Applications"),
        (p = space()),
        (v = element("div"));
      for (let j = 0; j < I.length; j += 1) I[j].c();
      $ = space();
      for (let j = 0; j < L.length; j += 1) L[j].c();
      attr(v, "class", "apps");
    },
    m(j, N) {
      insert(j, r, N), insert(j, p, N), insert(j, v, N);
      for (let q = 0; q < I.length; q += 1) I[q] && I[q].m(v, null);
      append(v, $);
      for (let q = 0; q < L.length; q += 1) L[q] && L[q].m(v, null);
      S = !0;
    },
    p(j, [N]) {
      if (N & 2) {
        x = j[1];
        let q;
        for (q = 0; q < x.length; q += 1) {
          const R = get_each_context_1$3(j, x, q);
          I[q]
            ? (I[q].p(R, N), transition_in(I[q], 1))
            : ((I[q] = create_each_block_1$3(R)),
              I[q].c(),
              transition_in(I[q], 1),
              I[q].m(v, $));
        }
        for (group_outros(), q = x.length; q < I.length; q += 1) F(q);
        check_outros();
      }
      if (N & 1) {
        O = j[0];
        let q;
        for (q = 0; q < O.length; q += 1) {
          const R = get_each_context$c(j, O, q);
          L[q]
            ? (L[q].p(R, N), transition_in(L[q], 1))
            : ((L[q] = create_each_block$c(R)),
              L[q].c(),
              transition_in(L[q], 1),
              L[q].m(v, null));
        }
        for (group_outros(), q = O.length; q < L.length; q += 1) U(q);
        check_outros();
      }
    },
    i(j) {
      if (!S) {
        for (let N = 0; N < x.length; N += 1) transition_in(I[N]);
        for (let N = 0; N < O.length; N += 1) transition_in(L[N]);
        S = !0;
      }
    },
    o(j) {
      I = I.filter(Boolean);
      for (let N = 0; N < I.length; N += 1) transition_out(I[N]);
      L = L.filter(Boolean);
      for (let N = 0; N < L.length; N += 1) transition_out(L[N]);
      S = !1;
    },
    d(j) {
      j && detach(r),
        j && detach(p),
        j && detach(v),
        destroy_each(I, j),
        destroy_each(L, j);
    },
  };
}
function instance$P(k, r, p) {
  let v = [],
    $ = [];
  return (
    WindowStore.subscribe((S) => {
      p(0, (v = [])), p(1, ($ = []));
      for (let x = 0; x < S.length; x++)
        S[x].info.hidden ? v.push(S[x]) : $.push(S[x]);
    }),
    [v, $]
  );
}
class Apps extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$P, create_fragment$U, safe_not_equal, {});
  }
}
const desktop$1 = "";
function create_if_block$q(k) {
  let r;
  return {
    c() {
      (r = element("span")),
        (r.textContent = "block"),
        attr(r, "class", "material-icons-round none");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$T(k) {
  let r,
    p,
    v,
    $,
    S = k[0][0] == "img0" && create_if_block$q();
  return {
    c() {
      (r = element("div")),
        S && S.c(),
        attr(r, "class", "wallpaper"),
        set_style(r, "background-image", "url(" + k[0][1] + ")"),
        attr(r, "title", (p = k[0][0] == "img0" ? "(none)" : k[0][0])),
        toggle_class(r, "selected", k[1].sh.desktop.wallpaper == k[0][0]);
    },
    m(x, I) {
      insert(x, r, I),
        S && S.m(r, null),
        v || (($ = listen(r, "click", k[2])), (v = !0));
    },
    p(x, [I]) {
      x[0][0] == "img0"
        ? S || ((S = create_if_block$q()), S.c(), S.m(r, null))
        : S && (S.d(1), (S = null)),
        I & 1 && set_style(r, "background-image", "url(" + x[0][1] + ")"),
        I & 1 &&
          p !== (p = x[0][0] == "img0" ? "(none)" : x[0][0]) &&
          attr(r, "title", p),
        I & 3 &&
          toggle_class(r, "selected", x[1].sh.desktop.wallpaper == x[0][0]);
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r), S && S.d(), (v = !1), $();
    },
  };
}
function instance$O(k, r, p) {
  let v;
  component_subscribe(k, UserData, (x) => p(1, (v = x)));
  let { wallpaper: $ } = r;
  function S() {
    set_store_value(UserData, (v.sh.desktop.wallpaper = $[0]), v);
  }
  return (
    (k.$$set = (x) => {
      "wallpaper" in x && p(0, ($ = x.wallpaper));
    }),
    [$, v, S]
  );
}
class ImageSelector extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$O, create_fragment$T, safe_not_equal, {
        wallpaper: 0,
      });
  }
}
function get_each_context$b(k, r, p) {
  const v = k.slice();
  return (v[1] = r[p]), v;
}
function create_each_block$b(k) {
  let r, p;
  return (
    (r = new ImageSelector({ props: { wallpaper: k[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$S(k) {
  let r, p, v, $, S, x, I, F, O, L, U;
  $ = new Current({});
  let j = Object.entries(Wallpapers),
    N = [];
  for (let R = 0; R < j.length; R += 1)
    N[R] = create_each_block$b(get_each_context$b(k, j, R));
  const q = (R) =>
    transition_out(N[R], 1, 1, () => {
      N[R] = null;
    });
  return {
    c() {
      (r = element("div")),
        (p = element("h1")),
        (p.textContent = "Wallpaper"),
        (v = space()),
        create_component($.$$.fragment),
        (S = space()),
        (x = element("div"));
      for (let R = 0; R < N.length; R += 1) N[R].c();
      (I = space()),
        (F = element("div")),
        (F.textContent = "add"),
        attr(F, "class", "wallpaper nobg customwp material-icons-round"),
        attr(x, "class", "wallpapers"),
        attr(r, "class", "desktop-page");
    },
    m(R, Q) {
      insert(R, r, Q),
        append(r, p),
        append(r, v),
        mount_component($, r, null),
        append(r, S),
        append(r, x);
      for (let H = 0; H < N.length; H += 1) N[H] && N[H].m(x, null);
      append(x, I),
        append(x, F),
        (O = !0),
        L || ((U = listen(F, "click", k[0])), (L = !0));
    },
    p(R, [Q]) {
      if (Q & 0) {
        j = Object.entries(Wallpapers);
        let H;
        for (H = 0; H < j.length; H += 1) {
          const G = get_each_context$b(R, j, H);
          N[H]
            ? (N[H].p(G, Q), transition_in(N[H], 1))
            : ((N[H] = create_each_block$b(G)),
              N[H].c(),
              transition_in(N[H], 1),
              N[H].m(x, I));
        }
        for (group_outros(), H = j.length; H < N.length; H += 1) q(H);
        check_outros();
      }
    },
    i(R) {
      if (!O) {
        transition_in($.$$.fragment, R);
        for (let Q = 0; Q < j.length; Q += 1) transition_in(N[Q]);
        O = !0;
      }
    },
    o(R) {
      transition_out($.$$.fragment, R), (N = N.filter(Boolean));
      for (let Q = 0; Q < N.length; Q += 1) transition_out(N[Q]);
      O = !1;
    },
    d(R) {
      R && detach(r), destroy_component($), destroy_each(N, R), (L = !1), U();
    },
  };
}
function instance$N(k) {
  function r() {
    showOverlay("customWallpaper", "SettingsApp");
  }
  return [r];
}
let Desktop$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$N, create_fragment$S, safe_not_equal, {});
  }
};
const accentColors = [
    "F94144",
    "F3722C",
    "F8961E",
    "F9C74F",
    "90BE6D",
    "43AA8B",
    "577590",
    "264653",
    "E63946",
    "F1FAEE",
    "A8DADC",
    "457B9D",
    "1D3557",
    "F72585",
    "7209B7",
    "03045E",
    "FF70A6",
    "F61067",
    "D62828",
    "F49E4C",
    "E2C044",
    "E9FF70",
    "C2E812",
    "61E786",
    "91F5AD",
    "70D6FF",
    "AFCBFF",
    "A09BE7",
  ],
  DefaultThemes = {
    arcDark: {
      author: "ArcOS Team",
      version: "1.0.0",
      name: "ArcOS Dark",
      anim: !0,
      noGlass: !1,
      sharp: !1,
      theme: "dark",
      wallpaper: "img04",
      taskbarCentered: !1,
      taskbarLabels: !1,
      taskbarPosition: "",
      docked: !1,
      accent: "70D6FF",
      smallStart: !0,
      titleButtons: "default",
      titlebarLarge: !1,
      titlebarLeft: !1,
      taskbarColored: !1,
    },
    arcLight: {
      author: "ArcOS Team",
      version: "1.0.0",
      name: "ArcOS Light",
      anim: !0,
      noGlass: !1,
      sharp: !1,
      theme: "light",
      wallpaper: "img05",
      taskbarCentered: !1,
      taskbarLabels: !1,
      taskbarPosition: "",
      docked: !1,
      accent: "70D6FF",
      smallStart: !0,
      titleButtons: "default",
      titlebarLarge: !1,
      titlebarLeft: !1,
      taskbarColored: !1,
    },
    theHague: {
      author: "Aron Wagener",
      version: "1.0.0",
      name: "The Hague",
      anim: !0,
      noGlass: !1,
      sharp: !1,
      theme: "dark",
      wallpaper: "img13",
      taskbarCentered: !1,
      taskbarLabels: !0,
      taskbarPosition: "",
      docked: !0,
      accent: "0A0",
      smallStart: !1,
      titleButtons: "default",
      titlebarLarge: !0,
      titlebarLeft: !1,
      taskbarColored: !1,
    },
    wacky: {
      author: "Izaak Kuipers",
      version: "1.0.0",
      name: "Wacky",
      anim: !0,
      noGlass: !1,
      sharp: !1,
      theme: "dark",
      wallpaper: "img03",
      taskbarCentered: !0,
      taskbarLabels: !0,
      taskbarPosition: "vertical",
      docked: !1,
      accent: "fa0",
      smallStart: !0,
      titleButtons: "og",
      titlebarLarge: !0,
      titlebarLeft: !0,
      taskbarColored: !1,
    },
    performance: {
      author: "ArcOS Team",
      version: "1.0.0",
      name: "Optimal Performance",
      anim: !1,
      noGlass: !0,
      sharp: !0,
      theme: "dark",
      wallpaper: "img0",
      taskbarCentered: !1,
      taskbarLabels: !1,
      taskbarPosition: "",
      docked: !0,
      accent: "FFF",
      smallStart: !0,
      titleButtons: "default",
      titlebarLarge: !1,
      titlebarLeft: !1,
      taskbarColored: !1,
    },
    wandelbos: {
      version: "1.0.0",
      name: "Wandelbos",
      author: "Izaak",
      anim: !0,
      noGlass: !1,
      sharp: !1,
      theme: "dark",
      wallpaper: "img08",
      accent: "91F5AD",
      docked: !0,
      taskbarCentered: !1,
      taskbarLabels: !1,
      taskbarPosition: "",
      smallStart: !0,
      titleButtons: "default",
      titlebarLarge: !1,
      titlebarLeft: !1,
      taskbarColored: !0,
    },
    scheveningen: {
      version: "1.0.0",
      name: "Scheveningen",
      author: "Izaak & keesvv",
      anim: !0,
      noGlass: !1,
      sharp: !1,
      theme: "dark",
      wallpaper: "img14",
      accent: "264653",
      docked: !0,
      taskbarCentered: !1,
      taskbarLabels: !1,
      taskbarPosition: "",
      smallStart: !0,
      titleButtons: "default",
      titlebarLarge: !1,
      titlebarLeft: !1,
      taskbarColored: !0,
    },
  },
  Color_svelte_svelte_type_style_lang = "";
function create_fragment$R(k) {
  let r, p, v, $;
  return {
    c() {
      (r = element("button")),
        attr(r, "class", "color ol svelte-17jz46c"),
        set_style(r, "background", "#" + k[0]),
        attr(r, "data-caller", "appearance-accentselector"),
        attr(r, "data-hex", k[0]),
        attr(r, "title", (p = "#" + k[0].toUpperCase())),
        toggle_class(r, "selected", k[0] == k[1].sh.desktop.accent);
    },
    m(S, x) {
      insert(S, r, x), v || (($ = listen(r, "click", k[2])), (v = !0));
    },
    p(S, [x]) {
      x & 1 && set_style(r, "background", "#" + S[0]),
        x & 1 && attr(r, "data-hex", S[0]),
        x & 1 && p !== (p = "#" + S[0].toUpperCase()) && attr(r, "title", p),
        x & 3 && toggle_class(r, "selected", S[0] == S[1].sh.desktop.accent);
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r), (v = !1), $();
    },
  };
}
function instance$M(k, r, p) {
  let v;
  component_subscribe(k, UserData, (x) => p(1, (v = x)));
  let { color: $ } = r;
  function S() {
    set_store_value(UserData, (v.sh.desktop.accent = $), v);
  }
  return (
    (k.$$set = (x) => {
      "color" in x && p(0, ($ = x.color));
    }),
    [$, v, S]
  );
}
class Color extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$M, create_fragment$R, safe_not_equal, {
        color: 0,
      });
  }
}
const AccentColor_svelte_svelte_type_style_lang = "";
function get_each_context$a(k, r, p) {
  const v = k.slice();
  return (v[0] = r[p]), v;
}
function create_each_block$a(k) {
  let r, p;
  return (
    (r = new Color({ props: { color: k[0] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$Q(k) {
  let r, p, v, $;
  r = new OptionSection({
    props: {
      title: "Accent Color",
      context: "Choose an accent color for ArcOS",
    },
  });
  let S = accentColors,
    x = [];
  for (let F = 0; F < S.length; F += 1)
    x[F] = create_each_block$a(get_each_context$a(k, S, F));
  const I = (F) =>
    transition_out(x[F], 1, 1, () => {
      x[F] = null;
    });
  return {
    c() {
      create_component(r.$$.fragment), (p = space()), (v = element("div"));
      for (let F = 0; F < x.length; F += 1) x[F].c();
      attr(v, "class", "wrapper svelte-1xz38z7");
    },
    m(F, O) {
      mount_component(r, F, O), insert(F, p, O), insert(F, v, O);
      for (let L = 0; L < x.length; L += 1) x[L] && x[L].m(v, null);
      $ = !0;
    },
    p(F, [O]) {
      if (O & 0) {
        S = accentColors;
        let L;
        for (L = 0; L < S.length; L += 1) {
          const U = get_each_context$a(F, S, L);
          x[L]
            ? (x[L].p(U, O), transition_in(x[L], 1))
            : ((x[L] = create_each_block$a(U)),
              x[L].c(),
              transition_in(x[L], 1),
              x[L].m(v, null));
        }
        for (group_outros(), L = S.length; L < x.length; L += 1) I(L);
        check_outros();
      }
    },
    i(F) {
      if (!$) {
        transition_in(r.$$.fragment, F);
        for (let O = 0; O < S.length; O += 1) transition_in(x[O]);
        $ = !0;
      }
    },
    o(F) {
      transition_out(r.$$.fragment, F), (x = x.filter(Boolean));
      for (let O = 0; O < x.length; O += 1) transition_out(x[O]);
      $ = !1;
    },
    d(F) {
      destroy_component(r, F),
        F && detach(p),
        F && detach(v),
        destroy_each(x, F);
    },
  };
}
class AccentColor extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$Q, safe_not_equal, {});
  }
}
function create_fragment$P(k) {
  let r, p, v, $, S, x, I, F, O, L, U;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("div")),
        attr(v, "class", "accent"),
        set_style(v, "color", k[0][1].accent),
        attr(p, "class", ($ = "mockup-window theme-" + k[0][1].theme)),
        attr(r, "class", "themerenderer"),
        attr(r, "title", (S = k[0][1].name + " by " + k[0][1].author)),
        set_style(
          r,
          "background-image",
          "url(" + getWallpaper(k[0][1].wallpaper) + ")"
        ),
        set_style(r, "--accent", "#" + k[0][1].accent),
        attr(r, "data-id", (x = k[0][0])),
        attr(
          r,
          "data-caller",
          (I = "themerenderer-" + (k[1] ? "user" : "system"))
        ),
        attr(r, "data-name", (F = k[0][1].name)),
        attr(r, "data-json", (O = JSON.stringify(k[0][1]))),
        toggle_class(r, "sharp", k[0][1].sharp);
    },
    m(j, N) {
      insert(j, r, N),
        append(r, p),
        append(p, v),
        L || ((U = listen(r, "click", k[2])), (L = !0));
    },
    p(j, [N]) {
      N & 1 && set_style(v, "color", j[0][1].accent),
        N & 1 &&
          $ !== ($ = "mockup-window theme-" + j[0][1].theme) &&
          attr(p, "class", $),
        N & 1 &&
          S !== (S = j[0][1].name + " by " + j[0][1].author) &&
          attr(r, "title", S),
        N & 1 &&
          set_style(
            r,
            "background-image",
            "url(" + getWallpaper(j[0][1].wallpaper) + ")"
          ),
        N & 1 && set_style(r, "--accent", "#" + j[0][1].accent),
        N & 1 && x !== (x = j[0][0]) && attr(r, "data-id", x),
        N & 2 &&
          I !== (I = "themerenderer-" + (j[1] ? "user" : "system")) &&
          attr(r, "data-caller", I),
        N & 1 && F !== (F = j[0][1].name) && attr(r, "data-name", F),
        N & 1 && O !== (O = JSON.stringify(j[0][1])) && attr(r, "data-json", O),
        N & 1 && toggle_class(r, "sharp", j[0][1].sharp);
    },
    i: noop$1,
    o: noop$1,
    d(j) {
      j && detach(r), (L = !1), U();
    },
  };
}
function instance$L(k, r, p) {
  let { theme: v } = r,
    { user: $ = !1 } = r;
  function S() {
    loadTheme(v[1]);
  }
  return (
    (k.$$set = (x) => {
      "theme" in x && p(0, (v = x.theme)), "user" in x && p(1, ($ = x.user));
    }),
    [v, $, S]
  );
}
class ThemeRenderer extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$L, create_fragment$P, safe_not_equal, {
        theme: 0,
        user: 1,
      });
  }
}
function get_each_context$9(k, r, p) {
  const v = k.slice();
  return (v[3] = r[p]), v;
}
function get_each_context_1$2(k, r, p) {
  const v = k.slice();
  return (v[3] = r[p]), v;
}
function create_each_block_1$2(k) {
  let r, p;
  return (
    (r = new ThemeRenderer({ props: { theme: k[3] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$p(k) {
  let r,
    p,
    v = Object.entries(k[0].sh.userThemes),
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$9(get_each_context$9(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = empty();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 1) {
        v = Object.entries(x[0].sh.userThemes);
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$9(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$9(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_each_block$9(k) {
  let r, p;
  return (
    (r = new ThemeRenderer({ props: { theme: k[3], user: !0 } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.theme = v[3]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_default_slot$4(k) {
  let r, p, v, $, S, x, I;
  return {
    c() {
      (r = element("select")),
        (p = element("option")),
        (p.textContent = "Darkmode"),
        (v = element("option")),
        (v.textContent = "Lightmode"),
        ($ = element("option")),
        ($.textContent = "Amoled"),
        (S = element("option")),
        (S.textContent = "High contrast"),
        (p.__value = "dark"),
        (p.value = p.__value),
        (v.__value = "light"),
        (v.value = v.__value),
        ($.__value = "amoled"),
        ($.value = $.__value),
        (S.__value = "hc"),
        (S.value = S.__value),
        attr(r, "name", "aa"),
        attr(r, "id", "bb"),
        k[0].sh.desktop.theme === void 0 &&
          add_render_callback(() => k[2].call(r));
    },
    m(F, O) {
      insert(F, r, O),
        append(r, p),
        append(r, v),
        append(r, $),
        append(r, S),
        select_option(r, k[0].sh.desktop.theme, !0),
        x || ((I = listen(r, "change", k[2])), (x = !0));
    },
    p(F, O) {
      O & 1 && select_option(r, F[0].sh.desktop.theme);
    },
    d(F) {
      F && detach(r), (x = !1), I();
    },
  };
}
function create_fragment$O(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H;
  S = new Current({});
  let G = Object.entries(DefaultThemes),
    V = [];
  for (let J = 0; J < G.length; J += 1)
    V[J] = create_each_block_1$2(get_each_context_1$2(k, G, J));
  const K = (J) =>
    transition_out(V[J], 1, 1, () => {
      V[J] = null;
    });
  let Y = k[0].sh.userThemes && create_if_block$p(k);
  return (
    (j = new OptionSection({
      props: {
        title: "Style",
        context: "Change the style of the UI",
        $$slots: { default: [create_default_slot$4] },
        $$scope: { ctx: k },
      },
    })),
    (q = new AccentColor({})),
    {
      c() {
        (r = element("h1")),
          (r.textContent = "Appearance"),
          (p = space()),
          (v = element("div")),
          ($ = element("div")),
          create_component(S.$$.fragment),
          (x = space()),
          (I = element("div"));
        for (let J = 0; J < V.length; J += 1) V[J].c();
        (F = space()),
          Y && Y.c(),
          (O = space()),
          (L = element("button")),
          (L.textContent = "save"),
          (U = space()),
          create_component(j.$$.fragment),
          (N = space()),
          create_component(q.$$.fragment),
          attr($, "class", "desktop-page"),
          attr(L, "class", "themerenderer save material-icons-round"),
          attr(L, "title", "Save current theme"),
          attr(I, "class", "themes"),
          attr(v, "class", "settingspage-themes");
      },
      m(J, Z) {
        insert(J, r, Z),
          insert(J, p, Z),
          insert(J, v, Z),
          append(v, $),
          mount_component(S, $, null),
          append(v, x),
          append(v, I);
        for (let X = 0; X < V.length; X += 1) V[X] && V[X].m(I, null);
        append(I, F),
          Y && Y.m(I, null),
          append(I, O),
          append(I, L),
          insert(J, U, Z),
          mount_component(j, J, Z),
          insert(J, N, Z),
          mount_component(q, J, Z),
          (R = !0),
          Q || ((H = listen(L, "click", k[1])), (Q = !0));
      },
      p(J, [Z]) {
        if (Z & 0) {
          G = Object.entries(DefaultThemes);
          let ee;
          for (ee = 0; ee < G.length; ee += 1) {
            const te = get_each_context_1$2(J, G, ee);
            V[ee]
              ? (V[ee].p(te, Z), transition_in(V[ee], 1))
              : ((V[ee] = create_each_block_1$2(te)),
                V[ee].c(),
                transition_in(V[ee], 1),
                V[ee].m(I, F));
          }
          for (group_outros(), ee = G.length; ee < V.length; ee += 1) K(ee);
          check_outros();
        }
        J[0].sh.userThemes
          ? Y
            ? (Y.p(J, Z), Z & 1 && transition_in(Y, 1))
            : ((Y = create_if_block$p(J)),
              Y.c(),
              transition_in(Y, 1),
              Y.m(I, O))
          : Y &&
            (group_outros(),
            transition_out(Y, 1, 1, () => {
              Y = null;
            }),
            check_outros());
        const X = {};
        Z & 257 && (X.$$scope = { dirty: Z, ctx: J }), j.$set(X);
      },
      i(J) {
        if (!R) {
          transition_in(S.$$.fragment, J);
          for (let Z = 0; Z < G.length; Z += 1) transition_in(V[Z]);
          transition_in(Y),
            transition_in(j.$$.fragment, J),
            transition_in(q.$$.fragment, J),
            (R = !0);
        }
      },
      o(J) {
        transition_out(S.$$.fragment, J), (V = V.filter(Boolean));
        for (let Z = 0; Z < V.length; Z += 1) transition_out(V[Z]);
        transition_out(Y),
          transition_out(j.$$.fragment, J),
          transition_out(q.$$.fragment, J),
          (R = !1);
      },
      d(J) {
        J && detach(r),
          J && detach(p),
          J && detach(v),
          destroy_component(S),
          destroy_each(V, J),
          Y && Y.d(),
          J && detach(U),
          destroy_component(j, J),
          J && detach(N),
          destroy_component(q, J),
          (Q = !1),
          H();
      },
    }
  );
}
function instance$K(k, r, p) {
  let v;
  component_subscribe(k, UserData, (x) => p(0, (v = x)));
  const $ = () => showOverlay("saveTheme", "SettingsApp");
  function S() {
    (v.sh.desktop.theme = select_value(this)), UserData.set(v);
  }
  return [v, $, S];
}
class Personalization extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$K, create_fragment$O, safe_not_equal, {});
  }
}
function create_default_slot_6(k) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch");
    },
    m($, S) {
      insert($, r, S),
        (r.checked = k[0].sh.taskbar.centered),
        p || ((v = listen(r, "change", k[1])), (p = !0));
    },
    p($, S) {
      S & 1 && (r.checked = $[0].sh.taskbar.centered);
    },
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_5$1(k) {
  let r, p, v, $;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch"),
        (r.disabled = p = !!k[0].sh.taskbar.pos);
    },
    m(S, x) {
      insert(S, r, x),
        (r.checked = k[0].sh.taskbar.labels),
        v || (($ = listen(r, "change", k[2])), (v = !0));
    },
    p(S, x) {
      x & 1 && p !== (p = !!S[0].sh.taskbar.pos) && (r.disabled = p),
        x & 1 && (r.checked = S[0].sh.taskbar.labels);
    },
    d(S) {
      S && detach(r), (v = !1), $();
    },
  };
}
function create_default_slot_4$1(k) {
  let r, p, v, $, S, x;
  return {
    c() {
      (r = element("select")),
        (p = element("option")),
        (p.textContent = "Left"),
        (v = element("option")),
        (v.textContent = "Bottom"),
        ($ = element("option")),
        ($.textContent = "Right"),
        (p.__value = "vertical"),
        (p.value = p.__value),
        (v.__value = ""),
        (v.value = v.__value),
        ($.__value = "vertical-right"),
        ($.value = $.__value),
        k[0].sh.taskbar.pos === void 0 &&
          add_render_callback(() => k[3].call(r));
    },
    m(I, F) {
      insert(I, r, F),
        append(r, p),
        append(r, v),
        append(r, $),
        select_option(r, k[0].sh.taskbar.pos, !0),
        S || ((x = listen(r, "change", k[3])), (S = !0));
    },
    p(I, F) {
      F & 1 && select_option(r, I[0].sh.taskbar.pos);
    },
    d(I) {
      I && detach(r), (S = !1), x();
    },
  };
}
function create_default_slot_3$1(k) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch");
    },
    m($, S) {
      insert($, r, S),
        (r.checked = k[0].sh.start.small),
        p || ((v = listen(r, "change", k[4])), (p = !0));
    },
    p($, S) {
      S & 1 && (r.checked = $[0].sh.start.small);
    },
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_2$1(k) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch");
    },
    m($, S) {
      insert($, r, S),
        (r.checked = k[0].sh.noQuickSettings),
        p || ((v = listen(r, "change", k[5])), (p = !0));
    },
    p($, S) {
      S & 1 && (r.checked = $[0].sh.noQuickSettings);
    },
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_1$1(k) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch");
    },
    m($, S) {
      insert($, r, S),
        (r.checked = k[0].sh.taskbar.docked),
        p || ((v = listen(r, "change", k[6])), (p = !0));
    },
    p($, S) {
      S & 1 && (r.checked = $[0].sh.taskbar.docked);
    },
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot$3(k) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch");
    },
    m($, S) {
      insert($, r, S),
        (r.checked = k[0].sh.taskbar.colored),
        p || ((v = listen(r, "change", k[7])), (p = !0));
    },
    p($, S) {
      S & 1 && (r.checked = $[0].sh.taskbar.colored);
    },
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_fragment$N(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H, G, V, K;
  return (
    (v = new OptionSection({
      props: {
        title: "Center taskbar buttons",
        context: "Centers the taskbar app buttons",
        $$slots: { default: [create_default_slot_6] },
        $$scope: { ctx: k },
      },
    })),
    (S = new OptionSection({
      props: {
        title: "Taskbar app labels",
        context: "Display app names on the taskbar",
        $$slots: { default: [create_default_slot_5$1] },
        $$scope: { ctx: k },
      },
    })),
    (I = new OptionSection({
      props: {
        title: "Taskbar position",
        context: "Where do you want the taskbar?",
        $$slots: { default: [create_default_slot_4$1] },
        $$scope: { ctx: k },
      },
    })),
    (U = new OptionSection({
      props: {
        title: "Small start menu",
        context: "Make the start menu smaller",
        $$slots: { default: [create_default_slot_3$1] },
        $$scope: { ctx: k },
      },
    })),
    (R = new OptionSection({
      props: {
        title: "Hide quick settings",
        context: "Hide quick settings in the action center",
        $$slots: { default: [create_default_slot_2$1] },
        $$scope: { ctx: k },
      },
    })),
    (H = new OptionSection({
      props: {
        title: "Dock shell",
        context: "Dock the taskbar and action center",
        $$slots: { default: [create_default_slot_1$1] },
        $$scope: { ctx: k },
      },
    })),
    (V = new OptionSection({
      props: {
        title: "Colored shell",
        context: "Apply the accent color to the shell",
        $$slots: { default: [create_default_slot$3] },
        $$scope: { ctx: k },
      },
    })),
    {
      c() {
        (r = element("h1")),
          (r.textContent = "Shell"),
          (p = space()),
          create_component(v.$$.fragment),
          ($ = space()),
          create_component(S.$$.fragment),
          (x = space()),
          create_component(I.$$.fragment),
          (F = space()),
          (O = element("hr")),
          (L = space()),
          create_component(U.$$.fragment),
          (j = space()),
          (N = element("hr")),
          (q = space()),
          create_component(R.$$.fragment),
          (Q = space()),
          create_component(H.$$.fragment),
          (G = space()),
          create_component(V.$$.fragment);
      },
      m(Y, J) {
        insert(Y, r, J),
          insert(Y, p, J),
          mount_component(v, Y, J),
          insert(Y, $, J),
          mount_component(S, Y, J),
          insert(Y, x, J),
          mount_component(I, Y, J),
          insert(Y, F, J),
          insert(Y, O, J),
          insert(Y, L, J),
          mount_component(U, Y, J),
          insert(Y, j, J),
          insert(Y, N, J),
          insert(Y, q, J),
          mount_component(R, Y, J),
          insert(Y, Q, J),
          mount_component(H, Y, J),
          insert(Y, G, J),
          mount_component(V, Y, J),
          (K = !0);
      },
      p(Y, [J]) {
        const Z = {};
        J & 257 && (Z.$$scope = { dirty: J, ctx: Y }), v.$set(Z);
        const X = {};
        J & 257 && (X.$$scope = { dirty: J, ctx: Y }), S.$set(X);
        const ee = {};
        J & 257 && (ee.$$scope = { dirty: J, ctx: Y }), I.$set(ee);
        const te = {};
        J & 257 && (te.$$scope = { dirty: J, ctx: Y }), U.$set(te);
        const re = {};
        J & 257 && (re.$$scope = { dirty: J, ctx: Y }), R.$set(re);
        const fe = {};
        J & 257 && (fe.$$scope = { dirty: J, ctx: Y }), H.$set(fe);
        const le = {};
        J & 257 && (le.$$scope = { dirty: J, ctx: Y }), V.$set(le);
      },
      i(Y) {
        K ||
          (transition_in(v.$$.fragment, Y),
          transition_in(S.$$.fragment, Y),
          transition_in(I.$$.fragment, Y),
          transition_in(U.$$.fragment, Y),
          transition_in(R.$$.fragment, Y),
          transition_in(H.$$.fragment, Y),
          transition_in(V.$$.fragment, Y),
          (K = !0));
      },
      o(Y) {
        transition_out(v.$$.fragment, Y),
          transition_out(S.$$.fragment, Y),
          transition_out(I.$$.fragment, Y),
          transition_out(U.$$.fragment, Y),
          transition_out(R.$$.fragment, Y),
          transition_out(H.$$.fragment, Y),
          transition_out(V.$$.fragment, Y),
          (K = !1);
      },
      d(Y) {
        Y && detach(r),
          Y && detach(p),
          destroy_component(v, Y),
          Y && detach($),
          destroy_component(S, Y),
          Y && detach(x),
          destroy_component(I, Y),
          Y && detach(F),
          Y && detach(O),
          Y && detach(L),
          destroy_component(U, Y),
          Y && detach(j),
          Y && detach(N),
          Y && detach(q),
          destroy_component(R, Y),
          Y && detach(Q),
          destroy_component(H, Y),
          Y && detach(G),
          destroy_component(V, Y);
      },
    }
  );
}
function instance$J(k, r, p) {
  let v;
  component_subscribe(k, UserData, (U) => p(0, (v = U)));
  function $() {
    (v.sh.taskbar.centered = this.checked), UserData.set(v);
  }
  function S() {
    (v.sh.taskbar.labels = this.checked), UserData.set(v);
  }
  function x() {
    (v.sh.taskbar.pos = select_value(this)), UserData.set(v);
  }
  function I() {
    (v.sh.start.small = this.checked), UserData.set(v);
  }
  function F() {
    (v.sh.noQuickSettings = this.checked), UserData.set(v);
  }
  function O() {
    (v.sh.taskbar.docked = this.checked), UserData.set(v);
  }
  function L() {
    (v.sh.taskbar.colored = this.checked), UserData.set(v);
  }
  return [v, $, S, x, I, F, O, L];
}
class Shell extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$J, create_fragment$N, safe_not_equal, {});
  }
}
function create_default_slot_5(k) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch");
    },
    m($, S) {
      insert($, r, S),
        (r.checked = k[0].sh.window.bigtb),
        p || ((v = listen(r, "change", k[1])), (p = !0));
    },
    p($, S) {
      S & 1 && (r.checked = $[0].sh.window.bigtb);
    },
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_4(k) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "b"),
        attr(r, "class", "switch");
    },
    m($, S) {
      insert($, r, S),
        (r.checked = k[0].sh.window.lefttb),
        p || ((v = listen(r, "change", k[2])), (p = !0));
    },
    p($, S) {
      S & 1 && (r.checked = $[0].sh.window.lefttb);
    },
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_3(k) {
  let r, p, v;
  return {
    c() {
      (r = element("button")), (r.textContent = "Change...");
    },
    m($, S) {
      insert($, r, S), p || ((v = listen(r, "click", k[3])), (p = !0));
    },
    p: noop$1,
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_2(k) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch");
    },
    m($, S) {
      insert($, r, S),
        (r.checked = k[0].sh.anim),
        p || ((v = listen(r, "change", k[4])), (p = !0));
    },
    p($, S) {
      S & 1 && (r.checked = $[0].sh.anim);
    },
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_1(k) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "b"),
        attr(r, "class", "switch");
    },
    m($, S) {
      insert($, r, S),
        (r.checked = k[0].sh.noGlass),
        p || ((v = listen(r, "change", k[5])), (p = !0));
    },
    p($, S) {
      S & 1 && (r.checked = $[0].sh.noGlass);
    },
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot$2(k) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "c"),
        attr(r, "class", "switch");
    },
    m($, S) {
      insert($, r, S),
        (r.checked = k[0].sh.desktop.sharp),
        p || ((v = listen(r, "change", k[6])), (p = !0));
    },
    p($, S) {
      S & 1 && (r.checked = $[0].sh.desktop.sharp);
    },
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function create_fragment$M(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q;
  return (
    (v = new OptionSection({
      props: {
        title: "Large titlebar",
        context: "Make the titlebars larger",
        $$slots: { default: [create_default_slot_5] },
        $$scope: { ctx: k },
      },
    })),
    (S = new OptionSection({
      props: {
        title: "Left titlebar buttons",
        context: "Swap the title and window controls",
        $$slots: { default: [create_default_slot_4] },
        $$scope: { ctx: k },
      },
    })),
    (I = new OptionSection({
      props: {
        title: "Titlebar Buttons",
        context: "Change the titlebar controls",
        $$slots: { default: [create_default_slot_3] },
        $$scope: { ctx: k },
      },
    })),
    (U = new OptionSection({
      props: {
        title: "Animations",
        context: "Display animations in ArcOS",
        $$slots: { default: [create_default_slot_2] },
        $$scope: { ctx: k },
      },
    })),
    (N = new OptionSection({
      props: {
        title: "No glass",
        context: "Disable glass effects in ArcOS",
        $$slots: { default: [create_default_slot_1] },
        $$scope: { ctx: k },
      },
    })),
    (R = new OptionSection({
      props: {
        title: "Sharp corners",
        context: "Disable rounding in all of ArcOS",
        $$slots: { default: [create_default_slot$2] },
        $$scope: { ctx: k },
      },
    })),
    {
      c() {
        (r = element("h1")),
          (r.textContent = "Windows"),
          (p = space()),
          create_component(v.$$.fragment),
          ($ = space()),
          create_component(S.$$.fragment),
          (x = space()),
          create_component(I.$$.fragment),
          (F = space()),
          (O = element("hr")),
          (L = space()),
          create_component(U.$$.fragment),
          (j = space()),
          create_component(N.$$.fragment),
          (q = space()),
          create_component(R.$$.fragment);
      },
      m(H, G) {
        insert(H, r, G),
          insert(H, p, G),
          mount_component(v, H, G),
          insert(H, $, G),
          mount_component(S, H, G),
          insert(H, x, G),
          mount_component(I, H, G),
          insert(H, F, G),
          insert(H, O, G),
          insert(H, L, G),
          mount_component(U, H, G),
          insert(H, j, G),
          mount_component(N, H, G),
          insert(H, q, G),
          mount_component(R, H, G),
          (Q = !0);
      },
      p(H, [G]) {
        const V = {};
        G & 129 && (V.$$scope = { dirty: G, ctx: H }), v.$set(V);
        const K = {};
        G & 129 && (K.$$scope = { dirty: G, ctx: H }), S.$set(K);
        const Y = {};
        G & 128 && (Y.$$scope = { dirty: G, ctx: H }), I.$set(Y);
        const J = {};
        G & 129 && (J.$$scope = { dirty: G, ctx: H }), U.$set(J);
        const Z = {};
        G & 129 && (Z.$$scope = { dirty: G, ctx: H }), N.$set(Z);
        const X = {};
        G & 129 && (X.$$scope = { dirty: G, ctx: H }), R.$set(X);
      },
      i(H) {
        Q ||
          (transition_in(v.$$.fragment, H),
          transition_in(S.$$.fragment, H),
          transition_in(I.$$.fragment, H),
          transition_in(U.$$.fragment, H),
          transition_in(N.$$.fragment, H),
          transition_in(R.$$.fragment, H),
          (Q = !0));
      },
      o(H) {
        transition_out(v.$$.fragment, H),
          transition_out(S.$$.fragment, H),
          transition_out(I.$$.fragment, H),
          transition_out(U.$$.fragment, H),
          transition_out(N.$$.fragment, H),
          transition_out(R.$$.fragment, H),
          (Q = !1);
      },
      d(H) {
        H && detach(r),
          H && detach(p),
          destroy_component(v, H),
          H && detach($),
          destroy_component(S, H),
          H && detach(x),
          destroy_component(I, H),
          H && detach(F),
          H && detach(O),
          H && detach(L),
          destroy_component(U, H),
          H && detach(j),
          destroy_component(N, H),
          H && detach(q),
          destroy_component(R, H);
      },
    }
  );
}
function instance$I(k, r, p) {
  let v;
  component_subscribe(k, UserData, (L) => p(0, (v = L)));
  function $() {
    (v.sh.window.bigtb = this.checked), UserData.set(v);
  }
  function S() {
    (v.sh.window.lefttb = this.checked), UserData.set(v);
  }
  const x = () => showOverlay("changeTitleButtons", "SettingsApp");
  function I() {
    (v.sh.anim = this.checked), UserData.set(v);
  }
  function F() {
    (v.sh.noGlass = this.checked), UserData.set(v);
  }
  function O() {
    (v.sh.desktop.sharp = this.checked), UserData.set(v);
  }
  return [v, $, S, x, I, F, O];
}
class Windows extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$I, create_fragment$M, safe_not_equal, {});
  }
}
const SettingsPages = [
  { name: "Account", icon: accountIcon, content: Account, sep: !0 },
  { name: "Appearance", icon: personalizationIcon, content: Personalization },
  { name: "Shell", icon: shellIcon, content: Shell },
  { name: "Windows", icon: windowsIcon, content: Windows },
  { name: "Wallpaper", icon: desktopIcon, content: Desktop$1, sep: !0 },
  { name: "Apps", icon: appsIcon, content: Apps, sep: !0 },
  { name: "About", icon: logo$c, content: About },
];
function getSettingsPage(k) {
  for (let r = 0; r < SettingsPages.length; r++)
    if (SettingsPages[r].name == k) return SettingsPages[r];
  return null;
}
function openByKey(k) {
  const r = getSettingsPage(k);
  r &&
    (openWindow("SettingsApp"),
    setTimeout(() => {
      currentSettingsPage.set(r);
    }));
}
const searchIcon = "./assets/arcfind-d60c3db2.svg";
let FILE_CACHE = [];
async function getSearchItems() {
  const k = compileSearchableApps(),
    r = compileSearchableSettingsPages(),
    p = POWER_OPTIONS,
    v = await getFiles();
  return [...k, ...r, ...p, ...v];
}
async function getFiles() {
  if (FILE_CACHE.length) return FILE_CACHE;
  const k = get_store_value(ConnectedServer);
  if (!k) return [];
  const r = [],
    v = (await apiCall(k, "fs/tree", {}, get_store_value(UserToken))).data;
  for (let $ = 0; $ < v.length; $++)
    r.push({
      caption: v[$].filename,
      action: async () => {
        const S = makeNotification({
            title: "Loading file",
            message: `Loading file ${v[$].filename} from the ArcAPI. This can take a while, depending on your internet connection and the size of the file.`,
            buttons: [],
            image: searchIcon,
          }),
          x = v[$].scopedPath;
        x.startsWith("./") && (v[$].scopedPath = x.replace("./", ""));
        const I = await openUserFile(v[$]);
        deleteNotification(S),
          closeNotification(),
          WindowStore.set(get_store_value(WindowStore)),
          I != !0 && openWithDialog({ ...I, anymime: !0 });
      },
      description: v[$].scopedPath.replace(`/${v[$].filename}`, ""),
      image: fileIcon,
    });
  return r;
}
function compileSearchableApps() {
  const k = [],
    r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++)
    r[p].info.hidden ||
      r[p].info.custom ||
      k.push({
        caption: r[p].info.name,
        description: r[p].info.description,
        image: r[p].info.icon,
        action: () => {
          openWindow(r[p].id);
        },
      });
  return k;
}
function compileSearchableSettingsPages() {
  const k = [],
    r = SettingsPages;
  for (let p = 0; p < r.length; p++) {
    const v = r[p];
    k.push({
      image: v.icon,
      caption: v.name,
      action: () => {
        openWindow("SettingsApp"),
          setTimeout(() => {
            currentSettingsPage.set(v);
          });
      },
    });
  }
  return k;
}
const POWER_OPTIONS = [
    {
      caption: "Shutdown",
      description: "Leave the desktop and turn off ArcOS",
      action: shutdown,
      image: shutdownIcon,
    },
    {
      caption: "Restart",
      description: "Leave the desktop and reload ArcOS",
      action: restart,
      image: shutdownIcon,
    },
  ],
  showArcFind = writable(!1);
async function Search(k) {
  const r = await getSearchItems(),
    p = { includeScore: !0, keys: ["caption", "description"] };
  return new Fuse(r, p).search(k);
}
const startOpened = writable(!1),
  loggingOff = writable(!1),
  shuttingDown = writable(!1),
  restarting = writable(!1),
  showDesktop = writable(!1),
  desktopClassNames = writable("");
function assignDesktopListeners() {
  UserData.subscribe((k) => {
    if (k) {
      const r = k;
      let p = "";
      r.sh.taskbar.docked && (p += "tbdocked "),
        r.sh.anim || (p += "noani "),
        r.sh.noGlass && (p += "noglass "),
        r.sh.window.bigtb && (p += "bigtitlebars "),
        r.sh.desktop.sharp && (p += "sharp "),
        desktopClassNames.set(p);
    }
  }),
    AppPokerData.subscribe((k) => {
      k ? openWindow("AppPoker") : closeWindow("AppPoker");
    }),
    loggingOff.subscribe((k) => {
      k &&
        (showDesktop.set(!1),
        setTimeout(() => {
          applyState("logoff"), loggingOff.set(!1);
        }, 500));
    }),
    restarting.subscribe((k) => {
      k &&
        (showDesktop.set(!1),
        setTimeout(() => {
          applyState("restart"), restarting.set(!1);
        }, 500));
    }),
    shuttingDown.subscribe((k) => {
      k &&
        (showDesktop.set(!1),
        setTimeout(() => {
          applyState("shutdown"), shuttingDown.set(!1);
        }, 500));
    }),
    registerShortcuts([
      {
        key: "q",
        alt: !0,
        action() {
          getOpenedStore().length
            ? (getWindow(get_store_value(focusedWindowId)).state.windowState
                .fll && isFullscreenWindow.set(!1),
              closeWindow(get_store_value(focusedWindowId)))
            : openWindow("Exit"),
            startOpened.set(!1),
            ActionCenterOpened.set(!1),
            CurrentNotification.set(null),
            focusedWindowId.set(null);
        },
        global: !0,
      },
      {
        key: "r",
        alt: !0,
        shift: !0,
        action() {
          startOpened.set(!1),
            ActionCenterOpened.set(!1),
            reloadApps(),
            setTimeout(() => {
              isFullscreenWindow.set(!0);
            }, 100),
            setTimeout(() => {
              isFullscreenWindow.set(!1);
            }, 1e3);
        },
        global: !0,
      },
      {
        key: "s",
        shift: !0,
        alt: !0,
        global: !0,
        action: () => {
          showArcFind.set(!get_store_value(showArcFind));
        },
      },
      {
        key: "n",
        alt: !0,
        global: !0,
        action: () => {
          ActionCenterOpened.set(!get_store_value(ActionCenterOpened));
        },
      },
      {
        key: "z",
        alt: !0,
        shift: !0,
        global: !0,
        action: () => {
          openWindow("AppMan");
        },
      },
    ]);
}
function openWindow(k, r = !1) {
  Log({
    msg: `Opening ${k}`,
    source: "events.ts: openWindow",
    level: LogLevel.info,
  });
  const p = getWindow(k);
  if (!isLoaded(k) || isOpened(k)) {
    const $ = getWindowElement(p);
    if (!$) return;
    maxZIndex.set(get_store_value(maxZIndex) + 1),
      ($.style.zIndex = `${get_store_value(maxZIndex)}`);
    return;
  }
  if (p.parentId && !isOpened(p.parentId)) {
    if (!r)
      return (
        Log({
          source: "events.ts: openWindow",
          msg: `The parent "${p.parentId}" of child window "${p.id}" must be opened before the child can be opened.`,
          level: LogLevel.error,
        }),
        !1
      );
    openWindow(p.parentId);
  }
  const v = get_store_value(WindowStore);
  for (let $ = 0; $ < v.length; $++) v[$].id == k && (v[$].opened = !0);
  return (
    WindowStore.set(v),
    setTimeout(() => {
      const $ = getWindowElement(p);
      $ &&
        (maxZIndex.set(get_store_value(maxZIndex) + 1),
        ($.style.zIndex = `${get_store_value(maxZIndex)}`),
        focusedWindowId.set(k));
    }, 10),
    startOpened.set(!1),
    ActionCenterOpened.set(!1),
    updateStores(),
    focusedWindowId.set(k),
    p.events && p.events.open && p.events.open(p),
    !0
  );
}
function openChildWindow(k, r) {
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++)
    if (p[v].parentId == k && p[v].id == r) return openWindow(r), !0;
  return !1;
}
function closeChildWindow(k, r) {
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++)
    if (p[v].parentId == k.id && p[v].id == r) return closeWindow(r), !0;
  return !1;
}
function closeWindow(k) {
  if (
    (Log({
      msg: `Closing ${k}`,
      source: "events.ts: closeWindow",
      level: LogLevel.info,
    }),
    !isOpened(k))
  )
    return !1;
  const r = get_store_value(WindowStore),
    p = getWindow(k);
  for (let v = 0; v < r.length; v++)
    if (r[v] && r[v].id == k) {
      (r[v].opened = !1), (r[v].openedFile = null);
      break;
    }
  if (p.children) {
    const v = Object.entries(p.children);
    for (let $ = 0; $ < v.length; $++) closeChildWindow(p, v[$][0]);
  }
  if (p.errorOverlays)
    for (let v = 0; v < p.errorOverlays.length; v++)
      destroyOverlayableError(p.errorOverlays[v].id, p.id);
  if (p.overlays) {
    const v = Object.entries(p.overlays);
    for (let $ = 0; $ < v.length; $++) hideOverlay(v[$][0], k);
  }
  return (
    (p.snapped = !1),
    WindowStore.set(r),
    p.events && p.events.close && p.events.close(p),
    !0
  );
}
function maximizeWindow(k) {
  Log({
    msg: `Switching maximized state of ${k.id}`,
    source: "events.ts: maximizeWindow",
    level: LogLevel.info,
  }),
    (k.state.windowState.max = !k.state.windowState.max),
    focusedWindowId.set(k.id),
    k.events && k.events.maximize && k.events.maximize(k),
    updateStores();
}
function minimizeWindow(k) {
  if (
    (Log({
      msg: `Switching minimized state of ${k.id}`,
      source: "events.ts: minimizeWindow",
      level: LogLevel.info,
    }),
    (k.state.windowState.min = !k.state.windowState.min),
    focusedWindowId.set(null),
    k.state.windowState.min)
  ) {
    const r = getWindowElement(k);
    r.style.zIndex = "0";
  }
  k.events && k.events.minimize && k.events.minimize(k), updateStores();
}
function fullscreenWindow(k) {
  Log({
    msg: `Switching fullscreen state of ${k.id}`,
    source: "events.ts: fullscreenWindow",
    level: LogLevel.info,
  }),
    (k.state.windowState.fll = !k.state.windowState.fll),
    focusedWindowId.set(k.id),
    k.events &&
      k.events.enterFullscreen &&
      k.state.windowState.fll &&
      k.events.enterFullscreen(k),
    k.events &&
      k.events.leaveFullscreen &&
      !k.state.windowState.fll &&
      k.events.leaveFullscreen(k),
    updateStores();
}
function headlessToggle(k) {
  Log({
    msg: `Switching headless state of ${k.id}`,
    source: "events.ts: headlessToggle",
    level: LogLevel.info,
  }),
    (k.state.headless = !k.state.headless),
    focusedWindowId.set(k.id),
    updateStores();
}
function fullscreenToggle(k) {
  Log({
    msg: `Switching fullscreen state of ${k}`,
    source: "events.ts: fullscreenToggle",
    level: LogLevel.info,
  });
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++)
    r[p].id == k && (r[p].state.windowState.fll = !r[p].state.windowState.fll);
  WindowStore.set(r);
}
function shutdown() {
  let k = 0;
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++)
    (k += 50),
      setTimeout(() => {
        closeWindow(r[p].id);
      }, k);
  logoffToken(), shuttingDown.set(!0);
}
function restart(k = !1) {
  let r = 0;
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++)
    (r += 50),
      setTimeout(() => {
        closeWindow(p[v].id);
      }, r);
  k && (localStorage.removeItem("arcos-remembered-token"), logoffToken()),
    restarting.set(!0);
}
const source = "UserLogic: UserData watch";
let commitTimeout;
function commitUserdata(k) {
  if (k) {
    if (
      (clearTimeout(commitTimeout),
      committingUserData.set(!0),
      get_store_value(UserName))
    ) {
      Log({ level: LogLevel.info, msg: "Change Detected, committing", source }),
        DevModeOverride.set(k.devmode);
      const r = setUserdata(k);
      unsetStatus(),
        r ||
          (Log({
            level: LogLevel.error,
            msg: "Commit failed, setter returned false",
            source,
          }),
          get_store_value(BugReportData) || commitFailed());
      return;
    }
    unsetStatus(),
      Log({ level: LogLevel.warn, msg: "Not committing, no username", source });
  }
}
function unsetStatus() {
  commitTimeout = setTimeout(() => {
    committingUserData.set(!1);
  }, 1500);
}
function commitFailed() {
  BugReportData.set([
    !0,
    {
      icon: "person_off",
      title: "User data commit failed",
      message:
        "The user data could not be saved. This happens if the<br>user data is altered while ArcOS is running.",
      details: "UserLogic: UserData watch: setter returned false",
      button: {
        action: () => {
          applyState("fts");
        },
        caption: "Reset",
      },
    },
  ]);
}
const committingUserData = writable(!1);
async function getUsers() {
  Log({
    msg: "Getting users",
    source: "userlogic/main.ts: getUsers",
    level: LogLevel.info,
  });
  const k = get_store_value(ConnectedServer);
  if (!k) return [];
  const r = await apiCall(k, "users/get", {}, null, null);
  let p = {};
  const v = r.data;
  for (let $ = 0; $ < v.length; $++) p[v[$].username] = v[$];
  return p;
}
async function deleteUser() {
  Log({
    msg: "Delete users",
    source: "userlogic/main.ts: deleteUsers",
    level: LogLevel.info,
  });
  const k = get_store_value(ConnectedServer),
    r = get_store_value(UserToken);
  k &&
    (apiCall(k, "user/delete", {}, r),
    get_store_value(CurrentState).name == "Desktop" && restart());
}
async function getUserdata(k) {
  Log({
    msg: `Getting userdata for "${k}"`,
    source: "userlogic/main.ts: getUserdata",
    level: LogLevel.info,
  });
  const r = await getUsers();
  if (r[k]) return r[k];
}
async function setUserdata(k) {
  Log({
    msg: "Setting userdata",
    source: "userlogic/main.ts: setUserdata",
    level: LogLevel.info,
  });
  const r = get_store_value(ConnectedServer);
  if (!r) return !1;
  (
    await apiCall(
      r,
      "user/properties/update",
      {},
      get_store_value(UserToken),
      null,
      JSON.stringify(k)
    )
  ).valid &&
    Log({
      msg: "Userdata committed to API",
      source: "userlogic/main.ts: setUserdata",
      level: LogLevel.info,
    });
}
UserData.subscribe(commitUserdata);
function create_if_block$o(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j;
  return (
    (p = new ProfilePicture$1({ props: { src: k[3], height: 151 } })),
    (F = new Spinner({ props: { height: 23 } })),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          ($ = element("h1")),
          (S = text(k[1])),
          (x = space()),
          (I = element("h3")),
          create_component(F.$$.fragment),
          (O = text("")),
          (L = element("span")),
          (U = text(k[0])),
          attr(r, "class", "userlogin show");
      },
      m(N, q) {
        insert(N, r, q),
          mount_component(p, r, null),
          append(r, v),
          append(r, $),
          append($, S),
          append(r, x),
          append(r, I),
          mount_component(F, I, null),
          append(I, O),
          append(I, L),
          append(L, U),
          (j = !0);
      },
      p(N, q) {
        const R = {};
        q & 8 && (R.src = N[3]),
          p.$set(R),
          (!j || q & 2) && set_data(S, N[1]),
          (!j || q & 1) && set_data(U, N[0]);
      },
      i(N) {
        j ||
          (transition_in(p.$$.fragment, N),
          transition_in(F.$$.fragment, N),
          (j = !0));
      },
      o(N) {
        transition_out(p.$$.fragment, N),
          transition_out(F.$$.fragment, N),
          (j = !1);
      },
      d(N) {
        N && detach(r), destroy_component(p), destroy_component(F);
      },
    }
  );
}
function create_fragment$L(k) {
  let r,
    p,
    v = k[2] && k[3] && create_if_block$o(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, [S]) {
      $[2] && $[3]
        ? v
          ? (v.p($, S), S & 12 && transition_in(v, 1))
          : ((v = create_if_block$o($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function instance$H(k, r, p) {
  let v, $;
  component_subscribe(k, UserName, (L) => p(5, (v = L))),
    component_subscribe(k, loginUsername, (L) => p(6, ($ = L)));
  let { caption: S } = r,
    { username: x = "" } = r,
    I = "",
    F,
    O = "";
  return (
    onMount(async () => {
      p(1, (I = $ || v || x)),
        p(2, (F = await getUserdata(I))),
        p(3, (O = await getUserPfp(I))),
        O == pfp && p(3, (O = logo$c));
    }),
    (k.$$set = (L) => {
      "caption" in L && p(0, (S = L.caption)),
        "username" in L && p(4, (x = L.username));
    }),
    [S, I, F, O, x]
  );
}
class Loading extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$H, create_fragment$L, safe_not_equal, {
        caption: 0,
        username: 4,
      });
  }
}
function create_fragment$K(k) {
  let r, p;
  return (
    (r = new Loading({ props: { caption: "Welcome" } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
class AutoLogin extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$K, safe_not_equal, {});
  }
}
const userlogin = "";
function flush() {
  UserName.set(void 0),
    loginUsername.set(void 0),
    NotificationStore.set({}),
    ErrorMessages.set([]),
    DevModeOverride.set(!1);
}
function create_fragment$J(k) {
  let r, p;
  return (
    (r = new Loading({ props: { caption: "Goodbye", username: k[0] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, [$]) {
        const S = {};
        $ & 1 && (S.username = v[0]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function instance$G(k, r, p) {
  let v;
  return (
    component_subscribe(k, UserName, ($) => p(0, (v = $))),
    onMount(() => {
      setTimeout(() => {
        flush(), applyLoginState("selector");
      }, 2e3);
    }),
    [v]
  );
}
class Logoff extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$G, create_fragment$J, safe_not_equal, {});
  }
}
function create_fragment$I(k) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.textContent = "Cancel"),
        attr(r, "class", "switchuser"),
        toggle_class(r, "show", k[0]);
    },
    m($, S) {
      insert($, r, S), p || ((v = listen(r, "click", k[1])), (p = !0));
    },
    p($, [S]) {
      S & 1 && toggle_class(r, "show", $[0]);
    },
    i: noop$1,
    o: noop$1,
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function instance$F(k, r, p) {
  let { show: v } = r;
  const $ = () => applyLoginState("selector");
  return (
    (k.$$set = (S) => {
      "show" in S && p(0, (v = S.show));
    }),
    [v, $]
  );
}
class Cancel extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$F, create_fragment$I, safe_not_equal, { show: 0 });
  }
}
function create_fragment$H(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H, G;
  return (
    (r = new ProfilePicture$1({ props: { src: pfp, height: 151 } })),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          (v = element("h1")),
          (v.textContent = "New user"),
          ($ = space()),
          (S = element("form")),
          (x = element("input")),
          (I = space()),
          (F = element("div")),
          (O = element("form")),
          (L = element("input")),
          (j = space()),
          (N = element("button")),
          (q = text("arrow_forward_ios")),
          attr(x, "type", "text"),
          attr(x, "placeholder", "Username"),
          attr(x, "class", "block"),
          (x.disabled = k[0]),
          attr(L, "type", "password"),
          attr(L, "placeholder", "Password"),
          attr(L, "class", "block"),
          (L.disabled = U = k[0] || !k[1]),
          (N.disabled = R = k[0] || !k[1] || !k[2]),
          attr(N, "class", "createbutton material-icons-round"),
          attr(F, "class", "input-wrapper");
      },
      m(V, K) {
        mount_component(r, V, K),
          insert(V, p, K),
          insert(V, v, K),
          insert(V, $, K),
          insert(V, S, K),
          append(S, x),
          set_input_value(x, k[1]),
          insert(V, I, K),
          insert(V, F, K),
          append(F, O),
          append(O, L),
          set_input_value(L, k[2]),
          append(F, j),
          append(F, N),
          append(N, q),
          (Q = !0),
          H ||
            ((G = [
              listen(x, "input", k[4]),
              listen(S, "submit", k[3]),
              listen(L, "input", k[5]),
              listen(O, "submit", k[3]),
              listen(N, "click", k[3]),
            ]),
            (H = !0));
      },
      p(V, [K]) {
        (!Q || K & 1) && (x.disabled = V[0]),
          K & 2 && x.value !== V[1] && set_input_value(x, V[1]),
          (!Q || (K & 3 && U !== (U = V[0] || !V[1]))) && (L.disabled = U),
          K & 4 && L.value !== V[2] && set_input_value(L, V[2]),
          (!Q || (K & 7 && R !== (R = V[0] || !V[1] || !V[2]))) &&
            (N.disabled = R);
      },
      i(V) {
        Q || (transition_in(r.$$.fragment, V), (Q = !0));
      },
      o(V) {
        transition_out(r.$$.fragment, V), (Q = !1);
      },
      d(V) {
        destroy_component(r, V),
          V && detach(p),
          V && detach(v),
          V && detach($),
          V && detach(S),
          V && detach(I),
          V && detach(F),
          (H = !1),
          run_all(G);
      },
    }
  );
}
function instance$E(k, r, p) {
  let v;
  component_subscribe(k, ConnectedServer, (L) => p(6, (v = L)));
  let { loading: $ } = r,
    { username: S } = r,
    { password: x } = r;
  async function I(L) {
    if ((L && L.preventDefault(), !S || !x || $)) return !1;
    loginUsername.set(S),
      p(0, ($ = !0)),
      await apiCall(v, "user/create", {}, null, { username: S, password: x });
    const U = await loginUsingCreds(
      generateCredToken({ username: S, password: x })
    );
    return U
      ? (UserData.set(U), UserName.set(S), applyState("desktop"), !1)
      : p(0, ($ = !1));
  }
  function F() {
    (S = this.value), p(1, S);
  }
  function O() {
    (x = this.value), p(2, x);
  }
  return (
    (k.$$set = (L) => {
      "loading" in L && p(0, ($ = L.loading)),
        "username" in L && p(1, (S = L.username)),
        "password" in L && p(2, (x = L.password));
    }),
    [$, S, x, I, F, O]
  );
}
class Form extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$E, create_fragment$H, safe_not_equal, {
        loading: 0,
        username: 1,
        password: 2,
      });
  }
}
function create_else_block$6(k) {
  let r, p;
  return (
    (r = new Loading({ props: { caption: "Welcome" } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_1$7(k) {
  let r, p, v, $, S;
  function x(L) {
    k[4](L);
  }
  function I(L) {
    k[5](L);
  }
  function F(L) {
    k[6](L);
  }
  let O = {};
  return (
    k[2] !== void 0 && (O.loading = k[2]),
    k[0] !== void 0 && (O.username = k[0]),
    k[1] !== void 0 && (O.password = k[1]),
    (r = new Form({ props: O })),
    binding_callbacks.push(() => bind$1(r, "loading", x)),
    binding_callbacks.push(() => bind$1(r, "username", I)),
    binding_callbacks.push(() => bind$1(r, "password", F)),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(L, U) {
        mount_component(r, L, U), (S = !0);
      },
      p(L, U) {
        const j = {};
        !p &&
          U & 4 &&
          ((p = !0), (j.loading = L[2]), add_flush_callback(() => (p = !1))),
          !v &&
            U & 1 &&
            ((v = !0), (j.username = L[0]), add_flush_callback(() => (v = !1))),
          !$ &&
            U & 2 &&
            (($ = !0), (j.password = L[1]), add_flush_callback(() => ($ = !1))),
          r.$set(j);
      },
      i(L) {
        S || (transition_in(r.$$.fragment, L), (S = !0));
      },
      o(L) {
        transition_out(r.$$.fragment, L), (S = !1);
      },
      d(L) {
        destroy_component(r, L);
      },
    }
  );
}
function create_if_block$n(k) {
  let r, p;
  return (
    (r = new Cancel({ props: { show: k[3] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 8 && (S.show = v[3]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$G(k) {
  let r, p, v, $, S, x;
  const I = [create_if_block_1$7, create_else_block$6],
    F = [];
  function O(U, j) {
    return U[2] ? 1 : 0;
  }
  (p = O(k)), (v = F[p] = I[p](k));
  let L = !k[2] && create_if_block$n(k);
  return {
    c() {
      (r = element("div")),
        v.c(),
        ($ = space()),
        L && L.c(),
        (S = empty()),
        attr(r, "class", "userlogin newuser"),
        toggle_class(r, "show", k[3]);
    },
    m(U, j) {
      insert(U, r, j),
        F[p].m(r, null),
        insert(U, $, j),
        L && L.m(U, j),
        insert(U, S, j),
        (x = !0);
    },
    p(U, [j]) {
      let N = p;
      (p = O(U)),
        p === N
          ? F[p].p(U, j)
          : (group_outros(),
            transition_out(F[N], 1, 1, () => {
              F[N] = null;
            }),
            check_outros(),
            (v = F[p]),
            v ? v.p(U, j) : ((v = F[p] = I[p](U)), v.c()),
            transition_in(v, 1),
            v.m(r, null)),
        (!x || j & 8) && toggle_class(r, "show", U[3]),
        U[2]
          ? L &&
            (group_outros(),
            transition_out(L, 1, 1, () => {
              L = null;
            }),
            check_outros())
          : L
          ? (L.p(U, j), j & 4 && transition_in(L, 1))
          : ((L = create_if_block$n(U)),
            L.c(),
            transition_in(L, 1),
            L.m(S.parentNode, S));
    },
    i(U) {
      x || (transition_in(v), transition_in(L), (x = !0));
    },
    o(U) {
      transition_out(v), transition_out(L), (x = !1);
    },
    d(U) {
      U && detach(r), F[p].d(), U && detach($), L && L.d(U), U && detach(S);
    },
  };
}
function instance$D(k, r, p) {
  let v = "",
    $ = "",
    S = !1,
    x = !1;
  onMount(() => {
    setTimeout(() => {
      p(3, (x = !0));
    });
  });
  function I(L) {
    (S = L), p(2, S);
  }
  function F(L) {
    (v = L), p(0, v);
  }
  function O(L) {
    ($ = L), p(1, $);
  }
  return [v, $, S, x, I, F, O];
}
class NewApiUser extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$D, create_fragment$G, safe_not_equal, {});
  }
}
function create_fragment$F(k) {
  let r, p;
  return (
    (r = new Loading({ props: { caption: "Restarting" } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function instance$C(k) {
  return (
    setTimeout(() => {
      location.reload();
    }, 2e3),
    []
  );
}
class Restart extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$C, create_fragment$F, safe_not_equal, {});
  }
}
function create_fragment$E(k) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.textContent = "Create Account"),
        attr(r, "class", "createacc");
    },
    m($, S) {
      insert($, r, S), p || ((v = listen(r, "click", k[0])), (p = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d($) {
      $ && detach(r), (p = !1), v();
    },
  };
}
function instance$B(k) {
  return [() => applyLoginState("newapiuser")];
}
class CreateButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$B, create_fragment$E, safe_not_equal, {});
  }
}
function create_if_block$m(k) {
  let r, p, v, $, S, x, I, F;
  return (
    (p = new ProfilePicture$1({ props: { src: k[2], height: 76 } })),
    {
      c() {
        (r = element("button")),
          create_component(p.$$.fragment),
          (v = space()),
          ($ = element("p")),
          (S = text(k[1])),
          attr($, "class", "username"),
          attr(r, "class", "user");
      },
      m(O, L) {
        insert(O, r, L),
          mount_component(p, r, null),
          append(r, v),
          append(r, $),
          append($, S),
          (x = !0),
          I || ((F = listen(r, "click", k[3])), (I = !0));
      },
      p(O, L) {
        const U = {};
        L & 4 && (U.src = O[2]), p.$set(U), (!x || L & 2) && set_data(S, O[1]);
      },
      i(O) {
        x || (transition_in(p.$$.fragment, O), (x = !0));
      },
      o(O) {
        transition_out(p.$$.fragment, O), (x = !1);
      },
      d(O) {
        O && detach(r), destroy_component(p), (I = !1), F();
      },
    }
  );
}
function create_fragment$D(k) {
  let r,
    p,
    v = k[0].acc.enabled && create_if_block$m(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, [S]) {
      $[0].acc.enabled
        ? v
          ? (v.p($, S), S & 1 && transition_in(v, 1))
          : ((v = create_if_block$m($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function instance$A(k, r, p) {
  let v = "",
    { data: $ } = r,
    { name: S } = r;
  function x() {
    loginUsername.set(S), applyLoginState("todesktop");
  }
  return (
    onMount(() => {
      p(2, (v = getProfilePicture($.acc.profilePicture)));
    }),
    (k.$$set = (I) => {
      "data" in I && p(0, ($ = I.data)), "name" in I && p(1, (S = I.name));
    }),
    [$, S, v, x]
  );
}
class User extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$A, create_fragment$D, safe_not_equal, {
        data: 0,
        name: 1,
      });
  }
}
function get_each_context$8(k, r, p) {
  const v = k.slice();
  return (v[1] = r[p]), v;
}
function create_if_block$l(k) {
  let r,
    p,
    v = Object.keys(k[0]),
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$8(get_each_context$8(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = empty();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 1) {
        v = Object.keys(x[0]);
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$8(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$8(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_each_block$8(k) {
  let r, p;
  return (
    (r = new User({ props: { data: k[0][k[1]], name: k[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.data = v[0][v[1]]), $ & 1 && (S.name = v[1]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$C(k) {
  let r,
    p,
    v = k[0] && create_if_block$l(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, [S]) {
      $[0]
        ? v
          ? (v.p($, S), S & 1 && transition_in(v, 1))
          : ((v = create_if_block$l($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function instance$z(k, r, p) {
  let v;
  return (
    onMount(async () => {
      p(0, (v = await getUsers()));
    }),
    [v]
  );
}
class Populator extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$z, create_fragment$C, safe_not_equal, {});
  }
}
function create_fragment$B(k) {
  let r, p, v, $, S;
  return (
    (p = new Populator({})),
    ($ = new CreateButton({})),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          create_component($.$$.fragment),
          attr(r, "class", "user-selector");
      },
      m(x, I) {
        insert(x, r, I),
          mount_component(p, r, null),
          append(r, v),
          mount_component($, r, null),
          (S = !0);
      },
      p: noop$1,
      i(x) {
        S ||
          (transition_in(p.$$.fragment, x),
          transition_in($.$$.fragment, x),
          (S = !0));
      },
      o(x) {
        transition_out(p.$$.fragment, x),
          transition_out($.$$.fragment, x),
          (S = !1);
      },
      d(x) {
        x && detach(r), destroy_component(p), destroy_component($);
      },
    }
  );
}
class Selector extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$B, safe_not_equal, {});
  }
}
function create_fragment$A(k) {
  let r, p;
  return (
    (r = new Loading({ props: { caption: "Shutting down" } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function instance$y(k) {
  return (
    onMount(() => {
      setTimeout(() => {
        flush(), applyState("turnedoff");
      }, 2e3);
    }),
    []
  );
}
class Shutdown extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$y, create_fragment$A, safe_not_equal, {});
  }
}
function create_fragment$z(k) {
  let r, p, v, $, S, x, I, F;
  return {
    c() {
      (r = element("form")),
        (p = element("input")),
        (v = space()),
        ($ = element("button")),
        (S = text("arrow_forward_ios")),
        (p.autofocus = !0),
        attr(p, "type", "password"),
        attr(p, "placeholder", "Password"),
        toggle_class(p, "wrongpswd", k[1]),
        attr($, "class", "material-icons-round"),
        ($.disabled = x = !k[0]);
    },
    m(O, L) {
      insert(O, r, L),
        append(r, p),
        set_input_value(p, k[0]),
        insert(O, v, L),
        insert(O, $, L),
        append($, S),
        p.focus(),
        I ||
          ((F = [
            listen(p, "input", k[7]),
            listen(p, "input", k[8]),
            listen(r, "submit", k[2]),
            listen($, "click", k[3]),
          ]),
          (I = !0));
    },
    p(O, [L]) {
      L & 1 && p.value !== O[0] && set_input_value(p, O[0]),
        L & 2 && toggle_class(p, "wrongpswd", O[1]),
        L & 1 && x !== (x = !O[0]) && ($.disabled = x);
    },
    i: noop$1,
    o: noop$1,
    d(O) {
      O && detach(r), O && detach(v), O && detach($), (I = !1), run_all(F);
    },
  };
}
function instance$x(k, r, p) {
  let v;
  component_subscribe(k, loginUsername, (N) => p(9, (v = N)));
  let { authenticating: $ } = r,
    { stay: S } = r,
    x,
    I = !1,
    { pfp: F = "" } = r;
  onMount(async () => {
    v || applyLoginState("selector"), p(5, (F = await getUserPfp(v)));
  });
  function O(N) {
    return N.preventDefault(), L(), !1;
  }
  async function L() {
    p(4, ($ = !0));
    const N = await loginUsingCreds(
      generateCredToken({ username: v, password: x })
    );
    if (!N) {
      p(4, ($ = !1)), p(1, (I = !0));
      return;
    }
    S && localStorage.setItem("arcos-remembered-token", btoa(`${v}:${x}`)),
      UserData.set(N),
      UserName.set(v),
      applyState("desktop");
  }
  function U() {
    (x = this.value), p(0, x);
  }
  const j = () => p(1, (I = !1));
  return (
    (k.$$set = (N) => {
      "authenticating" in N && p(4, ($ = N.authenticating)),
        "stay" in N && p(6, (S = N.stay)),
        "pfp" in N && p(5, (F = N.pfp));
    }),
    [x, I, O, L, $, F, S, U, j]
  );
}
class Input extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$x, create_fragment$z, safe_not_equal, {
        authenticating: 4,
        stay: 6,
        pfp: 5,
      });
  }
}
function create_fragment$y(k) {
  let r, p, v, $, S, x;
  return {
    c() {
      (r = element("span")),
        (p = element("input")),
        (v = space()),
        ($ = element("label")),
        ($.textContent = "Stay logged in"),
        attr(p, "type", "checkbox"),
        attr(p, "id", "rememberme"),
        attr($, "for", "rememberme"),
        attr(r, "class", "keep-loggedin-wrapper");
    },
    m(I, F) {
      insert(I, r, F),
        append(r, p),
        set_input_value(p, k[0]),
        append(r, v),
        append(r, $),
        S || ((x = listen(p, "change", k[1])), (S = !0));
    },
    p(I, [F]) {
      F & 1 && set_input_value(p, I[0]);
    },
    i: noop$1,
    o: noop$1,
    d(I) {
      I && detach(r), (S = !1), x();
    },
  };
}
function instance$w(k, r, p) {
  let { stay: v } = r;
  onMount(() => {
    p(0, (v = !0));
  });
  function $() {
    (v = this.value), p(0, v);
  }
  return (
    (k.$$set = (S) => {
      "stay" in S && p(0, (v = S.stay));
    }),
    [v, $]
  );
}
class Stay extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$w, create_fragment$y, safe_not_equal, { stay: 0 });
  }
}
function create_if_block_1$6(k) {
  let r, p, v, $, S;
  return (
    (r = new ProfilePicture$1({ props: { src: k[2], height: 151 } })),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          (v = element("h1")),
          ($ = text(k[3]));
      },
      m(x, I) {
        mount_component(r, x, I),
          insert(x, p, I),
          insert(x, v, I),
          append(v, $),
          (S = !0);
      },
      p(x, I) {
        const F = {};
        I & 4 && (F.src = x[2]), r.$set(F), (!S || I & 8) && set_data($, x[3]);
      },
      i(x) {
        S || (transition_in(r.$$.fragment, x), (S = !0));
      },
      o(x) {
        transition_out(r.$$.fragment, x), (S = !1);
      },
      d(x) {
        destroy_component(r, x), x && detach(p), x && detach(v);
      },
    }
  );
}
function create_else_block$5(k) {
  let r, p;
  return (
    (r = new Loading({ props: { caption: "Welcome" } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$k(k) {
  let r, p, v, $, S, x, I;
  function F(L) {
    k[8](L);
  }
  let O = {};
  return (
    k[1] !== void 0 && (O.stay = k[1]),
    (r = new Stay({ props: O })),
    binding_callbacks.push(() => bind$1(r, "stay", F)),
    {
      c() {
        create_component(r.$$.fragment),
          (v = space()),
          ($ = element("button")),
          ($.textContent = "Cancel"),
          attr($, "class", "switchuser");
      },
      m(L, U) {
        mount_component(r, L, U),
          insert(L, v, U),
          insert(L, $, U),
          (S = !0),
          x || ((I = listen($, "click", k[4])), (x = !0));
      },
      p(L, U) {
        const j = {};
        !p &&
          U & 2 &&
          ((p = !0), (j.stay = L[1]), add_flush_callback(() => (p = !1))),
          r.$set(j);
      },
      i(L) {
        S || (transition_in(r.$$.fragment, L), (S = !0));
      },
      o(L) {
        transition_out(r.$$.fragment, L), (S = !1);
      },
      d(L) {
        destroy_component(r, L), L && detach(v), L && detach($), (x = !1), I();
      },
    }
  );
}
function create_fragment$x(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L,
    U,
    j = !k[0] && create_if_block_1$6(k);
  function N(K) {
    k[5](K);
  }
  function q(K) {
    k[6](K);
  }
  function R(K) {
    k[7](K);
  }
  let Q = {};
  k[1] !== void 0 && (Q.stay = k[1]),
    k[0] !== void 0 && (Q.authenticating = k[0]),
    k[2] !== void 0 && (Q.pfp = k[2]),
    ($ = new Input({ props: Q })),
    binding_callbacks.push(() => bind$1($, "stay", N)),
    binding_callbacks.push(() => bind$1($, "authenticating", q)),
    binding_callbacks.push(() => bind$1($, "pfp", R));
  const H = [create_if_block$k, create_else_block$5],
    G = [];
  function V(K, Y) {
    return K[0] ? 1 : 0;
  }
  return (
    (O = V(k)),
    (L = G[O] = H[O](k)),
    {
      c() {
        j && j.c(),
          (r = space()),
          (p = element("div")),
          (v = element("div")),
          create_component($.$$.fragment),
          (F = space()),
          L.c(),
          attr(v, "class", "field"),
          toggle_class(v, "hidden", k[0]),
          attr(p, "class", "cloudlogin");
      },
      m(K, Y) {
        j && j.m(K, Y),
          insert(K, r, Y),
          insert(K, p, Y),
          append(p, v),
          mount_component($, v, null),
          append(p, F),
          G[O].m(p, null),
          (U = !0);
      },
      p(K, [Y]) {
        K[0]
          ? j &&
            (group_outros(),
            transition_out(j, 1, 1, () => {
              j = null;
            }),
            check_outros())
          : j
          ? (j.p(K, Y), Y & 1 && transition_in(j, 1))
          : ((j = create_if_block_1$6(K)),
            j.c(),
            transition_in(j, 1),
            j.m(r.parentNode, r));
        const J = {};
        !S &&
          Y & 2 &&
          ((S = !0), (J.stay = K[1]), add_flush_callback(() => (S = !1))),
          !x &&
            Y & 1 &&
            ((x = !0),
            (J.authenticating = K[0]),
            add_flush_callback(() => (x = !1))),
          !I &&
            Y & 4 &&
            ((I = !0), (J.pfp = K[2]), add_flush_callback(() => (I = !1))),
          $.$set(J),
          (!U || Y & 1) && toggle_class(v, "hidden", K[0]);
        let Z = O;
        (O = V(K)),
          O === Z
            ? G[O].p(K, Y)
            : (group_outros(),
              transition_out(G[Z], 1, 1, () => {
                G[Z] = null;
              }),
              check_outros(),
              (L = G[O]),
              L ? L.p(K, Y) : ((L = G[O] = H[O](K)), L.c()),
              transition_in(L, 1),
              L.m(p, null));
      },
      i(K) {
        U ||
          (transition_in(j),
          transition_in($.$$.fragment, K),
          transition_in(L),
          (U = !0));
      },
      o(K) {
        transition_out(j),
          transition_out($.$$.fragment, K),
          transition_out(L),
          (U = !1);
      },
      d(K) {
        j && j.d(K),
          K && detach(r),
          K && detach(p),
          destroy_component($),
          G[O].d();
      },
    }
  );
}
function instance$v(k, r, p) {
  let v;
  component_subscribe(k, loginUsername, (j) => p(3, (v = j)));
  let $ = !0,
    { authenticating: S = !1 } = r,
    x;
  async function I() {
    loginUsername.set(void 0), applyLoginState("selector");
  }
  function F(j) {
    ($ = j), p(1, $);
  }
  function O(j) {
    (S = j), p(0, S);
  }
  function L(j) {
    (x = j), p(2, x);
  }
  function U(j) {
    ($ = j), p(1, $);
  }
  return (
    (k.$$set = (j) => {
      "authenticating" in j && p(0, (S = j.authenticating));
    }),
    [S, $, x, v, I, F, O, L, U]
  );
}
class AuthForm extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$v, create_fragment$x, safe_not_equal, {
        authenticating: 0,
      });
  }
}
function create_fragment$w(k) {
  let r, p, v, $;
  function S(I) {
    k[2](I);
  }
  let x = {};
  return (
    k[0] !== void 0 && (x.authenticating = k[0]),
    (p = new AuthForm({ props: x })),
    binding_callbacks.push(() => bind$1(p, "authenticating", S)),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          attr(r, "class", "userlogin"),
          toggle_class(r, "show", k[1]);
      },
      m(I, F) {
        insert(I, r, F), mount_component(p, r, null), ($ = !0);
      },
      p(I, [F]) {
        const O = {};
        !v &&
          F & 1 &&
          ((v = !0),
          (O.authenticating = I[0]),
          add_flush_callback(() => (v = !1))),
          p.$set(O),
          (!$ || F & 2) && toggle_class(r, "show", I[1]);
      },
      i(I) {
        $ || (transition_in(p.$$.fragment, I), ($ = !0));
      },
      o(I) {
        transition_out(p.$$.fragment, I), ($ = !1);
      },
      d(I) {
        I && detach(r), destroy_component(p);
      },
    }
  );
}
function instance$u(k, r, p) {
  let v = !1,
    $ = !1;
  onMount(async () => {
    setTimeout(() => {
      p(1, ($ = !0));
    }, 10);
  });
  function S(x) {
    (v = x), p(0, v);
  }
  return [v, $, S];
}
class UserLogin extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$u, create_fragment$w, safe_not_equal, {});
  }
}
const LoginStates = new Map([
    [
      "selector",
      {
        name: "User Selector",
        content: Selector,
        attribs: { topbar: !0, darken: !1 },
        key: "selector",
      },
    ],
    [
      "todesktop",
      {
        name: "Login Redirector -> Desktop",
        content: UserLogin,
        attribs: { topbar: !1, darken: !0 },
        key: "todesktop",
      },
    ],
    [
      "logoff",
      {
        name: "Desktop -> Logoff -> User Selector",
        content: Logoff,
        attribs: { topbar: !1, darken: !0 },
        key: "logoff",
      },
    ],
    [
      "shutdown",
      {
        name: "Desktop -> Logoff -> End",
        content: Shutdown,
        attribs: { topbar: !1, darken: !0 },
        key: "shutdown",
      },
    ],
    [
      "restart",
      {
        name: "Desktop -> Logoff -> Boot",
        content: Restart,
        attribs: { topbar: !1, darken: !0 },
        key: "restart",
      },
    ],
    [
      "newapiuser",
      {
        name: "New User",
        content: NewApiUser,
        attribs: { topbar: !1, darken: !0 },
        key: "newapiuser",
      },
    ],
    [
      "autologin",
      {
        name: "Auto Login",
        content: AutoLogin,
        attribs: { topbar: !1, darken: !0 },
        key: "autologin",
      },
    ],
  ]),
  CurrentLoginState = writable(),
  loginUsername = writable();
function applyLoginState(k) {
  if (LoginStates.has(k)) {
    Log({
      level: LogLevel.info,
      source: "login/main.ts: applyLoginState",
      msg: `Applying state ${k}`,
    });
    const r = LoginStates.get(k);
    CurrentLoginState.set(r);
    return;
  }
  InvalidStateBugrep("Login", k);
}
async function loginOnMount() {
  const k = await getUsers(),
    r = localStorage.getItem("arcos-remembered-token"),
    p = get_store_value(CurrentLoginState),
    v = get_store_value(ConnectedServer);
  if (
    (setTimeout(() => {
      p || applyLoginState(r ? "autologin" : "selector");
    }, 100),
    r && (!p || (p.key != "shutdown" && p.key != "restart")))
  ) {
    const $ = await loginUsingCreds(r),
      S = atob(r).split(":")[0];
    if (!$) {
      applyLoginState("selector"),
        localStorage.removeItem("arcos-remembered-token");
      return;
    }
    loginUsername.set(S),
      UserData.set($),
      UserName.set(S),
      setTimeout(() => {
        applyState("desktop");
      }, 2e3);
  }
  if (!Object.keys(k).length && !r) {
    v ? applyLoginState("newapiuser") : applyState("fts");
    return;
  }
}
async function loginUsingCreds(k) {
  let [r, p] = atob(k).split(":");
  const v = get_store_value(ConnectedServer);
  loginUsername.set(r);
  let $ = await apiCall(get_store_value(ConnectedServer), "auth", {}, null, {
    username: r,
    password: p,
  });
  return !$.valid ||
    (UserToken.set($.data.token),
    UserName.set(r),
    ($ = await apiCall(
      v,
      "user/properties",
      {},
      get_store_value(UserToken),
      null
    )),
    !$.valid)
    ? !1
    : $;
}
async function rememberedLogin() {
  const k = localStorage.getItem("arcos-remembered-token");
  if (!k) return !1;
  const [r, p] = atob(k).split(":"),
    v = await loginUsingCreds(generateCredToken({ username: r, password: p }));
  return v ? (UserData.set(v), UserName.set(r), !0) : !1;
}
function create_fragment$v(k) {
  let r, p, v;
  return {
    c() {
      (r = element("div")),
        (r.textContent = "authenticating with ArcAPI..."),
        attr(r, "id", "target"),
        attr(r, "class", "terminal-renderer");
    },
    m($, S) {
      insert($, r, S), k[2](r), p || ((v = listen(r, "click", k[1])), (p = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d($) {
      $ && detach(r), k[2](null), (p = !1), v();
    },
  };
}
function instance$t(k, r, p) {
  let v, $;
  component_subscribe(k, UserName, (O) => p(4, (v = O))),
    component_subscribe(k, UserData, (O) => p(5, ($ = O)));
  let S, x;
  onMount(async () => {
    await rememberedLogin(),
      setTimeout(async () => {
        if (!$)
          return (
            p(
              0,
              (x.innerText = `Authentication failed! Please make sure you check
'Stay logged in' at the login screen to enable this mode.

Restarting in 5 seconds...`),
              x
            ),
            setTimeout(() => location.reload(), 5e3)
          );
        const O = localStorage.getItem("arcos-server"),
          L = v,
          U = await getFSQuota(),
          j = formatBytes(U.used),
          N = formatBytes(U.max),
          q = ((100 / U.max) * U.used).toFixed(2);
        S = new ArcTerm$1(x, arcCommands, null, (R) => {
          R.util.writeColor(
            `[] You are currently in [ArcTerm mode].
[] Commands that require the ArcOS desktop have been disabled.`,
            "orange"
          ),
            R.util.writeColor(
              `
Authenticated as [${L}] at [${O}]
`,
              "aqua"
            ),
            R.util.writeColor(
              `
[ArcFS]: You are using [${j}] of [${N}] total (${q}%)`,
              "yellow"
            ),
            R.util.writeLine(`
`);
        });
      }, 100);
  });
  function I() {
    !S ||
      !S.input ||
      !S.input.current ||
      (S.input.current.focus(), x && x.scrollTo(0, x.scrollHeight));
  }
  setInterval(I, 10);
  function F(O) {
    binding_callbacks[O ? "unshift" : "push"](() => {
      (x = O), p(0, x);
    });
  }
  return [x, I, F];
}
class ArcTerm_1 extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$t, create_fragment$v, safe_not_equal, {});
  }
}
const Blank_svelte_svelte_type_style_lang = "";
function create_fragment$u(k) {
  let r;
  return {
    c() {
      (r = element("div")), attr(r, "class", "fullscreen svelte-1b10uke");
    },
    m(p, v) {
      insert(p, r, v);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
class Blank extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$u, safe_not_equal, {});
  }
}
const boot = "";
function ttlFetch(k, r, p = 3e3) {
  return new Promise((v, $) => {
    const S = setTimeout(() => {
      $(new Error("TIMEOUT"));
    }, p);
    fetch(k, r)
      .then((x) => {
        clearTimeout(S), v(x);
      })
      .catch((x) => {
        clearTimeout(S), $(x);
      });
  });
}
const TEST_MODES = [
  [!0, 443],
  [!1, 3333],
  [!0, 80],
  [!1, 80],
  [!0, 3333],
];
async function testConnection(k) {
  for (let r = 0; r < TEST_MODES.length; r++) {
    const p = `http${TEST_MODES[r][0] ? "s" : ""}`,
      v = TEST_MODES[r][1],
      $ = `${p}://${k}:${v}/connect`;
    Log({
      msg: `Testing ${k} on port ${v} and protocol ${p}...`,
      source: "api/test.ts: testConnection",
      level: LogLevel.info,
    });
    try {
      const S = await (await ttlFetch($, {})).json();
      return (
        Log({
          msg: `Got a response from URL ${$}`,
          source: "api/test.ts: testConnection",
          level: LogLevel.warn,
        }),
        ConnectedServer.set(`${p}://${k}:${v}`),
        S && !!S.valid
      );
    } catch {
      Log({
        msg: `Did not get a valid response from ${$}`,
        source: "api/test.ts: testConnection",
        level: LogLevel.error,
      });
      continue;
    }
  }
  return (
    Log({
      msg: `Can't connect to server ${k}: none of the modes match`,
      source: "api/test.ts: testConnection",
      level: LogLevel.critical,
    }),
    !1
  );
}
function checkZones(k, r, p) {
  const v = getBounds(),
    $ = getWindow(p);
  if (p.startsWith("error_")) return;
  const S = $.state.resizable || $.controls.max;
  if (!$ || !v) return;
  const x = v.lTrig,
    I = v.rTrig,
    F = S && k > x.xStart && k < x.xEnd && r > x.yStart && r < x.yEnd,
    O = S && k > I.xStart && k < I.xEnd && r > I.yStart && r < I.yEnd;
  leftZoneTriggered.set(F),
    rightZoneTriggered.set(O),
    draggingId.set(F || O ? p : null);
}
function getBounds() {
  const [k, r, p, v] = getZoneElements();
  if (!k || !r || !p || !v) return !1;
  const $ = document.body.offsetWidth;
  return {
    lTrig: {
      xStart: k.offsetLeft,
      xEnd: k.offsetLeft + k.offsetWidth,
      yStart: k.offsetTop,
      yEnd: k.offsetTop + k.offsetHeight,
    },
    rTrig: {
      xStart: $ - r.offsetWidth,
      xEnd: $,
      yStart: r.offsetTop,
      yEnd: r.offsetTop + r.offsetHeight,
    },
    lZone: {
      xStart: p.offsetLeft,
      xEnd: p.offsetLeft + p.offsetWidth,
      yStart: p.offsetTop,
      yEnd: p.offsetTop + p.offsetHeight,
    },
    rZone: {
      xStart: $ - v.offsetWidth,
      xEnd: $,
      yStart: v.offsetTop,
      yEnd: v.offsetTop + v.offsetHeight,
    },
  };
}
function getZoneElements() {
  const k = document.querySelector("div.snapzones #snapTriggerLeft"),
    r = document.querySelector("div.snapzones #snapTriggerRight"),
    p = document.querySelector("div.snapzones #snapZoneLeft"),
    v = document.querySelector("div.snapzones #snapZoneRight"),
    $ = [k, r, p, v];
  for (let S = 0; S < $.length; S++) if (!$[S]) return [null, null, null, null];
  return $;
}
function snapWindow(k) {
  const r = get_store_value(leftZoneTriggered),
    p = get_store_value(rightZoneTriggered);
  (r || p) && draggingId.set(k), r && snapLeft(), p && snapRight();
}
function snapLeft() {
  const [k, r, p] = getData();
  if (!p || !k) return;
  let [v, $, S, x] = [0, 0, 0, 0];
  const I = get_store_value(WindowStore);
  for (let F = 0; F < I.length; F++) {
    const O = I[F];
    O.id == r &&
      ((O.pos.x = v = k.lZone.xStart),
      (O.pos.y = $ = k.lZone.yStart),
      (O.size.w = S = k.lZone.xEnd),
      (O.size.h = x = k.lZone.yEnd),
      (O.snapped = !0));
  }
  WindowStore.set(I), commitWindow(p, v, $, S, x);
}
function getData() {
  const k = getBounds(),
    r = get_store_value(draggingId),
    p = getWindowElement(getWindow(r));
  return [k, r, p];
}
function snapRight() {
  const [k, r, p] = getData();
  if (!p || !k) return;
  let [v, $, S, x] = [0, 0, 0, 0];
  const I = get_store_value(WindowStore);
  for (let F = 0; F < I.length; F++) {
    const O = I[F];
    O.id == r &&
      ((O.pos.x = v = k.rZone.xStart),
      (O.pos.y = $ = k.rZone.yStart),
      (O.size.w = S = k.rZone.xEnd - k.rZone.xStart),
      (O.size.h = x = k.rZone.yEnd - k.rZone.yStart),
      (O.snapped = !0));
  }
  WindowStore.set(I), commitWindow(p, v, $, S, x);
}
function commitWindow(k, r, p, v, $) {
  setTimeout(() => {
    (k.style.left = r + "px"),
      (k.style.top = p + "px"),
      (k.style.width = v + "px"),
      (k.style.height = $ + "px"),
      openWindow(get_store_value(draggingId));
  }, 5);
}
function dragWindow(k, r, p) {
  if (!k || !r || !p)
    return Log({
      msg: `Can't drag ${k.id}: one or more required elements are missing!`,
      source: "drag.ts: dragWindow",
      level: LogLevel.error,
    });
  r.addEventListener("mousedown", (v) => {
    let $, S;
    if (
      !k.info.custom &&
      (focusedWindowId.set(k.id), v.composedPath().includes(p))
    ) {
      let x, I, F, O;
      v.preventDefault(),
        (document.onmousemove = (L) => {
          (k.snapped = !1),
            WindowStore.set(get_store_value(WindowStore)),
            (x = F - L.clientX),
            (I = O - L.clientY),
            (F = L.clientX),
            (O = L.clientY);
          let U = r.offsetTop - I;
          const j = r.offsetLeft - x;
          U < 0 && (U = 0),
            (r.style.top = U + "px"),
            (r.style.left = j + "px"),
            (k.pos.x = j),
            (k.pos.y = U),
            checkZones(F, O, k.id),
            ([$, S] = [F, O]);
        }),
        (document.onmouseup = () => {
          checkZones($, S, k.id),
            snapWindow(k.id),
            leftZoneTriggered.set(!1),
            rightZoneTriggered.set(!1),
            (document.onmouseup = null),
            (document.onmousemove = null);
        });
    }
  });
}
function maxSizeExceedsLiteral(k) {}
function minSizeExceedsLiteral(k) {}
const error = "";
function get_each_context$7(k, r, p) {
  const v = k.slice();
  return (v[6] = r[p]), v;
}
function create_if_block$j(k) {
  let r, p, v, $;
  return {
    c() {
      (r = element("div")),
        (p = element("img")),
        src_url_equal(p.src, (v = k[0].image)) || attr(p, "src", v),
        attr(p, "alt", ($ = k[0].title)),
        attr(r, "class", "errimg");
    },
    m(S, x) {
      insert(S, r, x), append(r, p);
    },
    p(S, x) {
      x & 1 && !src_url_equal(p.src, (v = S[0].image)) && attr(p, "src", v),
        x & 1 && $ !== ($ = S[0].title) && attr(p, "alt", $);
    },
    d(S) {
      S && detach(r);
    },
  };
}
function create_each_block$7(k) {
  let r,
    p = k[6].caption + "",
    v,
    $,
    S;
  function x() {
    return k[4](k[6]);
  }
  return {
    c() {
      (r = element("button")), (v = text(p));
    },
    m(I, F) {
      insert(I, r, F),
        append(r, v),
        $ || ((S = listen(r, "click", x)), ($ = !0));
    },
    p(I, F) {
      (k = I), F & 1 && p !== (p = k[6].caption + "") && set_data(v, p);
    },
    d(I) {
      I && detach(r), ($ = !1), S();
    },
  };
}
function create_fragment$t(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F = k[0].title + "",
    O,
    L,
    U,
    j = k[0].message + "",
    N,
    q,
    R,
    Q,
    H = k[0].image && create_if_block$j(k),
    G = k[0].buttons,
    V = [];
  for (let K = 0; K < G.length; K += 1)
    V[K] = create_each_block$7(get_each_context$7(k, G, K));
  return {
    c() {
      (r = element("div")),
        (p = element("window")),
        (v = element("div")),
        ($ = element("div")),
        H && H.c(),
        (S = space()),
        (x = element("div")),
        (I = element("h3")),
        (O = text(F)),
        (L = space()),
        (U = element("p")),
        (N = text(j)),
        (q = space()),
        (R = element("div")),
        (Q = element("div"));
      for (let K = 0; K < V.length; K += 1) V[K].c();
      attr(I, "class", "error-title"),
        attr(U, "class", "error-message"),
        attr(x, "class", "error-content"),
        attr($, "class", "error-overlay"),
        attr(Q, "class", "inner"),
        attr(R, "class", "error-overlay-buttons"),
        attr(v, "class", "body overlay"),
        attr(p, "class", "window headless overlay overlayable-error"),
        toggle_class(p, "visible", k[1]),
        attr(r, "class", "overlay-wrapper"),
        toggle_class(r, "show", k[1]);
    },
    m(K, Y) {
      insert(K, r, Y),
        append(r, p),
        append(p, v),
        append(v, $),
        H && H.m($, null),
        append($, S),
        append($, x),
        append(x, I),
        append(I, O),
        append(x, L),
        append(x, U),
        append(U, N),
        append(v, q),
        append(v, R),
        append(R, Q);
      for (let J = 0; J < V.length; J += 1) V[J] && V[J].m(Q, null);
    },
    p(K, [Y]) {
      if (
        (K[0].image
          ? H
            ? H.p(K, Y)
            : ((H = create_if_block$j(K)), H.c(), H.m($, S))
          : H && (H.d(1), (H = null)),
        Y & 1 && F !== (F = K[0].title + "") && set_data(O, F),
        Y & 1 && j !== (j = K[0].message + "") && set_data(N, j),
        Y & 5)
      ) {
        G = K[0].buttons;
        let J;
        for (J = 0; J < G.length; J += 1) {
          const Z = get_each_context$7(K, G, J);
          V[J]
            ? V[J].p(Z, Y)
            : ((V[J] = create_each_block$7(Z)), V[J].c(), V[J].m(Q, null));
        }
        for (; J < V.length; J += 1) V[J].d(1);
        V.length = G.length;
      }
      Y & 2 && toggle_class(p, "visible", K[1]),
        Y & 2 && toggle_class(r, "show", K[1]);
    },
    i: noop$1,
    o: noop$1,
    d(K) {
      K && detach(r), H && H.d(), destroy_each(V, K);
    },
  };
}
function instance$s(k, r, p) {
  let { app: v } = r,
    { error: $ } = r,
    S = !1;
  function x() {
    p(1, (S = !1)),
      setTimeout(() => {
        destroyOverlayableError($.id, v.id);
      }, 100);
  }
  onMount(() => {
    setTimeout(() => {
      p(1, (S = !0));
    }, 100);
  });
  function I(O) {
    O(), x();
  }
  const F = (O) => I(O.action);
  return (
    (k.$$set = (O) => {
      "app" in O && p(3, (v = O.app)), "error" in O && p(0, ($ = O.error));
    }),
    [$, S, I, v, F]
  );
}
class OverlayableErrorWindow extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$s, create_fragment$t, safe_not_equal, {
        app: 3,
        error: 0,
      });
  }
}
function create_if_block$i(k) {
  let r, p, v, $, S;
  var x = k[0].content;
  function I(F) {
    return { props: { overlay: F[0], app: F[1], id: F[2] } };
  }
  return (
    x && ($ = construct_svelte_component(x, I(k))),
    {
      c() {
        (r = element("div")),
          (p = element("window")),
          (v = element("div")),
          $ && create_component($.$$.fragment),
          attr(v, "class", "body overlay"),
          attr(p, "class", "window headless overlay"),
          attr(p, "style", k[4]),
          attr(p, "id", k[2]),
          toggle_class(p, "visible", k[3]),
          attr(r, "class", "overlay-wrapper"),
          toggle_class(r, "show", k[3]);
      },
      m(F, O) {
        insert(F, r, O),
          append(r, p),
          append(p, v),
          $ && mount_component($, v, null),
          (S = !0);
      },
      p(F, O) {
        const L = {};
        if (
          (O & 1 && (L.overlay = F[0]),
          O & 2 && (L.app = F[1]),
          O & 4 && (L.id = F[2]),
          O & 1 && x !== (x = F[0].content))
        ) {
          if ($) {
            group_outros();
            const U = $;
            transition_out(U.$$.fragment, 1, 0, () => {
              destroy_component(U, 1);
            }),
              check_outros();
          }
          x
            ? (($ = construct_svelte_component(x, I(F))),
              create_component($.$$.fragment),
              transition_in($.$$.fragment, 1),
              mount_component($, v, null))
            : ($ = null);
        } else x && $.$set(L);
        (!S || O & 16) && attr(p, "style", F[4]),
          (!S || O & 4) && attr(p, "id", F[2]),
          (!S || O & 8) && toggle_class(p, "visible", F[3]),
          (!S || O & 8) && toggle_class(r, "show", F[3]);
      },
      i(F) {
        S || ($ && transition_in($.$$.fragment, F), (S = !0));
      },
      o(F) {
        $ && transition_out($.$$.fragment, F), (S = !1);
      },
      d(F) {
        F && detach(r), $ && destroy_component($);
      },
    }
  );
}
function create_fragment$s(k) {
  let r,
    p,
    v = k[0] && k[1] && create_if_block$i(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, [S]) {
      $[0] && $[1]
        ? v
          ? (v.p($, S), S & 3 && transition_in(v, 1))
          : ((v = create_if_block$i($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function instance$r(k, r, p) {
  let { overlay: v } = r,
    { app: $ } = r,
    { id: S } = r,
    x = !1,
    I = "";
  return (
    onMount(() => {
      p(4, (I = generateOverlayCSS(v)));
    }),
    WindowStore.subscribe(() => {
      p(4, (I = generateOverlayCSS(v))),
        p(3, (x = $.overlays[S] ? $.overlays[S].show : !1));
    }),
    (k.$$set = (F) => {
      "overlay" in F && p(0, (v = F.overlay)),
        "app" in F && p(1, ($ = F.app)),
        "id" in F && p(2, (S = F.id));
    }),
    [v, $, S, x, I]
  );
}
class OverlayableWindow extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$r, create_fragment$s, safe_not_equal, {
        overlay: 0,
        app: 1,
        id: 2,
      });
  }
}
function create_fragment$r(k) {
  let r, p, v, $;
  var S = k[0].content;
  function x(O) {
    return { props: { app: O[0], appdata: O[1].appdata[O[0].id] || {} } };
  }
  S && (p = construct_svelte_component(S, x(k)));
  const I = k[3].default,
    F = create_slot(I, k, k[2], null);
  return {
    c() {
      (r = element("div")),
        p && create_component(p.$$.fragment),
        (v = space()),
        F && F.c(),
        attr(r, "class", "body");
    },
    m(O, L) {
      insert(O, r, L),
        p && mount_component(p, r, null),
        append(r, v),
        F && F.m(r, null),
        ($ = !0);
    },
    p(O, [L]) {
      const U = {};
      if (
        (L & 1 && (U.app = O[0]),
        L & 3 && (U.appdata = O[1].appdata[O[0].id] || {}),
        L & 1 && S !== (S = O[0].content))
      ) {
        if (p) {
          group_outros();
          const j = p;
          transition_out(j.$$.fragment, 1, 0, () => {
            destroy_component(j, 1);
          }),
            check_outros();
        }
        S
          ? ((p = construct_svelte_component(S, x(O))),
            create_component(p.$$.fragment),
            transition_in(p.$$.fragment, 1),
            mount_component(p, r, v))
          : (p = null);
      } else S && p.$set(U);
      F &&
        F.p &&
        (!$ || L & 4) &&
        update_slot_base(
          F,
          I,
          O,
          O[2],
          $
            ? get_slot_changes(I, O[2], L, null)
            : get_all_dirty_from_scope(O[2]),
          null
        );
    },
    i(O) {
      $ ||
        (p && transition_in(p.$$.fragment, O), transition_in(F, O), ($ = !0));
    },
    o(O) {
      p && transition_out(p.$$.fragment, O), transition_out(F, O), ($ = !1);
    },
    d(O) {
      O && detach(r), p && destroy_component(p), F && F.d(O);
    },
  };
}
function instance$q(k, r, p) {
  let v;
  component_subscribe(k, UserData, (I) => p(1, (v = I)));
  let { $$slots: $ = {}, $$scope: S } = r,
    { app: x } = r;
  return (
    (k.$$set = (I) => {
      "app" in I && p(0, (x = I.app)), "$$scope" in I && p(2, (S = I.$$scope));
    }),
    [x, v, S, $]
  );
}
class Content extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$q, create_fragment$r, safe_not_equal, { app: 0 });
  }
}
function create_if_block_1$5(k) {
  let r;
  return {
    c() {
      r = text("(In recovery mode)");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_else_block$4(k) {
  let r, p;
  return (
    (r = new Default({
      props: { app: k[1], cls: k[6], min: k[4], max: k[5], isBoot: k[2] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 2 && (S.app = v[1]), $ & 4 && (S.isBoot = v[2]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$h(k) {
  let r, p, v;
  var $ = titlebarButtons[k[3].sh.window.buttons].content;
  function S(x) {
    return {
      props: { cls: x[6], min: x[4], max: x[5], app: x[1], isBoot: x[2] },
    };
  }
  return (
    $ && (r = construct_svelte_component($, S(k))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(x, I) {
        r && mount_component(r, x, I), insert(x, p, I), (v = !0);
      },
      p(x, I) {
        const F = {};
        if (
          (I & 2 && (F.app = x[1]),
          I & 4 && (F.isBoot = x[2]),
          I & 8 && $ !== ($ = titlebarButtons[x[3].sh.window.buttons].content))
        ) {
          if (r) {
            group_outros();
            const O = r;
            transition_out(O.$$.fragment, 1, 0, () => {
              destroy_component(O, 1);
            }),
              check_outros();
          }
          $
            ? ((r = construct_svelte_component($, S(x))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else $ && r.$set(F);
      },
      i(x) {
        v || (r && transition_in(r.$$.fragment, x), (v = !0));
      },
      o(x) {
        r && transition_out(r.$$.fragment, x), (v = !1);
      },
      d(x) {
        x && detach(p), r && destroy_component(r, x);
      },
    }
  );
}
function create_fragment$q(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F = k[1].info.name + "",
    O,
    L = (k[1].info.titleSuffix || "") + "",
    U,
    j,
    N,
    q,
    R,
    Q,
    H,
    G,
    V,
    K = k[2] && create_if_block_1$5();
  const Y = [create_if_block$h, create_else_block$4],
    J = [];
  function Z(X, ee) {
    return X[3].sh.window.buttons ? 0 : 1;
  }
  return (
    (R = Z(k)),
    (Q = J[R] = Y[R](k)),
    {
      c() {
        (r = element("div")),
          (p = element("p")),
          (v = element("img")),
          (x = space()),
          (I = element("span")),
          (O = text(F)),
          (U = text(L)),
          (j = space()),
          K && K.c(),
          (N = space()),
          (q = element("div")),
          Q.c(),
          attr(v, "class", "icon"),
          src_url_equal(v.src, ($ = getAppIcon(k[1]))) || attr(v, "src", $),
          attr(v, "alt", (S = k[1].info.name)),
          attr(p, "class", "title"),
          attr(q, "class", "controls"),
          attr(r, "class", "titlebar");
      },
      m(X, ee) {
        insert(X, r, ee),
          append(r, p),
          append(p, v),
          append(p, x),
          append(p, I),
          append(I, O),
          append(I, U),
          append(I, j),
          K && K.m(I, null),
          append(r, N),
          append(r, q),
          J[R].m(q, null),
          k[8](r),
          (H = !0),
          G || ((V = listen(r, "dblclick", k[5])), (G = !0));
      },
      p(X, [ee]) {
        (!H || (ee & 2 && !src_url_equal(v.src, ($ = getAppIcon(X[1]))))) &&
          attr(v, "src", $),
          (!H || (ee & 2 && S !== (S = X[1].info.name))) && attr(v, "alt", S),
          (!H || ee & 2) && F !== (F = X[1].info.name + "") && set_data(O, F),
          (!H || ee & 2) &&
            L !== (L = (X[1].info.titleSuffix || "") + "") &&
            set_data(U, L),
          X[2]
            ? K || ((K = create_if_block_1$5()), K.c(), K.m(I, null))
            : K && (K.d(1), (K = null));
        let te = R;
        (R = Z(X)),
          R === te
            ? J[R].p(X, ee)
            : (group_outros(),
              transition_out(J[te], 1, 1, () => {
                J[te] = null;
              }),
              check_outros(),
              (Q = J[R]),
              Q ? Q.p(X, ee) : ((Q = J[R] = Y[R](X)), Q.c()),
              transition_in(Q, 1),
              Q.m(q, null));
      },
      i(X) {
        H || (transition_in(Q), (H = !0));
      },
      o(X) {
        transition_out(Q), (H = !1);
      },
      d(X) {
        X && detach(r), K && K.d(), J[R].d(), k[8](null), (G = !1), V();
      },
    }
  );
}
function instance$p(k, r, p) {
  let v;
  component_subscribe(k, UserData, (j) => p(3, (v = j)));
  let { exttransition: $ = !1 } = r,
    { titlebar: S } = r,
    { app: x } = r,
    { isBoot: I = !1 } = r;
  function F() {
    p(1, (x.state.windowState.min = !x.state.windowState.min), x),
      updateStores();
  }
  function O() {
    x.controls.max &&
      (p(1, (x.state.windowState.max = !x.state.windowState.max), x),
      x.state.windowState.max
        ? p(7, ($ = !0))
        : setTimeout(() => {
            p(7, ($ = !1));
          }, 200),
      updateStores());
  }
  function L() {
    const j = x.id,
      N = j.startsWith("error_") ? parseInt(j.replace("error_", "")) : -1;
    N > 0 ? closeError(N) : closeWindow(x.id), I && p(1, (x.opened = !1), x);
  }
  function U(j) {
    binding_callbacks[j ? "unshift" : "push"](() => {
      (S = j), p(0, S);
    });
  }
  return (
    (k.$$set = (j) => {
      "exttransition" in j && p(7, ($ = j.exttransition)),
        "titlebar" in j && p(0, (S = j.titlebar)),
        "app" in j && p(1, (x = j.app)),
        "isBoot" in j && p(2, (I = j.isBoot));
    }),
    [S, x, I, v, F, O, L, $, U]
  );
}
class Titlebar extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$p, create_fragment$q, safe_not_equal, {
        exttransition: 7,
        titlebar: 0,
        app: 1,
        isBoot: 2,
      });
  }
}
function get_each_context$6(k, r, p) {
  const v = k.slice();
  return (v[21] = r[p]), v;
}
function get_each_context_1$1(k, r, p) {
  const v = k.slice();
  return (v[24] = r[p]), v;
}
function create_default_slot$1(k) {
  let r;
  const p = k[14].default,
    v = create_slot(p, k, k[18], null);
  return {
    c() {
      v && v.c();
    },
    m($, S) {
      v && v.m($, S), (r = !0);
    },
    p($, S) {
      v &&
        v.p &&
        (!r || S & 262144) &&
        update_slot_base(
          v,
          p,
          $,
          $[18],
          r
            ? get_slot_changes(p, $[18], S, null)
            : get_all_dirty_from_scope($[18]),
          null
        );
    },
    i($) {
      r || (transition_in(v, $), (r = !0));
    },
    o($) {
      transition_out(v, $), (r = !1);
    },
    d($) {
      v && v.d($);
    },
  };
}
function create_if_block_1$4(k) {
  let r,
    p,
    v = Object.entries(k[1].overlays),
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block_1$1(get_each_context_1$1(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = empty();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 2) {
        v = Object.entries(x[1].overlays);
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_1$1(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block_1$1(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_each_block_1$1(k) {
  let r, p;
  return (
    (r = new OverlayableWindow({
      props: { app: k[1], overlay: k[24][1], id: k[24][0] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 2 && (S.app = v[1]),
          $ & 2 && (S.overlay = v[24][1]),
          $ & 2 && (S.id = v[24][0]),
          r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$g(k) {
  let r,
    p,
    v = k[1].errorOverlays,
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$6(get_each_context$6(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = empty();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 2) {
        v = x[1].errorOverlays;
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$6(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$6(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_each_block$6(k) {
  let r, p;
  return (
    (r = new OverlayableErrorWindow({ props: { error: k[21], app: k[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 2 && (S.error = v[21]), $ & 2 && (S.app = v[1]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$p(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j;
  function N(G) {
    k[15](G);
  }
  function q(G) {
    k[16](G);
  }
  let R = { app: k[1], isBoot: k[4] };
  k[0] !== void 0 && (R.exttransition = k[0]),
    k[7] !== void 0 && (R.titlebar = k[7]),
    (p = new Titlebar({ props: R })),
    binding_callbacks.push(() => bind$1(p, "exttransition", N)),
    binding_callbacks.push(() => bind$1(p, "titlebar", q)),
    (x = new Content({
      props: {
        app: k[1],
        $$slots: { default: [create_default_slot$1] },
        $$scope: { ctx: k },
      },
    }));
  let Q = k[1] && k[1].overlays && create_if_block_1$4(k),
    H = k[1] && k[1].errorOverlays && create_if_block$g(k);
  return {
    c() {
      (r = element("window")),
        create_component(p.$$.fragment),
        (S = space()),
        create_component(x.$$.fragment),
        (I = space()),
        Q && Q.c(),
        (F = space()),
        H && H.c(),
        attr(r, "style", k[5]),
        attr(r, "id", (O = k[1].id)),
        toggle_class(r, "window", !k[1].info.custom),
        toggle_class(r, "focused", k[1].id == k[8]),
        toggle_class(
          r,
          "headless",
          k[1].state.headless || k[1].state.windowState.fll
        ),
        toggle_class(r, "resizable", k[1].state.resizable),
        toggle_class(r, "min", k[1].state.windowState.min),
        toggle_class(r, "max", k[1].state.windowState.max || k[3]),
        toggle_class(r, "visible", k[1].opened || k[2]),
        toggle_class(r, "exttransition", k[0]),
        toggle_class(
          r,
          "fullscreen",
          k[1].state.windowState.fll || k[1].info.custom
        ),
        toggle_class(r, "glass", k[1].glass),
        toggle_class(r, "lefttb", k[9].sh.window.lefttb),
        toggle_class(r, "custom", k[1].info.custom),
        toggle_class(r, "child", !!k[1].parentId),
        toggle_class(r, "snapped", k[1].snapped),
        toggle_class(r, "snapping", k[1].id == k[10] && (k[11] || k[12]));
    },
    m(G, V) {
      insert(G, r, V),
        mount_component(p, r, null),
        append(r, S),
        mount_component(x, r, null),
        append(r, I),
        Q && Q.m(r, null),
        append(r, F),
        H && H.m(r, null),
        k[17](r),
        (L = !0),
        U || ((j = listen(r, "mousedown", k[13])), (U = !0));
    },
    p(G, [V]) {
      const K = {};
      V & 2 && (K.app = G[1]),
        V & 16 && (K.isBoot = G[4]),
        !v &&
          V & 1 &&
          ((v = !0),
          (K.exttransition = G[0]),
          add_flush_callback(() => (v = !1))),
        !$ &&
          V & 128 &&
          (($ = !0), (K.titlebar = G[7]), add_flush_callback(() => ($ = !1))),
        p.$set(K);
      const Y = {};
      V & 2 && (Y.app = G[1]),
        V & 262144 && (Y.$$scope = { dirty: V, ctx: G }),
        x.$set(Y),
        G[1] && G[1].overlays
          ? Q
            ? (Q.p(G, V), V & 2 && transition_in(Q, 1))
            : ((Q = create_if_block_1$4(G)),
              Q.c(),
              transition_in(Q, 1),
              Q.m(r, F))
          : Q &&
            (group_outros(),
            transition_out(Q, 1, 1, () => {
              Q = null;
            }),
            check_outros()),
        G[1] && G[1].errorOverlays
          ? H
            ? (H.p(G, V), V & 2 && transition_in(H, 1))
            : ((H = create_if_block$g(G)),
              H.c(),
              transition_in(H, 1),
              H.m(r, null))
          : H &&
            (group_outros(),
            transition_out(H, 1, 1, () => {
              H = null;
            }),
            check_outros()),
        (!L || V & 32) && attr(r, "style", G[5]),
        (!L || (V & 2 && O !== (O = G[1].id))) && attr(r, "id", O),
        (!L || V & 2) && toggle_class(r, "window", !G[1].info.custom),
        (!L || V & 258) && toggle_class(r, "focused", G[1].id == G[8]),
        (!L || V & 2) &&
          toggle_class(
            r,
            "headless",
            G[1].state.headless || G[1].state.windowState.fll
          ),
        (!L || V & 2) && toggle_class(r, "resizable", G[1].state.resizable),
        (!L || V & 2) && toggle_class(r, "min", G[1].state.windowState.min),
        (!L || V & 10) &&
          toggle_class(r, "max", G[1].state.windowState.max || G[3]),
        (!L || V & 6) && toggle_class(r, "visible", G[1].opened || G[2]),
        (!L || V & 1) && toggle_class(r, "exttransition", G[0]),
        (!L || V & 2) &&
          toggle_class(
            r,
            "fullscreen",
            G[1].state.windowState.fll || G[1].info.custom
          ),
        (!L || V & 2) && toggle_class(r, "glass", G[1].glass),
        (!L || V & 512) && toggle_class(r, "lefttb", G[9].sh.window.lefttb),
        (!L || V & 2) && toggle_class(r, "custom", G[1].info.custom),
        (!L || V & 2) && toggle_class(r, "child", !!G[1].parentId),
        (!L || V & 2) && toggle_class(r, "snapped", G[1].snapped),
        (!L || V & 7170) &&
          toggle_class(r, "snapping", G[1].id == G[10] && (G[11] || G[12]));
    },
    i(G) {
      L ||
        (transition_in(p.$$.fragment, G),
        transition_in(x.$$.fragment, G),
        transition_in(Q),
        transition_in(H),
        (L = !0));
    },
    o(G) {
      transition_out(p.$$.fragment, G),
        transition_out(x.$$.fragment, G),
        transition_out(Q),
        transition_out(H),
        (L = !1);
    },
    d(G) {
      G && detach(r),
        destroy_component(p),
        destroy_component(x),
        Q && Q.d(),
        H && H.d(),
        k[17](null),
        (U = !1),
        j();
    },
  };
}
function instance$o(k, r, p) {
  let v, $, S, x, I;
  component_subscribe(k, focusedWindowId, (X) => p(8, (v = X))),
    component_subscribe(k, UserData, (X) => p(9, ($ = X))),
    component_subscribe(k, draggingId, (X) => p(10, (S = X))),
    component_subscribe(k, leftZoneTriggered, (X) => p(11, (x = X))),
    component_subscribe(k, rightZoneTriggered, (X) => p(12, (I = X)));
  let { $$slots: F = {}, $$scope: O } = r,
    { app: L = null } = r,
    { visible: U = !1 } = r,
    { max: j = !1 } = r,
    { isBoot: N = !1 } = r,
    q = "",
    R,
    Q = !1,
    H,
    { exttransition: G = !1 } = r;
  onMount(() => {
    focusedWindowId.set(L.id), V();
  });
  function V() {
    if (L.minSize.w > L.size.w || L.minSize.h > L.size.h) return void 0;
    if (L.maxSize.w < L.minSize.w || L.maxSize.h < L.minSize.h) return void 0;
    p(5, (q = generateCSS(L, !Q))),
      Q || (Q = !0),
      L.info.custom || dragWindow(L, R, H);
  }
  WindowStore.subscribe(() => {
    L.opened && !L.info.custom && dragWindow(L, R, H), V();
  });
  function K() {
    set_store_value(focusedWindowId, (v = L.id), v);
  }
  focusedWindowId.subscribe((X) => {
    !L ||
      !L.events ||
      (X == L.id && L.events.focus && L.events.focus(L),
      X != L.id && L.events.blur && L.events.blur(L));
  });
  function Y(X) {
    (G = X), p(0, G);
  }
  function J(X) {
    (H = X), p(7, H);
  }
  function Z(X) {
    binding_callbacks[X ? "unshift" : "push"](() => {
      (R = X), p(6, R);
    });
  }
  return (
    (k.$$set = (X) => {
      "app" in X && p(1, (L = X.app)),
        "visible" in X && p(2, (U = X.visible)),
        "max" in X && p(3, (j = X.max)),
        "isBoot" in X && p(4, (N = X.isBoot)),
        "exttransition" in X && p(0, (G = X.exttransition)),
        "$$scope" in X && p(18, (O = X.$$scope));
    }),
    [G, L, U, j, N, q, R, H, v, $, S, x, I, K, F, Y, J, Z, O]
  );
}
class Window extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$o, create_fragment$p, safe_not_equal, {
        app: 1,
        visible: 2,
        max: 3,
        isBoot: 4,
        exttransition: 0,
      });
  }
}
function create_if_block$f(k) {
  let r, p;
  return (
    (r = new Window({
      props: {
        isBoot: !0,
        max: !0,
        visible: !0,
        app: { ...k[0], glass: !1, id: "LoggerApp" },
      },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.app = { ...v[0], glass: !1, id: "LoggerApp" }), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$o(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L,
    U,
    j,
    N,
    q,
    R = k[3] && create_if_block$f(k);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (p.textContent = "ArcTerm Mode"),
        (v = space()),
        ($ = element("div")),
        (S = element("img")),
        (I = space()),
        (F = element("div")),
        (F.innerHTML = `<div class="line dark"></div> 
      <div class="subline dark inc"></div> 
      <div class="subline dark dec"></div>`),
        (O = space()),
        (L = element("p")),
        (j = space()),
        R && R.c(),
        (N = empty()),
        attr(p, "class", "arcterm-load"),
        toggle_class(p, "visible", k[4]),
        attr(S, "alt", "Logo"),
        attr(S, "class", "logo"),
        src_url_equal(S.src, (x = logo$c)) || attr(S, "src", x),
        attr(F, "class", "slider userdefined"),
        attr(L, "class", "status"),
        attr($, "class", "center-absolute"),
        attr(r, "class", (U = k[2] + " boot fullscreen"));
    },
    m(Q, H) {
      insert(Q, r, H),
        append(r, p),
        append(r, v),
        append(r, $),
        append($, S),
        append($, I),
        append($, F),
        append($, O),
        append($, L),
        (L.innerHTML = k[1]),
        insert(Q, j, H),
        R && R.m(Q, H),
        insert(Q, N, H),
        (q = !0);
    },
    p(Q, [H]) {
      (!q || H & 16) && toggle_class(p, "visible", Q[4]),
        (!q || H & 2) && (L.innerHTML = Q[1]),
        (!q || (H & 4 && U !== (U = Q[2] + " boot fullscreen"))) &&
          attr(r, "class", U),
        Q[3]
          ? R
            ? (R.p(Q, H), H & 8 && transition_in(R, 1))
            : ((R = create_if_block$f(Q)),
              R.c(),
              transition_in(R, 1),
              R.m(N.parentNode, N))
          : R &&
            (group_outros(),
            transition_out(R, 1, 1, () => {
              R = null;
            }),
            check_outros());
    },
    i(Q) {
      q || (transition_in(R), (q = !0));
    },
    o(Q) {
      transition_out(R), (q = !1);
    },
    d(Q) {
      Q && detach(r), Q && detach(j), R && R.d(Q), Q && detach(N);
    },
  };
}
let targetState = "login";
function instance$n(k, r, p) {
  let v = "",
    $ = "",
    S = null,
    x = null,
    I = null,
    F = !1,
    O = !1;
  onMount(async () => {
    p(1, (v = "&nbsp;")),
      (S = setTimeout(N, 500)),
      (x = setTimeout(j, 4e3)),
      (I = setTimeout(q, 4750)),
      (await U()) || p(1, (v = "Preparing ArcOS")),
      document.addEventListener("keydown", L);
  });
  function L(R) {
    R.altKey && R.key.toLowerCase() == "a" && p(4, (O = !0));
  }
  async function U() {
    const R = localStorage.getItem("arcos-server");
    let Q = !1;
    if (R)
      return (
        clearTimeout(S),
        clearTimeout(x),
        clearTimeout(I),
        N(),
        p(1, (v = "Connecting")),
        (Q = await testConnection(R)),
        Q
          ? (setTimeout(j, 2e3), setTimeout(q, 2750), Q)
          : (j(),
            BugReportData.set([
              !0,
              {
                title: "Boot failed",
                icon: "warning",
                message:
                  "ArcOS can't connect to the remote server. Please ensure<br>the server is online, or try again at a later date.",
                button: {
                  caption: "View logs",
                  action: () => {
                    p(3, (F = !0)),
                      p(0, (LoggerApp.state.windowState.fll = !0), LoggerApp);
                  },
                },
              },
            ]))
      );
  }
  function j() {
    Log({ level: LogLevel.info, source: "Boot.svelte", msg: "Fade-out" }),
      p(2, ($ = "fadeout"));
  }
  function N() {
    Log({ level: LogLevel.info, source: "Boot.svelte", msg: "Fade-in" }),
      p(2, ($ = "fadein"));
  }
  async function q() {
    Log({ level: LogLevel.info, source: "Boot.svelte", msg: "Redirecting" }),
      removeEventListener("keydown", L),
      applyState(O ? "arcterm" : targetState);
  }
  return [LoggerApp, v, $, F, O];
}
class Boot extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$n, create_fragment$o, safe_not_equal, {});
  }
}
const desktop = "";
async function importAutoLoaders() {
  const k = get_store_value(UserData);
  if (!k.autoLoads) return !1;
  for (let r = 0; r < k.autoLoads.length; r++) {
    const p = k.autoLoads[r],
      v = { name: p, path: p, mime: "text/plain", data: await readFile(p) };
    (!loadAppFile(v) || !v.data) &&
      errorMessage(
        "Can't import app",
        `ArcOS failed to load app file "${p}". Please verify that this file exists and then try again.`,
        null,
        null,
        { caption: "Close", action() {} },
        {
          caption: "Don't load again",
          action() {
            const S = get_store_value(UserData);
            for (let x = 0; x < S.autoLoads.length; x++)
              S.autoLoads[x] == p && S.autoLoads.splice(x, 1);
            UserData.set(S);
          },
        }
      );
  }
}
const banned = ["tab", "pagedown", "pageup"];
function startKeyListener() {
  Log({
    source: "keyboard/listener.ts: startKeyListener",
    msg: "Starting key listener",
    level: LogLevel.info,
  }),
    document.addEventListener("keydown", processEvent);
}
function processEvent(k) {
  if (k.key) {
    if (banned.includes(k.key.toLowerCase())) return k.preventDefault(), !1;
    if (
      (unfocusActiveElement(), get_store_value(CurrentState).key == "desktop")
    )
      for (let r = 0; r < appShortcuts.length; r++) {
        const p = appShortcuts[r],
          v = p[1];
        for (let $ = 0; $ < v.length; $++) {
          const S = v[$].alt ? k.altKey : !0,
            x = v[$].ctrl ? k.ctrlKey : !0,
            I = v[$].shift ? k.shiftKey : !0,
            F = S && x && I,
            O = k.key.toLowerCase().trim(),
            L = v[$].key.trim().toLowerCase(),
            U = get_store_value(focusedWindowId) == p[0] || v[$].global;
          if (!F || (L != O && L) || !U) continue;
          const j = v[$].global ? null : getWindow(p[0]);
          v[$].action(j);
        }
      }
  }
}
function unfocusActiveElement() {
  const k = document.activeElement;
  !k ||
    k instanceof HTMLInputElement ||
    k instanceof HTMLTextAreaElement ||
    k.blur();
}
let interval;
const pollBlockList = [];
function startMessageCheckInterval() {
  (interval = setInterval(tick, 1e3 * 60)), tick();
}
async function tick() {
  if (!get_store_value(UserName)) return stopMessageCheckInterval();
  messageUpdateTrigger();
  const k = (await getUnreadMessages()).sort(
    (p, v) => v.timestamp - p.timestamp
  );
  if (!k.length) return;
  const r = k[0];
  !r ||
    isOpened("MessagingApp") ||
    pollBlockList.includes(r.id) ||
    (pollBlockList.push(r.id),
    makeNotification({
      title: `New message from ${r.sender}`,
      message: `${r.partialBody}`,
      image: await getUserPfp(r.sender),
      buttons: [
        {
          capt: "Open Messages",
          action: () => {
            messageUpdateTrigger(), openWindow("MessagingApp");
          },
        },
      ],
    }));
}
function stopMessageCheckInterval() {
  clearInterval(interval);
}
const arcfind = "";
function create_if_block$e(k) {
  let r,
    p = k[0].description + "",
    v;
  return {
    c() {
      (r = element("p")), (v = text(p)), attr(r, "class", "description");
    },
    m($, S) {
      insert($, r, S), append(r, v);
    },
    p($, S) {
      S & 1 && p !== (p = $[0].description + "") && set_data(v, p);
    },
    d($) {
      $ && detach(r);
    },
  };
}
function create_fragment$n(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O = k[0].caption + "",
    L,
    U,
    j,
    N,
    q = k[0].description && create_if_block$e(k);
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (I = element("div")),
        (F = element("p")),
        (L = text(O)),
        (U = space()),
        q && q.c(),
        src_url_equal(v.src, ($ = k[0].image || searchIcon)) ||
          attr(v, "src", $),
        attr(v, "alt", (S = k[0].caption)),
        attr(p, "class", "image"),
        attr(F, "class", "title"),
        attr(I, "class", "context"),
        attr(r, "class", "result"),
        toggle_class(r, "selected", k[1] == k[2]);
    },
    m(R, Q) {
      insert(R, r, Q),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, I),
        append(I, F),
        append(F, L),
        append(I, U),
        q && q.m(I, null),
        j || ((N = listen(r, "click", k[3])), (j = !0));
    },
    p(R, [Q]) {
      Q & 1 &&
        !src_url_equal(v.src, ($ = R[0].image || searchIcon)) &&
        attr(v, "src", $),
        Q & 1 && S !== (S = R[0].caption) && attr(v, "alt", S),
        Q & 1 && O !== (O = R[0].caption + "") && set_data(L, O),
        R[0].description
          ? q
            ? q.p(R, Q)
            : ((q = create_if_block$e(R)), q.c(), q.m(I, null))
          : q && (q.d(1), (q = null)),
        Q & 6 && toggle_class(r, "selected", R[1] == R[2]);
    },
    i: noop$1,
    o: noop$1,
    d(R) {
      R && detach(r), q && q.d(), (j = !1), N();
    },
  };
}
function instance$m(k, r, p) {
  let { result: v } = r,
    { index: $ } = r,
    { resultIndex: S } = r;
  function x() {
    v.action(v), showArcFind.set(!1);
  }
  return (
    (k.$$set = (I) => {
      "result" in I && p(0, (v = I.result)),
        "index" in I && p(1, ($ = I.index)),
        "resultIndex" in I && p(2, (S = I.resultIndex));
    }),
    [v, $, S, x]
  );
}
class Result extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$m, create_fragment$n, safe_not_equal, {
        result: 0,
        index: 1,
        resultIndex: 2,
      });
  }
}
function get_each_context$5(k, r, p) {
  const v = k.slice();
  return (v[13] = r[p]), (v[15] = p), v;
}
function create_if_block$d(k) {
  let r,
    p,
    v = k[3],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$5(get_each_context$5(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      r = element("div");
      for (let x = 0; x < $.length; x += 1) $[x].c();
      attr(r, "class", "results");
    },
    m(x, I) {
      insert(x, r, I);
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(r, null);
      p = !0;
    },
    p(x, I) {
      if (I & 10) {
        v = x[3];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$5(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$5(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      x && detach(r), destroy_each($, x);
    },
  };
}
function create_each_block$5(k) {
  let r, p;
  return (
    (r = new Result({
      props: { index: k[1], result: k[13], resultIndex: k[15] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 2 && (S.index = v[1]), $ & 8 && (S.result = v[13]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$m(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L,
    U,
    j,
    N = k[3].length && create_if_block$d(k);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("form")),
        ($ = element("input")),
        (S = space()),
        (x = element("button")),
        (x.textContent = "search"),
        (I = space()),
        N && N.c(),
        (F = space()),
        (O = element("button")),
        (O.textContent = "close"),
        attr($, "type", "text"),
        attr($, "placeholder", "Search ArcOS"),
        attr(x, "class", "material-icons-round"),
        attr(p, "class", "arcfind"),
        attr(O, "class", "material-icons-round close"),
        attr(r, "class", "arcfind-wrapper"),
        set_style(r, "z-index", k[4] + 15),
        toggle_class(r, "show", k[5]);
    },
    m(q, R) {
      insert(q, r, R),
        append(r, p),
        append(p, v),
        append(v, $),
        set_input_value($, k[0]),
        k[11]($),
        append(p, S),
        append(p, x),
        append(r, I),
        N && N.m(r, null),
        append(r, F),
        append(r, O),
        (L = !0),
        U ||
          ((j = [
            listen($, "input", k[10]),
            listen($, "input", k[6]),
            listen($, "keydown", k[9]),
            listen(v, "submit", k[7]),
            listen(O, "click", k[8]),
          ]),
          (U = !0));
    },
    p(q, [R]) {
      R & 1 && $.value !== q[0] && set_input_value($, q[0]),
        q[3].length
          ? N
            ? (N.p(q, R), R & 8 && transition_in(N, 1))
            : ((N = create_if_block$d(q)),
              N.c(),
              transition_in(N, 1),
              N.m(r, F))
          : N &&
            (group_outros(),
            transition_out(N, 1, 1, () => {
              N = null;
            }),
            check_outros()),
        (!L || R & 16) && set_style(r, "z-index", q[4] + 15),
        (!L || R & 32) && toggle_class(r, "show", q[5]);
    },
    i(q) {
      L || (transition_in(N), (L = !0));
    },
    o(q) {
      transition_out(N), (L = !1);
    },
    d(q) {
      q && detach(r), k[11](null), N && N.d(), (U = !1), run_all(j);
    },
  };
}
function instance$l(k, r, p) {
  let v, $;
  component_subscribe(k, maxZIndex, (Q) => p(4, (v = Q))),
    component_subscribe(k, showArcFind, (Q) => p(5, ($ = Q)));
  let S = "",
    x = 0,
    I,
    F = [];
  async function O() {
    const Q = [],
      H = await Search(S);
    for (let G = 0; G < H.length; G++) Q.push(H[G].item);
    p(1, (x = -1)), p(3, (F = Q.slice(0, 6)));
  }
  function L(Q) {
    if ((Q.preventDefault(), !!F.length)) {
      if ((p(0, (S = "")), x != -1)) {
        F[x].action(F[x]), U(), showArcFind.set(!1);
        return;
      }
      F[0].action(F[0]), U(), showArcFind.set(!1);
    }
  }
  function U() {
    p(3, (F = [])), p(0, (S = "")), p(1, (x = -1));
  }
  function j() {
    U(), showArcFind.set(!1);
  }
  showArcFind.subscribe((Q) => {
    U(), Q && setTimeout(() => I.focus(), 100);
  });
  function N(Q) {
    const H = Q.key.toLowerCase();
    if (H == "escape") {
      U(), showArcFind.set(!1);
      return;
    }
    if (!F.length) return p(1, (x = -1));
    let G = F.length - 1;
    switch (H) {
      case "arrowup":
        p(1, x--, x), x < 0 && p(1, (x = G));
        break;
      case "arrowdown":
        p(1, x++, x), x > G && p(1, (x = 0));
        break;
    }
  }
  function q() {
    (S = this.value), p(0, S);
  }
  function R(Q) {
    binding_callbacks[Q ? "unshift" : "push"](() => {
      (I = Q), p(2, I);
    });
  }
  return [S, x, I, F, v, $, O, L, j, N, q, R];
}
class ArcFind extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$l, create_fragment$m, safe_not_equal, {});
  }
}
const contextmenu = "";
function create_else_block$3(k) {
  let r,
    p,
    v,
    $ = k[0].caption + "",
    S,
    x,
    I;
  function F(U, j) {
    if (U[0].icon) return create_if_block_1$3;
    if (U[0].image) return create_if_block_2$1;
  }
  let O = F(k),
    L = O && O(k);
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        L && L.c(),
        (v = space()),
        (S = text($)),
        attr(p, "class", "icon"),
        attr(r, "class", "contextmenu-item");
    },
    m(U, j) {
      insert(U, r, j),
        append(r, p),
        L && L.m(p, null),
        append(r, v),
        append(r, S),
        x || ((I = listen(r, "click", k[1])), (x = !0));
    },
    p(U, j) {
      O === (O = F(U)) && L
        ? L.p(U, j)
        : (L && L.d(1), (L = O && O(U)), L && (L.c(), L.m(p, null))),
        j & 1 && $ !== ($ = U[0].caption + "") && set_data(S, $);
    },
    d(U) {
      U && detach(r), L && L.d(), (x = !1), I();
    },
  };
}
function create_if_block$c(k) {
  let r;
  return {
    c() {
      r = element("hr");
    },
    m(p, v) {
      insert(p, r, v);
    },
    p: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
function create_if_block_2$1(k) {
  let r, p, v;
  return {
    c() {
      (r = element("img")),
        src_url_equal(r.src, (p = k[0].image)) || attr(r, "src", p),
        attr(r, "alt", (v = k[0].caption));
    },
    m($, S) {
      insert($, r, S);
    },
    p($, S) {
      S & 1 && !src_url_equal(r.src, (p = $[0].image)) && attr(r, "src", p),
        S & 1 && v !== (v = $[0].caption) && attr(r, "alt", v);
    },
    d($) {
      $ && detach(r);
    },
  };
}
function create_if_block_1$3(k) {
  let r,
    p = k[0].icon + "",
    v;
  return {
    c() {
      (r = element("span")),
        (v = text(p)),
        attr(r, "class", "material-icons-round");
    },
    m($, S) {
      insert($, r, S), append(r, v);
    },
    p($, S) {
      S & 1 && p !== (p = $[0].icon + "") && set_data(v, p);
    },
    d($) {
      $ && detach(r);
    },
  };
}
function create_fragment$l(k) {
  let r;
  function p(S, x) {
    return S[0].sep ? create_if_block$c : create_else_block$3;
  }
  let v = p(k),
    $ = v(k);
  return {
    c() {
      $.c(), (r = empty());
    },
    m(S, x) {
      $.m(S, x), insert(S, r, x);
    },
    p(S, [x]) {
      v === (v = p(S)) && $
        ? $.p(S, x)
        : ($.d(1), ($ = v(S)), $ && ($.c(), $.m(r.parentNode, r)));
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      $.d(S), S && detach(r);
    },
  };
}
function instance$k(k, r, p) {
  let { data: v } = r,
    { scope: $ } = r,
    { scopeMap: S } = r,
    { window: x } = r,
    { show: I } = r;
  function F() {
    v.action && v.action(x, S, $), p(2, (I = !1));
  }
  return (
    (k.$$set = (O) => {
      "data" in O && p(0, (v = O.data)),
        "scope" in O && p(3, ($ = O.scope)),
        "scopeMap" in O && p(4, (S = O.scopeMap)),
        "window" in O && p(5, (x = O.window)),
        "show" in O && p(2, (I = O.show));
    }),
    [v, F, I, $, S, x]
  );
}
class Item extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$k, create_fragment$l, safe_not_equal, {
        data: 0,
        scope: 3,
        scopeMap: 4,
        window: 5,
        show: 2,
      });
  }
}
function get_each_context$4(k, r, p) {
  const v = k.slice();
  return (v[12] = r[p]), v;
}
function create_each_block$4(k) {
  let r, p, v;
  function $(x) {
    k[9](x);
  }
  let S = { window: k[4], scope: k[5], scopeMap: k[6], data: k[12] };
  return (
    k[2] !== void 0 && (S.show = k[2]),
    (r = new Item({ props: S })),
    binding_callbacks.push(() => bind$1(r, "show", $)),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(x, I) {
        mount_component(r, x, I), (v = !0);
      },
      p(x, I) {
        const F = {};
        I & 16 && (F.window = x[4]),
          I & 32 && (F.scope = x[5]),
          I & 64 && (F.scopeMap = x[6]),
          I & 8 && (F.data = x[12]),
          !p &&
            I & 4 &&
            ((p = !0), (F.show = x[2]), add_flush_callback(() => (p = !1))),
          r.$set(F);
      },
      i(x) {
        v || (transition_in(r.$$.fragment, x), (v = !0));
      },
      o(x) {
        transition_out(r.$$.fragment, x), (v = !1);
      },
      d(x) {
        destroy_component(r, x);
      },
    }
  );
}
function create_fragment$k(k) {
  let r,
    p,
    v = k[3],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$4(get_each_context$4(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      r = element("div");
      for (let x = 0; x < $.length; x += 1) $[x].c();
      attr(r, "class", "contextmenu"),
        set_style(r, "top", k[1] + "px"),
        set_style(r, "left", k[0] + "px"),
        set_style(r, "z-index", k[8] + 10),
        toggle_class(r, "show", k[2]);
    },
    m(x, I) {
      insert(x, r, I);
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(r, null);
      k[10](r), (p = !0);
    },
    p(x, [I]) {
      if (I & 124) {
        v = x[3];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$4(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$4(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
      (!p || I & 2) && set_style(r, "top", x[1] + "px"),
        (!p || I & 1) && set_style(r, "left", x[0] + "px"),
        (!p || I & 256) && set_style(r, "z-index", x[8] + 10),
        (!p || I & 4) && toggle_class(r, "show", x[2]);
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      x && detach(r), destroy_each($, x), k[10](null);
    },
  };
}
function instance$j(k, r, p) {
  let v;
  component_subscribe(k, maxZIndex, (R) => p(8, (v = R)));
  let $ = 0,
    S = 0,
    x = !1,
    I = [],
    F,
    O,
    L,
    U;
  onMount(() => {
    document.addEventListener("contextmenu", j),
      document.addEventListener("mousedown", (R) => {
        R.button != 0 || R.composedPath().includes(U) || p(2, (x = !1));
      });
  });
  function j(R) {
    p(2, (x = !1)), R.preventDefault();
    const Q = getWindowElementByEvent(R);
    if (!Q) return;
    const H = getWindow(Q.id),
      G = getCallerScope(R);
    if (!G) return;
    const V = G == null ? void 0 : G.dataset.caller;
    p(3, (I = getContextEntry(Q.id, V) || [])),
      I.length &&
        (p(5, (O = V)),
        p(4, (F = H)),
        p(6, (L = G.dataset)),
        p(2, (x = !0)),
        setTimeout(() => {
          const K = U.offsetWidth,
            Y = U.offsetHeight;
          p(0, ([$, S] = composePosition(R, K, Y)), $, p(1, S));
        }));
  }
  function N(R) {
    (x = R), p(2, x);
  }
  function q(R) {
    binding_callbacks[R ? "unshift" : "push"](() => {
      (U = R), p(7, U);
    });
  }
  return [$, S, x, I, F, O, L, U, v, N, q];
}
class ContextMenu extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$j, create_fragment$k, safe_not_equal, {});
  }
}
function create_fragment$j(k) {
  let r,
    p = k[0].caption + "",
    v,
    $,
    S;
  return {
    c() {
      (r = element("button")), (v = text(p));
    },
    m(x, I) {
      insert(x, r, I),
        append(r, v),
        $ || ((S = listen(r, "click", k[1])), ($ = !0));
    },
    p(x, [I]) {
      I & 1 && p !== (p = x[0].caption + "") && set_data(v, p);
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r), ($ = !1), S();
    },
  };
}
function instance$i(k, r, p) {
  let { button: v } = r,
    { msg: $ } = r;
  function S() {
    v.action(), x();
  }
  function x() {
    closeError($.id);
  }
  return (
    (k.$$set = (I) => {
      "button" in I && p(0, (v = I.button)), "msg" in I && p(2, ($ = I.msg));
    }),
    [v, S, $]
  );
}
class Button extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$i, create_fragment$j, safe_not_equal, {
        button: 0,
        msg: 2,
      });
  }
}
function get_each_context$3(k, r, p) {
  const v = k.slice();
  return (v[2] = r[p]), v;
}
function get_each_context_1(k, r, p) {
  const v = k.slice();
  return (v[5] = r[p]), v;
}
function get_each_context_2(k, r, p) {
  const v = k.slice();
  return (v[8] = r[p]), v;
}
function create_if_block$b(k) {
  let r,
    p = k[5].message + "",
    v,
    $,
    S,
    x,
    I,
    F,
    O,
    L = k[5].buttons,
    U = [];
  for (let N = 0; N < L.length; N += 1)
    U[N] = create_each_block_2(get_each_context_2(k, L, N));
  const j = (N) =>
    transition_out(U[N], 1, 1, () => {
      U[N] = null;
    });
  return {
    c() {
      (r = element("p")),
        (v = space()),
        ($ = element("center")),
        (S = element("br")),
        (x = space());
      for (let N = 0; N < U.length; N += 1) U[N].c();
      (I = space()), (F = element("br"));
    },
    m(N, q) {
      insert(N, r, q),
        (r.innerHTML = p),
        insert(N, v, q),
        insert(N, $, q),
        append($, S),
        append($, x);
      for (let R = 0; R < U.length; R += 1) U[R] && U[R].m($, null);
      append($, I), append($, F), (O = !0);
    },
    p(N, q) {
      if (
        ((!O || q & 2) && p !== (p = N[5].message + "") && (r.innerHTML = p),
        q & 2)
      ) {
        L = N[5].buttons;
        let R;
        for (R = 0; R < L.length; R += 1) {
          const Q = get_each_context_2(N, L, R);
          U[R]
            ? (U[R].p(Q, q), transition_in(U[R], 1))
            : ((U[R] = create_each_block_2(Q)),
              U[R].c(),
              transition_in(U[R], 1),
              U[R].m($, I));
        }
        for (group_outros(), R = L.length; R < U.length; R += 1) j(R);
        check_outros();
      }
    },
    i(N) {
      if (!O) {
        for (let q = 0; q < L.length; q += 1) transition_in(U[q]);
        O = !0;
      }
    },
    o(N) {
      U = U.filter(Boolean);
      for (let q = 0; q < U.length; q += 1) transition_out(U[q]);
      O = !1;
    },
    d(N) {
      N && detach(r), N && detach(v), N && detach($), destroy_each(U, N);
    },
  };
}
function create_each_block_2(k) {
  let r, p;
  return (
    (r = new Button({ props: { button: k[8], msg: k[5] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 2 && (S.button = v[8]), $ & 2 && (S.msg = v[5]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block_1(k) {
  let r,
    p,
    v = `error_${k[5].id}` == k[2].id && create_if_block$b(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, S) {
      `error_${$[5].id}` == $[2].id
        ? v
          ? (v.p($, S), S & 3 && transition_in(v, 1))
          : ((v = create_if_block$b($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function create_default_slot(k) {
  let r,
    p,
    v = k[1],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block_1(get_each_context_1(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      for (let x = 0; x < $.length; x += 1) $[x].c();
      r = space();
    },
    m(x, I) {
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(x, I);
      insert(x, r, I), (p = !0);
    },
    p(x, I) {
      if (I & 3) {
        v = x[1];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_1(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block_1(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      destroy_each($, x), x && detach(r);
    },
  };
}
function create_each_block$3(k) {
  let r, p;
  return (
    (r = new Window({
      props: {
        app: k[2],
        $$slots: { default: [create_default_slot] },
        $$scope: { ctx: k },
      },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.app = v[2]),
          $ & 2051 && (S.$$scope = { dirty: $, ctx: v }),
          r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$i(k) {
  let r,
    p,
    v = k[0],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$3(get_each_context$3(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      r = element("div");
      for (let x = 0; x < $.length; x += 1) $[x].c();
      attr(r, "class", "winstore");
    },
    m(x, I) {
      insert(x, r, I);
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(r, null);
      p = !0;
    },
    p(x, [I]) {
      if (I & 3) {
        v = x[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$3(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$3(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      x && detach(r), destroy_each($, x);
    },
  };
}
function instance$h(k, r, p) {
  let v, $;
  return (
    component_subscribe(k, ErrorWindowStore, (S) => p(0, (v = S))),
    component_subscribe(k, ErrorMessages, (S) => p(1, ($ = S))),
    [v, $]
  );
}
class ErrorDialogStore extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$h, create_fragment$i, safe_not_equal, {});
  }
}
function get_each_context$2(k, r, p) {
  const v = k.slice();
  return (v[8] = r[p]), v;
}
function create_if_block$a(k) {
  let r,
    p,
    v = k[0].title + "",
    $,
    S,
    x,
    I,
    F,
    O = k[0].message + "",
    L,
    U,
    j,
    N;
  function q(V, K) {
    return V[0].image ? create_if_block_1$2 : create_else_block$2;
  }
  let R = q(k),
    Q = R(k),
    H = k[0].buttons,
    G = [];
  for (let V = 0; V < H.length; V += 1)
    G[V] = create_each_block$2(get_each_context$2(k, H, V));
  return {
    c() {
      (r = element("p")),
        Q.c(),
        (p = space()),
        ($ = text(v)),
        (S = space()),
        (x = element("button")),
        (x.textContent = "close"),
        (I = space()),
        (F = element("p")),
        (L = space()),
        (U = element("div"));
      for (let V = 0; V < G.length; V += 1) G[V].c();
      attr(x, "class", "close material-icons-round"),
        attr(r, "class", "title"),
        attr(F, "class", "message"),
        attr(U, "class", "buttons");
    },
    m(V, K) {
      insert(V, r, K),
        Q.m(r, null),
        append(r, p),
        append(r, $),
        append(r, S),
        append(r, x),
        insert(V, I, K),
        insert(V, F, K),
        (F.innerHTML = O),
        insert(V, L, K),
        insert(V, U, K);
      for (let Y = 0; Y < G.length; Y += 1) G[Y] && G[Y].m(U, null);
      j || ((N = listen(x, "click", k[4])), (j = !0));
    },
    p(V, K) {
      if (
        (R === (R = q(V)) && Q
          ? Q.p(V, K)
          : (Q.d(1), (Q = R(V)), Q && (Q.c(), Q.m(r, p))),
        K & 1 && v !== (v = V[0].title + "") && set_data($, v),
        K & 1 && O !== (O = V[0].message + "") && (F.innerHTML = O),
        K & 33)
      ) {
        H = V[0].buttons;
        let Y;
        for (Y = 0; Y < H.length; Y += 1) {
          const J = get_each_context$2(V, H, Y);
          G[Y]
            ? G[Y].p(J, K)
            : ((G[Y] = create_each_block$2(J)), G[Y].c(), G[Y].m(U, null));
        }
        for (; Y < G.length; Y += 1) G[Y].d(1);
        G.length = H.length;
      }
    },
    d(V) {
      V && detach(r),
        Q.d(),
        V && detach(I),
        V && detach(F),
        V && detach(L),
        V && detach(U),
        destroy_each(G, V),
        (j = !1),
        N();
    },
  };
}
function create_else_block$2(k) {
  let r,
    p = k[0].icon + "",
    v;
  return {
    c() {
      (r = element("span")),
        (v = text(p)),
        attr(r, "class", "material-icons-round");
    },
    m($, S) {
      insert($, r, S), append(r, v);
    },
    p($, S) {
      S & 1 && p !== (p = $[0].icon + "") && set_data(v, p);
    },
    d($) {
      $ && detach(r);
    },
  };
}
function create_if_block_1$2(k) {
  let r, p, v;
  return {
    c() {
      (r = element("img")),
        src_url_equal(r.src, (p = k[0].image)) || attr(r, "src", p),
        attr(r, "alt", (v = k[0].title));
    },
    m($, S) {
      insert($, r, S);
    },
    p($, S) {
      S & 1 && !src_url_equal(r.src, (p = $[0].image)) && attr(r, "src", p),
        S & 1 && v !== (v = $[0].title) && attr(r, "alt", v);
    },
    d($) {
      $ && detach(r);
    },
  };
}
function create_each_block$2(k) {
  let r,
    p = k[8].capt + "",
    v,
    $,
    S;
  return {
    c() {
      (r = element("button")), (v = text(p));
    },
    m(x, I) {
      insert(x, r, I),
        append(r, v),
        $ ||
          ((S = listen(r, "click", function () {
            is_function(k[5](k[8].action)) &&
              k[5](k[8].action).apply(this, arguments);
          })),
          ($ = !0));
    },
    p(x, I) {
      (k = x), I & 1 && p !== (p = k[8].capt + "") && set_data(v, p);
    },
    d(x) {
      x && detach(r), ($ = !1), S();
    },
  };
}
function create_fragment$h(k) {
  let r,
    p = k[0] && create_if_block$a(k);
  return {
    c() {
      (r = element("div")),
        p && p.c(),
        attr(r, "class", "notification"),
        set_style(r, "z-index", k[3] + 4),
        toggle_class(r, "hidden", !k[0] || k[1]),
        toggle_class(r, "colored", k[2].sh.taskbar.colored),
        toggle_class(r, "nobutt", k[0] && !k[0].buttons.length);
    },
    m(v, $) {
      insert(v, r, $), p && p.m(r, null);
    },
    p(v, [$]) {
      v[0]
        ? p
          ? p.p(v, $)
          : ((p = create_if_block$a(v)), p.c(), p.m(r, null))
        : p && (p.d(1), (p = null)),
        $ & 8 && set_style(r, "z-index", v[3] + 4),
        $ & 3 && toggle_class(r, "hidden", !v[0] || v[1]),
        $ & 4 && toggle_class(r, "colored", v[2].sh.taskbar.colored),
        $ & 1 && toggle_class(r, "nobutt", v[0] && !v[0].buttons.length);
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      v && detach(r), p && p.d();
    },
  };
}
function instance$g(k, r, p) {
  let v, $, S;
  component_subscribe(k, NotificationStore, (U) => p(7, (v = U))),
    component_subscribe(k, UserData, (U) => p(2, ($ = U))),
    component_subscribe(k, maxZIndex, (U) => p(3, (S = U)));
  let x = null,
    I = !1,
    F;
  CurrentNotification.subscribe((U) => {
    if (U) {
      p(1, (I = !0)),
        p(0, (x = null)),
        (F = U),
        setTimeout(() => {
          p(1, (I = !1)), p(0, (x = v[U]));
        }, 250);
      return;
    }
    p(1, (I = !0)),
      setTimeout(() => {
        p(0, (x = null));
      }, 300);
  });
  function O() {
    closeNotification();
  }
  function L(U) {
    return () => {
      U(), O(), deleteNotification(F);
    };
  }
  return [x, I, $, S, O, L];
}
class PushNotification extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$g, create_fragment$h, safe_not_equal, {});
  }
}
function get_each_context$1(k, r, p) {
  const v = k.slice();
  return (v[2] = r[p]), v;
}
function create_if_block$9(k) {
  let r, p;
  return (
    (r = new Window({ props: { app: k[2] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, $) {
        mount_component(r, v, $), (p = !0);
      },
      p(v, $) {
        const S = {};
        $ & 1 && (S.app = v[2]), r.$set(S);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$1(k) {
  let r,
    p,
    v = k[2] && !k[2].disabled && create_if_block$9(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, S) {
      $[2] && !$[2].disabled
        ? v
          ? (v.p($, S), S & 1 && transition_in(v, 1))
          : ((v = create_if_block$9($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function create_fragment$g(k) {
  let r,
    p,
    v = k[0],
    $ = [];
  for (let x = 0; x < v.length; x += 1)
    $[x] = create_each_block$1(get_each_context$1(k, v, x));
  const S = (x) =>
    transition_out($[x], 1, 1, () => {
      $[x] = null;
    });
  return {
    c() {
      r = element("div");
      for (let x = 0; x < $.length; x += 1) $[x].c();
      attr(r, "class", "winstore");
    },
    m(x, I) {
      insert(x, r, I);
      for (let F = 0; F < $.length; F += 1) $[F] && $[F].m(r, null);
      p = !0;
    },
    p(x, [I]) {
      if (I & 1) {
        v = x[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$1(x, v, F);
          $[F]
            ? ($[F].p(O, I), transition_in($[F], 1))
            : (($[F] = create_each_block$1(O)),
              $[F].c(),
              transition_in($[F], 1),
              $[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < $.length; F += 1) S(F);
        check_outros();
      }
    },
    i(x) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in($[I]);
        p = !0;
      }
    },
    o(x) {
      $ = $.filter(Boolean);
      for (let I = 0; I < $.length; I += 1) transition_out($[I]);
      p = !1;
    },
    d(x) {
      x && detach(r), destroy_each($, x);
    },
  };
}
function instance$f(k, r, p) {
  let v;
  component_subscribe(k, maxZIndex, (S) => p(1, (v = S)));
  let $ = [];
  return (
    WindowStore.subscribe((S) => {
      p(0, ($ = [])), S && p(0, ($ = S));
      const x = getOpenedStore();
      for (let I = 0; I < x.length; I++)
        if (x[I].state.windowState.fll) return isFullscreenWindow.set(!0);
      isFullscreenWindow.set(!1);
    }),
    focusedWindowId.subscribe((S) => {
      var F;
      if ((F = getWindow(S)) != null && F.info.custom) return;
      if ((set_store_value(maxZIndex, v++, v), !S || S.startsWith("error_"))) {
        if (!S) return;
        const O = document.querySelector(`#${S}`);
        if (!O) return;
        O.style.zIndex = `${v}`;
        return;
      }
      const x = getWindow(S);
      if (!x) return;
      const I = getWindowElement(x);
      I && (I.style.zIndex = `${v}`);
    }),
    [$]
  );
}
class WindowStore_1 extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$f, create_fragment$g, safe_not_equal, {});
  }
}
function create_if_block$8(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j;
  return (
    (p = new WindowStore_1({})),
    ($ = new ErrorDialogStore({})),
    (x = new ContextMenu({})),
    (F = new ArcFind({})),
    (L = new PushNotification({})),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          create_component($.$$.fragment),
          (S = space()),
          create_component(x.$$.fragment),
          (I = space()),
          create_component(F.$$.fragment),
          (O = space()),
          create_component(L.$$.fragment),
          attr(
            r,
            "class",
            (U =
              "desktop theme-" +
              k[2].sh.desktop.theme +
              " tb-" +
              k[2].sh.taskbar.pos +
              " fullscreen " +
              k[1])
          ),
          set_style(
            r,
            "--accent",
            "#" + (k[2].sh.desktop.accent || "70D6FF"),
            1
          ),
          toggle_class(r, "show", k[0]);
      },
      m(N, q) {
        insert(N, r, q),
          mount_component(p, r, null),
          append(r, v),
          mount_component($, r, null),
          append(r, S),
          mount_component(x, r, null),
          append(r, I),
          mount_component(F, r, null),
          append(r, O),
          mount_component(L, r, null),
          (j = !0);
      },
      p(N, q) {
        (!j ||
          (q & 6 &&
            U !==
              (U =
                "desktop theme-" +
                N[2].sh.desktop.theme +
                " tb-" +
                N[2].sh.taskbar.pos +
                " fullscreen " +
                N[1]))) &&
          attr(r, "class", U),
          (!j || q & 4) &&
            set_style(
              r,
              "--accent",
              "#" + (N[2].sh.desktop.accent || "70D6FF"),
              1
            ),
          (!j || q & 7) && toggle_class(r, "show", N[0]);
      },
      i(N) {
        j ||
          (transition_in(p.$$.fragment, N),
          transition_in($.$$.fragment, N),
          transition_in(x.$$.fragment, N),
          transition_in(F.$$.fragment, N),
          transition_in(L.$$.fragment, N),
          (j = !0));
      },
      o(N) {
        transition_out(p.$$.fragment, N),
          transition_out($.$$.fragment, N),
          transition_out(x.$$.fragment, N),
          transition_out(F.$$.fragment, N),
          transition_out(L.$$.fragment, N),
          (j = !1);
      },
      d(N) {
        N && detach(r),
          destroy_component(p),
          destroy_component($),
          destroy_component(x),
          destroy_component(F),
          destroy_component(L);
      },
    }
  );
}
function create_fragment$f(k) {
  let r,
    p,
    v = k[2] && k[3] && !k[4] && create_if_block$8(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, [S]) {
      $[2] && $[3] && !$[4]
        ? v
          ? (v.p($, S), S & 28 && transition_in(v, 1))
          : ((v = create_if_block$8($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function instance$e(k, r, p) {
  let v, $, S;
  component_subscribe(k, UserData, (O) => p(2, (v = O))),
    component_subscribe(k, UserName, (O) => p(3, ($ = O))),
    component_subscribe(k, loggingOff, (O) => p(4, (S = O)));
  let x = !1,
    I = "";
  desktopClassNames.subscribe((O) => p(1, (I = O))),
    showDesktop.subscribe((O) => p(0, (x = O))),
    onMount(() => {
      assignDesktopListeners(),
        importDefault(),
        F(),
        startKeyListener(),
        importAutoLoaders(),
        setTimeout(() => p(0, (x = !0)), 250),
        startMessageCheckInterval();
    });
  function F() {
    WindowStore.set([]),
      isFullscreenWindow.set(!1),
      updateStores(),
      startOpened.set(!1),
      loggingOff.set(!1),
      ErrorMessages.set([]),
      DevModeOverride.set(v.devmode);
  }
  return [x, I, v, $, S];
}
class Desktop extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$e, create_fragment$f, safe_not_equal, {});
  }
}
const fts = "",
  connect = "./assets/connect-7fe4df73.svg",
  finish = "./assets/finish-b74612a1.svg",
  license = "./assets/license-c775bee3.svg",
  wave = "./assets/wave-1b0d0ba8.svg",
  connecttocloud = "";
function create_fragment$e(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("button")),
        ($ = element("span")),
        ($.textContent = "arrow_back_ios_new"),
        (x = space()),
        (I = element("div")),
        (F = element("button")),
        (O = element("span")),
        (O.textContent = "arrow_forward_ios"),
        attr($, "class", "material-icons-round"),
        attr(v, "class", "nopad"),
        (v.disabled = S = k[0].back.disabled),
        attr(O, "class", "material-icons-round"),
        attr(F, "class", "nopad"),
        (F.disabled = L = k[0].forw.disabled),
        attr(I, "class", "alnr"),
        attr(r, "class", "nav");
    },
    m(N, q) {
      insert(N, r, q),
        append(r, p),
        append(p, v),
        append(v, $),
        append(r, x),
        append(r, I),
        append(I, F),
        append(F, O),
        U ||
          ((j = [listen(v, "click", k[1]), listen(F, "click", k[2])]),
          (U = !0));
    },
    p(N, [q]) {
      q & 1 && S !== (S = N[0].back.disabled) && (v.disabled = S),
        q & 1 && L !== (L = N[0].forw.disabled) && (F.disabled = L);
    },
    i: noop$1,
    o: noop$1,
    d(N) {
      N && detach(r), (U = !1), run_all(j);
    },
  };
}
function instance$d(k, r, p) {
  let { data: v } = r;
  function $() {
    applyFTSState(v.back.redir);
  }
  function S() {
    applyFTSState(v.forw.redir);
  }
  return (
    (k.$$set = (x) => {
      "data" in x && p(0, (v = x.data));
    }),
    [v, $, S]
  );
}
class Nav extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$d, create_fragment$e, safe_not_equal, { data: 0 });
  }
}
function create_else_block$1(k) {
  let r;
  return {
    c() {
      r = text("Connecting...");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_if_block_1$1(k) {
  let r;
  return {
    c() {
      r = text("Connect to server");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_if_block$7(k) {
  let r;
  return {
    c() {
      (r = element("p")),
        (r.innerHTML =
          '<span class="material-icons-round">error</span>Connection to ArcAPI failed!'),
        attr(r, "class", "fullwidth centered connect-error");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$d(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R, Q, H, G;
  function V(Z, X) {
    return Z[1] ? create_else_block$1 : create_if_block_1$1;
  }
  let K = V(k),
    Y = K(k),
    J = k[2] && create_if_block$7();
  return (
    (R = new Nav({
      props: {
        data: {
          back: { disabled: !1, redir: "license" },
          forw: { disabled: !0, redir: "finish" },
          prog: { max: 4, val: 3 },
        },
      },
    })),
    {
      c() {
        (r = element("div")),
          (p = element("img")),
          ($ = space()),
          (S = element("h1")),
          (S.textContent = "Time to get connected"),
          (x = space()),
          (I = element("p")),
          (I.textContent = "Enter the hostname of your ArcAPI:"),
          (F = space()),
          (O = element("input")),
          (L = space()),
          (U = element("button")),
          Y.c(),
          (N = space()),
          J && J.c(),
          (q = space()),
          create_component(R.$$.fragment),
          src_url_equal(p.src, (v = connect)) || attr(p, "src", v),
          attr(p, "alt", "Mode"),
          attr(I, "class", "subtitle"),
          attr(r, "class", "header centered"),
          attr(O, "class", "fullwidth centered"),
          attr(O, "placeholder", "Server name"),
          attr(U, "class", "fullwidth option centered"),
          (U.disabled = j = !k[0] || k[1]);
      },
      m(Z, X) {
        insert(Z, r, X),
          append(r, p),
          append(r, $),
          append(r, S),
          append(r, x),
          append(r, I),
          insert(Z, F, X),
          insert(Z, O, X),
          set_input_value(O, k[0]),
          insert(Z, L, X),
          insert(Z, U, X),
          Y.m(U, null),
          insert(Z, N, X),
          J && J.m(Z, X),
          insert(Z, q, X),
          mount_component(R, Z, X),
          (Q = !0),
          H ||
            ((G = [listen(O, "input", k[4]), listen(U, "click", k[3])]),
            (H = !0));
      },
      p(Z, [X]) {
        X & 1 && O.value !== Z[0] && set_input_value(O, Z[0]),
          K !== (K = V(Z)) && (Y.d(1), (Y = K(Z)), Y && (Y.c(), Y.m(U, null))),
          (!Q || (X & 3 && j !== (j = !Z[0] || Z[1]))) && (U.disabled = j),
          Z[2]
            ? J || ((J = create_if_block$7()), J.c(), J.m(q.parentNode, q))
            : J && (J.d(1), (J = null));
      },
      i(Z) {
        Q || (transition_in(R.$$.fragment, Z), (Q = !0));
      },
      o(Z) {
        transition_out(R.$$.fragment, Z), (Q = !1);
      },
      d(Z) {
        Z && detach(r),
          Z && detach(F),
          Z && detach(O),
          Z && detach(L),
          Z && detach(U),
          Y.d(),
          Z && detach(N),
          J && J.d(Z),
          Z && detach(q),
          destroy_component(R, Z),
          (H = !1),
          run_all(G);
      },
    }
  );
}
function instance$c(k, r, p) {
  let v = "",
    $ = !1,
    S = !1;
  async function x() {
    p(1, ($ = !0)),
      p(2, (S = !1)),
      (await testConnection(v))
        ? (localStorage.setItem("arcos-server", v), applyFTSState("finish"))
        : p(2, (S = !0)),
      p(1, ($ = !1));
  }
  function I() {
    (v = this.value), p(0, v);
  }
  return [v, $, S, x, I];
}
class ConnectToCloud extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$c, create_fragment$d, safe_not_equal, {});
  }
}
function create_fragment$c(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N, q, R;
  return {
    c() {
      (r = element("div")),
        (p = element("img")),
        ($ = space()),
        (S = element("h1")),
        (S.textContent = "Thank you!"),
        (x = space()),
        (I = element("p")),
        (I.textContent = "We greatly appreciate it."),
        (F = space()),
        (O = element("p")),
        (O.textContent = `Thank you for checking out ArcOS! We hope you'll enjoy it as much as we love
  making it. Please restart ArcOS to use your ArcOS instance.`),
        (L = space()),
        (U = element("br")),
        (j = space()),
        (N = element("button")),
        (N.textContent = "Restart"),
        src_url_equal(p.src, (v = finish)) || attr(p, "src", v),
        attr(p, "alt", "Mode"),
        attr(I, "class", "subtitle"),
        attr(r, "class", "header centered"),
        attr(O, "class", "fullwidth centered justified"),
        attr(N, "class", "fullwidth option centered");
    },
    m(Q, H) {
      insert(Q, r, H),
        append(r, p),
        append(r, $),
        append(r, S),
        append(r, x),
        append(r, I),
        insert(Q, F, H),
        insert(Q, O, H),
        insert(Q, L, H),
        insert(Q, U, H),
        insert(Q, j, H),
        insert(Q, N, H),
        q || ((R = listen(N, "click", k[0])), (q = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(Q) {
      Q && detach(r),
        Q && detach(F),
        Q && detach(O),
        Q && detach(L),
        Q && detach(U),
        Q && detach(j),
        Q && detach(N),
        (q = !1),
        R();
    },
  };
}
function instance$b(k) {
  function r() {
    applyState("boot");
  }
  return [r];
}
class Finish extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$b, create_fragment$c, safe_not_equal, {});
  }
}
function create_fragment$b(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N;
  return {
    c() {
      (r = element("div")),
        (p = element("img")),
        ($ = space()),
        (S = element("h1")),
        (S.textContent = "License agreement"),
        (x = space()),
        (I = element("p")),
        (I.textContent = "By using ArcOS, you agree to the GPLv3 License."),
        (F = space()),
        (O = element("button")),
        (O.textContent = "Open license"),
        (L = space()),
        (U = element("button")),
        (U.textContent = "I Agree"),
        src_url_equal(p.src, (v = license)) || attr(p, "src", v),
        attr(p, "alt", "Mode"),
        attr(I, "class", "subtitle"),
        attr(r, "class", "header centered"),
        attr(O, "class", "fullwidth option centered"),
        attr(U, "class", "fullwidth option centered");
    },
    m(q, R) {
      insert(q, r, R),
        append(r, p),
        append(r, $),
        append(r, S),
        append(r, x),
        append(r, I),
        insert(q, F, R),
        insert(q, O, R),
        insert(q, L, R),
        insert(q, U, R),
        j ||
          ((N = [listen(O, "click", openIt), listen(U, "click", k[0])]),
          (j = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(q) {
      q && detach(r),
        q && detach(F),
        q && detach(O),
        q && detach(L),
        q && detach(U),
        (j = !1),
        run_all(N);
    },
  };
}
function openIt() {
  window.open("https://www.gnu.org/licenses/gpl-3.0-standalone.html", "_blank");
}
function instance$a(k) {
  return [() => applyFTSState("connecttocloud")];
}
class License extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$a, create_fragment$b, safe_not_equal, {});
  }
}
const welcome = "";
function create_fragment$a(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (x = element("h1")),
        (x.textContent = "Welcome"),
        (I = space()),
        (F = element("p")),
        (F.textContent = "Time to set-up ArcOS."),
        (O = space()),
        (L = element("button")),
        (L.textContent = "Let's begin"),
        src_url_equal(v.src, ($ = logo$c)) || attr(v, "src", $),
        attr(v, "alt", "ArcOS"),
        attr(v, "class", "logo"),
        attr(x, "class", "center-header"),
        attr(F, "class", "center"),
        attr(r, "class", "center-flex");
    },
    m(N, q) {
      insert(N, r, q),
        append(r, p),
        append(p, v),
        append(p, S),
        append(p, x),
        append(p, I),
        append(p, F),
        append(p, O),
        append(p, L),
        U || ((j = listen(L, "click", k[0])), (U = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(N) {
      N && detach(r), (U = !1), j();
    },
  };
}
function instance$9(k) {
  return [() => applyFTSState("license")];
}
class Welcome extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$9, create_fragment$a, safe_not_equal, {});
  }
}
const FTSStates = new Map([
    [
      "welcome",
      {
        name: "Welcome",
        content: Welcome,
        attribs: {},
        key: "welcome",
        image: wave,
      },
    ],
    [
      "license",
      {
        name: "License",
        content: License,
        attribs: {},
        key: "license",
        image: license,
      },
    ],
    [
      "connecttocloud",
      {
        name: "Connect to ArcOS",
        content: ConnectToCloud,
        attribs: {},
        key: "connecttocloud",
        image: connect,
      },
    ],
    [
      "finish",
      {
        name: "Finish",
        content: Finish,
        attribs: {},
        key: "finish",
        image: finish,
      },
    ],
  ]),
  CurrentFTSState = writable();
function applyFTSState(k) {
  if (FTSStates.has(k)) {
    Log({
      level: LogLevel.info,
      source: "applyFTSState",
      msg: `Applying state ${k}`,
    });
    const r = FTSStates.get(k);
    CurrentFTSState.set(r);
    return;
  }
  InvalidStateBugrep("FirstTimeSetup", k);
}
function create_else_block(k) {
  let r, p, v;
  return (
    (p = new Spinner({ props: { height: 60 } })),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          attr(r, "class", "center-absolute centertext");
      },
      m($, S) {
        insert($, r, S), mount_component(p, r, null), (v = !0);
      },
      p: noop$1,
      i($) {
        v || (transition_in(p.$$.fragment, $), (v = !0));
      },
      o($) {
        transition_out(p.$$.fragment, $), (v = !1);
      },
      d($) {
        $ && detach(r), destroy_component(p);
      },
    }
  );
}
function create_if_block$6(k) {
  let r, p, v, $;
  var S = k[1].content;
  function x(I) {
    return {};
  }
  return (
    S && (p = construct_svelte_component(S, x())),
    {
      c() {
        (r = element("div")),
          p && create_component(p.$$.fragment),
          attr(r, "class", (v = "page " + k[0]));
      },
      m(I, F) {
        insert(I, r, F), p && mount_component(p, r, null), ($ = !0);
      },
      p(I, F) {
        if (F & 2 && S !== (S = I[1].content)) {
          if (p) {
            group_outros();
            const O = p;
            transition_out(O.$$.fragment, 1, 0, () => {
              destroy_component(O, 1);
            }),
              check_outros();
          }
          S
            ? ((p = construct_svelte_component(S, x())),
              create_component(p.$$.fragment),
              transition_in(p.$$.fragment, 1),
              mount_component(p, r, null))
            : (p = null);
        }
        (!$ || (F & 1 && v !== (v = "page " + I[0]))) && attr(r, "class", v);
      },
      i(I) {
        $ || (p && transition_in(p.$$.fragment, I), ($ = !0));
      },
      o(I) {
        p && transition_out(p.$$.fragment, I), ($ = !1);
      },
      d(I) {
        I && detach(r), p && destroy_component(p);
      },
    }
  );
}
function create_fragment$9(k) {
  let r, p, v, $, S;
  const x = [create_if_block$6, create_else_block],
    I = [];
  function F(O, L) {
    return O[1] ? 0 : 1;
  }
  return (
    (p = F(k)),
    (v = I[p] = x[p](k)),
    {
      c() {
        (r = element("div")),
          v.c(),
          attr(r, "class", ($ = "right " + (k[1] ? k[1].key : "")));
      },
      m(O, L) {
        insert(O, r, L), I[p].m(r, null), (S = !0);
      },
      p(O, [L]) {
        let U = p;
        (p = F(O)),
          p === U
            ? I[p].p(O, L)
            : (group_outros(),
              transition_out(I[U], 1, 1, () => {
                I[U] = null;
              }),
              check_outros(),
              (v = I[p]),
              v ? v.p(O, L) : ((v = I[p] = x[p](O)), v.c()),
              transition_in(v, 1),
              v.m(r, null)),
          (!S || (L & 2 && $ !== ($ = "right " + (O[1] ? O[1].key : "")))) &&
            attr(r, "class", $);
      },
      i(O) {
        S || (transition_in(v), (S = !0));
      },
      o(O) {
        transition_out(v), (S = !1);
      },
      d(O) {
        O && detach(r), I[p].d();
      },
    }
  );
}
function instance$8(k, r, p) {
  let v;
  component_subscribe(k, CurrentFTSState, (x) => p(1, (v = x)));
  let $ = "",
    S = [];
  return (
    CurrentFTSState.subscribe((x) => {
      x && p(0, ($ = x.name.split(" ")[0].toLowerCase()));
    }),
    onMount(() => {
      S = [];
      for (const x of FTSStates) S.push(x[0]);
    }),
    [$, v]
  );
}
class Right extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$8, create_fragment$9, safe_not_equal, {});
  }
}
function get_each_context(k, r, p) {
  const v = k.slice();
  return (v[2] = r[p][0]), (v[3] = r[p][1]), v;
}
function create_each_block(k) {
  let r,
    p,
    v,
    $,
    S = k[3].name + "",
    x,
    I;
  return {
    c() {
      (r = element("div")),
        (p = element("img")),
        ($ = space()),
        (x = text(S)),
        (I = space()),
        src_url_equal(p.src, (v = k[3].image)) || attr(p, "src", v),
        attr(p, "alt", k[3].name),
        attr(r, "class", "state"),
        toggle_class(r, "activated", k[1] && k[1].key == k[2]);
    },
    m(F, O) {
      insert(F, r, O), append(r, p), append(r, $), append(r, x), append(r, I);
    },
    p(F, O) {
      O & 2 && toggle_class(r, "activated", F[1] && F[1].key == F[2]);
    },
    d(F) {
      F && detach(r);
    },
  };
}
function create_fragment$8(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I = [...FTSStates],
    F = [];
  for (let O = 0; O < I.length; O += 1)
    F[O] = create_each_block(get_each_context(k, I, O));
  return (
    (S = new Right({})),
    {
      c() {
        (r = element("div")), (p = element("div")), (v = element("div"));
        for (let O = 0; O < F.length; O += 1) F[O].c();
        ($ = space()),
          create_component(S.$$.fragment),
          attr(v, "class", "left"),
          attr(p, "class", "center-absolute"),
          attr(r, "class", "fts fullscreen"),
          toggle_class(r, "show", k[0]);
      },
      m(O, L) {
        insert(O, r, L), append(r, p), append(p, v);
        for (let U = 0; U < F.length; U += 1) F[U] && F[U].m(v, null);
        append(p, $), mount_component(S, p, null), (x = !0);
      },
      p(O, [L]) {
        if (L & 2) {
          I = [...FTSStates];
          let U;
          for (U = 0; U < I.length; U += 1) {
            const j = get_each_context(O, I, U);
            F[U]
              ? F[U].p(j, L)
              : ((F[U] = create_each_block(j)), F[U].c(), F[U].m(v, null));
          }
          for (; U < F.length; U += 1) F[U].d(1);
          F.length = I.length;
        }
        (!x || L & 1) && toggle_class(r, "show", O[0]);
      },
      i(O) {
        x || (transition_in(S.$$.fragment, O), (x = !0));
      },
      o(O) {
        transition_out(S.$$.fragment, O), (x = !1);
      },
      d(O) {
        O && detach(r), destroy_each(F, O), destroy_component(S);
      },
    }
  );
}
function instance$7(k, r, p) {
  let v;
  component_subscribe(k, CurrentFTSState, (S) => p(1, (v = S)));
  let $ = !1;
  return (
    onMount(() => {
      setTimeout(() => p(0, ($ = !0)), 500),
        setTimeout(() => applyFTSState("welcome"), 1e3);
    }),
    [$, v]
  );
}
class FirstTimeSetup extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$7, create_fragment$8, safe_not_equal, {});
  }
}
const login = "";
function create_if_block$5(k) {
  let r;
  return {
    c() {
      (r = element("div")),
        attr(r, "class", "background fullscreen"),
        toggle_class(r, "zoom", k[0].attribs.darken);
    },
    m(p, v) {
      insert(p, r, v);
    },
    p(p, v) {
      v & 1 && toggle_class(r, "zoom", p[0].attribs.darken);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$7(k) {
  let r,
    p = k[0] && create_if_block$5(k);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, $) {
      p && p.m(v, $), insert(v, r, $);
    },
    p(v, [$]) {
      v[0]
        ? p
          ? p.p(v, $)
          : ((p = create_if_block$5(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$6(k, r, p) {
  let v;
  return component_subscribe(k, CurrentLoginState, ($) => p(0, (v = $))), [v];
}
class Background extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$6, create_fragment$7, safe_not_equal, {});
  }
}
function create_if_block$4(k) {
  let r, p, v;
  var $ = k[0].content;
  function S(x) {
    return {};
  }
  return (
    $ && (p = construct_svelte_component($, S())),
    {
      c() {
        (r = element("div")),
          p && create_component(p.$$.fragment),
          attr(r, "class", "center-absolute");
      },
      m(x, I) {
        insert(x, r, I), p && mount_component(p, r, null), (v = !0);
      },
      p(x, I) {
        if (I & 1 && $ !== ($ = x[0].content)) {
          if (p) {
            group_outros();
            const F = p;
            transition_out(F.$$.fragment, 1, 0, () => {
              destroy_component(F, 1);
            }),
              check_outros();
          }
          $
            ? ((p = construct_svelte_component($, S())),
              create_component(p.$$.fragment),
              transition_in(p.$$.fragment, 1),
              mount_component(p, r, null))
            : (p = null);
        }
      },
      i(x) {
        v || (p && transition_in(p.$$.fragment, x), (v = !0));
      },
      o(x) {
        p && transition_out(p.$$.fragment, x), (v = !1);
      },
      d(x) {
        x && detach(r), p && destroy_component(p);
      },
    }
  );
}
function create_fragment$6(k) {
  let r,
    p,
    v = k[0] && create_if_block$4(k);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m($, S) {
      v && v.m($, S), insert($, r, S), (p = !0);
    },
    p($, [S]) {
      $[0]
        ? v
          ? (v.p($, S), S & 1 && transition_in(v, 1))
          : ((v = create_if_block$4($)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i($) {
      p || (transition_in(v), (p = !0));
    },
    o($) {
      transition_out(v), (p = !1);
    },
    d($) {
      v && v.d($), $ && detach(r);
    },
  };
}
function instance$5(k, r, p) {
  let v;
  return component_subscribe(k, CurrentLoginState, ($) => p(0, (v = $))), [v];
}
class Center extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$5, create_fragment$6, safe_not_equal, {});
  }
}
function create_if_block$3(k) {
  let r;
  return {
    c() {
      (r = element("div")),
        attr(r, "class", "fullscreen darken"),
        toggle_class(r, "show", k[0].attribs.darken);
    },
    m(p, v) {
      insert(p, r, v);
    },
    p(p, v) {
      v & 1 && toggle_class(r, "show", p[0].attribs.darken);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$5(k) {
  let r,
    p = k[0] && create_if_block$3(k);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, $) {
      p && p.m(v, $), insert(v, r, $);
    },
    p(v, [$]) {
      v[0]
        ? p
          ? p.p(v, $)
          : ((p = create_if_block$3(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$4(k, r, p) {
  let v;
  return component_subscribe(k, CurrentLoginState, ($) => p(0, (v = $))), [v];
}
class Darken extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$4, create_fragment$5, safe_not_equal, {});
  }
}
function create_if_block$2(k) {
  let r, p, v, $, S, x, I, F, O, L, U, j, N;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = text(k[2])),
        ($ = space()),
        (S = element("div")),
        (x = text(k[0])),
        (I = space()),
        (F = element("div")),
        (O = element("button")),
        (O.innerHTML =
          '<span class="material-icons-round">power_settings_new</span>'),
        (L = space()),
        (U = element("button")),
        (U.innerHTML = '<span class="material-icons-round">restart_alt</span>'),
        attr(p, "class", "hostname"),
        attr(S, "class", "clock"),
        attr(O, "class", "nopad"),
        attr(U, "class", "nopad"),
        attr(F, "class", "right"),
        attr(r, "class", "topbar"),
        toggle_class(r, "show", (k[3].attribs.topbar || !1) && k[1]);
    },
    m(q, R) {
      insert(q, r, R),
        append(r, p),
        append(p, v),
        append(r, $),
        append(r, S),
        append(S, x),
        append(r, I),
        append(r, F),
        append(F, O),
        append(F, L),
        append(F, U),
        j ||
          ((N = [listen(O, "click", k[4]), listen(U, "click", k[5])]),
          (j = !0));
    },
    p(q, R) {
      R & 4 && set_data(v, q[2]),
        R & 1 && set_data(x, q[0]),
        R & 10 && toggle_class(r, "show", (q[3].attribs.topbar || !1) && q[1]);
    },
    d(q) {
      q && detach(r), (j = !1), run_all(N);
    },
  };
}
function create_fragment$4(k) {
  let r,
    p = k[3] && create_if_block$2(k);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, $) {
      p && p.m(v, $), insert(v, r, $);
    },
    p(v, [$]) {
      v[3]
        ? p
          ? p.p(v, $)
          : ((p = create_if_block$2(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$3(k, r, p) {
  let v;
  component_subscribe(k, CurrentLoginState, (O) => p(3, (v = O)));
  let $ = "",
    S = !1,
    x = "";
  onMount(() => {
    setInterval(() => p(0, ($ = dayjs().format("HH:mm"))), 500),
      setTimeout(() => p(1, (S = !0)), 750);
    const O = localStorage.getItem("arcos-server");
    p(2, (x = O ? `API: ${O}` : `Local: ${location.hostname}`));
  });
  function I() {
    loginUsername.set("ArcOS"), applyLoginState("shutdown");
  }
  function F() {
    loginUsername.set("ArcOS"), applyLoginState("restart");
  }
  return [$, S, x, v, I, F];
}
class Topbar extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3, create_fragment$4, safe_not_equal, {});
  }
}
function create_fragment$3(k) {
  let r, p, v, $, S, x, I, F, O;
  return (
    (p = new Background({})),
    ($ = new Darken({})),
    (x = new Topbar({})),
    (F = new Center({})),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          create_component($.$$.fragment),
          (S = space()),
          create_component(x.$$.fragment),
          (I = space()),
          create_component(F.$$.fragment),
          attr(r, "class", "login fullscreen"),
          toggle_class(r, "show", k[0]);
      },
      m(L, U) {
        insert(L, r, U),
          mount_component(p, r, null),
          append(r, v),
          mount_component($, r, null),
          append(r, S),
          mount_component(x, r, null),
          append(r, I),
          mount_component(F, r, null),
          (O = !0);
      },
      p(L, [U]) {
        (!O || U & 1) && toggle_class(r, "show", L[0]);
      },
      i(L) {
        O ||
          (transition_in(p.$$.fragment, L),
          transition_in($.$$.fragment, L),
          transition_in(x.$$.fragment, L),
          transition_in(F.$$.fragment, L),
          (O = !0));
      },
      o(L) {
        transition_out(p.$$.fragment, L),
          transition_out($.$$.fragment, L),
          transition_out(x.$$.fragment, L),
          transition_out(F.$$.fragment, L),
          (O = !1);
      },
      d(L) {
        L && detach(r),
          destroy_component(p),
          destroy_component($),
          destroy_component(x),
          destroy_component(F);
      },
    }
  );
}
function instance$2(k, r, p) {
  let v = !1;
  return (
    onMount(async () => {
      p(0, (v = !1)), await loginOnMount(), p(0, (v = !0));
    }),
    [v]
  );
}
class Login extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2, create_fragment$3, safe_not_equal, {});
  }
}
const safetoturnoff = "./assets/safetoturnoff-95895ce6.png",
  TurnedOff_svelte_svelte_type_style_lang = "";
function create_fragment$2(k) {
  let r, p, v;
  return {
    c() {
      (r = element("div")),
        (p = element("img")),
        src_url_equal(p.src, (v = safetoturnoff)) || attr(p, "src", v),
        attr(p, "alt", "It's now safe to turn off your computer."),
        attr(p, "class", "svelte-1kzg8gn"),
        attr(r, "class", "svelte-1kzg8gn");
    },
    m($, S) {
      insert($, r, S), append(r, p);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d($) {
      $ && detach(r);
    },
  };
}
class TurnedOff extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$2, safe_not_equal, {});
  }
}
const States = new Map([
    ["boot", { name: "Booting...", content: Boot, attribs: {}, key: "boot" }],
    ["login", { name: "Login", content: Login, attribs: {}, key: "login" }],
    [
      "fts",
      {
        name: "First Time Setup",
        content: FirstTimeSetup,
        attribs: {},
        key: "fts",
      },
    ],
    [
      "desktop",
      { name: "Desktop", content: Desktop, attribs: {}, key: "desktop" },
    ],
    [
      "logoff",
      {
        name: "Logoff",
        content: Login,
        attribs: {},
        onload: () => {
          applyLoginState("logoff"), loginUsername.set(null);
        },
        key: "logoff",
      },
    ],
    [
      "restart",
      {
        name: "Restart",
        content: Login,
        attribs: {},
        onload: () => {
          applyLoginState("restart"), loginUsername.set(null);
        },
        key: "restart",
      },
    ],
    [
      "shutdown",
      {
        name: "Shutdown",
        content: Login,
        attribs: {},
        onload: () => {
          applyLoginState("shutdown"), loginUsername.set(null);
        },
        key: "shutdown",
      },
    ],
    [
      "arcterm",
      { name: "ArcTerm", content: ArcTerm_1, attribs: {}, key: "arcterm" },
    ],
    ["blank", { name: "", content: Blank, attribs: {}, key: "blank" }],
    [
      "turnedoff",
      {
        name: "Turned off",
        content: TurnedOff,
        attribs: {},
        key: "turnedoff",
        async onload() {
          await b.close();
        },
      },
    ],
  ]),
  CurrentState = writable(States[0]);
function applyState(k) {
  if (States.has(k)) {
    Log({
      level: LogLevel.info,
      source: "state/main.ts: applyState",
      msg: `Applying state ${k}`,
    });
    const r = States.get(k);
    r.onload && r.onload(), CurrentState.set(r);
    const p = `ArcOS | ${r.name}`;
    document.title = p;
    try {
      b.setTitle(r.name);
    } catch {}
    k != "desktop" && logoffToken();
    return;
  }
  InvalidStateBugrep("ArcOS State Switcher", k);
}
const BugReportData = writable();
function InvalidStateBugrep(k, r) {
  BugReportData.set([
    !0,
    {
      icon: "broken_image",
      title: "Broken page",
      message:
        "ArcOS tried to open a page or location that doesn't exist.<br>This session can't continue. You can choose to restart.",
      button: { action: () => applyState("boot"), caption: "Restart" },
      source: k,
      details: `applyState for ${k}: Can't apply a non-existent state '${r}'.`,
    },
  ]),
    Log({
      level: LogLevel.warn,
      source: `applyState for ${k}`,
      msg: `Can't apply a non-existent state '${r}'.`,
    });
}
function create_if_block$1(k) {
  let r,
    p,
    v,
    $,
    S,
    x,
    I,
    F,
    O = k[2].icon + "",
    L,
    U = k[2].title + "",
    j,
    N,
    q,
    R = k[2].message + "",
    Q,
    H,
    G,
    V,
    K = k[2].button && create_if_block_2(k),
    Y = k[2].details && create_if_block_1(k);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (x = element("div")),
        (I = element("h3")),
        (F = element("span")),
        (L = text(O)),
        (j = text(U)),
        (N = space()),
        (q = element("p")),
        (Q = space()),
        K && K.c(),
        (H = space()),
        (G = element("div")),
        Y && Y.c(),
        attr(v, "class", "logo"),
        src_url_equal(v.src, ($ = logo$c)) || attr(v, "src", $),
        attr(v, "alt", "ArcOS"),
        attr(F, "class", "material-icons-round"),
        attr(p, "class", "content"),
        attr(G, "class", "details"),
        attr(r, "class", (V = "bugrep fullscreen " + k[1])),
        set_style(r, "z-index", k[3] * 10);
    },
    m(J, Z) {
      insert(J, r, Z),
        append(r, p),
        append(p, v),
        append(p, S),
        append(p, x),
        append(x, I),
        append(I, F),
        append(F, L),
        append(I, j),
        append(x, N),
        append(x, q),
        (q.innerHTML = R),
        append(r, Q),
        K && K.m(r, null),
        append(r, H),
        append(r, G),
        Y && Y.m(G, null);
    },
    p(J, Z) {
      Z & 4 && O !== (O = J[2].icon + "") && set_data(L, O),
        Z & 4 && U !== (U = J[2].title + "") && set_data(j, U),
        Z & 4 && R !== (R = J[2].message + "") && (q.innerHTML = R),
        J[2].button
          ? K
            ? K.p(J, Z)
            : ((K = create_if_block_2(J)), K.c(), K.m(r, H))
          : K && (K.d(1), (K = null)),
        J[2].details
          ? Y
            ? Y.p(J, Z)
            : ((Y = create_if_block_1(J)), Y.c(), Y.m(G, null))
          : Y && (Y.d(1), (Y = null)),
        Z & 2 && V !== (V = "bugrep fullscreen " + J[1]) && attr(r, "class", V),
        Z & 8 && set_style(r, "z-index", J[3] * 10);
    },
    d(J) {
      J && detach(r), K && K.d(), Y && Y.d();
    },
  };
}
function create_if_block_2(k) {
  let r,
    p = k[2].button.caption + "",
    v,
    $,
    S;
  return {
    c() {
      (r = element("button")), (v = text(p));
    },
    m(x, I) {
      insert(x, r, I),
        append(r, v),
        $ || ((S = listen(r, "click", k[4])), ($ = !0));
    },
    p(x, I) {
      I & 4 && p !== (p = x[2].button.caption + "") && set_data(v, p);
    },
    d(x) {
      x && detach(r), ($ = !1), S();
    },
  };
}
function create_if_block_1(k) {
  let r,
    p,
    v,
    $ = (k[2].source || "<anonymous>") + "",
    S,
    x,
    I,
    F,
    O,
    L,
    U = (k[2].details || "<anonymous>") + "",
    j;
  return {
    c() {
      (r = element("p")),
        (p = element("span")),
        (p.textContent = "Source :"),
        (v = space()),
        (S = text($)),
        (x = space()),
        (I = element("p")),
        (F = element("span")),
        (F.textContent = "Details:"),
        (O = space()),
        (L = element("code")),
        (j = text(U)),
        attr(p, "class", "title"),
        attr(F, "class", "title");
    },
    m(N, q) {
      insert(N, r, q),
        append(r, p),
        append(r, v),
        append(r, S),
        insert(N, x, q),
        insert(N, I, q),
        append(I, F),
        append(I, O),
        append(I, L),
        append(L, j);
    },
    p(N, q) {
      q & 4 &&
        $ !== ($ = (N[2].source || "<anonymous>") + "") &&
        set_data(S, $),
        q & 4 &&
          U !== (U = (N[2].details || "<anonymous>") + "") &&
          set_data(j, U);
    },
    d(N) {
      N && detach(r), N && detach(x), N && detach(I);
    },
  };
}
function create_fragment$1(k) {
  let r,
    p = k[0] && create_if_block$1(k);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, $) {
      p && p.m(v, $), insert(v, r, $);
    },
    p(v, [$]) {
      v[0]
        ? p
          ? p.p(v, $)
          : ((p = create_if_block$1(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$1(k, r, p) {
  let v;
  component_subscribe(k, maxZIndex, (F) => p(3, (v = F)));
  let $ = !1,
    S = "",
    x;
  function I() {
    x.button.action(), BugReportData.set([!1, null]);
  }
  return (
    BugReportData.subscribe((F) => {
      F && (p(0, ($ = F[0])), p(2, (x = F[1])), p(1, (S = $ ? "show" : "")));
    }),
    [$, S, x, v, I]
  );
}
class BugReport extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1, create_fragment$1, safe_not_equal, {});
  }
}
const devbar = "";
function assignHooks() {
  const k = window;
  k.__arcos = {
    loadWindow,
    loadExternalApp,
    api: { apiHost: ConnectedServer },
    userLogic: { username: UserName, userData: UserData },
    windowLogic: {
      openWindow,
      openChildWindow,
      closeChildWindow,
      closeWindow,
      maximizeWindow,
      minimizeWindow,
      fullscreenWindow,
      headlessToggle,
      windowStore: WindowStore,
    },
    overlay: { showOverlay, hideOverlay },
    notifier: {
      notifications: NotificationStore,
      errorStore: ErrorMessages,
      makeNotification,
      deleteNotification,
      closeNotification,
      errorMessage,
      closeError,
      createOverlayableError,
      destroyOverlayableError,
    },
  };
}
const hookUpdatable = [WindowStore, NotificationStore, ErrorMessages, UserData];
function assignHookUpdateListeners() {
  Log({
    source: "aftermarket/hooks/updaters.ts: assignHookUpdateListeners",
    msg: `Assigning updaters for ${hookUpdatable.length} writables.`,
    level: LogLevel.warn,
  });
  for (let k = 0; k < hookUpdatable.length; k++)
    hookUpdatable[k] && hookUpdatable[k].subscribe(assignHooks);
}
const dmTriggers = [
  WindowStore,
  UserName,
  loginUsername,
  UserData,
  ConnectedServer,
  CurrentFTSState,
  CurrentLoginState,
  NotificationStore,
  currentSettingsPage,
  ErrorWindowStore,
  FileBrowserSelectedFilename,
  FileBrowserCurrentDir,
];
function assignDevMutators() {
  for (let k = 0; k < dmTriggers.length; k++)
    dmTriggers[k].subscribe(updateDevModeProps);
}
function create_if_block(k) {
  let r, p, v;
  var $ = k[1].content;
  function S(x) {
    return {};
  }
  return (
    $ && (r = construct_svelte_component($, S())),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(x, I) {
        r && mount_component(r, x, I), insert(x, p, I), (v = !0);
      },
      p(x, I) {
        if (I & 2 && $ !== ($ = x[1].content)) {
          if (r) {
            group_outros();
            const F = r;
            transition_out(F.$$.fragment, 1, 0, () => {
              destroy_component(F, 1);
            }),
              check_outros();
          }
          $
            ? ((r = construct_svelte_component($, S())),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        }
      },
      i(x) {
        v || (r && transition_in(r.$$.fragment, x), (v = !0));
      },
      o(x) {
        r && transition_out(r.$$.fragment, x), (v = !1);
      },
      d(x) {
        x && detach(p), r && destroy_component(r, x);
      },
    }
  );
}
function create_fragment(k) {
  let r,
    p,
    v,
    $,
    S = k[1] && create_if_block(k);
  return (
    (v = new BugReport({})),
    {
      c() {
        (r = element("div")),
          S && S.c(),
          (p = space()),
          create_component(v.$$.fragment),
          attr(r, "class", "app fullscreen"),
          toggle_class(r, "floating", k[0]);
      },
      m(x, I) {
        insert(x, r, I),
          S && S.m(r, null),
          append(r, p),
          mount_component(v, r, null),
          ($ = !0);
      },
      p(x, [I]) {
        x[1]
          ? S
            ? (S.p(x, I), I & 2 && transition_in(S, 1))
            : ((S = create_if_block(x)), S.c(), transition_in(S, 1), S.m(r, p))
          : S &&
            (group_outros(),
            transition_out(S, 1, 1, () => {
              S = null;
            }),
            check_outros()),
          (!$ || I & 1) && toggle_class(r, "floating", x[0]);
      },
      i(x) {
        $ || (transition_in(S), transition_in(v.$$.fragment, x), ($ = !0));
      },
      o(x) {
        transition_out(S), transition_out(v.$$.fragment, x), ($ = !1);
      },
      d(x) {
        x && detach(r), S && S.d(), destroy_component(v);
      },
    }
  );
}
function instance(k, r, p) {
  let v;
  component_subscribe(k, CurrentState, (S) => p(1, (v = S)));
  let $ = !1;
  return (
    DevModeOverride.subscribe((S) => {
      S || p(0, ($ = !1));
    }),
    applyState("boot"),
    onMount(() => {
      dmMutators.unshift({
        caption: "CurrentState",
        store: CurrentState,
        value: "key",
        fallback: "unknown",
      }),
        dmTriggers.unshift(CurrentState),
        updateDevModeProps(),
        assignDevMutators(),
        assignHooks(),
        assignHookUpdateListeners();
    }),
    (console.warn = (S, ...x) =>
      Log({ source: "Console", msg: S + x.join(" "), level: LogLevel.warn })),
    (console.error = (S, ...x) =>
      Log({ source: "Console", msg: S + x.join(" "), level: LogLevel.error })),
    window.addEventListener("beforeunload", logoffToken),
    [$, v]
  );
}
class App extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance, create_fragment, safe_not_equal, {});
  }
}
new App({ target: document.getElementById("app") });
define();

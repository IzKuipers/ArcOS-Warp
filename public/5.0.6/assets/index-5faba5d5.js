var wt = Object.defineProperty;
var kt = ($, r, p) =>
  r in $
    ? wt($, r, { enumerable: !0, configurable: !0, writable: !0, value: p })
    : ($[r] = p);
var me = ($, r, p) => (kt($, typeof r != "symbol" ? r + "" : r, p), p);
(function () {
  const r = document.createElement("link").relList;
  if (r && r.supports && r.supports("modulepreload")) return;
  for (const k of document.querySelectorAll('link[rel="modulepreload"]')) v(k);
  new MutationObserver((k) => {
    for (const x of k)
      if (x.type === "childList")
        for (const S of x.addedNodes)
          S.tagName === "LINK" && S.rel === "modulepreload" && v(S);
  }).observe(document, { childList: !0, subtree: !0 });
  function p(k) {
    const x = {};
    return (
      k.integrity && (x.integrity = k.integrity),
      k.referrerpolicy && (x.referrerPolicy = k.referrerpolicy),
      k.crossorigin === "use-credentials"
        ? (x.credentials = "include")
        : k.crossorigin === "anonymous"
        ? (x.credentials = "omit")
        : (x.credentials = "same-origin"),
      x
    );
  }
  function v(k) {
    if (k.ep) return;
    k.ep = !0;
    const x = p(k);
    fetch(k.href, x);
  }
})();
function noop$1() {}
function assign($, r) {
  for (const p in r) $[p] = r[p];
  return $;
}
function run($) {
  return $();
}
function blank_object() {
  return Object.create(null);
}
function run_all($) {
  $.forEach(run);
}
function is_function($) {
  return typeof $ == "function";
}
function safe_not_equal($, r) {
  return $ != $
    ? r == r
    : $ !== r || ($ && typeof $ == "object") || typeof $ == "function";
}
let src_url_equal_anchor;
function src_url_equal($, r) {
  return (
    src_url_equal_anchor ||
      (src_url_equal_anchor = document.createElement("a")),
    (src_url_equal_anchor.href = r),
    $ === src_url_equal_anchor.href
  );
}
function is_empty($) {
  return Object.keys($).length === 0;
}
function subscribe($, ...r) {
  if ($ == null) return noop$1;
  const p = $.subscribe(...r);
  return p.unsubscribe ? () => p.unsubscribe() : p;
}
function get_store_value($) {
  let r;
  return subscribe($, (p) => (r = p))(), r;
}
function component_subscribe($, r, p) {
  $.$$.on_destroy.push(subscribe(r, p));
}
function create_slot($, r, p, v) {
  if ($) {
    const k = get_slot_context($, r, p, v);
    return $[0](k);
  }
}
function get_slot_context($, r, p, v) {
  return $[1] && v ? assign(p.ctx.slice(), $[1](v(r))) : p.ctx;
}
function get_slot_changes($, r, p, v) {
  if ($[2] && v) {
    const k = $[2](v(p));
    if (r.dirty === void 0) return k;
    if (typeof k == "object") {
      const x = [],
        S = Math.max(r.dirty.length, k.length);
      for (let I = 0; I < S; I += 1) x[I] = r.dirty[I] | k[I];
      return x;
    }
    return r.dirty | k;
  }
  return r.dirty;
}
function update_slot_base($, r, p, v, k, x) {
  if (k) {
    const S = get_slot_context(r, p, v, x);
    $.p(S, k);
  }
}
function get_all_dirty_from_scope($) {
  if ($.ctx.length > 32) {
    const r = [],
      p = $.ctx.length / 32;
    for (let v = 0; v < p; v++) r[v] = -1;
    return r;
  }
  return -1;
}
function exclude_internal_props($) {
  const r = {};
  for (const p in $) p[0] !== "$" && (r[p] = $[p]);
  return r;
}
function compute_rest_props($, r) {
  const p = {};
  r = new Set(r);
  for (const v in $) !r.has(v) && v[0] !== "$" && (p[v] = $[v]);
  return p;
}
function set_store_value($, r, p) {
  return $.set(p), r;
}
const is_client = typeof window < "u";
let raf = is_client ? ($) => requestAnimationFrame($) : noop$1;
function append($, r) {
  $.appendChild(r);
}
function insert($, r, p) {
  $.insertBefore(r, p || null);
}
function detach($) {
  $.parentNode && $.parentNode.removeChild($);
}
function destroy_each($, r) {
  for (let p = 0; p < $.length; p += 1) $[p] && $[p].d(r);
}
function element($) {
  return document.createElement($);
}
function svg_element($) {
  return document.createElementNS("http://www.w3.org/2000/svg", $);
}
function text($) {
  return document.createTextNode($);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen($, r, p, v) {
  return $.addEventListener(r, p, v), () => $.removeEventListener(r, p, v);
}
function attr($, r, p) {
  p == null
    ? $.removeAttribute(r)
    : $.getAttribute(r) !== p && $.setAttribute(r, p);
}
function children($) {
  return Array.from($.childNodes);
}
function set_data($, r) {
  (r = "" + r), $.wholeText !== r && ($.data = r);
}
function set_input_value($, r) {
  $.value = r ?? "";
}
function set_style($, r, p, v) {
  p === null
    ? $.style.removeProperty(r)
    : $.style.setProperty(r, p, v ? "important" : "");
}
function select_option($, r, p) {
  for (let v = 0; v < $.options.length; v += 1) {
    const k = $.options[v];
    if (k.__value === r) {
      k.selected = !0;
      return;
    }
  }
  (!p || r !== void 0) && ($.selectedIndex = -1);
}
function select_value($) {
  const r = $.querySelector(":checked");
  return r && r.__value;
}
function toggle_class($, r, p) {
  $.classList[p ? "add" : "remove"](r);
}
function custom_event($, r, { bubbles: p = !1, cancelable: v = !1 } = {}) {
  const k = document.createEvent("CustomEvent");
  return k.initCustomEvent($, p, v, r), k;
}
class HtmlTag {
  constructor(r = !1) {
    (this.is_svg = !1), (this.is_svg = r), (this.e = this.n = null);
  }
  c(r) {
    this.h(r);
  }
  m(r, p, v = null) {
    this.e ||
      (this.is_svg
        ? (this.e = svg_element(p.nodeName))
        : (this.e = element(p.nodeType === 11 ? "TEMPLATE" : p.nodeName)),
      (this.t = p.tagName !== "TEMPLATE" ? p : p.content),
      this.c(r)),
      this.i(v);
  }
  h(r) {
    (this.e.innerHTML = r),
      (this.n = Array.from(
        this.e.nodeName === "TEMPLATE"
          ? this.e.content.childNodes
          : this.e.childNodes
      ));
  }
  i(r) {
    for (let p = 0; p < this.n.length; p += 1) insert(this.t, this.n[p], r);
  }
  p(r) {
    this.d(), this.h(r), this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
}
function construct_svelte_component($, r) {
  return new $(r);
}
let current_component;
function set_current_component($) {
  current_component = $;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount($) {
  get_current_component().$$.on_mount.push($);
}
function createEventDispatcher() {
  const $ = get_current_component();
  return (r, p, { cancelable: v = !1 } = {}) => {
    const k = $.$$.callbacks[r];
    if (k) {
      const x = custom_event(r, p, { cancelable: v });
      return (
        k.slice().forEach((S) => {
          S.call($, x);
        }),
        !x.defaultPrevented
      );
    }
    return !0;
  };
}
function setContext($, r) {
  return get_current_component().$$.context.set($, r), r;
}
function getContext($) {
  return get_current_component().$$.context.get($);
}
const dirty_components = [],
  binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [],
  resolved_promise = Promise.resolve();
let update_scheduled = !1;
function schedule_update() {
  update_scheduled || ((update_scheduled = !0), resolved_promise.then(flush$1));
}
function add_render_callback($) {
  render_callbacks.push($);
}
function add_flush_callback($) {
  flush_callbacks.push($);
}
const seen_callbacks = new Set();
let flushidx = 0;
function flush$1() {
  if (flushidx !== 0) return;
  const $ = current_component;
  do {
    try {
      for (; flushidx < dirty_components.length; ) {
        const r = dirty_components[flushidx];
        flushidx++, set_current_component(r), update(r.$$);
      }
    } catch (r) {
      throw ((dirty_components.length = 0), (flushidx = 0), r);
    }
    for (
      set_current_component(null), dirty_components.length = 0, flushidx = 0;
      binding_callbacks.length;

    )
      binding_callbacks.pop()();
    for (let r = 0; r < render_callbacks.length; r += 1) {
      const p = render_callbacks[r];
      seen_callbacks.has(p) || (seen_callbacks.add(p), p());
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  for (; flush_callbacks.length; ) flush_callbacks.pop()();
  (update_scheduled = !1), seen_callbacks.clear(), set_current_component($);
}
function update($) {
  if ($.fragment !== null) {
    $.update(), run_all($.before_update);
    const r = $.dirty;
    ($.dirty = [-1]),
      $.fragment && $.fragment.p($.ctx, r),
      $.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks($) {
  const r = [],
    p = [];
  render_callbacks.forEach((v) =>
    $.indexOf(v) === -1 ? r.push(v) : p.push(v)
  ),
    p.forEach((v) => v()),
    (render_callbacks = r);
}
const outroing = new Set();
let outros;
function group_outros() {
  outros = { r: 0, c: [], p: outros };
}
function check_outros() {
  outros.r || run_all(outros.c), (outros = outros.p);
}
function transition_in($, r) {
  $ && $.i && (outroing.delete($), $.i(r));
}
function transition_out($, r, p, v) {
  if ($ && $.o) {
    if (outroing.has($)) return;
    outroing.add($),
      outros.c.push(() => {
        outroing.delete($), v && (p && $.d(1), v());
      }),
      $.o(r);
  } else v && v();
}
function get_spread_update($, r) {
  const p = {},
    v = {},
    k = { $$scope: 1 };
  let x = $.length;
  for (; x--; ) {
    const S = $[x],
      I = r[x];
    if (I) {
      for (const F in S) F in I || (v[F] = 1);
      for (const F in I) k[F] || ((p[F] = I[F]), (k[F] = 1));
      $[x] = I;
    } else for (const F in S) k[F] = 1;
  }
  for (const S in v) S in p || (p[S] = void 0);
  return p;
}
function get_spread_object($) {
  return typeof $ == "object" && $ !== null ? $ : {};
}
function bind$1($, r, p) {
  const v = $.$$.props[r];
  v !== void 0 && (($.$$.bound[v] = p), p($.$$.ctx[v]));
}
function create_component($) {
  $ && $.c();
}
function mount_component($, r, p, v) {
  const { fragment: k, after_update: x } = $.$$;
  k && k.m(r, p),
    v ||
      add_render_callback(() => {
        const S = $.$$.on_mount.map(run).filter(is_function);
        $.$$.on_destroy ? $.$$.on_destroy.push(...S) : run_all(S),
          ($.$$.on_mount = []);
      }),
    x.forEach(add_render_callback);
}
function destroy_component($, r) {
  const p = $.$$;
  p.fragment !== null &&
    (flush_render_callbacks(p.after_update),
    run_all(p.on_destroy),
    p.fragment && p.fragment.d(r),
    (p.on_destroy = p.fragment = null),
    (p.ctx = []));
}
function make_dirty($, r) {
  $.$$.dirty[0] === -1 &&
    (dirty_components.push($), schedule_update(), $.$$.dirty.fill(0)),
    ($.$$.dirty[(r / 31) | 0] |= 1 << r % 31);
}
function init($, r, p, v, k, x, S, I = [-1]) {
  const F = current_component;
  set_current_component($);
  const O = ($.$$ = {
    fragment: null,
    ctx: [],
    props: x,
    update: noop$1,
    not_equal: k,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(r.context || (F ? F.$$.context : [])),
    callbacks: blank_object(),
    dirty: I,
    skip_bound: !1,
    root: r.target || F.$$.root,
  });
  S && S(O.root);
  let L = !1;
  if (
    ((O.ctx = p
      ? p($, r.props || {}, (U, N, ...j) => {
          const R = j.length ? j[0] : N;
          return (
            O.ctx &&
              k(O.ctx[U], (O.ctx[U] = R)) &&
              (!O.skip_bound && O.bound[U] && O.bound[U](R),
              L && make_dirty($, U)),
            N
          );
        })
      : []),
    O.update(),
    (L = !0),
    run_all(O.before_update),
    (O.fragment = v ? v(O.ctx) : !1),
    r.target)
  ) {
    if (r.hydrate) {
      const U = children(r.target);
      O.fragment && O.fragment.l(U), U.forEach(detach);
    } else O.fragment && O.fragment.c();
    r.intro && transition_in($.$$.fragment),
      mount_component($, r.target, r.anchor, r.customElement),
      flush$1();
  }
  set_current_component(F);
}
class SvelteComponent {
  $destroy() {
    destroy_component(this, 1), (this.$destroy = noop$1);
  }
  $on(r, p) {
    if (!is_function(p)) return noop$1;
    const v = this.$$.callbacks[r] || (this.$$.callbacks[r] = []);
    return (
      v.push(p),
      () => {
        const k = v.indexOf(p);
        k !== -1 && v.splice(k, 1);
      }
    );
  }
  $set(r) {
    this.$$set &&
      !is_empty(r) &&
      ((this.$$.skip_bound = !0), this.$$set(r), (this.$$.skip_bound = !1));
  }
}
const main$1 = "",
  logo$d = "./assets/systemIcon-393c5507.svg",
  bugrep = "",
  subscriber_queue = [];
function writable($, r = noop$1) {
  let p;
  const v = new Set();
  function k(I) {
    if (safe_not_equal($, I) && (($ = I), p)) {
      const F = !subscriber_queue.length;
      for (const O of v) O[1](), subscriber_queue.push(O, $);
      if (F) {
        for (let O = 0; O < subscriber_queue.length; O += 2)
          subscriber_queue[O][0](subscriber_queue[O + 1]);
        subscriber_queue.length = 0;
      }
    }
  }
  function x(I) {
    k(I($));
  }
  function S(I, F = noop$1) {
    const O = [I, F];
    return (
      v.add(O),
      v.size === 1 && (p = r(k) || noop$1),
      I($),
      () => {
        v.delete(O), v.size === 0 && p && (p(), (p = null));
      }
    );
  }
  return { set: k, update: x, subscribe: S };
}
var commonjsGlobal =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function getAugmentedNamespace($) {
  if ($.__esModule) return $;
  var r = $.default;
  if (typeof r == "function") {
    var p = function v() {
      if (this instanceof v) {
        var k = [null];
        k.push.apply(k, arguments);
        var x = Function.bind.apply(r, k);
        return new x();
      }
      return r.apply(this, arguments);
    };
    p.prototype = r.prototype;
  } else p = {};
  return (
    Object.defineProperty(p, "__esModule", { value: !0 }),
    Object.keys($).forEach(function (v) {
      var k = Object.getOwnPropertyDescriptor($, v);
      Object.defineProperty(
        p,
        v,
        k.get
          ? k
          : {
              enumerable: !0,
              get: function () {
                return $[v];
              },
            }
      );
    }),
    p
  );
}
var dayjs_minExports = {},
  dayjs_min = {
    get exports() {
      return dayjs_minExports;
    },
    set exports($) {
      dayjs_minExports = $;
    },
  };
(function ($, r) {
  (function (p, v) {
    $.exports = v();
  })(commonjsGlobal, function () {
    var p = 1e3,
      v = 6e4,
      k = 36e5,
      x = "millisecond",
      S = "second",
      I = "minute",
      F = "hour",
      O = "day",
      L = "week",
      U = "month",
      N = "quarter",
      j = "year",
      R = "date",
      q = "Invalid Date",
      Q =
        /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
      K =
        /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
      V = {
        name: "en",
        weekdays:
          "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months:
          "January_February_March_April_May_June_July_August_September_October_November_December".split(
            "_"
          ),
        ordinal: function (oe) {
          var se = ["th", "st", "nd", "rd"],
            re = oe % 100;
          return "[" + oe + (se[(re - 20) % 10] || se[re] || se[0]) + "]";
        },
      },
      H = function (oe, se, re) {
        var le = String(oe);
        return !le || le.length >= se
          ? oe
          : "" + Array(se + 1 - le.length).join(re) + oe;
      },
      G = {
        s: H,
        z: function (oe) {
          var se = -oe.utcOffset(),
            re = Math.abs(se),
            le = Math.floor(re / 60),
            ae = re % 60;
          return (se <= 0 ? "+" : "-") + H(le, 2, "0") + ":" + H(ae, 2, "0");
        },
        m: function oe(se, re) {
          if (se.date() < re.date()) return -oe(re, se);
          var le = 12 * (re.year() - se.year()) + (re.month() - se.month()),
            ae = se.clone().add(le, U),
            ne = re - ae < 0,
            ce = se.clone().add(le + (ne ? -1 : 1), U);
          return +(-(le + (re - ae) / (ne ? ae - ce : ce - ae)) || 0);
        },
        a: function (oe) {
          return oe < 0 ? Math.ceil(oe) || 0 : Math.floor(oe);
        },
        p: function (oe) {
          return (
            { M: U, y: j, w: L, d: O, D: R, h: F, m: I, s: S, ms: x, Q: N }[
              oe
            ] ||
            String(oe || "")
              .toLowerCase()
              .replace(/s$/, "")
          );
        },
        u: function (oe) {
          return oe === void 0;
        },
      },
      Y = "en",
      J = {};
    J[Y] = V;
    var Z = function (oe) {
        return oe instanceof ie;
      },
      X = function oe(se, re, le) {
        var ae;
        if (!se) return Y;
        if (typeof se == "string") {
          var ne = se.toLowerCase();
          J[ne] && (ae = ne), re && ((J[ne] = re), (ae = ne));
          var ce = se.split("-");
          if (!ae && ce.length > 1) return oe(ce[0]);
        } else {
          var de = se.name;
          (J[de] = se), (ae = de);
        }
        return !le && ae && (Y = ae), ae || (!le && Y);
      },
      ee = function (oe, se) {
        if (Z(oe)) return oe.clone();
        var re = typeof se == "object" ? se : {};
        return (re.date = oe), (re.args = arguments), new ie(re);
      },
      te = G;
    (te.l = X),
      (te.i = Z),
      (te.w = function (oe, se) {
        return ee(oe, {
          locale: se.$L,
          utc: se.$u,
          x: se.$x,
          $offset: se.$offset,
        });
      });
    var ie = (function () {
        function oe(re) {
          (this.$L = X(re.locale, null, !0)), this.parse(re);
        }
        var se = oe.prototype;
        return (
          (se.parse = function (re) {
            (this.$d = (function (le) {
              var ae = le.date,
                ne = le.utc;
              if (ae === null) return new Date(NaN);
              if (te.u(ae)) return new Date();
              if (ae instanceof Date) return new Date(ae);
              if (typeof ae == "string" && !/Z$/i.test(ae)) {
                var ce = ae.match(Q);
                if (ce) {
                  var de = ce[2] - 1 || 0,
                    fe = (ce[7] || "0").substring(0, 3);
                  return ne
                    ? new Date(
                        Date.UTC(
                          ce[1],
                          de,
                          ce[3] || 1,
                          ce[4] || 0,
                          ce[5] || 0,
                          ce[6] || 0,
                          fe
                        )
                      )
                    : new Date(
                        ce[1],
                        de,
                        ce[3] || 1,
                        ce[4] || 0,
                        ce[5] || 0,
                        ce[6] || 0,
                        fe
                      );
                }
              }
              return new Date(ae);
            })(re)),
              (this.$x = re.x || {}),
              this.init();
          }),
          (se.init = function () {
            var re = this.$d;
            (this.$y = re.getFullYear()),
              (this.$M = re.getMonth()),
              (this.$D = re.getDate()),
              (this.$W = re.getDay()),
              (this.$H = re.getHours()),
              (this.$m = re.getMinutes()),
              (this.$s = re.getSeconds()),
              (this.$ms = re.getMilliseconds());
          }),
          (se.$utils = function () {
            return te;
          }),
          (se.isValid = function () {
            return this.$d.toString() !== q;
          }),
          (se.isSame = function (re, le) {
            var ae = ee(re);
            return this.startOf(le) <= ae && ae <= this.endOf(le);
          }),
          (se.isAfter = function (re, le) {
            return ee(re) < this.startOf(le);
          }),
          (se.isBefore = function (re, le) {
            return this.endOf(le) < ee(re);
          }),
          (se.$g = function (re, le, ae) {
            return te.u(re) ? this[le] : this.set(ae, re);
          }),
          (se.unix = function () {
            return Math.floor(this.valueOf() / 1e3);
          }),
          (se.valueOf = function () {
            return this.$d.getTime();
          }),
          (se.startOf = function (re, le) {
            var ae = this,
              ne = !!te.u(le) || le,
              ce = te.p(re),
              de = function (ve, be) {
                var ye = te.w(
                  ae.$u ? Date.UTC(ae.$y, be, ve) : new Date(ae.$y, be, ve),
                  ae
                );
                return ne ? ye : ye.endOf(O);
              },
              fe = function (ve, be) {
                return te.w(
                  ae
                    .toDate()
                    [ve].apply(
                      ae.toDate("s"),
                      (ne ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(be)
                    ),
                  ae
                );
              },
              pe = this.$W,
              _e = this.$M,
              ge = this.$D,
              Ae = "set" + (this.$u ? "UTC" : "");
            switch (ce) {
              case j:
                return ne ? de(1, 0) : de(31, 11);
              case U:
                return ne ? de(1, _e) : de(0, _e + 1);
              case L:
                var $e = this.$locale().weekStart || 0,
                  ke = (pe < $e ? pe + 7 : pe) - $e;
                return de(ne ? ge - ke : ge + (6 - ke), _e);
              case O:
              case R:
                return fe(Ae + "Hours", 0);
              case F:
                return fe(Ae + "Minutes", 1);
              case I:
                return fe(Ae + "Seconds", 2);
              case S:
                return fe(Ae + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }),
          (se.endOf = function (re) {
            return this.startOf(re, !1);
          }),
          (se.$set = function (re, le) {
            var ae,
              ne = te.p(re),
              ce = "set" + (this.$u ? "UTC" : ""),
              de = ((ae = {}),
              (ae[O] = ce + "Date"),
              (ae[R] = ce + "Date"),
              (ae[U] = ce + "Month"),
              (ae[j] = ce + "FullYear"),
              (ae[F] = ce + "Hours"),
              (ae[I] = ce + "Minutes"),
              (ae[S] = ce + "Seconds"),
              (ae[x] = ce + "Milliseconds"),
              ae)[ne],
              fe = ne === O ? this.$D + (le - this.$W) : le;
            if (ne === U || ne === j) {
              var pe = this.clone().set(R, 1);
              pe.$d[de](fe),
                pe.init(),
                (this.$d = pe.set(R, Math.min(this.$D, pe.daysInMonth())).$d);
            } else de && this.$d[de](fe);
            return this.init(), this;
          }),
          (se.set = function (re, le) {
            return this.clone().$set(re, le);
          }),
          (se.get = function (re) {
            return this[te.p(re)]();
          }),
          (se.add = function (re, le) {
            var ae,
              ne = this;
            re = Number(re);
            var ce = te.p(le),
              de = function (_e) {
                var ge = ee(ne);
                return te.w(ge.date(ge.date() + Math.round(_e * re)), ne);
              };
            if (ce === U) return this.set(U, this.$M + re);
            if (ce === j) return this.set(j, this.$y + re);
            if (ce === O) return de(1);
            if (ce === L) return de(7);
            var fe =
                ((ae = {}), (ae[I] = v), (ae[F] = k), (ae[S] = p), ae)[ce] || 1,
              pe = this.$d.getTime() + re * fe;
            return te.w(pe, this);
          }),
          (se.subtract = function (re, le) {
            return this.add(-1 * re, le);
          }),
          (se.format = function (re) {
            var le = this,
              ae = this.$locale();
            if (!this.isValid()) return ae.invalidDate || q;
            var ne = re || "YYYY-MM-DDTHH:mm:ssZ",
              ce = te.z(this),
              de = this.$H,
              fe = this.$m,
              pe = this.$M,
              _e = ae.weekdays,
              ge = ae.months,
              Ae = function (be, ye, Ce, Te) {
                return (be && (be[ye] || be(le, ne))) || Ce[ye].slice(0, Te);
              },
              $e = function (be) {
                return te.s(de % 12 || 12, be, "0");
              },
              ke =
                ae.meridiem ||
                function (be, ye, Ce) {
                  var Te = be < 12 ? "AM" : "PM";
                  return Ce ? Te.toLowerCase() : Te;
                },
              ve = {
                YY: String(this.$y).slice(-2),
                YYYY: this.$y,
                M: pe + 1,
                MM: te.s(pe + 1, 2, "0"),
                MMM: Ae(ae.monthsShort, pe, ge, 3),
                MMMM: Ae(ge, pe),
                D: this.$D,
                DD: te.s(this.$D, 2, "0"),
                d: String(this.$W),
                dd: Ae(ae.weekdaysMin, this.$W, _e, 2),
                ddd: Ae(ae.weekdaysShort, this.$W, _e, 3),
                dddd: _e[this.$W],
                H: String(de),
                HH: te.s(de, 2, "0"),
                h: $e(1),
                hh: $e(2),
                a: ke(de, fe, !0),
                A: ke(de, fe, !1),
                m: String(fe),
                mm: te.s(fe, 2, "0"),
                s: String(this.$s),
                ss: te.s(this.$s, 2, "0"),
                SSS: te.s(this.$ms, 3, "0"),
                Z: ce,
              };
            return ne.replace(K, function (be, ye) {
              return ye || ve[be] || ce.replace(":", "");
            });
          }),
          (se.utcOffset = function () {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }),
          (se.diff = function (re, le, ae) {
            var ne,
              ce = te.p(le),
              de = ee(re),
              fe = (de.utcOffset() - this.utcOffset()) * v,
              pe = this - de,
              _e = te.m(this, de);
            return (
              (_e =
                ((ne = {}),
                (ne[j] = _e / 12),
                (ne[U] = _e),
                (ne[N] = _e / 3),
                (ne[L] = (pe - fe) / 6048e5),
                (ne[O] = (pe - fe) / 864e5),
                (ne[F] = pe / k),
                (ne[I] = pe / v),
                (ne[S] = pe / p),
                ne)[ce] || pe),
              ae ? _e : te.a(_e)
            );
          }),
          (se.daysInMonth = function () {
            return this.endOf(U).$D;
          }),
          (se.$locale = function () {
            return J[this.$L];
          }),
          (se.locale = function (re, le) {
            if (!re) return this.$L;
            var ae = this.clone(),
              ne = X(re, le, !0);
            return ne && (ae.$L = ne), ae;
          }),
          (se.clone = function () {
            return te.w(this.$d, this);
          }),
          (se.toDate = function () {
            return new Date(this.valueOf());
          }),
          (se.toJSON = function () {
            return this.isValid() ? this.toISOString() : null;
          }),
          (se.toISOString = function () {
            return this.$d.toISOString();
          }),
          (se.toString = function () {
            return this.$d.toUTCString();
          }),
          oe
        );
      })(),
      ue = ie.prototype;
    return (
      (ee.prototype = ue),
      [
        ["$ms", x],
        ["$s", S],
        ["$m", I],
        ["$H", F],
        ["$W", O],
        ["$M", U],
        ["$y", j],
        ["$D", R],
      ].forEach(function (oe) {
        ue[oe[1]] = function (se) {
          return this.$g(se, oe[0], oe[1]);
        };
      }),
      (ee.extend = function (oe, se) {
        return oe.$i || (oe(se, ie, ee), (oe.$i = !0)), ee;
      }),
      (ee.locale = X),
      (ee.isDayjs = Z),
      (ee.unix = function (oe) {
        return ee(1e3 * oe);
      }),
      (ee.en = J[Y]),
      (ee.Ls = J),
      (ee.p = {}),
      ee
    );
  });
})(dayjs_min);
const dayjs = dayjs_minExports;
var LogLevel = (($) => (
  ($[($.info = 0)] = "info"),
  ($[($.warn = 1)] = "warn"),
  ($[($.error = 2)] = "error"),
  ($[($.critical = 3)] = "critical"),
  $
))(LogLevel || {});
const LogLevelData = {
    info: { capt: "INFO" },
    warn: { capt: "WARN" },
    error: { capt: "ERRR" },
    critical: { capt: "CRIT" },
  },
  log = writable([]);
function Log($) {
  $.timestamp = new Date().getTime();
  const r = get_store_value(log),
    p = dayjs($.timestamp || 0).format("HH:mm:ss.mmm");
  r.push($), log.set(r);
  const v = LogLevelData[LogLevel[$.level]];
  console.log(`ArcOS: ${p} [${v.capt}] ${$.source}: ${$.msg}`);
}
const OpenedStore = writable([]),
  WindowStore = writable([]),
  isFullscreenWindow = writable(!1),
  maxZIndex = writable(1e9),
  focusedWindowId = writable(null);
function getWindow($) {
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++) if (r[p] && r[p].id == $) return r[p];
  return null;
}
function getOpenedStore() {
  const $ = get_store_value(WindowStore),
    r = [];
  for (let p = 0; p < $.length; p++) $[p].opened && r.push($[p]);
  return r;
}
function updateStores() {
  Log({
    msg: "Flushing all stores",
    source: "store.ts: updateStores",
    level: LogLevel.info,
  });
  const $ = get_store_value(WindowStore),
    r = getOpenedStore();
  isFullscreenWindow.set(!1);
  for (let p = 0; p < r.length; p++) {
    const v = getWindow(r[p].id);
    v && (r[p] = v),
      r[p] &&
        r[p] &&
        r[p].state.windowState.fll &&
        !r[p].state.windowState.min &&
        isFullscreenWindow.set(!0);
  }
  WindowStore.set($);
}
WindowStore.subscribe(() => {
  OpenedStore.set(getOpenedStore());
});
var d$1 = Object.defineProperty,
  e = ($, r) => {
    for (var p in r) d$1($, p, { get: r[p], enumerable: !0 });
  },
  f$1 = {};
e(f$1, {
  convertFileSrc: () => w,
  invoke: () => c$3,
  transformCallback: () => s$4,
});
function u$4() {
  return window.crypto.getRandomValues(new Uint32Array(1))[0];
}
function s$4($, r = !1) {
  let p = u$4(),
    v = `_${p}`;
  return (
    Object.defineProperty(window, v, {
      value: (k) => (
        r && Reflect.deleteProperty(window, v), $ == null ? void 0 : $(k)
      ),
      writable: !1,
      configurable: !0,
    }),
    p
  );
}
async function c$3($, r = {}) {
  return new Promise((p, v) => {
    let k = s$4((S) => {
        p(S), Reflect.deleteProperty(window, `_${x}`);
      }, !0),
      x = s$4((S) => {
        v(S), Reflect.deleteProperty(window, `_${k}`);
      }, !0);
    window.__TAURI_IPC__({ cmd: $, callback: k, error: x, ...r });
  });
}
function w($, r = "asset") {
  let p = encodeURIComponent($);
  return navigator.userAgent.includes("Windows")
    ? `https://${r}.localhost/${p}`
    : `${r}://localhost/${p}`;
}
async function a$1($) {
  return c$3("tauri", $);
}
var W$1 = {};
e(W$1, {
  TauriEvent: () => c$2,
  emit: () => D,
  listen: () => E$1,
  once: () => _,
});
async function s$3($, r) {
  return a$1({
    __tauriModule: "Event",
    message: { cmd: "unlisten", event: $, eventId: r },
  });
}
async function m$1($, r, p) {
  await a$1({
    __tauriModule: "Event",
    message: { cmd: "emit", event: $, windowLabel: r, payload: p },
  });
}
async function o$3($, r, p) {
  return a$1({
    __tauriModule: "Event",
    message: { cmd: "listen", event: $, windowLabel: r, handler: s$4(p) },
  }).then((v) => async () => s$3($, v));
}
async function u$3($, r, p) {
  return o$3($, r, (v) => {
    p(v), s$3($, v.id).catch(() => {});
  });
}
var c$2 = (($) => (
  ($.WINDOW_RESIZED = "tauri://resize"),
  ($.WINDOW_MOVED = "tauri://move"),
  ($.WINDOW_CLOSE_REQUESTED = "tauri://close-requested"),
  ($.WINDOW_CREATED = "tauri://window-created"),
  ($.WINDOW_DESTROYED = "tauri://destroyed"),
  ($.WINDOW_FOCUS = "tauri://focus"),
  ($.WINDOW_BLUR = "tauri://blur"),
  ($.WINDOW_SCALE_FACTOR_CHANGED = "tauri://scale-change"),
  ($.WINDOW_THEME_CHANGED = "tauri://theme-changed"),
  ($.WINDOW_FILE_DROP = "tauri://file-drop"),
  ($.WINDOW_FILE_DROP_HOVER = "tauri://file-drop-hover"),
  ($.WINDOW_FILE_DROP_CANCELLED = "tauri://file-drop-cancelled"),
  ($.MENU = "tauri://menu"),
  ($.CHECK_UPDATE = "tauri://update"),
  ($.UPDATE_AVAILABLE = "tauri://update-available"),
  ($.INSTALL_UPDATE = "tauri://update-install"),
  ($.STATUS_UPDATE = "tauri://update-status"),
  ($.DOWNLOAD_PROGRESS = "tauri://update-download-progress"),
  $
))(c$2 || {});
async function E$1($, r) {
  return o$3($, null, r);
}
async function _($, r) {
  return u$3($, null, r);
}
async function D($, r) {
  return m$1($, void 0, r);
}
var C = {};
e(C, {
  CloseRequestedEvent: () => y,
  LogicalPosition: () => c$1,
  LogicalSize: () => m,
  PhysicalPosition: () => o$2,
  PhysicalSize: () => l$1,
  UserAttentionType: () => W,
  WebviewWindow: () => s$2,
  WebviewWindowHandle: () => u$2,
  WindowManager: () => h,
  appWindow: () => b,
  availableMonitors: () => T,
  currentMonitor: () => E,
  getAll: () => M,
  getCurrent: () => f,
  primaryMonitor: () => z,
});
var m = class {
    constructor($, r) {
      (this.type = "Logical"), (this.width = $), (this.height = r);
    }
  },
  l$1 = class {
    constructor(r, p) {
      (this.type = "Physical"), (this.width = r), (this.height = p);
    }
    toLogical(r) {
      return new m(this.width / r, this.height / r);
    }
  },
  c$1 = class {
    constructor(r, p) {
      (this.type = "Logical"), (this.x = r), (this.y = p);
    }
  },
  o$2 = class {
    constructor(r, p) {
      (this.type = "Physical"), (this.x = r), (this.y = p);
    }
    toLogical(r) {
      return new c$1(this.x / r, this.y / r);
    }
  },
  W = (($) => (
    ($[($.Critical = 1)] = "Critical"),
    ($[($.Informational = 2)] = "Informational"),
    $
  ))(W || {});
function f() {
  return new s$2(window.__TAURI_METADATA__.__currentWindow.label, { skip: !0 });
}
function M() {
  return window.__TAURI_METADATA__.__windows.map(
    ($) => new s$2($.label, { skip: !0 })
  );
}
var P = ["tauri://created", "tauri://error"],
  u$2 = class {
    constructor(r) {
      (this.label = r), (this.listeners = Object.create(null));
    }
    async listen(r, p) {
      return this._handleTauriEvent(r, p)
        ? Promise.resolve(() => {
            let v = this.listeners[r];
            v.splice(v.indexOf(p), 1);
          })
        : o$3(r, this.label, p);
    }
    async once(r, p) {
      return this._handleTauriEvent(r, p)
        ? Promise.resolve(() => {
            let v = this.listeners[r];
            v.splice(v.indexOf(p), 1);
          })
        : u$3(r, this.label, p);
    }
    async emit(r, p) {
      if (P.includes(r)) {
        for (let v of this.listeners[r] || [])
          v({ event: r, id: -1, windowLabel: this.label, payload: p });
        return Promise.resolve();
      }
      return m$1(r, this.label, p);
    }
    _handleTauriEvent(r, p) {
      return P.includes(r)
        ? (r in this.listeners
            ? this.listeners[r].push(p)
            : (this.listeners[r] = [p]),
          !0)
        : !1;
    }
  },
  h = class extends u$2 {
    async scaleFactor() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "scaleFactor" } },
        },
      });
    }
    async innerPosition() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "innerPosition" } },
        },
      }).then(({ x: $, y: r }) => new o$2($, r));
    }
    async outerPosition() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "outerPosition" } },
        },
      }).then(({ x: $, y: r }) => new o$2($, r));
    }
    async innerSize() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "innerSize" } },
        },
      }).then(({ width: $, height: r }) => new l$1($, r));
    }
    async outerSize() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "outerSize" } },
        },
      }).then(({ width: $, height: r }) => new l$1($, r));
    }
    async isFullscreen() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "isFullscreen" } },
        },
      });
    }
    async isMaximized() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "isMaximized" } },
        },
      });
    }
    async isDecorated() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "isDecorated" } },
        },
      });
    }
    async isResizable() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "isResizable" } },
        },
      });
    }
    async isVisible() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "isVisible" } },
        },
      });
    }
    async theme() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "theme" } },
        },
      });
    }
    async center() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "center" } },
        },
      });
    }
    async requestUserAttention($) {
      let r = null;
      return (
        $ &&
          ($ === 1
            ? (r = { type: "Critical" })
            : (r = { type: "Informational" })),
        a$1({
          __tauriModule: "Window",
          message: {
            cmd: "manage",
            data: {
              label: this.label,
              cmd: { type: "requestUserAttention", payload: r },
            },
          },
        })
      );
    }
    async setResizable($) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setResizable", payload: $ },
          },
        },
      });
    }
    async setTitle($) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "setTitle", payload: $ } },
        },
      });
    }
    async maximize() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "maximize" } },
        },
      });
    }
    async unmaximize() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "unmaximize" } },
        },
      });
    }
    async toggleMaximize() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "toggleMaximize" } },
        },
      });
    }
    async minimize() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "minimize" } },
        },
      });
    }
    async unminimize() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "unminimize" } },
        },
      });
    }
    async show() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "show" } },
        },
      });
    }
    async hide() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "hide" } },
        },
      });
    }
    async close() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "close" } },
        },
      });
    }
    async setDecorations($) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setDecorations", payload: $ },
          },
        },
      });
    }
    async setAlwaysOnTop($) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setAlwaysOnTop", payload: $ },
          },
        },
      });
    }
    async setSize($) {
      if (!$ || ($.type !== "Logical" && $.type !== "Physical"))
        throw new Error(
          "the `size` argument must be either a LogicalSize or a PhysicalSize instance"
        );
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: {
              type: "setSize",
              payload: {
                type: $.type,
                data: { width: $.width, height: $.height },
              },
            },
          },
        },
      });
    }
    async setMinSize($) {
      if ($ && $.type !== "Logical" && $.type !== "Physical")
        throw new Error(
          "the `size` argument must be either a LogicalSize or a PhysicalSize instance"
        );
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: {
              type: "setMinSize",
              payload: $
                ? { type: $.type, data: { width: $.width, height: $.height } }
                : null,
            },
          },
        },
      });
    }
    async setMaxSize($) {
      if ($ && $.type !== "Logical" && $.type !== "Physical")
        throw new Error(
          "the `size` argument must be either a LogicalSize or a PhysicalSize instance"
        );
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: {
              type: "setMaxSize",
              payload: $
                ? { type: $.type, data: { width: $.width, height: $.height } }
                : null,
            },
          },
        },
      });
    }
    async setPosition($) {
      if (!$ || ($.type !== "Logical" && $.type !== "Physical"))
        throw new Error(
          "the `position` argument must be either a LogicalPosition or a PhysicalPosition instance"
        );
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: {
              type: "setPosition",
              payload: { type: $.type, data: { x: $.x, y: $.y } },
            },
          },
        },
      });
    }
    async setFullscreen($) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setFullscreen", payload: $ },
          },
        },
      });
    }
    async setFocus() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "setFocus" } },
        },
      });
    }
    async setIcon($) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: {
              type: "setIcon",
              payload: { icon: typeof $ == "string" ? $ : Array.from($) },
            },
          },
        },
      });
    }
    async setSkipTaskbar($) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setSkipTaskbar", payload: $ },
          },
        },
      });
    }
    async setCursorGrab($) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setCursorGrab", payload: $ },
          },
        },
      });
    }
    async setCursorVisible($) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setCursorVisible", payload: $ },
          },
        },
      });
    }
    async setCursorIcon($) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setCursorIcon", payload: $ },
          },
        },
      });
    }
    async setCursorPosition($) {
      if (!$ || ($.type !== "Logical" && $.type !== "Physical"))
        throw new Error(
          "the `position` argument must be either a LogicalPosition or a PhysicalPosition instance"
        );
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: {
              type: "setCursorPosition",
              payload: { type: $.type, data: { x: $.x, y: $.y } },
            },
          },
        },
      });
    }
    async setIgnoreCursorEvents($) {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: {
            label: this.label,
            cmd: { type: "setIgnoreCursorEvents", payload: $ },
          },
        },
      });
    }
    async startDragging() {
      return a$1({
        __tauriModule: "Window",
        message: {
          cmd: "manage",
          data: { label: this.label, cmd: { type: "startDragging" } },
        },
      });
    }
    async onResized($) {
      return this.listen("tauri://resize", $);
    }
    async onMoved($) {
      return this.listen("tauri://move", $);
    }
    async onCloseRequested($) {
      return this.listen("tauri://close-requested", (r) => {
        let p = new y(r);
        Promise.resolve($(p)).then(() => {
          if (!p.isPreventDefault()) return this.close();
        });
      });
    }
    async onFocusChanged($) {
      let r = await this.listen("tauri://focus", (v) => {
          $({ ...v, payload: !0 });
        }),
        p = await this.listen("tauri://blur", (v) => {
          $({ ...v, payload: !1 });
        });
      return () => {
        r(), p();
      };
    }
    async onScaleChanged($) {
      return this.listen("tauri://scale-change", $);
    }
    async onMenuClicked($) {
      return this.listen("tauri://menu", $);
    }
    async onFileDropEvent($) {
      let r = await this.listen("tauri://file-drop", (k) => {
          $({ ...k, payload: { type: "drop", paths: k.payload } });
        }),
        p = await this.listen("tauri://file-drop-hover", (k) => {
          $({ ...k, payload: { type: "hover", paths: k.payload } });
        }),
        v = await this.listen("tauri://file-drop-cancelled", (k) => {
          $({ ...k, payload: { type: "cancel" } });
        });
      return () => {
        r(), p(), v();
      };
    }
    async onThemeChanged($) {
      return this.listen("tauri://theme-changed", $);
    }
  },
  y = class {
    constructor($) {
      (this._preventDefault = !1),
        (this.event = $.event),
        (this.windowLabel = $.windowLabel),
        (this.id = $.id);
    }
    preventDefault() {
      this._preventDefault = !0;
    }
    isPreventDefault() {
      return this._preventDefault;
    }
  },
  s$2 = class extends h {
    constructor(r, p = {}) {
      super(r),
        (p != null && p.skip) ||
          a$1({
            __tauriModule: "Window",
            message: {
              cmd: "createWebview",
              data: { options: { label: r, ...p } },
            },
          })
            .then(async () => this.emit("tauri://created"))
            .catch(async (v) => this.emit("tauri://error", v));
    }
    static getByLabel(r) {
      return M().some((p) => p.label === r) ? new s$2(r, { skip: !0 }) : null;
    }
  },
  b;
"__TAURI_METADATA__" in window
  ? (b = new s$2(window.__TAURI_METADATA__.__currentWindow.label, { skip: !0 }))
  : (console.warn(`Could not find "window.__TAURI_METADATA__". The "appWindow" value will reference the "main" window label.
Note that this is not an issue if running this frontend on a browser instead of a Tauri window.`),
    (b = new s$2("main", { skip: !0 })));
function g($) {
  return $ === null
    ? null
    : {
        name: $.name,
        scaleFactor: $.scaleFactor,
        position: new o$2($.position.x, $.position.y),
        size: new l$1($.size.width, $.size.height),
      };
}
async function E() {
  return a$1({
    __tauriModule: "Window",
    message: { cmd: "manage", data: { cmd: { type: "currentMonitor" } } },
  }).then(g);
}
async function z() {
  return a$1({
    __tauriModule: "Window",
    message: { cmd: "manage", data: { cmd: { type: "primaryMonitor" } } },
  }).then(g);
}
async function T() {
  return a$1({
    __tauriModule: "Window",
    message: { cmd: "manage", data: { cmd: { type: "availableMonitors" } } },
  }).then(($) => $.map(g));
}
const UserData = writable(),
  UserName = writable(),
  UserToken = writable(),
  trayIcons = writable([]);
function createTrayIcon($) {
  if (trayExists($.identifier)) return !1;
  const r = get_store_value(trayIcons);
  r.push($), trayIcons.set(r);
}
function disposeTrayIcon($) {
  const r = get_store_value(trayIcons);
  for (let p = 0; p < r.length; p++) r[p].identifier == $ && r.splice(p, 1);
  trayIcons.set(r);
}
function trayExists($) {
  const r = get_store_value(trayIcons);
  for (let p = 0; p < r.length; p++) if (r[p].identifier == $) return !0;
  return !1;
}
const icon$5 = "./assets/errordialog-744772f4.svg",
  ArcOSVersion = "5.0.6",
  minArcAPI = 0,
  ErrorMessages = writable([]),
  ErrorWindowStore = writable([]);
function errorMessage($, r, p, v, ...k) {
  Log({
    msg: `Generating "${$}"`,
    source: "errorlogic/main.ts: errorMessage",
    level: LogLevel.info,
  });
  const x = {
      title: $,
      message: r,
      opened: !1,
      buttons: k,
      id: Math.floor(Math.random() * 1e10),
      image: p,
      parentId: v,
    },
    S = get_store_value(ErrorMessages);
  S.push(x), ErrorMessages.set(S), createErrorAppData(x);
}
function closeError($) {
  Log({
    msg: `Closing error ${$}`,
    source: "errorlogic/main.ts: closeError",
    level: LogLevel.info,
  });
  const r = get_store_value(ErrorWindowStore);
  for (let p = 0; p < r.length; p++)
    r[p].id == `error_${$}` &&
      ((r[p].opened = !1),
      setTimeout(() => {
        r.splice(p, 1), ErrorWindowStore.set(r);
      }, 500));
  ErrorWindowStore.set(r);
}
function openError($) {
  Log({
    msg: `Opening error ${$}`,
    source: "errorlogic/main.ts: openError",
    level: LogLevel.info,
  });
  const r = get_store_value(ErrorWindowStore);
  for (let p = 0; p < r.length; p++)
    r[p].id == `error_${$}` && (r[p].opened = !0);
  ErrorWindowStore.set(r);
}
function createErrorAppData($) {
  Log({
    msg: `Generating error appData for ${$.title}`,
    source: "errorlogic/main.ts: createErrorAppData",
    level: LogLevel.info,
  });
  const r = {
      info: {
        name: $.title,
        description: "ArcOS.Desktop.ErrorLogicwindow",
        builtin: !0,
        version: ArcOSVersion,
        author: "Generated by ArcOS",
        icon: $.image || icon$5,
      },
      size: { w: NaN, h: NaN },
      pos: { x: 60, y: 60 },
      minSize: { w: 200, h: NaN },
      maxSize: { w: 600, h: NaN },
      controls: { min: !1, max: !1, cls: !0 },
      state: {
        headless: !1,
        resizable: !1,
        windowState: { min: !1, max: !1, fll: !1 },
      },
      content: null,
      glass: !1,
      id: `error_${$.id}`,
      opened: !1,
      parentId: $.parentId,
    },
    p = get_store_value(ErrorWindowStore);
  p.push(r),
    ErrorWindowStore.set(p),
    setTimeout(() => {
      openError($.id);
      const v = document.querySelector(`window#${r.id}`);
      if (!v)
        return Log({
          level: LogLevel.error,
          msg: `Can't bring window ${r.id} to front, no associated element could be found.`,
          source: "ErrorLogic: createErrorAppData",
        });
      maxZIndex.set(get_store_value(maxZIndex) + 1),
        (v.style.zIndex = `${get_store_value(maxZIndex)}`);
    }, 5);
}
function generateParamStr($) {
  let r = "?";
  const p = Object.entries($);
  for (let v = 0; v < p.length; v++) r += `${p[v][0]}=${p[v][1]}&`;
  return r;
}
const ConnectedServer = writable(null);
async function apiCall($, r, p, v, k, x, S) {
  const I = generateCredToken(k),
    F = {
      headers: { Authorization: v ? `Bearer ${v}` : `Basic ${I}` },
      body: x,
      method: x ? "post" : "get",
    },
    O = !k && !v,
    L = generateParamStr(p);
  let U;
  try {
    U = await fetch(`${$}/${r}${L}`, O ? { body: x } : F);
  } catch {
    return (
      get_store_value(CurrentState).name == "Desktop" &&
        invalidServerResponse(r),
      {}
    );
  }
  const N = await U.text();
  if (
    !U.ok &&
    v &&
    !"200|304".includes(`${U.status}`) &&
    get_store_value(CurrentState).name == "Desktop"
  )
    return invalidServerResponse(r), {};
  if (!S)
    try {
      return JSON.parse(N);
    } catch {
      return {};
    }
  return {};
}
function invalidServerResponse($) {
  createTrayIcon({
    identifier: "ArcAPI Error",
    icon: "warning",
    image: null,
    onOpen(r) {
      disposeTrayIcon(r.identifier),
        errorMessage(
          "ArcAPI Error",
          `ArcOS was unable to make a request to ArcAPI on path "${$}". Please check your internet connection and try again.`,
          null,
          null,
          { caption: "OK", action() {} }
        );
    },
  });
}
function generateCredToken($) {
  return $ ? btoa(`${$.username}:${$.password}`) : "";
}
async function changePassword($, r, p, v) {
  if (p != v) return !1;
  const k = await apiCall(
      get_store_value(ConnectedServer),
      "user/changepswd",
      { new: btoa(p) },
      null,
      { username: $, password: r }
    ),
    x = localStorage.getItem("arcos-remembered-token");
  return (
    !x ||
      !k.valid ||
      atob(x).split(":")[0] != $ ||
      localStorage.setItem("arcos-remembered-token", btoa(`${$}:${p}`)),
    k.valid
  );
}
async function changeUsername($, r) {
  if (get_store_value(UserName) != $) return !1;
  const p = await apiCall(
    get_store_value(ConnectedServer),
    "user/rename",
    { newname: btoa(r) },
    get_store_value(UserToken)
  );
  if ((UserName.set(r), !p.valid)) return !1;
  const v = localStorage.getItem("arcos-remembered-token");
  return (
    !v ||
      !p.valid ||
      atob(v).split(":")[0] != $ ||
      localStorage.setItem(
        "arcos-remembered-token",
        btoa(`${r}:${atob(v).split(":")[1]}`)
      ),
    p.valid
  );
}
async function logoffToken() {
  const $ = get_store_value(UserToken),
    r = get_store_value(ConnectedServer);
  if (!(!$ || !r)) return await apiCall(r, "logoff", {}, $);
}
const arctermonly = "",
  main = "",
  defaultDirectory = { files: [], directories: [], name: "", scopedPath: "" },
  warning = "./assets/error-3c4c2c86.svg";
async function getDirectory($ = "./") {
  Log({
    source: "fs/directory.ts: getDirectory",
    msg: `Requesting directory contents of "${$}" from ArcAPI`,
    level: LogLevel.info,
  });
  const r = get_store_value(ConnectedServer);
  if (!r) return !1;
  const p = await apiCall(
    r,
    "fs/dir/get",
    { path: $ ? btoa($) : null },
    get_store_value(UserToken)
  );
  return !p || !p.valid ? !1 : p.data;
}
async function createDirectory($) {
  const r = get_store_value(ConnectedServer);
  return r
    ? (
        await apiCall(
          r,
          "fs/dir/create",
          { path: btoa($) },
          get_store_value(UserToken)
        )
      ).valid
    : !1;
}
function bind($, r) {
  return function () {
    return $.apply(r, arguments);
  };
}
const { toString: toString$1 } = Object.prototype,
  { getPrototypeOf } = Object,
  kindOf = (($) => (r) => {
    const p = toString$1.call(r);
    return $[p] || ($[p] = p.slice(8, -1).toLowerCase());
  })(Object.create(null)),
  kindOfTest = ($) => (($ = $.toLowerCase()), (r) => kindOf(r) === $),
  typeOfTest = ($) => (r) => typeof r === $,
  { isArray: isArray$1 } = Array,
  isUndefined = typeOfTest("undefined");
function isBuffer($) {
  return (
    $ !== null &&
    !isUndefined($) &&
    $.constructor !== null &&
    !isUndefined($.constructor) &&
    isFunction($.constructor.isBuffer) &&
    $.constructor.isBuffer($)
  );
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView($) {
  let r;
  return (
    typeof ArrayBuffer < "u" && ArrayBuffer.isView
      ? (r = ArrayBuffer.isView($))
      : (r = $ && $.buffer && isArrayBuffer($.buffer)),
    r
  );
}
const isString$1 = typeOfTest("string"),
  isFunction = typeOfTest("function"),
  isNumber$1 = typeOfTest("number"),
  isObject$1 = ($) => $ !== null && typeof $ == "object",
  isBoolean$1 = ($) => $ === !0 || $ === !1,
  isPlainObject = ($) => {
    if (kindOf($) !== "object") return !1;
    const r = getPrototypeOf($);
    return (
      (r === null ||
        r === Object.prototype ||
        Object.getPrototypeOf(r) === null) &&
      !(Symbol.toStringTag in $) &&
      !(Symbol.iterator in $)
    );
  },
  isDate = kindOfTest("Date"),
  isFile = kindOfTest("File"),
  isBlob = kindOfTest("Blob"),
  isFileList = kindOfTest("FileList"),
  isStream = ($) => isObject$1($) && isFunction($.pipe),
  isFormData = ($) => {
    const r = "[object FormData]";
    return (
      $ &&
      ((typeof FormData == "function" && $ instanceof FormData) ||
        toString$1.call($) === r ||
        (isFunction($.toString) && $.toString() === r))
    );
  },
  isURLSearchParams = kindOfTest("URLSearchParams"),
  trim = ($) =>
    $.trim ? $.trim() : $.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach($, r, { allOwnKeys: p = !1 } = {}) {
  if ($ === null || typeof $ > "u") return;
  let v, k;
  if ((typeof $ != "object" && ($ = [$]), isArray$1($)))
    for (v = 0, k = $.length; v < k; v++) r.call(null, $[v], v, $);
  else {
    const x = p ? Object.getOwnPropertyNames($) : Object.keys($),
      S = x.length;
    let I;
    for (v = 0; v < S; v++) (I = x[v]), r.call(null, $[I], I, $);
  }
}
function findKey($, r) {
  r = r.toLowerCase();
  const p = Object.keys($);
  let v = p.length,
    k;
  for (; v-- > 0; ) if (((k = p[v]), r === k.toLowerCase())) return k;
  return null;
}
const _global = (() =>
    typeof globalThis < "u"
      ? globalThis
      : typeof self < "u"
      ? self
      : typeof window < "u"
      ? window
      : global)(),
  isContextDefined = ($) => !isUndefined($) && $ !== _global;
function merge$1() {
  const { caseless: $ } = (isContextDefined(this) && this) || {},
    r = {},
    p = (v, k) => {
      const x = ($ && findKey(r, k)) || k;
      isPlainObject(r[x]) && isPlainObject(v)
        ? (r[x] = merge$1(r[x], v))
        : isPlainObject(v)
        ? (r[x] = merge$1({}, v))
        : isArray$1(v)
        ? (r[x] = v.slice())
        : (r[x] = v);
    };
  for (let v = 0, k = arguments.length; v < k; v++)
    arguments[v] && forEach(arguments[v], p);
  return r;
}
const extend = ($, r, p, { allOwnKeys: v } = {}) => (
    forEach(
      r,
      (k, x) => {
        p && isFunction(k) ? ($[x] = bind(k, p)) : ($[x] = k);
      },
      { allOwnKeys: v }
    ),
    $
  ),
  stripBOM = ($) => ($.charCodeAt(0) === 65279 && ($ = $.slice(1)), $),
  inherits = ($, r, p, v) => {
    ($.prototype = Object.create(r.prototype, v)),
      ($.prototype.constructor = $),
      Object.defineProperty($, "super", { value: r.prototype }),
      p && Object.assign($.prototype, p);
  },
  toFlatObject = ($, r, p, v) => {
    let k, x, S;
    const I = {};
    if (((r = r || {}), $ == null)) return r;
    do {
      for (k = Object.getOwnPropertyNames($), x = k.length; x-- > 0; )
        (S = k[x]), (!v || v(S, $, r)) && !I[S] && ((r[S] = $[S]), (I[S] = !0));
      $ = p !== !1 && getPrototypeOf($);
    } while ($ && (!p || p($, r)) && $ !== Object.prototype);
    return r;
  },
  endsWith = ($, r, p) => {
    ($ = String($)),
      (p === void 0 || p > $.length) && (p = $.length),
      (p -= r.length);
    const v = $.indexOf(r, p);
    return v !== -1 && v === p;
  },
  toArray = ($) => {
    if (!$) return null;
    if (isArray$1($)) return $;
    let r = $.length;
    if (!isNumber$1(r)) return null;
    const p = new Array(r);
    for (; r-- > 0; ) p[r] = $[r];
    return p;
  },
  isTypedArray = (
    ($) => (r) =>
      $ && r instanceof $
  )(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array)),
  forEachEntry = ($, r) => {
    const v = ($ && $[Symbol.iterator]).call($);
    let k;
    for (; (k = v.next()) && !k.done; ) {
      const x = k.value;
      r.call($, x[0], x[1]);
    }
  },
  matchAll = ($, r) => {
    let p;
    const v = [];
    for (; (p = $.exec(r)) !== null; ) v.push(p);
    return v;
  },
  isHTMLForm = kindOfTest("HTMLFormElement"),
  toCamelCase = ($) =>
    $.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (p, v, k) {
      return v.toUpperCase() + k;
    }),
  hasOwnProperty = (
    ({ hasOwnProperty: $ }) =>
    (r, p) =>
      $.call(r, p)
  )(Object.prototype),
  isRegExp = kindOfTest("RegExp"),
  reduceDescriptors = ($, r) => {
    const p = Object.getOwnPropertyDescriptors($),
      v = {};
    forEach(p, (k, x) => {
      r(k, x, $) !== !1 && (v[x] = k);
    }),
      Object.defineProperties($, v);
  },
  freezeMethods = ($) => {
    reduceDescriptors($, (r, p) => {
      if (isFunction($) && ["arguments", "caller", "callee"].indexOf(p) !== -1)
        return !1;
      const v = $[p];
      if (isFunction(v)) {
        if (((r.enumerable = !1), "writable" in r)) {
          r.writable = !1;
          return;
        }
        r.set ||
          (r.set = () => {
            throw Error("Can not rewrite read-only method '" + p + "'");
          });
      }
    });
  },
  toObjectSet = ($, r) => {
    const p = {},
      v = (k) => {
        k.forEach((x) => {
          p[x] = !0;
        });
      };
    return isArray$1($) ? v($) : v(String($).split(r)), p;
  },
  noop = () => {},
  toFiniteNumber = ($, r) => (($ = +$), Number.isFinite($) ? $ : r),
  ALPHA = "abcdefghijklmnopqrstuvwxyz",
  DIGIT = "0123456789",
  ALPHABET = { DIGIT, ALPHA, ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT },
  generateString = ($ = 16, r = ALPHABET.ALPHA_DIGIT) => {
    let p = "";
    const { length: v } = r;
    for (; $--; ) p += r[(Math.random() * v) | 0];
    return p;
  };
function isSpecCompliantForm($) {
  return !!(
    $ &&
    isFunction($.append) &&
    $[Symbol.toStringTag] === "FormData" &&
    $[Symbol.iterator]
  );
}
const toJSONObject = ($) => {
    const r = new Array(10),
      p = (v, k) => {
        if (isObject$1(v)) {
          if (r.indexOf(v) >= 0) return;
          if (!("toJSON" in v)) {
            r[k] = v;
            const x = isArray$1(v) ? [] : {};
            return (
              forEach(v, (S, I) => {
                const F = p(S, k + 1);
                !isUndefined(F) && (x[I] = F);
              }),
              (r[k] = void 0),
              x
            );
          }
        }
        return v;
      };
    return p($, 0);
  },
  utils = {
    isArray: isArray$1,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString: isString$1,
    isNumber: isNumber$1,
    isBoolean: isBoolean$1,
    isObject: isObject$1,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge: merge$1,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
  };
function AxiosError($, r, p, v, k) {
  Error.call(this),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack),
    (this.message = $),
    (this.name = "AxiosError"),
    r && (this.code = r),
    p && (this.config = p),
    v && (this.request = v),
    k && (this.response = k);
}
utils.inherits(AxiosError, Error, {
  toJSON: function () {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: utils.toJSONObject(this.config),
      code: this.code,
      status:
        this.response && this.response.status ? this.response.status : null,
    };
  },
});
const prototype$1 = AxiosError.prototype,
  descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL",
].forEach(($) => {
  descriptors[$] = { value: $ };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: !0 });
AxiosError.from = ($, r, p, v, k, x) => {
  const S = Object.create(prototype$1);
  return (
    utils.toFlatObject(
      $,
      S,
      function (F) {
        return F !== Error.prototype;
      },
      (I) => I !== "isAxiosError"
    ),
    AxiosError.call(S, $.message, r, p, v, k),
    (S.cause = $),
    (S.name = $.name),
    x && Object.assign(S, x),
    S
  );
};
const httpAdapter = null;
function isVisitable($) {
  return utils.isPlainObject($) || utils.isArray($);
}
function removeBrackets($) {
  return utils.endsWith($, "[]") ? $.slice(0, -2) : $;
}
function renderKey($, r, p) {
  return $
    ? $.concat(r)
        .map(function (k, x) {
          return (k = removeBrackets(k)), !p && x ? "[" + k + "]" : k;
        })
        .join(p ? "." : "")
    : r;
}
function isFlatArray($) {
  return utils.isArray($) && !$.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function (r) {
  return /^is[A-Z]/.test(r);
});
function toFormData($, r, p) {
  if (!utils.isObject($)) throw new TypeError("target must be an object");
  (r = r || new FormData()),
    (p = utils.toFlatObject(
      p,
      { metaTokens: !0, dots: !1, indexes: !1 },
      !1,
      function (q, Q) {
        return !utils.isUndefined(Q[q]);
      }
    ));
  const v = p.metaTokens,
    k = p.visitor || L,
    x = p.dots,
    S = p.indexes,
    F = (p.Blob || (typeof Blob < "u" && Blob)) && utils.isSpecCompliantForm(r);
  if (!utils.isFunction(k)) throw new TypeError("visitor must be a function");
  function O(R) {
    if (R === null) return "";
    if (utils.isDate(R)) return R.toISOString();
    if (!F && utils.isBlob(R))
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    return utils.isArrayBuffer(R) || utils.isTypedArray(R)
      ? F && typeof Blob == "function"
        ? new Blob([R])
        : Buffer.from(R)
      : R;
  }
  function L(R, q, Q) {
    let K = R;
    if (R && !Q && typeof R == "object") {
      if (utils.endsWith(q, "{}"))
        (q = v ? q : q.slice(0, -2)), (R = JSON.stringify(R));
      else if (
        (utils.isArray(R) && isFlatArray(R)) ||
        ((utils.isFileList(R) || utils.endsWith(q, "[]")) &&
          (K = utils.toArray(R)))
      )
        return (
          (q = removeBrackets(q)),
          K.forEach(function (H, G) {
            !(utils.isUndefined(H) || H === null) &&
              r.append(
                S === !0 ? renderKey([q], G, x) : S === null ? q : q + "[]",
                O(H)
              );
          }),
          !1
        );
    }
    return isVisitable(R) ? !0 : (r.append(renderKey(Q, q, x), O(R)), !1);
  }
  const U = [],
    N = Object.assign(predicates, {
      defaultVisitor: L,
      convertValue: O,
      isVisitable,
    });
  function j(R, q) {
    if (!utils.isUndefined(R)) {
      if (U.indexOf(R) !== -1)
        throw Error("Circular reference detected in " + q.join("."));
      U.push(R),
        utils.forEach(R, function (K, V) {
          (!(utils.isUndefined(K) || K === null) &&
            k.call(r, K, utils.isString(V) ? V.trim() : V, q, N)) === !0 &&
            j(K, q ? q.concat(V) : [V]);
        }),
        U.pop();
    }
  }
  if (!utils.isObject($)) throw new TypeError("data must be an object");
  return j($), r;
}
function encode$1($) {
  const r = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0",
  };
  return encodeURIComponent($).replace(/[!'()~]|%20|%00/g, function (v) {
    return r[v];
  });
}
function AxiosURLSearchParams($, r) {
  (this._pairs = []), $ && toFormData($, this, r);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function (r, p) {
  this._pairs.push([r, p]);
};
prototype.toString = function (r) {
  const p = r
    ? function (v) {
        return r.call(this, v, encode$1);
      }
    : encode$1;
  return this._pairs
    .map(function (k) {
      return p(k[0]) + "=" + p(k[1]);
    }, "")
    .join("&");
};
function encode($) {
  return encodeURIComponent($)
    .replace(/%3A/gi, ":")
    .replace(/%24/g, "$")
    .replace(/%2C/gi, ",")
    .replace(/%20/g, "+")
    .replace(/%5B/gi, "[")
    .replace(/%5D/gi, "]");
}
function buildURL($, r, p) {
  if (!r) return $;
  const v = (p && p.encode) || encode,
    k = p && p.serialize;
  let x;
  if (
    (k
      ? (x = k(r, p))
      : (x = utils.isURLSearchParams(r)
          ? r.toString()
          : new AxiosURLSearchParams(r, p).toString(v)),
    x)
  ) {
    const S = $.indexOf("#");
    S !== -1 && ($ = $.slice(0, S)),
      ($ += ($.indexOf("?") === -1 ? "?" : "&") + x);
  }
  return $;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  use(r, p, v) {
    return (
      this.handlers.push({
        fulfilled: r,
        rejected: p,
        synchronous: v ? v.synchronous : !1,
        runWhen: v ? v.runWhen : null,
      }),
      this.handlers.length - 1
    );
  }
  eject(r) {
    this.handlers[r] && (this.handlers[r] = null);
  }
  clear() {
    this.handlers && (this.handlers = []);
  }
  forEach(r) {
    utils.forEach(this.handlers, function (v) {
      v !== null && r(v);
    });
  }
}
const InterceptorManager$1 = InterceptorManager,
  transitionalDefaults = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1,
  },
  URLSearchParams$1 =
    typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams,
  FormData$1 = FormData,
  isStandardBrowserEnv = (() => {
    let $;
    return typeof navigator < "u" &&
      (($ = navigator.product) === "ReactNative" ||
        $ === "NativeScript" ||
        $ === "NS")
      ? !1
      : typeof window < "u" && typeof document < "u";
  })(),
  isStandardBrowserWebWorkerEnv = (() =>
    typeof WorkerGlobalScope < "u" &&
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts == "function")(),
  platform = {
    isBrowser: !0,
    classes: { URLSearchParams: URLSearchParams$1, FormData: FormData$1, Blob },
    isStandardBrowserEnv,
    isStandardBrowserWebWorkerEnv,
    protocols: ["http", "https", "file", "blob", "url", "data"],
  };
function toURLEncodedForm($, r) {
  return toFormData(
    $,
    new platform.classes.URLSearchParams(),
    Object.assign(
      {
        visitor: function (p, v, k, x) {
          return platform.isNode && utils.isBuffer(p)
            ? (this.append(v, p.toString("base64")), !1)
            : x.defaultVisitor.apply(this, arguments);
        },
      },
      r
    )
  );
}
function parsePropPath($) {
  return utils
    .matchAll(/\w+|\[(\w*)]/g, $)
    .map((r) => (r[0] === "[]" ? "" : r[1] || r[0]));
}
function arrayToObject($) {
  const r = {},
    p = Object.keys($);
  let v;
  const k = p.length;
  let x;
  for (v = 0; v < k; v++) (x = p[v]), (r[x] = $[x]);
  return r;
}
function formDataToJSON($) {
  function r(p, v, k, x) {
    let S = p[x++];
    const I = Number.isFinite(+S),
      F = x >= p.length;
    return (
      (S = !S && utils.isArray(k) ? k.length : S),
      F
        ? (utils.hasOwnProp(k, S) ? (k[S] = [k[S], v]) : (k[S] = v), !I)
        : ((!k[S] || !utils.isObject(k[S])) && (k[S] = []),
          r(p, v, k[S], x) &&
            utils.isArray(k[S]) &&
            (k[S] = arrayToObject(k[S])),
          !I)
    );
  }
  if (utils.isFormData($) && utils.isFunction($.entries)) {
    const p = {};
    return (
      utils.forEachEntry($, (v, k) => {
        r(parsePropPath(v), k, p, 0);
      }),
      p
    );
  }
  return null;
}
const DEFAULT_CONTENT_TYPE = { "Content-Type": void 0 };
function stringifySafely($, r, p) {
  if (utils.isString($))
    try {
      return (r || JSON.parse)($), utils.trim($);
    } catch (v) {
      if (v.name !== "SyntaxError") throw v;
    }
  return (p || JSON.stringify)($);
}
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [
    function (r, p) {
      const v = p.getContentType() || "",
        k = v.indexOf("application/json") > -1,
        x = utils.isObject(r);
      if (
        (x && utils.isHTMLForm(r) && (r = new FormData(r)), utils.isFormData(r))
      )
        return k && k ? JSON.stringify(formDataToJSON(r)) : r;
      if (
        utils.isArrayBuffer(r) ||
        utils.isBuffer(r) ||
        utils.isStream(r) ||
        utils.isFile(r) ||
        utils.isBlob(r)
      )
        return r;
      if (utils.isArrayBufferView(r)) return r.buffer;
      if (utils.isURLSearchParams(r))
        return (
          p.setContentType(
            "application/x-www-form-urlencoded;charset=utf-8",
            !1
          ),
          r.toString()
        );
      let I;
      if (x) {
        if (v.indexOf("application/x-www-form-urlencoded") > -1)
          return toURLEncodedForm(r, this.formSerializer).toString();
        if (
          (I = utils.isFileList(r)) ||
          v.indexOf("multipart/form-data") > -1
        ) {
          const F = this.env && this.env.FormData;
          return toFormData(
            I ? { "files[]": r } : r,
            F && new F(),
            this.formSerializer
          );
        }
      }
      return x || k
        ? (p.setContentType("application/json", !1), stringifySafely(r))
        : r;
    },
  ],
  transformResponse: [
    function (r) {
      const p = this.transitional || defaults$1.transitional,
        v = p && p.forcedJSONParsing,
        k = this.responseType === "json";
      if (r && utils.isString(r) && ((v && !this.responseType) || k)) {
        const S = !(p && p.silentJSONParsing) && k;
        try {
          return JSON.parse(r);
        } catch (I) {
          if (S)
            throw I.name === "SyntaxError"
              ? AxiosError.from(
                  I,
                  AxiosError.ERR_BAD_RESPONSE,
                  this,
                  null,
                  this.response
                )
              : I;
        }
      }
      return r;
    },
  ],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: { FormData: platform.classes.FormData, Blob: platform.classes.Blob },
  validateStatus: function (r) {
    return r >= 200 && r < 300;
  },
  headers: { common: { Accept: "application/json, text/plain, */*" } },
};
utils.forEach(["delete", "get", "head"], function (r) {
  defaults$1.headers[r] = {};
});
utils.forEach(["post", "put", "patch"], function (r) {
  defaults$1.headers[r] = utils.merge(DEFAULT_CONTENT_TYPE);
});
const defaults$2 = defaults$1,
  ignoreDuplicateOf = utils.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent",
  ]),
  parseHeaders = ($) => {
    const r = {};
    let p, v, k;
    return (
      $ &&
        $.split(
          `
`
        ).forEach(function (S) {
          (k = S.indexOf(":")),
            (p = S.substring(0, k).trim().toLowerCase()),
            (v = S.substring(k + 1).trim()),
            !(!p || (r[p] && ignoreDuplicateOf[p])) &&
              (p === "set-cookie"
                ? r[p]
                  ? r[p].push(v)
                  : (r[p] = [v])
                : (r[p] = r[p] ? r[p] + ", " + v : v));
        }),
      r
    );
  },
  $internals = Symbol("internals");
function normalizeHeader($) {
  return $ && String($).trim().toLowerCase();
}
function normalizeValue($) {
  return $ === !1 || $ == null
    ? $
    : utils.isArray($)
    ? $.map(normalizeValue)
    : String($);
}
function parseTokens($) {
  const r = Object.create(null),
    p = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let v;
  for (; (v = p.exec($)); ) r[v[1]] = v[2];
  return r;
}
function isValidHeaderName($) {
  return /^[-_a-zA-Z]+$/.test($.trim());
}
function matchHeaderValue($, r, p, v) {
  if (utils.isFunction(v)) return v.call(this, r, p);
  if (utils.isString(r)) {
    if (utils.isString(v)) return r.indexOf(v) !== -1;
    if (utils.isRegExp(v)) return v.test(r);
  }
}
function formatHeader($) {
  return $.trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (r, p, v) => p.toUpperCase() + v);
}
function buildAccessors($, r) {
  const p = utils.toCamelCase(" " + r);
  ["get", "set", "has"].forEach((v) => {
    Object.defineProperty($, v + p, {
      value: function (k, x, S) {
        return this[v].call(this, r, k, x, S);
      },
      configurable: !0,
    });
  });
}
class AxiosHeaders {
  constructor(r) {
    r && this.set(r);
  }
  set(r, p, v) {
    const k = this;
    function x(I, F, O) {
      const L = normalizeHeader(F);
      if (!L) throw new Error("header name must be a non-empty string");
      const U = utils.findKey(k, L);
      (!U || k[U] === void 0 || O === !0 || (O === void 0 && k[U] !== !1)) &&
        (k[U || F] = normalizeValue(I));
    }
    const S = (I, F) => utils.forEach(I, (O, L) => x(O, L, F));
    return (
      utils.isPlainObject(r) || r instanceof this.constructor
        ? S(r, p)
        : utils.isString(r) && (r = r.trim()) && !isValidHeaderName(r)
        ? S(parseHeaders(r), p)
        : r != null && x(p, r, v),
      this
    );
  }
  get(r, p) {
    if (((r = normalizeHeader(r)), r)) {
      const v = utils.findKey(this, r);
      if (v) {
        const k = this[v];
        if (!p) return k;
        if (p === !0) return parseTokens(k);
        if (utils.isFunction(p)) return p.call(this, k, v);
        if (utils.isRegExp(p)) return p.exec(k);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(r, p) {
    if (((r = normalizeHeader(r)), r)) {
      const v = utils.findKey(this, r);
      return !!(
        v &&
        this[v] !== void 0 &&
        (!p || matchHeaderValue(this, this[v], v, p))
      );
    }
    return !1;
  }
  delete(r, p) {
    const v = this;
    let k = !1;
    function x(S) {
      if (((S = normalizeHeader(S)), S)) {
        const I = utils.findKey(v, S);
        I && (!p || matchHeaderValue(v, v[I], I, p)) && (delete v[I], (k = !0));
      }
    }
    return utils.isArray(r) ? r.forEach(x) : x(r), k;
  }
  clear(r) {
    const p = Object.keys(this);
    let v = p.length,
      k = !1;
    for (; v--; ) {
      const x = p[v];
      (!r || matchHeaderValue(this, this[x], x, r)) &&
        (delete this[x], (k = !0));
    }
    return k;
  }
  normalize(r) {
    const p = this,
      v = {};
    return (
      utils.forEach(this, (k, x) => {
        const S = utils.findKey(v, x);
        if (S) {
          (p[S] = normalizeValue(k)), delete p[x];
          return;
        }
        const I = r ? formatHeader(x) : String(x).trim();
        I !== x && delete p[x], (p[I] = normalizeValue(k)), (v[I] = !0);
      }),
      this
    );
  }
  concat(...r) {
    return this.constructor.concat(this, ...r);
  }
  toJSON(r) {
    const p = Object.create(null);
    return (
      utils.forEach(this, (v, k) => {
        v != null &&
          v !== !1 &&
          (p[k] = r && utils.isArray(v) ? v.join(", ") : v);
      }),
      p
    );
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([r, p]) => r + ": " + p).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(r) {
    return r instanceof this ? r : new this(r);
  }
  static concat(r, ...p) {
    const v = new this(r);
    return p.forEach((k) => v.set(k)), v;
  }
  static accessor(r) {
    const v = (this[$internals] = this[$internals] = { accessors: {} })
        .accessors,
      k = this.prototype;
    function x(S) {
      const I = normalizeHeader(S);
      v[I] || (buildAccessors(k, S), (v[I] = !0));
    }
    return utils.isArray(r) ? r.forEach(x) : x(r), this;
  }
}
AxiosHeaders.accessor([
  "Content-Type",
  "Content-Length",
  "Accept",
  "Accept-Encoding",
  "User-Agent",
  "Authorization",
]);
utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData($, r) {
  const p = this || defaults$2,
    v = r || p,
    k = AxiosHeaders$1.from(v.headers);
  let x = v.data;
  return (
    utils.forEach($, function (I) {
      x = I.call(p, x, k.normalize(), r ? r.status : void 0);
    }),
    k.normalize(),
    x
  );
}
function isCancel($) {
  return !!($ && $.__CANCEL__);
}
function CanceledError($, r, p) {
  AxiosError.call(this, $ ?? "canceled", AxiosError.ERR_CANCELED, r, p),
    (this.name = "CanceledError");
}
utils.inherits(CanceledError, AxiosError, { __CANCEL__: !0 });
function settle($, r, p) {
  const v = p.config.validateStatus;
  !p.status || !v || v(p.status)
    ? $(p)
    : r(
        new AxiosError(
          "Request failed with status code " + p.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][
            Math.floor(p.status / 100) - 4
          ],
          p.config,
          p.request,
          p
        )
      );
}
const cookies = platform.isStandardBrowserEnv
  ? (function () {
      return {
        write: function (p, v, k, x, S, I) {
          const F = [];
          F.push(p + "=" + encodeURIComponent(v)),
            utils.isNumber(k) && F.push("expires=" + new Date(k).toGMTString()),
            utils.isString(x) && F.push("path=" + x),
            utils.isString(S) && F.push("domain=" + S),
            I === !0 && F.push("secure"),
            (document.cookie = F.join("; "));
        },
        read: function (p) {
          const v = document.cookie.match(
            new RegExp("(^|;\\s*)(" + p + ")=([^;]*)")
          );
          return v ? decodeURIComponent(v[3]) : null;
        },
        remove: function (p) {
          this.write(p, "", Date.now() - 864e5);
        },
      };
    })()
  : (function () {
      return {
        write: function () {},
        read: function () {
          return null;
        },
        remove: function () {},
      };
    })();
function isAbsoluteURL($) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test($);
}
function combineURLs($, r) {
  return r ? $.replace(/\/+$/, "") + "/" + r.replace(/^\/+/, "") : $;
}
function buildFullPath($, r) {
  return $ && !isAbsoluteURL(r) ? combineURLs($, r) : r;
}
const isURLSameOrigin = platform.isStandardBrowserEnv
  ? (function () {
      const r = /(msie|trident)/i.test(navigator.userAgent),
        p = document.createElement("a");
      let v;
      function k(x) {
        let S = x;
        return (
          r && (p.setAttribute("href", S), (S = p.href)),
          p.setAttribute("href", S),
          {
            href: p.href,
            protocol: p.protocol ? p.protocol.replace(/:$/, "") : "",
            host: p.host,
            search: p.search ? p.search.replace(/^\?/, "") : "",
            hash: p.hash ? p.hash.replace(/^#/, "") : "",
            hostname: p.hostname,
            port: p.port,
            pathname:
              p.pathname.charAt(0) === "/" ? p.pathname : "/" + p.pathname,
          }
        );
      }
      return (
        (v = k(window.location.href)),
        function (S) {
          const I = utils.isString(S) ? k(S) : S;
          return I.protocol === v.protocol && I.host === v.host;
        }
      );
    })()
  : (function () {
      return function () {
        return !0;
      };
    })();
function parseProtocol($) {
  const r = /^([-+\w]{1,25})(:?\/\/|:)/.exec($);
  return (r && r[1]) || "";
}
function speedometer($, r) {
  $ = $ || 10;
  const p = new Array($),
    v = new Array($);
  let k = 0,
    x = 0,
    S;
  return (
    (r = r !== void 0 ? r : 1e3),
    function (F) {
      const O = Date.now(),
        L = v[x];
      S || (S = O), (p[k] = F), (v[k] = O);
      let U = x,
        N = 0;
      for (; U !== k; ) (N += p[U++]), (U = U % $);
      if (((k = (k + 1) % $), k === x && (x = (x + 1) % $), O - S < r)) return;
      const j = L && O - L;
      return j ? Math.round((N * 1e3) / j) : void 0;
    }
  );
}
function progressEventReducer($, r) {
  let p = 0;
  const v = speedometer(50, 250);
  return (k) => {
    const x = k.loaded,
      S = k.lengthComputable ? k.total : void 0,
      I = x - p,
      F = v(I),
      O = x <= S;
    p = x;
    const L = {
      loaded: x,
      total: S,
      progress: S ? x / S : void 0,
      bytes: I,
      rate: F || void 0,
      estimated: F && S && O ? (S - x) / F : void 0,
      event: k,
    };
    (L[r ? "download" : "upload"] = !0), $(L);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest < "u",
  xhrAdapter =
    isXHRAdapterSupported &&
    function ($) {
      return new Promise(function (p, v) {
        let k = $.data;
        const x = AxiosHeaders$1.from($.headers).normalize(),
          S = $.responseType;
        let I;
        function F() {
          $.cancelToken && $.cancelToken.unsubscribe(I),
            $.signal && $.signal.removeEventListener("abort", I);
        }
        utils.isFormData(k) &&
          (platform.isStandardBrowserEnv ||
            platform.isStandardBrowserWebWorkerEnv) &&
          x.setContentType(!1);
        let O = new XMLHttpRequest();
        if ($.auth) {
          const j = $.auth.username || "",
            R = $.auth.password
              ? unescape(encodeURIComponent($.auth.password))
              : "";
          x.set("Authorization", "Basic " + btoa(j + ":" + R));
        }
        const L = buildFullPath($.baseURL, $.url);
        O.open(
          $.method.toUpperCase(),
          buildURL(L, $.params, $.paramsSerializer),
          !0
        ),
          (O.timeout = $.timeout);
        function U() {
          if (!O) return;
          const j = AxiosHeaders$1.from(
              "getAllResponseHeaders" in O && O.getAllResponseHeaders()
            ),
            q = {
              data:
                !S || S === "text" || S === "json"
                  ? O.responseText
                  : O.response,
              status: O.status,
              statusText: O.statusText,
              headers: j,
              config: $,
              request: O,
            };
          settle(
            function (K) {
              p(K), F();
            },
            function (K) {
              v(K), F();
            },
            q
          ),
            (O = null);
        }
        if (
          ("onloadend" in O
            ? (O.onloadend = U)
            : (O.onreadystatechange = function () {
                !O ||
                  O.readyState !== 4 ||
                  (O.status === 0 &&
                    !(O.responseURL && O.responseURL.indexOf("file:") === 0)) ||
                  setTimeout(U);
              }),
          (O.onabort = function () {
            O &&
              (v(
                new AxiosError("Request aborted", AxiosError.ECONNABORTED, $, O)
              ),
              (O = null));
          }),
          (O.onerror = function () {
            v(new AxiosError("Network Error", AxiosError.ERR_NETWORK, $, O)),
              (O = null);
          }),
          (O.ontimeout = function () {
            let R = $.timeout
              ? "timeout of " + $.timeout + "ms exceeded"
              : "timeout exceeded";
            const q = $.transitional || transitionalDefaults;
            $.timeoutErrorMessage && (R = $.timeoutErrorMessage),
              v(
                new AxiosError(
                  R,
                  q.clarifyTimeoutError
                    ? AxiosError.ETIMEDOUT
                    : AxiosError.ECONNABORTED,
                  $,
                  O
                )
              ),
              (O = null);
          }),
          platform.isStandardBrowserEnv)
        ) {
          const j =
            ($.withCredentials || isURLSameOrigin(L)) &&
            $.xsrfCookieName &&
            cookies.read($.xsrfCookieName);
          j && x.set($.xsrfHeaderName, j);
        }
        k === void 0 && x.setContentType(null),
          "setRequestHeader" in O &&
            utils.forEach(x.toJSON(), function (R, q) {
              O.setRequestHeader(q, R);
            }),
          utils.isUndefined($.withCredentials) ||
            (O.withCredentials = !!$.withCredentials),
          S && S !== "json" && (O.responseType = $.responseType),
          typeof $.onDownloadProgress == "function" &&
            O.addEventListener(
              "progress",
              progressEventReducer($.onDownloadProgress, !0)
            ),
          typeof $.onUploadProgress == "function" &&
            O.upload &&
            O.upload.addEventListener(
              "progress",
              progressEventReducer($.onUploadProgress)
            ),
          ($.cancelToken || $.signal) &&
            ((I = (j) => {
              O &&
                (v(!j || j.type ? new CanceledError(null, $, O) : j),
                O.abort(),
                (O = null));
            }),
            $.cancelToken && $.cancelToken.subscribe(I),
            $.signal &&
              ($.signal.aborted ? I() : $.signal.addEventListener("abort", I)));
        const N = parseProtocol(L);
        if (N && platform.protocols.indexOf(N) === -1) {
          v(
            new AxiosError(
              "Unsupported protocol " + N + ":",
              AxiosError.ERR_BAD_REQUEST,
              $
            )
          );
          return;
        }
        O.send(k || null);
      });
    },
  knownAdapters = { http: httpAdapter, xhr: xhrAdapter };
utils.forEach(knownAdapters, ($, r) => {
  if ($) {
    try {
      Object.defineProperty($, "name", { value: r });
    } catch {}
    Object.defineProperty($, "adapterName", { value: r });
  }
});
const adapters = {
  getAdapter: ($) => {
    $ = utils.isArray($) ? $ : [$];
    const { length: r } = $;
    let p, v;
    for (
      let k = 0;
      k < r &&
      ((p = $[k]),
      !(v = utils.isString(p) ? knownAdapters[p.toLowerCase()] : p));
      k++
    );
    if (!v)
      throw v === !1
        ? new AxiosError(
            `Adapter ${p} is not supported by the environment`,
            "ERR_NOT_SUPPORT"
          )
        : new Error(
            utils.hasOwnProp(knownAdapters, p)
              ? `Adapter '${p}' is not available in the build`
              : `Unknown adapter '${p}'`
          );
    if (!utils.isFunction(v)) throw new TypeError("adapter is not a function");
    return v;
  },
  adapters: knownAdapters,
};
function throwIfCancellationRequested($) {
  if (
    ($.cancelToken && $.cancelToken.throwIfRequested(),
    $.signal && $.signal.aborted)
  )
    throw new CanceledError(null, $);
}
function dispatchRequest($) {
  return (
    throwIfCancellationRequested($),
    ($.headers = AxiosHeaders$1.from($.headers)),
    ($.data = transformData.call($, $.transformRequest)),
    ["post", "put", "patch"].indexOf($.method) !== -1 &&
      $.headers.setContentType("application/x-www-form-urlencoded", !1),
    adapters
      .getAdapter($.adapter || defaults$2.adapter)($)
      .then(
        function (v) {
          return (
            throwIfCancellationRequested($),
            (v.data = transformData.call($, $.transformResponse, v)),
            (v.headers = AxiosHeaders$1.from(v.headers)),
            v
          );
        },
        function (v) {
          return (
            isCancel(v) ||
              (throwIfCancellationRequested($),
              v &&
                v.response &&
                ((v.response.data = transformData.call(
                  $,
                  $.transformResponse,
                  v.response
                )),
                (v.response.headers = AxiosHeaders$1.from(
                  v.response.headers
                )))),
            Promise.reject(v)
          );
        }
      )
  );
}
const headersToObject = ($) => ($ instanceof AxiosHeaders$1 ? $.toJSON() : $);
function mergeConfig($, r) {
  r = r || {};
  const p = {};
  function v(O, L, U) {
    return utils.isPlainObject(O) && utils.isPlainObject(L)
      ? utils.merge.call({ caseless: U }, O, L)
      : utils.isPlainObject(L)
      ? utils.merge({}, L)
      : utils.isArray(L)
      ? L.slice()
      : L;
  }
  function k(O, L, U) {
    if (utils.isUndefined(L)) {
      if (!utils.isUndefined(O)) return v(void 0, O, U);
    } else return v(O, L, U);
  }
  function x(O, L) {
    if (!utils.isUndefined(L)) return v(void 0, L);
  }
  function S(O, L) {
    if (utils.isUndefined(L)) {
      if (!utils.isUndefined(O)) return v(void 0, O);
    } else return v(void 0, L);
  }
  function I(O, L, U) {
    if (U in r) return v(O, L);
    if (U in $) return v(void 0, O);
  }
  const F = {
    url: x,
    method: x,
    data: x,
    baseURL: S,
    transformRequest: S,
    transformResponse: S,
    paramsSerializer: S,
    timeout: S,
    timeoutMessage: S,
    withCredentials: S,
    adapter: S,
    responseType: S,
    xsrfCookieName: S,
    xsrfHeaderName: S,
    onUploadProgress: S,
    onDownloadProgress: S,
    decompress: S,
    maxContentLength: S,
    maxBodyLength: S,
    beforeRedirect: S,
    transport: S,
    httpAgent: S,
    httpsAgent: S,
    cancelToken: S,
    socketPath: S,
    responseEncoding: S,
    validateStatus: I,
    headers: (O, L) => k(headersToObject(O), headersToObject(L), !0),
  };
  return (
    utils.forEach(Object.keys($).concat(Object.keys(r)), function (L) {
      const U = F[L] || k,
        N = U($[L], r[L], L);
      (utils.isUndefined(N) && U !== I) || (p[L] = N);
    }),
    p
  );
}
const VERSION = "1.3.2",
  validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(
  ($, r) => {
    validators$1[$] = function (v) {
      return typeof v === $ || "a" + (r < 1 ? "n " : " ") + $;
    };
  }
);
const deprecatedWarnings = {};
validators$1.transitional = function (r, p, v) {
  function k(x, S) {
    return (
      "[Axios v" +
      VERSION +
      "] Transitional option '" +
      x +
      "'" +
      S +
      (v ? ". " + v : "")
    );
  }
  return (x, S, I) => {
    if (r === !1)
      throw new AxiosError(
        k(S, " has been removed" + (p ? " in " + p : "")),
        AxiosError.ERR_DEPRECATED
      );
    return (
      p &&
        !deprecatedWarnings[S] &&
        ((deprecatedWarnings[S] = !0),
        console.warn(
          k(
            S,
            " has been deprecated since v" +
              p +
              " and will be removed in the near future"
          )
        )),
      r ? r(x, S, I) : !0
    );
  };
};
function assertOptions($, r, p) {
  if (typeof $ != "object")
    throw new AxiosError(
      "options must be an object",
      AxiosError.ERR_BAD_OPTION_VALUE
    );
  const v = Object.keys($);
  let k = v.length;
  for (; k-- > 0; ) {
    const x = v[k],
      S = r[x];
    if (S) {
      const I = $[x],
        F = I === void 0 || S(I, x, $);
      if (F !== !0)
        throw new AxiosError(
          "option " + x + " must be " + F,
          AxiosError.ERR_BAD_OPTION_VALUE
        );
      continue;
    }
    if (p !== !0)
      throw new AxiosError("Unknown option " + x, AxiosError.ERR_BAD_OPTION);
  }
}
const validator = { assertOptions, validators: validators$1 },
  validators = validator.validators;
class Axios {
  constructor(r) {
    (this.defaults = r),
      (this.interceptors = {
        request: new InterceptorManager$1(),
        response: new InterceptorManager$1(),
      });
  }
  request(r, p) {
    typeof r == "string" ? ((p = p || {}), (p.url = r)) : (p = r || {}),
      (p = mergeConfig(this.defaults, p));
    const { transitional: v, paramsSerializer: k, headers: x } = p;
    v !== void 0 &&
      validator.assertOptions(
        v,
        {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean),
        },
        !1
      ),
      k !== void 0 &&
        validator.assertOptions(
          k,
          { encode: validators.function, serialize: validators.function },
          !0
        ),
      (p.method = (p.method || this.defaults.method || "get").toLowerCase());
    let S;
    (S = x && utils.merge(x.common, x[p.method])),
      S &&
        utils.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (R) => {
            delete x[R];
          }
        ),
      (p.headers = AxiosHeaders$1.concat(S, x));
    const I = [];
    let F = !0;
    this.interceptors.request.forEach(function (q) {
      (typeof q.runWhen == "function" && q.runWhen(p) === !1) ||
        ((F = F && q.synchronous), I.unshift(q.fulfilled, q.rejected));
    });
    const O = [];
    this.interceptors.response.forEach(function (q) {
      O.push(q.fulfilled, q.rejected);
    });
    let L,
      U = 0,
      N;
    if (!F) {
      const R = [dispatchRequest.bind(this), void 0];
      for (
        R.unshift.apply(R, I),
          R.push.apply(R, O),
          N = R.length,
          L = Promise.resolve(p);
        U < N;

      )
        L = L.then(R[U++], R[U++]);
      return L;
    }
    N = I.length;
    let j = p;
    for (U = 0; U < N; ) {
      const R = I[U++],
        q = I[U++];
      try {
        j = R(j);
      } catch (Q) {
        q.call(this, Q);
        break;
      }
    }
    try {
      L = dispatchRequest.call(this, j);
    } catch (R) {
      return Promise.reject(R);
    }
    for (U = 0, N = O.length; U < N; ) L = L.then(O[U++], O[U++]);
    return L;
  }
  getUri(r) {
    r = mergeConfig(this.defaults, r);
    const p = buildFullPath(r.baseURL, r.url);
    return buildURL(p, r.params, r.paramsSerializer);
  }
}
utils.forEach(["delete", "get", "head", "options"], function (r) {
  Axios.prototype[r] = function (p, v) {
    return this.request(
      mergeConfig(v || {}, { method: r, url: p, data: (v || {}).data })
    );
  };
});
utils.forEach(["post", "put", "patch"], function (r) {
  function p(v) {
    return function (x, S, I) {
      return this.request(
        mergeConfig(I || {}, {
          method: r,
          headers: v ? { "Content-Type": "multipart/form-data" } : {},
          url: x,
          data: S,
        })
      );
    };
  }
  (Axios.prototype[r] = p()), (Axios.prototype[r + "Form"] = p(!0));
});
const Axios$1 = Axios;
class CancelToken {
  constructor(r) {
    if (typeof r != "function")
      throw new TypeError("executor must be a function.");
    let p;
    this.promise = new Promise(function (x) {
      p = x;
    });
    const v = this;
    this.promise.then((k) => {
      if (!v._listeners) return;
      let x = v._listeners.length;
      for (; x-- > 0; ) v._listeners[x](k);
      v._listeners = null;
    }),
      (this.promise.then = (k) => {
        let x;
        const S = new Promise((I) => {
          v.subscribe(I), (x = I);
        }).then(k);
        return (
          (S.cancel = function () {
            v.unsubscribe(x);
          }),
          S
        );
      }),
      r(function (x, S, I) {
        v.reason || ((v.reason = new CanceledError(x, S, I)), p(v.reason));
      });
  }
  throwIfRequested() {
    if (this.reason) throw this.reason;
  }
  subscribe(r) {
    if (this.reason) {
      r(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(r) : (this._listeners = [r]);
  }
  unsubscribe(r) {
    if (!this._listeners) return;
    const p = this._listeners.indexOf(r);
    p !== -1 && this._listeners.splice(p, 1);
  }
  static source() {
    let r;
    return {
      token: new CancelToken(function (k) {
        r = k;
      }),
      cancel: r,
    };
  }
}
const CancelToken$1 = CancelToken;
function spread($) {
  return function (p) {
    return $.apply(null, p);
  };
}
function isAxiosError($) {
  return utils.isObject($) && $.isAxiosError === !0;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};
Object.entries(HttpStatusCode).forEach(([$, r]) => {
  HttpStatusCode[r] = $;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance($) {
  const r = new Axios$1($),
    p = bind(Axios$1.prototype.request, r);
  return (
    utils.extend(p, Axios$1.prototype, r, { allOwnKeys: !0 }),
    utils.extend(p, r, null, { allOwnKeys: !0 }),
    (p.create = function (k) {
      return createInstance(mergeConfig($, k));
    }),
    p
  );
}
const axios = createInstance(defaults$2);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function (r) {
  return Promise.all(r);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = ($) =>
  formDataToJSON(utils.isHTMLForm($) ? new FormData($) : $);
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios,
  abortFileReader = writable(!1);
async function readFile($) {
  Log({
    source: "fs/file.ts: readFile",
    msg: `Requesting file contents of "${$}" from ArcAPI`,
    level: LogLevel.info,
  });
  const r = get_store_value(ConnectedServer);
  if (!r) return !1;
  const p = {
    headers: { Authorization: `Bearer ${get_store_value(UserToken)}` },
  };
  let v = new AbortController();
  const k = generateParamStr({ path: btoa($) });
  let x = await fetch(`${r}/fs/file/get${k}`, { ...p, signal: v.signal });
  if (
    (abortFileReader.set(!1),
    abortFileReader.subscribe((I) => {
      I &&
        (Log({
          source: "fs/file.ts: readFile",
          msg: `Aborting readFile for "${$}" as requested by the user...`,
          level: LogLevel.error,
        }),
        v.abort(),
        FileBrowserOpenCancelled.set(!0),
        abortFileReader.set(!1));
    }),
    x.status != 200)
  )
    return !1;
  const S = await x.blob();
  return (x = null), await S.arrayBuffer();
}
async function deleteItem($) {
  Log({
    source: "fs/file.ts: deleteItem",
    msg: `Deleting item "${$}" from ArcFS`,
    level: LogLevel.info,
  });
  const r = get_store_value(ConnectedServer);
  return r
    ? (
        await apiCall(
          r,
          "fs/rm",
          { path: btoa($) },
          get_store_value(UserToken),
          null,
          null,
          !0
        )
      ).valid != !1
    : !1;
}
async function writeFile($, r) {
  const p = get_store_value(ConnectedServer);
  if (!p) return !1;
  const v = generateParamStr({ path: btoa($) });
  return (
    (
      await axios$1.post(`${p}/fs/file/write${v}`, r, {
        headers: { Authorization: `Bearer ${get_store_value(UserToken)}` },
        onUploadProgress(x) {
          const S = (x.loaded / x.total) * 100;
          FileBrowserUploadProgress.set(S);
        },
      })
    ).status == 200
  );
}
function createOverlayableError($, r) {
  Log({
    source: "errorlogic/overlay.ts",
    msg: `Creating error "${$.title}" for parent ${r}`,
    level: LogLevel.info,
  });
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++) {
    const k = p[v];
    if (k.id == r)
      return (
        k.errorOverlays || (k.errorOverlays = []),
        k.errorOverlays.push({
          ...$,
          id: `${Math.floor(Math.random() * 1e9)}`,
        }),
        WindowStore.set(p),
        !0
      );
  }
  return !1;
}
function destroyOverlayableError($, r) {
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++) {
    const k = p[v];
    if (k.id != r || !k.errorOverlays) continue;
    const x = k.errorOverlays;
    for (let S = 0; S < x.length; S++)
      if (x[S].id == $) return x.splice(S, 1), WindowStore.set(p), !0;
  }
  return !1;
}
function showOverlay($, r) {
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++)
    if (p[v].id == r) {
      if (!p[v].overlays || !p[v].overlays[$]) return !1;
      p[v].overlays[$].show = !0;
    }
  WindowStore.set(p);
}
function hideOverlay($, r) {
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++)
    if (p[v].id == r) {
      if (!p[v].overlays || !p[v].overlays[$]) return !1;
      p[v].overlays[$].show = !1;
    }
  WindowStore.set(p);
}
const clear$1 = "./assets/clear-675017c3.svg";
let FileBrowserCurrentDir = writable("./"),
  FileBrowserDirContents = writable(defaultDirectory),
  FileBrowserSelectedFilename = writable(null),
  FileBrowserOpeningFile = writable(null),
  FileBrowserDeletingFilename = writable(null),
  FileBrowserUploadFile = writable(null),
  FileBrowserOpenCancelled = writable(!1),
  FileBrowserRefreshing = writable(!1),
  FileBrowserUploadProgress = writable(0),
  FileBrowserCuttingFilename = writable(null),
  FileBrowserCopyingFilename = writable(null);
FileBrowserOpenCancelled.subscribe(($) => {
  $ &&
    (createOverlayableError(
      {
        title: "Open cancelled",
        message: "The opening procedure was cancelled by the user.",
        buttons: [{ caption: "OK", action() {} }],
        image: warning,
      },
      "FileManager"
    ),
    FileBrowserOpenCancelled.set(!1));
});
class FileBrowserClass {
  async refresh(r = !0) {
    Log({
      source: "FileBrowser: refresh",
      msg: "Refreshing current directory contents",
      level: LogLevel.info,
    }),
      FileBrowserRefreshing.set(!0),
      r &&
        (FileBrowserDirContents.set(defaultDirectory),
        FileBrowserSelectedFilename.set(null));
    const p = get_store_value(FileBrowserCurrentDir),
      v = await getDirectory(p);
    FileBrowserDirContents.set(v || { ...defaultDirectory, scopedPath: p }),
      FileBrowserRefreshing.set(!1);
  }
  async goToDirectory(r) {
    Log({
      source: "FileBrowser: goToDirectory",
      msg: `Navigating to "${r}"`,
      level: LogLevel.info,
    }),
      FileBrowserSelectedFilename.set(null),
      FileBrowserCurrentDir.set(r),
      await this.refresh();
  }
  async deleteItem(r, p) {
    FileBrowserDeletingFilename.set(r),
      showOverlay("deletingItem", "FileManager"),
      (await deleteItem(p)) ||
        createOverlayableError(
          {
            title: "Unable to delete item",
            message:
              "ArcAPI was not able to delete the item from the file system. A permission error may have occured. Please try again later.",
            buttons: [{ caption: "OK", action() {} }],
            image: clear$1,
          },
          "FileManager"
        ),
      FileBrowserSelectedFilename.set(null),
      fbClass.refresh(),
      setTimeout(() => {
        hideOverlay("deletingItem", "FileManager");
      }, 100);
  }
}
const fbClass = new FileBrowserClass(),
  ActionCenterOpened = writable(!1);
function toggleActionCenter() {
  const $ = !get_store_value(ActionCenterOpened);
  ActionCenterOpened.set($);
}
const AppPokerData = writable(null),
  appShortcuts = [];
function registerAppShortcuts($, r) {
  if (
    (Log({
      source: "keyboard: registerAppShortcuts",
      msg: `Registering app shortcuts for ${$}`,
      level: LogLevel.info,
    }),
    !r.events || !r.events.keyboardShortcuts || isRegistered($))
  )
    return !1;
  appShortcuts.push([$, r.events.keyboardShortcuts]);
}
function registerShortcuts($, r) {
  appShortcuts.push([r || "", $]);
}
function isRegistered($) {
  for (let r = 0; r < appShortcuts.length; r++)
    if (appShortcuts[r][0] == $) return !0;
  return !1;
}
function isLoaded($) {
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++) if (r[p] && r[p].id == $) return !0;
  return !1;
}
function isOpened($) {
  const r = getWindow($);
  return r ? r.opened : !1;
}
function isMinimized($) {
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++)
    if (r[p] && r[p].id == $ && r[p].state.windowState.min) return !0;
  return !1;
}
function isDisabled($) {
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++)
    if (r[p] && r[p].id == $ && r[p].disabled) return !0;
  return !1;
}
function isPopulatable($) {
  return get_store_value(UserData).sh.showHiddenApps && !$.disabled
    ? !0
    : !$.disabled && !$.info.hidden && !$.info.custom;
}
const CurrentNotification = writable(null),
  NotificationStore = writable({});
let globalNotifTimeout;
function makeNotification($) {
  if (isDisabled("ArcShell")) {
    errorMessage(
      $.title,
      $.message,
      $.image,
      null,
      { caption: "OK", action() {} },
      ...$.buttons
    );
    return;
  }
  clearTimeout(globalNotifTimeout);
  const r = `${Math.floor(Math.random() * 1e9)}`,
    p = get_store_value(NotificationStore);
  return (
    (p[r] = $),
    NotificationStore.set(p),
    setTimeout(() => {
      CurrentNotification.set(r);
    }, 100),
    $.timeout &&
      (globalNotifTimeout = setTimeout(() => {
        CurrentNotification.set(null);
      }, $.timeout)),
    r
  );
}
function closeNotification() {
  CurrentNotification.set(null);
}
function deleteNotification($) {
  const r = get_store_value(NotificationStore);
  delete r[$], NotificationStore.set(r);
}
function isArray($) {
  return Array.isArray ? Array.isArray($) : getTag($) === "[object Array]";
}
const INFINITY = 1 / 0;
function baseToString($) {
  if (typeof $ == "string") return $;
  let r = $ + "";
  return r == "0" && 1 / $ == -INFINITY ? "-0" : r;
}
function toString($) {
  return $ == null ? "" : baseToString($);
}
function isString($) {
  return typeof $ == "string";
}
function isNumber($) {
  return typeof $ == "number";
}
function isBoolean($) {
  return (
    $ === !0 || $ === !1 || (isObjectLike($) && getTag($) == "[object Boolean]")
  );
}
function isObject($) {
  return typeof $ == "object";
}
function isObjectLike($) {
  return isObject($) && $ !== null;
}
function isDefined($) {
  return $ != null;
}
function isBlank($) {
  return !$.trim().length;
}
function getTag($) {
  return $ == null
    ? $ === void 0
      ? "[object Undefined]"
      : "[object Null]"
    : Object.prototype.toString.call($);
}
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available",
  INCORRECT_INDEX_TYPE = "Incorrect 'index' type",
  LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = ($) => `Invalid value for key ${$}`,
  PATTERN_LENGTH_TOO_LARGE = ($) => `Pattern length exceeds max of ${$}.`,
  MISSING_KEY_PROPERTY = ($) => `Missing ${$} property in key`,
  INVALID_KEY_WEIGHT_VALUE = ($) =>
    `Property 'weight' in key '${$}' must be a positive integer`,
  hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
  constructor(r) {
    (this._keys = []), (this._keyMap = {});
    let p = 0;
    r.forEach((v) => {
      let k = createKey(v);
      (p += k.weight),
        this._keys.push(k),
        (this._keyMap[k.id] = k),
        (p += k.weight);
    }),
      this._keys.forEach((v) => {
        v.weight /= p;
      });
  }
  get(r) {
    return this._keyMap[r];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey($) {
  let r = null,
    p = null,
    v = null,
    k = 1,
    x = null;
  if (isString($) || isArray($))
    (v = $), (r = createKeyPath($)), (p = createKeyId($));
  else {
    if (!hasOwn.call($, "name")) throw new Error(MISSING_KEY_PROPERTY("name"));
    const S = $.name;
    if (((v = S), hasOwn.call($, "weight") && ((k = $.weight), k <= 0)))
      throw new Error(INVALID_KEY_WEIGHT_VALUE(S));
    (r = createKeyPath(S)), (p = createKeyId(S)), (x = $.getFn);
  }
  return { path: r, id: p, weight: k, src: v, getFn: x };
}
function createKeyPath($) {
  return isArray($) ? $ : $.split(".");
}
function createKeyId($) {
  return isArray($) ? $.join(".") : $;
}
function get($, r) {
  let p = [],
    v = !1;
  const k = (x, S, I) => {
    if (isDefined(x))
      if (!S[I]) p.push(x);
      else {
        let F = S[I];
        const O = x[F];
        if (!isDefined(O)) return;
        if (I === S.length - 1 && (isString(O) || isNumber(O) || isBoolean(O)))
          p.push(toString(O));
        else if (isArray(O)) {
          v = !0;
          for (let L = 0, U = O.length; L < U; L += 1) k(O[L], S, I + 1);
        } else S.length && k(O, S, I + 1);
      }
  };
  return k($, isString(r) ? r.split(".") : r, 0), v ? p : p[0];
}
const MatchOptions = {
    includeMatches: !1,
    findAllMatches: !1,
    minMatchCharLength: 1,
  },
  BasicOptions = {
    isCaseSensitive: !1,
    includeScore: !1,
    keys: [],
    shouldSort: !0,
    sortFn: ($, r) =>
      $.score === r.score
        ? $.idx < r.idx
          ? -1
          : 1
        : $.score < r.score
        ? -1
        : 1,
  },
  FuzzyOptions = { location: 0, threshold: 0.6, distance: 100 },
  AdvancedOptions = {
    useExtendedSearch: !1,
    getFn: get,
    ignoreLocation: !1,
    ignoreFieldNorm: !1,
    fieldNormWeight: 1,
  };
var Config$1 = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions,
};
const SPACE = /[^ ]+/g;
function norm($ = 1, r = 3) {
  const p = new Map(),
    v = Math.pow(10, r);
  return {
    get(k) {
      const x = k.match(SPACE).length;
      if (p.has(x)) return p.get(x);
      const S = 1 / Math.pow(x, 0.5 * $),
        I = parseFloat(Math.round(S * v) / v);
      return p.set(x, I), I;
    },
    clear() {
      p.clear();
    },
  };
}
class FuseIndex {
  constructor({
    getFn: r = Config$1.getFn,
    fieldNormWeight: p = Config$1.fieldNormWeight,
  } = {}) {
    (this.norm = norm(p, 3)),
      (this.getFn = r),
      (this.isCreated = !1),
      this.setIndexRecords();
  }
  setSources(r = []) {
    this.docs = r;
  }
  setIndexRecords(r = []) {
    this.records = r;
  }
  setKeys(r = []) {
    (this.keys = r),
      (this._keysMap = {}),
      r.forEach((p, v) => {
        this._keysMap[p.id] = v;
      });
  }
  create() {
    this.isCreated ||
      !this.docs.length ||
      ((this.isCreated = !0),
      isString(this.docs[0])
        ? this.docs.forEach((r, p) => {
            this._addString(r, p);
          })
        : this.docs.forEach((r, p) => {
            this._addObject(r, p);
          }),
      this.norm.clear());
  }
  add(r) {
    const p = this.size();
    isString(r) ? this._addString(r, p) : this._addObject(r, p);
  }
  removeAt(r) {
    this.records.splice(r, 1);
    for (let p = r, v = this.size(); p < v; p += 1) this.records[p].i -= 1;
  }
  getValueForItemAtKeyId(r, p) {
    return r[this._keysMap[p]];
  }
  size() {
    return this.records.length;
  }
  _addString(r, p) {
    if (!isDefined(r) || isBlank(r)) return;
    let v = { v: r, i: p, n: this.norm.get(r) };
    this.records.push(v);
  }
  _addObject(r, p) {
    let v = { i: p, $: {} };
    this.keys.forEach((k, x) => {
      let S = k.getFn ? k.getFn(r) : this.getFn(r, k.path);
      if (isDefined(S)) {
        if (isArray(S)) {
          let I = [];
          const F = [{ nestedArrIndex: -1, value: S }];
          for (; F.length; ) {
            const { nestedArrIndex: O, value: L } = F.pop();
            if (isDefined(L))
              if (isString(L) && !isBlank(L)) {
                let U = { v: L, i: O, n: this.norm.get(L) };
                I.push(U);
              } else
                isArray(L) &&
                  L.forEach((U, N) => {
                    F.push({ nestedArrIndex: N, value: U });
                  });
          }
          v.$[x] = I;
        } else if (isString(S) && !isBlank(S)) {
          let I = { v: S, n: this.norm.get(S) };
          v.$[x] = I;
        }
      }
    }),
      this.records.push(v);
  }
  toJSON() {
    return { keys: this.keys, records: this.records };
  }
}
function createIndex(
  $,
  r,
  {
    getFn: p = Config$1.getFn,
    fieldNormWeight: v = Config$1.fieldNormWeight,
  } = {}
) {
  const k = new FuseIndex({ getFn: p, fieldNormWeight: v });
  return k.setKeys($.map(createKey)), k.setSources(r), k.create(), k;
}
function parseIndex(
  $,
  {
    getFn: r = Config$1.getFn,
    fieldNormWeight: p = Config$1.fieldNormWeight,
  } = {}
) {
  const { keys: v, records: k } = $,
    x = new FuseIndex({ getFn: r, fieldNormWeight: p });
  return x.setKeys(v), x.setIndexRecords(k), x;
}
function computeScore$1(
  $,
  {
    errors: r = 0,
    currentLocation: p = 0,
    expectedLocation: v = 0,
    distance: k = Config$1.distance,
    ignoreLocation: x = Config$1.ignoreLocation,
  } = {}
) {
  const S = r / $.length;
  if (x) return S;
  const I = Math.abs(v - p);
  return k ? S + I / k : I ? 1 : S;
}
function convertMaskToIndices($ = [], r = Config$1.minMatchCharLength) {
  let p = [],
    v = -1,
    k = -1,
    x = 0;
  for (let S = $.length; x < S; x += 1) {
    let I = $[x];
    I && v === -1
      ? (v = x)
      : !I &&
        v !== -1 &&
        ((k = x - 1), k - v + 1 >= r && p.push([v, k]), (v = -1));
  }
  return $[x - 1] && x - v >= r && p.push([v, x - 1]), p;
}
const MAX_BITS = 32;
function search(
  $,
  r,
  p,
  {
    location: v = Config$1.location,
    distance: k = Config$1.distance,
    threshold: x = Config$1.threshold,
    findAllMatches: S = Config$1.findAllMatches,
    minMatchCharLength: I = Config$1.minMatchCharLength,
    includeMatches: F = Config$1.includeMatches,
    ignoreLocation: O = Config$1.ignoreLocation,
  } = {}
) {
  if (r.length > MAX_BITS) throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  const L = r.length,
    U = $.length,
    N = Math.max(0, Math.min(v, U));
  let j = x,
    R = N;
  const q = I > 1 || F,
    Q = q ? Array(U) : [];
  let K;
  for (; (K = $.indexOf(r, R)) > -1; ) {
    let Z = computeScore$1(r, {
      currentLocation: K,
      expectedLocation: N,
      distance: k,
      ignoreLocation: O,
    });
    if (((j = Math.min(Z, j)), (R = K + L), q)) {
      let X = 0;
      for (; X < L; ) (Q[K + X] = 1), (X += 1);
    }
  }
  R = -1;
  let V = [],
    H = 1,
    G = L + U;
  const Y = 1 << (L - 1);
  for (let Z = 0; Z < L; Z += 1) {
    let X = 0,
      ee = G;
    for (; X < ee; )
      computeScore$1(r, {
        errors: Z,
        currentLocation: N + ee,
        expectedLocation: N,
        distance: k,
        ignoreLocation: O,
      }) <= j
        ? (X = ee)
        : (G = ee),
        (ee = Math.floor((G - X) / 2 + X));
    G = ee;
    let te = Math.max(1, N - ee + 1),
      ie = S ? U : Math.min(N + ee, U) + L,
      ue = Array(ie + 2);
    ue[ie + 1] = (1 << Z) - 1;
    for (let se = ie; se >= te; se -= 1) {
      let re = se - 1,
        le = p[$.charAt(re)];
      if (
        (q && (Q[re] = +!!le),
        (ue[se] = ((ue[se + 1] << 1) | 1) & le),
        Z && (ue[se] |= ((V[se + 1] | V[se]) << 1) | 1 | V[se + 1]),
        ue[se] & Y &&
          ((H = computeScore$1(r, {
            errors: Z,
            currentLocation: re,
            expectedLocation: N,
            distance: k,
            ignoreLocation: O,
          })),
          H <= j))
      ) {
        if (((j = H), (R = re), R <= N)) break;
        te = Math.max(1, 2 * N - R);
      }
    }
    if (
      computeScore$1(r, {
        errors: Z + 1,
        currentLocation: N,
        expectedLocation: N,
        distance: k,
        ignoreLocation: O,
      }) > j
    )
      break;
    V = ue;
  }
  const J = { isMatch: R >= 0, score: Math.max(0.001, H) };
  if (q) {
    const Z = convertMaskToIndices(Q, I);
    Z.length ? F && (J.indices = Z) : (J.isMatch = !1);
  }
  return J;
}
function createPatternAlphabet($) {
  let r = {};
  for (let p = 0, v = $.length; p < v; p += 1) {
    const k = $.charAt(p);
    r[k] = (r[k] || 0) | (1 << (v - p - 1));
  }
  return r;
}
class BitapSearch {
  constructor(
    r,
    {
      location: p = Config$1.location,
      threshold: v = Config$1.threshold,
      distance: k = Config$1.distance,
      includeMatches: x = Config$1.includeMatches,
      findAllMatches: S = Config$1.findAllMatches,
      minMatchCharLength: I = Config$1.minMatchCharLength,
      isCaseSensitive: F = Config$1.isCaseSensitive,
      ignoreLocation: O = Config$1.ignoreLocation,
    } = {}
  ) {
    if (
      ((this.options = {
        location: p,
        threshold: v,
        distance: k,
        includeMatches: x,
        findAllMatches: S,
        minMatchCharLength: I,
        isCaseSensitive: F,
        ignoreLocation: O,
      }),
      (this.pattern = F ? r : r.toLowerCase()),
      (this.chunks = []),
      !this.pattern.length)
    )
      return;
    const L = (N, j) => {
        this.chunks.push({
          pattern: N,
          alphabet: createPatternAlphabet(N),
          startIndex: j,
        });
      },
      U = this.pattern.length;
    if (U > MAX_BITS) {
      let N = 0;
      const j = U % MAX_BITS,
        R = U - j;
      for (; N < R; ) L(this.pattern.substr(N, MAX_BITS), N), (N += MAX_BITS);
      if (j) {
        const q = U - MAX_BITS;
        L(this.pattern.substr(q), q);
      }
    } else L(this.pattern, 0);
  }
  searchIn(r) {
    const { isCaseSensitive: p, includeMatches: v } = this.options;
    if ((p || (r = r.toLowerCase()), this.pattern === r)) {
      let R = { isMatch: !0, score: 0 };
      return v && (R.indices = [[0, r.length - 1]]), R;
    }
    const {
      location: k,
      distance: x,
      threshold: S,
      findAllMatches: I,
      minMatchCharLength: F,
      ignoreLocation: O,
    } = this.options;
    let L = [],
      U = 0,
      N = !1;
    this.chunks.forEach(({ pattern: R, alphabet: q, startIndex: Q }) => {
      const {
        isMatch: K,
        score: V,
        indices: H,
      } = search(r, R, q, {
        location: k + Q,
        distance: x,
        threshold: S,
        findAllMatches: I,
        minMatchCharLength: F,
        includeMatches: v,
        ignoreLocation: O,
      });
      K && (N = !0), (U += V), K && H && (L = [...L, ...H]);
    });
    let j = { isMatch: N, score: N ? U / this.chunks.length : 1 };
    return N && v && (j.indices = L), j;
  }
}
class BaseMatch {
  constructor(r) {
    this.pattern = r;
  }
  static isMultiMatch(r) {
    return getMatch(r, this.multiRegex);
  }
  static isSingleMatch(r) {
    return getMatch(r, this.singleRegex);
  }
  search() {}
}
function getMatch($, r) {
  const p = $.match(r);
  return p ? p[1] : null;
}
class ExactMatch extends BaseMatch {
  constructor(r) {
    super(r);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(r) {
    const p = r === this.pattern;
    return {
      isMatch: p,
      score: p ? 0 : 1,
      indices: [0, this.pattern.length - 1],
    };
  }
}
class InverseExactMatch extends BaseMatch {
  constructor(r) {
    super(r);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(r) {
    const v = r.indexOf(this.pattern) === -1;
    return { isMatch: v, score: v ? 0 : 1, indices: [0, r.length - 1] };
  }
}
class PrefixExactMatch extends BaseMatch {
  constructor(r) {
    super(r);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(r) {
    const p = r.startsWith(this.pattern);
    return {
      isMatch: p,
      score: p ? 0 : 1,
      indices: [0, this.pattern.length - 1],
    };
  }
}
class InversePrefixExactMatch extends BaseMatch {
  constructor(r) {
    super(r);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(r) {
    const p = !r.startsWith(this.pattern);
    return { isMatch: p, score: p ? 0 : 1, indices: [0, r.length - 1] };
  }
}
class SuffixExactMatch extends BaseMatch {
  constructor(r) {
    super(r);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(r) {
    const p = r.endsWith(this.pattern);
    return {
      isMatch: p,
      score: p ? 0 : 1,
      indices: [r.length - this.pattern.length, r.length - 1],
    };
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  constructor(r) {
    super(r);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(r) {
    const p = !r.endsWith(this.pattern);
    return { isMatch: p, score: p ? 0 : 1, indices: [0, r.length - 1] };
  }
}
class FuzzyMatch extends BaseMatch {
  constructor(
    r,
    {
      location: p = Config$1.location,
      threshold: v = Config$1.threshold,
      distance: k = Config$1.distance,
      includeMatches: x = Config$1.includeMatches,
      findAllMatches: S = Config$1.findAllMatches,
      minMatchCharLength: I = Config$1.minMatchCharLength,
      isCaseSensitive: F = Config$1.isCaseSensitive,
      ignoreLocation: O = Config$1.ignoreLocation,
    } = {}
  ) {
    super(r),
      (this._bitapSearch = new BitapSearch(r, {
        location: p,
        threshold: v,
        distance: k,
        includeMatches: x,
        findAllMatches: S,
        minMatchCharLength: I,
        isCaseSensitive: F,
        ignoreLocation: O,
      }));
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(r) {
    return this._bitapSearch.searchIn(r);
  }
}
class IncludeMatch extends BaseMatch {
  constructor(r) {
    super(r);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(r) {
    let p = 0,
      v;
    const k = [],
      x = this.pattern.length;
    for (; (v = r.indexOf(this.pattern, p)) > -1; )
      (p = v + x), k.push([v, p - 1]);
    const S = !!k.length;
    return { isMatch: S, score: S ? 0 : 1, indices: k };
  }
}
const searchers = [
    ExactMatch,
    IncludeMatch,
    PrefixExactMatch,
    InversePrefixExactMatch,
    InverseSuffixExactMatch,
    SuffixExactMatch,
    InverseExactMatch,
    FuzzyMatch,
  ],
  searchersLen = searchers.length,
  SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,
  OR_TOKEN = "|";
function parseQuery($, r = {}) {
  return $.split(OR_TOKEN).map((p) => {
    let v = p
        .trim()
        .split(SPACE_RE)
        .filter((x) => x && !!x.trim()),
      k = [];
    for (let x = 0, S = v.length; x < S; x += 1) {
      const I = v[x];
      let F = !1,
        O = -1;
      for (; !F && ++O < searchersLen; ) {
        const L = searchers[O];
        let U = L.isMultiMatch(I);
        U && (k.push(new L(U, r)), (F = !0));
      }
      if (!F)
        for (O = -1; ++O < searchersLen; ) {
          const L = searchers[O];
          let U = L.isSingleMatch(I);
          if (U) {
            k.push(new L(U, r));
            break;
          }
        }
    }
    return k;
  });
}
const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
  constructor(
    r,
    {
      isCaseSensitive: p = Config$1.isCaseSensitive,
      includeMatches: v = Config$1.includeMatches,
      minMatchCharLength: k = Config$1.minMatchCharLength,
      ignoreLocation: x = Config$1.ignoreLocation,
      findAllMatches: S = Config$1.findAllMatches,
      location: I = Config$1.location,
      threshold: F = Config$1.threshold,
      distance: O = Config$1.distance,
    } = {}
  ) {
    (this.query = null),
      (this.options = {
        isCaseSensitive: p,
        includeMatches: v,
        minMatchCharLength: k,
        findAllMatches: S,
        ignoreLocation: x,
        location: I,
        threshold: F,
        distance: O,
      }),
      (this.pattern = p ? r : r.toLowerCase()),
      (this.query = parseQuery(this.pattern, this.options));
  }
  static condition(r, p) {
    return p.useExtendedSearch;
  }
  searchIn(r) {
    const p = this.query;
    if (!p) return { isMatch: !1, score: 1 };
    const { includeMatches: v, isCaseSensitive: k } = this.options;
    r = k ? r : r.toLowerCase();
    let x = 0,
      S = [],
      I = 0;
    for (let F = 0, O = p.length; F < O; F += 1) {
      const L = p[F];
      (S.length = 0), (x = 0);
      for (let U = 0, N = L.length; U < N; U += 1) {
        const j = L[U],
          { isMatch: R, indices: q, score: Q } = j.search(r);
        if (R) {
          if (((x += 1), (I += Q), v)) {
            const K = j.constructor.type;
            MultiMatchSet.has(K) ? (S = [...S, ...q]) : S.push(q);
          }
        } else {
          (I = 0), (x = 0), (S.length = 0);
          break;
        }
      }
      if (x) {
        let U = { isMatch: !0, score: I / x };
        return v && (U.indices = S), U;
      }
    }
    return { isMatch: !1, score: 1 };
  }
}
const registeredSearchers = [];
function register(...$) {
  registeredSearchers.push(...$);
}
function createSearcher($, r) {
  for (let p = 0, v = registeredSearchers.length; p < v; p += 1) {
    let k = registeredSearchers[p];
    if (k.condition($, r)) return new k($, r);
  }
  return new BitapSearch($, r);
}
const LogicalOperator = { AND: "$and", OR: "$or" },
  KeyType = { PATH: "$path", PATTERN: "$val" },
  isExpression = ($) => !!($[LogicalOperator.AND] || $[LogicalOperator.OR]),
  isPath = ($) => !!$[KeyType.PATH],
  isLeaf = ($) => !isArray($) && isObject($) && !isExpression($),
  convertToExplicit = ($) => ({
    [LogicalOperator.AND]: Object.keys($).map((r) => ({ [r]: $[r] })),
  });
function parse($, r, { auto: p = !0 } = {}) {
  const v = (k) => {
    let x = Object.keys(k);
    const S = isPath(k);
    if (!S && x.length > 1 && !isExpression(k)) return v(convertToExplicit(k));
    if (isLeaf(k)) {
      const F = S ? k[KeyType.PATH] : x[0],
        O = S ? k[KeyType.PATTERN] : k[F];
      if (!isString(O))
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(F));
      const L = { keyId: createKeyId(F), pattern: O };
      return p && (L.searcher = createSearcher(O, r)), L;
    }
    let I = { children: [], operator: x[0] };
    return (
      x.forEach((F) => {
        const O = k[F];
        isArray(O) &&
          O.forEach((L) => {
            I.children.push(v(L));
          });
      }),
      I
    );
  };
  return isExpression($) || ($ = convertToExplicit($)), v($);
}
function computeScore($, { ignoreFieldNorm: r = Config$1.ignoreFieldNorm }) {
  $.forEach((p) => {
    let v = 1;
    p.matches.forEach(({ key: k, norm: x, score: S }) => {
      const I = k ? k.weight : null;
      v *= Math.pow(S === 0 && I ? Number.EPSILON : S, (I || 1) * (r ? 1 : x));
    }),
      (p.score = v);
  });
}
function transformMatches($, r) {
  const p = $.matches;
  (r.matches = []),
    isDefined(p) &&
      p.forEach((v) => {
        if (!isDefined(v.indices) || !v.indices.length) return;
        const { indices: k, value: x } = v;
        let S = { indices: k, value: x };
        v.key && (S.key = v.key.src),
          v.idx > -1 && (S.refIndex = v.idx),
          r.matches.push(S);
      });
}
function transformScore($, r) {
  r.score = $.score;
}
function format(
  $,
  r,
  {
    includeMatches: p = Config$1.includeMatches,
    includeScore: v = Config$1.includeScore,
  } = {}
) {
  const k = [];
  return (
    p && k.push(transformMatches),
    v && k.push(transformScore),
    $.map((x) => {
      const { idx: S } = x,
        I = { item: r[S], refIndex: S };
      return (
        k.length &&
          k.forEach((F) => {
            F(x, I);
          }),
        I
      );
    })
  );
}
class Fuse {
  constructor(r, p = {}, v) {
    (this.options = { ...Config$1, ...p }),
      this.options.useExtendedSearch,
      (this._keyStore = new KeyStore(this.options.keys)),
      this.setCollection(r, v);
  }
  setCollection(r, p) {
    if (((this._docs = r), p && !(p instanceof FuseIndex)))
      throw new Error(INCORRECT_INDEX_TYPE);
    this._myIndex =
      p ||
      createIndex(this.options.keys, this._docs, {
        getFn: this.options.getFn,
        fieldNormWeight: this.options.fieldNormWeight,
      });
  }
  add(r) {
    isDefined(r) && (this._docs.push(r), this._myIndex.add(r));
  }
  remove(r = () => !1) {
    const p = [];
    for (let v = 0, k = this._docs.length; v < k; v += 1) {
      const x = this._docs[v];
      r(x, v) && (this.removeAt(v), (v -= 1), (k -= 1), p.push(x));
    }
    return p;
  }
  removeAt(r) {
    this._docs.splice(r, 1), this._myIndex.removeAt(r);
  }
  getIndex() {
    return this._myIndex;
  }
  search(r, { limit: p = -1 } = {}) {
    const {
      includeMatches: v,
      includeScore: k,
      shouldSort: x,
      sortFn: S,
      ignoreFieldNorm: I,
    } = this.options;
    let F = isString(r)
      ? isString(this._docs[0])
        ? this._searchStringList(r)
        : this._searchObjectList(r)
      : this._searchLogical(r);
    return (
      computeScore(F, { ignoreFieldNorm: I }),
      x && F.sort(S),
      isNumber(p) && p > -1 && (F = F.slice(0, p)),
      format(F, this._docs, { includeMatches: v, includeScore: k })
    );
  }
  _searchStringList(r) {
    const p = createSearcher(r, this.options),
      { records: v } = this._myIndex,
      k = [];
    return (
      v.forEach(({ v: x, i: S, n: I }) => {
        if (!isDefined(x)) return;
        const { isMatch: F, score: O, indices: L } = p.searchIn(x);
        F &&
          k.push({
            item: x,
            idx: S,
            matches: [{ score: O, value: x, norm: I, indices: L }],
          });
      }),
      k
    );
  }
  _searchLogical(r) {
    const p = parse(r, this.options),
      v = (I, F, O) => {
        if (!I.children) {
          const { keyId: U, searcher: N } = I,
            j = this._findMatches({
              key: this._keyStore.get(U),
              value: this._myIndex.getValueForItemAtKeyId(F, U),
              searcher: N,
            });
          return j && j.length ? [{ idx: O, item: F, matches: j }] : [];
        }
        const L = [];
        for (let U = 0, N = I.children.length; U < N; U += 1) {
          const j = I.children[U],
            R = v(j, F, O);
          if (R.length) L.push(...R);
          else if (I.operator === LogicalOperator.AND) return [];
        }
        return L;
      },
      k = this._myIndex.records,
      x = {},
      S = [];
    return (
      k.forEach(({ $: I, i: F }) => {
        if (isDefined(I)) {
          let O = v(p, I, F);
          O.length &&
            (x[F] || ((x[F] = { idx: F, item: I, matches: [] }), S.push(x[F])),
            O.forEach(({ matches: L }) => {
              x[F].matches.push(...L);
            }));
        }
      }),
      S
    );
  }
  _searchObjectList(r) {
    const p = createSearcher(r, this.options),
      { keys: v, records: k } = this._myIndex,
      x = [];
    return (
      k.forEach(({ $: S, i: I }) => {
        if (!isDefined(S)) return;
        let F = [];
        v.forEach((O, L) => {
          F.push(...this._findMatches({ key: O, value: S[L], searcher: p }));
        }),
          F.length && x.push({ idx: I, item: S, matches: F });
      }),
      x
    );
  }
  _findMatches({ key: r, value: p, searcher: v }) {
    if (!isDefined(p)) return [];
    let k = [];
    if (isArray(p))
      p.forEach(({ v: x, i: S, n: I }) => {
        if (!isDefined(x)) return;
        const { isMatch: F, score: O, indices: L } = v.searchIn(x);
        F &&
          k.push({ score: O, key: r, value: x, idx: S, norm: I, indices: L });
      });
    else {
      const { v: x, n: S } = p,
        { isMatch: I, score: F, indices: O } = v.searchIn(x);
      I && k.push({ score: F, key: r, value: x, norm: S, indices: O });
    }
    return k;
  }
}
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config$1;
Fuse.parseQuery = parse;
register(ExtendedSearch);
const shutdownIcon = "./assets/exit-ccaa87b5.svg";
function compileSearchableApps() {
  const $ = [],
    r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++)
    isPopulatable(r[p]) &&
      $.push({
        caption: r[p].info.name,
        description: r[p].info.description,
        image: r[p].info.icon,
        action: () => {
          openWindow(r[p].id);
        },
      });
  return $;
}
const searchIcon = "./assets/arcfind-d60c3db2.svg",
  fileIcon = "./assets/text-plain-19145840.svg",
  appSettings = "./assets/apps-5c65dab6.svg",
  openwith = "",
  apLoaderIcon = "./assets/apploader-cf8168a8.svg",
  pdfOpenerIcon = "./assets/pdfopener-7ec41537.svg",
  openInNewIcon = "./assets/openinnew-33fae09f.svg",
  themeIcon = "./assets/personalization-61b4520f.svg",
  logo$c = "./assets/apppoker-d7ed29fe.svg";
function loadExternalApp($) {
  const r = document.createElement("style"),
    p = document.createElement("script"),
    v = document.createElement("div");
  (v.id = `SIDELOAD_${Math.floor(Math.random() * 1e4 * Math.PI)}`),
    (p.id = `hotLoaderJS_${$.id}`),
    (r.id = `hotLoaderCSS_${$.id}`),
    (r.textContent = $.css),
    (p.textContent = $.js.replace(".$$.root", "")),
    !(
      !$.meta ||
      !$.meta.author ||
      !$.meta.name ||
      !$.meta.version ||
      $.meta.version.split(".")[0] == "0"
    ) && (v.append(p, r), document.body.append(v));
}
function loadAppFile($) {
  const r = String.fromCharCode.apply(null, new Uint8Array($.data));
  let p;
  try {
    p = JSON.parse(r);
  } catch {
    return (
      errorMessage(
        "Unable to load app from file",
        "The imported file could not be parsed as a valid JSON object.",
        null,
        null,
        { caption: "OK", action() {} }
      ),
      !1
    );
  }
  if (isLoaded(p.id))
    return makeNotification({
      title: "Can't import app",
      message:
        "Another app with the same ID is already loaded. It is not possible to load apps with the same ID.",
      buttons: [],
      timeout: 3e3,
      image: apLoaderIcon,
    });
  const v = get_store_value(UserData),
    k = v.askPresist,
    x = v.autoLoads && v.autoLoads.includes($.path);
  return (
    k &&
      !x &&
      makeNotification({
        title: "Always import?",
        message: `Do you want to import application file "${$.name}" every time you log in?`,
        buttons: [
          {
            caption: "Yes",
            action() {
              const S = get_store_value(UserData);
              S.autoLoads || (S.autoLoads = []),
                S.autoLoads.push($.path),
                UserData.set(S);
            },
          },
          {
            caption: "Don't show again",
            action() {
              const S = get_store_value(UserData);
              (S.askPresist = !1), UserData.set(S);
            },
          },
        ],
        image: apLoaderIcon,
      }),
    loadExternalApp(p),
    !0
  );
}
const values = [
  "anim",
  "noGlass",
  "sharp",
  "theme",
  "wallpaper",
  "accent",
  "docked",
  "taskbarCentered",
  "taskbarLabels",
  "taskbarPosition",
  "taskbarColored",
  "smallStart",
  "titleButtons",
  "titlebarLarge",
  "titlebarLeft",
];
function loadTheme($) {
  const r = get_store_value(UserData);
  (r.sh.anim = $.anim),
    (r.sh.noGlass = $.noGlass),
    (r.sh.desktop.sharp = $.sharp),
    (r.sh.desktop.theme = $.theme),
    (r.sh.desktop.wallpaper = $.wallpaper),
    (r.sh.desktop.accent = $.accent),
    (r.sh.taskbar.docked = $.docked),
    (r.sh.taskbar.centered = $.taskbarCentered),
    (r.sh.taskbar.labels = $.taskbarLabels),
    (r.sh.taskbar.pos = $.taskbarPosition),
    (r.sh.start.small = $.smallStart),
    (r.sh.window.buttons = $.titleButtons),
    (r.sh.window.bigtb = $.titlebarLarge),
    (r.sh.window.lefttb = $.titlebarLeft),
    (r.sh.taskbar.colored = $.taskbarColored),
    (r.sh.window.centertb = !!$.titlebarCentered),
    (r.sh.taskbar.isLauncher = !!$.isLauncher),
    UserData.set(r);
}
function saveCurrentTheme($) {
  const r = `${Math.floor(Math.random() * 1e6)}`,
    p = get_store_value(UserData),
    v = {
      version: "1.0.0",
      name: $,
      author: get_store_value(UserName),
      anim: p.sh.anim,
      noGlass: p.sh.noGlass,
      sharp: p.sh.desktop.sharp,
      theme: p.sh.desktop.theme,
      wallpaper: p.sh.desktop.wallpaper,
      accent: p.sh.desktop.accent,
      docked: p.sh.taskbar.docked,
      taskbarCentered: p.sh.taskbar.centered,
      taskbarLabels: p.sh.taskbar.labels,
      taskbarPosition: p.sh.taskbar.pos,
      smallStart: p.sh.start.small,
      titleButtons: p.sh.window.buttons,
      titlebarLarge: p.sh.window.bigtb,
      titlebarLeft: p.sh.window.lefttb,
      taskbarColored: p.sh.taskbar.colored,
      titlebarCentered: p.sh.taskbar.centered,
      isLauncher: p.sh.taskbar.isLauncher,
    };
  p.sh.userThemes || (p.sh.userThemes = {}),
    (p.sh.userThemes[r] = v),
    UserData.set(p);
}
function deleteCustomTheme($) {
  const r = get_store_value(UserData);
  return !r.sh.userThemes || !r.sh.userThemes[$]
    ? !1
    : (delete r.sh.userThemes[$], UserData.set(r), !0);
}
function verifyTheme($) {
  const r = Object.keys($);
  for (let p = 0; p < values.length; p++) if (!r.includes(values[p])) return !1;
  return !0;
}
const FileLoaders = {
  appLoader: {
    name: "Application Import",
    description: "Load a third-party application",
    icon: apLoaderIcon,
    loader: loadAppFile,
    extensions: [".app", ".ealc", ".app.json"],
  },
  pdfOpener: {
    name: "Open In New Tab",
    description: "Open a PDF file in a new browser tab",
    icon: pdfOpenerIcon,
    loader: ($) => {
      const r = new Blob([new Uint8Array($.data)], { type: "application/pdf" });
      window.open(URL.createObjectURL(r), "_blank");
    },
    extensions: [".pdf"],
  },
  loadTheme: {
    name: "Load theme file",
    description: "Apply theme file to ArcOS",
    loader: ($) => {
      const r = String.fromCharCode.apply(null, new Uint8Array($.data));
      let p;
      try {
        p = JSON.parse(r);
      } catch {
        p = !1;
      }
      if (!p || !verifyTheme(p))
        return errorMessage(
          "Unable to load theme",
          "The theme file is invalid, or it could not be parsed. Please make sure you are trying to load a theme, and then try again.",
          themeIcon,
          null,
          { caption: "OK", action() {} }
        );
      loadTheme(p);
    },
    icon: themeIcon,
    extensions: [".arctheme"],
  },
  editFile: {
    name: "Edit config file",
    description: "Open file in Text Editor",
    icon: logo$c,
    loader($) {
      openWith("TextEditor", $, !0);
    },
    extensions: [".conf"],
  },
  openInNew: {
    name: "Download",
    description: "Open file in a new tab to download it",
    loader: ($) => {
      const r = new Blob([new Uint8Array($.data)], {
        type: $.mime.split(";")[0],
      });
      window.open(URL.createObjectURL(r), "_blank");
    },
    icon: openInNewIcon,
    extensions: [],
  },
};
function create_fragment$44($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O = $[1].name + "",
    L,
    U,
    N,
    j = $[1].description + "",
    R,
    q,
    Q;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (I = element("div")),
        (F = element("div")),
        (L = text(O)),
        (U = space()),
        (N = element("div")),
        (R = text(j)),
        src_url_equal(v.src, (k = $[1].icon)) || attr(v, "src", k),
        attr(v, "alt", (x = $[1].name)),
        attr(p, "class", "icon"),
        attr(F, "class", "name"),
        attr(N, "class", "description"),
        attr(r, "class", "option loader"),
        toggle_class(r, "selected", $[0] == $[1].name);
    },
    m(K, V) {
      insert(K, r, V),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, I),
        append(I, F),
        append(F, L),
        append(I, U),
        append(I, N),
        append(N, R),
        q ||
          ((Q = [listen(r, "click", $[2]), listen(r, "dblclick", $[3])]),
          (q = !0));
    },
    p(K, [V]) {
      V & 2 && !src_url_equal(v.src, (k = K[1].icon)) && attr(v, "src", k),
        V & 2 && x !== (x = K[1].name) && attr(v, "alt", x),
        V & 2 && O !== (O = K[1].name + "") && set_data(L, O),
        V & 2 && j !== (j = K[1].description + "") && set_data(R, j),
        V & 3 && toggle_class(r, "selected", K[0] == K[1].name);
    },
    i: noop$1,
    o: noop$1,
    d(K) {
      K && detach(r), (q = !1), run_all(Q);
    },
  };
}
function instance$3L($, r, p) {
  let { loader: v } = r,
    { file: k } = r,
    { selected: x = "" } = r,
    { loaderOptions: S } = r,
    { options: I } = r;
  function F() {
    p(0, (x = v.name));
  }
  function O() {
    v.loader(k),
      setTimeout(() => {
        OpenWithFile.set(null);
      }, 1e3),
      closeWindow("OpenWithApp"),
      p(4, (S = [])),
      p(5, (I = []));
  }
  return (
    ($.$$set = (L) => {
      "loader" in L && p(1, (v = L.loader)),
        "file" in L && p(6, (k = L.file)),
        "selected" in L && p(0, (x = L.selected)),
        "loaderOptions" in L && p(4, (S = L.loaderOptions)),
        "options" in L && p(5, (I = L.options));
    }),
    [x, v, F, O, S, I, k]
  );
}
class LoaderOption extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3L, create_fragment$44, safe_not_equal, {
        loader: 1,
        file: 6,
        selected: 0,
        loaderOptions: 4,
        options: 5,
      });
  }
}
function create_fragment$43($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O = $[1].info.name + "",
    L,
    U,
    N,
    j = $[1].info.description + "",
    R,
    q,
    Q,
    K = $[1].id + "",
    V,
    H,
    G;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (I = element("div")),
        (F = element("div")),
        (L = text(O)),
        (U = space()),
        (N = element("div")),
        (R = text(j)),
        (q = space()),
        (Q = element("div")),
        (V = text(K)),
        src_url_equal(v.src, (k = $[1].info.icon)) || attr(v, "src", k),
        attr(v, "alt", (x = $[1].info.name)),
        attr(p, "class", "icon"),
        attr(F, "class", "name"),
        attr(N, "class", "description"),
        attr(Q, "class", "id"),
        attr(r, "class", "option"),
        toggle_class(r, "selected", $[0] == $[1].id);
    },
    m(Y, J) {
      insert(Y, r, J),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, I),
        append(I, F),
        append(F, L),
        append(I, U),
        append(I, N),
        append(N, R),
        append(r, q),
        append(r, Q),
        append(Q, V),
        H ||
          ((G = [listen(r, "click", $[2]), listen(r, "dblclick", $[3])]),
          (H = !0));
    },
    p(Y, [J]) {
      J & 2 && !src_url_equal(v.src, (k = Y[1].info.icon)) && attr(v, "src", k),
        J & 2 && x !== (x = Y[1].info.name) && attr(v, "alt", x),
        J & 2 && O !== (O = Y[1].info.name + "") && set_data(L, O),
        J & 2 && j !== (j = Y[1].info.description + "") && set_data(R, j),
        J & 2 && K !== (K = Y[1].id + "") && set_data(V, K),
        J & 3 && toggle_class(r, "selected", Y[0] == Y[1].id);
    },
    i: noop$1,
    o: noop$1,
    d(Y) {
      Y && detach(r), (H = !1), run_all(G);
    },
  };
}
function instance$3K($, r, p) {
  let { app: v } = r,
    { file: k } = r,
    { selected: x = "" } = r,
    { loaderOptions: S } = r,
    { options: I } = r;
  function F() {
    p(0, (x = v.id));
  }
  function O() {
    openWith(v.id, k, k.anymime),
      setTimeout(() => {
        OpenWithFile.set(null);
      }, 1e3),
      closeWindow("OpenWithApp"),
      p(4, (S = [])),
      p(5, (I = []));
  }
  return (
    ($.$$set = (L) => {
      "app" in L && p(1, (v = L.app)),
        "file" in L && p(6, (k = L.file)),
        "selected" in L && p(0, (x = L.selected)),
        "loaderOptions" in L && p(4, (S = L.loaderOptions)),
        "options" in L && p(5, (I = L.options));
    }),
    [x, v, F, O, S, I, k]
  );
}
class Option extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3K, create_fragment$43, safe_not_equal, {
        app: 1,
        file: 6,
        selected: 0,
        loaderOptions: 4,
        options: 5,
      });
  }
}
function get_each_context$T($, r, p) {
  const v = $.slice();
  return (v[13] = r[p]), v;
}
function get_each_context_1$c($, r, p) {
  const v = $.slice();
  return (v[16] = r[p]), v;
}
function create_each_block_1$c($) {
  let r, p, v, k, x;
  function S(L) {
    $[7](L);
  }
  function I(L) {
    $[8](L);
  }
  function F(L) {
    $[9](L);
  }
  let O = { file: $[4], app: $[16] };
  return (
    $[1] !== void 0 && (O.loaderOptions = $[1]),
    $[0] !== void 0 && (O.options = $[0]),
    $[2] !== void 0 && (O.selected = $[2]),
    (r = new Option({ props: O })),
    binding_callbacks.push(() => bind$1(r, "loaderOptions", S)),
    binding_callbacks.push(() => bind$1(r, "options", I)),
    binding_callbacks.push(() => bind$1(r, "selected", F)),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(L, U) {
        mount_component(r, L, U), (x = !0);
      },
      p(L, U) {
        const N = {};
        U & 16 && (N.file = L[4]),
          U & 1 && (N.app = L[16]),
          !p &&
            U & 2 &&
            ((p = !0),
            (N.loaderOptions = L[1]),
            add_flush_callback(() => (p = !1))),
          !v &&
            U & 1 &&
            ((v = !0), (N.options = L[0]), add_flush_callback(() => (v = !1))),
          !k &&
            U & 4 &&
            ((k = !0), (N.selected = L[2]), add_flush_callback(() => (k = !1))),
          r.$set(N);
      },
      i(L) {
        x || (transition_in(r.$$.fragment, L), (x = !0));
      },
      o(L) {
        transition_out(r.$$.fragment, L), (x = !1);
      },
      d(L) {
        destroy_component(r, L);
      },
    }
  );
}
function create_if_block_1$v($) {
  let r;
  return {
    c() {
      (r = element("p")),
        (r.textContent = "No apps found"),
        attr(r, "class", "noitems");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_each_block$T($) {
  let r, p, v, k, x;
  function S(L) {
    $[10](L);
  }
  function I(L) {
    $[11](L);
  }
  function F(L) {
    $[12](L);
  }
  let O = { loader: $[13], file: $[4] };
  return (
    $[1] !== void 0 && (O.loaderOptions = $[1]),
    $[0] !== void 0 && (O.options = $[0]),
    $[2] !== void 0 && (O.selected = $[2]),
    (r = new LoaderOption({ props: O })),
    binding_callbacks.push(() => bind$1(r, "loaderOptions", S)),
    binding_callbacks.push(() => bind$1(r, "options", I)),
    binding_callbacks.push(() => bind$1(r, "selected", F)),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(L, U) {
        mount_component(r, L, U), (x = !0);
      },
      p(L, U) {
        const N = {};
        U & 2 && (N.loader = L[13]),
          U & 16 && (N.file = L[4]),
          !p &&
            U & 2 &&
            ((p = !0),
            (N.loaderOptions = L[1]),
            add_flush_callback(() => (p = !1))),
          !v &&
            U & 1 &&
            ((v = !0), (N.options = L[0]), add_flush_callback(() => (v = !1))),
          !k &&
            U & 4 &&
            ((k = !0), (N.selected = L[2]), add_flush_callback(() => (k = !1))),
          r.$set(N);
      },
      i(L) {
        x || (transition_in(r.$$.fragment, L), (x = !0));
      },
      o(L) {
        transition_out(r.$$.fragment, L), (x = !1);
      },
      d(L) {
        destroy_component(r, L);
      },
    }
  );
}
function create_if_block$1y($) {
  let r;
  return {
    c() {
      (r = element("p")),
        (r.textContent = "No handlers found"),
        attr(r, "class", "noitems");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$42($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U,
    N,
    j,
    R,
    q,
    Q,
    K,
    V,
    H,
    G,
    Y,
    J,
    Z,
    X = $[0],
    ee = [];
  for (let le = 0; le < X.length; le += 1)
    ee[le] = create_each_block_1$c(get_each_context_1$c($, X, le));
  const te = (le) =>
    transition_out(ee[le], 1, 1, () => {
      ee[le] = null;
    });
  let ie = !$[0].length && create_if_block_1$v(),
    ue = $[1],
    oe = [];
  for (let le = 0; le < ue.length; le += 1)
    oe[le] = create_each_block$T(get_each_context$T($, ue, le));
  const se = (le) =>
    transition_out(oe[le], 1, 1, () => {
      oe[le] = null;
    });
  let re = !$[1].length && create_if_block$1y();
  return {
    c() {
      (r = element("div")),
        (p = element("p")),
        (v = text("Select an item to open ")),
        (k = text($[3])),
        (x = space()),
        (S = element("div")),
        (I = element("p")),
        (I.textContent = "Apps"),
        (F = space());
      for (let le = 0; le < ee.length; le += 1) ee[le].c();
      (O = space()),
        ie && ie.c(),
        (L = space()),
        (U = element("p")),
        (U.textContent = "Handlers"),
        (N = space());
      for (let le = 0; le < oe.length; le += 1) oe[le].c();
      (j = space()),
        re && re.c(),
        (R = space()),
        (q = element("div")),
        (Q = element("button")),
        (K = text("Open")),
        (H = space()),
        (G = element("button")),
        (G.textContent = "Cancel"),
        attr(p, "class", "title"),
        attr(I, "class", "category"),
        attr(U, "class", "category"),
        attr(S, "class", "options"),
        (Q.disabled = V = !$[2]),
        attr(q, "class", "actions"),
        attr(r, "class", "content");
    },
    m(le, ae) {
      insert(le, r, ae),
        append(r, p),
        append(p, v),
        append(p, k),
        append(r, x),
        append(r, S),
        append(S, I),
        append(S, F);
      for (let ne = 0; ne < ee.length; ne += 1) ee[ne] && ee[ne].m(S, null);
      append(S, O),
        ie && ie.m(S, null),
        append(S, L),
        append(S, U),
        append(S, N);
      for (let ne = 0; ne < oe.length; ne += 1) oe[ne] && oe[ne].m(S, null);
      append(S, j),
        re && re.m(S, null),
        append(r, R),
        append(r, q),
        append(q, Q),
        append(Q, K),
        append(q, H),
        append(q, G),
        (Y = !0),
        J ||
          ((Z = [listen(Q, "click", $[5]), listen(G, "click", $[6])]),
          (J = !0));
    },
    p(le, [ae]) {
      if (((!Y || ae & 8) && set_data(k, le[3]), ae & 23)) {
        X = le[0];
        let ne;
        for (ne = 0; ne < X.length; ne += 1) {
          const ce = get_each_context_1$c(le, X, ne);
          ee[ne]
            ? (ee[ne].p(ce, ae), transition_in(ee[ne], 1))
            : ((ee[ne] = create_each_block_1$c(ce)),
              ee[ne].c(),
              transition_in(ee[ne], 1),
              ee[ne].m(S, O));
        }
        for (group_outros(), ne = X.length; ne < ee.length; ne += 1) te(ne);
        check_outros();
      }
      if (
        (le[0].length
          ? ie && (ie.d(1), (ie = null))
          : ie || ((ie = create_if_block_1$v()), ie.c(), ie.m(S, L)),
        ae & 23)
      ) {
        ue = le[1];
        let ne;
        for (ne = 0; ne < ue.length; ne += 1) {
          const ce = get_each_context$T(le, ue, ne);
          oe[ne]
            ? (oe[ne].p(ce, ae), transition_in(oe[ne], 1))
            : ((oe[ne] = create_each_block$T(ce)),
              oe[ne].c(),
              transition_in(oe[ne], 1),
              oe[ne].m(S, j));
        }
        for (group_outros(), ne = ue.length; ne < oe.length; ne += 1) se(ne);
        check_outros();
      }
      le[1].length
        ? re && (re.d(1), (re = null))
        : re || ((re = create_if_block$1y()), re.c(), re.m(S, null)),
        (!Y || (ae & 4 && V !== (V = !le[2]))) && (Q.disabled = V);
    },
    i(le) {
      if (!Y) {
        for (let ae = 0; ae < X.length; ae += 1) transition_in(ee[ae]);
        for (let ae = 0; ae < ue.length; ae += 1) transition_in(oe[ae]);
        Y = !0;
      }
    },
    o(le) {
      ee = ee.filter(Boolean);
      for (let ae = 0; ae < ee.length; ae += 1) transition_out(ee[ae]);
      oe = oe.filter(Boolean);
      for (let ae = 0; ae < oe.length; ae += 1) transition_out(oe[ae]);
      Y = !1;
    },
    d(le) {
      le && detach(r),
        destroy_each(ee, le),
        ie && ie.d(),
        destroy_each(oe, le),
        re && re.d(),
        (J = !1),
        run_all(Z);
    },
  };
}
function instance$3J($, r, p) {
  let v;
  component_subscribe($, OpenWithFile, (Q) => p(4, (v = Q)));
  let k = [],
    x = [],
    S = "",
    I = "";
  OpenWithFile.subscribe((Q) => {
    if (!Q) return p(3, (I = "file"));
    p(3, (I = Q.name)), p(0, (k = [])), p(1, (x = []));
    let K = [];
    Q.anymime ? (K = getAllFileHandlers()) : (K = findAppToOpen(Q.mime));
    for (let H = 0; H < K.length; H++) k.push(getWindow(K[H]));
    p(2, (S = ""));
    const V = Object.entries(FileLoaders);
    for (let H = 0; H < V.length; H++) {
      const Y = V[H][1];
      for (let J = 0; J < Y.extensions.length; J++)
        I.endsWith(Y.extensions[J]) && x.push(Y);
      Y.extensions.length || x.push(Y);
    }
  });
  function F() {
    const Q = getWindow(S);
    if (Q) openWith(Q.id, v, v.anymime);
    else
      for (let K = 0; K < x.length; K++)
        x[K].name == S && x[K].loader(v),
          set_store_value(OpenWithFile, (v = null), v);
    setTimeout(() => {
      OpenWithFile.set(null);
    }, 1e3),
      O();
  }
  function O() {
    isFullscreenWindow.set(!1), closeWindow("OpenWithApp");
  }
  function L(Q) {
    (x = Q), p(1, x);
  }
  function U(Q) {
    (k = Q), p(0, k);
  }
  function N(Q) {
    (S = Q), p(2, S);
  }
  function j(Q) {
    (x = Q), p(1, x);
  }
  function R(Q) {
    (k = Q), p(0, k);
  }
  function q(Q) {
    (S = Q), p(2, S);
  }
  return [k, x, S, I, v, F, O, L, U, N, j, R, q];
}
class OpenWith extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3J, create_fragment$42, safe_not_equal, {});
  }
}
const OpenWithApp = {
    info: {
      name: "Open With",
      description: "Open a file with an app",
      builtin: !0,
      version: "1.0.0",
      author: "Izaak Kuipers",
      hidden: !0,
      icon: appSettings,
    },
    size: { w: 450, h: 550 },
    pos: { x: 30, y: 40 },
    minSize: { w: 450, h: 550 },
    maxSize: { w: 450, h: 550 },
    controls: { min: !1, max: !1, cls: !1 },
    state: {
      headless: !0,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !0 },
    },
    content: OpenWith,
    glass: !0,
    events: {
      close() {
        OpenWithFile.set(null);
      },
    },
  },
  OpenWithFile = writable(null),
  logo$b = "./assets/testapp-fd93573e.svg",
  AppInfo$3 = "",
  def = "./assets/unknown-41ebe866.svg";
function hotSwapAppIcon($, r) {
  Log({
    msg: `Changing app icon for ${r} to ${$}`,
    source: "icon.ts: hotSwapAppIcon",
    level: LogLevel.info,
  });
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++)
    p[v].id == r &&
      (Originals$1[r] || (Originals$1[r] = `${getAppIcon(p[v])}`),
      (p[v].info.icon = $));
  WindowStore.set(p);
}
function getOriginalIcon($) {
  return Originals$1[$];
}
function getAppIcon($) {
  return $.info.builtin ? $.info.icon : def;
}
const Originals$1 = {};
function create_if_block$1x($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O = $[0].info.name + "",
    L,
    U,
    N,
    j = $[0].info.description + "",
    R,
    q,
    Q,
    K,
    V,
    H,
    G,
    Y,
    J,
    Z,
    X,
    ee,
    te = ($[0].size.w || d) + "",
    ie,
    ue,
    oe = ($[0].size.h || d) + "",
    se,
    re,
    le,
    ae,
    ne,
    ce,
    de = ($[0].minSize.w || d) + "",
    fe,
    pe,
    _e = ($[0].minSize.h || d) + "",
    ge,
    Ae,
    $e,
    ke,
    ve,
    be,
    ye = ($[0].maxSize.w || d) + "",
    Ce,
    Te,
    Ue = ($[0].maxSize.h || d) + "",
    Ge,
    nt,
    it,
    at,
    Ie,
    Ye,
    ot,
    De,
    Ne = ($[0].pos.x || d) + "",
    Ze,
    st,
    je = ($[0].pos.y || d) + "",
    Je,
    rt,
    Ee,
    Xe,
    lt,
    Re,
    Se,
    Fe,
    ct,
    We,
    ut,
    Oe,
    pt,
    qe,
    ft,
    Le,
    dt,
    Qe,
    mt,
    Be,
    et,
    _t,
    Me,
    ze,
    gt,
    He,
    ht,
    Pe,
    bt,
    Ke,
    tt,
    At;
  function vt(he, we) {
    return he[0].parentId ? create_if_block_1$u : create_else_block$w;
  }
  let Ve = vt($),
    xe = Ve($);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (I = element("div")),
        (F = element("p")),
        (L = text(O)),
        (U = space()),
        (N = element("p")),
        (R = text(j)),
        (q = space()),
        xe.c(),
        (Q = space()),
        (K = element("div")),
        (V = element("input")),
        (G = space()),
        (Y = element("div")),
        (J = element("div")),
        (Z = element("div")),
        (Z.textContent = "Size:"),
        (X = space()),
        (ee = element("div")),
        (ie = text(te)),
        (ue = text("x")),
        (se = text(oe)),
        (re = space()),
        (le = element("div")),
        (ae = element("div")),
        (ae.textContent = "Minimal size:"),
        (ne = space()),
        (ce = element("div")),
        (fe = text(de)),
        (pe = text("x")),
        (ge = text(_e)),
        (Ae = space()),
        ($e = element("div")),
        (ke = element("div")),
        (ke.textContent = "Maximal size:"),
        (ve = space()),
        (be = element("div")),
        (Ce = text(ye)),
        (Te = text("x")),
        (Ge = text(Ue)),
        (nt = space()),
        (it = element("hr")),
        (at = space()),
        (Ie = element("div")),
        (Ye = element("div")),
        (Ye.textContent = "Start position:"),
        (ot = space()),
        (De = element("div")),
        (Ze = text(Ne)),
        (st = text("x")),
        (Je = text(je)),
        (rt = space()),
        (Ee = element("div")),
        (Xe = element("div")),
        (Xe.textContent = "Window controls:"),
        (lt = space()),
        (Re = element("div")),
        (Se = element("div")),
        (Fe = element("button")),
        (ct = text("minimize")),
        (ut = space()),
        (Oe = element("button")),
        (pt = text("crop_square")),
        (ft = space()),
        (Le = element("button")),
        (dt = text("close")),
        (mt = space()),
        (Be = element("div")),
        (et = element("div")),
        (et.textContent = "Actions"),
        (_t = space()),
        (Me = element("div")),
        (ze = element("button")),
        (gt = text("Open")),
        (ht = space()),
        (Pe = element("button")),
        (bt = text("Poke")),
        src_url_equal(v.src, (k = getAppIcon($[0]))) || attr(v, "src", k),
        attr(v, "alt", (x = $[0].info.name)),
        attr(F, "class", "appname"),
        attr(N, "class", "description"),
        attr(V, "type", "checkbox"),
        attr(V, "class", "switch"),
        (V.disabled = H = SystemApps.includes($[3])),
        attr(K, "class", "actions"),
        attr(r, "class", "name"),
        attr(ee, "class", "value"),
        attr(J, "class", "property"),
        attr(ce, "class", "value"),
        attr(le, "class", "property"),
        attr(be, "class", "value"),
        attr($e, "class", "property"),
        attr(De, "class", "value"),
        attr(Ie, "class", "property"),
        attr(Fe, "class", "material-icons-round"),
        (Fe.disabled = We = !$[0].controls.min),
        attr(Oe, "class", "material-icons-round"),
        (Oe.disabled = qe = !$[0].controls.max),
        attr(Le, "class", "material-icons-round"),
        (Le.disabled = Qe = !$[0].controls.cls),
        attr(Se, "class", "controls"),
        attr(Re, "class", "value"),
        attr(Ee, "class", "property"),
        (ze.disabled = He = $[0].opened || $[0].disabled),
        (Pe.disabled = Ke = $[0].disabled || $[2]),
        attr(Me, "class", "value"),
        attr(Be, "class", "property"),
        attr(Y, "class", "properties");
    },
    m(he, we) {
      insert(he, r, we),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, I),
        append(I, F),
        append(F, L),
        append(I, U),
        append(I, N),
        append(N, R),
        append(N, q),
        xe.m(N, null),
        append(r, Q),
        append(r, K),
        append(K, V),
        (V.checked = $[1]),
        insert(he, G, we),
        insert(he, Y, we),
        append(Y, J),
        append(J, Z),
        append(J, X),
        append(J, ee),
        append(ee, ie),
        append(ee, ue),
        append(ee, se),
        append(Y, re),
        append(Y, le),
        append(le, ae),
        append(le, ne),
        append(le, ce),
        append(ce, fe),
        append(ce, pe),
        append(ce, ge),
        append(Y, Ae),
        append(Y, $e),
        append($e, ke),
        append($e, ve),
        append($e, be),
        append(be, Ce),
        append(be, Te),
        append(be, Ge),
        append(Y, nt),
        append(Y, it),
        append(Y, at),
        append(Y, Ie),
        append(Ie, Ye),
        append(Ie, ot),
        append(Ie, De),
        append(De, Ze),
        append(De, st),
        append(De, Je),
        append(Y, rt),
        append(Y, Ee),
        append(Ee, Xe),
        append(Ee, lt),
        append(Ee, Re),
        append(Re, Se),
        append(Se, Fe),
        append(Fe, ct),
        append(Se, ut),
        append(Se, Oe),
        append(Oe, pt),
        append(Se, ft),
        append(Se, Le),
        append(Le, dt),
        append(Y, mt),
        append(Y, Be),
        append(Be, et),
        append(Be, _t),
        append(Be, Me),
        append(Me, ze),
        append(ze, gt),
        append(Me, ht),
        append(Me, Pe),
        append(Pe, bt),
        tt ||
          ((At = [
            listen(V, "change", $[5]),
            listen(V, "change", $[4]),
            listen(ze, "click", $[6]),
            listen(Pe, "click", $[7]),
          ]),
          (tt = !0));
    },
    p(he, we) {
      we & 1 &&
        !src_url_equal(v.src, (k = getAppIcon(he[0]))) &&
        attr(v, "src", k),
        we & 1 && x !== (x = he[0].info.name) && attr(v, "alt", x),
        we & 1 && O !== (O = he[0].info.name + "") && set_data(L, O),
        we & 1 && j !== (j = he[0].info.description + "") && set_data(R, j),
        Ve === (Ve = vt(he)) && xe
          ? xe.p(he, we)
          : (xe.d(1), (xe = Ve(he)), xe && (xe.c(), xe.m(N, null))),
        we & 8 && H !== (H = SystemApps.includes(he[3])) && (V.disabled = H),
        we & 2 && (V.checked = he[1]),
        we & 1 && te !== (te = (he[0].size.w || d) + "") && set_data(ie, te),
        we & 1 && oe !== (oe = (he[0].size.h || d) + "") && set_data(se, oe),
        we & 1 && de !== (de = (he[0].minSize.w || d) + "") && set_data(fe, de),
        we & 1 && _e !== (_e = (he[0].minSize.h || d) + "") && set_data(ge, _e),
        we & 1 && ye !== (ye = (he[0].maxSize.w || d) + "") && set_data(Ce, ye),
        we & 1 && Ue !== (Ue = (he[0].maxSize.h || d) + "") && set_data(Ge, Ue),
        we & 1 && Ne !== (Ne = (he[0].pos.x || d) + "") && set_data(Ze, Ne),
        we & 1 && je !== (je = (he[0].pos.y || d) + "") && set_data(Je, je),
        we & 1 && We !== (We = !he[0].controls.min) && (Fe.disabled = We),
        we & 1 && qe !== (qe = !he[0].controls.max) && (Oe.disabled = qe),
        we & 1 && Qe !== (Qe = !he[0].controls.cls) && (Le.disabled = Qe),
        we & 1 &&
          He !== (He = he[0].opened || he[0].disabled) &&
          (ze.disabled = He),
        we & 5 && Ke !== (Ke = he[0].disabled || he[2]) && (Pe.disabled = Ke);
    },
    d(he) {
      he && detach(r),
        xe.d(),
        he && detach(G),
        he && detach(Y),
        (tt = !1),
        run_all(At);
    },
  };
}
function create_else_block$w($) {
  let r,
    p = $[0].id + "",
    v,
    k;
  return {
    c() {
      (r = text("(")), (v = text(p)), (k = text(")"));
    },
    m(x, S) {
      insert(x, r, S), insert(x, v, S), insert(x, k, S);
    },
    p(x, S) {
      S & 1 && p !== (p = x[0].id + "") && set_data(v, p);
    },
    d(x) {
      x && detach(r), x && detach(v), x && detach(k);
    },
  };
}
function create_if_block_1$u($) {
  let r,
    p = $[0].parentId + "",
    v,
    k,
    x = $[0].id + "",
    S,
    I;
  return {
    c() {
      (r = text("(")),
        (v = text(p)),
        (k = text(".")),
        (S = text(x)),
        (I = text(")"));
    },
    m(F, O) {
      insert(F, r, O),
        insert(F, v, O),
        insert(F, k, O),
        insert(F, S, O),
        insert(F, I, O);
    },
    p(F, O) {
      O & 1 && p !== (p = F[0].parentId + "") && set_data(v, p),
        O & 1 && x !== (x = F[0].id + "") && set_data(S, x);
    },
    d(F) {
      F && detach(r),
        F && detach(v),
        F && detach(k),
        F && detach(S),
        F && detach(I);
    },
  };
}
function create_fragment$41($) {
  let r,
    p = $[0] && create_if_block$1x($);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, k) {
      p && p.m(v, k), insert(v, r, k);
    },
    p(v, [k]) {
      v[0]
        ? p
          ? p.p(v, k)
          : ((p = create_if_block$1x(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
let d = "Auto";
function instance$3I($, r, p) {
  let v;
  component_subscribe($, AppInfoId, (N) => p(3, (v = N)));
  let k,
    x = !0,
    S = !1;
  function I() {
    x ? enableApp(v) : disableApp(v),
      p(0, (k = getWindow(v))),
      k && p(1, (x = !getWindow(v).disabled));
  }
  AppInfoId.subscribe(F), WindowStore.subscribe(F);
  function F() {
    v &&
      (p(0, (k = getWindow(v))),
      k &&
        (p(1, (x = !getWindow(v).disabled)),
        p(2, (S = isDisabled("AppPoker")))));
  }
  function O() {
    (x = this.checked), p(1, x);
  }
  return [k, x, S, v, I, O, () => openWindow(v), () => AppPokerData.set(k)];
}
let AppInfo$2 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3I, create_fragment$41, safe_not_equal, {});
  }
};
const AppInfo$1 = {
    info: {
      name: "Application Info",
      description: "View information about an application",
      builtin: !0,
      version: "1.0.0",
      author: "Izaak Kuipers",
      hidden: !0,
      icon: logo$b,
    },
    size: { w: 500, h: 450 },
    pos: { x: 30, y: 40 },
    minSize: { w: 500, h: 450 },
    maxSize: { w: 500, h: 450 },
    controls: { min: !0, max: !1, cls: !0 },
    state: {
      headless: !1,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: AppInfo$2,
    glass: !1,
    events: {
      close() {
        AppInfoId.set(null);
      },
    },
  },
  AppInfoId = writable(null),
  appMan = "./assets/appmanager-60c1ea43.svg",
  AppManager$2 = "",
  AppPokerProperties = [
    {
      caption: "Minimize",
      action: ($) => {
        minimizeWindow($);
      },
      getter: ($) => $.state.windowState.min,
    },
    {
      caption: "Maximize",
      action: ($) => {
        maximizeWindow($);
      },
      getter: ($) => $.state.windowState.max,
    },
    {
      caption: "Close",
      action: ($) => {
        isOpened($.id) ? closeWindow($.id) : openWindow($.id);
      },
      getter: ($) => !isOpened($.id),
    },
    {
      caption: "Headless",
      action: ($) => {
        ($.state.headless = !$.state.headless), updateStores();
      },
      getter: ($) => $.state.headless,
    },
    {
      caption: "Fullscreen",
      action: ($) => {
        ($.state.windowState.fll = !$.state.windowState.fll), updateStores();
      },
      getter: ($) => $.state.windowState.fll,
    },
    {
      caption: "Resizable",
      action: ($) => {
        ($.state.resizable = !$.state.resizable), updateStores();
      },
      getter: ($) => $.state.resizable,
    },
    {
      caption: "Glass",
      action: ($) => {
        ($.glass = !$.glass), updateStores();
      },
      getter: ($) => $.glass,
    },
  ],
  staticAppManActions = [
    {
      caption: "Run...",
      icon: "directions_run",
      action: () => {
        showOverlay("run", "AppMan");
      },
    },
  ],
  appManSelected = writable();
function create_if_block$1w($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I = $[0].info.name + "",
    F,
    O,
    L,
    U,
    N,
    j,
    R = $[1] && create_if_block_2$8();
  function q(V, H) {
    return V[0].parentId ? create_if_block_1$t : create_else_block$v;
  }
  let Q = q($),
    K = Q($);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (S = element("div")),
        (F = text(I)),
        (O = space()),
        R && R.c(),
        (L = space()),
        (U = element("div")),
        K.c(),
        src_url_equal(
          v.src,
          (k = getOriginalIcon($[0].id) || getAppIcon($[0]))
        ) || attr(v, "src", k),
        attr(v, "alt", ""),
        attr(S, "class", "appname"),
        attr(U, "class", "id"),
        attr(r, "class", "appinstance"),
        toggle_class(r, "closed", !$[0].opened),
        toggle_class(r, "selected", $[2] == $[0].id);
    },
    m(V, H) {
      insert(V, r, H),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, S),
        append(S, F),
        append(S, O),
        R && R.m(S, null),
        append(r, L),
        append(r, U),
        K.m(U, null),
        N || ((j = listen(r, "click", $[3])), (N = !0));
    },
    p(V, H) {
      H & 1 &&
        !src_url_equal(
          v.src,
          (k = getOriginalIcon(V[0].id) || getAppIcon(V[0]))
        ) &&
        attr(v, "src", k),
        H & 1 && I !== (I = V[0].info.name + "") && set_data(F, I),
        V[1]
          ? R || ((R = create_if_block_2$8()), R.c(), R.m(S, null))
          : R && (R.d(1), (R = null)),
        Q === (Q = q(V)) && K
          ? K.p(V, H)
          : (K.d(1), (K = Q(V)), K && (K.c(), K.m(U, null))),
        H & 1 && toggle_class(r, "closed", !V[0].opened),
        H & 5 && toggle_class(r, "selected", V[2] == V[0].id);
    },
    d(V) {
      V && detach(r), R && R.d(), K.d(), (N = !1), j();
    },
  };
}
function create_if_block_2$8($) {
  let r;
  return {
    c() {
      r = text("(Dialog)");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_else_block$v($) {
  let r = $[0].id + "",
    p;
  return {
    c() {
      p = text(r);
    },
    m(v, k) {
      insert(v, p, k);
    },
    p(v, k) {
      k & 1 && r !== (r = v[0].id + "") && set_data(p, r);
    },
    d(v) {
      v && detach(p);
    },
  };
}
function create_if_block_1$t($) {
  let r = $[0].parentId + "",
    p,
    v,
    k = $[0].id + "",
    x;
  return {
    c() {
      (p = text(r)), (v = text(".")), (x = text(k));
    },
    m(S, I) {
      insert(S, p, I), insert(S, v, I), insert(S, x, I);
    },
    p(S, I) {
      I & 1 && r !== (r = S[0].parentId + "") && set_data(p, r),
        I & 1 && k !== (k = S[0].id + "") && set_data(x, k);
    },
    d(S) {
      S && detach(p), S && detach(v), S && detach(x);
    },
  };
}
function create_fragment$40($) {
  let r = $[0] && ((!isDisabled($[0].id) && isOpened($[0].id)) || $[1]),
    p,
    v = r && create_if_block$1w($);
  return {
    c() {
      v && v.c(), (p = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, p, x);
    },
    p(k, [x]) {
      x & 3 &&
        (r = k[0] && ((!isDisabled(k[0].id) && isOpened(k[0].id)) || k[1])),
        r
          ? v
            ? v.p(k, x)
            : ((v = create_if_block$1w(k)), v.c(), v.m(p.parentNode, p))
          : v && (v.d(1), (v = null));
    },
    i: noop$1,
    o: noop$1,
    d(k) {
      v && v.d(k), k && detach(p);
    },
  };
}
function instance$3H($, r, p) {
  let v;
  component_subscribe($, appManSelected, (I) => p(2, (v = I)));
  let { app: k } = r,
    { error: x = !1 } = r;
  function S() {
    set_store_value(appManSelected, (v = k.id), v);
  }
  return (
    ($.$$set = (I) => {
      "app" in I && p(0, (k = I.app)), "error" in I && p(1, (x = I.error));
    }),
    [k, x, v, S]
  );
}
let App$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3H, create_fragment$40, safe_not_equal, {
        app: 0,
        error: 1,
      });
  }
};
const logo$a = "./assets/default-fc91861d.svg";
function create_if_block$1v($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I = $[1].info.name + "",
    F,
    O,
    L,
    U = $[2].id + "",
    N,
    j,
    R;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (S = element("div")),
        (F = text(I)),
        (O = space()),
        (L = element("div")),
        (N = text(U)),
        (j = text(".")),
        (R = text($[0])),
        src_url_equal(v.src, (k = logo$a)) || attr(v, "src", k),
        attr(v, "alt", ""),
        attr(S, "class", "appname"),
        attr(L, "class", "id"),
        attr(r, "class", "appinstance"),
        toggle_class(r, "closed", !$[1].show);
    },
    m(q, Q) {
      insert(q, r, Q),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, S),
        append(S, F),
        append(r, O),
        append(r, L),
        append(L, N),
        append(L, j),
        append(L, R);
    },
    p(q, Q) {
      Q & 2 && I !== (I = q[1].info.name + "") && set_data(F, I),
        Q & 4 && U !== (U = q[2].id + "") && set_data(N, U),
        Q & 1 && set_data(R, q[0]),
        Q & 2 && toggle_class(r, "closed", !q[1].show);
    },
    d(q) {
      q && detach(r);
    },
  };
}
function create_fragment$3$($) {
  let r,
    p = $[1] && isOpened($[2].id),
    v = p && create_if_block$1v($);
  return {
    c() {
      (r = element("div")), v && v.c(), attr(r, "class", "indent");
    },
    m(k, x) {
      insert(k, r, x), v && v.m(r, null);
    },
    p(k, [x]) {
      x & 6 && (p = k[1] && isOpened(k[2].id)),
        p
          ? v
            ? v.p(k, x)
            : ((v = create_if_block$1v(k)), v.c(), v.m(r, null))
          : v && (v.d(1), (v = null));
    },
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r), v && v.d();
    },
  };
}
function instance$3G($, r, p) {
  let { id: v } = r,
    { overlay: k } = r,
    { parent: x } = r;
  return (
    ($.$$set = (S) => {
      "id" in S && p(0, (v = S.id)),
        "overlay" in S && p(1, (k = S.overlay)),
        "parent" in S && p(2, (x = S.parent));
    }),
    [v, k, x]
  );
}
class OverlayApp extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3G, create_fragment$3$, safe_not_equal, {
        id: 0,
        overlay: 1,
        parent: 2,
      });
  }
}
function get_each_context$S($, r, p) {
  const v = $.slice();
  return (v[3] = r[p]), v;
}
function get_each_context_1$b($, r, p) {
  const v = $.slice();
  return (v[6] = r[p]), v;
}
function create_if_block$1u($) {
  let r, p, v, k, x;
  p = new App$1({ props: { app: $[0], error: $[2] } });
  let S = $[0].children && create_if_block_2$7($),
    I = $[0].overlays && create_if_block_1$s($);
  return {
    c() {
      (r = element("div")),
        create_component(p.$$.fragment),
        (v = space()),
        S && S.c(),
        (k = space()),
        I && I.c(),
        toggle_class(r, "indent", !$[1]);
    },
    m(F, O) {
      insert(F, r, O),
        mount_component(p, r, null),
        append(r, v),
        S && S.m(r, null),
        append(r, k),
        I && I.m(r, null),
        (x = !0);
    },
    p(F, O) {
      const L = {};
      O & 1 && (L.app = F[0]),
        O & 4 && (L.error = F[2]),
        p.$set(L),
        F[0].children
          ? S
            ? (S.p(F, O), O & 1 && transition_in(S, 1))
            : ((S = create_if_block_2$7(F)),
              S.c(),
              transition_in(S, 1),
              S.m(r, k))
          : S &&
            (group_outros(),
            transition_out(S, 1, 1, () => {
              S = null;
            }),
            check_outros()),
        F[0].overlays
          ? I
            ? (I.p(F, O), O & 1 && transition_in(I, 1))
            : ((I = create_if_block_1$s(F)),
              I.c(),
              transition_in(I, 1),
              I.m(r, null))
          : I &&
            (group_outros(),
            transition_out(I, 1, 1, () => {
              I = null;
            }),
            check_outros()),
        (!x || O & 2) && toggle_class(r, "indent", !F[1]);
    },
    i(F) {
      x ||
        (transition_in(p.$$.fragment, F),
        transition_in(S),
        transition_in(I),
        (x = !0));
    },
    o(F) {
      transition_out(p.$$.fragment, F),
        transition_out(S),
        transition_out(I),
        (x = !1);
    },
    d(F) {
      F && detach(r), destroy_component(p), S && S.d(), I && I.d();
    },
  };
}
function create_if_block_2$7($) {
  let r,
    p,
    v = Object.keys($[0].children),
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block_1$b(get_each_context_1$b($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 1) {
        v = Object.keys(S[0].children);
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_1$b(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block_1$b(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_each_block_1$b($) {
  let r, p;
  return (
    (r = new Branch_1$1({ props: { window: getWindow($[6]) } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.window = getWindow(v[6])), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_1$s($) {
  let r,
    p,
    v = Object.entries($[0].overlays),
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$S(get_each_context$S($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 1) {
        v = Object.entries(S[0].overlays);
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$S(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$S(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_each_block$S($) {
  let r, p;
  return (
    (r = new OverlayApp({
      props: { overlay: $[3][1], parent: $[0], id: $[3][0] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.overlay = v[3][1]),
          k & 1 && (x.parent = v[0]),
          k & 1 && (x.id = v[3][0]),
          r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$3_($) {
  let r,
    p,
    v = $[0] && create_if_block$1u($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[0]
        ? v
          ? (v.p(k, x), x & 1 && transition_in(v, 1))
          : ((v = create_if_block$1u(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$3F($, r, p) {
  let { window: v } = r,
    { top: k = !1 } = r,
    { error: x = !1 } = r;
  return (
    ($.$$set = (S) => {
      "window" in S && p(0, (v = S.window)),
        "top" in S && p(1, (k = S.top)),
        "error" in S && p(2, (x = S.error));
    }),
    [v, k, x]
  );
}
let Branch_1$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3F, create_fragment$3_, safe_not_equal, {
        window: 0,
        top: 1,
        error: 2,
      });
  }
};
function get_each_context$R($, r, p) {
  const v = $.slice();
  return (v[2] = r[p]), v;
}
function get_each_context_1$a($, r, p) {
  const v = $.slice();
  return (v[5] = r[p]), v;
}
function create_if_block$1t($) {
  let r, p;
  return (
    (r = new Branch_1$1({ props: { window: $[5], top: !0 } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 2 && (x.window = v[5]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block_1$a($) {
  let r,
    p,
    v = !$[5].parentId && create_if_block$1t($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, x) {
      k[5].parentId
        ? v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros())
        : v
        ? (v.p(k, x), x & 2 && transition_in(v, 1))
        : ((v = create_if_block$1t(k)),
          v.c(),
          transition_in(v, 1),
          v.m(r.parentNode, r));
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function create_each_block$R($) {
  let r, p;
  return (
    (r = new Branch_1$1({ props: { window: $[2], top: !0, error: !0 } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.window = v[2]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$3Z($) {
  let r,
    p,
    v,
    k = $[1],
    x = [];
  for (let L = 0; L < k.length; L += 1)
    x[L] = create_each_block_1$a(get_each_context_1$a($, k, L));
  const S = (L) =>
    transition_out(x[L], 1, 1, () => {
      x[L] = null;
    });
  let I = $[0],
    F = [];
  for (let L = 0; L < I.length; L += 1)
    F[L] = create_each_block$R(get_each_context$R($, I, L));
  const O = (L) =>
    transition_out(F[L], 1, 1, () => {
      F[L] = null;
    });
  return {
    c() {
      r = element("div");
      for (let L = 0; L < x.length; L += 1) x[L].c();
      p = space();
      for (let L = 0; L < F.length; L += 1) F[L].c();
      attr(r, "class", "apps");
    },
    m(L, U) {
      insert(L, r, U);
      for (let N = 0; N < x.length; N += 1) x[N] && x[N].m(r, null);
      append(r, p);
      for (let N = 0; N < F.length; N += 1) F[N] && F[N].m(r, null);
      v = !0;
    },
    p(L, [U]) {
      if (U & 2) {
        k = L[1];
        let N;
        for (N = 0; N < k.length; N += 1) {
          const j = get_each_context_1$a(L, k, N);
          x[N]
            ? (x[N].p(j, U), transition_in(x[N], 1))
            : ((x[N] = create_each_block_1$a(j)),
              x[N].c(),
              transition_in(x[N], 1),
              x[N].m(r, p));
        }
        for (group_outros(), N = k.length; N < x.length; N += 1) S(N);
        check_outros();
      }
      if (U & 1) {
        I = L[0];
        let N;
        for (N = 0; N < I.length; N += 1) {
          const j = get_each_context$R(L, I, N);
          F[N]
            ? (F[N].p(j, U), transition_in(F[N], 1))
            : ((F[N] = create_each_block$R(j)),
              F[N].c(),
              transition_in(F[N], 1),
              F[N].m(r, null));
        }
        for (group_outros(), N = I.length; N < F.length; N += 1) O(N);
        check_outros();
      }
    },
    i(L) {
      if (!v) {
        for (let U = 0; U < k.length; U += 1) transition_in(x[U]);
        for (let U = 0; U < I.length; U += 1) transition_in(F[U]);
        v = !0;
      }
    },
    o(L) {
      x = x.filter(Boolean);
      for (let U = 0; U < x.length; U += 1) transition_out(x[U]);
      F = F.filter(Boolean);
      for (let U = 0; U < F.length; U += 1) transition_out(F[U]);
      v = !1;
    },
    d(L) {
      L && detach(r), destroy_each(x, L), destroy_each(F, L);
    },
  };
}
function instance$3E($, r, p) {
  let v;
  component_subscribe($, WindowStore, (x) => p(1, (v = x)));
  let k = [];
  return (
    ErrorWindowStore.subscribe((x) => {
      p(0, (k = x));
    }),
    [k, v]
  );
}
let AppList$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3E, create_fragment$3Z, safe_not_equal, {});
  }
};
function create_if_block$1s($) {
  let r,
    p,
    v = getWindow($[0]).snapped ? "yes" : "no",
    k;
  return {
    c() {
      (r = element("div")),
        (p = text("Snapped: ")),
        (k = text(v)),
        attr(r, "class", "section");
    },
    m(x, S) {
      insert(x, r, S), append(r, p), append(r, k);
    },
    p(x, S) {
      S & 1 &&
        v !== (v = getWindow(x[0]).snapped ? "yes" : "no") &&
        set_data(k, v);
    },
    d(x) {
      x && detach(r);
    },
  };
}
function create_fragment$3Y($) {
  let r,
    p,
    v = $[0] && !$[0].startsWith("error_"),
    k,
    x,
    S,
    I = $[1].length + "",
    F,
    O,
    L,
    U,
    N = $[2].length + "",
    j,
    R,
    q,
    Q,
    K = $[3].length + "",
    V,
    H = v && create_if_block$1s($);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        H && H.c(),
        (k = space()),
        (x = element("div")),
        (S = text("Running: ")),
        (F = text(I)),
        (O = space()),
        (L = element("div")),
        (U = text("Loaded: ")),
        (j = text(N)),
        (R = space()),
        (q = element("div")),
        (Q = text("Dialogs: ")),
        (V = text(K)),
        attr(x, "class", "section"),
        attr(L, "class", "section"),
        attr(q, "class", "section"),
        attr(p, "class", "right"),
        attr(r, "class", "bottombar");
    },
    m(G, Y) {
      insert(G, r, Y),
        append(r, p),
        H && H.m(p, null),
        append(p, k),
        append(p, x),
        append(x, S),
        append(x, F),
        append(p, O),
        append(p, L),
        append(L, U),
        append(L, j),
        append(p, R),
        append(p, q),
        append(q, Q),
        append(q, V);
    },
    p(G, [Y]) {
      Y & 1 && (v = G[0] && !G[0].startsWith("error_")),
        v
          ? H
            ? H.p(G, Y)
            : ((H = create_if_block$1s(G)), H.c(), H.m(p, k))
          : H && (H.d(1), (H = null)),
        Y & 2 && I !== (I = G[1].length + "") && set_data(F, I),
        Y & 4 && N !== (N = G[2].length + "") && set_data(j, N),
        Y & 8 && K !== (K = G[3].length + "") && set_data(V, K);
    },
    i: noop$1,
    o: noop$1,
    d(G) {
      G && detach(r), H && H.d();
    },
  };
}
function instance$3D($, r, p) {
  let v, k, x, S;
  return (
    component_subscribe($, appManSelected, (I) => p(0, (v = I))),
    component_subscribe($, OpenedStore, (I) => p(1, (k = I))),
    component_subscribe($, WindowStore, (I) => p(2, (x = I))),
    component_subscribe($, ErrorWindowStore, (I) => p(3, (S = I))),
    [v, k, x, S]
  );
}
class BottomBar extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3D, create_fragment$3Y, safe_not_equal, {});
  }
}
function create_fragment$3X($) {
  let r,
    p,
    v = $[0].icon + "",
    k,
    x,
    S,
    I = $[0].caption + "",
    F,
    O,
    L;
  return {
    c() {
      (r = element("button")),
        (p = element("span")),
        (k = text(v)),
        (x = space()),
        (S = element("p")),
        (F = text(I)),
        attr(p, "class", "material-icons-round"),
        attr(S, "class", "caption"),
        attr(r, "class", "action");
    },
    m(U, N) {
      insert(U, r, N),
        append(r, p),
        append(p, k),
        append(r, x),
        append(r, S),
        append(S, F),
        O ||
          ((L = listen(r, "click", function () {
            is_function($[0].action) && $[0].action.apply(this, arguments);
          })),
          (O = !0));
    },
    p(U, [N]) {
      ($ = U),
        N & 1 && v !== (v = $[0].icon + "") && set_data(k, v),
        N & 1 && I !== (I = $[0].caption + "") && set_data(F, I);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r), (O = !1), L();
    },
  };
}
function instance$3C($, r, p) {
  let { action: v } = r;
  return (
    ($.$$set = (k) => {
      "action" in k && p(0, (v = k.action));
    }),
    [v]
  );
}
let Action$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3C, create_fragment$3X, safe_not_equal, {
        action: 0,
      });
  }
};
function create_fragment$3W($) {
  let r, p, v, k, x, S, I;
  return {
    c() {
      (r = element("button")),
        (p = element("span")),
        (p.textContent = "settings"),
        (v = space()),
        (k = element("p")),
        (k.textContent = "App info"),
        attr(p, "class", "material-icons-round"),
        attr(k, "class", "caption"),
        attr(r, "class", "action"),
        (r.disabled = x = !$[0]);
    },
    m(F, O) {
      insert(F, r, O),
        append(r, p),
        append(r, v),
        append(r, k),
        S || ((I = listen(r, "click", $[1])), (S = !0));
    },
    p(F, [O]) {
      O & 1 && x !== (x = !F[0]) && (r.disabled = x);
    },
    i: noop$1,
    o: noop$1,
    d(F) {
      F && detach(r), (S = !1), I();
    },
  };
}
function instance$3B($, r, p) {
  let v;
  component_subscribe($, appManSelected, (x) => p(0, (v = x)));
  function k() {
    AppInfoId.set(v), openWindow("AppInfo");
  }
  return [v, k];
}
class AppInfo extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3B, create_fragment$3W, safe_not_equal, {});
  }
}
function create_fragment$3V($) {
  let r, p, v, k, x, S, I;
  return {
    c() {
      (r = element("button")),
        (p = element("span")),
        (p.textContent = "close"),
        (v = space()),
        (k = element("p")),
        (k.textContent = "Close"),
        attr(p, "class", "material-icons-round"),
        attr(k, "class", "caption"),
        attr(r, "class", "action"),
        (r.disabled = x = !$[0]);
    },
    m(F, O) {
      insert(F, r, O),
        append(r, p),
        append(r, v),
        append(r, k),
        S || ((I = listen(r, "click", $[1])), (S = !0));
    },
    p(F, [O]) {
      O & 1 && x !== (x = !F[0]) && (r.disabled = x);
    },
    i: noop$1,
    o: noop$1,
    d(F) {
      F && detach(r), (S = !1), I();
    },
  };
}
function instance$3A($, r, p) {
  let v;
  component_subscribe($, appManSelected, (x) => p(0, (v = x)));
  function k() {
    closeWindow(v), set_store_value(appManSelected, (v = null), v);
  }
  return [v, k];
}
class Close extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3A, create_fragment$3V, safe_not_equal, {});
  }
}
function create_fragment$3U($) {
  let r, p, v, k, x, S, I;
  return {
    c() {
      (r = element("button")),
        (p = element("span")),
        (p.textContent = "block"),
        (v = space()),
        (k = element("p")),
        (k.textContent = "Disable"),
        attr(p, "class", "material-icons-round"),
        attr(k, "class", "caption"),
        attr(r, "class", "action"),
        (r.disabled = x = !$[0]);
    },
    m(F, O) {
      insert(F, r, O),
        append(r, p),
        append(r, v),
        append(r, k),
        S || ((I = listen(r, "click", $[1])), (S = !0));
    },
    p(F, [O]) {
      O & 1 && x !== (x = !F[0]) && (r.disabled = x);
    },
    i: noop$1,
    o: noop$1,
    d(F) {
      F && detach(r), (S = !1), I();
    },
  };
}
function instance$3z($, r, p) {
  let v;
  component_subscribe($, appManSelected, (x) => p(0, (v = x)));
  function k() {
    disableApp(v);
  }
  return [v, k];
}
class DisableApp extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3z, create_fragment$3U, safe_not_equal, {});
  }
}
function get_each_context$Q($, r, p) {
  const v = $.slice();
  return (v[0] = r[p]), v;
}
function create_each_block$Q($) {
  let r, p;
  return (
    (r = new Action$1({ props: { action: $[0] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$3T($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j;
  (v = new AppInfo({})), (I = new DisableApp({})), (O = new Close({}));
  let R = staticAppManActions,
    q = [];
  for (let K = 0; K < R.length; K += 1)
    q[K] = create_each_block$Q(get_each_context$Q($, R, K));
  const Q = (K) =>
    transition_out(q[K], 1, 1, () => {
      q[K] = null;
    });
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        create_component(v.$$.fragment),
        (k = space()),
        (x = element("div")),
        (S = space()),
        create_component(I.$$.fragment),
        (F = space()),
        create_component(O.$$.fragment),
        (L = space()),
        (U = element("div")),
        (N = space());
      for (let K = 0; K < q.length; K += 1) q[K].c();
      attr(x, "class", "sep"),
        attr(U, "class", "sep"),
        attr(p, "class", "actions"),
        attr(r, "class", "topbar");
    },
    m(K, V) {
      insert(K, r, V),
        append(r, p),
        mount_component(v, p, null),
        append(p, k),
        append(p, x),
        append(p, S),
        mount_component(I, p, null),
        append(p, F),
        mount_component(O, p, null),
        append(p, L),
        append(p, U),
        append(p, N);
      for (let H = 0; H < q.length; H += 1) q[H] && q[H].m(p, null);
      j = !0;
    },
    p(K, [V]) {
      if (V & 0) {
        R = staticAppManActions;
        let H;
        for (H = 0; H < R.length; H += 1) {
          const G = get_each_context$Q(K, R, H);
          q[H]
            ? (q[H].p(G, V), transition_in(q[H], 1))
            : ((q[H] = create_each_block$Q(G)),
              q[H].c(),
              transition_in(q[H], 1),
              q[H].m(p, null));
        }
        for (group_outros(), H = R.length; H < q.length; H += 1) Q(H);
        check_outros();
      }
    },
    i(K) {
      if (!j) {
        transition_in(v.$$.fragment, K),
          transition_in(I.$$.fragment, K),
          transition_in(O.$$.fragment, K);
        for (let V = 0; V < R.length; V += 1) transition_in(q[V]);
        j = !0;
      }
    },
    o(K) {
      transition_out(v.$$.fragment, K),
        transition_out(I.$$.fragment, K),
        transition_out(O.$$.fragment, K),
        (q = q.filter(Boolean));
      for (let V = 0; V < q.length; V += 1) transition_out(q[V]);
      j = !1;
    },
    d(K) {
      K && detach(r),
        destroy_component(v),
        destroy_component(I),
        destroy_component(O),
        destroy_each(q, K);
    },
  };
}
let TopBar$3 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$3T, safe_not_equal, {});
  }
};
function create_fragment$3S($) {
  let r, p, v, k, x, S;
  return (
    (r = new TopBar$3({})),
    (v = new AppList$1({})),
    (x = new BottomBar({})),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          create_component(v.$$.fragment),
          (k = space()),
          create_component(x.$$.fragment);
      },
      m(I, F) {
        mount_component(r, I, F),
          insert(I, p, F),
          mount_component(v, I, F),
          insert(I, k, F),
          mount_component(x, I, F),
          (S = !0);
      },
      p: noop$1,
      i(I) {
        S ||
          (transition_in(r.$$.fragment, I),
          transition_in(v.$$.fragment, I),
          transition_in(x.$$.fragment, I),
          (S = !0));
      },
      o(I) {
        transition_out(r.$$.fragment, I),
          transition_out(v.$$.fragment, I),
          transition_out(x.$$.fragment, I),
          (S = !1);
      },
      d(I) {
        destroy_component(r, I),
          I && detach(p),
          destroy_component(v, I),
          I && detach(k),
          destroy_component(x, I);
      },
    }
  );
}
let AppManager$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$3S, safe_not_equal, {});
  }
};
const RunDialog_svelte_svelte_type_style_lang = "";
function get_each_context$P($, r, p) {
  const v = $.slice();
  return (v[5] = r[p]), v;
}
function create_if_block$1r($) {
  let r,
    p = $[5].id + "",
    v,
    k;
  return {
    c() {
      (r = element("option")),
        (v = text(p)),
        (r.__value = k = $[5].id),
        (r.value = r.__value);
    },
    m(x, S) {
      insert(x, r, S), append(r, v);
    },
    p(x, S) {
      S & 2 && p !== (p = x[5].id + "") && set_data(v, p),
        S & 2 &&
          k !== (k = x[5].id) &&
          ((r.__value = k), (r.value = r.__value));
    },
    d(x) {
      x && detach(r);
    },
  };
}
function create_each_block$P($) {
  let r = !isOpened($[5].id) && !$[5].info.custom && !isDisabled($[5].id),
    p,
    v = r && create_if_block$1r($);
  return {
    c() {
      v && v.c(), (p = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, p, x);
    },
    p(k, x) {
      x & 2 &&
        (r = !isOpened(k[5].id) && !k[5].info.custom && !isDisabled(k[5].id)),
        r
          ? v
            ? v.p(k, x)
            : ((v = create_if_block$1r(k)), v.c(), v.m(p.parentNode, p))
          : v && (v.d(1), (v = null));
    },
    d(k) {
      v && v.d(k), k && detach(p);
    },
  };
}
function create_fragment$3R($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U,
    N,
    j,
    R,
    q,
    Q,
    K,
    V,
    H = $[1],
    G = [];
  for (let Y = 0; Y < H.length; Y += 1)
    G[Y] = create_each_block$P(get_each_context$P($, H, Y));
  return {
    c() {
      (r = element("div")),
        (p = element("img")),
        (k = space()),
        (x = element("div")),
        (S = element("p")),
        (S.textContent =
          "Select the ID of the app you want to run from the following list:"),
        (I = space()),
        (F = element("select"));
      for (let Y = 0; Y < G.length; Y += 1) G[Y].c();
      (O = space()),
        (L = element("div")),
        (U = element("div")),
        (N = element("button")),
        (j = text("Run")),
        (q = space()),
        (Q = element("button")),
        (Q.textContent = "Cancel"),
        src_url_equal(p.src, (v = appSettings)) || attr(p, "src", v),
        attr(p, "alt", "Run"),
        attr(p, "class", "svelte-1pwxzgl"),
        attr(S, "class", "caption svelte-1pwxzgl"),
        attr(F, "class", "svelte-1pwxzgl"),
        $[0] === void 0 && add_render_callback(() => $[4].call(F)),
        attr(x, "class", "inner"),
        attr(r, "class", "wrapper svelte-1pwxzgl"),
        (N.disabled = R = !$[0]),
        attr(U, "class", "inner svelte-1pwxzgl"),
        attr(L, "class", "actions svelte-1pwxzgl");
    },
    m(Y, J) {
      insert(Y, r, J),
        append(r, p),
        append(r, k),
        append(r, x),
        append(x, S),
        append(x, I),
        append(x, F);
      for (let Z = 0; Z < G.length; Z += 1) G[Z] && G[Z].m(F, null);
      select_option(F, $[0], !0),
        insert(Y, O, J),
        insert(Y, L, J),
        append(L, U),
        append(U, N),
        append(N, j),
        append(U, q),
        append(U, Q),
        K ||
          ((V = [
            listen(F, "change", $[4]),
            listen(N, "click", $[2]),
            listen(Q, "click", $[3]),
          ]),
          (K = !0));
    },
    p(Y, [J]) {
      if (J & 2) {
        H = Y[1];
        let Z;
        for (Z = 0; Z < H.length; Z += 1) {
          const X = get_each_context$P(Y, H, Z);
          G[Z]
            ? G[Z].p(X, J)
            : ((G[Z] = create_each_block$P(X)), G[Z].c(), G[Z].m(F, null));
        }
        for (; Z < G.length; Z += 1) G[Z].d(1);
        G.length = H.length;
      }
      J & 3 && select_option(F, Y[0]),
        J & 3 && R !== (R = !Y[0]) && (N.disabled = R);
    },
    i: noop$1,
    o: noop$1,
    d(Y) {
      Y && detach(r),
        destroy_each(G, Y),
        Y && detach(O),
        Y && detach(L),
        (K = !1),
        run_all(V);
    },
  };
}
function instance$3y($, r, p) {
  let v;
  component_subscribe($, WindowStore, (F) => p(1, (v = F)));
  let k;
  function x() {
    openWindow(k, !0), S();
  }
  function S() {
    hideOverlay("run", "AppMan");
  }
  function I() {
    (k = select_value(this)), p(0, k);
  }
  return [k, v, x, S, I];
}
class RunDialog extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3y, create_fragment$3R, safe_not_equal, {});
  }
}
const AppManager = {
    info: {
      name: "Application Manager",
      description: "Manage Open Apps",
      builtin: !0,
      version: "1.5.0",
      author: "Izaak Kuipers",
      icon: appMan,
    },
    size: { w: 600, h: 500 },
    pos: { x: 30, y: 40 },
    minSize: { w: 600, h: 500 },
    maxSize: { w: 600, h: 500 },
    controls: { min: !1, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: AppManager$1,
    glass: !0,
    events: {
      open() {
        createTrayIcon({
          image: AppManager.info.icon,
          identifier: "Application Manager",
          onOpen() {},
        });
      },
      close() {
        disposeTrayIcon("Application Manager");
      },
    },
    overlays: {
      run: {
        info: { name: "Run", author: "ArcOS Team", version: "1.0.0" },
        size: { w: NaN, h: NaN },
        show: !1,
        content: RunDialog,
      },
    },
  },
  AppPoker$2 = "",
  notice = "";
function create_fragment$3Q($) {
  let r, p, v, k, x, S, I, F, O, L;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("span")),
        (k = text($[2])),
        (x = space()),
        (S = element("div")),
        (I = element("p")),
        (F = text($[0])),
        (O = space()),
        (L = element("p")),
        attr(v, "class", "material-icons-round"),
        attr(I, "class", "title"),
        attr(L, "class", "message"),
        attr(r, "class", "notice");
    },
    m(U, N) {
      insert(U, r, N),
        append(r, p),
        append(p, v),
        append(v, k),
        append(r, x),
        append(r, S),
        append(S, I),
        append(I, F),
        append(S, O),
        append(S, L),
        (L.innerHTML = $[1]);
    },
    p(U, [N]) {
      N & 4 && set_data(k, U[2]),
        N & 1 && set_data(F, U[0]),
        N & 2 && (L.innerHTML = U[1]);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r);
    },
  };
}
function instance$3x($, r, p) {
  let { title: v } = r,
    { text: k } = r,
    { icon: x } = r;
  return (
    ($.$$set = (S) => {
      "title" in S && p(0, (v = S.title)),
        "text" in S && p(1, (k = S.text)),
        "icon" in S && p(2, (x = S.icon));
    }),
    [v, k, x]
  );
}
class Notice extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3x, create_fragment$3Q, safe_not_equal, {
        title: 0,
        text: 1,
        icon: 2,
      });
  }
}
function get_each_context$O($, r, p) {
  const v = $.slice();
  return (v[4] = r[p]), v;
}
function create_if_block$1q($) {
  let r, p, v, k;
  r = new Notice({
    props: {
      icon: "warning",
      text: "You can alter properties for applications that are disabled by default. This can cause the UI to break, be careful!",
      title: "Hold up!",
    },
  });
  let x = AppPokerProperties,
    S = [];
  for (let I = 0; I < x.length; I += 1)
    S[I] = create_each_block$O(get_each_context$O($, x, I));
  return {
    c() {
      create_component(r.$$.fragment), (p = space()), (v = element("div"));
      for (let I = 0; I < S.length; I += 1) S[I].c();
      attr(v, "class", "manager");
    },
    m(I, F) {
      mount_component(r, I, F), insert(I, p, F), insert(I, v, F);
      for (let O = 0; O < S.length; O += 1) S[O] && S[O].m(v, null);
      k = !0;
    },
    p(I, F) {
      if (F & 2) {
        x = AppPokerProperties;
        let O;
        for (O = 0; O < x.length; O += 1) {
          const L = get_each_context$O(I, x, O);
          S[O]
            ? S[O].p(L, F)
            : ((S[O] = create_each_block$O(L)), S[O].c(), S[O].m(v, null));
        }
        for (; O < S.length; O += 1) S[O].d(1);
        S.length = x.length;
      }
    },
    i(I) {
      k || (transition_in(r.$$.fragment, I), (k = !0));
    },
    o(I) {
      transition_out(r.$$.fragment, I), (k = !1);
    },
    d(I) {
      destroy_component(r, I),
        I && detach(p),
        I && detach(v),
        destroy_each(S, I);
    },
  };
}
function create_each_block$O($) {
  let r,
    p = $[4].caption + "",
    v,
    k,
    x,
    S;
  function I() {
    return $[3]($[4]);
  }
  return {
    c() {
      (r = element("button")),
        (v = text(p)),
        (k = space()),
        toggle_class(r, "off", !$[4].getter($[1]));
    },
    m(F, O) {
      insert(F, r, O),
        append(r, v),
        append(r, k),
        x || ((S = listen(r, "click", I)), (x = !0));
    },
    p(F, O) {
      ($ = F), O & 2 && toggle_class(r, "off", !$[4].getter($[1]));
    },
    d(F) {
      F && detach(r), (x = !1), S();
    },
  };
}
function create_fragment$3P($) {
  let r,
    p,
    v = $[1] && !$[0] && create_if_block$1q($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[1] && !k[0]
        ? v
          ? (v.p(k, x), x & 3 && transition_in(v, 1))
          : ((v = create_if_block$1q(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$3w($, r, p) {
  let v;
  component_subscribe($, AppPokerData, (I) => p(1, (v = I)));
  let { app: k } = r,
    x = !1;
  WindowStore.subscribe((I) => {
    I && (p(0, (x = !0)), p(0, (x = !1)));
  }),
    AppPokerData.subscribe((I) => {
      I &&
        (p(2, (k.info.titleSuffix = ` - Managing ${I.info.name}`), k),
        updateStores());
    });
  const S = (I) => I.action(v);
  return (
    ($.$$set = (I) => {
      "app" in I && p(2, (k = I.app));
    }),
    [x, v, k, S]
  );
}
let AppPoker$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3w, create_fragment$3P, safe_not_equal, {
        app: 2,
      });
  }
};
const AppPoker = {
    info: {
      name: "App Poker",
      description: "Poke properties of applications",
      builtin: !0,
      version: "1.0.0",
      author: "Izaak Kuipers",
      hidden: !0,
      icon: logo$c,
    },
    size: { w: 500, h: 300 },
    pos: { x: 30, y: 40 },
    minSize: { w: 500, h: 300 },
    maxSize: { w: 500, h: 300 },
    controls: { min: !1, max: !1, cls: !0 },
    state: {
      headless: !1,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: AppPoker$1,
    glass: !1,
    events: {
      close() {
        AppPokerData.set(null);
      },
    },
    disabledWarning: {
      title: "Can't poke apps",
      message:
        "The app poker is disabled, so you won't be able to poke applications. Go to the Apps page in settings to re-enable it.",
    },
  },
  logo$9 = "./assets/calculator-a55e0dfc.svg",
  calculator = "";
class CS {
  constructor() {
    me(this, "Source", "Calculator/main.ts:");
    me(this, "AllowedKeys", [
      "+",
      "-",
      "/",
      "*",
      "7",
      "8",
      "9",
      "**",
      "4",
      "5",
      "6",
      "%",
      "1",
      "2",
      "3",
      "%%C",
      ".",
      "0",
      "00",
      "%%E",
    ]);
    me(this, "Shortcuts", [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "/",
      "+",
      "-",
      "*",
    ]);
    me(this, "Overrides", { "*": "x", "/": ":", "**": "^", "%": "mod()" });
    me(this, "altClasses", ["+", "-", "/", "*", "**", "%", "."]);
  }
}
const CalculatorStore = new CS(),
  CalculatorValue = writable("");
class CL {
  constructor() {
    me(this, "keys", []);
    me(this, "Functions", {
      "%%C": ["C", () => CalculatorValue.set(""), "clear"],
      "%%E": ["=", this.evaluate, "process"],
    });
    this.keys = this.compileKeys(
      CalculatorStore.AllowedKeys,
      CalculatorStore.Overrides
    );
  }
  compileKeys($, r) {
    const p = [];
    for (let v = 0; v < $.length; v++) {
      let k = [null, null];
      (k[0] = r[$[v]] || $[v]), (k[1] = $[v]), p.push(k);
    }
    return p;
  }
  evaluate() {
    if (
      (Log({
        source: `${CalculatorStore.Source} evaluate`,
        msg: `Evaluating sum ("${get_store_value(CalculatorValue)}")`,
        level: LogLevel.info,
      }),
      !CalculatorClass.isValid(get_store_value(CalculatorValue)))
    )
      return !1;
    const value = eval(get_store_value(CalculatorValue));
    return CalculatorValue.set(value), value;
  }
  isValid($) {
    if (
      (Log({
        source: `${CalculatorStore.Source} isValid`,
        msg: `Verifying input "${$}"...`,
        level: LogLevel.info,
      }),
      $.startsWith("%%"))
    )
      return !1;
    for (let r = 0; r < $.length; r++)
      if (!CalculatorStore.AllowedKeys.includes($[r]))
        return (
          Log({
            source: `${CalculatorStore.Source} isValid`,
            msg: `Input "${$}" not valid.`,
            level: LogLevel.warn,
          }),
          !1
        );
    return !0;
  }
  generateKeyboardShortcuts() {
    let $ = [];
    for (let r = 0; r < CalculatorStore.Shortcuts.length; r++)
      $.push({
        key: CalculatorStore.Shortcuts[r],
        action: () => this.processKey(CalculatorStore.Shortcuts[r]),
      });
    return $;
  }
  processKey(key) {
    if (
      (Log({
        source: `${CalculatorStore.Source} processKey`,
        msg: `Processing key "${key}"`,
        level: LogLevel.info,
      }),
      !this.isValid(key))
    )
      return !1;
    const newValue = `${get_store_value(CalculatorValue)}${key}0`;
    try {
      eval(newValue);
    } catch {
      return (
        Log({
          source: `${CalculatorStore.Source} Calculator/main.ts: processKey`,
          msg: `Test sum "${newValue}" is not valid. Aborting.`,
          level: LogLevel.error,
        }),
        !1
      );
    }
    CalculatorValue.set(get_store_value(CalculatorValue) + key);
  }
}
const CalculatorClass = new CL();
function get_each_context$N($, r, p) {
  const v = $.slice();
  return (v[4] = r[p]), v;
}
function create_else_block$u($) {
  let r,
    p = CalculatorClass.Functions[$[4][1]][0] + "",
    v,
    k,
    x,
    S;
  return {
    c() {
      (r = element("button")),
        (v = text(p)),
        (k = space()),
        attr(r, "class", CalculatorClass.Functions[$[4][1]][2]);
    },
    m(I, F) {
      insert(I, r, F),
        append(r, v),
        append(r, k),
        x ||
          ((S = listen(r, "click", CalculatorClass.Functions[$[4][0]][1])),
          (x = !0));
    },
    p(I, F) {
      $ = I;
    },
    d(I) {
      I && detach(r), (x = !1), S();
    },
  };
}
function create_if_block$1p($) {
  let r,
    p = $[4][0] + "",
    v,
    k,
    x,
    S;
  function I() {
    return $[1]($[4]);
  }
  return {
    c() {
      (r = element("button")),
        (v = text(p)),
        (k = space()),
        toggle_class(r, "empty", !$[4][0]),
        toggle_class(r, "alt", CalculatorStore.altClasses.includes($[4][1]));
    },
    m(F, O) {
      insert(F, r, O),
        append(r, v),
        append(r, k),
        x || ((S = listen(r, "click", I)), (x = !0));
    },
    p(F, O) {
      $ = F;
    },
    d(F) {
      F && detach(r), (x = !1), S();
    },
  };
}
function create_each_block$N($) {
  let r;
  function p(x, S) {
    return x[4][0].startsWith("%%") ? create_else_block$u : create_if_block$1p;
  }
  let k = p($)($);
  return {
    c() {
      k.c(), (r = empty());
    },
    m(x, S) {
      k.m(x, S), insert(x, r, S);
    },
    p(x, S) {
      k.p(x, S);
    },
    d(x) {
      k.d(x), x && detach(r);
    },
  };
}
function create_fragment$3O($) {
  let r,
    p,
    v,
    k = CalculatorClass.keys,
    x = [];
  for (let S = 0; S < k.length; S += 1)
    x[S] = create_each_block$N(get_each_context$N($, k, S));
  return {
    c() {
      (r = element("input")), (p = space()), (v = element("div"));
      for (let S = 0; S < x.length; S += 1) x[S].c();
      attr(r, "type", "text"),
        attr(r, "class", "display"),
        (r.readOnly = !0),
        (r.value = $[0]),
        attr(v, "class", "keys");
    },
    m(S, I) {
      insert(S, r, I), insert(S, p, I), insert(S, v, I);
      for (let F = 0; F < x.length; F += 1) x[F] && x[F].m(v, null);
    },
    p(S, [I]) {
      if ((I & 1 && r.value !== S[0] && (r.value = S[0]), I & 0)) {
        k = CalculatorClass.keys;
        let F;
        for (F = 0; F < k.length; F += 1) {
          const O = get_each_context$N(S, k, F);
          x[F]
            ? x[F].p(O, I)
            : ((x[F] = create_each_block$N(O)), x[F].c(), x[F].m(v, null));
        }
        for (; F < x.length; F += 1) x[F].d(1);
        x.length = k.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r), S && detach(p), S && detach(v), destroy_each(x, S);
    },
  };
}
function instance$3v($, r, p) {
  let v;
  component_subscribe($, CalculatorValue, (S) => p(2, (v = S)));
  let k = "";
  return (
    onMount(() => {
      CalculatorValue.subscribe((S) => {
        Log({
          source: "Calculator: CalculatorValue.subscribe",
          msg: `Value of CalculatorValue<string> changed to "${v}"`,
          level: LogLevel.info,
        }),
          p(0, (k = S || "0"));
      });
    }),
    [k, (S) => CalculatorClass.processKey(S[1])]
  );
}
class Calculator extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3v, create_fragment$3O, safe_not_equal, {});
  }
}
const CalculatorApp = {
    info: {
      name: "Calculator",
      description: "ArcOS Calculator",
      builtin: !0,
      version: "2.0.0",
      author: "Izaak Kuipers",
      icon: logo$9,
    },
    size: { w: 340, h: NaN },
    pos: { x: 60, y: 60 },
    minSize: { w: 340, h: NaN },
    maxSize: { w: 340, h: NaN },
    controls: { min: !0, max: !1, cls: !0 },
    state: {
      headless: !1,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: Calculator,
    glass: !0,
    events: {
      close() {
        CalculatorValue.set("");
      },
      open() {
        CalculatorValue.set("");
      },
      keyboardShortcuts: [
        ...CalculatorClass.generateKeyboardShortcuts(),
        { key: "enter", action: () => CalculatorClass.evaluate() },
        { key: "escape", action: () => CalculatorValue.set("") },
      ],
    },
  },
  logo$8 = "./assets/donut-041054d9.png";
let A = 1,
  B = 1;
function tick$1() {
  const $ = [],
    r = [];
  (A += 0.07), (B += 0.03);
  let p = Math.cos(A),
    v = Math.sin(A),
    k = Math.cos(B),
    x = Math.sin(B);
  for (let S = 0; S < 1760; S++)
    ($[S] =
      S % 80 == 79
        ? `
`
        : " "),
      (r[S] = 0);
  for (let S = 0; S < 6.28; S += 0.07) {
    let I = Math.cos(S),
      F = Math.sin(S);
    for (let O = 0; O < 6.28; O += 0.02) {
      let L = Math.sin(O),
        U = Math.cos(O),
        N = I + 2,
        j = 1 / (L * N * v + F * p + 5),
        R = L * N * p - F * v,
        q = 0 | (40 + 30 * j * (U * N * k - R * x)),
        Q = 0 | (12 + 15 * j * (U * N * x + R * k)),
        K = q + 80 * Q,
        V = 0 | (8 * ((F * v - L * I * p) * k - L * I * v - F * p - U * I * x));
      Q < 22 &&
        Q >= 0 &&
        q >= 0 &&
        q < 79 &&
        j > r[K] &&
        ((r[K] = j), ($[K] = ".,-~:;=!*#$@"[V > 0 ? V : 0]));
      const H = {
        o: K,
        A,
        B,
        N: V,
        st: F,
        sA: v,
        sp: L,
        ct: I,
        cA: p,
        cB: k,
        cp: U,
        sB: x,
        D: j,
        t: R,
        h: N,
        i: O,
        j: S,
        x: q,
        y: Q,
        cycles: (A / 0.07 / 89.71428571428571).toFixed(2),
      };
      donutDebugInformation.set(H);
    }
  }
  return $.join("");
}
const donutDebugInformation = writable(),
  Donut_svelte_svelte_type_style_lang = "";
function get_each_context$M($, r, p) {
  const v = $.slice();
  return (v[3] = r[p]), v;
}
function create_if_block$1o($) {
  let r,
    p = Object.entries($[1]),
    v = [];
  for (let k = 0; k < p.length; k += 1)
    v[k] = create_each_block$M(get_each_context$M($, p, k));
  return {
    c() {
      for (let k = 0; k < v.length; k += 1) v[k].c();
      r = empty();
    },
    m(k, x) {
      for (let S = 0; S < v.length; S += 1) v[S] && v[S].m(k, x);
      insert(k, r, x);
    },
    p(k, x) {
      if (x & 2) {
        p = Object.entries(k[1]);
        let S;
        for (S = 0; S < p.length; S += 1) {
          const I = get_each_context$M(k, p, S);
          v[S]
            ? v[S].p(I, x)
            : ((v[S] = create_each_block$M(I)),
              v[S].c(),
              v[S].m(r.parentNode, r));
        }
        for (; S < v.length; S += 1) v[S].d(1);
        v.length = p.length;
      }
    },
    d(k) {
      destroy_each(v, k), k && detach(r);
    },
  };
}
function create_else_block$t($) {
  let r = $[3][1] + "",
    p;
  return {
    c() {
      p = text(r);
    },
    m(v, k) {
      insert(v, p, k);
    },
    p(v, k) {
      k & 2 && r !== (r = v[3][1] + "") && set_data(p, r);
    },
    d(v) {
      v && detach(p);
    },
  };
}
function create_if_block_1$r($) {
  let r = $[3][1].toFixed(8) + "",
    p;
  return {
    c() {
      p = text(r);
    },
    m(v, k) {
      insert(v, p, k);
    },
    p(v, k) {
      k & 2 && r !== (r = v[3][1].toFixed(8) + "") && set_data(p, r);
    },
    d(v) {
      v && detach(p);
    },
  };
}
function create_each_block$M($) {
  let r,
    p,
    v = $[3][0] + "",
    k,
    x,
    S,
    I;
  function F(U, N) {
    return typeof U[3][1] == "number"
      ? create_if_block_1$r
      : create_else_block$t;
  }
  let O = F($),
    L = O($);
  return {
    c() {
      (r = element("tr")),
        (p = element("td")),
        (k = text(v)),
        (x = space()),
        (S = element("td")),
        L.c(),
        (I = space()),
        attr(p, "class", "svelte-u78920"),
        attr(S, "class", "svelte-u78920"),
        attr(r, "class", "svelte-u78920");
    },
    m(U, N) {
      insert(U, r, N),
        append(r, p),
        append(p, k),
        append(r, x),
        append(r, S),
        L.m(S, null),
        append(r, I);
    },
    p(U, N) {
      N & 2 && v !== (v = U[3][0] + "") && set_data(k, v),
        O === (O = F(U)) && L
          ? L.p(U, N)
          : (L.d(1), (L = O(U)), L && (L.c(), L.m(S, null)));
    },
    d(U) {
      U && detach(r), L.d();
    },
  };
}
function create_fragment$3N($) {
  let r,
    p,
    v,
    k,
    x,
    S = $[1] && create_if_block$1o($);
  return {
    c() {
      (r = element("div")),
        (p = element("pre")),
        (v = text($[0])),
        (k = space()),
        (x = element("table")),
        S && S.c(),
        attr(p, "class", "svelte-u78920"),
        attr(x, "class", "svelte-u78920"),
        attr(r, "data-caller", "donut-target"),
        attr(r, "class", "svelte-u78920");
    },
    m(I, F) {
      insert(I, r, F),
        append(r, p),
        append(p, v),
        append(r, k),
        append(r, x),
        S && S.m(x, null);
    },
    p(I, [F]) {
      F & 1 && set_data(v, I[0]),
        I[1]
          ? S
            ? S.p(I, F)
            : ((S = create_if_block$1o(I)), S.c(), S.m(x, null))
          : S && (S.d(1), (S = null));
    },
    i: noop$1,
    o: noop$1,
    d(I) {
      I && detach(r), S && S.d();
    },
  };
}
let fps = 30;
function instance$3u($, r, p) {
  let v, k;
  component_subscribe($, donutSpinning, (S) => p(2, (v = S))),
    component_subscribe($, donutDebugInformation, (S) => p(1, (k = S)));
  let x = "";
  return (
    setInterval(() => {
      v && p(0, (x = tick$1()));
    }, 1e3 / fps),
    [x, k]
  );
}
class Donut extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3u, create_fragment$3N, safe_not_equal, {});
  }
}
const DonutApp = {
    info: {
      name: "Donut",
      description: "A spinning ASCII donut",
      builtin: !0,
      version: ArcOSVersion,
      author: "Andy Sloane (ArcOS port by IzK)",
      icon: logo$8,
    },
    size: { w: 850, h: 520 },
    pos: { x: 30, y: 40 },
    minSize: { w: 850, h: 520 },
    maxSize: { w: 850, h: NaN },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: Donut,
    glass: !0,
    events: {
      open() {
        donutSpinning.set(!0);
      },
      close() {
        donutSpinning.set(!1);
      },
      blur() {
        donutSpinning.set(!1);
      },
      focus() {
        donutSpinning.set(!0);
      },
    },
  },
  donutSpinning = writable(!1);
function create_fragment$3M($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K;
  return {
    c() {
      (r = element("p")),
        (r.textContent =
          "Specify the title and message to create an error message:"),
        (p = space()),
        (v = element("br")),
        (k = space()),
        (x = element("input")),
        (S = space()),
        (I = element("input")),
        (F = space()),
        (O = element("input")),
        (L = space()),
        (U = element("input")),
        (N = space()),
        (j = element("button")),
        (R = text("Create")),
        attr(x, "placeholder", "title"),
        attr(x, "class", "fullwidth"),
        attr(I, "placeholder", "message"),
        attr(I, "class", "fullwidth"),
        attr(O, "placeholder", "button caption 1"),
        attr(O, "class", "fullwidth"),
        attr(U, "placeholder", "button caption 2"),
        attr(U, "class", "fullwidth"),
        (j.disabled = q = !$[0] || !$[1]);
    },
    m(V, H) {
      insert(V, r, H),
        insert(V, p, H),
        insert(V, v, H),
        insert(V, k, H),
        insert(V, x, H),
        set_input_value(x, $[0]),
        insert(V, S, H),
        insert(V, I, H),
        set_input_value(I, $[1]),
        insert(V, F, H),
        insert(V, O, H),
        set_input_value(O, $[2]),
        insert(V, L, H),
        insert(V, U, H),
        set_input_value(U, $[3]),
        insert(V, N, H),
        insert(V, j, H),
        append(j, R),
        Q ||
          ((K = [
            listen(x, "input", $[5]),
            listen(I, "input", $[6]),
            listen(O, "input", $[7]),
            listen(U, "input", $[8]),
            listen(j, "click", $[4]),
          ]),
          (Q = !0));
    },
    p(V, [H]) {
      H & 1 && x.value !== V[0] && set_input_value(x, V[0]),
        H & 2 && I.value !== V[1] && set_input_value(I, V[1]),
        H & 4 && O.value !== V[2] && set_input_value(O, V[2]),
        H & 8 && U.value !== V[3] && set_input_value(U, V[3]),
        H & 3 && q !== (q = !V[0] || !V[1]) && (j.disabled = q);
    },
    i: noop$1,
    o: noop$1,
    d(V) {
      V && detach(r),
        V && detach(p),
        V && detach(v),
        V && detach(k),
        V && detach(x),
        V && detach(S),
        V && detach(I),
        V && detach(F),
        V && detach(O),
        V && detach(L),
        V && detach(U),
        V && detach(N),
        V && detach(j),
        (Q = !1),
        run_all(K);
    },
  };
}
function instance$3t($, r, p) {
  let v, k, x, S;
  function I() {
    errorMessage(
      v,
      k,
      null,
      "ErrCre",
      { caption: x, action: () => {} },
      { caption: S, action: () => {} }
    );
  }
  function F() {
    (v = this.value), p(0, v);
  }
  function O() {
    (k = this.value), p(1, k);
  }
  function L() {
    (x = this.value), p(2, x);
  }
  function U() {
    (S = this.value), p(3, S);
  }
  return [v, k, x, S, I, F, O, L, U];
}
let ErrorCreator$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3t, create_fragment$3M, safe_not_equal, {});
  }
};
const ErrorCreator = {
    info: {
      name: "Error Message Summoner",
      description: "Use for testing only -- error message creator",
      builtin: !0,
      version: ArcOSVersion,
      author: "Izaak Kuipers",
      icon: warning,
      hidden: !0,
    },
    size: { w: 300, h: 267 },
    pos: { x: 30, y: 40 },
    minSize: { w: 300, h: 253 },
    maxSize: { w: 300, h: 253 },
    controls: { min: !0, max: !1, cls: !0 },
    state: {
      headless: !1,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: ErrorCreator$1,
    glass: !0,
  },
  exit = "",
  selectedMessageId = writable(null),
  replyMessageId = writable(null),
  threadMessageId = writable(null),
  creatingMessage = writable(!1);
async function getMessages() {
  const $ = get_store_value(ConnectedServer);
  if (!$) return [];
  const r = await apiCall($, "messages/list", {}, get_store_value(UserToken));
  return r.valid ? r.data : [];
}
async function getMessage($) {
  const r = get_store_value(ConnectedServer);
  if (!r) return !1;
  const p = await apiCall(
    r,
    "messages/get",
    { id: btoa($) },
    get_store_value(UserToken)
  );
  return p.valid ? p.data : !1;
}
function create_if_block$1n($) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.innerHTML = `<span class="material-icons-round">terminal</span> 
        <p class="caption">ArcTerm</p>`),
        attr(r, "class", "option");
    },
    m(k, x) {
      insert(k, r, x), p || ((v = listen(r, "click", $[2])), (p = !0));
    },
    p: noop$1,
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_fragment$3L($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U,
    N,
    j,
    R,
    q = $[0] && create_if_block$1n($);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("h3")),
        (v.textContent = "ArcOS"),
        (k = space()),
        (x = element("button")),
        (x.innerHTML = `<span class="material-icons-round">power_settings_new</span> 
      <p class="caption">Shutdown</p>`),
        (S = space()),
        (I = element("button")),
        (I.innerHTML = `<span class="material-icons-round">logout</span> 
      <p class="caption">Logoff</p>`),
        (F = space()),
        (O = element("button")),
        (O.innerHTML = `<span class="material-icons-round">refresh</span> 
      <p class="caption">Restart</p>`),
        (L = space()),
        q && q.c(),
        (U = space()),
        (N = element("button")),
        (N.textContent = "Cancel"),
        attr(v, "class", "header"),
        attr(x, "class", "option"),
        attr(I, "class", "option"),
        attr(O, "class", "option"),
        attr(N, "class", "cancel"),
        attr(p, "class", "flex-stop"),
        attr(r, "class", "center-flex");
    },
    m(Q, K) {
      insert(Q, r, K),
        append(r, p),
        append(p, v),
        append(p, k),
        append(p, x),
        append(p, S),
        append(p, I),
        append(p, F),
        append(p, O),
        append(p, L),
        q && q.m(p, null),
        append(p, U),
        append(p, N),
        j ||
          ((R = [
            listen(x, "click", shutdown),
            listen(I, "click", $[4]),
            listen(O, "click", $[5]),
            listen(N, "click", $[1]),
          ]),
          (j = !0));
    },
    p(Q, [K]) {
      Q[0]
        ? q
          ? q.p(Q, K)
          : ((q = create_if_block$1n(Q)), q.c(), q.m(p, U))
        : q && (q.d(1), (q = null));
    },
    i: noop$1,
    o: noop$1,
    d(Q) {
      Q && detach(r), q && q.d(), (j = !1), run_all(R);
    },
  };
}
function instance$3s($, r, p) {
  let v;
  component_subscribe($, ExitShowAT, (O) => p(0, (v = O)));
  let { app: k } = r;
  function x() {
    isFullscreenWindow.set(!1), closeWindow(k.id);
  }
  function S() {
    FileBrowserCurrentDir.set("./"),
      FileBrowserSelectedFilename.set(null),
      FileBrowserDirContents.set(defaultDirectory),
      FileBrowserDeletingFilename.set(null),
      NotificationStore.set({}),
      ErrorWindowStore.set([]),
      ErrorMessages.set([]),
      WindowStore.set([]),
      selectedMessageId.set(null),
      applyState("arcterm");
  }
  const I = () => restart$1(!0),
    F = () => restart$1(!1);
  return (
    ($.$$set = (O) => {
      "app" in O && p(3, (k = O.app));
    }),
    [v, x, S, k, I, F]
  );
}
let Exit$2 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3s, create_fragment$3L, safe_not_equal, {
        app: 3,
      });
  }
};
const Exit$1 = {
    info: {
      name: "Exit",
      description: "ArcOS Exit Menu",
      builtin: !0,
      version: "2.0.0",
      author: "Izaak Kuipers",
      icon: shutdownIcon,
      hidden: !0,
    },
    size: { w: 280, h: 50 },
    pos: { x: 30, y: 40 },
    minSize: { w: 280, h: 50 },
    maxSize: { w: 280, h: 50 },
    controls: { min: !1, max: !1, cls: !0 },
    state: {
      headless: !0,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !0 },
    },
    content: Exit$2,
    glass: !0,
    events: {
      keyboardShortcuts: [
        {
          shift: !0,
          key: "",
          action() {
            ExitShowAT.set(!0);
          },
        },
      ],
      close($) {
        ExitShowAT.set(!1);
      },
    },
  },
  ExitShowAT = writable(!1),
  fileManager = "./assets/filemanager-cb441701.svg",
  filebrowser = "";
function getParentDirectory($) {
  const r = $.split("/");
  return $ == "./" || !r.length
    ? $
    : r.length == 1
    ? "./"
    : (r.splice(-1), r.join("/"));
}
function closeFile($) {
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++) r[p].id == $ && (r[p].openedFile = null);
  WindowStore.set(r);
}
const spinner$1 = "",
  spinner = "./assets/spinner-14f81f00.svg";
function create_fragment$3K($) {
  let r, p;
  return {
    c() {
      (r = element("img")),
        src_url_equal(r.src, (p = spinner)) || attr(r, "src", p),
        attr(r, "alt", "spinner"),
        set_style(r, "height", $[0] + "px"),
        attr(r, "class", "spinner-svg");
    },
    m(v, k) {
      insert(v, r, k);
    },
    p(v, [k]) {
      k & 1 && set_style(r, "height", v[0] + "px");
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      v && detach(r);
    },
  };
}
function instance$3r($, r, p) {
  let { height: v } = r;
  return (
    ($.$$set = (k) => {
      "height" in k && p(0, (v = k.height));
    }),
    [v]
  );
}
class Spinner extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3r, create_fragment$3K, safe_not_equal, {
        height: 0,
      });
  }
}
const folder = "./assets/folder-f520676e.svg";
function create_fragment$3J($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F = $[0].name + "",
    O,
    L,
    U,
    N,
    j,
    R,
    q,
    Q,
    K;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (I = element("div")),
        (O = text(F)),
        (L = space()),
        (U = element("div")),
        (U.textContent = "Folder"),
        (N = space()),
        (j = element("div")),
        (j.textContent = "-"),
        src_url_equal(v.src, (k = folder)) || attr(v, "src", k),
        attr(v, "alt", (x = $[0].name)),
        attr(p, "class", "image"),
        attr(I, "class", "name"),
        attr(U, "class", "mime"),
        attr(j, "class", "size"),
        attr(r, "class", "item dir"),
        attr(r, "data-path", (R = $[0].scopedPath)),
        attr(r, "data-type", "dir"),
        attr(r, "data-name", (q = $[0].name)),
        attr(r, "data-caller", "listitem-dir"),
        toggle_class(r, "selected", $[1] == $[0].name),
        toggle_class(r, "cutting", $[2] && $[2].name == $[0].name);
    },
    m(V, H) {
      insert(V, r, H),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, I),
        append(I, O),
        append(r, L),
        append(r, U),
        append(r, N),
        append(r, j),
        Q ||
          ((K = [listen(r, "click", $[3]), listen(r, "dblclick", $[4])]),
          (Q = !0));
    },
    p(V, [H]) {
      H & 1 && x !== (x = V[0].name) && attr(v, "alt", x),
        H & 1 && F !== (F = V[0].name + "") && set_data(O, F),
        H & 1 && R !== (R = V[0].scopedPath) && attr(r, "data-path", R),
        H & 1 && q !== (q = V[0].name) && attr(r, "data-name", q),
        H & 3 && toggle_class(r, "selected", V[1] == V[0].name),
        H & 5 && toggle_class(r, "cutting", V[2] && V[2].name == V[0].name);
    },
    i: noop$1,
    o: noop$1,
    d(V) {
      V && detach(r), (Q = !1), run_all(K);
    },
  };
}
function instance$3q($, r, p) {
  let v, k;
  component_subscribe($, FileBrowserSelectedFilename, (F) => p(1, (v = F))),
    component_subscribe($, FileBrowserCuttingFilename, (F) => p(2, (k = F)));
  let { dir: x } = r;
  function S() {
    set_store_value(FileBrowserSelectedFilename, (v = x.name), v);
  }
  function I() {
    fbClass.goToDirectory(x.scopedPath);
  }
  return (
    ($.$$set = (F) => {
      "dir" in F && p(0, (x = F.dir));
    }),
    [x, v, k, S, I]
  );
}
let Dir$4 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3q, create_fragment$3J, safe_not_equal, {
        dir: 0,
      });
  }
};
const icon$4 = "./assets/file-0d0c64f1.svg",
  file = "./assets/application-default-dbaaa566.svg",
  imgIcon = "./assets/image-x-generic-0c29fb59.svg",
  svgIcon = "./assets/application-svg-944fd245.svg",
  pdfIcon = "./assets/application-pdf-7a1f0afa.svg",
  arcAppI = "./assets/application-arcapp-2a8df358.svg",
  jsonIcon = "./assets/application-json-e04d619a.svg",
  archiveIcon = "./assets/application-x-compress-98d85b80.svg",
  icon$3 = "./assets/markdownviewer-a03d6bb8.svg",
  soundIcon = "./assets/audio-x-generic-73f31c65.svg",
  logo$7 = "./assets/arcterm-b608c3ab.svg",
  extensionIcons = [
    {
      extensions: [".png", ".jpg", ".bmp", ".gif", ".ico", ".webp"],
      image: imgIcon,
    },
    { extensions: [".svg"], image: svgIcon },
    { extensions: [".md"], image: icon$3 },
    { extensions: [".app", ".ealc", ".app.json"], image: arcAppI },
    { extensions: [".pdf"], image: pdfIcon },
    { extensions: [".txt"], image: fileIcon },
    { extensions: [".json"], image: jsonIcon },
    {
      extensions: [".zip", ".tar", ".tar.gz", ".7z", ".rar"],
      image: archiveIcon,
    },
    { extensions: [".flac", ".mp3", ".wav"], image: soundIcon },
    { extensions: [".arctheme"], image: themeIcon },
    { extensions: ["arcterm.conf"], image: logo$7 },
  ];
function getMimeIcon($) {
  for (let r = 0; r < extensionIcons.length; r++) {
    const p = extensionIcons[r].extensions;
    for (let v = 0; v < p.length; v++)
      if ($.endsWith(p[v])) return extensionIcons[r].image;
  }
  return file;
}
const sizeUnits = ["bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
function formatBytes($) {
  let r = 0,
    p = $;
  for (; p >= 1024 && ++r; ) p = p / 1024;
  return p.toFixed(p < 10 && r > 0 ? 1 : 0) + " " + sizeUnits[r];
}
function create_fragment$3I($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F = $[0].filename + "",
    O,
    L,
    U,
    N = $[0].mime.split("; ")[0].split("/").join(" - ") + "",
    j,
    R,
    q,
    Q = formatBytes($[0].size) + "",
    K,
    V,
    H,
    G,
    Y,
    J,
    Z,
    X,
    ee;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (I = element("div")),
        (O = text(F)),
        (L = space()),
        (U = element("div")),
        (j = text(N)),
        (R = space()),
        (q = element("div")),
        (K = text(Q)),
        (V = space()),
        (H = element("div")),
        (G = element("button")),
        (G.textContent = "launch"),
        src_url_equal(v.src, (k = $[1])) || attr(v, "src", k),
        attr(v, "alt", (x = $[0].filename)),
        attr(p, "class", "image"),
        attr(I, "class", "name"),
        attr(U, "class", "mime"),
        attr(q, "class", "size"),
        attr(G, "class", "material-icons-round"),
        attr(H, "class", "options"),
        attr(r, "class", "item file"),
        attr(r, "title", (Y = $[0].scopedPath)),
        attr(r, "data-path", (J = $[0].scopedPath)),
        attr(r, "data-type", "file"),
        attr(r, "data-name", (Z = $[0].filename)),
        attr(r, "data-caller", "listitem-file"),
        toggle_class(r, "selected", $[2] == $[0].filename),
        toggle_class(r, "cutting", $[3] && $[3].name == $[0].filename);
    },
    m(te, ie) {
      insert(te, r, ie),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, I),
        append(I, O),
        append(r, L),
        append(r, U),
        append(U, j),
        append(r, R),
        append(r, q),
        append(q, K),
        append(r, V),
        append(r, H),
        append(H, G),
        X ||
          ((ee = [
            listen(G, "click", $[6]),
            listen(r, "click", $[4]),
            listen(r, "contextmenu", $[4]),
            listen(r, "dblclick", $[5]),
          ]),
          (X = !0));
    },
    p(te, [ie]) {
      ie & 2 && !src_url_equal(v.src, (k = te[1])) && attr(v, "src", k),
        ie & 1 && x !== (x = te[0].filename) && attr(v, "alt", x),
        ie & 1 && F !== (F = te[0].filename + "") && set_data(O, F),
        ie & 1 &&
          N !== (N = te[0].mime.split("; ")[0].split("/").join(" - ") + "") &&
          set_data(j, N),
        ie & 1 && Q !== (Q = formatBytes(te[0].size) + "") && set_data(K, Q),
        ie & 1 && Y !== (Y = te[0].scopedPath) && attr(r, "title", Y),
        ie & 1 && J !== (J = te[0].scopedPath) && attr(r, "data-path", J),
        ie & 1 && Z !== (Z = te[0].filename) && attr(r, "data-name", Z),
        ie & 5 && toggle_class(r, "selected", te[2] == te[0].filename),
        ie & 9 &&
          toggle_class(r, "cutting", te[3] && te[3].name == te[0].filename);
    },
    i: noop$1,
    o: noop$1,
    d(te) {
      te && detach(r), (X = !1), run_all(ee);
    },
  };
}
function instance$3p($, r, p) {
  let v, k, x;
  component_subscribe($, FileBrowserOpeningFile, (N) => p(7, (v = N))),
    component_subscribe($, FileBrowserSelectedFilename, (N) => p(2, (k = N))),
    component_subscribe($, FileBrowserCuttingFilename, (N) => p(3, (x = N)));
  let { file: S } = r,
    I = icon$4;
  function F() {
    set_store_value(FileBrowserSelectedFilename, (k = S.filename), k);
  }
  async function O() {
    set_store_value(FileBrowserOpeningFile, (v = S), v),
      showOverlay("openingFile", "FileManager");
    let N = await openUserFile(S);
    if (
      (hideOverlay("openingFile", "FileManager"),
      set_store_value(FileBrowserOpeningFile, (v = null), v),
      N != !0)
    ) {
      const j = N;
      createOverlayableError(
        {
          title: `Unable to open ${S.filename}`,
          message:
            "You don't have an app or handler that can open this type of file.",
          buttons: [
            {
              caption: "Close",
              action: () => {
                N = null;
              },
            },
            { caption: "Open With...", action: () => L(j) },
          ],
          image: icon$4,
        },
        "FileManager"
      );
    }
    N = null;
  }
  function L(N) {
    openWithDialog({ ...N, anymime: !0 });
  }
  async function U() {
    set_store_value(FileBrowserOpeningFile, (v = S), v),
      showOverlay("openingFile", "FileManager");
    let N = {
      data: await readFile(S.scopedPath),
      name: S.filename,
      path: S.scopedPath,
      mime: S.mime,
    };
    L(N),
      hideOverlay("openingFile", "FileManager"),
      set_store_value(FileBrowserOpeningFile, (v = S), v);
  }
  return (
    onMount(() => {
      p(1, (I = getMimeIcon(S.filename)));
    }),
    FileBrowserDirContents.subscribe(() => p(1, (I = getMimeIcon(S.filename)))),
    ($.$$set = (N) => {
      "file" in N && p(0, (S = N.file));
    }),
    [S, I, k, x, F, O, U]
  );
}
let File$3 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3p, create_fragment$3I, safe_not_equal, {
        file: 0,
      });
  }
};
function create_fragment$3H($) {
  let r;
  return {
    c() {
      (r = element("button")),
        (r.innerHTML = `<div class="image"></div> 
  <div class="name">Name</div> 
  <div class="mime">Type</div> 
  <div class="size">Size</div>`),
        attr(r, "class", "item head");
    },
    m(p, v) {
      insert(p, r, v);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
class TopRow extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$3H, safe_not_equal, {});
  }
}
function get_each_context$L($, r, p) {
  const v = $.slice();
  return (v[3] = r[p]), v;
}
function get_each_context_1$9($, r, p) {
  const v = $.slice();
  return (v[6] = r[p]), v;
}
function create_else_block_1$2($) {
  let r, p, v, k, x, S;
  p = new TopRow({});
  let I = $[1],
    F = [];
  for (let j = 0; j < I.length; j += 1)
    F[j] = create_each_block_1$9(get_each_context_1$9($, I, j));
  const O = (j) =>
    transition_out(F[j], 1, 1, () => {
      F[j] = null;
    });
  let L = $[0],
    U = [];
  for (let j = 0; j < L.length; j += 1)
    U[j] = create_each_block$L(get_each_context$L($, L, j));
  const N = (j) =>
    transition_out(U[j], 1, 1, () => {
      U[j] = null;
    });
  return {
    c() {
      (r = element("div")),
        create_component(p.$$.fragment),
        (v = space()),
        (k = element("div"));
      for (let j = 0; j < F.length; j += 1) F[j].c();
      x = space();
      for (let j = 0; j < U.length; j += 1) U[j].c();
      attr(k, "class", "items"), attr(r, "class", "listview");
    },
    m(j, R) {
      insert(j, r, R), mount_component(p, r, null), append(r, v), append(r, k);
      for (let q = 0; q < F.length; q += 1) F[q] && F[q].m(k, null);
      append(k, x);
      for (let q = 0; q < U.length; q += 1) U[q] && U[q].m(k, null);
      S = !0;
    },
    p(j, R) {
      if (R & 2) {
        I = j[1];
        let q;
        for (q = 0; q < I.length; q += 1) {
          const Q = get_each_context_1$9(j, I, q);
          F[q]
            ? (F[q].p(Q, R), transition_in(F[q], 1))
            : ((F[q] = create_each_block_1$9(Q)),
              F[q].c(),
              transition_in(F[q], 1),
              F[q].m(k, x));
        }
        for (group_outros(), q = I.length; q < F.length; q += 1) O(q);
        check_outros();
      }
      if (R & 1) {
        L = j[0];
        let q;
        for (q = 0; q < L.length; q += 1) {
          const Q = get_each_context$L(j, L, q);
          U[q]
            ? (U[q].p(Q, R), transition_in(U[q], 1))
            : ((U[q] = create_each_block$L(Q)),
              U[q].c(),
              transition_in(U[q], 1),
              U[q].m(k, null));
        }
        for (group_outros(), q = L.length; q < U.length; q += 1) N(q);
        check_outros();
      }
    },
    i(j) {
      if (!S) {
        transition_in(p.$$.fragment, j);
        for (let R = 0; R < I.length; R += 1) transition_in(F[R]);
        for (let R = 0; R < L.length; R += 1) transition_in(U[R]);
        S = !0;
      }
    },
    o(j) {
      transition_out(p.$$.fragment, j), (F = F.filter(Boolean));
      for (let R = 0; R < F.length; R += 1) transition_out(F[R]);
      U = U.filter(Boolean);
      for (let R = 0; R < U.length; R += 1) transition_out(U[R]);
      S = !1;
    },
    d(j) {
      j && detach(r),
        destroy_component(p),
        destroy_each(F, j),
        destroy_each(U, j);
    },
  };
}
function create_if_block$1m($) {
  let r, p, v, k;
  const x = [create_if_block_1$q, create_else_block$s],
    S = [];
  function I(F, O) {
    return F[2] ? 0 : 1;
  }
  return (
    (r = I($)),
    (p = S[r] = x[r]($)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        S[r].m(F, O), insert(F, v, O), (k = !0);
      },
      p(F, O) {
        let L = r;
        (r = I(F)),
          r !== L &&
            (group_outros(),
            transition_out(S[L], 1, 1, () => {
              S[L] = null;
            }),
            check_outros(),
            (p = S[r]),
            p || ((p = S[r] = x[r](F)), p.c()),
            transition_in(p, 1),
            p.m(v.parentNode, v));
      },
      i(F) {
        k || (transition_in(p), (k = !0));
      },
      o(F) {
        transition_out(p), (k = !1);
      },
      d(F) {
        S[r].d(F), F && detach(v);
      },
    }
  );
}
function create_each_block_1$9($) {
  let r, p;
  return (
    (r = new Dir$4({ props: { dir: $[6] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 2 && (x.dir = v[6]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$L($) {
  let r, p;
  return (
    (r = new File$3({ props: { file: $[3] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.file = v[3]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_else_block$s($) {
  let r;
  return {
    c() {
      (r = element("div")),
        (r.textContent = "This folder is empty."),
        attr(r, "class", "nofiles");
    },
    m(p, v) {
      insert(p, r, v);
    },
    i: noop$1,
    o: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
function create_if_block_1$q($) {
  let r, p, v, k, x, S;
  return (
    (v = new Spinner({ props: { height: 32 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          create_component(v.$$.fragment),
          (k = space()),
          (x = element("p")),
          (x.textContent = "Reading items..."),
          attr(x, "class", "caption"),
          attr(p, "class", "loading-inner"),
          attr(r, "class", "loading");
      },
      m(I, F) {
        insert(I, r, F),
          append(r, p),
          mount_component(v, p, null),
          append(p, k),
          append(p, x),
          (S = !0);
      },
      i(I) {
        S || (transition_in(v.$$.fragment, I), (S = !0));
      },
      o(I) {
        transition_out(v.$$.fragment, I), (S = !1);
      },
      d(I) {
        I && detach(r), destroy_component(v);
      },
    }
  );
}
function create_fragment$3G($) {
  let r, p, v, k;
  const x = [create_if_block$1m, create_else_block_1$2],
    S = [];
  function I(F, O) {
    return !F[1].length && !F[0].length ? 0 : 1;
  }
  return (
    (r = I($)),
    (p = S[r] = x[r]($)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        S[r].m(F, O), insert(F, v, O), (k = !0);
      },
      p(F, [O]) {
        let L = r;
        (r = I(F)),
          r === L
            ? S[r].p(F, O)
            : (group_outros(),
              transition_out(S[L], 1, 1, () => {
                S[L] = null;
              }),
              check_outros(),
              (p = S[r]),
              p ? p.p(F, O) : ((p = S[r] = x[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        k || (transition_in(p), (k = !0));
      },
      o(F) {
        transition_out(p), (k = !1);
      },
      d(F) {
        S[r].d(F), F && detach(v);
      },
    }
  );
}
function instance$3o($, r, p) {
  let v;
  component_subscribe($, FileBrowserRefreshing, (S) => p(2, (v = S)));
  let { files: k = [] } = r,
    { dirs: x = [] } = r;
  return (
    ($.$$set = (S) => {
      "files" in S && p(0, (k = S.files)), "dirs" in S && p(1, (x = S.dirs));
    }),
    [k, x, v]
  );
}
class ListView extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3o, create_fragment$3G, safe_not_equal, {
        files: 0,
        dirs: 1,
      });
  }
}
function create_if_block$1l($) {
  let r, p, v, k;
  return {
    c() {
      (r = element("button")), (p = text($[0])), attr(r, "class", "crumb");
    },
    m(x, S) {
      insert(x, r, S),
        append(r, p),
        v || ((k = listen(r, "click", $[1])), (v = !0));
    },
    p(x, S) {
      S & 1 && set_data(p, x[0]);
    },
    d(x) {
      x && detach(r), (v = !1), k();
    },
  };
}
function create_fragment$3F($) {
  let r,
    p = $[0] && $[0] != "." && create_if_block$1l($);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, k) {
      p && p.m(v, k), insert(v, r, k);
    },
    p(v, [k]) {
      v[0] && v[0] != "."
        ? p
          ? p.p(v, k)
          : ((p = create_if_block$1l(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$3n($, r, p) {
  let { crumb: v } = r,
    { path: k } = r;
  function x() {
    fbClass.goToDirectory(k);
  }
  return (
    ($.$$set = (S) => {
      "crumb" in S && p(0, (v = S.crumb)), "path" in S && p(2, (k = S.path));
    }),
    [v, x, k]
  );
}
let Crumb$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3n, create_fragment$3F, safe_not_equal, {
        crumb: 0,
        path: 2,
      });
  }
};
function get_each_context$K($, r, p) {
  const v = $.slice();
  return (v[4] = r[p]), (v[6] = p), v;
}
function create_each_block$K($) {
  let r, p;
  return (
    (r = new Crumb$1({ props: { crumb: $[4], path: $[2]($[4], $[6]) } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.crumb = v[4]),
          k & 1 && (x.path = v[2](v[4], v[6])),
          r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$3E($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O = $[0],
    L = [];
  for (let N = 0; N < O.length; N += 1)
    L[N] = create_each_block$K(get_each_context$K($, O, N));
  const U = (N) =>
    transition_out(L[N], 1, 1, () => {
      L[N] = null;
    });
  return {
    c() {
      (r = element("button")),
        (r.textContent = "home"),
        (p = space()),
        (v = element("div"));
      for (let N = 0; N < L.length; N += 1) L[N].c();
      (k = space()),
        (x = element("button")),
        (x.textContent = "refresh"),
        attr(r, "class", "home material-icons-round"),
        attr(v, "class", "addressbar"),
        attr(x, "class", "refresh material-icons-round");
    },
    m(N, j) {
      insert(N, r, j), insert(N, p, j), insert(N, v, j);
      for (let R = 0; R < L.length; R += 1) L[R] && L[R].m(v, null);
      insert(N, k, j),
        insert(N, x, j),
        (S = !0),
        I ||
          ((F = [listen(r, "click", $[1]), listen(x, "click", $[3])]),
          (I = !0));
    },
    p(N, [j]) {
      if (j & 5) {
        O = N[0];
        let R;
        for (R = 0; R < O.length; R += 1) {
          const q = get_each_context$K(N, O, R);
          L[R]
            ? (L[R].p(q, j), transition_in(L[R], 1))
            : ((L[R] = create_each_block$K(q)),
              L[R].c(),
              transition_in(L[R], 1),
              L[R].m(v, null));
        }
        for (group_outros(), R = O.length; R < L.length; R += 1) U(R);
        check_outros();
      }
    },
    i(N) {
      if (!S) {
        for (let j = 0; j < O.length; j += 1) transition_in(L[j]);
        S = !0;
      }
    },
    o(N) {
      L = L.filter(Boolean);
      for (let j = 0; j < L.length; j += 1) transition_out(L[j]);
      S = !1;
    },
    d(N) {
      N && detach(r),
        N && detach(p),
        N && detach(v),
        destroy_each(L, N),
        N && detach(k),
        N && detach(x),
        (I = !1),
        run_all(F);
    },
  };
}
function instance$3m($, r, p) {
  let v = [];
  FileBrowserCurrentDir.subscribe((I) => {
    p(0, (v = I.split("/")));
  });
  function k() {
    fbClass.goToDirectory("./");
  }
  function x(I, F) {
    let O = "";
    for (let L = 0; L < F; L++) O += `${v[L]}/`;
    return `${O}${I}`;
  }
  return [v, k, x, () => fbClass.refresh()];
}
class PathCrumbs extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3m, create_fragment$3E, safe_not_equal, {});
  }
}
function create_fragment$3D($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I = $[0].name + "",
    F,
    O,
    L;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (x = space()),
        (S = element("p")),
        (F = text(I)),
        src_url_equal(p.src, (v = folder)) || attr(p, "src", v),
        attr(p, "alt", (k = $[0].name)),
        attr(S, "class", "name"),
        attr(r, "class", "folder"),
        toggle_class(r, "selected", $[1]);
    },
    m(U, N) {
      insert(U, r, N),
        append(r, p),
        append(r, x),
        append(r, S),
        append(S, F),
        O || ((L = listen(r, "click", $[2])), (O = !0));
    },
    p(U, [N]) {
      N & 1 && k !== (k = U[0].name) && attr(p, "alt", k),
        N & 1 && I !== (I = U[0].name + "") && set_data(F, I),
        N & 2 && toggle_class(r, "selected", U[1]);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r), (O = !1), L();
    },
  };
}
function instance$3l($, r, p) {
  let { folder: v } = r,
    k = !1;
  async function x() {
    fbClass.goToDirectory(v.scopedPath);
  }
  return (
    FileBrowserCurrentDir.subscribe((S) => {
      const I = S.replace("./", "");
      p(1, (k = I.startsWith(v.name)));
    }),
    ($.$$set = (S) => {
      "folder" in S && p(0, (v = S.folder));
    }),
    [v, k, x]
  );
}
class Folder extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3l, create_fragment$3D, safe_not_equal, {
        folder: 0,
      });
  }
}
const defaultQuota = { used: 0, max: 0, free: 0, username: "ArcOS" };
async function getFSQuota() {
  const $ = get_store_value(UserName),
    r = get_store_value(ConnectedServer);
  if (!r || !$) return defaultQuota;
  const p = await apiCall(r, "fs/quota", {}, get_store_value(UserToken));
  return p.valid ? p.data : defaultQuota;
}
function create_fragment$3C($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I = formatBytes($[0].used) + "",
    F,
    O,
    L,
    U,
    N = formatBytes($[0].max) + "",
    j;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("div")),
        (k = space()),
        (x = element("div")),
        (S = element("span")),
        (F = text(I)),
        (L = space()),
        (U = element("div")),
        (j = text(N)),
        attr(v, "class", "inner"),
        set_style(v, "width", $[1] + "%"),
        attr(p, "class", "bar"),
        attr(S, "title", (O = $[0].used + "B")),
        toggle_class(S, "invalid", $[0].used > $[0].max),
        attr(U, "class", "right"),
        attr(x, "class", "stat"),
        attr(r, "class", "quota-renderer");
    },
    m(R, q) {
      insert(R, r, q),
        append(r, p),
        append(p, v),
        append(r, k),
        append(r, x),
        append(x, S),
        append(S, F),
        append(x, L),
        append(x, U),
        append(U, j);
    },
    p(R, [q]) {
      q & 2 && set_style(v, "width", R[1] + "%"),
        q & 1 && I !== (I = formatBytes(R[0].used) + "") && set_data(F, I),
        q & 1 && O !== (O = R[0].used + "B") && attr(S, "title", O),
        q & 1 && toggle_class(S, "invalid", R[0].used > R[0].max),
        q & 1 && N !== (N = formatBytes(R[0].max) + "") && set_data(j, N);
    },
    i: noop$1,
    o: noop$1,
    d(R) {
      R && detach(r);
    },
  };
}
function instance$3k($, r, p) {
  let v = defaultQuota,
    k = 0;
  FileBrowserDirContents.subscribe(x);
  async function x() {
    p(0, (v = await getFSQuota())),
      p(1, (k = Math.round((100 / v.max) * v.used)));
  }
  return [v, k];
}
class QuotaRenderer extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3k, create_fragment$3C, safe_not_equal, {});
  }
}
function get_each_context$J($, r, p) {
  const v = $.slice();
  return (v[1] = r[p]), v;
}
function create_each_block$J($) {
  let r, p;
  return (
    (r = new Folder({ props: { folder: $[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.folder = v[1]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$3B($) {
  let r,
    p,
    v,
    k,
    x,
    S = $[0],
    I = [];
  for (let O = 0; O < S.length; O += 1)
    I[O] = create_each_block$J(get_each_context$J($, S, O));
  const F = (O) =>
    transition_out(I[O], 1, 1, () => {
      I[O] = null;
    });
  return (
    (k = new QuotaRenderer({})),
    {
      c() {
        (r = element("div")), (p = element("div"));
        for (let O = 0; O < I.length; O += 1) I[O].c();
        (v = space()),
          create_component(k.$$.fragment),
          attr(p, "class", "dirs"),
          attr(r, "class", "sidebar");
      },
      m(O, L) {
        insert(O, r, L), append(r, p);
        for (let U = 0; U < I.length; U += 1) I[U] && I[U].m(p, null);
        append(r, v), mount_component(k, r, null), (x = !0);
      },
      p(O, [L]) {
        if (L & 1) {
          S = O[0];
          let U;
          for (U = 0; U < S.length; U += 1) {
            const N = get_each_context$J(O, S, U);
            I[U]
              ? (I[U].p(N, L), transition_in(I[U], 1))
              : ((I[U] = create_each_block$J(N)),
                I[U].c(),
                transition_in(I[U], 1),
                I[U].m(p, null));
          }
          for (group_outros(), U = S.length; U < I.length; U += 1) F(U);
          check_outros();
        }
      },
      i(O) {
        if (!x) {
          for (let L = 0; L < S.length; L += 1) transition_in(I[L]);
          transition_in(k.$$.fragment, O), (x = !0);
        }
      },
      o(O) {
        I = I.filter(Boolean);
        for (let L = 0; L < I.length; L += 1) transition_out(I[L]);
        transition_out(k.$$.fragment, O), (x = !1);
      },
      d(O) {
        O && detach(r), destroy_each(I, O), destroy_component(k);
      },
    }
  );
}
function instance$3j($, r, p) {
  let v = [];
  return (
    FileBrowserDirContents.subscribe(async (k) => {
      p(0, (v = (await getDirectory("./")).directories));
    }),
    [v]
  );
}
let SideBar$3 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3j, create_fragment$3B, safe_not_equal, {});
  }
};
const tile = "";
function create_fragment$3A($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I = $[0].name + "",
    F,
    O,
    L;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (x = space()),
        (S = element("p")),
        (F = text(I)),
        src_url_equal(p.src, (v = folder)) || attr(p, "src", v),
        attr(p, "alt", (k = $[0].name)),
        attr(S, "class", "name"),
        attr(r, "class", "tile dir"),
        toggle_class(r, "selected", $[1] == $[0].name),
        toggle_class(r, "cutting", $[2] && $[2].name == $[0].name);
    },
    m(U, N) {
      insert(U, r, N),
        append(r, p),
        append(r, x),
        append(r, S),
        append(S, F),
        O ||
          ((L = [listen(r, "click", $[3]), listen(r, "dblclick", $[4])]),
          (O = !0));
    },
    p(U, [N]) {
      N & 1 && k !== (k = U[0].name) && attr(p, "alt", k),
        N & 1 && I !== (I = U[0].name + "") && set_data(F, I),
        N & 3 && toggle_class(r, "selected", U[1] == U[0].name),
        N & 5 && toggle_class(r, "cutting", U[2] && U[2].name == U[0].name);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r), (O = !1), run_all(L);
    },
  };
}
function instance$3i($, r, p) {
  let v, k;
  component_subscribe($, FileBrowserSelectedFilename, (F) => p(1, (v = F))),
    component_subscribe($, FileBrowserCuttingFilename, (F) => p(2, (k = F)));
  let { dir: x } = r;
  function S() {
    set_store_value(FileBrowserSelectedFilename, (v = x.name), v);
  }
  function I() {
    fbClass.goToDirectory(x.scopedPath);
  }
  return (
    ($.$$set = (F) => {
      "dir" in F && p(0, (x = F.dir));
    }),
    [x, v, k, S, I]
  );
}
let Dir$3 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3i, create_fragment$3A, safe_not_equal, {
        dir: 0,
      });
  }
};
function create_fragment$3z($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I = $[0].filename + "",
    F,
    O,
    L,
    U;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (x = space()),
        (S = element("p")),
        (F = text(I)),
        src_url_equal(p.src, (v = $[1])) || attr(p, "src", v),
        attr(p, "alt", (k = $[0].filename)),
        attr(S, "class", "name"),
        attr(r, "class", "tile file"),
        attr(r, "title", (O = $[0].scopedPath)),
        toggle_class(r, "selected", $[2] == $[0].filename),
        toggle_class(r, "cutting", $[3] && $[3].name == $[0].filename);
    },
    m(N, j) {
      insert(N, r, j),
        append(r, p),
        append(r, x),
        append(r, S),
        append(S, F),
        L ||
          ((U = [listen(r, "click", $[4]), listen(r, "dblclick", $[5])]),
          (L = !0));
    },
    p(N, [j]) {
      j & 2 && !src_url_equal(p.src, (v = N[1])) && attr(p, "src", v),
        j & 1 && k !== (k = N[0].filename) && attr(p, "alt", k),
        j & 1 && I !== (I = N[0].filename + "") && set_data(F, I),
        j & 1 && O !== (O = N[0].scopedPath) && attr(r, "title", O),
        j & 5 && toggle_class(r, "selected", N[2] == N[0].filename),
        j & 9 && toggle_class(r, "cutting", N[3] && N[3].name == N[0].filename);
    },
    i: noop$1,
    o: noop$1,
    d(N) {
      N && detach(r), (L = !1), run_all(U);
    },
  };
}
function instance$3h($, r, p) {
  let v, k, x;
  component_subscribe($, FileBrowserOpeningFile, (U) => p(6, (v = U))),
    component_subscribe($, FileBrowserSelectedFilename, (U) => p(2, (k = U))),
    component_subscribe($, FileBrowserCuttingFilename, (U) => p(3, (x = U)));
  let { file: S } = r,
    I = icon$4;
  function F() {
    set_store_value(FileBrowserSelectedFilename, (k = S.filename), k);
  }
  async function O() {
    set_store_value(FileBrowserOpeningFile, (v = S), v),
      showOverlay("openingFile", "FileManager");
    let U = await openUserFile(S);
    if (
      (hideOverlay("openingFile", "FileManager"),
      set_store_value(FileBrowserOpeningFile, (v = null), v),
      U != !0)
    ) {
      const N = U;
      createOverlayableError(
        {
          title: `Unable to open ${S.filename}`,
          message:
            "You don't have an app or handler that can open this type of file.",
          buttons: [
            {
              caption: "Close",
              action: () => {
                U = null;
              },
            },
            { caption: "Open With...", action: () => L(N) },
          ],
          image: icon$4,
        },
        "FileManager"
      );
    }
    U = null;
  }
  function L(U) {
    openWithDialog({ ...U, anymime: !0 });
  }
  return (
    onMount(() => {
      p(1, (I = getMimeIcon(S.filename)));
    }),
    FileBrowserDirContents.subscribe(() => p(1, (I = getMimeIcon(S.filename)))),
    ($.$$set = (U) => {
      "file" in U && p(0, (S = U.file));
    }),
    [S, I, k, x, F, O]
  );
}
let File$2 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3h, create_fragment$3z, safe_not_equal, {
        file: 0,
      });
  }
};
function get_each_context$I($, r, p) {
  const v = $.slice();
  return (v[3] = r[p]), v;
}
function get_each_context_1$8($, r, p) {
  const v = $.slice();
  return (v[6] = r[p]), v;
}
function create_else_block_1$1($) {
  let r,
    p,
    v,
    k = $[1].length && create_if_block_3$3($),
    x = $[0].length && create_if_block_2$6($);
  return {
    c() {
      (r = element("div")),
        k && k.c(),
        (p = space()),
        x && x.c(),
        attr(r, "class", "tileview");
    },
    m(S, I) {
      insert(S, r, I),
        k && k.m(r, null),
        append(r, p),
        x && x.m(r, null),
        (v = !0);
    },
    p(S, I) {
      S[1].length
        ? k
          ? (k.p(S, I), I & 2 && transition_in(k, 1))
          : ((k = create_if_block_3$3(S)),
            k.c(),
            transition_in(k, 1),
            k.m(r, p))
        : k &&
          (group_outros(),
          transition_out(k, 1, 1, () => {
            k = null;
          }),
          check_outros()),
        S[0].length
          ? x
            ? (x.p(S, I), I & 1 && transition_in(x, 1))
            : ((x = create_if_block_2$6(S)),
              x.c(),
              transition_in(x, 1),
              x.m(r, null))
          : x &&
            (group_outros(),
            transition_out(x, 1, 1, () => {
              x = null;
            }),
            check_outros());
    },
    i(S) {
      v || (transition_in(k), transition_in(x), (v = !0));
    },
    o(S) {
      transition_out(k), transition_out(x), (v = !1);
    },
    d(S) {
      S && detach(r), k && k.d(), x && x.d();
    },
  };
}
function create_if_block$1k($) {
  let r, p, v, k;
  const x = [create_if_block_1$p, create_else_block$r],
    S = [];
  function I(F, O) {
    return F[2] ? 0 : 1;
  }
  return (
    (r = I($)),
    (p = S[r] = x[r]($)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        S[r].m(F, O), insert(F, v, O), (k = !0);
      },
      p(F, O) {
        let L = r;
        (r = I(F)),
          r !== L &&
            (group_outros(),
            transition_out(S[L], 1, 1, () => {
              S[L] = null;
            }),
            check_outros(),
            (p = S[r]),
            p || ((p = S[r] = x[r](F)), p.c()),
            transition_in(p, 1),
            p.m(v.parentNode, v));
      },
      i(F) {
        k || (transition_in(p), (k = !0));
      },
      o(F) {
        transition_out(p), (k = !1);
      },
      d(F) {
        S[r].d(F), F && detach(v);
      },
    }
  );
}
function create_if_block_3$3($) {
  let r,
    p,
    v = $[1],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block_1$8(get_each_context_1$8($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      r = element("div");
      for (let S = 0; S < k.length; S += 1) k[S].c();
      attr(r, "class", "folders");
    },
    m(S, I) {
      insert(S, r, I);
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(r, null);
      p = !0;
    },
    p(S, I) {
      if (I & 2) {
        v = S[1];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_1$8(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block_1$8(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      S && detach(r), destroy_each(k, S);
    },
  };
}
function create_each_block_1$8($) {
  let r, p;
  return (
    (r = new Dir$3({ props: { dir: $[6] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 2 && (x.dir = v[6]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_2$6($) {
  let r,
    p,
    v = $[0],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$I(get_each_context$I($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      r = element("div");
      for (let S = 0; S < k.length; S += 1) k[S].c();
      attr(r, "class", "files");
    },
    m(S, I) {
      insert(S, r, I);
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(r, null);
      p = !0;
    },
    p(S, I) {
      if (I & 1) {
        v = S[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$I(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$I(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      S && detach(r), destroy_each(k, S);
    },
  };
}
function create_each_block$I($) {
  let r, p;
  return (
    (r = new File$2({ props: { file: $[3] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.file = v[3]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_else_block$r($) {
  let r;
  return {
    c() {
      (r = element("div")),
        (r.textContent = "This folder is empty."),
        attr(r, "class", "nofiles");
    },
    m(p, v) {
      insert(p, r, v);
    },
    i: noop$1,
    o: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
function create_if_block_1$p($) {
  let r, p, v, k, x, S;
  return (
    (v = new Spinner({ props: { height: 32 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          create_component(v.$$.fragment),
          (k = space()),
          (x = element("p")),
          (x.textContent = "Reading items..."),
          attr(x, "class", "caption"),
          attr(p, "class", "loading-inner"),
          attr(r, "class", "loading");
      },
      m(I, F) {
        insert(I, r, F),
          append(r, p),
          mount_component(v, p, null),
          append(p, k),
          append(p, x),
          (S = !0);
      },
      i(I) {
        S || (transition_in(v.$$.fragment, I), (S = !0));
      },
      o(I) {
        transition_out(v.$$.fragment, I), (S = !1);
      },
      d(I) {
        I && detach(r), destroy_component(v);
      },
    }
  );
}
function create_fragment$3y($) {
  let r, p, v, k;
  const x = [create_if_block$1k, create_else_block_1$1],
    S = [];
  function I(F, O) {
    return !F[1].length && !F[0].length ? 0 : 1;
  }
  return (
    (r = I($)),
    (p = S[r] = x[r]($)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        S[r].m(F, O), insert(F, v, O), (k = !0);
      },
      p(F, [O]) {
        let L = r;
        (r = I(F)),
          r === L
            ? S[r].p(F, O)
            : (group_outros(),
              transition_out(S[L], 1, 1, () => {
                S[L] = null;
              }),
              check_outros(),
              (p = S[r]),
              p ? p.p(F, O) : ((p = S[r] = x[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        k || (transition_in(p), (k = !0));
      },
      o(F) {
        transition_out(p), (k = !1);
      },
      d(F) {
        S[r].d(F), F && detach(v);
      },
    }
  );
}
function instance$3g($, r, p) {
  let v;
  component_subscribe($, FileBrowserRefreshing, (S) => p(2, (v = S)));
  let { files: k = [] } = r,
    { dirs: x = [] } = r;
  return (
    ($.$$set = (S) => {
      "files" in S && p(0, (k = S.files)), "dirs" in S && p(1, (x = S.dirs));
    }),
    [k, x, v]
  );
}
class TileView extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$3g, create_fragment$3y, safe_not_equal, {
        files: 0,
        dirs: 1,
      });
  }
}
function create_fragment$3x($) {
  let r, p, v, k, x;
  return {
    c() {
      (r = element("button")),
        (p = text("content_copy")),
        attr(r, "class", "material-icons-round copy"),
        (r.disabled = v = !$[0]);
    },
    m(S, I) {
      insert(S, r, I),
        append(r, p),
        k || ((x = listen(r, "click", $[1])), (k = !0));
    },
    p(S, [I]) {
      I & 1 && v !== (v = !S[0]) && (r.disabled = v);
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r), (k = !1), x();
    },
  };
}
function instance$3f($, r, p) {
  let v, k;
  component_subscribe($, FileBrowserSelectedFilename, (S) => p(0, (v = S))),
    component_subscribe($, FileBrowserCurrentDir, (S) => p(2, (k = S)));
  function x() {
    FileBrowserCopyingFilename.set({ name: v, scopedPath: `${k}/${v}` });
  }
  return [v, x];
}
class CopyButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3f, create_fragment$3x, safe_not_equal, {});
  }
}
function create_fragment$3w($) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.textContent = "add"),
        attr(r, "class", "material-icons-round create");
    },
    m(k, x) {
      insert(k, r, x), p || ((v = listen(r, "click", $[0])), (p = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function instance$3e($) {
  function r() {
    showOverlay("createFile", "FileManager");
  }
  return [r];
}
let CreateButton$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3e, create_fragment$3w, safe_not_equal, {});
  }
};
function create_fragment$3v($) {
  let r, p, v, k, x;
  return {
    c() {
      (r = element("button")),
        (p = text("content_cut")),
        attr(r, "class", "material-icons-round cut"),
        (r.disabled = v = !$[0]);
    },
    m(S, I) {
      insert(S, r, I),
        append(r, p),
        k || ((x = listen(r, "click", $[1])), (k = !0));
    },
    p(S, [I]) {
      I & 1 && v !== (v = !S[0]) && (r.disabled = v);
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r), (k = !1), x();
    },
  };
}
function instance$3d($, r, p) {
  let v, k;
  component_subscribe($, FileBrowserSelectedFilename, (S) => p(0, (v = S))),
    component_subscribe($, FileBrowserCurrentDir, (S) => p(2, (k = S)));
  function x() {
    FileBrowserCuttingFilename.set({ name: v, scopedPath: `${k}/${v}` });
  }
  return [v, x];
}
class CutButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3d, create_fragment$3v, safe_not_equal, {});
  }
}
function create_fragment$3u($) {
  let r, p, v, k, x;
  return {
    c() {
      (r = element("button")),
        (p = text("delete")),
        attr(r, "class", "material-icons-round"),
        (r.disabled = v = !$[0]),
        attr(r, "title", "Delete item");
    },
    m(S, I) {
      insert(S, r, I),
        append(r, p),
        k || ((x = listen(r, "click", $[1])), (k = !0));
    },
    p(S, [I]) {
      I & 1 && v !== (v = !S[0]) && (r.disabled = v);
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r), (k = !1), x();
    },
  };
}
function instance$3c($, r, p) {
  let v, k;
  component_subscribe($, FileBrowserSelectedFilename, (I) => p(0, (v = I))),
    component_subscribe($, FileBrowserCurrentDir, (I) => p(2, (k = I)));
  function x() {
    createOverlayableError(
      {
        title: "Delete item?",
        message: `Are you sure you want to permanently delete ${v}?`,
        buttons: [
          { caption: "Delete", action: S },
          { caption: "Cancel", action() {} },
        ],
        image: clear$1,
      },
      "FileManager"
    );
  }
  async function S() {
    const I = `${k}/${v}`;
    FileBrowserDeletingFilename.set(v),
      showOverlay("deletingItem", "FileManager"),
      (await deleteItem(I)) ||
        createOverlayableError(
          {
            title: "Unable to delete item",
            message:
              "ArcAPI was not able to delete the item from the file system. A permission error may have occured. Please try again later.",
            buttons: [{ caption: "OK", action() {} }],
            image: warning,
          },
          "FileManager"
        ),
      FileBrowserSelectedFilename.set(null),
      fbClass.refresh(),
      setTimeout(() => {
        hideOverlay("deletingItem", "FileManager");
      }, 100);
  }
  return [v, x];
}
class DeleteButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3c, create_fragment$3u, safe_not_equal, {});
  }
}
function create_fragment$3t($) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.textContent = "create_new_folder"),
        attr(r, "class", "material-icons-round"),
        attr(r, "title", "New folder");
    },
    m(k, x) {
      insert(k, r, x), p || ((v = listen(r, "click", $[0])), (p = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function instance$3b($) {
  function r() {
    showOverlay("createFolder", "FileManager");
  }
  return [r];
}
class NewFolderButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3b, create_fragment$3t, safe_not_equal, {});
  }
}
function create_fragment$3s($) {
  let r, p, v, k, x;
  return {
    c() {
      (r = element("button")),
        (p = text("arrow_upward")),
        attr(r, "class", "material-icons-round parentdir"),
        (r.disabled = v = $[0] == "./"),
        attr(r, "title", "Parent folder");
    },
    m(S, I) {
      insert(S, r, I),
        append(r, p),
        k || ((x = listen(r, "click", $[1])), (k = !0));
    },
    p(S, [I]) {
      I & 1 && v !== (v = S[0] == "./") && (r.disabled = v);
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r), (k = !1), x();
    },
  };
}
function instance$3a($, r, p) {
  let v;
  component_subscribe($, FileBrowserCurrentDir, (x) => p(0, (v = x)));
  function k() {
    fbClass.goToDirectory(getParentDirectory(v));
  }
  return [v, k];
}
class ParentDir extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3a, create_fragment$3s, safe_not_equal, {});
  }
}
async function copyItem($, r) {
  const p = get_store_value(ConnectedServer);
  return p
    ? (await apiCall(
        p,
        "fs/cp",
        { path: btoa($), target: btoa(r) },
        get_store_value(UserToken)
      ),
      !0)
    : !1;
}
async function renameItem($, r) {
  const p = get_store_value(ConnectedServer);
  return p
    ? (
        await apiCall(
          p,
          "fs/rename",
          { oldpath: btoa($), newpath: btoa(r) },
          get_store_value(UserToken)
        )
      ).valid
    : !1;
}
function create_fragment$3r($) {
  let r, p, v, k, x;
  return {
    c() {
      (r = element("button")),
        (p = text("content_paste")),
        attr(r, "class", "material-icons-round paste"),
        (r.disabled = v = !$[0] && !$[1]);
    },
    m(S, I) {
      insert(S, r, I),
        append(r, p),
        k || ((x = listen(r, "click", $[2])), (k = !0));
    },
    p(S, [I]) {
      I & 3 && v !== (v = !S[0] && !S[1]) && (r.disabled = v);
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r), (k = !1), x();
    },
  };
}
function instance$39($, r, p) {
  let v, k, x;
  component_subscribe($, FileBrowserCurrentDir, (I) => p(3, (v = I))),
    component_subscribe($, FileBrowserCuttingFilename, (I) => p(0, (k = I))),
    component_subscribe($, FileBrowserCopyingFilename, (I) => p(1, (x = I)));
  async function S() {
    if (x) {
      const I = x.name,
        F = x.scopedPath;
      await copyItem(F, `${v}/${I}`), FileBrowserCopyingFilename.set(null);
    }
    if (k) {
      const I = k.name,
        F = k.scopedPath;
      await renameItem(F, `${v}/${I}`), FileBrowserCuttingFilename.set(null);
    }
    fbClass.refresh();
  }
  return [k, x, S];
}
class PasteButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$39, create_fragment$3r, safe_not_equal, {});
  }
}
function create_fragment$3q($) {
  let r, p, v, k, x;
  return {
    c() {
      (r = element("button")),
        (p = text("drive_file_rename_outline")),
        attr(r, "class", "material-icons-round"),
        (r.disabled = v = !$[0]),
        attr(r, "title", "Rename item");
    },
    m(S, I) {
      insert(S, r, I),
        append(r, p),
        k || ((x = listen(r, "click", $[1])), (k = !0));
    },
    p(S, [I]) {
      I & 1 && v !== (v = !S[0]) && (r.disabled = v);
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r), (k = !1), x();
    },
  };
}
function instance$38($, r, p) {
  let v;
  component_subscribe($, FileBrowserSelectedFilename, (x) => p(0, (v = x)));
  function k() {
    showOverlay("renameItem", "FileManager");
  }
  return [v, k];
}
class RenameButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$38, create_fragment$3q, safe_not_equal, {});
  }
}
var mimeTypes = {},
  mimeDbExports = {},
  mimeDb = {
    get exports() {
      return mimeDbExports;
    },
    set exports($) {
      mimeDbExports = $;
    },
  };
const require$$0 = {
  "application/1d-interleaved-parityfec": { source: "iana" },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/3gpp-ims+xml": { source: "iana", compressible: !0 },
  "application/3gpphal+json": { source: "iana", compressible: !0 },
  "application/3gpphalforms+json": { source: "iana", compressible: !0 },
  "application/a2l": { source: "iana" },
  "application/ace+cbor": { source: "iana" },
  "application/activemessage": { source: "iana" },
  "application/activity+json": { source: "iana", compressible: !0 },
  "application/alto-costmap+json": { source: "iana", compressible: !0 },
  "application/alto-costmapfilter+json": { source: "iana", compressible: !0 },
  "application/alto-directory+json": { source: "iana", compressible: !0 },
  "application/alto-endpointcost+json": { source: "iana", compressible: !0 },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-endpointprop+json": { source: "iana", compressible: !0 },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-error+json": { source: "iana", compressible: !0 },
  "application/alto-networkmap+json": { source: "iana", compressible: !0 },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: !0,
  },
  "application/aml": { source: "iana" },
  "application/andrew-inset": { source: "iana", extensions: ["ez"] },
  "application/applefile": { source: "iana" },
  "application/applixware": { source: "apache", extensions: ["aw"] },
  "application/at+jwt": { source: "iana" },
  "application/atf": { source: "iana" },
  "application/atfx": { source: "iana" },
  "application/atom+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atom"],
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atomcat"],
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atomdeleted"],
  },
  "application/atomicmail": { source: "iana" },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atomsvc"],
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["dwd"],
  },
  "application/atsc-dynamic-event-message": { source: "iana" },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["held"],
  },
  "application/atsc-rdt+json": { source: "iana", compressible: !0 },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rsat"],
  },
  "application/atxml": { source: "iana" },
  "application/auth-policy+xml": { source: "iana", compressible: !0 },
  "application/bacnet-xdd+zip": { source: "iana", compressible: !1 },
  "application/batch-smtp": { source: "iana" },
  "application/bdoc": { compressible: !1, extensions: ["bdoc"] },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/calendar+json": { source: "iana", compressible: !0 },
  "application/calendar+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xcs"],
  },
  "application/call-completion": { source: "iana" },
  "application/cals-1840": { source: "iana" },
  "application/captive+json": { source: "iana", compressible: !0 },
  "application/cbor": { source: "iana" },
  "application/cbor-seq": { source: "iana" },
  "application/cccex": { source: "iana" },
  "application/ccmp+xml": { source: "iana", compressible: !0 },
  "application/ccxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ccxml"],
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["cdfx"],
  },
  "application/cdmi-capability": { source: "iana", extensions: ["cdmia"] },
  "application/cdmi-container": { source: "iana", extensions: ["cdmic"] },
  "application/cdmi-domain": { source: "iana", extensions: ["cdmid"] },
  "application/cdmi-object": { source: "iana", extensions: ["cdmio"] },
  "application/cdmi-queue": { source: "iana", extensions: ["cdmiq"] },
  "application/cdni": { source: "iana" },
  "application/cea": { source: "iana" },
  "application/cea-2018+xml": { source: "iana", compressible: !0 },
  "application/cellml+xml": { source: "iana", compressible: !0 },
  "application/cfw": { source: "iana" },
  "application/city+json": { source: "iana", compressible: !0 },
  "application/clr": { source: "iana" },
  "application/clue+xml": { source: "iana", compressible: !0 },
  "application/clue_info+xml": { source: "iana", compressible: !0 },
  "application/cms": { source: "iana" },
  "application/cnrp+xml": { source: "iana", compressible: !0 },
  "application/coap-group+json": { source: "iana", compressible: !0 },
  "application/coap-payload": { source: "iana" },
  "application/commonground": { source: "iana" },
  "application/conference-info+xml": { source: "iana", compressible: !0 },
  "application/cose": { source: "iana" },
  "application/cose-key": { source: "iana" },
  "application/cose-key-set": { source: "iana" },
  "application/cpl+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["cpl"],
  },
  "application/csrattrs": { source: "iana" },
  "application/csta+xml": { source: "iana", compressible: !0 },
  "application/cstadata+xml": { source: "iana", compressible: !0 },
  "application/csvm+json": { source: "iana", compressible: !0 },
  "application/cu-seeme": { source: "apache", extensions: ["cu"] },
  "application/cwt": { source: "iana" },
  "application/cybercash": { source: "iana" },
  "application/dart": { compressible: !0 },
  "application/dash+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpd"],
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpp"],
  },
  "application/dashdelta": { source: "iana" },
  "application/davmount+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["davmount"],
  },
  "application/dca-rft": { source: "iana" },
  "application/dcd": { source: "iana" },
  "application/dec-dx": { source: "iana" },
  "application/dialog-info+xml": { source: "iana", compressible: !0 },
  "application/dicom": { source: "iana" },
  "application/dicom+json": { source: "iana", compressible: !0 },
  "application/dicom+xml": { source: "iana", compressible: !0 },
  "application/dii": { source: "iana" },
  "application/dit": { source: "iana" },
  "application/dns": { source: "iana" },
  "application/dns+json": { source: "iana", compressible: !0 },
  "application/dns-message": { source: "iana" },
  "application/docbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["dbk"],
  },
  "application/dots+cbor": { source: "iana" },
  "application/dskpp+xml": { source: "iana", compressible: !0 },
  "application/dssc+der": { source: "iana", extensions: ["dssc"] },
  "application/dssc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xdssc"],
  },
  "application/dvcs": { source: "iana" },
  "application/ecmascript": {
    source: "iana",
    compressible: !0,
    extensions: ["es", "ecma"],
  },
  "application/edi-consent": { source: "iana" },
  "application/edi-x12": { source: "iana", compressible: !1 },
  "application/edifact": { source: "iana", compressible: !1 },
  "application/efi": { source: "iana" },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/elm+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.ecall.msd": { source: "iana" },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emma+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["emma"],
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["emotionml"],
  },
  "application/encaprtp": { source: "iana" },
  "application/epp+xml": { source: "iana", compressible: !0 },
  "application/epub+zip": {
    source: "iana",
    compressible: !1,
    extensions: ["epub"],
  },
  "application/eshop": { source: "iana" },
  "application/exi": { source: "iana", extensions: ["exi"] },
  "application/expect-ct-report+json": { source: "iana", compressible: !0 },
  "application/express": { source: "iana", extensions: ["exp"] },
  "application/fastinfoset": { source: "iana" },
  "application/fastsoap": { source: "iana" },
  "application/fdt+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["fdt"],
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/fido.trusted-apps+json": { compressible: !0 },
  "application/fits": { source: "iana" },
  "application/flexfec": { source: "iana" },
  "application/font-sfnt": { source: "iana" },
  "application/font-tdpfr": { source: "iana", extensions: ["pfr"] },
  "application/font-woff": { source: "iana", compressible: !1 },
  "application/framework-attributes+xml": { source: "iana", compressible: !0 },
  "application/geo+json": {
    source: "iana",
    compressible: !0,
    extensions: ["geojson"],
  },
  "application/geo+json-seq": { source: "iana" },
  "application/geopackage+sqlite3": { source: "iana" },
  "application/geoxacml+xml": { source: "iana", compressible: !0 },
  "application/gltf-buffer": { source: "iana" },
  "application/gml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["gml"],
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["gpx"],
  },
  "application/gxf": { source: "apache", extensions: ["gxf"] },
  "application/gzip": { source: "iana", compressible: !1, extensions: ["gz"] },
  "application/h224": { source: "iana" },
  "application/held+xml": { source: "iana", compressible: !0 },
  "application/hjson": { extensions: ["hjson"] },
  "application/http": { source: "iana" },
  "application/hyperstudio": { source: "iana", extensions: ["stk"] },
  "application/ibe-key-request+xml": { source: "iana", compressible: !0 },
  "application/ibe-pkg-reply+xml": { source: "iana", compressible: !0 },
  "application/ibe-pp-data": { source: "iana" },
  "application/iges": { source: "iana" },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/index": { source: "iana" },
  "application/index.cmd": { source: "iana" },
  "application/index.obj": { source: "iana" },
  "application/index.response": { source: "iana" },
  "application/index.vnd": { source: "iana" },
  "application/inkml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ink", "inkml"],
  },
  "application/iotp": { source: "iana" },
  "application/ipfix": { source: "iana", extensions: ["ipfix"] },
  "application/ipp": { source: "iana" },
  "application/isup": { source: "iana" },
  "application/its+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["its"],
  },
  "application/java-archive": {
    source: "apache",
    compressible: !1,
    extensions: ["jar", "war", "ear"],
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: !1,
    extensions: ["ser"],
  },
  "application/java-vm": {
    source: "apache",
    compressible: !1,
    extensions: ["class"],
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["js", "mjs"],
  },
  "application/jf2feed+json": { source: "iana", compressible: !0 },
  "application/jose": { source: "iana" },
  "application/jose+json": { source: "iana", compressible: !0 },
  "application/jrd+json": { source: "iana", compressible: !0 },
  "application/jscalendar+json": { source: "iana", compressible: !0 },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["json", "map"],
  },
  "application/json-patch+json": { source: "iana", compressible: !0 },
  "application/json-seq": { source: "iana" },
  "application/json5": { extensions: ["json5"] },
  "application/jsonml+json": {
    source: "apache",
    compressible: !0,
    extensions: ["jsonml"],
  },
  "application/jwk+json": { source: "iana", compressible: !0 },
  "application/jwk-set+json": { source: "iana", compressible: !0 },
  "application/jwt": { source: "iana" },
  "application/kpml-request+xml": { source: "iana", compressible: !0 },
  "application/kpml-response+xml": { source: "iana", compressible: !0 },
  "application/ld+json": {
    source: "iana",
    compressible: !0,
    extensions: ["jsonld"],
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lgr"],
  },
  "application/link-format": { source: "iana" },
  "application/load-control+xml": { source: "iana", compressible: !0 },
  "application/lost+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lostxml"],
  },
  "application/lostsync+xml": { source: "iana", compressible: !0 },
  "application/lpf+zip": { source: "iana", compressible: !1 },
  "application/lxf": { source: "iana" },
  "application/mac-binhex40": { source: "iana", extensions: ["hqx"] },
  "application/mac-compactpro": { source: "apache", extensions: ["cpt"] },
  "application/macwriteii": { source: "iana" },
  "application/mads+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mads"],
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["webmanifest"],
  },
  "application/marc": { source: "iana", extensions: ["mrc"] },
  "application/marcxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mrcx"],
  },
  "application/mathematica": { source: "iana", extensions: ["ma", "nb", "mb"] },
  "application/mathml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mathml"],
  },
  "application/mathml-content+xml": { source: "iana", compressible: !0 },
  "application/mathml-presentation+xml": { source: "iana", compressible: !0 },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbms-deregister+xml": { source: "iana", compressible: !0 },
  "application/mbms-envelope+xml": { source: "iana", compressible: !0 },
  "application/mbms-msk+xml": { source: "iana", compressible: !0 },
  "application/mbms-msk-response+xml": { source: "iana", compressible: !0 },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbms-reception-report+xml": { source: "iana", compressible: !0 },
  "application/mbms-register+xml": { source: "iana", compressible: !0 },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbms-schedule+xml": { source: "iana", compressible: !0 },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbox": { source: "iana", extensions: ["mbox"] },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpf"],
  },
  "application/media_control+xml": { source: "iana", compressible: !0 },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mscml"],
  },
  "application/merge-patch+json": { source: "iana", compressible: !0 },
  "application/metalink+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["metalink"],
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["meta4"],
  },
  "application/mets+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mets"],
  },
  "application/mf4": { source: "iana" },
  "application/mikey": { source: "iana" },
  "application/mipc": { source: "iana" },
  "application/missing-blocks+cbor-seq": { source: "iana" },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["maei"],
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["musd"],
  },
  "application/mods+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mods"],
  },
  "application/moss-keys": { source: "iana" },
  "application/moss-signature": { source: "iana" },
  "application/mosskey-data": { source: "iana" },
  "application/mosskey-request": { source: "iana" },
  "application/mp21": { source: "iana", extensions: ["m21", "mp21"] },
  "application/mp4": { source: "iana", extensions: ["mp4s", "m4p"] },
  "application/mpeg4-generic": { source: "iana" },
  "application/mpeg4-iod": { source: "iana" },
  "application/mpeg4-iod-xmt": { source: "iana" },
  "application/mrb-consumer+xml": { source: "iana", compressible: !0 },
  "application/mrb-publish+xml": { source: "iana", compressible: !0 },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/msword": {
    source: "iana",
    compressible: !1,
    extensions: ["doc", "dot"],
  },
  "application/mud+json": { source: "iana", compressible: !0 },
  "application/multipart-core": { source: "iana" },
  "application/mxf": { source: "iana", extensions: ["mxf"] },
  "application/n-quads": { source: "iana", extensions: ["nq"] },
  "application/n-triples": { source: "iana", extensions: ["nt"] },
  "application/nasdata": { source: "iana" },
  "application/news-checkgroups": { source: "iana", charset: "US-ASCII" },
  "application/news-groupinfo": { source: "iana", charset: "US-ASCII" },
  "application/news-transmission": { source: "iana" },
  "application/nlsml+xml": { source: "iana", compressible: !0 },
  "application/node": { source: "iana", extensions: ["cjs"] },
  "application/nss": { source: "iana" },
  "application/oauth-authz-req+jwt": { source: "iana" },
  "application/oblivious-dns-message": { source: "iana" },
  "application/ocsp-request": { source: "iana" },
  "application/ocsp-response": { source: "iana" },
  "application/octet-stream": {
    source: "iana",
    compressible: !1,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer",
    ],
  },
  "application/oda": { source: "iana", extensions: ["oda"] },
  "application/odm+xml": { source: "iana", compressible: !0 },
  "application/odx": { source: "iana" },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["opf"],
  },
  "application/ogg": { source: "iana", compressible: !1, extensions: ["ogx"] },
  "application/omdoc+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["omdoc"],
  },
  "application/onenote": {
    source: "apache",
    extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"],
  },
  "application/opc-nodeset+xml": { source: "iana", compressible: !0 },
  "application/oscore": { source: "iana" },
  "application/oxps": { source: "iana", extensions: ["oxps"] },
  "application/p21": { source: "iana" },
  "application/p21+zip": { source: "iana", compressible: !1 },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["relo"],
  },
  "application/parityfec": { source: "iana" },
  "application/passport": { source: "iana" },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xer"],
  },
  "application/pdf": { source: "iana", compressible: !1, extensions: ["pdf"] },
  "application/pdx": { source: "iana" },
  "application/pem-certificate-chain": { source: "iana" },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: !1,
    extensions: ["pgp"],
  },
  "application/pgp-keys": { source: "iana", extensions: ["asc"] },
  "application/pgp-signature": { source: "iana", extensions: ["asc", "sig"] },
  "application/pics-rules": { source: "apache", extensions: ["prf"] },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/pkcs10": { source: "iana", extensions: ["p10"] },
  "application/pkcs12": { source: "iana" },
  "application/pkcs7-mime": { source: "iana", extensions: ["p7m", "p7c"] },
  "application/pkcs7-signature": { source: "iana", extensions: ["p7s"] },
  "application/pkcs8": { source: "iana", extensions: ["p8"] },
  "application/pkcs8-encrypted": { source: "iana" },
  "application/pkix-attr-cert": { source: "iana", extensions: ["ac"] },
  "application/pkix-cert": { source: "iana", extensions: ["cer"] },
  "application/pkix-crl": { source: "iana", extensions: ["crl"] },
  "application/pkix-pkipath": { source: "iana", extensions: ["pkipath"] },
  "application/pkixcmp": { source: "iana", extensions: ["pki"] },
  "application/pls+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["pls"],
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/postscript": {
    source: "iana",
    compressible: !0,
    extensions: ["ai", "eps", "ps"],
  },
  "application/ppsp-tracker+json": { source: "iana", compressible: !0 },
  "application/problem+json": { source: "iana", compressible: !0 },
  "application/problem+xml": { source: "iana", compressible: !0 },
  "application/provenance+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["provx"],
  },
  "application/prs.alvestrand.titrax-sheet": { source: "iana" },
  "application/prs.cww": { source: "iana", extensions: ["cww"] },
  "application/prs.cyn": { source: "iana", charset: "7-BIT" },
  "application/prs.hpub+zip": { source: "iana", compressible: !1 },
  "application/prs.nprend": { source: "iana" },
  "application/prs.plucker": { source: "iana" },
  "application/prs.rdf-xml-crypt": { source: "iana" },
  "application/prs.xsf+xml": { source: "iana", compressible: !0 },
  "application/pskc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["pskcxml"],
  },
  "application/pvd+json": { source: "iana", compressible: !0 },
  "application/qsig": { source: "iana" },
  "application/raml+yaml": { compressible: !0, extensions: ["raml"] },
  "application/raptorfec": { source: "iana" },
  "application/rdap+json": { source: "iana", compressible: !0 },
  "application/rdf+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rdf", "owl"],
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rif"],
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: ["rnc"],
  },
  "application/remote-printing": { source: "iana" },
  "application/reputon+json": { source: "iana", compressible: !0 },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rl"],
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rld"],
  },
  "application/rfc+xml": { source: "iana", compressible: !0 },
  "application/riscos": { source: "iana" },
  "application/rlmi+xml": { source: "iana", compressible: !0 },
  "application/rls-services+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rs"],
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rapd"],
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sls"],
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rusd"],
  },
  "application/rpki-ghostbusters": { source: "iana", extensions: ["gbr"] },
  "application/rpki-manifest": { source: "iana", extensions: ["mft"] },
  "application/rpki-publication": { source: "iana" },
  "application/rpki-roa": { source: "iana", extensions: ["roa"] },
  "application/rpki-updown": { source: "iana" },
  "application/rsd+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["rsd"],
  },
  "application/rss+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["rss"],
  },
  "application/rtf": { source: "iana", compressible: !0, extensions: ["rtf"] },
  "application/rtploopback": { source: "iana" },
  "application/rtx": { source: "iana" },
  "application/samlassertion+xml": { source: "iana", compressible: !0 },
  "application/samlmetadata+xml": { source: "iana", compressible: !0 },
  "application/sarif+json": { source: "iana", compressible: !0 },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: !0,
  },
  "application/sbe": { source: "iana" },
  "application/sbml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sbml"],
  },
  "application/scaip+xml": { source: "iana", compressible: !0 },
  "application/scim+json": { source: "iana", compressible: !0 },
  "application/scvp-cv-request": { source: "iana", extensions: ["scq"] },
  "application/scvp-cv-response": { source: "iana", extensions: ["scs"] },
  "application/scvp-vp-request": { source: "iana", extensions: ["spq"] },
  "application/scvp-vp-response": { source: "iana", extensions: ["spp"] },
  "application/sdp": { source: "iana", extensions: ["sdp"] },
  "application/secevent+jwt": { source: "iana" },
  "application/senml+cbor": { source: "iana" },
  "application/senml+json": { source: "iana", compressible: !0 },
  "application/senml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["senmlx"],
  },
  "application/senml-etch+cbor": { source: "iana" },
  "application/senml-etch+json": { source: "iana", compressible: !0 },
  "application/senml-exi": { source: "iana" },
  "application/sensml+cbor": { source: "iana" },
  "application/sensml+json": { source: "iana", compressible: !0 },
  "application/sensml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sensmlx"],
  },
  "application/sensml-exi": { source: "iana" },
  "application/sep+xml": { source: "iana", compressible: !0 },
  "application/sep-exi": { source: "iana" },
  "application/session-info": { source: "iana" },
  "application/set-payment": { source: "iana" },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: ["setpay"],
  },
  "application/set-registration": { source: "iana" },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: ["setreg"],
  },
  "application/sgml": { source: "iana" },
  "application/sgml-open-catalog": { source: "iana" },
  "application/shf+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["shf"],
  },
  "application/sieve": { source: "iana", extensions: ["siv", "sieve"] },
  "application/simple-filter+xml": { source: "iana", compressible: !0 },
  "application/simple-message-summary": { source: "iana" },
  "application/simplesymbolcontainer": { source: "iana" },
  "application/sipc": { source: "iana" },
  "application/slate": { source: "iana" },
  "application/smil": { source: "iana" },
  "application/smil+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["smi", "smil"],
  },
  "application/smpte336m": { source: "iana" },
  "application/soap+fastinfoset": { source: "iana" },
  "application/soap+xml": { source: "iana", compressible: !0 },
  "application/sparql-query": { source: "iana", extensions: ["rq"] },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["srx"],
  },
  "application/spdx+json": { source: "iana", compressible: !0 },
  "application/spirits-event+xml": { source: "iana", compressible: !0 },
  "application/sql": { source: "iana" },
  "application/srgs": { source: "iana", extensions: ["gram"] },
  "application/srgs+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["grxml"],
  },
  "application/sru+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sru"],
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["ssdl"],
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ssml"],
  },
  "application/stix+json": { source: "iana", compressible: !0 },
  "application/swid+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["swidtag"],
  },
  "application/tamp-apex-update": { source: "iana" },
  "application/tamp-apex-update-confirm": { source: "iana" },
  "application/tamp-community-update": { source: "iana" },
  "application/tamp-community-update-confirm": { source: "iana" },
  "application/tamp-error": { source: "iana" },
  "application/tamp-sequence-adjust": { source: "iana" },
  "application/tamp-sequence-adjust-confirm": { source: "iana" },
  "application/tamp-status-query": { source: "iana" },
  "application/tamp-status-response": { source: "iana" },
  "application/tamp-update": { source: "iana" },
  "application/tamp-update-confirm": { source: "iana" },
  "application/tar": { compressible: !0 },
  "application/taxii+json": { source: "iana", compressible: !0 },
  "application/td+json": { source: "iana", compressible: !0 },
  "application/tei+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["tei", "teicorpus"],
  },
  "application/tetra_isi": { source: "iana" },
  "application/thraud+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["tfi"],
  },
  "application/timestamp-query": { source: "iana" },
  "application/timestamp-reply": { source: "iana" },
  "application/timestamped-data": { source: "iana", extensions: ["tsd"] },
  "application/tlsrpt+gzip": { source: "iana" },
  "application/tlsrpt+json": { source: "iana", compressible: !0 },
  "application/tnauthlist": { source: "iana" },
  "application/token-introspection+jwt": { source: "iana" },
  "application/toml": { compressible: !0, extensions: ["toml"] },
  "application/trickle-ice-sdpfrag": { source: "iana" },
  "application/trig": { source: "iana", extensions: ["trig"] },
  "application/ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ttml"],
  },
  "application/tve-trigger": { source: "iana" },
  "application/tzif": { source: "iana" },
  "application/tzif-leap": { source: "iana" },
  "application/ubjson": { compressible: !1, extensions: ["ubj"] },
  "application/ulpfec": { source: "iana" },
  "application/urc-grpsheet+xml": { source: "iana", compressible: !0 },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rsheet"],
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["td"],
  },
  "application/urc-uisocketdesc+xml": { source: "iana", compressible: !0 },
  "application/vcard+json": { source: "iana", compressible: !0 },
  "application/vcard+xml": { source: "iana", compressible: !0 },
  "application/vemmi": { source: "iana" },
  "application/vividence.scriptfile": { source: "apache" },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["1km"],
  },
  "application/vnd.3gpp-prose+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-prose-pc3ch+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-v2x-local-service-information": { source: "iana" },
  "application/vnd.3gpp.5gnas": { source: "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.bsf+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.gmop+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.gtpc": { source: "iana" },
  "application/vnd.3gpp.interworking-data": { source: "iana" },
  "application/vnd.3gpp.lpp": { source: "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { source: "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcdata-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-payload": { source: "iana" },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcdata-signalling": { source: "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-signed+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mid-call+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.ngap": { source: "iana" },
  "application/vnd.3gpp.pfcp": { source: "iana" },
  "application/vnd.3gpp.pic-bw-large": { source: "iana", extensions: ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { source: "iana", extensions: ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { source: "iana", extensions: ["pvb"] },
  "application/vnd.3gpp.s1ap": { source: "iana" },
  "application/vnd.3gpp.sms": { source: "iana" },
  "application/vnd.3gpp.sms+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.srvcc-ext+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.srvcc-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.ussd+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp2.bcmcsinfo+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp2.sms": { source: "iana" },
  "application/vnd.3gpp2.tcap": { source: "iana", extensions: ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { source: "iana" },
  "application/vnd.3m.post-it-notes": { source: "iana", extensions: ["pwn"] },
  "application/vnd.accpac.simply.aso": { source: "iana", extensions: ["aso"] },
  "application/vnd.accpac.simply.imp": { source: "iana", extensions: ["imp"] },
  "application/vnd.acucobol": { source: "iana", extensions: ["acu"] },
  "application/vnd.acucorp": { source: "iana", extensions: ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: !1,
    extensions: ["air"],
  },
  "application/vnd.adobe.flash.movie": { source: "iana" },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: ["fcdt"],
  },
  "application/vnd.adobe.fxp": { source: "iana", extensions: ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { source: "iana" },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xdp"],
  },
  "application/vnd.adobe.xfdf": { source: "iana", extensions: ["xfdf"] },
  "application/vnd.aether.imp": { source: "iana" },
  "application/vnd.afpc.afplinedata": { source: "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { source: "iana" },
  "application/vnd.afpc.cmoca-cmresource": { source: "iana" },
  "application/vnd.afpc.foca-charset": { source: "iana" },
  "application/vnd.afpc.foca-codedfont": { source: "iana" },
  "application/vnd.afpc.foca-codepage": { source: "iana" },
  "application/vnd.afpc.modca": { source: "iana" },
  "application/vnd.afpc.modca-cmtable": { source: "iana" },
  "application/vnd.afpc.modca-formdef": { source: "iana" },
  "application/vnd.afpc.modca-mediummap": { source: "iana" },
  "application/vnd.afpc.modca-objectcontainer": { source: "iana" },
  "application/vnd.afpc.modca-overlay": { source: "iana" },
  "application/vnd.afpc.modca-pagesegment": { source: "iana" },
  "application/vnd.age": { source: "iana", extensions: ["age"] },
  "application/vnd.ah-barcode": { source: "iana" },
  "application/vnd.ahead.space": { source: "iana", extensions: ["ahead"] },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: ["azf"],
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: ["azs"],
  },
  "application/vnd.amadeus+json": { source: "iana", compressible: !0 },
  "application/vnd.amazon.ebook": { source: "apache", extensions: ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { source: "iana" },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: ["acc"],
  },
  "application/vnd.amiga.ami": { source: "iana", extensions: ["ami"] },
  "application/vnd.amundsen.maze+xml": { source: "iana", compressible: !0 },
  "application/vnd.android.ota": { source: "iana" },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: !1,
    extensions: ["apk"],
  },
  "application/vnd.anki": { source: "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: ["cii"],
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: ["fti"],
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: ["atx"],
  },
  "application/vnd.apache.arrow.file": { source: "iana" },
  "application/vnd.apache.arrow.stream": { source: "iana" },
  "application/vnd.apache.thrift.binary": { source: "iana" },
  "application/vnd.apache.thrift.compact": { source: "iana" },
  "application/vnd.apache.thrift.json": { source: "iana" },
  "application/vnd.api+json": { source: "iana", compressible: !0 },
  "application/vnd.aplextor.warrp+json": { source: "iana", compressible: !0 },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpkg"],
  },
  "application/vnd.apple.keynote": { source: "iana", extensions: ["key"] },
  "application/vnd.apple.mpegurl": { source: "iana", extensions: ["m3u8"] },
  "application/vnd.apple.numbers": { source: "iana", extensions: ["numbers"] },
  "application/vnd.apple.pages": { source: "iana", extensions: ["pages"] },
  "application/vnd.apple.pkpass": { compressible: !1, extensions: ["pkpass"] },
  "application/vnd.arastra.swi": { source: "iana" },
  "application/vnd.aristanetworks.swi": { source: "iana", extensions: ["swi"] },
  "application/vnd.artisan+json": { source: "iana", compressible: !0 },
  "application/vnd.artsquare": { source: "iana" },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: ["iota"],
  },
  "application/vnd.audiograph": { source: "iana", extensions: ["aep"] },
  "application/vnd.autopackage": { source: "iana" },
  "application/vnd.avalon+json": { source: "iana", compressible: !0 },
  "application/vnd.avistar+xml": { source: "iana", compressible: !0 },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["bmml"],
  },
  "application/vnd.balsamiq.bmpr": { source: "iana" },
  "application/vnd.banana-accounting": { source: "iana" },
  "application/vnd.bbf.usp.error": { source: "iana" },
  "application/vnd.bbf.usp.msg": { source: "iana" },
  "application/vnd.bbf.usp.msg+json": { source: "iana", compressible: !0 },
  "application/vnd.bekitzur-stech+json": { source: "iana", compressible: !0 },
  "application/vnd.bint.med-content": { source: "iana" },
  "application/vnd.biopax.rdf+xml": { source: "iana", compressible: !0 },
  "application/vnd.blink-idb-value-wrapper": { source: "iana" },
  "application/vnd.blueice.multipass": { source: "iana", extensions: ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { source: "iana" },
  "application/vnd.bluetooth.le.oob": { source: "iana" },
  "application/vnd.bmi": { source: "iana", extensions: ["bmi"] },
  "application/vnd.bpf": { source: "iana" },
  "application/vnd.bpf3": { source: "iana" },
  "application/vnd.businessobjects": { source: "iana", extensions: ["rep"] },
  "application/vnd.byu.uapi+json": { source: "iana", compressible: !0 },
  "application/vnd.cab-jscript": { source: "iana" },
  "application/vnd.canon-cpdl": { source: "iana" },
  "application/vnd.canon-lips": { source: "iana" },
  "application/vnd.capasystems-pg+json": { source: "iana", compressible: !0 },
  "application/vnd.cendio.thinlinc.clientconf": { source: "iana" },
  "application/vnd.century-systems.tcp_stream": { source: "iana" },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["cdxml"],
  },
  "application/vnd.chess-pgn": { source: "iana" },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: ["mmd"],
  },
  "application/vnd.ciedi": { source: "iana" },
  "application/vnd.cinderella": { source: "iana", extensions: ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { source: "iana" },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["csl"],
  },
  "application/vnd.claymore": { source: "iana", extensions: ["cla"] },
  "application/vnd.cloanto.rp9": { source: "iana", extensions: ["rp9"] },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"],
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: ["c11amc"],
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: ["c11amz"],
  },
  "application/vnd.coffeescript": { source: "iana" },
  "application/vnd.collabio.xodocuments.document": { source: "iana" },
  "application/vnd.collabio.xodocuments.document-template": { source: "iana" },
  "application/vnd.collabio.xodocuments.presentation": { source: "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana",
  },
  "application/vnd.collabio.xodocuments.spreadsheet": { source: "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana",
  },
  "application/vnd.collection+json": { source: "iana", compressible: !0 },
  "application/vnd.collection.doc+json": { source: "iana", compressible: !0 },
  "application/vnd.collection.next+json": { source: "iana", compressible: !0 },
  "application/vnd.comicbook+zip": { source: "iana", compressible: !1 },
  "application/vnd.comicbook-rar": { source: "iana" },
  "application/vnd.commerce-battelle": { source: "iana" },
  "application/vnd.commonspace": { source: "iana", extensions: ["csp"] },
  "application/vnd.contact.cmsg": { source: "iana", extensions: ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { source: "iana", compressible: !0 },
  "application/vnd.cosmocaller": { source: "iana", extensions: ["cmc"] },
  "application/vnd.crick.clicker": { source: "iana", extensions: ["clkx"] },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: ["clkk"],
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: ["clkp"],
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: ["clkt"],
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: ["clkw"],
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wbs"],
  },
  "application/vnd.cryptii.pipe+json": { source: "iana", compressible: !0 },
  "application/vnd.crypto-shade-file": { source: "iana" },
  "application/vnd.cryptomator.encrypted": { source: "iana" },
  "application/vnd.cryptomator.vault": { source: "iana" },
  "application/vnd.ctc-posml": { source: "iana", extensions: ["pml"] },
  "application/vnd.ctct.ws+xml": { source: "iana", compressible: !0 },
  "application/vnd.cups-pdf": { source: "iana" },
  "application/vnd.cups-postscript": { source: "iana" },
  "application/vnd.cups-ppd": { source: "iana", extensions: ["ppd"] },
  "application/vnd.cups-raster": { source: "iana" },
  "application/vnd.cups-raw": { source: "iana" },
  "application/vnd.curl": { source: "iana" },
  "application/vnd.curl.car": { source: "apache", extensions: ["car"] },
  "application/vnd.curl.pcurl": { source: "apache", extensions: ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { source: "iana", compressible: !0 },
  "application/vnd.cybank": { source: "iana" },
  "application/vnd.cyclonedx+json": { source: "iana", compressible: !0 },
  "application/vnd.cyclonedx+xml": { source: "iana", compressible: !0 },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: !1,
  },
  "application/vnd.d3m-dataset": { source: "iana" },
  "application/vnd.d3m-problem": { source: "iana" },
  "application/vnd.dart": {
    source: "iana",
    compressible: !0,
    extensions: ["dart"],
  },
  "application/vnd.data-vision.rdz": { source: "iana", extensions: ["rdz"] },
  "application/vnd.datapackage+json": { source: "iana", compressible: !0 },
  "application/vnd.dataresource+json": { source: "iana", compressible: !0 },
  "application/vnd.dbf": { source: "iana", extensions: ["dbf"] },
  "application/vnd.debian.binary-package": { source: "iana" },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: ["uvf", "uvvf", "uvd", "uvvd"],
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["uvt", "uvvt"],
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: ["uvx", "uvvx"],
  },
  "application/vnd.dece.zip": { source: "iana", extensions: ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: ["fe_launch"],
  },
  "application/vnd.desmume.movie": { source: "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { source: "iana" },
  "application/vnd.dm.delegation+xml": { source: "iana", compressible: !0 },
  "application/vnd.dna": { source: "iana", extensions: ["dna"] },
  "application/vnd.document+json": { source: "iana", compressible: !0 },
  "application/vnd.dolby.mlp": { source: "apache", extensions: ["mlp"] },
  "application/vnd.dolby.mobile.1": { source: "iana" },
  "application/vnd.dolby.mobile.2": { source: "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { source: "iana" },
  "application/vnd.dpgraph": { source: "iana", extensions: ["dpg"] },
  "application/vnd.dreamfactory": { source: "iana", extensions: ["dfac"] },
  "application/vnd.drive+json": { source: "iana", compressible: !0 },
  "application/vnd.ds-keypoint": { source: "apache", extensions: ["kpxx"] },
  "application/vnd.dtg.local": { source: "iana" },
  "application/vnd.dtg.local.flash": { source: "iana" },
  "application/vnd.dtg.local.html": { source: "iana" },
  "application/vnd.dvb.ait": { source: "iana", extensions: ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.dvbj": { source: "iana" },
  "application/vnd.dvb.esgcontainer": { source: "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { source: "iana" },
  "application/vnd.dvb.ipdcesgaccess": { source: "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { source: "iana" },
  "application/vnd.dvb.ipdcesgpdd": { source: "iana" },
  "application/vnd.dvb.ipdcroaming": { source: "iana" },
  "application/vnd.dvb.iptv.alfec-base": { source: "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { source: "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-generic+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-init+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.pfr": { source: "iana" },
  "application/vnd.dvb.service": { source: "iana", extensions: ["svc"] },
  "application/vnd.dxr": { source: "iana" },
  "application/vnd.dynageo": { source: "iana", extensions: ["geo"] },
  "application/vnd.dzr": { source: "iana" },
  "application/vnd.easykaraoke.cdgdownload": { source: "iana" },
  "application/vnd.ecdis-update": { source: "iana" },
  "application/vnd.ecip.rlp": { source: "iana" },
  "application/vnd.eclipse.ditto+json": { source: "iana", compressible: !0 },
  "application/vnd.ecowin.chart": { source: "iana", extensions: ["mag"] },
  "application/vnd.ecowin.filerequest": { source: "iana" },
  "application/vnd.ecowin.fileupdate": { source: "iana" },
  "application/vnd.ecowin.series": { source: "iana" },
  "application/vnd.ecowin.seriesrequest": { source: "iana" },
  "application/vnd.ecowin.seriesupdate": { source: "iana" },
  "application/vnd.efi.img": { source: "iana" },
  "application/vnd.efi.iso": { source: "iana" },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.enliven": { source: "iana", extensions: ["nml"] },
  "application/vnd.enphase.envoy": { source: "iana" },
  "application/vnd.eprints.data+xml": { source: "iana", compressible: !0 },
  "application/vnd.epson.esf": { source: "iana", extensions: ["esf"] },
  "application/vnd.epson.msf": { source: "iana", extensions: ["msf"] },
  "application/vnd.epson.quickanime": { source: "iana", extensions: ["qam"] },
  "application/vnd.epson.salt": { source: "iana", extensions: ["slt"] },
  "application/vnd.epson.ssf": { source: "iana", extensions: ["ssf"] },
  "application/vnd.ericsson.quickcall": { source: "iana" },
  "application/vnd.espass-espass+zip": { source: "iana", compressible: !1 },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["es3", "et3"],
  },
  "application/vnd.etsi.aoc+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.asic-e+zip": { source: "iana", compressible: !1 },
  "application/vnd.etsi.asic-s+zip": { source: "iana", compressible: !1 },
  "application/vnd.etsi.cug+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvcommand+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.etsi.iptvprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-bc+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-cod+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-npvr+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvservice+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsync+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.etsi.mcid+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.mheg5": { source: "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.etsi.pstn+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.sci+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.simservs+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.timestamp-token": { source: "iana" },
  "application/vnd.etsi.tsl+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.tsl.der": { source: "iana" },
  "application/vnd.eu.kasparian.car+json": { source: "iana", compressible: !0 },
  "application/vnd.eudora.data": { source: "iana" },
  "application/vnd.evolv.ecig.profile": { source: "iana" },
  "application/vnd.evolv.ecig.settings": { source: "iana" },
  "application/vnd.evolv.ecig.theme": { source: "iana" },
  "application/vnd.exstream-empower+zip": { source: "iana", compressible: !1 },
  "application/vnd.exstream-package": { source: "iana" },
  "application/vnd.ezpix-album": { source: "iana", extensions: ["ez2"] },
  "application/vnd.ezpix-package": { source: "iana", extensions: ["ez3"] },
  "application/vnd.f-secure.mobile": { source: "iana" },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: !1,
  },
  "application/vnd.fastcopy-disk-image": { source: "iana" },
  "application/vnd.fdf": { source: "iana", extensions: ["fdf"] },
  "application/vnd.fdsn.mseed": { source: "iana", extensions: ["mseed"] },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: ["seed", "dataless"],
  },
  "application/vnd.ffsns": { source: "iana" },
  "application/vnd.ficlab.flb+zip": { source: "iana", compressible: !1 },
  "application/vnd.filmit.zfc": { source: "iana" },
  "application/vnd.fints": { source: "iana" },
  "application/vnd.firemonkeys.cloudcell": { source: "iana" },
  "application/vnd.flographit": { source: "iana", extensions: ["gph"] },
  "application/vnd.fluxtime.clip": { source: "iana", extensions: ["ftc"] },
  "application/vnd.font-fontforge-sfd": { source: "iana" },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: ["fm", "frame", "maker", "book"],
  },
  "application/vnd.frogans.fnc": { source: "iana", extensions: ["fnc"] },
  "application/vnd.frogans.ltf": { source: "iana", extensions: ["ltf"] },
  "application/vnd.fsc.weblaunch": { source: "iana", extensions: ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { source: "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { source: "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { source: "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { source: "iana", compressible: !0 },
  "application/vnd.fujitsu.oasys": { source: "iana", extensions: ["oas"] },
  "application/vnd.fujitsu.oasys2": { source: "iana", extensions: ["oa2"] },
  "application/vnd.fujitsu.oasys3": { source: "iana", extensions: ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { source: "iana", extensions: ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { source: "iana", extensions: ["bh2"] },
  "application/vnd.fujixerox.art-ex": { source: "iana" },
  "application/vnd.fujixerox.art4": { source: "iana" },
  "application/vnd.fujixerox.ddd": { source: "iana", extensions: ["ddd"] },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: ["xdw"],
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: ["xbd"],
  },
  "application/vnd.fujixerox.docuworks.container": { source: "iana" },
  "application/vnd.fujixerox.hbpl": { source: "iana" },
  "application/vnd.fut-misnet": { source: "iana" },
  "application/vnd.futoin+cbor": { source: "iana" },
  "application/vnd.futoin+json": { source: "iana", compressible: !0 },
  "application/vnd.fuzzysheet": { source: "iana", extensions: ["fzs"] },
  "application/vnd.genomatix.tuxedo": { source: "iana", extensions: ["txd"] },
  "application/vnd.gentics.grd+json": { source: "iana", compressible: !0 },
  "application/vnd.geo+json": { source: "iana", compressible: !0 },
  "application/vnd.geocube+xml": { source: "iana", compressible: !0 },
  "application/vnd.geogebra.file": { source: "iana", extensions: ["ggb"] },
  "application/vnd.geogebra.slides": { source: "iana" },
  "application/vnd.geogebra.tool": { source: "iana", extensions: ["ggt"] },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: ["gex", "gre"],
  },
  "application/vnd.geonext": { source: "iana", extensions: ["gxt"] },
  "application/vnd.geoplan": { source: "iana", extensions: ["g2w"] },
  "application/vnd.geospace": { source: "iana", extensions: ["g3w"] },
  "application/vnd.gerber": { source: "iana" },
  "application/vnd.globalplatform.card-content-mgt": { source: "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana",
  },
  "application/vnd.gmx": { source: "iana", extensions: ["gmx"] },
  "application/vnd.google-apps.document": {
    compressible: !1,
    extensions: ["gdoc"],
  },
  "application/vnd.google-apps.presentation": {
    compressible: !1,
    extensions: ["gslides"],
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: !1,
    extensions: ["gsheet"],
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["kml"],
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: !1,
    extensions: ["kmz"],
  },
  "application/vnd.gov.sk.e-form+xml": { source: "iana", compressible: !0 },
  "application/vnd.gov.sk.e-form+zip": { source: "iana", compressible: !1 },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.grafeq": { source: "iana", extensions: ["gqf", "gqs"] },
  "application/vnd.gridmp": { source: "iana" },
  "application/vnd.groove-account": { source: "iana", extensions: ["gac"] },
  "application/vnd.groove-help": { source: "iana", extensions: ["ghf"] },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: ["gim"],
  },
  "application/vnd.groove-injector": { source: "iana", extensions: ["grv"] },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: ["gtm"],
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: ["tpl"],
  },
  "application/vnd.groove-vcard": { source: "iana", extensions: ["vcg"] },
  "application/vnd.hal+json": { source: "iana", compressible: !0 },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["hal"],
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["zmm"],
  },
  "application/vnd.hbci": { source: "iana", extensions: ["hbci"] },
  "application/vnd.hc+json": { source: "iana", compressible: !0 },
  "application/vnd.hcl-bireports": { source: "iana" },
  "application/vnd.hdt": { source: "iana" },
  "application/vnd.heroku+json": { source: "iana", compressible: !0 },
  "application/vnd.hhe.lesson-player": { source: "iana", extensions: ["les"] },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.hp-hpgl": { source: "iana", extensions: ["hpgl"] },
  "application/vnd.hp-hpid": { source: "iana", extensions: ["hpid"] },
  "application/vnd.hp-hps": { source: "iana", extensions: ["hps"] },
  "application/vnd.hp-jlyt": { source: "iana", extensions: ["jlt"] },
  "application/vnd.hp-pcl": { source: "iana", extensions: ["pcl"] },
  "application/vnd.hp-pclxl": { source: "iana", extensions: ["pclxl"] },
  "application/vnd.httphone": { source: "iana" },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: ["sfd-hdstx"],
  },
  "application/vnd.hyper+json": { source: "iana", compressible: !0 },
  "application/vnd.hyper-item+json": { source: "iana", compressible: !0 },
  "application/vnd.hyperdrive+json": { source: "iana", compressible: !0 },
  "application/vnd.hzn-3d-crossword": { source: "iana" },
  "application/vnd.ibm.afplinedata": { source: "iana" },
  "application/vnd.ibm.electronic-media": { source: "iana" },
  "application/vnd.ibm.minipay": { source: "iana", extensions: ["mpy"] },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: ["afp", "listafp", "list3820"],
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: ["irm"],
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: ["sc"],
  },
  "application/vnd.iccprofile": { source: "iana", extensions: ["icc", "icm"] },
  "application/vnd.ieee.1905": { source: "iana" },
  "application/vnd.igloader": { source: "iana", extensions: ["igl"] },
  "application/vnd.imagemeter.folder+zip": { source: "iana", compressible: !1 },
  "application/vnd.imagemeter.image+zip": { source: "iana", compressible: !1 },
  "application/vnd.immervision-ivp": { source: "iana", extensions: ["ivp"] },
  "application/vnd.immervision-ivu": { source: "iana", extensions: ["ivu"] },
  "application/vnd.ims.imsccv1p1": { source: "iana" },
  "application/vnd.ims.imsccv1p2": { source: "iana" },
  "application/vnd.ims.imsccv1p3": { source: "iana" },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.informix-visionary": { source: "iana" },
  "application/vnd.infotech.project": { source: "iana" },
  "application/vnd.infotech.project+xml": { source: "iana", compressible: !0 },
  "application/vnd.innopath.wamp.notification": { source: "iana" },
  "application/vnd.insors.igm": { source: "iana", extensions: ["igm"] },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: ["xpw", "xpx"],
  },
  "application/vnd.intergeo": { source: "iana", extensions: ["i2g"] },
  "application/vnd.intertrust.digibox": { source: "iana" },
  "application/vnd.intertrust.nncp": { source: "iana" },
  "application/vnd.intu.qbo": { source: "iana", extensions: ["qbo"] },
  "application/vnd.intu.qfx": { source: "iana", extensions: ["qfx"] },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.newsitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: ["rcprofile"],
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["irp"],
  },
  "application/vnd.is-xpr": { source: "iana", extensions: ["xpr"] },
  "application/vnd.isac.fcs": { source: "iana", extensions: ["fcs"] },
  "application/vnd.iso11783-10+zip": { source: "iana", compressible: !1 },
  "application/vnd.jam": { source: "iana", extensions: ["jam"] },
  "application/vnd.japannet-directory-service": { source: "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { source: "iana" },
  "application/vnd.japannet-payment-wakeup": { source: "iana" },
  "application/vnd.japannet-registration": { source: "iana" },
  "application/vnd.japannet-registration-wakeup": { source: "iana" },
  "application/vnd.japannet-setstore-wakeup": { source: "iana" },
  "application/vnd.japannet-verification": { source: "iana" },
  "application/vnd.japannet-verification-wakeup": { source: "iana" },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: ["rms"],
  },
  "application/vnd.jisp": { source: "iana", extensions: ["jisp"] },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: ["joda"],
  },
  "application/vnd.jsk.isdn-ngn": { source: "iana" },
  "application/vnd.kahootz": { source: "iana", extensions: ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { source: "iana", extensions: ["karbon"] },
  "application/vnd.kde.kchart": { source: "iana", extensions: ["chrt"] },
  "application/vnd.kde.kformula": { source: "iana", extensions: ["kfo"] },
  "application/vnd.kde.kivio": { source: "iana", extensions: ["flw"] },
  "application/vnd.kde.kontour": { source: "iana", extensions: ["kon"] },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: ["kpr", "kpt"],
  },
  "application/vnd.kde.kspread": { source: "iana", extensions: ["ksp"] },
  "application/vnd.kde.kword": { source: "iana", extensions: ["kwd", "kwt"] },
  "application/vnd.kenameaapp": { source: "iana", extensions: ["htke"] },
  "application/vnd.kidspiration": { source: "iana", extensions: ["kia"] },
  "application/vnd.kinar": { source: "iana", extensions: ["kne", "knp"] },
  "application/vnd.koan": {
    source: "iana",
    extensions: ["skp", "skd", "skt", "skm"],
  },
  "application/vnd.kodak-descriptor": { source: "iana", extensions: ["sse"] },
  "application/vnd.las": { source: "iana" },
  "application/vnd.las.las+json": { source: "iana", compressible: !0 },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lasxml"],
  },
  "application/vnd.laszip": { source: "iana" },
  "application/vnd.leap+json": { source: "iana", compressible: !0 },
  "application/vnd.liberty-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: ["lbd"],
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lbe"],
  },
  "application/vnd.logipipe.circuit+zip": { source: "iana", compressible: !1 },
  "application/vnd.loom": { source: "iana" },
  "application/vnd.lotus-1-2-3": { source: "iana", extensions: ["123"] },
  "application/vnd.lotus-approach": { source: "iana", extensions: ["apr"] },
  "application/vnd.lotus-freelance": { source: "iana", extensions: ["pre"] },
  "application/vnd.lotus-notes": { source: "iana", extensions: ["nsf"] },
  "application/vnd.lotus-organizer": { source: "iana", extensions: ["org"] },
  "application/vnd.lotus-screencam": { source: "iana", extensions: ["scm"] },
  "application/vnd.lotus-wordpro": { source: "iana", extensions: ["lwp"] },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: ["portpkg"],
  },
  "application/vnd.mapbox-vector-tile": { source: "iana", extensions: ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.marlin.drm.mdcf": { source: "iana" },
  "application/vnd.mason+json": { source: "iana", compressible: !0 },
  "application/vnd.maxar.archive.3tz+zip": { source: "iana", compressible: !1 },
  "application/vnd.maxmind.maxmind-db": { source: "iana" },
  "application/vnd.mcd": { source: "iana", extensions: ["mcd"] },
  "application/vnd.medcalcdata": { source: "iana", extensions: ["mc1"] },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: ["cdkey"],
  },
  "application/vnd.meridian-slingshot": { source: "iana" },
  "application/vnd.mfer": { source: "iana", extensions: ["mwf"] },
  "application/vnd.mfmp": { source: "iana", extensions: ["mfm"] },
  "application/vnd.micro+json": { source: "iana", compressible: !0 },
  "application/vnd.micrografx.flo": { source: "iana", extensions: ["flo"] },
  "application/vnd.micrografx.igx": { source: "iana", extensions: ["igx"] },
  "application/vnd.microsoft.portable-executable": { source: "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { source: "iana" },
  "application/vnd.miele+json": { source: "iana", compressible: !0 },
  "application/vnd.mif": { source: "iana", extensions: ["mif"] },
  "application/vnd.minisoft-hp3000-save": { source: "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { source: "iana" },
  "application/vnd.mobius.daf": { source: "iana", extensions: ["daf"] },
  "application/vnd.mobius.dis": { source: "iana", extensions: ["dis"] },
  "application/vnd.mobius.mbk": { source: "iana", extensions: ["mbk"] },
  "application/vnd.mobius.mqy": { source: "iana", extensions: ["mqy"] },
  "application/vnd.mobius.msl": { source: "iana", extensions: ["msl"] },
  "application/vnd.mobius.plc": { source: "iana", extensions: ["plc"] },
  "application/vnd.mobius.txf": { source: "iana", extensions: ["txf"] },
  "application/vnd.mophun.application": { source: "iana", extensions: ["mpn"] },
  "application/vnd.mophun.certificate": { source: "iana", extensions: ["mpc"] },
  "application/vnd.motorola.flexsuite": { source: "iana" },
  "application/vnd.motorola.flexsuite.adsi": { source: "iana" },
  "application/vnd.motorola.flexsuite.fis": { source: "iana" },
  "application/vnd.motorola.flexsuite.gotap": { source: "iana" },
  "application/vnd.motorola.flexsuite.kmr": { source: "iana" },
  "application/vnd.motorola.flexsuite.ttc": { source: "iana" },
  "application/vnd.motorola.flexsuite.wem": { source: "iana" },
  "application/vnd.motorola.iprm": { source: "iana" },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xul"],
  },
  "application/vnd.ms-3mfdocument": { source: "iana" },
  "application/vnd.ms-artgalry": { source: "iana", extensions: ["cil"] },
  "application/vnd.ms-asf": { source: "iana" },
  "application/vnd.ms-cab-compressed": { source: "iana", extensions: ["cab"] },
  "application/vnd.ms-color.iccprofile": { source: "apache" },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: !1,
    extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: ["xlam"],
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: ["xlsb"],
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: ["xlsm"],
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: ["xltm"],
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: !0,
    extensions: ["eot"],
  },
  "application/vnd.ms-htmlhelp": { source: "iana", extensions: ["chm"] },
  "application/vnd.ms-ims": { source: "iana", extensions: ["ims"] },
  "application/vnd.ms-lrm": { source: "iana", extensions: ["lrm"] },
  "application/vnd.ms-office.activex+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-officetheme": { source: "iana", extensions: ["thmx"] },
  "application/vnd.ms-opentype": { source: "apache", compressible: !0 },
  "application/vnd.ms-outlook": { compressible: !1, extensions: ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { source: "apache" },
  "application/vnd.ms-pki.seccat": { source: "apache", extensions: ["cat"] },
  "application/vnd.ms-pki.stl": { source: "apache", extensions: ["stl"] },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: !1,
    extensions: ["ppt", "pps", "pot"],
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: ["ppam"],
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: ["pptm"],
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: ["sldm"],
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: ["ppsm"],
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: ["potm"],
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: !0,
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ms-project": { source: "iana", extensions: ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { source: "iana" },
  "application/vnd.ms-windows.devicepairing": { source: "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { source: "iana" },
  "application/vnd.ms-windows.printerpairing": { source: "iana" },
  "application/vnd.ms-windows.wsd.oob": { source: "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { source: "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { source: "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { source: "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { source: "iana" },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: ["docm"],
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: ["dotm"],
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: ["wps", "wks", "wcm", "wdb"],
  },
  "application/vnd.ms-wpl": { source: "iana", extensions: ["wpl"] },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: !1,
    extensions: ["xps"],
  },
  "application/vnd.msa-disk-image": { source: "iana" },
  "application/vnd.mseq": { source: "iana", extensions: ["mseq"] },
  "application/vnd.msign": { source: "iana" },
  "application/vnd.multiad.creator": { source: "iana" },
  "application/vnd.multiad.creator.cif": { source: "iana" },
  "application/vnd.music-niff": { source: "iana" },
  "application/vnd.musician": { source: "iana", extensions: ["mus"] },
  "application/vnd.muvee.style": { source: "iana", extensions: ["msty"] },
  "application/vnd.mynfc": { source: "iana", extensions: ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { source: "iana", compressible: !0 },
  "application/vnd.ncd.control": { source: "iana" },
  "application/vnd.ncd.reference": { source: "iana" },
  "application/vnd.nearst.inv+json": { source: "iana", compressible: !0 },
  "application/vnd.nebumind.line": { source: "iana" },
  "application/vnd.nervana": { source: "iana" },
  "application/vnd.netfpx": { source: "iana" },
  "application/vnd.neurolanguage.nlu": { source: "iana", extensions: ["nlu"] },
  "application/vnd.nimn": { source: "iana" },
  "application/vnd.nintendo.nitro.rom": { source: "iana" },
  "application/vnd.nintendo.snes.rom": { source: "iana" },
  "application/vnd.nitf": { source: "iana", extensions: ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { source: "iana", extensions: ["nnd"] },
  "application/vnd.noblenet-sealer": { source: "iana", extensions: ["nns"] },
  "application/vnd.noblenet-web": { source: "iana", extensions: ["nnw"] },
  "application/vnd.nokia.catalogs": { source: "iana" },
  "application/vnd.nokia.conml+wbxml": { source: "iana" },
  "application/vnd.nokia.conml+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.iptv.config+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.isds-radio-presets": { source: "iana" },
  "application/vnd.nokia.landmark+wbxml": { source: "iana" },
  "application/vnd.nokia.landmark+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ac"],
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: ["ngdat"],
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: ["n-gage"],
  },
  "application/vnd.nokia.ncd": { source: "iana" },
  "application/vnd.nokia.pcd+wbxml": { source: "iana" },
  "application/vnd.nokia.pcd+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: ["rpst"],
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: ["rpss"],
  },
  "application/vnd.novadigm.edm": { source: "iana", extensions: ["edm"] },
  "application/vnd.novadigm.edx": { source: "iana", extensions: ["edx"] },
  "application/vnd.novadigm.ext": { source: "iana", extensions: ["ext"] },
  "application/vnd.ntt-local.content-share": { source: "iana" },
  "application/vnd.ntt-local.file-transfer": { source: "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { source: "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { source: "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { source: "iana" },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: ["odc"],
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: ["otc"],
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: ["odb"],
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: ["odf"],
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: ["odft"],
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: !1,
    extensions: ["odg"],
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: ["otg"],
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: ["odi"],
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: ["oti"],
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: !1,
    extensions: ["odp"],
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: ["otp"],
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: !1,
    extensions: ["ods"],
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: ["ots"],
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: !1,
    extensions: ["odt"],
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: ["odm"],
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: ["ott"],
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: ["oth"],
  },
  "application/vnd.obn": { source: "iana" },
  "application/vnd.ocf+cbor": { source: "iana" },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oftn.l10n+json": { source: "iana", compressible: !0 },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oipf.cspg-hexbinary": { source: "iana" },
  "application/vnd.oipf.dae.svg+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.dae.xhtml+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oipf.pae.gem": { source: "iana" },
  "application/vnd.oipf.spdiscovery+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.spdlist+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.ueprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.userprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.olpc-sugar": { source: "iana", extensions: ["xo"] },
  "application/vnd.oma-scws-config": { source: "iana" },
  "application/vnd.oma-scws-http-request": { source: "iana" },
  "application/vnd.oma-scws-http-response": { source: "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.imd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.ltkm": { source: "iana" },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.provisioningtrigger": { source: "iana" },
  "application/vnd.oma.bcast.sgboot": { source: "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.sgdu": { source: "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { source: "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.sprov+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.stkm": { source: "iana" },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.cab-pcc+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.dcd": { source: "iana" },
  "application/vnd.oma.dcdc": { source: "iana" },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["dd2"],
  },
  "application/vnd.oma.drm.risd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.lwm2m+cbor": { source: "iana" },
  "application/vnd.oma.lwm2m+json": { source: "iana", compressible: !0 },
  "application/vnd.oma.lwm2m+tlv": { source: "iana" },
  "application/vnd.oma.pal+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.poc.groups+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.push": { source: "iana" },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.omaloc-supl-init": { source: "iana" },
  "application/vnd.onepager": { source: "iana" },
  "application/vnd.onepagertamp": { source: "iana" },
  "application/vnd.onepagertamx": { source: "iana" },
  "application/vnd.onepagertat": { source: "iana" },
  "application/vnd.onepagertatp": { source: "iana" },
  "application/vnd.onepagertatx": { source: "iana" },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["obgx"],
  },
  "application/vnd.openblox.game-binary": { source: "iana" },
  "application/vnd.openeye.oeb": { source: "iana" },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: ["oxt"],
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["osm"],
  },
  "application/vnd.opentimestamps.ots": { source: "iana" },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: !1,
    extensions: ["pptx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: ["sldx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: ["ppsx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: ["potx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: !1,
    extensions: ["xlsx"],
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: ["xltx"],
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana",
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: !1,
    extensions: ["docx"],
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: ["dotx"],
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oracle.resource+json": { source: "iana", compressible: !0 },
  "application/vnd.orange.indata": { source: "iana" },
  "application/vnd.osa.netdeploy": { source: "iana" },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: ["mgp"],
  },
  "application/vnd.osgi.bundle": { source: "iana" },
  "application/vnd.osgi.dp": { source: "iana", extensions: ["dp"] },
  "application/vnd.osgi.subsystem": { source: "iana", extensions: ["esa"] },
  "application/vnd.otps.ct-kip+xml": { source: "iana", compressible: !0 },
  "application/vnd.oxli.countgraph": { source: "iana" },
  "application/vnd.pagerduty+json": { source: "iana", compressible: !0 },
  "application/vnd.palm": {
    source: "iana",
    extensions: ["pdb", "pqa", "oprc"],
  },
  "application/vnd.panoply": { source: "iana" },
  "application/vnd.paos.xml": { source: "iana" },
  "application/vnd.patentdive": { source: "iana" },
  "application/vnd.patientecommsdoc": { source: "iana" },
  "application/vnd.pawaafile": { source: "iana", extensions: ["paw"] },
  "application/vnd.pcos": { source: "iana" },
  "application/vnd.pg.format": { source: "iana", extensions: ["str"] },
  "application/vnd.pg.osasli": { source: "iana", extensions: ["ei6"] },
  "application/vnd.piaccess.application-licence": { source: "iana" },
  "application/vnd.picsel": { source: "iana", extensions: ["efif"] },
  "application/vnd.pmi.widget": { source: "iana", extensions: ["wg"] },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.pocketlearn": { source: "iana", extensions: ["plf"] },
  "application/vnd.powerbuilder6": { source: "iana", extensions: ["pbd"] },
  "application/vnd.powerbuilder6-s": { source: "iana" },
  "application/vnd.powerbuilder7": { source: "iana" },
  "application/vnd.powerbuilder7-s": { source: "iana" },
  "application/vnd.powerbuilder75": { source: "iana" },
  "application/vnd.powerbuilder75-s": { source: "iana" },
  "application/vnd.preminet": { source: "iana" },
  "application/vnd.previewsystems.box": { source: "iana", extensions: ["box"] },
  "application/vnd.proteus.magazine": { source: "iana", extensions: ["mgz"] },
  "application/vnd.psfs": { source: "iana" },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: ["qps"],
  },
  "application/vnd.pvi.ptid1": { source: "iana", extensions: ["ptid"] },
  "application/vnd.pwg-multiplexed": { source: "iana" },
  "application/vnd.pwg-xhtml-print+xml": { source: "iana", compressible: !0 },
  "application/vnd.qualcomm.brew-app-res": { source: "iana" },
  "application/vnd.quarantainenet": { source: "iana" },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
  },
  "application/vnd.quobject-quoxdocument": { source: "iana" },
  "application/vnd.radisys.moml+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-conf+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.rainstor.data": { source: "iana" },
  "application/vnd.rapid": { source: "iana" },
  "application/vnd.rar": { source: "iana", extensions: ["rar"] },
  "application/vnd.realvnc.bed": { source: "iana", extensions: ["bed"] },
  "application/vnd.recordare.musicxml": { source: "iana", extensions: ["mxl"] },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["musicxml"],
  },
  "application/vnd.renlearn.rlprint": { source: "iana" },
  "application/vnd.resilient.logic": { source: "iana" },
  "application/vnd.restful+json": { source: "iana", compressible: !0 },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: ["cryptonote"],
  },
  "application/vnd.rim.cod": { source: "apache", extensions: ["cod"] },
  "application/vnd.rn-realmedia": { source: "apache", extensions: ["rm"] },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: ["rmvb"],
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["link66"],
  },
  "application/vnd.rs-274x": { source: "iana" },
  "application/vnd.ruckus.download": { source: "iana" },
  "application/vnd.s3sms": { source: "iana" },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: ["st"],
  },
  "application/vnd.sar": { source: "iana" },
  "application/vnd.sbm.cid": { source: "iana" },
  "application/vnd.sbm.mid2": { source: "iana" },
  "application/vnd.scribus": { source: "iana" },
  "application/vnd.sealed.3df": { source: "iana" },
  "application/vnd.sealed.csf": { source: "iana" },
  "application/vnd.sealed.doc": { source: "iana" },
  "application/vnd.sealed.eml": { source: "iana" },
  "application/vnd.sealed.mht": { source: "iana" },
  "application/vnd.sealed.net": { source: "iana" },
  "application/vnd.sealed.ppt": { source: "iana" },
  "application/vnd.sealed.tiff": { source: "iana" },
  "application/vnd.sealed.xls": { source: "iana" },
  "application/vnd.sealedmedia.softseal.html": { source: "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { source: "iana" },
  "application/vnd.seemail": { source: "iana", extensions: ["see"] },
  "application/vnd.seis+json": { source: "iana", compressible: !0 },
  "application/vnd.sema": { source: "iana", extensions: ["sema"] },
  "application/vnd.semd": { source: "iana", extensions: ["semd"] },
  "application/vnd.semf": { source: "iana", extensions: ["semf"] },
  "application/vnd.shade-save-file": { source: "iana" },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: ["ifm"],
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: ["itp"],
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: ["iif"],
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: ["ipk"],
  },
  "application/vnd.shootproof+json": { source: "iana", compressible: !0 },
  "application/vnd.shopkick+json": { source: "iana", compressible: !0 },
  "application/vnd.shp": { source: "iana" },
  "application/vnd.shx": { source: "iana" },
  "application/vnd.sigrok.session": { source: "iana" },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: ["twd", "twds"],
  },
  "application/vnd.siren+json": { source: "iana", compressible: !0 },
  "application/vnd.smaf": { source: "iana", extensions: ["mmf"] },
  "application/vnd.smart.notebook": { source: "iana" },
  "application/vnd.smart.teacher": { source: "iana", extensions: ["teacher"] },
  "application/vnd.snesdev-page-table": { source: "iana" },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["fo"],
  },
  "application/vnd.software602.filler.form-xml-zip": { source: "iana" },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sdkm", "sdkd"],
  },
  "application/vnd.spotfire.dxp": { source: "iana", extensions: ["dxp"] },
  "application/vnd.spotfire.sfs": { source: "iana", extensions: ["sfs"] },
  "application/vnd.sqlite3": { source: "iana" },
  "application/vnd.sss-cod": { source: "iana" },
  "application/vnd.sss-dtf": { source: "iana" },
  "application/vnd.sss-ntf": { source: "iana" },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: ["sdc"],
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: ["sda"],
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: ["sdd"],
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: ["smf"],
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: ["sdw", "vor"],
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: ["sgl"],
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: ["smzip"],
  },
  "application/vnd.stepmania.stepchart": { source: "iana", extensions: ["sm"] },
  "application/vnd.street-stream": { source: "iana" },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wadl"],
  },
  "application/vnd.sun.xml.calc": { source: "apache", extensions: ["sxc"] },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: ["stc"],
  },
  "application/vnd.sun.xml.draw": { source: "apache", extensions: ["sxd"] },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: ["std"],
  },
  "application/vnd.sun.xml.impress": { source: "apache", extensions: ["sxi"] },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: ["sti"],
  },
  "application/vnd.sun.xml.math": { source: "apache", extensions: ["sxm"] },
  "application/vnd.sun.xml.writer": { source: "apache", extensions: ["sxw"] },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: ["sxg"],
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: ["stw"],
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: ["sus", "susp"],
  },
  "application/vnd.svd": { source: "iana", extensions: ["svd"] },
  "application/vnd.swiftview-ics": { source: "iana" },
  "application/vnd.sycle+xml": { source: "iana", compressible: !0 },
  "application/vnd.syft+json": { source: "iana", compressible: !0 },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: ["sis", "sisx"],
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["xsm"],
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["bdm"],
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["xdm"],
  },
  "application/vnd.syncml.dm.notification": { source: "iana" },
  "application/vnd.syncml.dmddf+wbxml": { source: "iana" },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["ddf"],
  },
  "application/vnd.syncml.dmtnds+wbxml": { source: "iana" },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.syncml.ds.notification": { source: "iana" },
  "application/vnd.tableschema+json": { source: "iana", compressible: !0 },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: ["tao"],
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: ["pcap", "cap", "dmp"],
  },
  "application/vnd.think-cell.ppttc+json": { source: "iana", compressible: !0 },
  "application/vnd.tmd.mediaflex.api+xml": { source: "iana", compressible: !0 },
  "application/vnd.tml": { source: "iana" },
  "application/vnd.tmobile-livetv": { source: "iana", extensions: ["tmo"] },
  "application/vnd.tri.onesource": { source: "iana" },
  "application/vnd.trid.tpt": { source: "iana", extensions: ["tpt"] },
  "application/vnd.triscape.mxs": { source: "iana", extensions: ["mxs"] },
  "application/vnd.trueapp": { source: "iana", extensions: ["tra"] },
  "application/vnd.truedoc": { source: "iana" },
  "application/vnd.ubisoft.webplayer": { source: "iana" },
  "application/vnd.ufdl": { source: "iana", extensions: ["ufd", "ufdl"] },
  "application/vnd.uiq.theme": { source: "iana", extensions: ["utz"] },
  "application/vnd.umajin": { source: "iana", extensions: ["umj"] },
  "application/vnd.unity": { source: "iana", extensions: ["unityweb"] },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["uoml"],
  },
  "application/vnd.uplanet.alert": { source: "iana" },
  "application/vnd.uplanet.alert-wbxml": { source: "iana" },
  "application/vnd.uplanet.bearer-choice": { source: "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { source: "iana" },
  "application/vnd.uplanet.cacheop": { source: "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { source: "iana" },
  "application/vnd.uplanet.channel": { source: "iana" },
  "application/vnd.uplanet.channel-wbxml": { source: "iana" },
  "application/vnd.uplanet.list": { source: "iana" },
  "application/vnd.uplanet.list-wbxml": { source: "iana" },
  "application/vnd.uplanet.listcmd": { source: "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { source: "iana" },
  "application/vnd.uplanet.signal": { source: "iana" },
  "application/vnd.uri-map": { source: "iana" },
  "application/vnd.valve.source.material": { source: "iana" },
  "application/vnd.vcx": { source: "iana", extensions: ["vcx"] },
  "application/vnd.vd-study": { source: "iana" },
  "application/vnd.vectorworks": { source: "iana" },
  "application/vnd.vel+json": { source: "iana", compressible: !0 },
  "application/vnd.verimatrix.vcas": { source: "iana" },
  "application/vnd.veritone.aion+json": { source: "iana", compressible: !0 },
  "application/vnd.veryant.thin": { source: "iana" },
  "application/vnd.ves.encrypted": { source: "iana" },
  "application/vnd.vidsoft.vidconference": { source: "iana" },
  "application/vnd.visio": {
    source: "iana",
    extensions: ["vsd", "vst", "vss", "vsw"],
  },
  "application/vnd.visionary": { source: "iana", extensions: ["vis"] },
  "application/vnd.vividence.scriptfile": { source: "iana" },
  "application/vnd.vsf": { source: "iana", extensions: ["vsf"] },
  "application/vnd.wap.sic": { source: "iana" },
  "application/vnd.wap.slc": { source: "iana" },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["wbxml"],
  },
  "application/vnd.wap.wmlc": { source: "iana", extensions: ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { source: "iana", extensions: ["wmlsc"] },
  "application/vnd.webturbo": { source: "iana", extensions: ["wtb"] },
  "application/vnd.wfa.dpp": { source: "iana" },
  "application/vnd.wfa.p2p": { source: "iana" },
  "application/vnd.wfa.wsc": { source: "iana" },
  "application/vnd.windows.devicepairing": { source: "iana" },
  "application/vnd.wmc": { source: "iana" },
  "application/vnd.wmf.bootstrap": { source: "iana" },
  "application/vnd.wolfram.mathematica": { source: "iana" },
  "application/vnd.wolfram.mathematica.package": { source: "iana" },
  "application/vnd.wolfram.player": { source: "iana", extensions: ["nbp"] },
  "application/vnd.wordperfect": { source: "iana", extensions: ["wpd"] },
  "application/vnd.wqd": { source: "iana", extensions: ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { source: "iana" },
  "application/vnd.wt.stf": { source: "iana", extensions: ["stf"] },
  "application/vnd.wv.csp+wbxml": { source: "iana" },
  "application/vnd.wv.csp+xml": { source: "iana", compressible: !0 },
  "application/vnd.wv.ssp+xml": { source: "iana", compressible: !0 },
  "application/vnd.xacml+json": { source: "iana", compressible: !0 },
  "application/vnd.xara": { source: "iana", extensions: ["xar"] },
  "application/vnd.xfdl": { source: "iana", extensions: ["xfdl"] },
  "application/vnd.xfdl.webform": { source: "iana" },
  "application/vnd.xmi+xml": { source: "iana", compressible: !0 },
  "application/vnd.xmpie.cpkg": { source: "iana" },
  "application/vnd.xmpie.dpkg": { source: "iana" },
  "application/vnd.xmpie.plan": { source: "iana" },
  "application/vnd.xmpie.ppkg": { source: "iana" },
  "application/vnd.xmpie.xlim": { source: "iana" },
  "application/vnd.yamaha.hv-dic": { source: "iana", extensions: ["hvd"] },
  "application/vnd.yamaha.hv-script": { source: "iana", extensions: ["hvs"] },
  "application/vnd.yamaha.hv-voice": { source: "iana", extensions: ["hvp"] },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: ["osf"],
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["osfpvg"],
  },
  "application/vnd.yamaha.remote-setup": { source: "iana" },
  "application/vnd.yamaha.smaf-audio": { source: "iana", extensions: ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { source: "iana", extensions: ["spf"] },
  "application/vnd.yamaha.through-ngn": { source: "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { source: "iana" },
  "application/vnd.yaoweme": { source: "iana" },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: ["cmp"],
  },
  "application/vnd.youtube.yt": { source: "iana" },
  "application/vnd.zul": { source: "iana", extensions: ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["zaz"],
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["vxml"],
  },
  "application/voucher-cms+json": { source: "iana", compressible: !0 },
  "application/vq-rtcpxr": { source: "iana" },
  "application/wasm": {
    source: "iana",
    compressible: !0,
    extensions: ["wasm"],
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wif"],
  },
  "application/webpush-options+json": { source: "iana", compressible: !0 },
  "application/whoispp-query": { source: "iana" },
  "application/whoispp-response": { source: "iana" },
  "application/widget": { source: "iana", extensions: ["wgt"] },
  "application/winhlp": { source: "apache", extensions: ["hlp"] },
  "application/wita": { source: "iana" },
  "application/wordperfect5.1": { source: "iana" },
  "application/wsdl+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wsdl"],
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wspolicy"],
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: !1,
    extensions: ["7z"],
  },
  "application/x-abiword": { source: "apache", extensions: ["abw"] },
  "application/x-ace-compressed": { source: "apache", extensions: ["ace"] },
  "application/x-amf": { source: "apache" },
  "application/x-apple-diskimage": { source: "apache", extensions: ["dmg"] },
  "application/x-arj": { compressible: !1, extensions: ["arj"] },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: ["aab", "x32", "u32", "vox"],
  },
  "application/x-authorware-map": { source: "apache", extensions: ["aam"] },
  "application/x-authorware-seg": { source: "apache", extensions: ["aas"] },
  "application/x-bcpio": { source: "apache", extensions: ["bcpio"] },
  "application/x-bdoc": { compressible: !1, extensions: ["bdoc"] },
  "application/x-bittorrent": { source: "apache", extensions: ["torrent"] },
  "application/x-blorb": { source: "apache", extensions: ["blb", "blorb"] },
  "application/x-bzip": {
    source: "apache",
    compressible: !1,
    extensions: ["bz"],
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: !1,
    extensions: ["bz2", "boz"],
  },
  "application/x-cbr": {
    source: "apache",
    extensions: ["cbr", "cba", "cbt", "cbz", "cb7"],
  },
  "application/x-cdlink": { source: "apache", extensions: ["vcd"] },
  "application/x-cfs-compressed": { source: "apache", extensions: ["cfs"] },
  "application/x-chat": { source: "apache", extensions: ["chat"] },
  "application/x-chess-pgn": { source: "apache", extensions: ["pgn"] },
  "application/x-chrome-extension": { extensions: ["crx"] },
  "application/x-cocoa": { source: "nginx", extensions: ["cco"] },
  "application/x-compress": { source: "apache" },
  "application/x-conference": { source: "apache", extensions: ["nsc"] },
  "application/x-cpio": { source: "apache", extensions: ["cpio"] },
  "application/x-csh": { source: "apache", extensions: ["csh"] },
  "application/x-deb": { compressible: !1 },
  "application/x-debian-package": {
    source: "apache",
    extensions: ["deb", "udeb"],
  },
  "application/x-dgc-compressed": { source: "apache", extensions: ["dgc"] },
  "application/x-director": {
    source: "apache",
    extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"],
  },
  "application/x-doom": { source: "apache", extensions: ["wad"] },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["ncx"],
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["dtb"],
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["res"],
  },
  "application/x-dvi": {
    source: "apache",
    compressible: !1,
    extensions: ["dvi"],
  },
  "application/x-envoy": { source: "apache", extensions: ["evy"] },
  "application/x-eva": { source: "apache", extensions: ["eva"] },
  "application/x-font-bdf": { source: "apache", extensions: ["bdf"] },
  "application/x-font-dos": { source: "apache" },
  "application/x-font-framemaker": { source: "apache" },
  "application/x-font-ghostscript": { source: "apache", extensions: ["gsf"] },
  "application/x-font-libgrx": { source: "apache" },
  "application/x-font-linux-psf": { source: "apache", extensions: ["psf"] },
  "application/x-font-pcf": { source: "apache", extensions: ["pcf"] },
  "application/x-font-snf": { source: "apache", extensions: ["snf"] },
  "application/x-font-speedo": { source: "apache" },
  "application/x-font-sunos-news": { source: "apache" },
  "application/x-font-type1": {
    source: "apache",
    extensions: ["pfa", "pfb", "pfm", "afm"],
  },
  "application/x-font-vfont": { source: "apache" },
  "application/x-freearc": { source: "apache", extensions: ["arc"] },
  "application/x-futuresplash": { source: "apache", extensions: ["spl"] },
  "application/x-gca-compressed": { source: "apache", extensions: ["gca"] },
  "application/x-glulx": { source: "apache", extensions: ["ulx"] },
  "application/x-gnumeric": { source: "apache", extensions: ["gnumeric"] },
  "application/x-gramps-xml": { source: "apache", extensions: ["gramps"] },
  "application/x-gtar": { source: "apache", extensions: ["gtar"] },
  "application/x-gzip": { source: "apache" },
  "application/x-hdf": { source: "apache", extensions: ["hdf"] },
  "application/x-httpd-php": { compressible: !0, extensions: ["php"] },
  "application/x-install-instructions": {
    source: "apache",
    extensions: ["install"],
  },
  "application/x-iso9660-image": { source: "apache", extensions: ["iso"] },
  "application/x-iwork-keynote-sffkey": { extensions: ["key"] },
  "application/x-iwork-numbers-sffnumbers": { extensions: ["numbers"] },
  "application/x-iwork-pages-sffpages": { extensions: ["pages"] },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: ["jardiff"],
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: !1,
    extensions: ["jnlp"],
  },
  "application/x-javascript": { compressible: !0 },
  "application/x-keepass2": { extensions: ["kdbx"] },
  "application/x-latex": {
    source: "apache",
    compressible: !1,
    extensions: ["latex"],
  },
  "application/x-lua-bytecode": { extensions: ["luac"] },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: ["lzh", "lha"],
  },
  "application/x-makeself": { source: "nginx", extensions: ["run"] },
  "application/x-mie": { source: "apache", extensions: ["mie"] },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: ["prc", "mobi"],
  },
  "application/x-mpegurl": { compressible: !1 },
  "application/x-ms-application": {
    source: "apache",
    extensions: ["application"],
  },
  "application/x-ms-shortcut": { source: "apache", extensions: ["lnk"] },
  "application/x-ms-wmd": { source: "apache", extensions: ["wmd"] },
  "application/x-ms-wmz": { source: "apache", extensions: ["wmz"] },
  "application/x-ms-xbap": { source: "apache", extensions: ["xbap"] },
  "application/x-msaccess": { source: "apache", extensions: ["mdb"] },
  "application/x-msbinder": { source: "apache", extensions: ["obd"] },
  "application/x-mscardfile": { source: "apache", extensions: ["crd"] },
  "application/x-msclip": { source: "apache", extensions: ["clp"] },
  "application/x-msdos-program": { extensions: ["exe"] },
  "application/x-msdownload": {
    source: "apache",
    extensions: ["exe", "dll", "com", "bat", "msi"],
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: ["mvb", "m13", "m14"],
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: ["wmf", "wmz", "emf", "emz"],
  },
  "application/x-msmoney": { source: "apache", extensions: ["mny"] },
  "application/x-mspublisher": { source: "apache", extensions: ["pub"] },
  "application/x-msschedule": { source: "apache", extensions: ["scd"] },
  "application/x-msterminal": { source: "apache", extensions: ["trm"] },
  "application/x-mswrite": { source: "apache", extensions: ["wri"] },
  "application/x-netcdf": { source: "apache", extensions: ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": {
    compressible: !0,
    extensions: ["pac"],
  },
  "application/x-nzb": { source: "apache", extensions: ["nzb"] },
  "application/x-perl": { source: "nginx", extensions: ["pl", "pm"] },
  "application/x-pilot": { source: "nginx", extensions: ["prc", "pdb"] },
  "application/x-pkcs12": {
    source: "apache",
    compressible: !1,
    extensions: ["p12", "pfx"],
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: ["p7b", "spc"],
  },
  "application/x-pkcs7-certreqresp": { source: "apache", extensions: ["p7r"] },
  "application/x-pki-message": { source: "iana" },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: !1,
    extensions: ["rar"],
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: ["rpm"],
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: ["ris"],
  },
  "application/x-sea": { source: "nginx", extensions: ["sea"] },
  "application/x-sh": {
    source: "apache",
    compressible: !0,
    extensions: ["sh"],
  },
  "application/x-shar": { source: "apache", extensions: ["shar"] },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: !1,
    extensions: ["swf"],
  },
  "application/x-silverlight-app": { source: "apache", extensions: ["xap"] },
  "application/x-sql": { source: "apache", extensions: ["sql"] },
  "application/x-stuffit": {
    source: "apache",
    compressible: !1,
    extensions: ["sit"],
  },
  "application/x-stuffitx": { source: "apache", extensions: ["sitx"] },
  "application/x-subrip": { source: "apache", extensions: ["srt"] },
  "application/x-sv4cpio": { source: "apache", extensions: ["sv4cpio"] },
  "application/x-sv4crc": { source: "apache", extensions: ["sv4crc"] },
  "application/x-t3vm-image": { source: "apache", extensions: ["t3"] },
  "application/x-tads": { source: "apache", extensions: ["gam"] },
  "application/x-tar": {
    source: "apache",
    compressible: !0,
    extensions: ["tar"],
  },
  "application/x-tcl": { source: "apache", extensions: ["tcl", "tk"] },
  "application/x-tex": { source: "apache", extensions: ["tex"] },
  "application/x-tex-tfm": { source: "apache", extensions: ["tfm"] },
  "application/x-texinfo": {
    source: "apache",
    extensions: ["texinfo", "texi"],
  },
  "application/x-tgif": { source: "apache", extensions: ["obj"] },
  "application/x-ustar": { source: "apache", extensions: ["ustar"] },
  "application/x-virtualbox-hdd": { compressible: !0, extensions: ["hdd"] },
  "application/x-virtualbox-ova": { compressible: !0, extensions: ["ova"] },
  "application/x-virtualbox-ovf": { compressible: !0, extensions: ["ovf"] },
  "application/x-virtualbox-vbox": { compressible: !0, extensions: ["vbox"] },
  "application/x-virtualbox-vbox-extpack": {
    compressible: !1,
    extensions: ["vbox-extpack"],
  },
  "application/x-virtualbox-vdi": { compressible: !0, extensions: ["vdi"] },
  "application/x-virtualbox-vhd": { compressible: !0, extensions: ["vhd"] },
  "application/x-virtualbox-vmdk": { compressible: !0, extensions: ["vmdk"] },
  "application/x-wais-source": { source: "apache", extensions: ["src"] },
  "application/x-web-app-manifest+json": {
    compressible: !0,
    extensions: ["webapp"],
  },
  "application/x-www-form-urlencoded": { source: "iana", compressible: !0 },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: ["der", "crt", "pem"],
  },
  "application/x-x509-ca-ra-cert": { source: "iana" },
  "application/x-x509-next-ca-cert": { source: "iana" },
  "application/x-xfig": { source: "apache", extensions: ["fig"] },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xlf"],
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: !1,
    extensions: ["xpi"],
  },
  "application/x-xz": { source: "apache", extensions: ["xz"] },
  "application/x-zmachine": {
    source: "apache",
    extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
  },
  "application/x400-bp": { source: "iana" },
  "application/xacml+xml": { source: "iana", compressible: !0 },
  "application/xaml+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xaml"],
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xav"],
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xca"],
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xdf"],
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xel"],
  },
  "application/xcap-error+xml": { source: "iana", compressible: !0 },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xns"],
  },
  "application/xcon-conference-info+xml": { source: "iana", compressible: !0 },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xenc"],
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xhtml", "xht"],
  },
  "application/xhtml-voice+xml": { source: "apache", compressible: !0 },
  "application/xliff+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xlf"],
  },
  "application/xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xml", "xsl", "xsd", "rng"],
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: !0,
    extensions: ["dtd"],
  },
  "application/xml-external-parsed-entity": { source: "iana" },
  "application/xml-patch+xml": { source: "iana", compressible: !0 },
  "application/xmpp+xml": { source: "iana", compressible: !0 },
  "application/xop+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xop"],
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xpl"],
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xsl", "xslt"],
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xspf"],
  },
  "application/xv+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mxml", "xhvml", "xvml", "xvm"],
  },
  "application/yang": { source: "iana", extensions: ["yang"] },
  "application/yang-data+json": { source: "iana", compressible: !0 },
  "application/yang-data+xml": { source: "iana", compressible: !0 },
  "application/yang-patch+json": { source: "iana", compressible: !0 },
  "application/yang-patch+xml": { source: "iana", compressible: !0 },
  "application/yin+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["yin"],
  },
  "application/zip": { source: "iana", compressible: !1, extensions: ["zip"] },
  "application/zlib": { source: "iana" },
  "application/zstd": { source: "iana" },
  "audio/1d-interleaved-parityfec": { source: "iana" },
  "audio/32kadpcm": { source: "iana" },
  "audio/3gpp": { source: "iana", compressible: !1, extensions: ["3gpp"] },
  "audio/3gpp2": { source: "iana" },
  "audio/aac": { source: "iana" },
  "audio/ac3": { source: "iana" },
  "audio/adpcm": { source: "apache", extensions: ["adp"] },
  "audio/amr": { source: "iana", extensions: ["amr"] },
  "audio/amr-wb": { source: "iana" },
  "audio/amr-wb+": { source: "iana" },
  "audio/aptx": { source: "iana" },
  "audio/asc": { source: "iana" },
  "audio/atrac-advanced-lossless": { source: "iana" },
  "audio/atrac-x": { source: "iana" },
  "audio/atrac3": { source: "iana" },
  "audio/basic": {
    source: "iana",
    compressible: !1,
    extensions: ["au", "snd"],
  },
  "audio/bv16": { source: "iana" },
  "audio/bv32": { source: "iana" },
  "audio/clearmode": { source: "iana" },
  "audio/cn": { source: "iana" },
  "audio/dat12": { source: "iana" },
  "audio/dls": { source: "iana" },
  "audio/dsr-es201108": { source: "iana" },
  "audio/dsr-es202050": { source: "iana" },
  "audio/dsr-es202211": { source: "iana" },
  "audio/dsr-es202212": { source: "iana" },
  "audio/dv": { source: "iana" },
  "audio/dvi4": { source: "iana" },
  "audio/eac3": { source: "iana" },
  "audio/encaprtp": { source: "iana" },
  "audio/evrc": { source: "iana" },
  "audio/evrc-qcp": { source: "iana" },
  "audio/evrc0": { source: "iana" },
  "audio/evrc1": { source: "iana" },
  "audio/evrcb": { source: "iana" },
  "audio/evrcb0": { source: "iana" },
  "audio/evrcb1": { source: "iana" },
  "audio/evrcnw": { source: "iana" },
  "audio/evrcnw0": { source: "iana" },
  "audio/evrcnw1": { source: "iana" },
  "audio/evrcwb": { source: "iana" },
  "audio/evrcwb0": { source: "iana" },
  "audio/evrcwb1": { source: "iana" },
  "audio/evs": { source: "iana" },
  "audio/flexfec": { source: "iana" },
  "audio/fwdred": { source: "iana" },
  "audio/g711-0": { source: "iana" },
  "audio/g719": { source: "iana" },
  "audio/g722": { source: "iana" },
  "audio/g7221": { source: "iana" },
  "audio/g723": { source: "iana" },
  "audio/g726-16": { source: "iana" },
  "audio/g726-24": { source: "iana" },
  "audio/g726-32": { source: "iana" },
  "audio/g726-40": { source: "iana" },
  "audio/g728": { source: "iana" },
  "audio/g729": { source: "iana" },
  "audio/g7291": { source: "iana" },
  "audio/g729d": { source: "iana" },
  "audio/g729e": { source: "iana" },
  "audio/gsm": { source: "iana" },
  "audio/gsm-efr": { source: "iana" },
  "audio/gsm-hr-08": { source: "iana" },
  "audio/ilbc": { source: "iana" },
  "audio/ip-mr_v2.5": { source: "iana" },
  "audio/isac": { source: "apache" },
  "audio/l16": { source: "iana" },
  "audio/l20": { source: "iana" },
  "audio/l24": { source: "iana", compressible: !1 },
  "audio/l8": { source: "iana" },
  "audio/lpc": { source: "iana" },
  "audio/melp": { source: "iana" },
  "audio/melp1200": { source: "iana" },
  "audio/melp2400": { source: "iana" },
  "audio/melp600": { source: "iana" },
  "audio/mhas": { source: "iana" },
  "audio/midi": { source: "apache", extensions: ["mid", "midi", "kar", "rmi"] },
  "audio/mobile-xmf": { source: "iana", extensions: ["mxmf"] },
  "audio/mp3": { compressible: !1, extensions: ["mp3"] },
  "audio/mp4": {
    source: "iana",
    compressible: !1,
    extensions: ["m4a", "mp4a"],
  },
  "audio/mp4a-latm": { source: "iana" },
  "audio/mpa": { source: "iana" },
  "audio/mpa-robust": { source: "iana" },
  "audio/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
  },
  "audio/mpeg4-generic": { source: "iana" },
  "audio/musepack": { source: "apache" },
  "audio/ogg": {
    source: "iana",
    compressible: !1,
    extensions: ["oga", "ogg", "spx", "opus"],
  },
  "audio/opus": { source: "iana" },
  "audio/parityfec": { source: "iana" },
  "audio/pcma": { source: "iana" },
  "audio/pcma-wb": { source: "iana" },
  "audio/pcmu": { source: "iana" },
  "audio/pcmu-wb": { source: "iana" },
  "audio/prs.sid": { source: "iana" },
  "audio/qcelp": { source: "iana" },
  "audio/raptorfec": { source: "iana" },
  "audio/red": { source: "iana" },
  "audio/rtp-enc-aescm128": { source: "iana" },
  "audio/rtp-midi": { source: "iana" },
  "audio/rtploopback": { source: "iana" },
  "audio/rtx": { source: "iana" },
  "audio/s3m": { source: "apache", extensions: ["s3m"] },
  "audio/scip": { source: "iana" },
  "audio/silk": { source: "apache", extensions: ["sil"] },
  "audio/smv": { source: "iana" },
  "audio/smv-qcp": { source: "iana" },
  "audio/smv0": { source: "iana" },
  "audio/sofa": { source: "iana" },
  "audio/sp-midi": { source: "iana" },
  "audio/speex": { source: "iana" },
  "audio/t140c": { source: "iana" },
  "audio/t38": { source: "iana" },
  "audio/telephone-event": { source: "iana" },
  "audio/tetra_acelp": { source: "iana" },
  "audio/tetra_acelp_bb": { source: "iana" },
  "audio/tone": { source: "iana" },
  "audio/tsvcis": { source: "iana" },
  "audio/uemclip": { source: "iana" },
  "audio/ulpfec": { source: "iana" },
  "audio/usac": { source: "iana" },
  "audio/vdvi": { source: "iana" },
  "audio/vmr-wb": { source: "iana" },
  "audio/vnd.3gpp.iufp": { source: "iana" },
  "audio/vnd.4sb": { source: "iana" },
  "audio/vnd.audiokoz": { source: "iana" },
  "audio/vnd.celp": { source: "iana" },
  "audio/vnd.cisco.nse": { source: "iana" },
  "audio/vnd.cmles.radio-events": { source: "iana" },
  "audio/vnd.cns.anp1": { source: "iana" },
  "audio/vnd.cns.inf1": { source: "iana" },
  "audio/vnd.dece.audio": { source: "iana", extensions: ["uva", "uvva"] },
  "audio/vnd.digital-winds": { source: "iana", extensions: ["eol"] },
  "audio/vnd.dlna.adts": { source: "iana" },
  "audio/vnd.dolby.heaac.1": { source: "iana" },
  "audio/vnd.dolby.heaac.2": { source: "iana" },
  "audio/vnd.dolby.mlp": { source: "iana" },
  "audio/vnd.dolby.mps": { source: "iana" },
  "audio/vnd.dolby.pl2": { source: "iana" },
  "audio/vnd.dolby.pl2x": { source: "iana" },
  "audio/vnd.dolby.pl2z": { source: "iana" },
  "audio/vnd.dolby.pulse.1": { source: "iana" },
  "audio/vnd.dra": { source: "iana", extensions: ["dra"] },
  "audio/vnd.dts": { source: "iana", extensions: ["dts"] },
  "audio/vnd.dts.hd": { source: "iana", extensions: ["dtshd"] },
  "audio/vnd.dts.uhd": { source: "iana" },
  "audio/vnd.dvb.file": { source: "iana" },
  "audio/vnd.everad.plj": { source: "iana" },
  "audio/vnd.hns.audio": { source: "iana" },
  "audio/vnd.lucent.voice": { source: "iana", extensions: ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { source: "iana", extensions: ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { source: "iana" },
  "audio/vnd.nortel.vbk": { source: "iana" },
  "audio/vnd.nuera.ecelp4800": { source: "iana", extensions: ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { source: "iana", extensions: ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { source: "iana", extensions: ["ecelp9600"] },
  "audio/vnd.octel.sbc": { source: "iana" },
  "audio/vnd.presonus.multitrack": { source: "iana" },
  "audio/vnd.qcelp": { source: "iana" },
  "audio/vnd.rhetorex.32kadpcm": { source: "iana" },
  "audio/vnd.rip": { source: "iana", extensions: ["rip"] },
  "audio/vnd.rn-realaudio": { compressible: !1 },
  "audio/vnd.sealedmedia.softseal.mpeg": { source: "iana" },
  "audio/vnd.vmx.cvsd": { source: "iana" },
  "audio/vnd.wave": { compressible: !1 },
  "audio/vorbis": { source: "iana", compressible: !1 },
  "audio/vorbis-config": { source: "iana" },
  "audio/wav": { compressible: !1, extensions: ["wav"] },
  "audio/wave": { compressible: !1, extensions: ["wav"] },
  "audio/webm": { source: "apache", compressible: !1, extensions: ["weba"] },
  "audio/x-aac": { source: "apache", compressible: !1, extensions: ["aac"] },
  "audio/x-aiff": { source: "apache", extensions: ["aif", "aiff", "aifc"] },
  "audio/x-caf": { source: "apache", compressible: !1, extensions: ["caf"] },
  "audio/x-flac": { source: "apache", extensions: ["flac"] },
  "audio/x-m4a": { source: "nginx", extensions: ["m4a"] },
  "audio/x-matroska": { source: "apache", extensions: ["mka"] },
  "audio/x-mpegurl": { source: "apache", extensions: ["m3u"] },
  "audio/x-ms-wax": { source: "apache", extensions: ["wax"] },
  "audio/x-ms-wma": { source: "apache", extensions: ["wma"] },
  "audio/x-pn-realaudio": { source: "apache", extensions: ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { source: "apache", extensions: ["rmp"] },
  "audio/x-realaudio": { source: "nginx", extensions: ["ra"] },
  "audio/x-tta": { source: "apache" },
  "audio/x-wav": { source: "apache", extensions: ["wav"] },
  "audio/xm": { source: "apache", extensions: ["xm"] },
  "chemical/x-cdx": { source: "apache", extensions: ["cdx"] },
  "chemical/x-cif": { source: "apache", extensions: ["cif"] },
  "chemical/x-cmdf": { source: "apache", extensions: ["cmdf"] },
  "chemical/x-cml": { source: "apache", extensions: ["cml"] },
  "chemical/x-csml": { source: "apache", extensions: ["csml"] },
  "chemical/x-pdb": { source: "apache" },
  "chemical/x-xyz": { source: "apache", extensions: ["xyz"] },
  "font/collection": { source: "iana", extensions: ["ttc"] },
  "font/otf": { source: "iana", compressible: !0, extensions: ["otf"] },
  "font/sfnt": { source: "iana" },
  "font/ttf": { source: "iana", compressible: !0, extensions: ["ttf"] },
  "font/woff": { source: "iana", extensions: ["woff"] },
  "font/woff2": { source: "iana", extensions: ["woff2"] },
  "image/aces": { source: "iana", extensions: ["exr"] },
  "image/apng": { compressible: !1, extensions: ["apng"] },
  "image/avci": { source: "iana", extensions: ["avci"] },
  "image/avcs": { source: "iana", extensions: ["avcs"] },
  "image/avif": { source: "iana", compressible: !1, extensions: ["avif"] },
  "image/bmp": { source: "iana", compressible: !0, extensions: ["bmp"] },
  "image/cgm": { source: "iana", extensions: ["cgm"] },
  "image/dicom-rle": { source: "iana", extensions: ["drle"] },
  "image/emf": { source: "iana", extensions: ["emf"] },
  "image/fits": { source: "iana", extensions: ["fits"] },
  "image/g3fax": { source: "iana", extensions: ["g3"] },
  "image/gif": { source: "iana", compressible: !1, extensions: ["gif"] },
  "image/heic": { source: "iana", extensions: ["heic"] },
  "image/heic-sequence": { source: "iana", extensions: ["heics"] },
  "image/heif": { source: "iana", extensions: ["heif"] },
  "image/heif-sequence": { source: "iana", extensions: ["heifs"] },
  "image/hej2k": { source: "iana", extensions: ["hej2"] },
  "image/hsj2": { source: "iana", extensions: ["hsj2"] },
  "image/ief": { source: "iana", extensions: ["ief"] },
  "image/jls": { source: "iana", extensions: ["jls"] },
  "image/jp2": {
    source: "iana",
    compressible: !1,
    extensions: ["jp2", "jpg2"],
  },
  "image/jpeg": {
    source: "iana",
    compressible: !1,
    extensions: ["jpeg", "jpg", "jpe"],
  },
  "image/jph": { source: "iana", extensions: ["jph"] },
  "image/jphc": { source: "iana", extensions: ["jhc"] },
  "image/jpm": { source: "iana", compressible: !1, extensions: ["jpm"] },
  "image/jpx": { source: "iana", compressible: !1, extensions: ["jpx", "jpf"] },
  "image/jxr": { source: "iana", extensions: ["jxr"] },
  "image/jxra": { source: "iana", extensions: ["jxra"] },
  "image/jxrs": { source: "iana", extensions: ["jxrs"] },
  "image/jxs": { source: "iana", extensions: ["jxs"] },
  "image/jxsc": { source: "iana", extensions: ["jxsc"] },
  "image/jxsi": { source: "iana", extensions: ["jxsi"] },
  "image/jxss": { source: "iana", extensions: ["jxss"] },
  "image/ktx": { source: "iana", extensions: ["ktx"] },
  "image/ktx2": { source: "iana", extensions: ["ktx2"] },
  "image/naplps": { source: "iana" },
  "image/pjpeg": { compressible: !1 },
  "image/png": { source: "iana", compressible: !1, extensions: ["png"] },
  "image/prs.btif": { source: "iana", extensions: ["btif"] },
  "image/prs.pti": { source: "iana", extensions: ["pti"] },
  "image/pwg-raster": { source: "iana" },
  "image/sgi": { source: "apache", extensions: ["sgi"] },
  "image/svg+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["svg", "svgz"],
  },
  "image/t38": { source: "iana", extensions: ["t38"] },
  "image/tiff": {
    source: "iana",
    compressible: !1,
    extensions: ["tif", "tiff"],
  },
  "image/tiff-fx": { source: "iana", extensions: ["tfx"] },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: !0,
    extensions: ["psd"],
  },
  "image/vnd.airzip.accelerator.azv": { source: "iana", extensions: ["azv"] },
  "image/vnd.cns.inf2": { source: "iana" },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: ["uvi", "uvvi", "uvg", "uvvg"],
  },
  "image/vnd.djvu": { source: "iana", extensions: ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
  "image/vnd.dwg": { source: "iana", extensions: ["dwg"] },
  "image/vnd.dxf": { source: "iana", extensions: ["dxf"] },
  "image/vnd.fastbidsheet": { source: "iana", extensions: ["fbs"] },
  "image/vnd.fpx": { source: "iana", extensions: ["fpx"] },
  "image/vnd.fst": { source: "iana", extensions: ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { source: "iana", extensions: ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { source: "iana", extensions: ["rlc"] },
  "image/vnd.globalgraphics.pgb": { source: "iana" },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: !0,
    extensions: ["ico"],
  },
  "image/vnd.mix": { source: "iana" },
  "image/vnd.mozilla.apng": { source: "iana" },
  "image/vnd.ms-dds": { compressible: !0, extensions: ["dds"] },
  "image/vnd.ms-modi": { source: "iana", extensions: ["mdi"] },
  "image/vnd.ms-photo": { source: "apache", extensions: ["wdp"] },
  "image/vnd.net-fpx": { source: "iana", extensions: ["npx"] },
  "image/vnd.pco.b16": { source: "iana", extensions: ["b16"] },
  "image/vnd.radiance": { source: "iana" },
  "image/vnd.sealed.png": { source: "iana" },
  "image/vnd.sealedmedia.softseal.gif": { source: "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { source: "iana" },
  "image/vnd.svf": { source: "iana" },
  "image/vnd.tencent.tap": { source: "iana", extensions: ["tap"] },
  "image/vnd.valve.source.texture": { source: "iana", extensions: ["vtf"] },
  "image/vnd.wap.wbmp": { source: "iana", extensions: ["wbmp"] },
  "image/vnd.xiff": { source: "iana", extensions: ["xif"] },
  "image/vnd.zbrush.pcx": { source: "iana", extensions: ["pcx"] },
  "image/webp": { source: "apache", extensions: ["webp"] },
  "image/wmf": { source: "iana", extensions: ["wmf"] },
  "image/x-3ds": { source: "apache", extensions: ["3ds"] },
  "image/x-cmu-raster": { source: "apache", extensions: ["ras"] },
  "image/x-cmx": { source: "apache", extensions: ["cmx"] },
  "image/x-freehand": {
    source: "apache",
    extensions: ["fh", "fhc", "fh4", "fh5", "fh7"],
  },
  "image/x-icon": { source: "apache", compressible: !0, extensions: ["ico"] },
  "image/x-jng": { source: "nginx", extensions: ["jng"] },
  "image/x-mrsid-image": { source: "apache", extensions: ["sid"] },
  "image/x-ms-bmp": { source: "nginx", compressible: !0, extensions: ["bmp"] },
  "image/x-pcx": { source: "apache", extensions: ["pcx"] },
  "image/x-pict": { source: "apache", extensions: ["pic", "pct"] },
  "image/x-portable-anymap": { source: "apache", extensions: ["pnm"] },
  "image/x-portable-bitmap": { source: "apache", extensions: ["pbm"] },
  "image/x-portable-graymap": { source: "apache", extensions: ["pgm"] },
  "image/x-portable-pixmap": { source: "apache", extensions: ["ppm"] },
  "image/x-rgb": { source: "apache", extensions: ["rgb"] },
  "image/x-tga": { source: "apache", extensions: ["tga"] },
  "image/x-xbitmap": { source: "apache", extensions: ["xbm"] },
  "image/x-xcf": { compressible: !1 },
  "image/x-xpixmap": { source: "apache", extensions: ["xpm"] },
  "image/x-xwindowdump": { source: "apache", extensions: ["xwd"] },
  "message/cpim": { source: "iana" },
  "message/delivery-status": { source: "iana" },
  "message/disposition-notification": {
    source: "iana",
    extensions: ["disposition-notification"],
  },
  "message/external-body": { source: "iana" },
  "message/feedback-report": { source: "iana" },
  "message/global": { source: "iana", extensions: ["u8msg"] },
  "message/global-delivery-status": { source: "iana", extensions: ["u8dsn"] },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: ["u8mdn"],
  },
  "message/global-headers": { source: "iana", extensions: ["u8hdr"] },
  "message/http": { source: "iana", compressible: !1 },
  "message/imdn+xml": { source: "iana", compressible: !0 },
  "message/news": { source: "iana" },
  "message/partial": { source: "iana", compressible: !1 },
  "message/rfc822": {
    source: "iana",
    compressible: !0,
    extensions: ["eml", "mime"],
  },
  "message/s-http": { source: "iana" },
  "message/sip": { source: "iana" },
  "message/sipfrag": { source: "iana" },
  "message/tracking-status": { source: "iana" },
  "message/vnd.si.simp": { source: "iana" },
  "message/vnd.wfa.wsc": { source: "iana", extensions: ["wsc"] },
  "model/3mf": { source: "iana", extensions: ["3mf"] },
  "model/e57": { source: "iana" },
  "model/gltf+json": { source: "iana", compressible: !0, extensions: ["gltf"] },
  "model/gltf-binary": {
    source: "iana",
    compressible: !0,
    extensions: ["glb"],
  },
  "model/iges": {
    source: "iana",
    compressible: !1,
    extensions: ["igs", "iges"],
  },
  "model/mesh": {
    source: "iana",
    compressible: !1,
    extensions: ["msh", "mesh", "silo"],
  },
  "model/mtl": { source: "iana", extensions: ["mtl"] },
  "model/obj": { source: "iana", extensions: ["obj"] },
  "model/step": { source: "iana" },
  "model/step+xml": { source: "iana", compressible: !0, extensions: ["stpx"] },
  "model/step+zip": { source: "iana", compressible: !1, extensions: ["stpz"] },
  "model/step-xml+zip": {
    source: "iana",
    compressible: !1,
    extensions: ["stpxz"],
  },
  "model/stl": { source: "iana", extensions: ["stl"] },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["dae"],
  },
  "model/vnd.dwf": { source: "iana", extensions: ["dwf"] },
  "model/vnd.flatland.3dml": { source: "iana" },
  "model/vnd.gdl": { source: "iana", extensions: ["gdl"] },
  "model/vnd.gs-gdl": { source: "apache" },
  "model/vnd.gs.gdl": { source: "iana" },
  "model/vnd.gtw": { source: "iana", extensions: ["gtw"] },
  "model/vnd.moml+xml": { source: "iana", compressible: !0 },
  "model/vnd.mts": { source: "iana", extensions: ["mts"] },
  "model/vnd.opengex": { source: "iana", extensions: ["ogex"] },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: ["x_b"],
  },
  "model/vnd.parasolid.transmit.text": { source: "iana", extensions: ["x_t"] },
  "model/vnd.pytha.pyox": { source: "iana" },
  "model/vnd.rosette.annotated-data-model": { source: "iana" },
  "model/vnd.sap.vds": { source: "iana", extensions: ["vds"] },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: !1,
    extensions: ["usdz"],
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: ["bsp"],
  },
  "model/vnd.vtu": { source: "iana", extensions: ["vtu"] },
  "model/vrml": {
    source: "iana",
    compressible: !1,
    extensions: ["wrl", "vrml"],
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: !1,
    extensions: ["x3db", "x3dbz"],
  },
  "model/x3d+fastinfoset": { source: "iana", extensions: ["x3db"] },
  "model/x3d+vrml": {
    source: "apache",
    compressible: !1,
    extensions: ["x3dv", "x3dvz"],
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["x3d", "x3dz"],
  },
  "model/x3d-vrml": { source: "iana", extensions: ["x3dv"] },
  "multipart/alternative": { source: "iana", compressible: !1 },
  "multipart/appledouble": { source: "iana" },
  "multipart/byteranges": { source: "iana" },
  "multipart/digest": { source: "iana" },
  "multipart/encrypted": { source: "iana", compressible: !1 },
  "multipart/form-data": { source: "iana", compressible: !1 },
  "multipart/header-set": { source: "iana" },
  "multipart/mixed": { source: "iana" },
  "multipart/multilingual": { source: "iana" },
  "multipart/parallel": { source: "iana" },
  "multipart/related": { source: "iana", compressible: !1 },
  "multipart/report": { source: "iana" },
  "multipart/signed": { source: "iana", compressible: !1 },
  "multipart/vnd.bint.med-plus": { source: "iana" },
  "multipart/voice-message": { source: "iana" },
  "multipart/x-mixed-replace": { source: "iana" },
  "text/1d-interleaved-parityfec": { source: "iana" },
  "text/cache-manifest": {
    source: "iana",
    compressible: !0,
    extensions: ["appcache", "manifest"],
  },
  "text/calendar": { source: "iana", extensions: ["ics", "ifb"] },
  "text/calender": { compressible: !0 },
  "text/cmd": { compressible: !0 },
  "text/coffeescript": { extensions: ["coffee", "litcoffee"] },
  "text/cql": { source: "iana" },
  "text/cql-expression": { source: "iana" },
  "text/cql-identifier": { source: "iana" },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["css"],
  },
  "text/csv": { source: "iana", compressible: !0, extensions: ["csv"] },
  "text/csv-schema": { source: "iana" },
  "text/directory": { source: "iana" },
  "text/dns": { source: "iana" },
  "text/ecmascript": { source: "iana" },
  "text/encaprtp": { source: "iana" },
  "text/enriched": { source: "iana" },
  "text/fhirpath": { source: "iana" },
  "text/flexfec": { source: "iana" },
  "text/fwdred": { source: "iana" },
  "text/gff3": { source: "iana" },
  "text/grammar-ref-list": { source: "iana" },
  "text/html": {
    source: "iana",
    compressible: !0,
    extensions: ["html", "htm", "shtml"],
  },
  "text/jade": { extensions: ["jade"] },
  "text/javascript": { source: "iana", compressible: !0 },
  "text/jcr-cnd": { source: "iana" },
  "text/jsx": { compressible: !0, extensions: ["jsx"] },
  "text/less": { compressible: !0, extensions: ["less"] },
  "text/markdown": {
    source: "iana",
    compressible: !0,
    extensions: ["markdown", "md"],
  },
  "text/mathml": { source: "nginx", extensions: ["mml"] },
  "text/mdx": { compressible: !0, extensions: ["mdx"] },
  "text/mizar": { source: "iana" },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["n3"],
  },
  "text/parameters": { source: "iana", charset: "UTF-8" },
  "text/parityfec": { source: "iana" },
  "text/plain": {
    source: "iana",
    compressible: !0,
    extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
  },
  "text/provenance-notation": { source: "iana", charset: "UTF-8" },
  "text/prs.fallenstein.rst": { source: "iana" },
  "text/prs.lines.tag": { source: "iana", extensions: ["dsc"] },
  "text/prs.prop.logic": { source: "iana" },
  "text/raptorfec": { source: "iana" },
  "text/red": { source: "iana" },
  "text/rfc822-headers": { source: "iana" },
  "text/richtext": { source: "iana", compressible: !0, extensions: ["rtx"] },
  "text/rtf": { source: "iana", compressible: !0, extensions: ["rtf"] },
  "text/rtp-enc-aescm128": { source: "iana" },
  "text/rtploopback": { source: "iana" },
  "text/rtx": { source: "iana" },
  "text/sgml": { source: "iana", extensions: ["sgml", "sgm"] },
  "text/shaclc": { source: "iana" },
  "text/shex": { source: "iana", extensions: ["shex"] },
  "text/slim": { extensions: ["slim", "slm"] },
  "text/spdx": { source: "iana", extensions: ["spdx"] },
  "text/strings": { source: "iana" },
  "text/stylus": { extensions: ["stylus", "styl"] },
  "text/t140": { source: "iana" },
  "text/tab-separated-values": {
    source: "iana",
    compressible: !0,
    extensions: ["tsv"],
  },
  "text/troff": {
    source: "iana",
    extensions: ["t", "tr", "roff", "man", "me", "ms"],
  },
  "text/turtle": { source: "iana", charset: "UTF-8", extensions: ["ttl"] },
  "text/ulpfec": { source: "iana" },
  "text/uri-list": {
    source: "iana",
    compressible: !0,
    extensions: ["uri", "uris", "urls"],
  },
  "text/vcard": { source: "iana", compressible: !0, extensions: ["vcard"] },
  "text/vnd.a": { source: "iana" },
  "text/vnd.abc": { source: "iana" },
  "text/vnd.ascii-art": { source: "iana" },
  "text/vnd.curl": { source: "iana", extensions: ["curl"] },
  "text/vnd.curl.dcurl": { source: "apache", extensions: ["dcurl"] },
  "text/vnd.curl.mcurl": { source: "apache", extensions: ["mcurl"] },
  "text/vnd.curl.scurl": { source: "apache", extensions: ["scurl"] },
  "text/vnd.debian.copyright": { source: "iana", charset: "UTF-8" },
  "text/vnd.dmclientscript": { source: "iana" },
  "text/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { source: "iana", charset: "UTF-8" },
  "text/vnd.familysearch.gedcom": { source: "iana", extensions: ["ged"] },
  "text/vnd.ficlab.flt": { source: "iana" },
  "text/vnd.fly": { source: "iana", extensions: ["fly"] },
  "text/vnd.fmi.flexstor": { source: "iana", extensions: ["flx"] },
  "text/vnd.gml": { source: "iana" },
  "text/vnd.graphviz": { source: "iana", extensions: ["gv"] },
  "text/vnd.hans": { source: "iana" },
  "text/vnd.hgl": { source: "iana" },
  "text/vnd.in3d.3dml": { source: "iana", extensions: ["3dml"] },
  "text/vnd.in3d.spot": { source: "iana", extensions: ["spot"] },
  "text/vnd.iptc.newsml": { source: "iana" },
  "text/vnd.iptc.nitf": { source: "iana" },
  "text/vnd.latex-z": { source: "iana" },
  "text/vnd.motorola.reflex": { source: "iana" },
  "text/vnd.ms-mediapackage": { source: "iana" },
  "text/vnd.net2phone.commcenter.command": { source: "iana" },
  "text/vnd.radisys.msml-basic-layout": { source: "iana" },
  "text/vnd.senx.warpscript": { source: "iana" },
  "text/vnd.si.uricatalogue": { source: "iana" },
  "text/vnd.sosi": { source: "iana" },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["jad"],
  },
  "text/vnd.trolltech.linguist": { source: "iana", charset: "UTF-8" },
  "text/vnd.wap.si": { source: "iana" },
  "text/vnd.wap.sl": { source: "iana" },
  "text/vnd.wap.wml": { source: "iana", extensions: ["wml"] },
  "text/vnd.wap.wmlscript": { source: "iana", extensions: ["wmls"] },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["vtt"],
  },
  "text/x-asm": { source: "apache", extensions: ["s", "asm"] },
  "text/x-c": {
    source: "apache",
    extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
  },
  "text/x-component": { source: "nginx", extensions: ["htc"] },
  "text/x-fortran": {
    source: "apache",
    extensions: ["f", "for", "f77", "f90"],
  },
  "text/x-gwt-rpc": { compressible: !0 },
  "text/x-handlebars-template": { extensions: ["hbs"] },
  "text/x-java-source": { source: "apache", extensions: ["java"] },
  "text/x-jquery-tmpl": { compressible: !0 },
  "text/x-lua": { extensions: ["lua"] },
  "text/x-markdown": { compressible: !0, extensions: ["mkd"] },
  "text/x-nfo": { source: "apache", extensions: ["nfo"] },
  "text/x-opml": { source: "apache", extensions: ["opml"] },
  "text/x-org": { compressible: !0, extensions: ["org"] },
  "text/x-pascal": { source: "apache", extensions: ["p", "pas"] },
  "text/x-processing": { compressible: !0, extensions: ["pde"] },
  "text/x-sass": { extensions: ["sass"] },
  "text/x-scss": { extensions: ["scss"] },
  "text/x-setext": { source: "apache", extensions: ["etx"] },
  "text/x-sfv": { source: "apache", extensions: ["sfv"] },
  "text/x-suse-ymp": { compressible: !0, extensions: ["ymp"] },
  "text/x-uuencode": { source: "apache", extensions: ["uu"] },
  "text/x-vcalendar": { source: "apache", extensions: ["vcs"] },
  "text/x-vcard": { source: "apache", extensions: ["vcf"] },
  "text/xml": { source: "iana", compressible: !0, extensions: ["xml"] },
  "text/xml-external-parsed-entity": { source: "iana" },
  "text/yaml": { compressible: !0, extensions: ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { source: "iana" },
  "video/3gpp": { source: "iana", extensions: ["3gp", "3gpp"] },
  "video/3gpp-tt": { source: "iana" },
  "video/3gpp2": { source: "iana", extensions: ["3g2"] },
  "video/av1": { source: "iana" },
  "video/bmpeg": { source: "iana" },
  "video/bt656": { source: "iana" },
  "video/celb": { source: "iana" },
  "video/dv": { source: "iana" },
  "video/encaprtp": { source: "iana" },
  "video/ffv1": { source: "iana" },
  "video/flexfec": { source: "iana" },
  "video/h261": { source: "iana", extensions: ["h261"] },
  "video/h263": { source: "iana", extensions: ["h263"] },
  "video/h263-1998": { source: "iana" },
  "video/h263-2000": { source: "iana" },
  "video/h264": { source: "iana", extensions: ["h264"] },
  "video/h264-rcdo": { source: "iana" },
  "video/h264-svc": { source: "iana" },
  "video/h265": { source: "iana" },
  "video/iso.segment": { source: "iana", extensions: ["m4s"] },
  "video/jpeg": { source: "iana", extensions: ["jpgv"] },
  "video/jpeg2000": { source: "iana" },
  "video/jpm": { source: "apache", extensions: ["jpm", "jpgm"] },
  "video/jxsv": { source: "iana" },
  "video/mj2": { source: "iana", extensions: ["mj2", "mjp2"] },
  "video/mp1s": { source: "iana" },
  "video/mp2p": { source: "iana" },
  "video/mp2t": { source: "iana", extensions: ["ts"] },
  "video/mp4": {
    source: "iana",
    compressible: !1,
    extensions: ["mp4", "mp4v", "mpg4"],
  },
  "video/mp4v-es": { source: "iana" },
  "video/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"],
  },
  "video/mpeg4-generic": { source: "iana" },
  "video/mpv": { source: "iana" },
  "video/nv": { source: "iana" },
  "video/ogg": { source: "iana", compressible: !1, extensions: ["ogv"] },
  "video/parityfec": { source: "iana" },
  "video/pointer": { source: "iana" },
  "video/quicktime": {
    source: "iana",
    compressible: !1,
    extensions: ["qt", "mov"],
  },
  "video/raptorfec": { source: "iana" },
  "video/raw": { source: "iana" },
  "video/rtp-enc-aescm128": { source: "iana" },
  "video/rtploopback": { source: "iana" },
  "video/rtx": { source: "iana" },
  "video/scip": { source: "iana" },
  "video/smpte291": { source: "iana" },
  "video/smpte292m": { source: "iana" },
  "video/ulpfec": { source: "iana" },
  "video/vc1": { source: "iana" },
  "video/vc2": { source: "iana" },
  "video/vnd.cctv": { source: "iana" },
  "video/vnd.dece.hd": { source: "iana", extensions: ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { source: "iana", extensions: ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { source: "iana" },
  "video/vnd.dece.pd": { source: "iana", extensions: ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { source: "iana", extensions: ["uvs", "uvvs"] },
  "video/vnd.dece.video": { source: "iana", extensions: ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { source: "iana" },
  "video/vnd.directv.mpeg-tts": { source: "iana" },
  "video/vnd.dlna.mpeg-tts": { source: "iana" },
  "video/vnd.dvb.file": { source: "iana", extensions: ["dvb"] },
  "video/vnd.fvt": { source: "iana", extensions: ["fvt"] },
  "video/vnd.hns.video": { source: "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { source: "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { source: "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { source: "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { source: "iana" },
  "video/vnd.iptvforum.ttsavc": { source: "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { source: "iana" },
  "video/vnd.motorola.video": { source: "iana" },
  "video/vnd.motorola.videop": { source: "iana" },
  "video/vnd.mpegurl": { source: "iana", extensions: ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { source: "iana", extensions: ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { source: "iana" },
  "video/vnd.nokia.mp4vr": { source: "iana" },
  "video/vnd.nokia.videovoip": { source: "iana" },
  "video/vnd.objectvideo": { source: "iana" },
  "video/vnd.radgamettools.bink": { source: "iana" },
  "video/vnd.radgamettools.smacker": { source: "iana" },
  "video/vnd.sealed.mpeg1": { source: "iana" },
  "video/vnd.sealed.mpeg4": { source: "iana" },
  "video/vnd.sealed.swf": { source: "iana" },
  "video/vnd.sealedmedia.softseal.mov": { source: "iana" },
  "video/vnd.uvvu.mp4": { source: "iana", extensions: ["uvu", "uvvu"] },
  "video/vnd.vivo": { source: "iana", extensions: ["viv"] },
  "video/vnd.youtube.yt": { source: "iana" },
  "video/vp8": { source: "iana" },
  "video/vp9": { source: "iana" },
  "video/webm": { source: "apache", compressible: !1, extensions: ["webm"] },
  "video/x-f4v": { source: "apache", extensions: ["f4v"] },
  "video/x-fli": { source: "apache", extensions: ["fli"] },
  "video/x-flv": { source: "apache", compressible: !1, extensions: ["flv"] },
  "video/x-m4v": { source: "apache", extensions: ["m4v"] },
  "video/x-matroska": {
    source: "apache",
    compressible: !1,
    extensions: ["mkv", "mk3d", "mks"],
  },
  "video/x-mng": { source: "apache", extensions: ["mng"] },
  "video/x-ms-asf": { source: "apache", extensions: ["asf", "asx"] },
  "video/x-ms-vob": { source: "apache", extensions: ["vob"] },
  "video/x-ms-wm": { source: "apache", extensions: ["wm"] },
  "video/x-ms-wmv": { source: "apache", compressible: !1, extensions: ["wmv"] },
  "video/x-ms-wmx": { source: "apache", extensions: ["wmx"] },
  "video/x-ms-wvx": { source: "apache", extensions: ["wvx"] },
  "video/x-msvideo": { source: "apache", extensions: ["avi"] },
  "video/x-sgi-movie": { source: "apache", extensions: ["movie"] },
  "video/x-smv": { source: "apache", extensions: ["smv"] },
  "x-conference/x-cooltalk": { source: "apache", extensions: ["ice"] },
  "x-shader/x-fragment": { compressible: !0 },
  "x-shader/x-vertex": { compressible: !0 },
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ (function ($) {
  $.exports = require$$0;
})(mimeDb);
const __viteBrowserExternal = {},
  __viteBrowserExternal$1 = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: __viteBrowserExternal },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  require$$1 = getAugmentedNamespace(__viteBrowserExternal$1);
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ (function ($) {
  var r = mimeDbExports,
    p = require$$1.extname,
    v = /^\s*([^;\s]*)(?:;|\s|$)/,
    k = /^text\//i;
  ($.charset = x),
    ($.charsets = { lookup: x }),
    ($.contentType = S),
    ($.extension = I),
    ($.extensions = Object.create(null)),
    ($.lookup = F),
    ($.types = Object.create(null)),
    O($.extensions, $.types);
  function x(L) {
    if (!L || typeof L != "string") return !1;
    var U = v.exec(L),
      N = U && r[U[1].toLowerCase()];
    return N && N.charset ? N.charset : U && k.test(U[1]) ? "UTF-8" : !1;
  }
  function S(L) {
    if (!L || typeof L != "string") return !1;
    var U = L.indexOf("/") === -1 ? $.lookup(L) : L;
    if (!U) return !1;
    if (U.indexOf("charset") === -1) {
      var N = $.charset(U);
      N && (U += "; charset=" + N.toLowerCase());
    }
    return U;
  }
  function I(L) {
    if (!L || typeof L != "string") return !1;
    var U = v.exec(L),
      N = U && $.extensions[U[1].toLowerCase()];
    return !N || !N.length ? !1 : N[0];
  }
  function F(L) {
    if (!L || typeof L != "string") return !1;
    var U = p("x." + L)
      .toLowerCase()
      .substr(1);
    return (U && $.types[U]) || !1;
  }
  function O(L, U) {
    var N = ["nginx", "apache", void 0, "iana"];
    Object.keys(r).forEach(function (R) {
      var q = r[R],
        Q = q.extensions;
      if (!(!Q || !Q.length)) {
        L[R] = Q;
        for (var K = 0; K < Q.length; K++) {
          var V = Q[K];
          if (U[V]) {
            var H = N.indexOf(r[U[V]].source),
              G = N.indexOf(q.source);
            if (
              U[V] !== "application/octet-stream" &&
              (H > G || (H === G && U[V].substr(0, 12) === "application/"))
            )
              continue;
          }
          U[V] = R;
        }
      }
    });
  }
})(mimeTypes);
const icon$2 = "./assets/upload-62f3bdf6.svg",
  UploadFileButton_svelte_svelte_type_style_lang = "";
function create_fragment$3p($) {
  let r, p, v, k, x;
  return {
    c() {
      (r = element("input")),
        (p = space()),
        (v = element("button")),
        (v.textContent = "upload"),
        attr(r, "type", "file"),
        attr(r, "name", "file"),
        (r.multiple = !0),
        attr(r, "class", "svelte-nn3gqf"),
        attr(v, "class", "material-icons-round"),
        attr(v, "title", "Upload file");
    },
    m(S, I) {
      insert(S, r, I),
        $[2](r),
        insert(S, p, I),
        insert(S, v, I),
        k ||
          ((x = [listen(r, "change", $[1]), listen(v, "click", $[3])]),
          (k = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r),
        $[2](null),
        S && detach(p),
        S && detach(v),
        (k = !1),
        run_all(x);
    },
  };
}
function instance$37($, r, p) {
  let v;
  component_subscribe($, FileBrowserCurrentDir, (O) => p(4, (v = O)));
  let k;
  async function x() {
    const O = k.files;
    if (O.length > 80)
      return createOverlayableError(
        {
          title: "Too many files",
          message:
            "You are only allowed to upload 80 files at a time to prevent overloading.",
          buttons: [{ caption: "Understood", action() {} }],
          image: icon$2,
        },
        "FileManager"
      );
    showOverlay("uploadingFile", "FileManager");
    let L = 50;
    for (let U = 0; U < O.length; U++) (L += 25), O[U] && (await S(O[U]));
    setTimeout(() => {
      hideOverlay("uploadingFile", "FileManager"), fbClass.refresh();
    }, L + 500);
  }
  async function S(O) {
    const L = new Blob([new Uint8Array(await O.arrayBuffer())]),
      U = `${v}/${O.name}`.split("//").join("/"),
      N = {
        name: O.name,
        path: U,
        data: await O.arrayBuffer(),
        mime: "ArcOS Uploadable",
      };
    FileBrowserUploadFile.set(N),
      (await writeFile(U, L)) ||
        makeNotification({
          title: "File upload failed",
          message:
            "The server could not parse the file or it could not be written to the ArcFS",
          buttons: [],
          image: icon$2,
        });
  }
  function I(O) {
    binding_callbacks[O ? "unshift" : "push"](() => {
      (k = O), p(0, k);
    });
  }
  return [k, x, I, () => k.click()];
}
class UploadFileButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$37, create_fragment$3p, safe_not_equal, {});
  }
}
function create_fragment$3o($) {
  let r, p, v, k, x, S;
  return {
    c() {
      (r = element("div")),
        (p = element("button")),
        (p.textContent = "format_list_bulleted"),
        (v = space()),
        (k = element("button")),
        (k.textContent = "grid_view"),
        attr(p, "class", "material-icons-round"),
        attr(p, "title", "List view"),
        toggle_class(p, "selected", !$[0].tiled),
        attr(k, "class", "material-icons-round"),
        attr(k, "title", "Tile view"),
        toggle_class(k, "selected", $[0].tiled),
        attr(r, "class", "group");
    },
    m(I, F) {
      insert(I, r, F),
        append(r, p),
        append(r, v),
        append(r, k),
        x ||
          ((S = [listen(p, "click", $[1](!1)), listen(k, "click", $[1](!0))]),
          (x = !0));
    },
    p(I, [F]) {
      F & 1 && toggle_class(p, "selected", !I[0].tiled),
        F & 1 && toggle_class(k, "selected", I[0].tiled);
    },
    i: noop$1,
    o: noop$1,
    d(I) {
      I && detach(r), (x = !1), run_all(S);
    },
  };
}
function instance$36($, r, p) {
  let v;
  component_subscribe($, UserData, (I) => p(3, (v = I)));
  let { appdata: k } = r,
    { app: x } = r;
  function S(I) {
    return () => {
      p(0, (k.tiled = I), k),
        set_store_value(UserData, (v.appdata[x.id] = k), v);
    };
  }
  return (
    ($.$$set = (I) => {
      "appdata" in I && p(0, (k = I.appdata)), "app" in I && p(2, (x = I.app));
    }),
    [k, S, x]
  );
}
class Views extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$36, create_fragment$3o, safe_not_equal, {
        appdata: 0,
        app: 2,
      });
  }
}
function create_fragment$3n($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U,
    N,
    j,
    R,
    q,
    Q,
    K,
    V,
    H,
    G,
    Y,
    J,
    Z,
    X,
    ee,
    te,
    ie,
    ue,
    oe,
    se;
  (p = new ParentDir({})),
    (k = new PathCrumbs({})),
    (F = new CutButton({})),
    (L = new CopyButton({})),
    (N = new PasteButton({})),
    (Q = new DeleteButton({})),
    (V = new RenameButton({})),
    (Y = new NewFolderButton({})),
    (Z = new CreateButton$1({})),
    (ee = new UploadFileButton({}));
  function re(ne) {
    $[2](ne);
  }
  function le(ne) {
    $[3](ne);
  }
  let ae = {};
  return (
    $[0] !== void 0 && (ae.appdata = $[0]),
    $[1] !== void 0 && (ae.app = $[1]),
    (ie = new Views({ props: ae })),
    binding_callbacks.push(() => bind$1(ie, "appdata", re)),
    binding_callbacks.push(() => bind$1(ie, "app", le)),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          create_component(k.$$.fragment),
          (x = space()),
          (S = element("div")),
          (I = element("div")),
          create_component(F.$$.fragment),
          (O = space()),
          create_component(L.$$.fragment),
          (U = space()),
          create_component(N.$$.fragment),
          (j = space()),
          (R = element("div")),
          (q = space()),
          create_component(Q.$$.fragment),
          (K = space()),
          create_component(V.$$.fragment),
          (H = space()),
          (G = element("div")),
          create_component(Y.$$.fragment),
          (J = space()),
          create_component(Z.$$.fragment),
          (X = space()),
          create_component(ee.$$.fragment),
          (te = space()),
          create_component(ie.$$.fragment),
          attr(R, "class", "sep"),
          attr(I, "class", "group"),
          attr(G, "class", "group"),
          attr(S, "class", "right"),
          attr(r, "class", "topbar");
      },
      m(ne, ce) {
        insert(ne, r, ce),
          mount_component(p, r, null),
          append(r, v),
          mount_component(k, r, null),
          append(r, x),
          append(r, S),
          append(S, I),
          mount_component(F, I, null),
          append(I, O),
          mount_component(L, I, null),
          append(I, U),
          mount_component(N, I, null),
          append(I, j),
          append(I, R),
          append(I, q),
          mount_component(Q, I, null),
          append(I, K),
          mount_component(V, I, null),
          append(S, H),
          append(S, G),
          mount_component(Y, G, null),
          append(G, J),
          mount_component(Z, G, null),
          append(G, X),
          mount_component(ee, G, null),
          append(S, te),
          mount_component(ie, S, null),
          (se = !0);
      },
      p(ne, [ce]) {
        const de = {};
        !ue &&
          ce & 1 &&
          ((ue = !0),
          (de.appdata = ne[0]),
          add_flush_callback(() => (ue = !1))),
          !oe &&
            ce & 2 &&
            ((oe = !0), (de.app = ne[1]), add_flush_callback(() => (oe = !1))),
          ie.$set(de);
      },
      i(ne) {
        se ||
          (transition_in(p.$$.fragment, ne),
          transition_in(k.$$.fragment, ne),
          transition_in(F.$$.fragment, ne),
          transition_in(L.$$.fragment, ne),
          transition_in(N.$$.fragment, ne),
          transition_in(Q.$$.fragment, ne),
          transition_in(V.$$.fragment, ne),
          transition_in(Y.$$.fragment, ne),
          transition_in(Z.$$.fragment, ne),
          transition_in(ee.$$.fragment, ne),
          transition_in(ie.$$.fragment, ne),
          (se = !0));
      },
      o(ne) {
        transition_out(p.$$.fragment, ne),
          transition_out(k.$$.fragment, ne),
          transition_out(F.$$.fragment, ne),
          transition_out(L.$$.fragment, ne),
          transition_out(N.$$.fragment, ne),
          transition_out(Q.$$.fragment, ne),
          transition_out(V.$$.fragment, ne),
          transition_out(Y.$$.fragment, ne),
          transition_out(Z.$$.fragment, ne),
          transition_out(ee.$$.fragment, ne),
          transition_out(ie.$$.fragment, ne),
          (se = !1);
      },
      d(ne) {
        ne && detach(r),
          destroy_component(p),
          destroy_component(k),
          destroy_component(F),
          destroy_component(L),
          destroy_component(N),
          destroy_component(Q),
          destroy_component(V),
          destroy_component(Y),
          destroy_component(Z),
          destroy_component(ee),
          destroy_component(ie);
      },
    }
  );
}
function instance$35($, r, p) {
  let { appdata: v } = r,
    { app: k } = r;
  function x(I) {
    (v = I), p(0, v);
  }
  function S(I) {
    (k = I), p(1, k);
  }
  return (
    ($.$$set = (I) => {
      "appdata" in I && p(0, (v = I.appdata)), "app" in I && p(1, (k = I.app));
    }),
    [v, k, x, S]
  );
}
let TopBar$2 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$35, create_fragment$3n, safe_not_equal, {
        appdata: 0,
        app: 1,
      });
  }
};
function create_else_block$q($) {
  let r, p;
  return (
    (r = new ListView({ props: { files: $[2], dirs: $[3] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 4 && (x.files = v[2]), k & 8 && (x.dirs = v[3]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$1j($) {
  let r, p;
  return (
    (r = new TileView({ props: { files: $[2], dirs: $[3] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 4 && (x.files = v[2]), k & 8 && (x.dirs = v[3]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$3m($) {
  let r, p, v, k, x, S, I, F, O;
  function L(q) {
    $[5](q);
  }
  let U = { app: $[1] };
  $[0] !== void 0 && (U.appdata = $[0]),
    (r = new TopBar$2({ props: U })),
    binding_callbacks.push(() => bind$1(r, "appdata", L)),
    (k = new SideBar$3({}));
  const N = [create_if_block$1j, create_else_block$q],
    j = [];
  function R(q, Q) {
    return q[4] ? 0 : 1;
  }
  return (
    (I = R($)),
    (F = j[I] = N[I]($)),
    {
      c() {
        create_component(r.$$.fragment),
          (v = space()),
          create_component(k.$$.fragment),
          (x = space()),
          (S = element("div")),
          F.c(),
          attr(S, "class", "content");
      },
      m(q, Q) {
        mount_component(r, q, Q),
          insert(q, v, Q),
          mount_component(k, q, Q),
          insert(q, x, Q),
          insert(q, S, Q),
          j[I].m(S, null),
          (O = !0);
      },
      p(q, [Q]) {
        const K = {};
        Q & 2 && (K.app = q[1]),
          !p &&
            Q & 1 &&
            ((p = !0), (K.appdata = q[0]), add_flush_callback(() => (p = !1))),
          r.$set(K);
        let V = I;
        (I = R(q)),
          I === V
            ? j[I].p(q, Q)
            : (group_outros(),
              transition_out(j[V], 1, 1, () => {
                j[V] = null;
              }),
              check_outros(),
              (F = j[I]),
              F ? F.p(q, Q) : ((F = j[I] = N[I](q)), F.c()),
              transition_in(F, 1),
              F.m(S, null));
      },
      i(q) {
        O ||
          (transition_in(r.$$.fragment, q),
          transition_in(k.$$.fragment, q),
          transition_in(F),
          (O = !0));
      },
      o(q) {
        transition_out(r.$$.fragment, q),
          transition_out(k.$$.fragment, q),
          transition_out(F),
          (O = !1);
      },
      d(q) {
        destroy_component(r, q),
          q && detach(v),
          destroy_component(k, q),
          q && detach(x),
          q && detach(S),
          j[I].d();
      },
    }
  );
}
function instance$34($, r, p) {
  let v;
  component_subscribe($, FileBrowserDirContents, (L) => p(6, (v = L)));
  let k = [],
    x = [],
    S = !1,
    { app: I } = r,
    { appdata: F } = r;
  UserData.subscribe(() => {
    p(4, (S = F.tiled));
  }),
    onMount(async () => {
      await fbClass.refresh();
      const L = v || defaultDirectory;
      p(2, (k = L.files)), p(3, (x = L.directories));
    }),
    FileBrowserDirContents.subscribe((L) => {
      p(3, (x = L.directories)), p(2, (k = L.files));
    });
  function O(L) {
    (F = L), p(0, F);
  }
  return (
    ($.$$set = (L) => {
      "app" in L && p(1, (I = L.app)), "appdata" in L && p(0, (F = L.appdata));
    }),
    [F, I, k, x, S, O]
  );
}
class FileBrowser extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$34, create_fragment$3m, safe_not_equal, {
        app: 1,
        appdata: 0,
      });
  }
}
const SEP_ITEM = { sep: !0 },
  validCallerTags = [
    "button",
    "div",
    "span",
    "p",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "img",
  ];
function composePosition($, r, p) {
  const v = document.querySelectorAll("div.app > div.desktop")[0];
  if (!v) return;
  const k = v.offsetWidth,
    x = v.offsetHeight;
  let S = $.clientX,
    I = $.clientY;
  return (
    S + r > k && (S = k - r),
    I + p > x && (I = x - p),
    S < 0 && (S = 0),
    I < 0 && (I = 0),
    [S, I]
  );
}
function getCallerScope($) {
  const r = $.composedPath();
  for (let p = 0; p < r.length; p++) {
    const v = r[p].tagName;
    if (!v) continue;
    const k = r[p].dataset.caller;
    if (validCallerTags.includes(v.toLowerCase()) && k) return r[p];
  }
  return null;
}
function getContextEntry($, r) {
  const p = getWindow($);
  if (!p || !p.contextMenu) return !1;
  const v = Object.entries(p.contextMenu);
  for (let k = 0; k < v.length; k++) if (r.includes(v[k][0])) return v[k][1];
  return !1;
}
const FileManagerContextMenu = {
    "listitem-dir": [
      {
        icon: "launch",
        caption: "Open",
        action: ($, r) => {
          const p = r.path;
          p && fbClass.goToDirectory(p);
        },
      },
      {
        icon: "drive_file_rename_outline",
        caption: "Rename",
        action: ($, r) => {
          FileBrowserSelectedFilename.set(r.name),
            showOverlay("renameItem", "FileManager");
        },
      },
      {
        icon: "content_copy",
        caption: "Copy",
        action: ($, r) => {
          FileBrowserSelectedFilename.set(r.name),
            FileBrowserCopyingFilename.set({
              name: r.name,
              scopedPath: `${r.path}`,
            });
        },
      },
      {
        icon: "content_cut",
        caption: "Cut",
        action: ($, r) => {
          FileBrowserSelectedFilename.set(r.name),
            FileBrowserCuttingFilename.set({
              name: r.name,
              scopedPath: `${r.path}`,
            });
        },
      },
    ],
    "listitem-file": [
      {
        caption: "Delete",
        action: ($, r) => {
          createOverlayableError(
            {
              title: "Delete item?",
              message: `Are you sure you want to permanently delete ${r.name}?`,
              buttons: [
                {
                  caption: "Delete",
                  action: async () => {
                    fbClass.deleteItem(r.name, r.path);
                  },
                },
                { caption: "Cancel", action() {} },
              ],
              image: clear$1,
            },
            "FileManager"
          );
        },
      },
    ],
  },
  mutator = "";
function create_fragment$3l($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K, V;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (S = element("div")),
        (I = element("p")),
        (I.textContent = "Enter a name for the new file:"),
        (F = space()),
        (O = element("input")),
        (L = space()),
        (U = element("div")),
        (N = element("div")),
        (j = element("button")),
        (R = text("Create")),
        (q = space()),
        (Q = element("button")),
        (Q.textContent = "Cancel"),
        src_url_equal(v.src, (k = $[1] || fileIcon)) || attr(v, "src", k),
        attr(v, "alt", ""),
        attr(p, "class", "image"),
        attr(O, "type", "text"),
        (j.disabled = $[2]),
        attr(N, "class", "inner"),
        attr(U, "class", "actions"),
        attr(r, "class", "fb-overlay-mutator-wrapper");
    },
    m(H, G) {
      insert(H, r, G),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, S),
        append(S, I),
        append(S, F),
        append(S, O),
        set_input_value(O, $[0]),
        append(S, L),
        append(S, U),
        append(U, N),
        append(N, j),
        append(j, R),
        append(N, q),
        append(N, Q),
        K ||
          ((V = [
            listen(O, "input", $[6]),
            listen(O, "input", $[3]),
            listen(j, "click", $[4]),
            listen(Q, "click", $[5]),
          ]),
          (K = !0));
    },
    p(H, [G]) {
      G & 2 &&
        !src_url_equal(v.src, (k = H[1] || fileIcon)) &&
        attr(v, "src", k),
        G & 1 && O.value !== H[0] && set_input_value(O, H[0]),
        G & 4 && (j.disabled = H[2]);
    },
    i: noop$1,
    o: noop$1,
    d(H) {
      H && detach(r), (K = !1), run_all(V);
    },
  };
}
function instance$33($, r, p) {
  let v, k;
  component_subscribe($, FileBrowserCurrentDir, (N) => p(7, (v = N))),
    component_subscribe($, FileBrowserDirContents, (N) => p(8, (k = N)));
  let x = "",
    S = "",
    I = !1;
  function F() {
    const N = k.directories,
      j = k.files;
    for (let R = 0; R < N.length; R++)
      if (N[R].name == x) return p(2, (I = !0));
    for (let R = 0; R < j.length; R++)
      if (j[R].filename == x) return p(2, (I = !0));
    p(2, (I = !1)), p(1, (S = getMimeIcon(x) || fileIcon));
  }
  async function O() {
    await writeFile(`${v}/${x}`, new Blob([])),
      FileBrowserSelectedFilename.set(x),
      L(),
      fbClass.refresh();
  }
  function L() {
    hideOverlay("createFile", "FileManager"), p(0, (x = ""));
  }
  function U() {
    (x = this.value), p(0, x);
  }
  return [x, S, I, F, O, L, U];
}
class CreateFile extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$33, create_fragment$3l, safe_not_equal, {});
  }
}
function create_fragment$3k($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K, V;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (S = element("div")),
        (I = element("p")),
        (I.textContent = "Enter a name for the new folder:"),
        (F = space()),
        (O = element("input")),
        (L = space()),
        (U = element("div")),
        (N = element("div")),
        (j = element("button")),
        (R = text("Create")),
        (q = space()),
        (Q = element("button")),
        (Q.textContent = "Cancel"),
        src_url_equal(v.src, (k = folder)) || attr(v, "src", k),
        attr(v, "alt", ""),
        attr(p, "class", "image"),
        attr(O, "type", "text"),
        (j.disabled = $[1]),
        attr(N, "class", "inner"),
        attr(U, "class", "actions"),
        attr(r, "class", "fb-overlay-mutator-wrapper");
    },
    m(H, G) {
      insert(H, r, G),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, S),
        append(S, I),
        append(S, F),
        append(S, O),
        set_input_value(O, $[0]),
        append(S, L),
        append(S, U),
        append(U, N),
        append(N, j),
        append(j, R),
        append(N, q),
        append(N, Q),
        K ||
          ((V = [
            listen(O, "input", $[5]),
            listen(O, "input", $[2]),
            listen(j, "click", $[3]),
            listen(Q, "click", $[4]),
          ]),
          (K = !0));
    },
    p(H, [G]) {
      G & 1 && O.value !== H[0] && set_input_value(O, H[0]),
        G & 2 && (j.disabled = H[1]);
    },
    i: noop$1,
    o: noop$1,
    d(H) {
      H && detach(r), (K = !1), run_all(V);
    },
  };
}
function instance$32($, r, p) {
  let v, k;
  component_subscribe($, FileBrowserCurrentDir, (U) => p(6, (v = U))),
    component_subscribe($, FileBrowserDirContents, (U) => p(7, (k = U)));
  let x = "",
    S = !1;
  function I() {
    const U = k.directories,
      N = k.files;
    for (let j = 0; j < U.length; j++)
      if (U[j].name == x) return p(1, (S = !0));
    for (let j = 0; j < N.length; j++)
      if (N[j].filename == x) return p(1, (S = !0));
    p(1, (S = !1));
  }
  async function F() {
    await createDirectory(`${v}/${x}`),
      FileBrowserSelectedFilename.set(x),
      O(),
      fbClass.refresh();
  }
  function O() {
    hideOverlay("createFolder", "FileManager"), p(0, (x = ""));
  }
  function L() {
    (x = this.value), p(0, x);
  }
  return [x, S, I, F, O, L];
}
class CreateFolder extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$32, create_fragment$3k, safe_not_equal, {});
  }
}
const deletingfile = "";
function create_fragment$3j($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j;
  return (
    (N = new Spinner({ props: { height: 30 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          (v = element("img")),
          (x = space()),
          (S = element("div")),
          (I = text("Deleting ")),
          (F = text($[0])),
          (O = text("...")),
          (L = space()),
          (U = element("div")),
          create_component(N.$$.fragment),
          src_url_equal(v.src, (k = clear$1)) || attr(v, "src", k),
          attr(v, "alt", ""),
          attr(p, "class", "icon"),
          attr(S, "class", "caption"),
          attr(U, "class", "spin"),
          attr(r, "class", "deletingfile-wrapper");
      },
      m(R, q) {
        insert(R, r, q),
          append(r, p),
          append(p, v),
          append(r, x),
          append(r, S),
          append(S, I),
          append(S, F),
          append(S, O),
          append(r, L),
          append(r, U),
          mount_component(N, U, null),
          (j = !0);
      },
      p(R, [q]) {
        (!j || q & 1) && set_data(F, R[0]);
      },
      i(R) {
        j || (transition_in(N.$$.fragment, R), (j = !0));
      },
      o(R) {
        transition_out(N.$$.fragment, R), (j = !1);
      },
      d(R) {
        R && detach(r), destroy_component(N);
      },
    }
  );
}
function instance$31($, r, p) {
  let v;
  return (
    component_subscribe($, FileBrowserDeletingFilename, (k) => p(0, (v = k))),
    [v]
  );
}
class DeletingItem extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$31, create_fragment$3j, safe_not_equal, {});
  }
}
const openingfile = "",
  icon$1 = "./assets/memory-802c404d.svg";
function create_if_block$1i($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F = $[0].filename + "",
    O,
    L,
    U,
    N,
    j,
    R,
    q,
    Q,
    K,
    V,
    H,
    G = $[0].filename + "",
    Y,
    J,
    Z,
    X,
    ee,
    te,
    ie = $[0].scopedPath + "",
    ue,
    oe,
    se,
    re,
    le,
    ae,
    ne = $[0].mime + "",
    ce,
    de,
    fe,
    pe,
    _e,
    ge,
    Ae = formatBytes($[0].size) + "",
    $e,
    ke;
  return (
    (j = new Spinner({ props: { height: 30 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          (v = element("img")),
          (x = space()),
          (S = element("div")),
          (I = text("Downloading ")),
          (O = text(F)),
          (L = text(" to RAM...")),
          (U = space()),
          (N = element("div")),
          create_component(j.$$.fragment),
          (R = space()),
          (q = element("table")),
          (Q = element("tr")),
          (K = element("td")),
          (K.textContent = "Name"),
          (V = space()),
          (H = element("td")),
          (Y = text(G)),
          (J = space()),
          (Z = element("tr")),
          (X = element("td")),
          (X.textContent = "Path"),
          (ee = space()),
          (te = element("td")),
          (ue = text(ie)),
          (oe = space()),
          (se = element("tr")),
          (re = element("td")),
          (re.textContent = "Mimetype"),
          (le = space()),
          (ae = element("td")),
          (ce = text(ne)),
          (de = space()),
          (fe = element("tr")),
          (pe = element("td")),
          (pe.textContent = "Size"),
          (_e = space()),
          (ge = element("td")),
          ($e = text(Ae)),
          src_url_equal(v.src, (k = icon$1)) || attr(v, "src", k),
          attr(v, "alt", ""),
          attr(p, "class", "icon"),
          attr(S, "class", "caption"),
          attr(N, "class", "spin"),
          attr(r, "class", "openingfile-wrapper"),
          attr(K, "class", "key"),
          attr(X, "class", "key"),
          attr(re, "class", "key"),
          attr(pe, "class", "key"),
          attr(q, "class", "openfile-details");
      },
      m(ve, be) {
        insert(ve, r, be),
          append(r, p),
          append(p, v),
          append(r, x),
          append(r, S),
          append(S, I),
          append(S, O),
          append(S, L),
          append(r, U),
          append(r, N),
          mount_component(j, N, null),
          insert(ve, R, be),
          insert(ve, q, be),
          append(q, Q),
          append(Q, K),
          append(Q, V),
          append(Q, H),
          append(H, Y),
          append(q, J),
          append(q, Z),
          append(Z, X),
          append(Z, ee),
          append(Z, te),
          append(te, ue),
          append(q, oe),
          append(q, se),
          append(se, re),
          append(se, le),
          append(se, ae),
          append(ae, ce),
          append(q, de),
          append(q, fe),
          append(fe, pe),
          append(fe, _e),
          append(fe, ge),
          append(ge, $e),
          (ke = !0);
      },
      p(ve, be) {
        (!ke || be & 1) && F !== (F = ve[0].filename + "") && set_data(O, F),
          (!ke || be & 1) && G !== (G = ve[0].filename + "") && set_data(Y, G),
          (!ke || be & 1) &&
            ie !== (ie = ve[0].scopedPath + "") &&
            set_data(ue, ie),
          (!ke || be & 1) && ne !== (ne = ve[0].mime + "") && set_data(ce, ne),
          (!ke || be & 1) &&
            Ae !== (Ae = formatBytes(ve[0].size) + "") &&
            set_data($e, Ae);
      },
      i(ve) {
        ke || (transition_in(j.$$.fragment, ve), (ke = !0));
      },
      o(ve) {
        transition_out(j.$$.fragment, ve), (ke = !1);
      },
      d(ve) {
        ve && detach(r), destroy_component(j), ve && detach(R), ve && detach(q);
      },
    }
  );
}
function create_fragment$3i($) {
  let r,
    p,
    v,
    k,
    x,
    S = $[0] && create_if_block$1i($);
  return {
    c() {
      S && S.c(),
        (r = space()),
        (p = element("button")),
        (p.textContent = "Cancel"),
        attr(p, "class", "cancel");
    },
    m(I, F) {
      S && S.m(I, F),
        insert(I, r, F),
        insert(I, p, F),
        (v = !0),
        k || ((x = listen(p, "click", $[1])), (k = !0));
    },
    p(I, [F]) {
      I[0]
        ? S
          ? (S.p(I, F), F & 1 && transition_in(S, 1))
          : ((S = create_if_block$1i(I)),
            S.c(),
            transition_in(S, 1),
            S.m(r.parentNode, r))
        : S &&
          (group_outros(),
          transition_out(S, 1, 1, () => {
            S = null;
          }),
          check_outros());
    },
    i(I) {
      v || (transition_in(S), (v = !0));
    },
    o(I) {
      transition_out(S), (v = !1);
    },
    d(I) {
      S && S.d(I), I && detach(r), I && detach(p), (k = !1), x();
    },
  };
}
function instance$30($, r, p) {
  let v;
  component_subscribe($, FileBrowserOpeningFile, (x) => p(0, (v = x)));
  function k() {
    abortFileReader.set(!0), hideOverlay("openingFile", "FileManager");
  }
  return [v, k];
}
class OpeningFile extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$30, create_fragment$3i, safe_not_equal, {});
  }
}
function create_fragment$3h($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K, V, H, G, Y, J;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (S = element("div")),
        (I = element("p")),
        (F = text("Enter a new name for ")),
        (O = text($[4])),
        (L = text(":")),
        (U = space()),
        (N = element("input")),
        (j = space()),
        (R = element("div")),
        (q = element("div")),
        (Q = element("button")),
        (K = text("Rename")),
        (H = space()),
        (G = element("button")),
        (G.textContent = "Cancel"),
        src_url_equal(v.src, (k = $[2] ? folder : $[1])) || attr(v, "src", k),
        attr(v, "alt", ""),
        attr(p, "class", "image"),
        attr(N, "type", "text"),
        attr(N, "placeholder", $[4]),
        (Q.disabled = V = $[3] || !$[0]),
        attr(q, "class", "inner"),
        attr(R, "class", "actions"),
        attr(r, "class", "fb-overlay-mutator-wrapper");
    },
    m(Z, X) {
      insert(Z, r, X),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, S),
        append(S, I),
        append(I, F),
        append(I, O),
        append(I, L),
        append(S, U),
        append(S, N),
        set_input_value(N, $[0]),
        append(S, j),
        append(S, R),
        append(R, q),
        append(q, Q),
        append(Q, K),
        append(q, H),
        append(q, G),
        Y ||
          ((J = [
            listen(N, "input", $[8]),
            listen(N, "input", $[5]),
            listen(Q, "click", $[6]),
            listen(G, "click", $[7]),
          ]),
          (Y = !0));
    },
    p(Z, [X]) {
      X & 6 &&
        !src_url_equal(v.src, (k = Z[2] ? folder : Z[1])) &&
        attr(v, "src", k),
        X & 16 && set_data(O, Z[4]),
        X & 16 && attr(N, "placeholder", Z[4]),
        X & 1 && N.value !== Z[0] && set_input_value(N, Z[0]),
        X & 9 && V !== (V = Z[3] || !Z[0]) && (Q.disabled = V);
    },
    i: noop$1,
    o: noop$1,
    d(Z) {
      Z && detach(r), (Y = !1), run_all(J);
    },
  };
}
function instance$2$($, r, p) {
  let v, k, x;
  component_subscribe($, FileBrowserCurrentDir, (q) => p(9, (v = q))),
    component_subscribe($, FileBrowserSelectedFilename, (q) => p(4, (k = q))),
    component_subscribe($, FileBrowserDirContents, (q) => p(10, (x = q)));
  let S = "",
    I = "",
    F = !1,
    O = !1;
  function L() {
    const q = x.directories,
      Q = x.files;
    p(2, (F = U()));
    for (let K = 0; K < q.length; K++) q[K].name == v && p(2, (F = !0));
    for (let K = 0; K < Q.length; K++)
      if (Q[K].filename == S) return p(3, (O = !0));
    p(3, (O = !1));
  }
  FileBrowserSelectedFilename.subscribe((q) => {
    q && (p(2, (F = U())), p(1, (I = getMimeIcon(q))));
  });
  function U() {
    const q = x.directories;
    for (let Q = 0; Q < q.length; Q++) if (q[Q].name == k) return !0;
    return !1;
  }
  async function N() {
    await renameItem(`${v}/${k}`, `${v}/${S}`),
      FileBrowserSelectedFilename.set(S),
      j(),
      p(0, (S = "")),
      fbClass.refresh();
  }
  function j() {
    hideOverlay("renameItem", "FileManager");
  }
  function R() {
    (S = this.value), p(0, S);
  }
  return [S, I, F, O, k, L, N, j, R];
}
class RenameItem extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2$, create_fragment$3h, safe_not_equal, {});
  }
}
const uploadingfile = "";
function create_if_block$1h($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F = $[0].name + "",
    O,
    L,
    U,
    N,
    j,
    R,
    q,
    Q,
    K = $[1].toFixed(0) + "",
    V,
    H,
    G,
    Y,
    J,
    Z,
    X,
    ee,
    te = $[0].path + "",
    ie,
    ue,
    oe,
    se,
    re,
    le,
    ae = $[0].mime + "",
    ne,
    ce,
    de,
    fe,
    pe,
    _e;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (S = element("div")),
        (I = text("Uploading ")),
        (O = text(F)),
        (L = text("...")),
        (U = space()),
        (N = element("div")),
        (j = element("div")),
        (R = element("div")),
        (q = space()),
        (Q = element("div")),
        (V = text(K)),
        (H = text("%")),
        (G = space()),
        (Y = element("table")),
        (J = element("tr")),
        (Z = element("td")),
        (Z.textContent = "Path"),
        (X = space()),
        (ee = element("td")),
        (ie = text(te)),
        (ue = space()),
        (oe = element("tr")),
        (se = element("td")),
        (se.textContent = "Type"),
        (re = space()),
        (le = element("td")),
        (ne = text(ae)),
        (ce = space()),
        (de = element("tr")),
        (fe = element("td")),
        (fe.textContent = "Target"),
        (pe = space()),
        (_e = element("td")),
        (_e.textContent = `${localStorage.getItem("arcos-server")}`),
        src_url_equal(v.src, (k = icon$2)) || attr(v, "src", k),
        attr(v, "alt", ""),
        attr(p, "class", "icon"),
        attr(S, "class", "caption"),
        attr(r, "class", "uploadingfile-wrapper"),
        attr(R, "class", "inner"),
        set_style(R, "width", Math.floor($[1]) + "%"),
        attr(j, "class", "progress"),
        attr(Q, "class", "percentage"),
        attr(N, "class", "progress-wrapper"),
        attr(Z, "class", "key"),
        attr(se, "class", "key"),
        attr(fe, "class", "key"),
        attr(Y, "class", "openfile-details");
    },
    m(ge, Ae) {
      insert(ge, r, Ae),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, S),
        append(S, I),
        append(S, O),
        append(S, L),
        insert(ge, U, Ae),
        insert(ge, N, Ae),
        append(N, j),
        append(j, R),
        append(N, q),
        append(N, Q),
        append(Q, V),
        append(Q, H),
        insert(ge, G, Ae),
        insert(ge, Y, Ae),
        append(Y, J),
        append(J, Z),
        append(J, X),
        append(J, ee),
        append(ee, ie),
        append(Y, ue),
        append(Y, oe),
        append(oe, se),
        append(oe, re),
        append(oe, le),
        append(le, ne),
        append(Y, ce),
        append(Y, de),
        append(de, fe),
        append(de, pe),
        append(de, _e);
    },
    p(ge, Ae) {
      Ae & 1 && F !== (F = ge[0].name + "") && set_data(O, F),
        Ae & 2 && set_style(R, "width", Math.floor(ge[1]) + "%"),
        Ae & 2 && K !== (K = ge[1].toFixed(0) + "") && set_data(V, K),
        Ae & 1 && te !== (te = ge[0].path + "") && set_data(ie, te),
        Ae & 1 && ae !== (ae = ge[0].mime + "") && set_data(ne, ae);
    },
    d(ge) {
      ge && detach(r),
        ge && detach(U),
        ge && detach(N),
        ge && detach(G),
        ge && detach(Y);
    },
  };
}
function create_fragment$3g($) {
  let r,
    p = $[0] && create_if_block$1h($);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, k) {
      p && p.m(v, k), insert(v, r, k);
    },
    p(v, [k]) {
      v[0]
        ? p
          ? p.p(v, k)
          : ((p = create_if_block$1h(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$2_($, r, p) {
  let v, k;
  return (
    component_subscribe($, FileBrowserUploadFile, (x) => p(0, (v = x))),
    component_subscribe($, FileBrowserUploadProgress, (x) => p(1, (k = x))),
    [v, k]
  );
}
class UploadingFile extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2_, create_fragment$3g, safe_not_equal, {});
  }
}
const fbOverlays = {
    openingFile: {
      info: { name: "Opening File", version: "1.0.0", author: "ArcOS Team" },
      content: OpeningFile,
      size: { w: 430, h: 165 },
      show: !1,
    },
    deletingItem: {
      info: { name: "Deleting Item", version: "1.0.0", author: "ArcOS Team" },
      content: DeletingItem,
      size: { w: 430, h: 75 },
      show: !1,
    },
    createFolder: {
      info: { name: "Create Folder", version: "1.0.0", author: "ArcOS Team" },
      content: CreateFolder,
      size: { w: 350, h: 115 },
      show: !1,
    },
    createFile: {
      info: { name: "Create File", version: "1.0.0", author: "ArcOS Team" },
      content: CreateFile,
      size: { w: 350, h: 115 },
      show: !1,
    },
    uploadingFile: {
      info: { name: "Uploading File", version: "1.0.0", author: "ArcOS Team" },
      content: UploadingFile,
      size: { w: 430, h: 175 },
      show: !1,
    },
    renameItem: {
      info: { name: "Rename Item", version: "1.0.0", author: "ArcOS Team" },
      content: RenameItem,
      size: { w: 350, h: 115 },
      show: !1,
    },
  },
  FileBrowserApp = {
    info: {
      name: "File Manager",
      description: "Browse your files",
      builtin: !0,
      version: "2.5.1",
      author: "ArcOS Team",
      icon: fileManager,
    },
    size: { w: 700, h: 450 },
    pos: { x: 30, y: 40 },
    minSize: { w: 700, h: 450 },
    maxSize: { w: 1e3, h: 600 },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: FileBrowser,
    glass: !0,
    overlays: fbOverlays,
    contextMenu: FileManagerContextMenu,
  },
  logo$6 = "./assets/imageviewer-5b7c750b.svg",
  imageviewer = "";
function create_if_block$1g($) {
  let r, p, v, k;
  return {
    c() {
      (r = element("img")),
        src_url_equal(r.src, (p = $[1])) || attr(r, "src", p),
        attr(r, "alt", (v = $[0].openedFile.name)),
        attr(r, "data-caller", "output"),
        attr(r, "data-path", (k = $[0].openedFile.path));
    },
    m(x, S) {
      insert(x, r, S);
    },
    p(x, S) {
      S & 2 && !src_url_equal(r.src, (p = x[1])) && attr(r, "src", p),
        S & 1 && v !== (v = x[0].openedFile.name) && attr(r, "alt", v),
        S & 1 && k !== (k = x[0].openedFile.path) && attr(r, "data-path", k);
    },
    d(x) {
      x && detach(r);
    },
  };
}
function create_fragment$3f($) {
  let r,
    p = $[0].openedFile && $[1] && create_if_block$1g($);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, k) {
      p && p.m(v, k), insert(v, r, k);
    },
    p(v, [k]) {
      v[0].openedFile && v[1]
        ? p
          ? p.p(v, k)
          : ((p = create_if_block$1g(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$2Z($, r, p) {
  let { app: v } = r,
    k = "";
  return (
    WindowStore.subscribe(() => {
      if (!v.openedFile) return p(1, (k = ""));
      const x = new Blob([new Uint8Array(v.openedFile.data)], {
        type: v.openedFile.mime,
      });
      p(1, (k = URL.createObjectURL(x)));
    }),
    ($.$$set = (x) => {
      "app" in x && p(0, (v = x.app));
    }),
    [v, k]
  );
}
class ImageView extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2Z, create_fragment$3f, safe_not_equal, {
        app: 0,
      });
  }
}
const textview = "",
  chooseTargets = writable({});
function setTargetFile($, r) {
  const p = get_store_value(chooseTargets),
    v = p[$],
    k = get_store_value(WindowStore);
  let x = null;
  for (let S = 0; S < k.length; S++) k[S].id == v && (x = S);
  return x == null
    ? !1
    : ((k[x].openedFile = r),
      k[x].events && k[x].events.openFile && k[x].events.openFile(k[x]),
      delete k[x].overlays[$],
      WindowStore.set(k),
      delete p[$],
      chooseTargets.set(p),
      !0);
}
function getChooserTarget($) {
  return get_store_value(chooseTargets)[$] || !1;
}
function assignTarget($, r) {
  const p = get_store_value(chooseTargets);
  return p[$] ? !1 : ((p[$] = r), chooseTargets.set(p), !0);
}
function create_fragment$3e($) {
  let r, p, v, k, x, S, I, F, O;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("button")),
        (v.textContent = "Cancel"),
        (k = space()),
        (x = element("button")),
        (S = text("Open")),
        attr(v, "class", "cancel"),
        attr(x, "class", "confirm"),
        (x.disabled = I = !$[5] || !$[4]),
        attr(p, "class", "buttons"),
        attr(r, "class", "bottompane");
    },
    m(L, U) {
      insert(L, r, U),
        append(r, p),
        append(p, v),
        append(p, k),
        append(p, x),
        append(x, S),
        F ||
          ((O = [listen(v, "click", $[7]), listen(x, "click", $[6])]),
          (F = !0));
    },
    p(L, [U]) {
      U & 48 && I !== (I = !L[5] || !L[4]) && (x.disabled = I);
    },
    i: noop$1,
    o: noop$1,
    d(L) {
      L && detach(r), (F = !1), run_all(O);
    },
  };
}
function instance$2Y($, r, p) {
  let v,
    k = noop$1,
    x = () => (k(), (k = subscribe(V, (J) => p(9, (v = J)))), V),
    S,
    I = noop$1,
    F = () => (I(), (I = subscribe(q, (J) => p(10, (S = J)))), q),
    O,
    L = noop$1,
    U = () => (L(), (L = subscribe(K, (J) => p(4, (O = J)))), K),
    N,
    j = noop$1,
    R = () => (j(), (j = subscribe(Q, (J) => p(5, (N = J)))), Q);
  $.$$.on_destroy.push(() => k()),
    $.$$.on_destroy.push(() => I()),
    $.$$.on_destroy.push(() => L()),
    $.$$.on_destroy.push(() => j());
  let { currentDir: q } = r;
  F();
  let { currentPath: Q } = r;
  R();
  let { selected: K } = r;
  U();
  let { processing: V } = r;
  x();
  let { overlay: H } = r;
  async function G() {
    set_store_value(V, (v = !0), v);
    let J;
    for (let X = 0; X < S.files.length; X++)
      S.files[X].filename == O && (J = S.files[X]);
    const Z = {
      name: J.filename,
      path: J.scopedPath,
      data: await readFile(J.scopedPath),
      mime: J.mime,
    };
    hideOverlay(H.id, getChooserTarget(H.id)),
      setTargetFile(H.id, Z),
      set_store_value(V, (v = !1), v);
  }
  function Y() {
    const J = getChooserTarget(H.id),
      Z = getWindow(J);
    hideOverlay(H.id, J), setTargetFile(H.id, Z.openedFile);
  }
  return (
    ($.$$set = (J) => {
      "currentDir" in J && F(p(0, (q = J.currentDir))),
        "currentPath" in J && R(p(1, (Q = J.currentPath))),
        "selected" in J && U(p(2, (K = J.selected))),
        "processing" in J && x(p(3, (V = J.processing))),
        "overlay" in J && p(8, (H = J.overlay));
    }),
    [q, Q, K, V, O, N, G, Y, H]
  );
}
let BottomPane$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2Y, create_fragment$3e, safe_not_equal, {
        currentDir: 0,
        currentPath: 1,
        selected: 2,
        processing: 3,
        overlay: 8,
      });
  }
};
function create_fragment$3d($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F = $[0].name + "",
    O,
    L,
    U,
    N,
    j,
    R,
    q;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (I = element("div")),
        (O = text(F)),
        (L = space()),
        (U = element("div")),
        (U.textContent = "Folder"),
        (N = space()),
        (j = element("div")),
        (j.textContent = "-"),
        src_url_equal(v.src, (k = folder)) || attr(v, "src", k),
        attr(v, "alt", (x = $[0].name)),
        attr(p, "class", "image"),
        attr(I, "class", "name"),
        attr(U, "class", "mime"),
        attr(j, "class", "size"),
        attr(r, "class", "item dir");
    },
    m(Q, K) {
      insert(Q, r, K),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, I),
        append(I, O),
        append(r, L),
        append(r, U),
        append(r, N),
        append(r, j),
        R || ((q = listen(r, "dblclick", $[2])), (R = !0));
    },
    p(Q, [K]) {
      K & 1 && x !== (x = Q[0].name) && attr(v, "alt", x),
        K & 1 && F !== (F = Q[0].name + "") && set_data(O, F);
    },
    i: noop$1,
    o: noop$1,
    d(Q) {
      Q && detach(r), (R = !1), q();
    },
  };
}
function instance$2X($, r, p) {
  let { dir: v } = r,
    { setDir: k } = r;
  const x = () => k(v.scopedPath);
  return (
    ($.$$set = (S) => {
      "dir" in S && p(0, (v = S.dir)), "setDir" in S && p(1, (k = S.setDir));
    }),
    [v, k, x]
  );
}
let Dir$2 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2X, create_fragment$3d, safe_not_equal, {
        dir: 0,
        setDir: 1,
      });
  }
};
function create_fragment$3c($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F = $[2].filename + "",
    O,
    L,
    U,
    N = $[2].mime.split("; ")[0].split("/").join(" - ") + "",
    j,
    R,
    q,
    Q = formatBytes($[2].size) + "",
    K,
    V,
    H;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (I = element("div")),
        (O = text(F)),
        (L = space()),
        (U = element("div")),
        (j = text(N)),
        (R = space()),
        (q = element("div")),
        (K = text(Q)),
        src_url_equal(v.src, (k = $[3])) || attr(v, "src", k),
        attr(v, "alt", (x = $[2].filename)),
        attr(p, "class", "image"),
        attr(I, "class", "name"),
        attr(U, "class", "mime"),
        attr(q, "class", "size"),
        attr(r, "class", "item file"),
        toggle_class(r, "selected", $[4] == $[2].filename);
    },
    m(G, Y) {
      insert(G, r, Y),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, I),
        append(I, O),
        append(r, L),
        append(r, U),
        append(U, j),
        append(r, R),
        append(r, q),
        append(q, K),
        V ||
          ((H = [listen(r, "dblclick", $[5]), listen(r, "click", $[7])]),
          (V = !0));
    },
    p(G, [Y]) {
      Y & 8 && !src_url_equal(v.src, (k = G[3])) && attr(v, "src", k),
        Y & 4 && x !== (x = G[2].filename) && attr(v, "alt", x),
        Y & 4 && F !== (F = G[2].filename + "") && set_data(O, F),
        Y & 4 &&
          N !== (N = G[2].mime.split("; ")[0].split("/").join(" - ") + "") &&
          set_data(j, N),
        Y & 4 && Q !== (Q = formatBytes(G[2].size) + "") && set_data(K, Q),
        Y & 20 && toggle_class(r, "selected", G[4] == G[2].filename);
    },
    i: noop$1,
    o: noop$1,
    d(G) {
      G && detach(r), (V = !1), run_all(H);
    },
  };
}
function instance$2W($, r, p) {
  let v,
    k = noop$1,
    x = () => (k(), (k = subscribe(U, (Q) => p(8, (v = Q)))), U),
    S,
    I = noop$1,
    F = () => (I(), (I = subscribe(L, (Q) => p(4, (S = Q)))), L);
  $.$$.on_destroy.push(() => k()), $.$$.on_destroy.push(() => I());
  let { overlay: O } = r,
    { selected: L } = r;
  F();
  let { processing: U } = r;
  x();
  let N = "";
  onMount(() => {
    p(3, (N = getMimeIcon(R.filename)));
  });
  async function j() {
    set_store_value(U, (v = !0), v);
    const Q = {
      name: R.filename,
      path: R.scopedPath,
      data: await readFile(R.scopedPath),
      mime: R.mime,
    };
    setTargetFile(O.id, Q), set_store_value(U, (v = !1), v);
  }
  let { file: R } = r;
  const q = () => set_store_value(L, (S = R.filename), S);
  return (
    ($.$$set = (Q) => {
      "overlay" in Q && p(6, (O = Q.overlay)),
        "selected" in Q && F(p(0, (L = Q.selected))),
        "processing" in Q && x(p(1, (U = Q.processing))),
        "file" in Q && p(2, (R = Q.file));
    }),
    [L, U, R, N, S, j, O, q]
  );
}
let File$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2W, create_fragment$3c, safe_not_equal, {
        overlay: 6,
        selected: 0,
        processing: 1,
        file: 2,
      });
  }
};
function getAppPreference($, r) {
  const p = get_store_value(UserData);
  if (!(!p.appdata || !p.appdata[$])) return p.appdata[$][r];
}
function setAppPreference($, r, p) {
  const v = get_store_value(UserData);
  return !v.appdata || !v.appdata[$]
    ? !1
    : ((v.appdata[$][r] = p), UserData.set(v), !0);
}
function create_if_block$1f($) {
  let r, p, v, k;
  return {
    c() {
      (r = element("button")), (p = text($[0])), attr(r, "class", "crumb");
    },
    m(x, S) {
      insert(x, r, S),
        append(r, p),
        v || ((k = listen(r, "click", $[1])), (v = !0));
    },
    p(x, S) {
      S & 1 && set_data(p, x[0]);
    },
    d(x) {
      x && detach(r), (v = !1), k();
    },
  };
}
function create_fragment$3b($) {
  let r,
    p = $[0] && $[0] != "." && create_if_block$1f($);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, k) {
      p && p.m(v, k), insert(v, r, k);
    },
    p(v, [k]) {
      v[0] && v[0] != "."
        ? p
          ? p.p(v, k)
          : ((p = create_if_block$1f(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$2V($, r, p) {
  let { crumb: v } = r,
    { path: k } = r,
    { setDir: x } = r;
  function S() {
    x(k);
  }
  return (
    ($.$$set = (I) => {
      "crumb" in I && p(0, (v = I.crumb)),
        "path" in I && p(2, (k = I.path)),
        "setDir" in I && p(3, (x = I.setDir));
    }),
    [v, S, k, x]
  );
}
class Crumb extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2V, create_fragment$3b, safe_not_equal, {
        crumb: 0,
        path: 2,
        setDir: 3,
      });
  }
}
function get_each_context$H($, r, p) {
  const v = $.slice();
  return (v[10] = r[p]), (v[12] = p), v;
}
function create_each_block$H($) {
  let r, p;
  return (
    (r = new Crumb({
      props: { crumb: $[10], path: $[6]($[10], $[12]), setDir: $[3] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 16 && (x.crumb = v[10]),
          k & 16 && (x.path = v[6](v[10], v[12])),
          k & 8 && (x.setDir = v[3]),
          r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$3a($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U,
    N,
    j,
    R,
    q,
    Q,
    K,
    V,
    H,
    G,
    Y,
    J = $[4],
    Z = [];
  for (let ee = 0; ee < J.length; ee += 1)
    Z[ee] = create_each_block$H(get_each_context$H($, J, ee));
  const X = (ee) =>
    transition_out(Z[ee], 1, 1, () => {
      Z[ee] = null;
    });
  return {
    c() {
      (r = element("div")),
        (p = element("button")),
        (v = text("arrow_upward")),
        (x = space()),
        (S = element("button")),
        (S.textContent = "home"),
        (I = space()),
        (F = element("div"));
      for (let ee = 0; ee < Z.length; ee += 1) Z[ee].c();
      (O = space()),
        (L = element("button")),
        (L.textContent = "refresh"),
        (U = space()),
        (N = element("div")),
        (j = element("button")),
        (R = text("format_list_bulleted")),
        (Q = space()),
        (K = element("button")),
        (V = text("grid_view")),
        attr(p, "class", "parentdir material-icons-round"),
        (p.disabled = k = $[4].length == 2 && $[4][0] == "." && !$[4][1]),
        attr(S, "class", "home material-icons-round"),
        attr(F, "class", "addressbar"),
        attr(L, "class", "refresh material-icons-round"),
        attr(j, "class", "material-icons-round"),
        (j.disabled = q = !$[0]),
        attr(j, "title", "List view"),
        toggle_class(j, "selected", $[0]),
        attr(K, "class", "material-icons-round"),
        (K.disabled = $[0]),
        attr(K, "title", "Tile view"),
        toggle_class(K, "selected", !$[0]),
        attr(N, "class", "group"),
        attr(r, "class", "topbar");
    },
    m(ee, te) {
      insert(ee, r, te),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, S),
        append(r, I),
        append(r, F);
      for (let ie = 0; ie < Z.length; ie += 1) Z[ie] && Z[ie].m(F, null);
      append(r, O),
        append(r, L),
        append(r, U),
        append(r, N),
        append(N, j),
        append(j, R),
        append(N, Q),
        append(N, K),
        append(K, V),
        (H = !0),
        G ||
          ((Y = [
            listen(p, "click", $[7]),
            listen(S, "click", $[5]),
            listen(L, "click", function () {
              is_function($[2]) && $[2].apply(this, arguments);
            }),
            listen(j, "click", $[8]),
            listen(K, "click", $[8]),
          ]),
          (G = !0));
    },
    p(ee, [te]) {
      if (
        (($ = ee),
        (!H ||
          (te & 16 &&
            k !== (k = $[4].length == 2 && $[4][0] == "." && !$[4][1]))) &&
          (p.disabled = k),
        te & 88)
      ) {
        J = $[4];
        let ie;
        for (ie = 0; ie < J.length; ie += 1) {
          const ue = get_each_context$H($, J, ie);
          Z[ie]
            ? (Z[ie].p(ue, te), transition_in(Z[ie], 1))
            : ((Z[ie] = create_each_block$H(ue)),
              Z[ie].c(),
              transition_in(Z[ie], 1),
              Z[ie].m(F, null));
        }
        for (group_outros(), ie = J.length; ie < Z.length; ie += 1) X(ie);
        check_outros();
      }
      (!H || (te & 1 && q !== (q = !$[0]))) && (j.disabled = q),
        (!H || te & 1) && toggle_class(j, "selected", $[0]),
        (!H || te & 1) && (K.disabled = $[0]),
        (!H || te & 1) && toggle_class(K, "selected", !$[0]);
    },
    i(ee) {
      if (!H) {
        for (let te = 0; te < J.length; te += 1) transition_in(Z[te]);
        H = !0;
      }
    },
    o(ee) {
      Z = Z.filter(Boolean);
      for (let te = 0; te < Z.length; te += 1) transition_out(Z[te]);
      H = !1;
    },
    d(ee) {
      ee && detach(r), destroy_each(Z, ee), (G = !1), run_all(Y);
    },
  };
}
function instance$2U($, r, p) {
  let v,
    k = noop$1,
    x = () => (k(), (k = subscribe(S, (q) => p(9, (v = q)))), S);
  $.$$.on_destroy.push(() => k());
  let { currentPath: S } = r;
  x();
  let { refresh: I } = r,
    { setDir: F } = r,
    O,
    { tiled: L } = r;
  S.subscribe((q) => {
    p(4, (O = q.split("/"))),
      I(),
      p(0, (L = !!getAppPreference("FileManager", "tiled")));
  });
  function U() {
    S.set("./");
  }
  function N(q, Q) {
    let K = "";
    for (let V = 0; V < Q; V++) K += `${O[V]}/`;
    return `${K}${q}`;
  }
  function j() {
    F(getParentDirectory(v));
  }
  function R() {
    p(0, (L = !L)), setAppPreference("FileManager", "tiled", L);
  }
  return (
    UserData.subscribe(() => {
      p(0, (L = !!getAppPreference("FileManager", "tiled")));
    }),
    ($.$$set = (q) => {
      "currentPath" in q && x(p(1, (S = q.currentPath))),
        "refresh" in q && p(2, (I = q.refresh)),
        "setDir" in q && p(3, (F = q.setDir)),
        "tiled" in q && p(0, (L = q.tiled));
    }),
    [L, S, I, F, O, U, N, j, R]
  );
}
let TopBar$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2U, create_fragment$3a, safe_not_equal, {
        currentPath: 1,
        refresh: 2,
        setDir: 3,
        tiled: 0,
      });
  }
};
const chooseroverlay = "";
function create_fragment$39($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I = $[0].name + "",
    F,
    O,
    L;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (x = space()),
        (S = element("p")),
        (F = text(I)),
        src_url_equal(p.src, (v = folder)) || attr(p, "src", v),
        attr(p, "alt", (k = $[0].name)),
        attr(S, "class", "caption"),
        attr(r, "class", "tile dir");
    },
    m(U, N) {
      insert(U, r, N),
        append(r, p),
        append(r, x),
        append(r, S),
        append(S, F),
        O || ((L = listen(r, "dblclick", $[1])), (O = !0));
    },
    p(U, [N]) {
      N & 1 && k !== (k = U[0].name) && attr(p, "alt", k),
        N & 1 && I !== (I = U[0].name + "") && set_data(F, I);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r), (O = !1), L();
    },
  };
}
function instance$2T($, r, p) {
  let { dir: v } = r,
    { setDir: k } = r;
  function x() {
    k(v.scopedPath);
  }
  return (
    ($.$$set = (S) => {
      "dir" in S && p(0, (v = S.dir)), "setDir" in S && p(2, (k = S.setDir));
    }),
    [v, x, k]
  );
}
let Dir$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2T, create_fragment$39, safe_not_equal, {
        dir: 0,
        setDir: 2,
      });
  }
};
function create_fragment$38($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F = $[2].filename + "",
    O,
    L,
    U;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (I = element("p")),
        (O = text(F)),
        src_url_equal(v.src, (k = $[3])) || attr(v, "src", k),
        attr(v, "alt", (x = $[2].filename)),
        attr(p, "class", "image"),
        attr(I, "class", "name"),
        attr(r, "class", "tile file"),
        toggle_class(r, "selected", $[4] == $[2].filename);
    },
    m(N, j) {
      insert(N, r, j),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, I),
        append(I, O),
        L ||
          ((U = [listen(r, "dblclick", $[5]), listen(r, "click", $[7])]),
          (L = !0));
    },
    p(N, [j]) {
      j & 8 && !src_url_equal(v.src, (k = N[3])) && attr(v, "src", k),
        j & 4 && x !== (x = N[2].filename) && attr(v, "alt", x),
        j & 4 && F !== (F = N[2].filename + "") && set_data(O, F),
        j & 20 && toggle_class(r, "selected", N[4] == N[2].filename);
    },
    i: noop$1,
    o: noop$1,
    d(N) {
      N && detach(r), (L = !1), run_all(U);
    },
  };
}
function instance$2S($, r, p) {
  let v,
    k = noop$1,
    x = () => (k(), (k = subscribe(U, (Q) => p(8, (v = Q)))), U),
    S,
    I = noop$1,
    F = () => (I(), (I = subscribe(L, (Q) => p(4, (S = Q)))), L);
  $.$$.on_destroy.push(() => k()), $.$$.on_destroy.push(() => I());
  let { overlay: O } = r,
    { selected: L } = r;
  F();
  let { processing: U } = r;
  x();
  let N = "";
  onMount(() => {
    p(3, (N = getMimeIcon(R.filename)));
  });
  async function j() {
    set_store_value(U, (v = !0), v);
    const Q = {
      name: R.filename,
      path: R.scopedPath,
      data: await readFile(R.scopedPath),
      mime: R.mime,
    };
    setTargetFile(O.id, Q), set_store_value(U, (v = !1), v);
  }
  let { file: R } = r;
  const q = () => set_store_value(L, (S = R.filename), S);
  return (
    ($.$$set = (Q) => {
      "overlay" in Q && p(6, (O = Q.overlay)),
        "selected" in Q && F(p(0, (L = Q.selected))),
        "processing" in Q && x(p(1, (U = Q.processing))),
        "file" in Q && p(2, (R = Q.file));
    }),
    [L, U, R, N, S, j, O, q]
  );
}
class File extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2S, create_fragment$38, safe_not_equal, {
        overlay: 6,
        selected: 0,
        processing: 1,
        file: 2,
      });
  }
}
function get_each_context$G($, r, p) {
  const v = $.slice();
  return (v[5] = r[p]), v;
}
function get_each_context_1$7($, r, p) {
  const v = $.slice();
  return (v[8] = r[p]), v;
}
function create_if_block$1e($) {
  let r,
    p,
    v = $[3].directories,
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block_1$7(get_each_context_1$7($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      r = element("div");
      for (let S = 0; S < k.length; S += 1) k[S].c();
      attr(r, "class", "dirs");
    },
    m(S, I) {
      insert(S, r, I);
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(r, null);
      p = !0;
    },
    p(S, I) {
      if (I & 24) {
        v = S[3].directories;
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_1$7(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block_1$7(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      S && detach(r), destroy_each(k, S);
    },
  };
}
function create_each_block_1$7($) {
  let r, p;
  return (
    (r = new Dir$1({ props: { dir: $[8], setDir: $[4] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 8 && (x.dir = v[8]), k & 16 && (x.setDir = v[4]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$G($) {
  let r, p;
  return (
    (r = new File({
      props: { file: $[5], overlay: $[0], selected: $[1], processing: $[2] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 8 && (x.file = v[5]),
          k & 1 && (x.overlay = v[0]),
          k & 2 && (x.selected = v[1]),
          k & 4 && (x.processing = v[2]),
          r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$37($) {
  let r,
    p,
    v,
    k,
    x = $[3].directories.length && create_if_block$1e($),
    S = $[3].files,
    I = [];
  for (let O = 0; O < S.length; O += 1)
    I[O] = create_each_block$G(get_each_context$G($, S, O));
  const F = (O) =>
    transition_out(I[O], 1, 1, () => {
      I[O] = null;
    });
  return {
    c() {
      (r = element("div")), x && x.c(), (p = space()), (v = element("div"));
      for (let O = 0; O < I.length; O += 1) I[O].c();
      attr(v, "class", "files"), attr(r, "class", "tiled");
    },
    m(O, L) {
      insert(O, r, L), x && x.m(r, null), append(r, p), append(r, v);
      for (let U = 0; U < I.length; U += 1) I[U] && I[U].m(v, null);
      k = !0;
    },
    p(O, [L]) {
      if (
        (O[3].directories.length
          ? x
            ? (x.p(O, L), L & 8 && transition_in(x, 1))
            : ((x = create_if_block$1e(O)),
              x.c(),
              transition_in(x, 1),
              x.m(r, p))
          : x &&
            (group_outros(),
            transition_out(x, 1, 1, () => {
              x = null;
            }),
            check_outros()),
        L & 15)
      ) {
        S = O[3].files;
        let U;
        for (U = 0; U < S.length; U += 1) {
          const N = get_each_context$G(O, S, U);
          I[U]
            ? (I[U].p(N, L), transition_in(I[U], 1))
            : ((I[U] = create_each_block$G(N)),
              I[U].c(),
              transition_in(I[U], 1),
              I[U].m(v, null));
        }
        for (group_outros(), U = S.length; U < I.length; U += 1) F(U);
        check_outros();
      }
    },
    i(O) {
      if (!k) {
        transition_in(x);
        for (let L = 0; L < S.length; L += 1) transition_in(I[L]);
        k = !0;
      }
    },
    o(O) {
      transition_out(x), (I = I.filter(Boolean));
      for (let L = 0; L < I.length; L += 1) transition_out(I[L]);
      k = !1;
    },
    d(O) {
      O && detach(r), x && x.d(), destroy_each(I, O);
    },
  };
}
function instance$2R($, r, p) {
  let { overlay: v } = r,
    { selected: k } = r,
    { processing: x } = r,
    { data: S } = r,
    { setDir: I } = r;
  return (
    ($.$$set = (F) => {
      "overlay" in F && p(0, (v = F.overlay)),
        "selected" in F && p(1, (k = F.selected)),
        "processing" in F && p(2, (x = F.processing)),
        "data" in F && p(3, (S = F.data)),
        "setDir" in F && p(4, (I = F.setDir));
    }),
    [v, k, x, S, I]
  );
}
class Tiled extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2R, create_fragment$37, safe_not_equal, {
        overlay: 0,
        selected: 1,
        processing: 2,
        data: 3,
        setDir: 4,
      });
  }
}
function create_fragment$36($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I = $[0].name + "",
    F,
    O,
    L;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (x = space()),
        (S = element("p")),
        (F = text(I)),
        src_url_equal(p.src, (v = folder)) || attr(p, "src", v),
        attr(p, "alt", (k = $[0].name)),
        attr(S, "class", "caption"),
        attr(r, "class", "link"),
        toggle_class(r, "selected", $[1]);
    },
    m(U, N) {
      insert(U, r, N),
        append(r, p),
        append(r, x),
        append(r, S),
        append(S, F),
        O || ((L = listen(r, "click", $[2])), (O = !0));
    },
    p(U, [N]) {
      N & 1 && k !== (k = U[0].name) && attr(p, "alt", k),
        N & 1 && I !== (I = U[0].name + "") && set_data(F, I),
        N & 2 && toggle_class(r, "selected", U[1]);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r), (O = !1), L();
    },
  };
}
function instance$2Q($, r, p) {
  let { folder: v } = r,
    { setDir: k } = r,
    { currentPath: x } = r,
    S = !1;
  function I() {
    k(v.scopedPath);
  }
  return (
    x.subscribe((F) => {
      p(1, (S = F == v.scopedPath));
    }),
    ($.$$set = (F) => {
      "folder" in F && p(0, (v = F.folder)),
        "setDir" in F && p(3, (k = F.setDir)),
        "currentPath" in F && p(4, (x = F.currentPath));
    }),
    [v, S, I, k, x]
  );
}
let Link$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2Q, create_fragment$36, safe_not_equal, {
        folder: 0,
        setDir: 3,
        currentPath: 4,
      });
  }
};
function get_each_context$F($, r, p) {
  const v = $.slice();
  return (v[4] = r[p]), v;
}
function create_each_block$F($) {
  let r, p;
  return (
    (r = new Link$1({
      props: { setDir: $[1], currentPath: $[0], folder: $[4] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 2 && (x.setDir = v[1]),
          k & 1 && (x.currentPath = v[0]),
          k & 4 && (x.folder = v[4]),
          r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$35($) {
  let r,
    p,
    v = $[2],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$F(get_each_context$F($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      r = element("div");
      for (let S = 0; S < k.length; S += 1) k[S].c();
      attr(r, "class", "sidebar");
    },
    m(S, I) {
      insert(S, r, I);
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(r, null);
      p = !0;
    },
    p(S, [I]) {
      if (I & 7) {
        v = S[2];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$F(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$F(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      S && detach(r), destroy_each(k, S);
    },
  };
}
function instance$2P($, r, p) {
  let v = [],
    { currentDir: k } = r,
    { currentPath: x } = r,
    { setDir: S } = r;
  return (
    k.subscribe(async (I) => {
      p(2, (v = (await getDirectory("./")).directories));
    }),
    ($.$$set = (I) => {
      "currentDir" in I && p(3, (k = I.currentDir)),
        "currentPath" in I && p(0, (x = I.currentPath)),
        "setDir" in I && p(1, (S = I.setDir));
    }),
    [x, S, v, k]
  );
}
let SideBar$2 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2P, create_fragment$35, safe_not_equal, {
        currentDir: 3,
        currentPath: 0,
        setDir: 1,
      });
  }
};
function get_each_context$E($, r, p) {
  const v = $.slice();
  return (v[13] = r[p]), v;
}
function get_each_context_1$6($, r, p) {
  const v = $.slice();
  return (v[16] = r[p]), v;
}
function create_if_block$1d($) {
  let r, p, v, k, x, S, I, F, O, L, U, N;
  function j(H) {
    $[11](H);
  }
  let R = { currentPath: $[6], refresh: $[10], setDir: $[9] };
  $[1] !== void 0 && (R.tiled = $[1]),
    (r = new TopBar$1({ props: R })),
    binding_callbacks.push(() => bind$1(r, "tiled", j)),
    (x = new SideBar$2({
      props: { currentDir: $[5], setDir: $[9], currentPath: $[6] },
    }));
  const q = [create_if_block_2$5, create_else_block$p],
    Q = [];
  function K(H, G) {
    return H[1] ? 0 : 1;
  }
  (I = K($)), (F = Q[I] = q[I]($));
  let V = $[3] && create_if_block_1$o($);
  return (
    (U = new BottomPane$1({
      props: {
        currentDir: $[5],
        currentPath: $[6],
        selected: $[7],
        overlay: $[0],
        processing: $[8],
      },
    })),
    {
      c() {
        create_component(r.$$.fragment),
          (v = space()),
          (k = element("div")),
          create_component(x.$$.fragment),
          (S = space()),
          F.c(),
          (O = space()),
          V && V.c(),
          (L = space()),
          create_component(U.$$.fragment),
          attr(k, "class", "content");
      },
      m(H, G) {
        mount_component(r, H, G),
          insert(H, v, G),
          insert(H, k, G),
          mount_component(x, k, null),
          append(k, S),
          Q[I].m(k, null),
          append(k, O),
          V && V.m(k, null),
          insert(H, L, G),
          mount_component(U, H, G),
          (N = !0);
      },
      p(H, G) {
        const Y = {};
        !p &&
          G & 2 &&
          ((p = !0), (Y.tiled = H[1]), add_flush_callback(() => (p = !1))),
          r.$set(Y);
        let J = I;
        (I = K(H)),
          I === J
            ? Q[I].p(H, G)
            : (group_outros(),
              transition_out(Q[J], 1, 1, () => {
                Q[J] = null;
              }),
              check_outros(),
              (F = Q[I]),
              F ? F.p(H, G) : ((F = Q[I] = q[I](H)), F.c()),
              transition_in(F, 1),
              F.m(k, O)),
          H[3]
            ? V
              ? (V.p(H, G), G & 8 && transition_in(V, 1))
              : ((V = create_if_block_1$o(H)),
                V.c(),
                transition_in(V, 1),
                V.m(k, null))
            : V &&
              (group_outros(),
              transition_out(V, 1, 1, () => {
                V = null;
              }),
              check_outros());
        const Z = {};
        G & 1 && (Z.overlay = H[0]), U.$set(Z);
      },
      i(H) {
        N ||
          (transition_in(r.$$.fragment, H),
          transition_in(x.$$.fragment, H),
          transition_in(F),
          transition_in(V),
          transition_in(U.$$.fragment, H),
          (N = !0));
      },
      o(H) {
        transition_out(r.$$.fragment, H),
          transition_out(x.$$.fragment, H),
          transition_out(F),
          transition_out(V),
          transition_out(U.$$.fragment, H),
          (N = !1);
      },
      d(H) {
        destroy_component(r, H),
          H && detach(v),
          H && detach(k),
          destroy_component(x),
          Q[I].d(),
          V && V.d(),
          H && detach(L),
          destroy_component(U, H);
      },
    }
  );
}
function create_else_block$p($) {
  let r, p, v, k, x;
  p = new TopRow({});
  let S = $[2].directories,
    I = [];
  for (let N = 0; N < S.length; N += 1)
    I[N] = create_each_block_1$6(get_each_context_1$6($, S, N));
  const F = (N) =>
    transition_out(I[N], 1, 1, () => {
      I[N] = null;
    });
  let O = $[2].files,
    L = [];
  for (let N = 0; N < O.length; N += 1)
    L[N] = create_each_block$E(get_each_context$E($, O, N));
  const U = (N) =>
    transition_out(L[N], 1, 1, () => {
      L[N] = null;
    });
  return {
    c() {
      (r = element("div")), create_component(p.$$.fragment), (v = space());
      for (let N = 0; N < I.length; N += 1) I[N].c();
      k = space();
      for (let N = 0; N < L.length; N += 1) L[N].c();
      attr(r, "class", "list");
    },
    m(N, j) {
      insert(N, r, j), mount_component(p, r, null), append(r, v);
      for (let R = 0; R < I.length; R += 1) I[R] && I[R].m(r, null);
      append(r, k);
      for (let R = 0; R < L.length; R += 1) L[R] && L[R].m(r, null);
      x = !0;
    },
    p(N, j) {
      if (j & 516) {
        S = N[2].directories;
        let R;
        for (R = 0; R < S.length; R += 1) {
          const q = get_each_context_1$6(N, S, R);
          I[R]
            ? (I[R].p(q, j), transition_in(I[R], 1))
            : ((I[R] = create_each_block_1$6(q)),
              I[R].c(),
              transition_in(I[R], 1),
              I[R].m(r, k));
        }
        for (group_outros(), R = S.length; R < I.length; R += 1) F(R);
        check_outros();
      }
      if (j & 389) {
        O = N[2].files;
        let R;
        for (R = 0; R < O.length; R += 1) {
          const q = get_each_context$E(N, O, R);
          L[R]
            ? (L[R].p(q, j), transition_in(L[R], 1))
            : ((L[R] = create_each_block$E(q)),
              L[R].c(),
              transition_in(L[R], 1),
              L[R].m(r, null));
        }
        for (group_outros(), R = O.length; R < L.length; R += 1) U(R);
        check_outros();
      }
    },
    i(N) {
      if (!x) {
        transition_in(p.$$.fragment, N);
        for (let j = 0; j < S.length; j += 1) transition_in(I[j]);
        for (let j = 0; j < O.length; j += 1) transition_in(L[j]);
        x = !0;
      }
    },
    o(N) {
      transition_out(p.$$.fragment, N), (I = I.filter(Boolean));
      for (let j = 0; j < I.length; j += 1) transition_out(I[j]);
      L = L.filter(Boolean);
      for (let j = 0; j < L.length; j += 1) transition_out(L[j]);
      x = !1;
    },
    d(N) {
      N && detach(r),
        destroy_component(p),
        destroy_each(I, N),
        destroy_each(L, N);
    },
  };
}
function create_if_block_2$5($) {
  let r, p;
  return (
    (r = new Tiled({
      props: {
        data: $[2],
        setDir: $[9],
        overlay: $[0],
        selected: $[7],
        processing: $[8],
      },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 4 && (x.data = v[2]), k & 1 && (x.overlay = v[0]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block_1$6($) {
  let r, p;
  return (
    (r = new Dir$2({ props: { setDir: $[9], dir: $[16] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 4 && (x.dir = v[16]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$E($) {
  let r, p;
  return (
    (r = new File$1({
      props: { file: $[13], overlay: $[0], selected: $[7], processing: $[8] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 4 && (x.file = v[13]), k & 1 && (x.overlay = v[0]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_1$o($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j;
  return (
    (N = new Spinner({ props: { height: 30 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          (v = element("div")),
          (k = element("img")),
          (S = space()),
          (I = element("p")),
          (F = text("Opening ")),
          (O = text($[4])),
          (L = text("...")),
          (U = space()),
          create_component(N.$$.fragment),
          src_url_equal(k.src, (x = icon$4)) || attr(k, "src", x),
          attr(k, "alt", ""),
          attr(I, "class", "caption"),
          attr(v, "class", "processing"),
          attr(p, "class", "processing-content"),
          attr(r, "class", "processing-overlay");
      },
      m(R, q) {
        insert(R, r, q),
          append(r, p),
          append(p, v),
          append(v, k),
          append(v, S),
          append(v, I),
          append(I, F),
          append(I, O),
          append(I, L),
          append(v, U),
          mount_component(N, v, null),
          (j = !0);
      },
      p(R, q) {
        (!j || q & 16) && set_data(O, R[4]);
      },
      i(R) {
        j || (transition_in(N.$$.fragment, R), (j = !0));
      },
      o(R) {
        transition_out(N.$$.fragment, R), (j = !1);
      },
      d(R) {
        R && detach(r), destroy_component(N);
      },
    }
  );
}
function create_fragment$34($) {
  let r,
    p,
    v = $[0] && create_if_block$1d($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[0]
        ? v
          ? (v.p(k, x), x & 1 && transition_in(v, 1))
          : ((v = create_if_block$1d(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$2O($, r, p) {
  let v,
    k,
    x,
    S,
    { overlay: I } = r,
    F = !1,
    O = writable(defaultDirectory);
  component_subscribe($, O, (Q) => p(2, (k = Q)));
  let L = writable("./");
  component_subscribe($, L, (Q) => p(12, (v = Q)));
  let U = writable(null);
  component_subscribe($, U, (Q) => p(4, (S = Q)));
  let N = writable(!1);
  component_subscribe($, N, (Q) => p(3, (x = Q)));
  async function j(Q) {
    set_store_value(L, (v = Q), v), await R();
  }
  async function R() {
    set_store_value(O, (k = defaultDirectory), k),
      set_store_value(O, (k = (await getDirectory(v)) || null), k);
  }
  function q(Q) {
    (F = Q), p(1, F);
  }
  return (
    ($.$$set = (Q) => {
      "overlay" in Q && p(0, (I = Q.overlay));
    }),
    [I, F, k, x, S, O, L, U, N, j, R, q]
  );
}
class ChooserOverlay extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2O, create_fragment$34, safe_not_equal, {
        overlay: 0,
      });
  }
}
function generateChooserOverlayData($ = "Choose File") {
  return {
    info: { name: $, author: "ArcOS Generated", version: "1" },
    size: { w: NaN, h: NaN },
    show: !0,
    id: `CHOOSER#${Math.floor(Math.random() * 1e6)}`,
    content: ChooserOverlay,
  };
}
function showOpenFileDialog($) {
  const r = get_store_value(WindowStore);
  let p = null;
  for (let k = 0; k < r.length; k++)
    if (r[k].id == $) {
      p = k;
      break;
    }
  if (p == null) return !1;
  const v = generateChooserOverlayData();
  assignTarget(v.id, $),
    r[p].overlays || (r[p].overlays = {}),
    (r[p].overlays[v.id] = v),
    WindowStore.set(r);
}
const TextEditorContent = writable(null);
async function saveTextEditorFile($, r) {
  const p = new Blob([$]);
  await writeFile(r.path, p);
}
async function setShortcuts($, r) {
  registerShortcuts(
    [
      {
        key: "o",
        alt: !0,
        action: () => {
          showOpenFileDialog($.id);
        },
      },
      {
        key: "m",
        alt: !0,
        action: () => {
          !$.openedFile ||
            !$.openedFile.name.endsWith(".md") ||
            (openWindow("MarkDownViewer"), closeFile("MarkDownViewer"));
        },
      },
      { key: "s", alt: !0, action: r },
    ],
    "TextEditor"
  ),
    ($.events.close = () => {
      get_store_value(TextEditorContent) && closeWindow("MarkDownViewer");
    });
}
async function doLoadError($, r) {
  return createOverlayableError(
    {
      title: $,
      message: r,
      buttons: [{ caption: "Close", action: () => closeWindow("TextEditor") }],
    },
    "TextEditor"
  );
}
function tryParse($) {
  try {
    return JSON.parse($);
  } catch {
    return !1;
  }
}
function create_fragment$33($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R;
  return {
    c() {
      (r = element("div")),
        (p = element("button")),
        (p.textContent = "folder_open"),
        (v = space()),
        (k = element("button")),
        (x = text("save")),
        (I = space()),
        (F = element("div")),
        (O = element("button")),
        (L = element("img")),
        attr(p, "class", "material-icons-round open"),
        attr(k, "class", "material-icons-round save"),
        (k.disabled = S = !$[0].openedFile),
        src_url_equal(L.src, (U = icon$3)) || attr(L, "src", U),
        attr(L, "alt", "Markdown Viewer"),
        attr(O, "title", "Open Markdown Viewer"),
        (O.disabled = N =
          !$[0].openedFile || !$[0].openedFile.name.endsWith(".md")),
        attr(O, "class", "markdown-open"),
        attr(F, "class", "right"),
        attr(r, "class", "actions");
    },
    m(q, Q) {
      insert(q, r, Q),
        append(r, p),
        append(r, v),
        append(r, k),
        append(k, x),
        append(r, I),
        append(r, F),
        append(F, O),
        append(O, L),
        j ||
          ((R = [
            listen(p, "click", $[2]),
            listen(k, "click", function () {
              is_function($[1]) && $[1].apply(this, arguments);
            }),
            listen(O, "click", $[3]),
          ]),
          (j = !0));
    },
    p(q, [Q]) {
      ($ = q),
        Q & 1 && S !== (S = !$[0].openedFile) && (k.disabled = S),
        Q & 1 &&
          N !==
            (N = !$[0].openedFile || !$[0].openedFile.name.endsWith(".md")) &&
          (O.disabled = N);
    },
    i: noop$1,
    o: noop$1,
    d(q) {
      q && detach(r), (j = !1), run_all(R);
    },
  };
}
function instance$2N($, r, p) {
  let { app: v } = r,
    { saveFile: k } = r;
  const x = () => showOpenFileDialog(v.id),
    S = () => openWindow("MarkDownViewer");
  return (
    ($.$$set = (I) => {
      "app" in I && p(0, (v = I.app)),
        "saveFile" in I && p(1, (k = I.saveFile));
    }),
    [v, k, x, S]
  );
}
let Actions$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2N, create_fragment$33, safe_not_equal, {
        app: 0,
        saveFile: 1,
      });
  }
};
function create_fragment$32($) {
  let r,
    p,
    v,
    k,
    x = formatBytes($[0].length) + "",
    S,
    I,
    F,
    O = $[1].openedFile.name + "",
    L,
    U,
    N,
    j = $[1].openedFile.mime.split(";")[0] + "",
    R;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("div")),
        (k = text("Size: ")),
        (S = text(x)),
        (I = space()),
        (F = element("div")),
        (L = text(O)),
        (U = space()),
        (N = element("div")),
        (R = text(j)),
        attr(v, "class", "section"),
        attr(F, "class", "section"),
        attr(N, "class", "section"),
        attr(p, "class", "right"),
        attr(r, "class", "bottom");
    },
    m(q, Q) {
      insert(q, r, Q),
        append(r, p),
        append(p, v),
        append(v, k),
        append(v, S),
        append(p, I),
        append(p, F),
        append(F, L),
        append(p, U),
        append(p, N),
        append(N, R);
    },
    p(q, [Q]) {
      Q & 1 && x !== (x = formatBytes(q[0].length) + "") && set_data(S, x),
        Q & 2 && O !== (O = q[1].openedFile.name + "") && set_data(L, O),
        Q & 2 &&
          j !== (j = q[1].openedFile.mime.split(";")[0] + "") &&
          set_data(R, j);
    },
    i: noop$1,
    o: noop$1,
    d(q) {
      q && detach(r);
    },
  };
}
function instance$2M($, r, p) {
  let { fileContents: v } = r,
    { app: k } = r;
  return (
    ($.$$set = (x) => {
      "fileContents" in x && p(0, (v = x.fileContents)),
        "app" in x && p(1, (k = x.app));
    }),
    [v, k]
  );
}
let Bottom$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2M, create_fragment$32, safe_not_equal, {
        fileContents: 0,
        app: 1,
      });
  }
};
const icon = "./assets/save-13107e70.svg";
function create_if_block$1c($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F = $[1].openedFile.name + "",
    O,
    L,
    U,
    N,
    j;
  return (
    (N = new Spinner({ props: { height: 24 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          (v = element("img")),
          (x = space()),
          (S = element("p")),
          (I = text("Saving ")),
          (O = text(F)),
          (L = text("...")),
          (U = space()),
          create_component(N.$$.fragment),
          src_url_equal(v.src, (k = icon)) || attr(v, "src", k),
          attr(v, "alt", "Saving"),
          attr(S, "class", "caption"),
          attr(p, "class", "saving-content"),
          attr(r, "class", "saving-wrapper");
      },
      m(R, q) {
        insert(R, r, q),
          append(r, p),
          append(p, v),
          append(p, x),
          append(p, S),
          append(S, I),
          append(S, O),
          append(S, L),
          append(p, U),
          mount_component(N, p, null),
          (j = !0);
      },
      p(R, q) {
        (!j || q & 2) &&
          F !== (F = R[1].openedFile.name + "") &&
          set_data(O, F);
      },
      i(R) {
        j || (transition_in(N.$$.fragment, R), (j = !0));
      },
      o(R) {
        transition_out(N.$$.fragment, R), (j = !1);
      },
      d(R) {
        R && detach(r), destroy_component(N);
      },
    }
  );
}
function create_fragment$31($) {
  let r,
    p,
    v = $[0] && $[1].openedFile && create_if_block$1c($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[0] && k[1].openedFile
        ? v
          ? (v.p(k, x), x & 3 && transition_in(v, 1))
          : ((v = create_if_block$1c(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$2L($, r, p) {
  let { saving: v } = r,
    { app: k } = r;
  return (
    ($.$$set = (x) => {
      "saving" in x && p(0, (v = x.saving)), "app" in x && p(1, (k = x.app));
    }),
    [v, k]
  );
}
class Saving extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2L, create_fragment$31, safe_not_equal, {
        saving: 0,
        app: 1,
      });
  }
}
function create_fragment$30($) {
  let r, p, v;
  return {
    c() {
      (r = element("textarea")), attr(r, "spellcheck", !1);
    },
    m(k, x) {
      insert(k, r, x),
        set_input_value(r, $[0]),
        p ||
          ((v = [
            listen(r, "input", $[2]),
            listen(r, "change", function () {
              is_function($[1]) && $[1].apply(this, arguments);
            }),
            listen(r, "input", function () {
              is_function($[1]) && $[1].apply(this, arguments);
            }),
            listen(r, "keydown", function () {
              is_function($[1]) && $[1].apply(this, arguments);
            }),
          ]),
          (p = !0));
    },
    p(k, [x]) {
      ($ = k), x & 1 && set_input_value(r, $[0]);
    },
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r), (p = !1), run_all(v);
    },
  };
}
function instance$2K($, r, p) {
  let { onchange: v } = r,
    { fileContents: k } = r;
  function x() {
    (k = this.value), p(0, k);
  }
  return (
    ($.$$set = (S) => {
      "onchange" in S && p(1, (v = S.onchange)),
        "fileContents" in S && p(0, (k = S.fileContents));
    }),
    [k, v, x]
  );
}
class TextArea extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2K, create_fragment$30, safe_not_equal, {
        onchange: 1,
        fileContents: 0,
      });
  }
}
function create_if_block$1b($) {
  let r, p, v, k, x;
  function S(F) {
    $[6](F);
  }
  let I = { onchange: $[5] };
  return (
    $[3] !== void 0 && (I.fileContents = $[3]),
    (r = new TextArea({ props: I })),
    binding_callbacks.push(() => bind$1(r, "fileContents", S)),
    (k = new Bottom$1({ props: { fileContents: $[3], app: $[0] } })),
    {
      c() {
        create_component(r.$$.fragment),
          (v = space()),
          create_component(k.$$.fragment);
      },
      m(F, O) {
        mount_component(r, F, O),
          insert(F, v, O),
          mount_component(k, F, O),
          (x = !0);
      },
      p(F, O) {
        const L = {};
        !p &&
          O & 8 &&
          ((p = !0),
          (L.fileContents = F[3]),
          add_flush_callback(() => (p = !1))),
          r.$set(L);
        const U = {};
        O & 8 && (U.fileContents = F[3]), O & 1 && (U.app = F[0]), k.$set(U);
      },
      i(F) {
        x ||
          (transition_in(r.$$.fragment, F),
          transition_in(k.$$.fragment, F),
          (x = !0));
      },
      o(F) {
        transition_out(r.$$.fragment, F),
          transition_out(k.$$.fragment, F),
          (x = !1);
      },
      d(F) {
        destroy_component(r, F), F && detach(v), destroy_component(k, F);
      },
    }
  );
}
function create_fragment$2$($) {
  let r, p, v, k, x, S, I;
  r = new Actions$1({ props: { app: $[0], saveFile: $[4] } });
  let F = $[0].openedFile && !$[1] && create_if_block$1b($);
  function O(U) {
    $[7](U);
  }
  let L = { saving: $[2] };
  return (
    $[0] !== void 0 && (L.app = $[0]),
    (x = new Saving({ props: L })),
    binding_callbacks.push(() => bind$1(x, "app", O)),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          (v = element("div")),
          F && F.c(),
          (k = space()),
          create_component(x.$$.fragment),
          attr(v, "class", "content"),
          toggle_class(v, "nofile", !$[0].openedFile);
      },
      m(U, N) {
        mount_component(r, U, N),
          insert(U, p, N),
          insert(U, v, N),
          F && F.m(v, null),
          insert(U, k, N),
          mount_component(x, U, N),
          (I = !0);
      },
      p(U, [N]) {
        const j = {};
        N & 1 && (j.app = U[0]),
          r.$set(j),
          U[0].openedFile && !U[1]
            ? F
              ? (F.p(U, N), N & 3 && transition_in(F, 1))
              : ((F = create_if_block$1b(U)),
                F.c(),
                transition_in(F, 1),
                F.m(v, null))
            : F &&
              (group_outros(),
              transition_out(F, 1, 1, () => {
                F = null;
              }),
              check_outros()),
          (!I || N & 1) && toggle_class(v, "nofile", !U[0].openedFile);
        const R = {};
        N & 4 && (R.saving = U[2]),
          !S &&
            N & 1 &&
            ((S = !0), (R.app = U[0]), add_flush_callback(() => (S = !1))),
          x.$set(R);
      },
      i(U) {
        I ||
          (transition_in(r.$$.fragment, U),
          transition_in(F),
          transition_in(x.$$.fragment, U),
          (I = !0));
      },
      o(U) {
        transition_out(r.$$.fragment, U),
          transition_out(F),
          transition_out(x.$$.fragment, U),
          (I = !1);
      },
      d(U) {
        destroy_component(r, U),
          U && detach(p),
          U && detach(v),
          F && F.d(),
          U && detach(k),
          destroy_component(x, U);
      },
    }
  );
}
function instance$2J($, r, p) {
  let v;
  component_subscribe($, TextEditorContent, (j) => p(9, (v = j)));
  let { app: k } = r,
    x = !1,
    S = !1,
    I = "";
  onMount(() => {
    p(0, (k.events = {}), k),
      p(
        0,
        (k.events.openFile = (j) => {
          if ((p(1, (x = !1)), !j.openedFile)) return p(3, (I = ""));
          const R = new TextDecoder().decode(j.openedFile.data);
          p(3, (I = R)), j.openedFile.path, TextEditorContent.set(I);
          const q = tryParse(I);
          q &&
            q.error &&
            q.valid == !1 &&
            (p(1, (x = !0)), doLoadError(q.error.title, q.error.message));
        }),
        k
      ),
      p(0, (k.events.open = L), k),
      setShortcuts(k, F);
  });
  async function F() {
    if (!k.openedFile.path) {
      showOverlay("saveNewFile", "TextEditor");
      return;
    }
    p(2, (S = !0)), await saveTextEditorFile(I, k.openedFile), p(2, (S = !1));
  }
  async function O() {
    v != I && TextEditorContent.set(I);
  }
  async function L() {
    k.openedFile ||
      p(
        0,
        (k.openedFile = {
          name: "Untitled",
          path: "",
          data: new ArrayBuffer(0),
          mime: "text/plain",
        }),
        k
      );
  }
  function U(j) {
    (I = j), p(3, I);
  }
  function N(j) {
    (k = j), p(0, k);
  }
  return (
    ($.$$set = (j) => {
      "app" in j && p(0, (k = j.app));
    }),
    [k, x, S, I, F, O, U, N]
  );
}
class TextView extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2J, create_fragment$2$, safe_not_equal, {
        app: 0,
      });
  }
}
function setTitleSuffix($, r) {
  Log({
    msg: `Setting title suffix of ${r}`,
    source: "title.ts: setTitleSuffix",
    level: LogLevel.info,
  });
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++)
    p[v].id == r &&
      (Originals[r] || (Originals[r] = `${p[v].info.titleSuffix}`),
      (p[v].info.titleSuffix = $));
  WindowStore.set(p);
}
const Originals = {},
  ImageViewer = {
    info: {
      name: "Image Viewer",
      description: "Display images from the ArcAPI",
      builtin: !0,
      version: "2.0.1",
      author: "Izaak Kuipers",
      hidden: !0,
      icon: logo$6,
    },
    size: { w: 500, h: 400 },
    pos: { x: 30, y: 40 },
    minSize: { w: 500, h: 400 },
    maxSize: { w: 1e3, h: 700 },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: ImageView,
    glass: !0,
    fileMimes: [
      "image/png",
      "image/jpeg",
      "image/svg+xml",
      "image/vnd.microsoft.icon",
      "image/bmp",
      "image/jpeg",
      "image/webp",
      "image/gif",
    ],
    events: {
      openFile($) {
        $.openedFile && setTitleSuffix(` - ${$.openedFile.name}`, $.id);
      },
    },
    contextMenu: {
      output: [
        {
          caption: "Set as wallpaper",
          icon: "image",
          action($, r, p) {
            const v = get_store_value(UserData);
            (v.sh.desktop.wallpaper = `@local:${btoa(r.path)}`),
              UserData.set(v);
          },
        },
      ],
    },
  },
  logo$5 = "./assets/logger-53b4bb5a.svg",
  logger = "";
function collectLogsBySource() {
  const $ = get_store_value(log);
  let r = [],
    p = {};
  for (let v = 0; v < $.length; v++) {
    const k = $[v];
    r.includes(k.source) || r.push(k.source),
      (p[k.source] = Array.prototype.concat(p[k.source] || [], [k]));
  }
  return p;
}
function create_fragment$2_($) {
  let r,
    p,
    v = $[0][1] + "",
    k,
    x,
    S,
    I,
    F;
  return {
    c() {
      (r = element("button")),
        (p = element("span")),
        (k = text(v)),
        attr(p, "class", "material-icons-round"),
        attr(r, "class", (x = "filter " + LogLevel[$[0][0]])),
        (r.disabled = S = !$[1] || $[4]),
        toggle_class(r, "selected", $[0][0] == $[2]);
    },
    m(O, L) {
      insert(O, r, L),
        append(r, p),
        append(p, k),
        I || ((F = listen(r, "click", $[5])), (I = !0));
    },
    p(O, [L]) {
      L & 1 && v !== (v = O[0][1] + "") && set_data(k, v),
        L & 1 &&
          x !== (x = "filter " + LogLevel[O[0][0]]) &&
          attr(r, "class", x),
        L & 18 && S !== (S = !O[1] || O[4]) && (r.disabled = S),
        L & 5 && toggle_class(r, "selected", O[0][0] == O[2]);
    },
    i: noop$1,
    o: noop$1,
    d(O) {
      O && detach(r), (I = !1), F();
    },
  };
}
function instance$2I($, r, p) {
  let v;
  component_subscribe($, log, (L) => p(6, (v = L)));
  let { data: k } = r,
    { currentSource: x } = r,
    { currentFilter: S } = r,
    { filter: I } = r,
    F = !1;
  log.subscribe(() => {
    setTimeout(() => {
      let L = 0;
      for (let U = 0; U < v.length; U++)
        v[U].level == k[0] && v[U].source == x && L++;
      p(4, (F = !L));
    }),
      p(4, (F = !1));
  });
  const O = () => I(k[0]);
  return (
    ($.$$set = (L) => {
      "data" in L && p(0, (k = L.data)),
        "currentSource" in L && p(1, (x = L.currentSource)),
        "currentFilter" in L && p(2, (S = L.currentFilter)),
        "filter" in L && p(3, (I = L.filter));
    }),
    [k, x, S, I, F, O]
  );
}
class Filter extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2I, create_fragment$2_, safe_not_equal, {
        data: 0,
        currentSource: 1,
        currentFilter: 2,
        filter: 3,
      });
  }
}
function get_each_context$D($, r, p) {
  const v = $.slice();
  return (v[4] = r[p]), v;
}
function create_each_block$D($) {
  let r, p;
  return (
    (r = new Filter({
      props: {
        data: $[4],
        currentSource: $[2],
        currentFilter: $[0],
        filter: $[1],
      },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 4 && (x.currentSource = v[2]),
          k & 1 && (x.currentFilter = v[0]),
          k & 2 && (x.filter = v[1]),
          r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$2Z($) {
  let r,
    p,
    v = $[3],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$D(get_each_context$D($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      r = element("div");
      for (let S = 0; S < k.length; S += 1) k[S].c();
      attr(r, "class", "filters");
    },
    m(S, I) {
      insert(S, r, I);
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(r, null);
      p = !0;
    },
    p(S, [I]) {
      if (I & 15) {
        v = S[3];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$D(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$D(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      S && detach(r), destroy_each(k, S);
    },
  };
}
function instance$2H($, r, p) {
  let { filter: v } = r,
    { currentFilter: k } = r,
    { currentSource: x } = r;
  const S = [
    [LogLevel.error, "error"],
    [LogLevel.warn, "warning"],
    [LogLevel.info, "info"],
    [LogLevel.critical, "cancel"],
  ];
  return (
    log.subscribe(() => {
      p(0, (k = null));
    }),
    ($.$$set = (I) => {
      "filter" in I && p(1, (v = I.filter)),
        "currentFilter" in I && p(0, (k = I.currentFilter)),
        "currentSource" in I && p(2, (x = I.currentSource));
    }),
    [k, v, x, S]
  );
}
class Filters extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2H, create_fragment$2Z, safe_not_equal, {
        filter: 1,
        currentFilter: 0,
        currentSource: 2,
      });
  }
}
function create_fragment$2Y($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K;
  return {
    c() {
      (r = element("div")),
        (p = element("button")),
        (v = element("img")),
        (x = text(`
    Clear`)),
        (I = space()),
        (F = element("div")),
        (O = space()),
        (L = element("button")),
        (U = element("span")),
        (U.textContent = "refresh"),
        (N = text(`
    Refresh`)),
        (R = space()),
        (q = element("button")),
        (q.innerHTML = `<span class="material-icons-round">title</span>
    monospace`),
        src_url_equal(v.src, (k = clear$1)) || attr(v, "src", k),
        attr(v, "alt", "Clear"),
        attr(p, "class", "action"),
        (p.disabled = S = !$[0]),
        attr(F, "class", "sep"),
        attr(U, "class", "material-icons-round"),
        attr(L, "class", "action"),
        (L.disabled = j = !$[0]),
        attr(q, "class", "action"),
        attr(r, "class", "static");
    },
    m(V, H) {
      insert(V, r, H),
        append(r, p),
        append(p, v),
        append(p, x),
        append(r, I),
        append(r, F),
        append(r, O),
        append(r, L),
        append(L, U),
        append(L, N),
        append(r, R),
        append(r, q),
        Q ||
          ((K = [
            listen(p, "click", $[10]),
            listen(L, "click", $[2]),
            listen(q, "click", $[3]),
          ]),
          (Q = !0));
    },
    p(V, [H]) {
      H & 1 && S !== (S = !V[0]) && (p.disabled = S),
        H & 1 && j !== (j = !V[0]) && (L.disabled = j);
    },
    i: noop$1,
    o: noop$1,
    d(V) {
      V && detach(r), (Q = !1), run_all(K);
    },
  };
}
function instance$2G($, r, p) {
  let v, k;
  component_subscribe($, UserData, (Q) => p(11, (v = Q))),
    component_subscribe($, log, (Q) => p(12, (k = Q)));
  let { currentSource: x } = r,
    { currentFilter: S } = r,
    { logItems: I } = r,
    { setView: F } = r,
    { filter: O } = r,
    { appdata: L } = r,
    { app: U } = r;
  function N(Q) {
    for (let K = 0; K < k.length; K++) k[K].source == Q && k.splice(K, 1);
    p(0, (x = "")), p(4, (I = [])), log.set(k);
  }
  function j() {
    Log({
      source: "Logger: refresh",
      msg: "Refreshing current view",
      level: LogLevel.warn,
    }),
      F(x),
      S && O(S);
  }
  function R() {
    p(5, (L.monospace = !L.monospace), L),
      set_store_value(UserData, (v.appdata[U.id] = L), v);
  }
  const q = () => N(x);
  return (
    ($.$$set = (Q) => {
      "currentSource" in Q && p(0, (x = Q.currentSource)),
        "currentFilter" in Q && p(6, (S = Q.currentFilter)),
        "logItems" in Q && p(4, (I = Q.logItems)),
        "setView" in Q && p(7, (F = Q.setView)),
        "filter" in Q && p(8, (O = Q.filter)),
        "appdata" in Q && p(5, (L = Q.appdata)),
        "app" in Q && p(9, (U = Q.app));
    }),
    [x, N, j, R, I, L, S, F, O, U, q]
  );
}
class Static extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2G, create_fragment$2Y, safe_not_equal, {
        currentSource: 0,
        currentFilter: 6,
        logItems: 4,
        setView: 7,
        filter: 8,
        appdata: 5,
        app: 9,
      });
  }
}
function create_fragment$2X($) {
  let r, p, v, k, x, S, I, F;
  function O(j) {
    $[8](j);
  }
  function L(j) {
    $[9](j);
  }
  function U(j) {
    $[10](j);
  }
  let N = { currentFilter: $[5], filter: $[6], setView: $[4], app: $[3] };
  return (
    $[0] !== void 0 && (N.currentSource = $[0]),
    $[1] !== void 0 && (N.logItems = $[1]),
    $[2] !== void 0 && (N.appdata = $[2]),
    (p = new Static({ props: N })),
    binding_callbacks.push(() => bind$1(p, "currentSource", O)),
    binding_callbacks.push(() => bind$1(p, "logItems", L)),
    binding_callbacks.push(() => bind$1(p, "appdata", U)),
    (I = new Filters({
      props: { currentFilter: $[5], currentSource: $[0], filter: $[6] },
    })),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (S = space()),
          create_component(I.$$.fragment),
          attr(r, "class", "actions");
      },
      m(j, R) {
        insert(j, r, R),
          mount_component(p, r, null),
          append(r, S),
          mount_component(I, r, null),
          (F = !0);
      },
      p(j, [R]) {
        const q = {};
        R & 32 && (q.currentFilter = j[5]),
          R & 16 && (q.setView = j[4]),
          R & 8 && (q.app = j[3]),
          !v &&
            R & 1 &&
            ((v = !0),
            (q.currentSource = j[0]),
            add_flush_callback(() => (v = !1))),
          !k &&
            R & 2 &&
            ((k = !0), (q.logItems = j[1]), add_flush_callback(() => (k = !1))),
          !x &&
            R & 4 &&
            ((x = !0), (q.appdata = j[2]), add_flush_callback(() => (x = !1))),
          p.$set(q);
        const Q = {};
        R & 32 && (Q.currentFilter = j[5]),
          R & 1 && (Q.currentSource = j[0]),
          I.$set(Q);
      },
      i(j) {
        F ||
          (transition_in(p.$$.fragment, j),
          transition_in(I.$$.fragment, j),
          (F = !0));
      },
      o(j) {
        transition_out(p.$$.fragment, j),
          transition_out(I.$$.fragment, j),
          (F = !1);
      },
      d(j) {
        j && detach(r), destroy_component(p), destroy_component(I);
      },
    }
  );
}
function instance$2F($, r, p) {
  let { app: v } = r,
    { currentSource: k } = r,
    { logItems: x } = r,
    { setView: S } = r,
    { updating: I } = r,
    { appdata: F } = r,
    O = [],
    L;
  log.subscribe((q) => {
    p(7, (I = !0)), (O = []), p(5, (L = null));
    const Q = Object.entries(q);
    for (let K = 0; K < Q.length; K++) Q[K][0] == k && O.push(Q[K][1]);
    setTimeout(() => {
      p(7, (I = !1));
    });
  });
  function U(q) {
    O.length || (O = x);
    const Q = [];
    for (let K = 0; K < O.length; K++) q == O[K].level && Q.push(O[K]);
    p(1, (x = Q)), p(5, (L = q));
  }
  function N(q) {
    (k = q), p(0, k);
  }
  function j(q) {
    (x = q), p(1, x);
  }
  function R(q) {
    (F = q), p(2, F);
  }
  return (
    ($.$$set = (q) => {
      "app" in q && p(3, (v = q.app)),
        "currentSource" in q && p(0, (k = q.currentSource)),
        "logItems" in q && p(1, (x = q.logItems)),
        "setView" in q && p(4, (S = q.setView)),
        "updating" in q && p(7, (I = q.updating)),
        "appdata" in q && p(2, (F = q.appdata));
    }),
    [k, x, F, v, S, L, U, I, N, j, R]
  );
}
class Actions extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2F, create_fragment$2X, safe_not_equal, {
        app: 3,
        currentSource: 0,
        logItems: 1,
        setView: 4,
        updating: 7,
        appdata: 2,
      });
  }
}
function create_fragment$2W($) {
  let r,
    p,
    v = $[1][$[0].level] + "",
    k,
    x,
    S,
    I,
    F = dayjs($[0].timestamp).format("HH:mm:ss.SSS") + "",
    O,
    L,
    U,
    N = $[0].msg + "",
    j;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (k = text(v)),
        (S = space()),
        (I = element("div")),
        (O = text(F)),
        (L = space()),
        (U = element("div")),
        (j = text(N)),
        attr(
          p,
          "class",
          (x = "level material-icons-round " + LogLevel[$[0].level])
        ),
        attr(I, "class", "timestamp"),
        attr(U, "class", "msg"),
        attr(r, "class", "logitem");
    },
    m(R, q) {
      insert(R, r, q),
        append(r, p),
        append(p, k),
        append(r, S),
        append(r, I),
        append(I, O),
        append(r, L),
        append(r, U),
        append(U, j);
    },
    p(R, [q]) {
      q & 1 && v !== (v = R[1][R[0].level] + "") && set_data(k, v),
        q & 1 &&
          x !== (x = "level material-icons-round " + LogLevel[R[0].level]) &&
          attr(p, "class", x),
        q & 1 &&
          F !== (F = dayjs(R[0].timestamp).format("HH:mm:ss.SSS") + "") &&
          set_data(O, F),
        q & 1 && N !== (N = R[0].msg + "") && set_data(j, N);
    },
    i: noop$1,
    o: noop$1,
    d(R) {
      R && detach(r);
    },
  };
}
function instance$2E($, r, p) {
  let { logItem: v } = r;
  const k = { 0: "info", 1: "warning", 2: "error", 3: "cancel" };
  return (
    ($.$$set = (x) => {
      "logItem" in x && p(0, (v = x.logItem));
    }),
    [v, k]
  );
}
class LogItem extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2E, create_fragment$2W, safe_not_equal, {
        logItem: 0,
      });
  }
}
function get_each_context$C($, r, p) {
  const v = $.slice();
  return (v[4] = r[p]), v;
}
function create_if_block_1$n($) {
  let r,
    p,
    v = $[1],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$C(get_each_context$C($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 2) {
        v = S[1];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$C(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$C(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_each_block$C($) {
  let r, p;
  return (
    (r = new LogItem({ props: { logItem: $[4] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 2 && (x.logItem = v[4]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$1a($) {
  let r, p, v, k, x, S;
  return {
    c() {
      (r = element("div")),
        (p = element("img")),
        (x = space()),
        (S = element("p")),
        (S.textContent = "No items found."),
        src_url_equal(p.src, (v = getAppIcon($[0]))) || attr(p, "src", v),
        attr(p, "alt", (k = $[0].info.name)),
        attr(r, "class", "noitems");
    },
    m(I, F) {
      insert(I, r, F), append(r, p), append(r, x), append(r, S);
    },
    p(I, F) {
      F & 1 &&
        !src_url_equal(p.src, (v = getAppIcon(I[0]))) &&
        attr(p, "src", v),
        F & 1 && k !== (k = I[0].info.name) && attr(p, "alt", k);
    },
    d(I) {
      I && detach(r);
    },
  };
}
function create_fragment$2V($) {
  let r,
    p,
    v,
    k = !$[2] && create_if_block_1$n($),
    x = !$[1].length && create_if_block$1a($);
  return {
    c() {
      (r = element("div")),
        k && k.c(),
        (p = space()),
        x && x.c(),
        attr(r, "class", "items"),
        toggle_class(r, "cflex", !$[1].length),
        toggle_class(r, "monospace", !!$[3].monospace);
    },
    m(S, I) {
      insert(S, r, I),
        k && k.m(r, null),
        append(r, p),
        x && x.m(r, null),
        (v = !0);
    },
    p(S, [I]) {
      S[2]
        ? k &&
          (group_outros(),
          transition_out(k, 1, 1, () => {
            k = null;
          }),
          check_outros())
        : k
        ? (k.p(S, I), I & 4 && transition_in(k, 1))
        : ((k = create_if_block_1$n(S)), k.c(), transition_in(k, 1), k.m(r, p)),
        S[1].length
          ? x && (x.d(1), (x = null))
          : x
          ? x.p(S, I)
          : ((x = create_if_block$1a(S)), x.c(), x.m(r, null)),
        (!v || I & 2) && toggle_class(r, "cflex", !S[1].length),
        (!v || I & 8) && toggle_class(r, "monospace", !!S[3].monospace);
    },
    i(S) {
      v || (transition_in(k), (v = !0));
    },
    o(S) {
      transition_out(k), (v = !1);
    },
    d(S) {
      S && detach(r), k && k.d(), x && x.d();
    },
  };
}
function instance$2D($, r, p) {
  let { app: v } = r,
    { logItems: k } = r,
    { updating: x } = r,
    { appdata: S } = r;
  return (
    ($.$$set = (I) => {
      "app" in I && p(0, (v = I.app)),
        "logItems" in I && p(1, (k = I.logItems)),
        "updating" in I && p(2, (x = I.updating)),
        "appdata" in I && p(3, (S = I.appdata));
    }),
    [v, k, x, S]
  );
}
class Items extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2D, create_fragment$2V, safe_not_equal, {
        app: 0,
        logItems: 1,
        updating: 2,
        appdata: 3,
      });
  }
}
function create_fragment$2U($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j;
  function R(X) {
    $[6](X);
  }
  function q(X) {
    $[7](X);
  }
  function Q(X) {
    $[8](X);
  }
  function K(X) {
    $[9](X);
  }
  function V(X) {
    $[10](X);
  }
  function H(X) {
    $[11](X);
  }
  let G = {};
  $[1] !== void 0 && (G.currentSource = $[1]),
    $[2] !== void 0 && (G.logItems = $[2]),
    $[3] !== void 0 && (G.setView = $[3]),
    $[5] !== void 0 && (G.updating = $[5]),
    $[4] !== void 0 && (G.appdata = $[4]),
    $[0] !== void 0 && (G.app = $[0]),
    (p = new Actions({ props: G })),
    binding_callbacks.push(() => bind$1(p, "currentSource", R)),
    binding_callbacks.push(() => bind$1(p, "logItems", q)),
    binding_callbacks.push(() => bind$1(p, "setView", Q)),
    binding_callbacks.push(() => bind$1(p, "updating", K)),
    binding_callbacks.push(() => bind$1(p, "appdata", V)),
    binding_callbacks.push(() => bind$1(p, "app", H));
  function Y(X) {
    $[12](X);
  }
  function J(X) {
    $[13](X);
  }
  let Z = { app: $[0], appdata: $[4] };
  return (
    $[2] !== void 0 && (Z.logItems = $[2]),
    $[5] !== void 0 && (Z.updating = $[5]),
    (L = new Items({ props: Z })),
    binding_callbacks.push(() => bind$1(L, "logItems", Y)),
    binding_callbacks.push(() => bind$1(L, "updating", J)),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (O = space()),
          create_component(L.$$.fragment),
          attr(r, "class", "content");
      },
      m(X, ee) {
        insert(X, r, ee),
          mount_component(p, r, null),
          append(r, O),
          mount_component(L, r, null),
          (j = !0);
      },
      p(X, [ee]) {
        const te = {};
        !v &&
          ee & 2 &&
          ((v = !0),
          (te.currentSource = X[1]),
          add_flush_callback(() => (v = !1))),
          !k &&
            ee & 4 &&
            ((k = !0),
            (te.logItems = X[2]),
            add_flush_callback(() => (k = !1))),
          !x &&
            ee & 8 &&
            ((x = !0), (te.setView = X[3]), add_flush_callback(() => (x = !1))),
          !S &&
            ee & 32 &&
            ((S = !0),
            (te.updating = X[5]),
            add_flush_callback(() => (S = !1))),
          !I &&
            ee & 16 &&
            ((I = !0), (te.appdata = X[4]), add_flush_callback(() => (I = !1))),
          !F &&
            ee & 1 &&
            ((F = !0), (te.app = X[0]), add_flush_callback(() => (F = !1))),
          p.$set(te);
        const ie = {};
        ee & 1 && (ie.app = X[0]),
          ee & 16 && (ie.appdata = X[4]),
          !U &&
            ee & 4 &&
            ((U = !0),
            (ie.logItems = X[2]),
            add_flush_callback(() => (U = !1))),
          !N &&
            ee & 32 &&
            ((N = !0),
            (ie.updating = X[5]),
            add_flush_callback(() => (N = !1))),
          L.$set(ie);
      },
      i(X) {
        j ||
          (transition_in(p.$$.fragment, X),
          transition_in(L.$$.fragment, X),
          (j = !0));
      },
      o(X) {
        transition_out(p.$$.fragment, X),
          transition_out(L.$$.fragment, X),
          (j = !1);
      },
      d(X) {
        X && detach(r), destroy_component(p), destroy_component(L);
      },
    }
  );
}
function instance$2C($, r, p) {
  let { app: v } = r,
    { currentSource: k } = r,
    { logItems: x } = r,
    { setView: S } = r,
    { appdata: I } = r,
    F = !1;
  function O(K) {
    (k = K), p(1, k);
  }
  function L(K) {
    (x = K), p(2, x);
  }
  function U(K) {
    (S = K), p(3, S);
  }
  function N(K) {
    (F = K), p(5, F);
  }
  function j(K) {
    (I = K), p(4, I);
  }
  function R(K) {
    (v = K), p(0, v);
  }
  function q(K) {
    (x = K), p(2, x);
  }
  function Q(K) {
    (F = K), p(5, F);
  }
  return (
    ($.$$set = (K) => {
      "app" in K && p(0, (v = K.app)),
        "currentSource" in K && p(1, (k = K.currentSource)),
        "logItems" in K && p(2, (x = K.logItems)),
        "setView" in K && p(3, (S = K.setView)),
        "appdata" in K && p(4, (I = K.appdata));
    }),
    [v, k, x, S, I, F, O, L, U, N, j, R, q, Q]
  );
}
let Content$3 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2C, create_fragment$2U, safe_not_equal, {
        app: 0,
        currentSource: 1,
        logItems: 2,
        setView: 3,
        appdata: 4,
      });
  }
};
function create_fragment$2T($) {
  let r,
    p,
    v = $[0][0] + "",
    k,
    x,
    S,
    I = $[0][1].length + "",
    F,
    O,
    L,
    U;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (k = text(v)),
        (x = space()),
        (S = element("div")),
        (F = text(I)),
        (O = text(" items")),
        attr(p, "class", "name"),
        attr(S, "class", "items"),
        toggle_class(r, "active", $[0][0] == $[1]);
    },
    m(N, j) {
      insert(N, r, j),
        append(r, p),
        append(p, k),
        append(r, x),
        append(r, S),
        append(S, F),
        append(S, O),
        L || ((U = listen(r, "click", $[2])), (L = !0));
    },
    p(N, [j]) {
      j & 1 && v !== (v = N[0][0] + "") && set_data(k, v),
        j & 1 && I !== (I = N[0][1].length + "") && set_data(F, I),
        j & 3 && toggle_class(r, "active", N[0][0] == N[1]);
    },
    i: noop$1,
    o: noop$1,
    d(N) {
      N && detach(r), (L = !1), U();
    },
  };
}
function instance$2B($, r, p) {
  let { category: v } = r,
    { setView: k } = r,
    { currentSource: x } = r;
  function S() {
    k && k(v[0]);
  }
  return (
    ($.$$set = (I) => {
      "category" in I && p(0, (v = I.category)),
        "setView" in I && p(3, (k = I.setView)),
        "currentSource" in I && p(1, (x = I.currentSource));
    }),
    [v, x, S, k]
  );
}
class Category extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2B, create_fragment$2T, safe_not_equal, {
        category: 0,
        setView: 3,
        currentSource: 1,
      });
  }
}
function get_each_context$B($, r, p) {
  const v = $.slice();
  return (v[6] = r[p]), (v[7] = r), (v[8] = p), v;
}
function create_each_block$B($) {
  let r, p, v, k, x;
  function S(L) {
    $[3](L);
  }
  function I(L) {
    $[4](L, $[6], $[7], $[8]);
  }
  function F(L) {
    $[5](L);
  }
  let O = {};
  return (
    $[1] !== void 0 && (O.setView = $[1]),
    $[6] !== void 0 && (O.category = $[6]),
    $[2] !== void 0 && (O.currentSource = $[2]),
    (r = new Category({ props: O })),
    binding_callbacks.push(() => bind$1(r, "setView", S)),
    binding_callbacks.push(() => bind$1(r, "category", I)),
    binding_callbacks.push(() => bind$1(r, "currentSource", F)),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(L, U) {
        mount_component(r, L, U), (x = !0);
      },
      p(L, U) {
        $ = L;
        const N = {};
        !p &&
          U & 2 &&
          ((p = !0), (N.setView = $[1]), add_flush_callback(() => (p = !1))),
          !v &&
            U & 1 &&
            ((v = !0), (N.category = $[6]), add_flush_callback(() => (v = !1))),
          !k &&
            U & 4 &&
            ((k = !0),
            (N.currentSource = $[2]),
            add_flush_callback(() => (k = !1))),
          r.$set(N);
      },
      i(L) {
        x || (transition_in(r.$$.fragment, L), (x = !0));
      },
      o(L) {
        transition_out(r.$$.fragment, L), (x = !1);
      },
      d(L) {
        destroy_component(r, L);
      },
    }
  );
}
function create_fragment$2S($) {
  let r,
    p,
    v = $[0],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$B(get_each_context$B($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      r = element("div");
      for (let S = 0; S < k.length; S += 1) k[S].c();
      attr(r, "class", "sidebar");
    },
    m(S, I) {
      insert(S, r, I);
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(r, null);
      p = !0;
    },
    p(S, [I]) {
      if (I & 7) {
        v = S[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$B(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$B(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      S && detach(r), destroy_each(k, S);
    },
  };
}
function instance$2A($, r, p) {
  let { logs: v } = r,
    { setView: k } = r,
    { currentSource: x } = r;
  function S(O) {
    (k = O), p(1, k);
  }
  function I(O, L, U, N) {
    (U[N] = O), p(0, v);
  }
  function F(O) {
    (x = O), p(2, x);
  }
  return (
    ($.$$set = (O) => {
      "logs" in O && p(0, (v = O.logs)),
        "setView" in O && p(1, (k = O.setView)),
        "currentSource" in O && p(2, (x = O.currentSource));
    }),
    [v, k, x, S, I, F]
  );
}
let Sidebar$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2A, create_fragment$2S, safe_not_equal, {
        logs: 0,
        setView: 1,
        currentSource: 2,
      });
  }
};
function create_if_block$19($) {
  let r, p, v, k, x, S, I, F, O;
  function L(K) {
    $[6](K);
  }
  function U(K) {
    $[7](K);
  }
  let N = { setView: $[5] };
  $[4] !== void 0 && (N.currentSource = $[4]),
    $[2] !== void 0 && (N.logs = $[2]),
    (r = new Sidebar$1({ props: N })),
    binding_callbacks.push(() => bind$1(r, "currentSource", L)),
    binding_callbacks.push(() => bind$1(r, "logs", U));
  function j(K) {
    $[8](K);
  }
  function R(K) {
    $[9](K);
  }
  function q(K) {
    $[10](K);
  }
  let Q = { setView: $[5], app: $[0] };
  return (
    $[4] !== void 0 && (Q.currentSource = $[4]),
    $[3] !== void 0 && (Q.logItems = $[3]),
    $[1] !== void 0 && (Q.appdata = $[1]),
    (x = new Content$3({ props: Q })),
    binding_callbacks.push(() => bind$1(x, "currentSource", j)),
    binding_callbacks.push(() => bind$1(x, "logItems", R)),
    binding_callbacks.push(() => bind$1(x, "appdata", q)),
    {
      c() {
        create_component(r.$$.fragment),
          (k = space()),
          create_component(x.$$.fragment);
      },
      m(K, V) {
        mount_component(r, K, V),
          insert(K, k, V),
          mount_component(x, K, V),
          (O = !0);
      },
      p(K, V) {
        const H = {};
        !p &&
          V & 16 &&
          ((p = !0),
          (H.currentSource = K[4]),
          add_flush_callback(() => (p = !1))),
          !v &&
            V & 4 &&
            ((v = !0), (H.logs = K[2]), add_flush_callback(() => (v = !1))),
          r.$set(H);
        const G = {};
        V & 1 && (G.app = K[0]),
          !S &&
            V & 16 &&
            ((S = !0),
            (G.currentSource = K[4]),
            add_flush_callback(() => (S = !1))),
          !I &&
            V & 8 &&
            ((I = !0), (G.logItems = K[3]), add_flush_callback(() => (I = !1))),
          !F &&
            V & 2 &&
            ((F = !0), (G.appdata = K[1]), add_flush_callback(() => (F = !1))),
          x.$set(G);
      },
      i(K) {
        O ||
          (transition_in(r.$$.fragment, K),
          transition_in(x.$$.fragment, K),
          (O = !0));
      },
      o(K) {
        transition_out(r.$$.fragment, K),
          transition_out(x.$$.fragment, K),
          (O = !1);
      },
      d(K) {
        destroy_component(r, K), K && detach(k), destroy_component(x, K);
      },
    }
  );
}
function create_fragment$2R($) {
  let r,
    p,
    v = $[0] && create_if_block$19($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[0]
        ? v
          ? (v.p(k, x), x & 1 && transition_in(v, 1))
          : ((v = create_if_block$19(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$2z($, r, p) {
  let v;
  component_subscribe($, log, (q) => p(11, (v = q)));
  let k = [],
    x = [],
    S = "",
    { app: I } = r,
    { appdata: F } = r;
  function O(q) {
    Log({
      source: "apps/Logger: setView",
      msg: `Setting source to "${q}"`,
      level: LogLevel.info,
    });
    for (let Q = 0; Q < k.length; Q++) k[Q][0] == q && p(3, (x = k[Q][1]));
    x.length ||
      Log({
        source: "apps/Logger: setView",
        msg: `Source "${q}" contains no items or could not be found.`,
        level: LogLevel.info,
      }),
      p(4, (S = q));
  }
  log.subscribe(() => {
    p(2, (k = Object.entries(collectLogsBySource()))),
      p(0, (I.info.titleSuffix = ` - ${v.length} items`), I);
  });
  function L(q) {
    (S = q), p(4, S);
  }
  function U(q) {
    (k = q), p(2, k);
  }
  function N(q) {
    (S = q), p(4, S);
  }
  function j(q) {
    (x = q), p(3, x);
  }
  function R(q) {
    (F = q), p(1, F);
  }
  return (
    ($.$$set = (q) => {
      "app" in q && p(0, (I = q.app)), "appdata" in q && p(1, (F = q.appdata));
    }),
    [I, F, k, x, S, O, L, U, N, j, R]
  );
}
class Logger extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2z, create_fragment$2R, safe_not_equal, {
        app: 0,
        appdata: 1,
      });
  }
}
const LoggerApp = {
  info: {
    name: "System Logger",
    description: "All the ArcOS logs in one place",
    builtin: !0,
    version: "1.0.0",
    author: "ArcOS Team",
    icon: logo$5,
  },
  size: { w: 900, h: 600 },
  pos: { x: 30, y: 40 },
  minSize: { w: 900, h: 600 },
  maxSize: { w: 901, h: 601 },
  controls: { min: !0, max: !0, cls: !0 },
  state: {
    headless: !1,
    resizable: !1,
    windowState: { min: !1, max: !1, fll: !1 },
  },
  content: Logger,
  glass: !0,
};
function supressWarnings() {
  const $ = console.warn;
  (console.warn = (r) => {
    r.includes("unknown prop") || r.includes("unexpected slot") || $(r);
  }),
    onMount(() => {
      console.warn = $;
    });
}
function get_each_context_5($, r, p) {
  const v = $.slice();
  return (v[18] = r[p]), v;
}
function get_each_context_4($, r, p) {
  const v = $.slice();
  return (v[18] = r[p]), v;
}
function get_each_context_1$5($, r, p) {
  const v = $.slice();
  return (v[10] = r[p]), v;
}
function get_each_context_2$1($, r, p) {
  const v = $.slice();
  return (v[13] = r[p]), (v[15] = p), v;
}
function get_each_context_3($, r, p) {
  const v = $.slice();
  return (v[16] = r[p]), (v[15] = p), v;
}
function get_each_context$A($, r, p) {
  const v = $.slice();
  return (v[7] = r[p]), v;
}
function create_if_block_1$m($) {
  let r, p, v, k;
  const x = [create_if_block_2$4, create_if_block_3$2, create_else_block_1],
    S = [];
  function I(F, O) {
    return F[0] === "table" ? 0 : F[0] === "list" ? 1 : 2;
  }
  return (
    (r = I($)),
    (p = S[r] = x[r]($)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        S[r].m(F, O), insert(F, v, O), (k = !0);
      },
      p(F, O) {
        let L = r;
        (r = I(F)),
          r === L
            ? S[r].p(F, O)
            : (group_outros(),
              transition_out(S[L], 1, 1, () => {
                S[L] = null;
              }),
              check_outros(),
              (p = S[r]),
              p ? p.p(F, O) : ((p = S[r] = x[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        k || (transition_in(p), (k = !0));
      },
      o(F) {
        transition_out(p), (k = !1);
      },
      d(F) {
        S[r].d(F), F && detach(v);
      },
    }
  );
}
function create_if_block$18($) {
  let r,
    p,
    v = $[1],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$A(get_each_context$A($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 34) {
        v = S[1];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$A(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$A(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_else_block_1($) {
  let r, p, v;
  const k = [$[6]];
  var x = $[5][$[0]];
  function S(I) {
    let F = {
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx: I },
    };
    for (let O = 0; O < k.length; O += 1) F = assign(F, k[O]);
    return { props: F };
  }
  return (
    x && (r = construct_svelte_component(x, S($))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(I, F) {
        r && mount_component(r, I, F), insert(I, p, F), (v = !0);
      },
      p(I, F) {
        const O = F & 64 ? get_spread_update(k, [get_spread_object(I[6])]) : {};
        if (
          (F & 8388706 && (O.$$scope = { dirty: F, ctx: I }),
          F & 33 && x !== (x = I[5][I[0]]))
        ) {
          if (r) {
            group_outros();
            const L = r;
            transition_out(L.$$.fragment, 1, 0, () => {
              destroy_component(L, 1);
            }),
              check_outros();
          }
          x
            ? ((r = construct_svelte_component(x, S(I))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else x && r.$set(O);
      },
      i(I) {
        v || (r && transition_in(r.$$.fragment, I), (v = !0));
      },
      o(I) {
        r && transition_out(r.$$.fragment, I), (v = !1);
      },
      d(I) {
        I && detach(p), r && destroy_component(r, I);
      },
    }
  );
}
function create_if_block_3$2($) {
  let r, p, v, k;
  const x = [create_if_block_4$1, create_else_block$o],
    S = [];
  function I(F, O) {
    return F[4] ? 0 : 1;
  }
  return (
    (r = I($)),
    (p = S[r] = x[r]($)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        S[r].m(F, O), insert(F, v, O), (k = !0);
      },
      p(F, O) {
        let L = r;
        (r = I(F)),
          r === L
            ? S[r].p(F, O)
            : (group_outros(),
              transition_out(S[L], 1, 1, () => {
                S[L] = null;
              }),
              check_outros(),
              (p = S[r]),
              p ? p.p(F, O) : ((p = S[r] = x[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        k || (transition_in(p), (k = !0));
      },
      o(F) {
        transition_out(p), (k = !1);
      },
      d(F) {
        S[r].d(F), F && detach(v);
      },
    }
  );
}
function create_if_block_2$4($) {
  let r, p, v;
  var k = $[5].table;
  function x(S) {
    return {
      props: {
        $$slots: { default: [create_default_slot$a] },
        $$scope: { ctx: S },
      },
    };
  }
  return (
    k && (r = construct_svelte_component(k, x($))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(S, I) {
        r && mount_component(r, S, I), insert(S, p, I), (v = !0);
      },
      p(S, I) {
        const F = {};
        if (
          (I & 8388716 && (F.$$scope = { dirty: I, ctx: S }),
          I & 32 && k !== (k = S[5].table))
        ) {
          if (r) {
            group_outros();
            const O = r;
            transition_out(O.$$.fragment, 1, 0, () => {
              destroy_component(O, 1);
            }),
              check_outros();
          }
          k
            ? ((r = construct_svelte_component(k, x(S))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else k && r.$set(F);
      },
      i(S) {
        v || (r && transition_in(r.$$.fragment, S), (v = !0));
      },
      o(S) {
        r && transition_out(r.$$.fragment, S), (v = !1);
      },
      d(S) {
        S && detach(p), r && destroy_component(r, S);
      },
    }
  );
}
function create_else_block_2($) {
  let r = $[6].raw + "",
    p;
  return {
    c() {
      p = text(r);
    },
    m(v, k) {
      insert(v, p, k);
    },
    p(v, k) {
      k & 64 && r !== (r = v[6].raw + "") && set_data(p, r);
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      v && detach(p);
    },
  };
}
function create_if_block_5$1($) {
  let r, p;
  return (
    (r = new Parser$1({ props: { tokens: $[1], renderers: $[5] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 2 && (x.tokens = v[1]), k & 32 && (x.renderers = v[5]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_default_slot_11($) {
  let r, p, v, k;
  const x = [create_if_block_5$1, create_else_block_2],
    S = [];
  function I(F, O) {
    return F[1] ? 0 : 1;
  }
  return (
    (r = I($)),
    (p = S[r] = x[r]($)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        S[r].m(F, O), insert(F, v, O), (k = !0);
      },
      p(F, O) {
        let L = r;
        (r = I(F)),
          r === L
            ? S[r].p(F, O)
            : (group_outros(),
              transition_out(S[L], 1, 1, () => {
                S[L] = null;
              }),
              check_outros(),
              (p = S[r]),
              p ? p.p(F, O) : ((p = S[r] = x[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        k || (transition_in(p), (k = !0));
      },
      o(F) {
        transition_out(p), (k = !1);
      },
      d(F) {
        S[r].d(F), F && detach(v);
      },
    }
  );
}
function create_else_block$o($) {
  let r, p, v;
  const k = [{ ordered: $[4] }, $[6]];
  var x = $[5].list;
  function S(I) {
    let F = {
      $$slots: { default: [create_default_slot_9$1] },
      $$scope: { ctx: I },
    };
    for (let O = 0; O < k.length; O += 1) F = assign(F, k[O]);
    return { props: F };
  }
  return (
    x && (r = construct_svelte_component(x, S($))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(I, F) {
        r && mount_component(r, I, F), insert(I, p, F), (v = !0);
      },
      p(I, F) {
        const O =
          F & 80
            ? get_spread_update(k, [
                F & 16 && { ordered: I[4] },
                F & 64 && get_spread_object(I[6]),
              ])
            : {};
        if (
          (F & 8388704 && (O.$$scope = { dirty: F, ctx: I }),
          F & 32 && x !== (x = I[5].list))
        ) {
          if (r) {
            group_outros();
            const L = r;
            transition_out(L.$$.fragment, 1, 0, () => {
              destroy_component(L, 1);
            }),
              check_outros();
          }
          x
            ? ((r = construct_svelte_component(x, S(I))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else x && r.$set(O);
      },
      i(I) {
        v || (r && transition_in(r.$$.fragment, I), (v = !0));
      },
      o(I) {
        r && transition_out(r.$$.fragment, I), (v = !1);
      },
      d(I) {
        I && detach(p), r && destroy_component(r, I);
      },
    }
  );
}
function create_if_block_4$1($) {
  let r, p, v;
  const k = [{ ordered: $[4] }, $[6]];
  var x = $[5].list;
  function S(I) {
    let F = {
      $$slots: { default: [create_default_slot_7$1] },
      $$scope: { ctx: I },
    };
    for (let O = 0; O < k.length; O += 1) F = assign(F, k[O]);
    return { props: F };
  }
  return (
    x && (r = construct_svelte_component(x, S($))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(I, F) {
        r && mount_component(r, I, F), insert(I, p, F), (v = !0);
      },
      p(I, F) {
        const O =
          F & 80
            ? get_spread_update(k, [
                F & 16 && { ordered: I[4] },
                F & 64 && get_spread_object(I[6]),
              ])
            : {};
        if (
          (F & 8388704 && (O.$$scope = { dirty: F, ctx: I }),
          F & 32 && x !== (x = I[5].list))
        ) {
          if (r) {
            group_outros();
            const L = r;
            transition_out(L.$$.fragment, 1, 0, () => {
              destroy_component(L, 1);
            }),
              check_outros();
          }
          x
            ? ((r = construct_svelte_component(x, S(I))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else x && r.$set(O);
      },
      i(I) {
        v || (r && transition_in(r.$$.fragment, I), (v = !0));
      },
      o(I) {
        r && transition_out(r.$$.fragment, I), (v = !1);
      },
      d(I) {
        I && detach(p), r && destroy_component(r, I);
      },
    }
  );
}
function create_default_slot_10($) {
  let r, p, v;
  return (
    (r = new Parser$1({ props: { tokens: $[18].tokens, renderers: $[5] } })),
    {
      c() {
        create_component(r.$$.fragment), (p = space());
      },
      m(k, x) {
        mount_component(r, k, x), insert(k, p, x), (v = !0);
      },
      p(k, x) {
        const S = {};
        x & 64 && (S.tokens = k[18].tokens),
          x & 32 && (S.renderers = k[5]),
          r.$set(S);
      },
      i(k) {
        v || (transition_in(r.$$.fragment, k), (v = !0));
      },
      o(k) {
        transition_out(r.$$.fragment, k), (v = !1);
      },
      d(k) {
        destroy_component(r, k), k && detach(p);
      },
    }
  );
}
function create_each_block_5($) {
  let r, p, v;
  const k = [$[18]];
  var x = $[5].unorderedlistitem || $[5].listitem;
  function S(I) {
    let F = {
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx: I },
    };
    for (let O = 0; O < k.length; O += 1) F = assign(F, k[O]);
    return { props: F };
  }
  return (
    x && (r = construct_svelte_component(x, S($))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(I, F) {
        r && mount_component(r, I, F), insert(I, p, F), (v = !0);
      },
      p(I, F) {
        const O =
          F & 64 ? get_spread_update(k, [get_spread_object(I[18])]) : {};
        if (
          (F & 8388704 && (O.$$scope = { dirty: F, ctx: I }),
          F & 32 && x !== (x = I[5].unorderedlistitem || I[5].listitem))
        ) {
          if (r) {
            group_outros();
            const L = r;
            transition_out(L.$$.fragment, 1, 0, () => {
              destroy_component(L, 1);
            }),
              check_outros();
          }
          x
            ? ((r = construct_svelte_component(x, S(I))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else x && r.$set(O);
      },
      i(I) {
        v || (r && transition_in(r.$$.fragment, I), (v = !0));
      },
      o(I) {
        r && transition_out(r.$$.fragment, I), (v = !1);
      },
      d(I) {
        I && detach(p), r && destroy_component(r, I);
      },
    }
  );
}
function create_default_slot_9$1($) {
  let r,
    p,
    v = $[6].items,
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block_5(get_each_context_5($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 96) {
        v = S[6].items;
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_5(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block_5(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_default_slot_8$1($) {
  let r, p, v;
  return (
    (r = new Parser$1({ props: { tokens: $[18].tokens, renderers: $[5] } })),
    {
      c() {
        create_component(r.$$.fragment), (p = space());
      },
      m(k, x) {
        mount_component(r, k, x), insert(k, p, x), (v = !0);
      },
      p(k, x) {
        const S = {};
        x & 64 && (S.tokens = k[18].tokens),
          x & 32 && (S.renderers = k[5]),
          r.$set(S);
      },
      i(k) {
        v || (transition_in(r.$$.fragment, k), (v = !0));
      },
      o(k) {
        transition_out(r.$$.fragment, k), (v = !1);
      },
      d(k) {
        destroy_component(r, k), k && detach(p);
      },
    }
  );
}
function create_each_block_4($) {
  let r, p, v;
  const k = [$[18]];
  var x = $[5].orderedlistitem || $[5].listitem;
  function S(I) {
    let F = {
      $$slots: { default: [create_default_slot_8$1] },
      $$scope: { ctx: I },
    };
    for (let O = 0; O < k.length; O += 1) F = assign(F, k[O]);
    return { props: F };
  }
  return (
    x && (r = construct_svelte_component(x, S($))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(I, F) {
        r && mount_component(r, I, F), insert(I, p, F), (v = !0);
      },
      p(I, F) {
        const O =
          F & 64 ? get_spread_update(k, [get_spread_object(I[18])]) : {};
        if (
          (F & 8388704 && (O.$$scope = { dirty: F, ctx: I }),
          F & 32 && x !== (x = I[5].orderedlistitem || I[5].listitem))
        ) {
          if (r) {
            group_outros();
            const L = r;
            transition_out(L.$$.fragment, 1, 0, () => {
              destroy_component(L, 1);
            }),
              check_outros();
          }
          x
            ? ((r = construct_svelte_component(x, S(I))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else x && r.$set(O);
      },
      i(I) {
        v || (r && transition_in(r.$$.fragment, I), (v = !0));
      },
      o(I) {
        r && transition_out(r.$$.fragment, I), (v = !1);
      },
      d(I) {
        I && detach(p), r && destroy_component(r, I);
      },
    }
  );
}
function create_default_slot_7$1($) {
  let r,
    p,
    v = $[6].items,
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block_4(get_each_context_4($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 96) {
        v = S[6].items;
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_4(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block_4(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_default_slot_6$2($) {
  let r, p, v;
  return (
    (r = new Parser$1({ props: { tokens: $[16].tokens, renderers: $[5] } })),
    {
      c() {
        create_component(r.$$.fragment), (p = space());
      },
      m(k, x) {
        mount_component(r, k, x), insert(k, p, x), (v = !0);
      },
      p(k, x) {
        const S = {};
        x & 4 && (S.tokens = k[16].tokens),
          x & 32 && (S.renderers = k[5]),
          r.$set(S);
      },
      i(k) {
        v || (transition_in(r.$$.fragment, k), (v = !0));
      },
      o(k) {
        transition_out(r.$$.fragment, k), (v = !1);
      },
      d(k) {
        destroy_component(r, k), k && detach(p);
      },
    }
  );
}
function create_each_block_3($) {
  let r, p, v;
  var k = $[5].tablecell;
  function x(S) {
    return {
      props: {
        header: !0,
        align: S[6].align[S[15]] || "center",
        $$slots: { default: [create_default_slot_6$2] },
        $$scope: { ctx: S },
      },
    };
  }
  return (
    k && (r = construct_svelte_component(k, x($))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(S, I) {
        r && mount_component(r, S, I), insert(S, p, I), (v = !0);
      },
      p(S, I) {
        const F = {};
        if (
          (I & 64 && (F.align = S[6].align[S[15]] || "center"),
          I & 8388644 && (F.$$scope = { dirty: I, ctx: S }),
          I & 32 && k !== (k = S[5].tablecell))
        ) {
          if (r) {
            group_outros();
            const O = r;
            transition_out(O.$$.fragment, 1, 0, () => {
              destroy_component(O, 1);
            }),
              check_outros();
          }
          k
            ? ((r = construct_svelte_component(k, x(S))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else k && r.$set(F);
      },
      i(S) {
        v || (r && transition_in(r.$$.fragment, S), (v = !0));
      },
      o(S) {
        r && transition_out(r.$$.fragment, S), (v = !1);
      },
      d(S) {
        S && detach(p), r && destroy_component(r, S);
      },
    }
  );
}
function create_default_slot_5$2($) {
  let r,
    p,
    v = $[2],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block_3(get_each_context_3($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 100) {
        v = S[2];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_3(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block_3(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_default_slot_4$2($) {
  let r, p, v;
  var k = $[5].tablerow;
  function x(S) {
    return {
      props: {
        $$slots: { default: [create_default_slot_5$2] },
        $$scope: { ctx: S },
      },
    };
  }
  return (
    k && (r = construct_svelte_component(k, x($))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(S, I) {
        r && mount_component(r, S, I), insert(S, p, I), (v = !0);
      },
      p(S, I) {
        const F = {};
        if (
          (I & 8388708 && (F.$$scope = { dirty: I, ctx: S }),
          I & 32 && k !== (k = S[5].tablerow))
        ) {
          if (r) {
            group_outros();
            const O = r;
            transition_out(O.$$.fragment, 1, 0, () => {
              destroy_component(O, 1);
            }),
              check_outros();
          }
          k
            ? ((r = construct_svelte_component(k, x(S))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else k && r.$set(F);
      },
      i(S) {
        v || (r && transition_in(r.$$.fragment, S), (v = !0));
      },
      o(S) {
        r && transition_out(r.$$.fragment, S), (v = !1);
      },
      d(S) {
        S && detach(p), r && destroy_component(r, S);
      },
    }
  );
}
function create_default_slot_3$2($) {
  let r, p;
  return (
    (r = new Parser$1({ props: { tokens: $[13].tokens, renderers: $[5] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 8 && (x.tokens = v[13].tokens),
          k & 32 && (x.renderers = v[5]),
          r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block_2$1($) {
  let r, p, v;
  var k = $[5].tablecell;
  function x(S) {
    return {
      props: {
        header: !1,
        align: S[6].align[S[15]] || "center",
        $$slots: { default: [create_default_slot_3$2] },
        $$scope: { ctx: S },
      },
    };
  }
  return (
    k && (r = construct_svelte_component(k, x($))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(S, I) {
        r && mount_component(r, S, I), insert(S, p, I), (v = !0);
      },
      p(S, I) {
        const F = {};
        if (
          (I & 64 && (F.align = S[6].align[S[15]] || "center"),
          I & 8388648 && (F.$$scope = { dirty: I, ctx: S }),
          I & 32 && k !== (k = S[5].tablecell))
        ) {
          if (r) {
            group_outros();
            const O = r;
            transition_out(O.$$.fragment, 1, 0, () => {
              destroy_component(O, 1);
            }),
              check_outros();
          }
          k
            ? ((r = construct_svelte_component(k, x(S))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else k && r.$set(F);
      },
      i(S) {
        v || (r && transition_in(r.$$.fragment, S), (v = !0));
      },
      o(S) {
        r && transition_out(r.$$.fragment, S), (v = !1);
      },
      d(S) {
        S && detach(p), r && destroy_component(r, S);
      },
    }
  );
}
function create_default_slot_2$4($) {
  let r,
    p,
    v = $[10],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block_2$1(get_each_context_2$1($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = space();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 104) {
        v = S[10];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_2$1(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block_2$1(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_each_block_1$5($) {
  let r, p, v;
  var k = $[5].tablerow;
  function x(S) {
    return {
      props: {
        $$slots: { default: [create_default_slot_2$4] },
        $$scope: { ctx: S },
      },
    };
  }
  return (
    k && (r = construct_svelte_component(k, x($))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(S, I) {
        r && mount_component(r, S, I), insert(S, p, I), (v = !0);
      },
      p(S, I) {
        const F = {};
        if (
          (I & 8388712 && (F.$$scope = { dirty: I, ctx: S }),
          I & 32 && k !== (k = S[5].tablerow))
        ) {
          if (r) {
            group_outros();
            const O = r;
            transition_out(O.$$.fragment, 1, 0, () => {
              destroy_component(O, 1);
            }),
              check_outros();
          }
          k
            ? ((r = construct_svelte_component(k, x(S))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else k && r.$set(F);
      },
      i(S) {
        v || (r && transition_in(r.$$.fragment, S), (v = !0));
      },
      o(S) {
        r && transition_out(r.$$.fragment, S), (v = !1);
      },
      d(S) {
        S && detach(p), r && destroy_component(r, S);
      },
    }
  );
}
function create_default_slot_1$5($) {
  let r,
    p,
    v = $[3],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block_1$5(get_each_context_1$5($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 104) {
        v = S[3];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_1$5(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block_1$5(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_default_slot$a($) {
  let r, p, v, k, x;
  var S = $[5].tablehead;
  function I(L) {
    return {
      props: {
        $$slots: { default: [create_default_slot_4$2] },
        $$scope: { ctx: L },
      },
    };
  }
  S && (r = construct_svelte_component(S, I($)));
  var F = $[5].tablebody;
  function O(L) {
    return {
      props: {
        $$slots: { default: [create_default_slot_1$5] },
        $$scope: { ctx: L },
      },
    };
  }
  return (
    F && (v = construct_svelte_component(F, O($))),
    {
      c() {
        r && create_component(r.$$.fragment),
          (p = space()),
          v && create_component(v.$$.fragment),
          (k = empty());
      },
      m(L, U) {
        r && mount_component(r, L, U),
          insert(L, p, U),
          v && mount_component(v, L, U),
          insert(L, k, U),
          (x = !0);
      },
      p(L, U) {
        const N = {};
        if (
          (U & 8388708 && (N.$$scope = { dirty: U, ctx: L }),
          U & 32 && S !== (S = L[5].tablehead))
        ) {
          if (r) {
            group_outros();
            const R = r;
            transition_out(R.$$.fragment, 1, 0, () => {
              destroy_component(R, 1);
            }),
              check_outros();
          }
          S
            ? ((r = construct_svelte_component(S, I(L))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else S && r.$set(N);
        const j = {};
        if (
          (U & 8388712 && (j.$$scope = { dirty: U, ctx: L }),
          U & 32 && F !== (F = L[5].tablebody))
        ) {
          if (v) {
            group_outros();
            const R = v;
            transition_out(R.$$.fragment, 1, 0, () => {
              destroy_component(R, 1);
            }),
              check_outros();
          }
          F
            ? ((v = construct_svelte_component(F, O(L))),
              create_component(v.$$.fragment),
              transition_in(v.$$.fragment, 1),
              mount_component(v, k.parentNode, k))
            : (v = null);
        } else F && v.$set(j);
      },
      i(L) {
        x ||
          (r && transition_in(r.$$.fragment, L),
          v && transition_in(v.$$.fragment, L),
          (x = !0));
      },
      o(L) {
        r && transition_out(r.$$.fragment, L),
          v && transition_out(v.$$.fragment, L),
          (x = !1);
      },
      d(L) {
        r && destroy_component(r, L),
          L && detach(p),
          L && detach(k),
          v && destroy_component(v, L);
      },
    }
  );
}
function create_each_block$A($) {
  let r, p;
  const v = [$[7], { renderers: $[5] }];
  let k = {};
  for (let x = 0; x < v.length; x += 1) k = assign(k, v[x]);
  return (
    (r = new Parser$1({ props: k })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(x, S) {
        mount_component(r, x, S), (p = !0);
      },
      p(x, S) {
        const I =
          S & 34
            ? get_spread_update(v, [
                S & 2 && get_spread_object(x[7]),
                S & 32 && { renderers: x[5] },
              ])
            : {};
        r.$set(I);
      },
      i(x) {
        p || (transition_in(r.$$.fragment, x), (p = !0));
      },
      o(x) {
        transition_out(r.$$.fragment, x), (p = !1);
      },
      d(x) {
        destroy_component(r, x);
      },
    }
  );
}
function create_fragment$2Q($) {
  let r, p, v, k;
  const x = [create_if_block$18, create_if_block_1$m],
    S = [];
  function I(F, O) {
    return F[0] ? (F[5][F[0]] ? 1 : -1) : 0;
  }
  return (
    ~(r = I($)) && (p = S[r] = x[r]($)),
    {
      c() {
        p && p.c(), (v = empty());
      },
      m(F, O) {
        ~r && S[r].m(F, O), insert(F, v, O), (k = !0);
      },
      p(F, [O]) {
        let L = r;
        (r = I(F)),
          r === L
            ? ~r && S[r].p(F, O)
            : (p &&
                (group_outros(),
                transition_out(S[L], 1, 1, () => {
                  S[L] = null;
                }),
                check_outros()),
              ~r
                ? ((p = S[r]),
                  p ? p.p(F, O) : ((p = S[r] = x[r](F)), p.c()),
                  transition_in(p, 1),
                  p.m(v.parentNode, v))
                : (p = null));
      },
      i(F) {
        k || (transition_in(p), (k = !0));
      },
      o(F) {
        transition_out(p), (k = !1);
      },
      d(F) {
        ~r && S[r].d(F), F && detach(v);
      },
    }
  );
}
function instance$2y($, r, p) {
  const v = ["type", "tokens", "header", "rows", "ordered", "renderers"];
  let k = compute_rest_props(r, v),
    { type: x = void 0 } = r,
    { tokens: S = void 0 } = r,
    { header: I = void 0 } = r,
    { rows: F = void 0 } = r,
    { ordered: O = !1 } = r,
    { renderers: L } = r;
  return (
    supressWarnings(),
    ($.$$set = (U) => {
      (r = assign(assign({}, r), exclude_internal_props(U))),
        p(6, (k = compute_rest_props(r, v))),
        "type" in U && p(0, (x = U.type)),
        "tokens" in U && p(1, (S = U.tokens)),
        "header" in U && p(2, (I = U.header)),
        "rows" in U && p(3, (F = U.rows)),
        "ordered" in U && p(4, (O = U.ordered)),
        "renderers" in U && p(5, (L = U.renderers));
    }),
    [x, S, I, F, O, L, k]
  );
}
let Parser$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2y, create_fragment$2Q, safe_not_equal, {
        type: 0,
        tokens: 1,
        header: 2,
        rows: 3,
        ordered: 4,
        renderers: 5,
      });
  }
};
function getDefaults() {
  return {
    async: !1,
    baseUrl: null,
    breaks: !1,
    extensions: null,
    gfm: !0,
    headerIds: !0,
    headerPrefix: "",
    highlight: null,
    langPrefix: "language-",
    mangle: !0,
    pedantic: !1,
    renderer: null,
    sanitize: !1,
    sanitizer: null,
    silent: !1,
    smartypants: !1,
    tokenizer: null,
    walkTokens: null,
    xhtml: !1,
  };
}
let defaults = getDefaults();
function changeDefaults($) {
  defaults = $;
}
const escapeTest = /[&<>"']/,
  escapeReplace = new RegExp(escapeTest.source, "g"),
  escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
  escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g"),
  escapeReplacements = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
  },
  getEscapeReplacement = ($) => escapeReplacements[$];
function escape($, r) {
  if (r) {
    if (escapeTest.test($))
      return $.replace(escapeReplace, getEscapeReplacement);
  } else if (escapeTestNoEncode.test($))
    return $.replace(escapeReplaceNoEncode, getEscapeReplacement);
  return $;
}
const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;
function unescape$1($) {
  return $.replace(
    unescapeTest,
    (r, p) => (
      (p = p.toLowerCase()),
      p === "colon"
        ? ":"
        : p.charAt(0) === "#"
        ? p.charAt(1) === "x"
          ? String.fromCharCode(parseInt(p.substring(2), 16))
          : String.fromCharCode(+p.substring(1))
        : ""
    )
  );
}
const caret = /(^|[^\[])\^/g;
function edit($, r) {
  ($ = typeof $ == "string" ? $ : $.source), (r = r || "");
  const p = {
    replace: (v, k) => (
      (k = k.source || k),
      (k = k.replace(caret, "$1")),
      ($ = $.replace(v, k)),
      p
    ),
    getRegex: () => new RegExp($, r),
  };
  return p;
}
const nonWordAndColonTest = /[^\w:]/g,
  originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl($, r, p) {
  if ($) {
    let v;
    try {
      v = decodeURIComponent(unescape$1(p))
        .replace(nonWordAndColonTest, "")
        .toLowerCase();
    } catch {
      return null;
    }
    if (
      v.indexOf("javascript:") === 0 ||
      v.indexOf("vbscript:") === 0 ||
      v.indexOf("data:") === 0
    )
      return null;
  }
  r && !originIndependentUrl.test(p) && (p = resolveUrl(r, p));
  try {
    p = encodeURI(p).replace(/%25/g, "%");
  } catch {
    return null;
  }
  return p;
}
const baseUrls = {},
  justDomain = /^[^:]+:\/*[^/]*$/,
  protocol = /^([^:]+:)[\s\S]*$/,
  domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl($, r) {
  baseUrls[" " + $] ||
    (justDomain.test($)
      ? (baseUrls[" " + $] = $ + "/")
      : (baseUrls[" " + $] = rtrim($, "/", !0))),
    ($ = baseUrls[" " + $]);
  const p = $.indexOf(":") === -1;
  return r.substring(0, 2) === "//"
    ? p
      ? r
      : $.replace(protocol, "$1") + r
    : r.charAt(0) === "/"
    ? p
      ? r
      : $.replace(domain, "$1") + r
    : $ + r;
}
const noopTest = { exec: function $() {} };
function merge($) {
  let r = 1,
    p,
    v;
  for (; r < arguments.length; r++) {
    p = arguments[r];
    for (v in p) Object.prototype.hasOwnProperty.call(p, v) && ($[v] = p[v]);
  }
  return $;
}
function splitCells($, r) {
  const p = $.replace(/\|/g, (x, S, I) => {
      let F = !1,
        O = S;
      for (; --O >= 0 && I[O] === "\\"; ) F = !F;
      return F ? "|" : " |";
    }),
    v = p.split(/ \|/);
  let k = 0;
  if (
    (v[0].trim() || v.shift(),
    v.length > 0 && !v[v.length - 1].trim() && v.pop(),
    v.length > r)
  )
    v.splice(r);
  else for (; v.length < r; ) v.push("");
  for (; k < v.length; k++) v[k] = v[k].trim().replace(/\\\|/g, "|");
  return v;
}
function rtrim($, r, p) {
  const v = $.length;
  if (v === 0) return "";
  let k = 0;
  for (; k < v; ) {
    const x = $.charAt(v - k - 1);
    if (x === r && !p) k++;
    else if (x !== r && p) k++;
    else break;
  }
  return $.slice(0, v - k);
}
function findClosingBracket($, r) {
  if ($.indexOf(r[1]) === -1) return -1;
  const p = $.length;
  let v = 0,
    k = 0;
  for (; k < p; k++)
    if ($[k] === "\\") k++;
    else if ($[k] === r[0]) v++;
    else if ($[k] === r[1] && (v--, v < 0)) return k;
  return -1;
}
function checkSanitizeDeprecation($) {
  $ &&
    $.sanitize &&
    !$.silent &&
    console.warn(
      "marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options"
    );
}
function repeatString($, r) {
  if (r < 1) return "";
  let p = "";
  for (; r > 1; ) r & 1 && (p += $), (r >>= 1), ($ += $);
  return p + $;
}
function outputLink($, r, p, v) {
  const k = r.href,
    x = r.title ? escape(r.title) : null,
    S = $[1].replace(/\\([\[\]])/g, "$1");
  if ($[0].charAt(0) !== "!") {
    v.state.inLink = !0;
    const I = {
      type: "link",
      raw: p,
      href: k,
      title: x,
      text: S,
      tokens: v.inlineTokens(S),
    };
    return (v.state.inLink = !1), I;
  }
  return { type: "image", raw: p, href: k, title: x, text: escape(S) };
}
function indentCodeCompensation($, r) {
  const p = $.match(/^(\s+)(?:```)/);
  if (p === null) return r;
  const v = p[1];
  return r
    .split(
      `
`
    )
    .map((k) => {
      const x = k.match(/^\s+/);
      if (x === null) return k;
      const [S] = x;
      return S.length >= v.length ? k.slice(v.length) : k;
    }).join(`
`);
}
class Tokenizer {
  constructor(r) {
    this.options = r || defaults;
  }
  space(r) {
    const p = this.rules.block.newline.exec(r);
    if (p && p[0].length > 0) return { type: "space", raw: p[0] };
  }
  code(r) {
    const p = this.rules.block.code.exec(r);
    if (p) {
      const v = p[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: p[0],
        codeBlockStyle: "indented",
        text: this.options.pedantic
          ? v
          : rtrim(
              v,
              `
`
            ),
      };
    }
  }
  fences(r) {
    const p = this.rules.block.fences.exec(r);
    if (p) {
      const v = p[0],
        k = indentCodeCompensation(v, p[3] || "");
      return {
        type: "code",
        raw: v,
        lang: p[2]
          ? p[2].trim().replace(this.rules.inline._escapes, "$1")
          : p[2],
        text: k,
      };
    }
  }
  heading(r) {
    const p = this.rules.block.heading.exec(r);
    if (p) {
      let v = p[2].trim();
      if (/#$/.test(v)) {
        const k = rtrim(v, "#");
        (this.options.pedantic || !k || / $/.test(k)) && (v = k.trim());
      }
      return {
        type: "heading",
        raw: p[0],
        depth: p[1].length,
        text: v,
        tokens: this.lexer.inline(v),
      };
    }
  }
  hr(r) {
    const p = this.rules.block.hr.exec(r);
    if (p) return { type: "hr", raw: p[0] };
  }
  blockquote(r) {
    const p = this.rules.block.blockquote.exec(r);
    if (p) {
      const v = p[0].replace(/^ *>[ \t]?/gm, ""),
        k = this.lexer.state.top;
      this.lexer.state.top = !0;
      const x = this.lexer.blockTokens(v);
      return (
        (this.lexer.state.top = k),
        { type: "blockquote", raw: p[0], tokens: x, text: v }
      );
    }
  }
  list(r) {
    let p = this.rules.block.list.exec(r);
    if (p) {
      let v,
        k,
        x,
        S,
        I,
        F,
        O,
        L,
        U,
        N,
        j,
        R,
        q = p[1].trim();
      const Q = q.length > 1,
        K = {
          type: "list",
          raw: "",
          ordered: Q,
          start: Q ? +q.slice(0, -1) : "",
          loose: !1,
          items: [],
        };
      (q = Q ? `\\d{1,9}\\${q.slice(-1)}` : `\\${q}`),
        this.options.pedantic && (q = Q ? q : "[*+-]");
      const V = new RegExp(`^( {0,3}${q})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      for (
        ;
        r && ((R = !1), !(!(p = V.exec(r)) || this.rules.block.hr.test(r)));

      ) {
        if (
          ((v = p[0]),
          (r = r.substring(v.length)),
          (L = p[2]
            .split(
              `
`,
              1
            )[0]
            .replace(/^\t+/, (G) => " ".repeat(3 * G.length))),
          (U = r.split(
            `
`,
            1
          )[0]),
          this.options.pedantic
            ? ((S = 2), (j = L.trimLeft()))
            : ((S = p[2].search(/[^ ]/)),
              (S = S > 4 ? 1 : S),
              (j = L.slice(S)),
              (S += p[1].length)),
          (F = !1),
          !L &&
            /^ *$/.test(U) &&
            ((v +=
              U +
              `
`),
            (r = r.substring(U.length + 1)),
            (R = !0)),
          !R)
        ) {
          const G = new RegExp(
              `^ {0,${Math.min(
                3,
                S - 1
              )}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`
            ),
            Y = new RegExp(
              `^ {0,${Math.min(
                3,
                S - 1
              )}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`
            ),
            J = new RegExp(`^ {0,${Math.min(3, S - 1)}}(?:\`\`\`|~~~)`),
            Z = new RegExp(`^ {0,${Math.min(3, S - 1)}}#`);
          for (
            ;
            r &&
            ((N = r.split(
              `
`,
              1
            )[0]),
            (U = N),
            this.options.pedantic &&
              (U = U.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")),
            !(J.test(U) || Z.test(U) || G.test(U) || Y.test(r)));

          ) {
            if (U.search(/[^ ]/) >= S || !U.trim())
              j +=
                `
` + U.slice(S);
            else {
              if (
                F ||
                L.search(/[^ ]/) >= 4 ||
                J.test(L) ||
                Z.test(L) ||
                Y.test(L)
              )
                break;
              j +=
                `
` + U;
            }
            !F && !U.trim() && (F = !0),
              (v +=
                N +
                `
`),
              (r = r.substring(N.length + 1)),
              (L = U.slice(S));
          }
        }
        K.loose || (O ? (K.loose = !0) : /\n *\n *$/.test(v) && (O = !0)),
          this.options.gfm &&
            ((k = /^\[[ xX]\] /.exec(j)),
            k && ((x = k[0] !== "[ ] "), (j = j.replace(/^\[[ xX]\] +/, "")))),
          K.items.push({
            type: "list_item",
            raw: v,
            task: !!k,
            checked: x,
            loose: !1,
            text: j,
          }),
          (K.raw += v);
      }
      (K.items[K.items.length - 1].raw = v.trimRight()),
        (K.items[K.items.length - 1].text = j.trimRight()),
        (K.raw = K.raw.trimRight());
      const H = K.items.length;
      for (I = 0; I < H; I++)
        if (
          ((this.lexer.state.top = !1),
          (K.items[I].tokens = this.lexer.blockTokens(K.items[I].text, [])),
          !K.loose)
        ) {
          const G = K.items[I].tokens.filter((J) => J.type === "space"),
            Y = G.length > 0 && G.some((J) => /\n.*\n/.test(J.raw));
          K.loose = Y;
        }
      if (K.loose) for (I = 0; I < H; I++) K.items[I].loose = !0;
      return K;
    }
  }
  html(r) {
    const p = this.rules.block.html.exec(r);
    if (p) {
      const v = {
        type: "html",
        raw: p[0],
        pre:
          !this.options.sanitizer &&
          (p[1] === "pre" || p[1] === "script" || p[1] === "style"),
        text: p[0],
      };
      if (this.options.sanitize) {
        const k = this.options.sanitizer
          ? this.options.sanitizer(p[0])
          : escape(p[0]);
        (v.type = "paragraph"), (v.text = k), (v.tokens = this.lexer.inline(k));
      }
      return v;
    }
  }
  def(r) {
    const p = this.rules.block.def.exec(r);
    if (p) {
      const v = p[1].toLowerCase().replace(/\s+/g, " "),
        k = p[2]
          ? p[2]
              .replace(/^<(.*)>$/, "$1")
              .replace(this.rules.inline._escapes, "$1")
          : "",
        x = p[3]
          ? p[3]
              .substring(1, p[3].length - 1)
              .replace(this.rules.inline._escapes, "$1")
          : p[3];
      return { type: "def", tag: v, raw: p[0], href: k, title: x };
    }
  }
  table(r) {
    const p = this.rules.block.table.exec(r);
    if (p) {
      const v = {
        type: "table",
        header: splitCells(p[1]).map((k) => ({ text: k })),
        align: p[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows:
          p[3] && p[3].trim()
            ? p[3].replace(/\n[ \t]*$/, "").split(`
`)
            : [],
      };
      if (v.header.length === v.align.length) {
        v.raw = p[0];
        let k = v.align.length,
          x,
          S,
          I,
          F;
        for (x = 0; x < k; x++)
          /^ *-+: *$/.test(v.align[x])
            ? (v.align[x] = "right")
            : /^ *:-+: *$/.test(v.align[x])
            ? (v.align[x] = "center")
            : /^ *:-+ *$/.test(v.align[x])
            ? (v.align[x] = "left")
            : (v.align[x] = null);
        for (k = v.rows.length, x = 0; x < k; x++)
          v.rows[x] = splitCells(v.rows[x], v.header.length).map((O) => ({
            text: O,
          }));
        for (k = v.header.length, S = 0; S < k; S++)
          v.header[S].tokens = this.lexer.inline(v.header[S].text);
        for (k = v.rows.length, S = 0; S < k; S++)
          for (F = v.rows[S], I = 0; I < F.length; I++)
            F[I].tokens = this.lexer.inline(F[I].text);
        return v;
      }
    }
  }
  lheading(r) {
    const p = this.rules.block.lheading.exec(r);
    if (p)
      return {
        type: "heading",
        raw: p[0],
        depth: p[2].charAt(0) === "=" ? 1 : 2,
        text: p[1],
        tokens: this.lexer.inline(p[1]),
      };
  }
  paragraph(r) {
    const p = this.rules.block.paragraph.exec(r);
    if (p) {
      const v =
        p[1].charAt(p[1].length - 1) ===
        `
`
          ? p[1].slice(0, -1)
          : p[1];
      return {
        type: "paragraph",
        raw: p[0],
        text: v,
        tokens: this.lexer.inline(v),
      };
    }
  }
  text(r) {
    const p = this.rules.block.text.exec(r);
    if (p)
      return {
        type: "text",
        raw: p[0],
        text: p[0],
        tokens: this.lexer.inline(p[0]),
      };
  }
  escape(r) {
    const p = this.rules.inline.escape.exec(r);
    if (p) return { type: "escape", raw: p[0], text: escape(p[1]) };
  }
  tag(r) {
    const p = this.rules.inline.tag.exec(r);
    if (p)
      return (
        !this.lexer.state.inLink && /^<a /i.test(p[0])
          ? (this.lexer.state.inLink = !0)
          : this.lexer.state.inLink &&
            /^<\/a>/i.test(p[0]) &&
            (this.lexer.state.inLink = !1),
        !this.lexer.state.inRawBlock &&
        /^<(pre|code|kbd|script)(\s|>)/i.test(p[0])
          ? (this.lexer.state.inRawBlock = !0)
          : this.lexer.state.inRawBlock &&
            /^<\/(pre|code|kbd|script)(\s|>)/i.test(p[0]) &&
            (this.lexer.state.inRawBlock = !1),
        {
          type: this.options.sanitize ? "text" : "html",
          raw: p[0],
          inLink: this.lexer.state.inLink,
          inRawBlock: this.lexer.state.inRawBlock,
          text: this.options.sanitize
            ? this.options.sanitizer
              ? this.options.sanitizer(p[0])
              : escape(p[0])
            : p[0],
        }
      );
  }
  link(r) {
    const p = this.rules.inline.link.exec(r);
    if (p) {
      const v = p[2].trim();
      if (!this.options.pedantic && /^</.test(v)) {
        if (!/>$/.test(v)) return;
        const S = rtrim(v.slice(0, -1), "\\");
        if ((v.length - S.length) % 2 === 0) return;
      } else {
        const S = findClosingBracket(p[2], "()");
        if (S > -1) {
          const F = (p[0].indexOf("!") === 0 ? 5 : 4) + p[1].length + S;
          (p[2] = p[2].substring(0, S)),
            (p[0] = p[0].substring(0, F).trim()),
            (p[3] = "");
        }
      }
      let k = p[2],
        x = "";
      if (this.options.pedantic) {
        const S = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(k);
        S && ((k = S[1]), (x = S[3]));
      } else x = p[3] ? p[3].slice(1, -1) : "";
      return (
        (k = k.trim()),
        /^</.test(k) &&
          (this.options.pedantic && !/>$/.test(v)
            ? (k = k.slice(1))
            : (k = k.slice(1, -1))),
        outputLink(
          p,
          {
            href: k && k.replace(this.rules.inline._escapes, "$1"),
            title: x && x.replace(this.rules.inline._escapes, "$1"),
          },
          p[0],
          this.lexer
        )
      );
    }
  }
  reflink(r, p) {
    let v;
    if (
      (v = this.rules.inline.reflink.exec(r)) ||
      (v = this.rules.inline.nolink.exec(r))
    ) {
      let k = (v[2] || v[1]).replace(/\s+/g, " ");
      if (((k = p[k.toLowerCase()]), !k)) {
        const x = v[0].charAt(0);
        return { type: "text", raw: x, text: x };
      }
      return outputLink(v, k, v[0], this.lexer);
    }
  }
  emStrong(r, p, v = "") {
    let k = this.rules.inline.emStrong.lDelim.exec(r);
    if (!k || (k[3] && v.match(/[\p{L}\p{N}]/u))) return;
    const x = k[1] || k[2] || "";
    if (!x || (x && (v === "" || this.rules.inline.punctuation.exec(v)))) {
      const S = k[0].length - 1;
      let I,
        F,
        O = S,
        L = 0;
      const U =
        k[0][0] === "*"
          ? this.rules.inline.emStrong.rDelimAst
          : this.rules.inline.emStrong.rDelimUnd;
      for (
        U.lastIndex = 0, p = p.slice(-1 * r.length + S);
        (k = U.exec(p)) != null;

      ) {
        if (((I = k[1] || k[2] || k[3] || k[4] || k[5] || k[6]), !I)) continue;
        if (((F = I.length), k[3] || k[4])) {
          O += F;
          continue;
        } else if ((k[5] || k[6]) && S % 3 && !((S + F) % 3)) {
          L += F;
          continue;
        }
        if (((O -= F), O > 0)) continue;
        F = Math.min(F, F + O + L);
        const N = r.slice(0, S + k.index + (k[0].length - I.length) + F);
        if (Math.min(S, F) % 2) {
          const R = N.slice(1, -1);
          return {
            type: "em",
            raw: N,
            text: R,
            tokens: this.lexer.inlineTokens(R),
          };
        }
        const j = N.slice(2, -2);
        return {
          type: "strong",
          raw: N,
          text: j,
          tokens: this.lexer.inlineTokens(j),
        };
      }
    }
  }
  codespan(r) {
    const p = this.rules.inline.code.exec(r);
    if (p) {
      let v = p[2].replace(/\n/g, " ");
      const k = /[^ ]/.test(v),
        x = /^ /.test(v) && / $/.test(v);
      return (
        k && x && (v = v.substring(1, v.length - 1)),
        (v = escape(v, !0)),
        { type: "codespan", raw: p[0], text: v }
      );
    }
  }
  br(r) {
    const p = this.rules.inline.br.exec(r);
    if (p) return { type: "br", raw: p[0] };
  }
  del(r) {
    const p = this.rules.inline.del.exec(r);
    if (p)
      return {
        type: "del",
        raw: p[0],
        text: p[2],
        tokens: this.lexer.inlineTokens(p[2]),
      };
  }
  autolink(r, p) {
    const v = this.rules.inline.autolink.exec(r);
    if (v) {
      let k, x;
      return (
        v[2] === "@"
          ? ((k = escape(this.options.mangle ? p(v[1]) : v[1])),
            (x = "mailto:" + k))
          : ((k = escape(v[1])), (x = k)),
        {
          type: "link",
          raw: v[0],
          text: k,
          href: x,
          tokens: [{ type: "text", raw: k, text: k }],
        }
      );
    }
  }
  url(r, p) {
    let v;
    if ((v = this.rules.inline.url.exec(r))) {
      let k, x;
      if (v[2] === "@")
        (k = escape(this.options.mangle ? p(v[0]) : v[0])), (x = "mailto:" + k);
      else {
        let S;
        do (S = v[0]), (v[0] = this.rules.inline._backpedal.exec(v[0])[0]);
        while (S !== v[0]);
        (k = escape(v[0])),
          v[1] === "www." ? (x = "http://" + v[0]) : (x = v[0]);
      }
      return {
        type: "link",
        raw: v[0],
        text: k,
        href: x,
        tokens: [{ type: "text", raw: k, text: k }],
      };
    }
  }
  inlineText(r, p) {
    const v = this.rules.inline.text.exec(r);
    if (v) {
      let k;
      return (
        this.lexer.state.inRawBlock
          ? (k = this.options.sanitize
              ? this.options.sanitizer
                ? this.options.sanitizer(v[0])
                : escape(v[0])
              : v[0])
          : (k = escape(this.options.smartypants ? p(v[0]) : v[0])),
        { type: "text", raw: v[0], text: k }
      );
    }
  }
}
const block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences:
    /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  _paragraph:
    /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/,
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def)
  .replace("label", block._label)
  .replace("title", block._title)
  .getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */)
  .replace("bull", block.bullet)
  .getRegex();
block.list = edit(block.list)
  .replace(/bull/g, block.bullet)
  .replace(
    "hr",
    "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))"
  )
  .replace("def", "\\n+(?=" + block.def.source + ")")
  .getRegex();
block._tag =
  "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i")
  .replace("comment", block._comment)
  .replace("tag", block._tag)
  .replace(
    "attribute",
    / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/
  )
  .getRegex();
block.paragraph = edit(block._paragraph)
  .replace("hr", block.hr)
  .replace("heading", " {0,3}#{1,6} ")
  .replace("|lheading", "")
  .replace("|table", "")
  .replace("blockquote", " {0,3}>")
  .replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
  .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
  .replace(
    "html",
    "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)"
  )
  .replace("tag", block._tag)
  .getRegex();
block.blockquote = edit(block.blockquote)
  .replace("paragraph", block.paragraph)
  .getRegex();
block.normal = merge({}, block);
block.gfm = merge({}, block.normal, {
  table:
    "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)",
});
block.gfm.table = edit(block.gfm.table)
  .replace("hr", block.hr)
  .replace("heading", " {0,3}#{1,6} ")
  .replace("blockquote", " {0,3}>")
  .replace("code", " {4}[^\\n]")
  .replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
  .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
  .replace(
    "html",
    "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)"
  )
  .replace("tag", block._tag)
  .getRegex();
block.gfm.paragraph = edit(block._paragraph)
  .replace("hr", block.hr)
  .replace("heading", " {0,3}#{1,6} ")
  .replace("|lheading", "")
  .replace("table", block.gfm.table)
  .replace("blockquote", " {0,3}>")
  .replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
  .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
  .replace(
    "html",
    "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)"
  )
  .replace("tag", block._tag)
  .getRegex();
block.pedantic = merge({}, block.normal, {
  html: edit(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  )
    .replace("comment", block._comment)
    .replace(
      /tag/g,
      "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b"
    )
    .getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph)
    .replace("hr", block.hr)
    .replace(
      "heading",
      ` *#{1,6} *[^
]`
    )
    .replace("lheading", block.lheading)
    .replace("blockquote", " {0,3}>")
    .replace("|fences", "")
    .replace("|list", "")
    .replace("|html", "")
    .getRegex(),
});
const inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    rDelimAst:
      /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd:
      /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/,
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/,
};
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
inline.punctuation = edit(inline.punctuation)
  .replace(/punctuation/g, inline._punctuation)
  .getRegex();
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim)
  .replace(/punct/g, inline._punctuation)
  .getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g")
  .replace(/punct/g, inline._punctuation)
  .getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g")
  .replace(/punct/g, inline._punctuation)
  .getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email =
  /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink)
  .replace("scheme", inline._scheme)
  .replace("email", inline._email)
  .getRegex();
inline._attribute =
  /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag)
  .replace("comment", inline._comment)
  .replace("attribute", inline._attribute)
  .getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link)
  .replace("label", inline._label)
  .replace("href", inline._href)
  .replace("title", inline._title)
  .getRegex();
inline.reflink = edit(inline.reflink)
  .replace("label", inline._label)
  .replace("ref", block._label)
  .getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g")
  .replace("reflink", inline.reflink)
  .replace("nolink", inline.nolink)
  .getRegex();
inline.normal = merge({}, inline);
inline.pedantic = merge({}, inline.normal, {
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g,
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g,
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/)
    .replace("label", inline._label)
    .getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
    .replace("label", inline._label)
    .getRegex(),
});
inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email:
    /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal:
    /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
});
inline.gfm.url = edit(inline.gfm.url, "i")
  .replace("email", inline.gfm._extended_email)
  .getRegex();
inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text)
    .replace("\\b_", "\\b_| {2,}\\n")
    .replace(/\{2,\}/g, "*")
    .getRegex(),
});
function smartypants($) {
  return $.replace(/---/g, "—")
    .replace(/--/g, "–")
    .replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘")
    .replace(/'/g, "’")
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“")
    .replace(/"/g, "”")
    .replace(/\.{3}/g, "…");
}
function mangle($) {
  let r = "",
    p,
    v;
  const k = $.length;
  for (p = 0; p < k; p++)
    (v = $.charCodeAt(p)),
      Math.random() > 0.5 && (v = "x" + v.toString(16)),
      (r += "&#" + v + ";");
  return r;
}
class Lexer {
  constructor(r) {
    (this.tokens = []),
      (this.tokens.links = Object.create(null)),
      (this.options = r || defaults),
      (this.options.tokenizer = this.options.tokenizer || new Tokenizer()),
      (this.tokenizer = this.options.tokenizer),
      (this.tokenizer.options = this.options),
      (this.tokenizer.lexer = this),
      (this.inlineQueue = []),
      (this.state = { inLink: !1, inRawBlock: !1, top: !0 });
    const p = { block: block.normal, inline: inline.normal };
    this.options.pedantic
      ? ((p.block = block.pedantic), (p.inline = inline.pedantic))
      : this.options.gfm &&
        ((p.block = block.gfm),
        this.options.breaks
          ? (p.inline = inline.breaks)
          : (p.inline = inline.gfm)),
      (this.tokenizer.rules = p);
  }
  static get rules() {
    return { block, inline };
  }
  static lex(r, p) {
    return new Lexer(p).lex(r);
  }
  static lexInline(r, p) {
    return new Lexer(p).inlineTokens(r);
  }
  lex(r) {
    (r = r.replace(
      /\r\n|\r/g,
      `
`
    )),
      this.blockTokens(r, this.tokens);
    let p;
    for (; (p = this.inlineQueue.shift()); ) this.inlineTokens(p.src, p.tokens);
    return this.tokens;
  }
  blockTokens(r, p = []) {
    this.options.pedantic
      ? (r = r.replace(/\t/g, "    ").replace(/^ +$/gm, ""))
      : (r = r.replace(
          /^( *)(\t+)/gm,
          (I, F, O) => F + "    ".repeat(O.length)
        ));
    let v, k, x, S;
    for (; r; )
      if (
        !(
          this.options.extensions &&
          this.options.extensions.block &&
          this.options.extensions.block.some((I) =>
            (v = I.call({ lexer: this }, r, p))
              ? ((r = r.substring(v.raw.length)), p.push(v), !0)
              : !1
          )
        )
      ) {
        if ((v = this.tokenizer.space(r))) {
          (r = r.substring(v.raw.length)),
            v.raw.length === 1 && p.length > 0
              ? (p[p.length - 1].raw += `
`)
              : p.push(v);
          continue;
        }
        if ((v = this.tokenizer.code(r))) {
          (r = r.substring(v.raw.length)),
            (k = p[p.length - 1]),
            k && (k.type === "paragraph" || k.type === "text")
              ? ((k.raw +=
                  `
` + v.raw),
                (k.text +=
                  `
` + v.text),
                (this.inlineQueue[this.inlineQueue.length - 1].src = k.text))
              : p.push(v);
          continue;
        }
        if ((v = this.tokenizer.fences(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.heading(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.hr(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.blockquote(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.list(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.html(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.def(r))) {
          (r = r.substring(v.raw.length)),
            (k = p[p.length - 1]),
            k && (k.type === "paragraph" || k.type === "text")
              ? ((k.raw +=
                  `
` + v.raw),
                (k.text +=
                  `
` + v.raw),
                (this.inlineQueue[this.inlineQueue.length - 1].src = k.text))
              : this.tokens.links[v.tag] ||
                (this.tokens.links[v.tag] = { href: v.href, title: v.title });
          continue;
        }
        if ((v = this.tokenizer.table(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.lheading(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if (
          ((x = r),
          this.options.extensions && this.options.extensions.startBlock)
        ) {
          let I = 1 / 0;
          const F = r.slice(1);
          let O;
          this.options.extensions.startBlock.forEach(function (L) {
            (O = L.call({ lexer: this }, F)),
              typeof O == "number" && O >= 0 && (I = Math.min(I, O));
          }),
            I < 1 / 0 && I >= 0 && (x = r.substring(0, I + 1));
        }
        if (this.state.top && (v = this.tokenizer.paragraph(x))) {
          (k = p[p.length - 1]),
            S && k.type === "paragraph"
              ? ((k.raw +=
                  `
` + v.raw),
                (k.text +=
                  `
` + v.text),
                this.inlineQueue.pop(),
                (this.inlineQueue[this.inlineQueue.length - 1].src = k.text))
              : p.push(v),
            (S = x.length !== r.length),
            (r = r.substring(v.raw.length));
          continue;
        }
        if ((v = this.tokenizer.text(r))) {
          (r = r.substring(v.raw.length)),
            (k = p[p.length - 1]),
            k && k.type === "text"
              ? ((k.raw +=
                  `
` + v.raw),
                (k.text +=
                  `
` + v.text),
                this.inlineQueue.pop(),
                (this.inlineQueue[this.inlineQueue.length - 1].src = k.text))
              : p.push(v);
          continue;
        }
        if (r) {
          const I = "Infinite loop on byte: " + r.charCodeAt(0);
          if (this.options.silent) {
            console.error(I);
            break;
          } else throw new Error(I);
        }
      }
    return (this.state.top = !0), p;
  }
  inline(r, p = []) {
    return this.inlineQueue.push({ src: r, tokens: p }), p;
  }
  inlineTokens(r, p = []) {
    let v,
      k,
      x,
      S = r,
      I,
      F,
      O;
    if (this.tokens.links) {
      const L = Object.keys(this.tokens.links);
      if (L.length > 0)
        for (
          ;
          (I = this.tokenizer.rules.inline.reflinkSearch.exec(S)) != null;

        )
          L.includes(I[0].slice(I[0].lastIndexOf("[") + 1, -1)) &&
            (S =
              S.slice(0, I.index) +
              "[" +
              repeatString("a", I[0].length - 2) +
              "]" +
              S.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (I = this.tokenizer.rules.inline.blockSkip.exec(S)) != null; )
      S =
        S.slice(0, I.index) +
        "[" +
        repeatString("a", I[0].length - 2) +
        "]" +
        S.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    for (; (I = this.tokenizer.rules.inline.escapedEmSt.exec(S)) != null; )
      (S =
        S.slice(0, I.index + I[0].length - 2) +
        "++" +
        S.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex)),
        this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    for (; r; )
      if (
        (F || (O = ""),
        (F = !1),
        !(
          this.options.extensions &&
          this.options.extensions.inline &&
          this.options.extensions.inline.some((L) =>
            (v = L.call({ lexer: this }, r, p))
              ? ((r = r.substring(v.raw.length)), p.push(v), !0)
              : !1
          )
        ))
      ) {
        if ((v = this.tokenizer.escape(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.tag(r))) {
          (r = r.substring(v.raw.length)),
            (k = p[p.length - 1]),
            k && v.type === "text" && k.type === "text"
              ? ((k.raw += v.raw), (k.text += v.text))
              : p.push(v);
          continue;
        }
        if ((v = this.tokenizer.link(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.reflink(r, this.tokens.links))) {
          (r = r.substring(v.raw.length)),
            (k = p[p.length - 1]),
            k && v.type === "text" && k.type === "text"
              ? ((k.raw += v.raw), (k.text += v.text))
              : p.push(v);
          continue;
        }
        if ((v = this.tokenizer.emStrong(r, S, O))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.codespan(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.br(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.del(r))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if ((v = this.tokenizer.autolink(r, mangle))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if (!this.state.inLink && (v = this.tokenizer.url(r, mangle))) {
          (r = r.substring(v.raw.length)), p.push(v);
          continue;
        }
        if (
          ((x = r),
          this.options.extensions && this.options.extensions.startInline)
        ) {
          let L = 1 / 0;
          const U = r.slice(1);
          let N;
          this.options.extensions.startInline.forEach(function (j) {
            (N = j.call({ lexer: this }, U)),
              typeof N == "number" && N >= 0 && (L = Math.min(L, N));
          }),
            L < 1 / 0 && L >= 0 && (x = r.substring(0, L + 1));
        }
        if ((v = this.tokenizer.inlineText(x, smartypants))) {
          (r = r.substring(v.raw.length)),
            v.raw.slice(-1) !== "_" && (O = v.raw.slice(-1)),
            (F = !0),
            (k = p[p.length - 1]),
            k && k.type === "text"
              ? ((k.raw += v.raw), (k.text += v.text))
              : p.push(v);
          continue;
        }
        if (r) {
          const L = "Infinite loop on byte: " + r.charCodeAt(0);
          if (this.options.silent) {
            console.error(L);
            break;
          } else throw new Error(L);
        }
      }
    return p;
  }
}
class Renderer {
  constructor(r) {
    this.options = r || defaults;
  }
  code(r, p, v) {
    const k = (p || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const x = this.options.highlight(r, k);
      x != null && x !== r && ((v = !0), (r = x));
    }
    return (
      (r =
        r.replace(/\n$/, "") +
        `
`),
      k
        ? '<pre><code class="' +
          this.options.langPrefix +
          escape(k) +
          '">' +
          (v ? r : escape(r, !0)) +
          `</code></pre>
`
        : "<pre><code>" +
          (v ? r : escape(r, !0)) +
          `</code></pre>
`
    );
  }
  blockquote(r) {
    return `<blockquote>
${r}</blockquote>
`;
  }
  html(r) {
    return r;
  }
  heading(r, p, v, k) {
    if (this.options.headerIds) {
      const x = this.options.headerPrefix + k.slug(v);
      return `<h${p} id="${x}">${r}</h${p}>
`;
    }
    return `<h${p}>${r}</h${p}>
`;
  }
  hr() {
    return this.options.xhtml
      ? `<hr/>
`
      : `<hr>
`;
  }
  list(r, p, v) {
    const k = p ? "ol" : "ul",
      x = p && v !== 1 ? ' start="' + v + '"' : "";
    return (
      "<" +
      k +
      x +
      `>
` +
      r +
      "</" +
      k +
      `>
`
    );
  }
  listitem(r) {
    return `<li>${r}</li>
`;
  }
  checkbox(r) {
    return (
      "<input " +
      (r ? 'checked="" ' : "") +
      'disabled="" type="checkbox"' +
      (this.options.xhtml ? " /" : "") +
      "> "
    );
  }
  paragraph(r) {
    return `<p>${r}</p>
`;
  }
  table(r, p) {
    return (
      p && (p = `<tbody>${p}</tbody>`),
      `<table>
<thead>
` +
        r +
        `</thead>
` +
        p +
        `</table>
`
    );
  }
  tablerow(r) {
    return `<tr>
${r}</tr>
`;
  }
  tablecell(r, p) {
    const v = p.header ? "th" : "td";
    return (
      (p.align ? `<${v} align="${p.align}">` : `<${v}>`) +
      r +
      `</${v}>
`
    );
  }
  strong(r) {
    return `<strong>${r}</strong>`;
  }
  em(r) {
    return `<em>${r}</em>`;
  }
  codespan(r) {
    return `<code>${r}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  del(r) {
    return `<del>${r}</del>`;
  }
  link(r, p, v) {
    if (
      ((r = cleanUrl(this.options.sanitize, this.options.baseUrl, r)),
      r === null)
    )
      return v;
    let k = '<a href="' + r + '"';
    return p && (k += ' title="' + p + '"'), (k += ">" + v + "</a>"), k;
  }
  image(r, p, v) {
    if (
      ((r = cleanUrl(this.options.sanitize, this.options.baseUrl, r)),
      r === null)
    )
      return v;
    let k = `<img src="${r}" alt="${v}"`;
    return (
      p && (k += ` title="${p}"`), (k += this.options.xhtml ? "/>" : ">"), k
    );
  }
  text(r) {
    return r;
  }
}
class TextRenderer {
  strong(r) {
    return r;
  }
  em(r) {
    return r;
  }
  codespan(r) {
    return r;
  }
  del(r) {
    return r;
  }
  html(r) {
    return r;
  }
  text(r) {
    return r;
  }
  link(r, p, v) {
    return "" + v;
  }
  image(r, p, v) {
    return "" + v;
  }
  br() {
    return "";
  }
}
class Slugger {
  constructor() {
    this.seen = {};
  }
  serialize(r) {
    return r
      .toLowerCase()
      .trim()
      .replace(/<[!\/a-z].*?>/gi, "")
      .replace(
        /[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g,
        ""
      )
      .replace(/\s/g, "-");
  }
  getNextSafeSlug(r, p) {
    let v = r,
      k = 0;
    if (this.seen.hasOwnProperty(v)) {
      k = this.seen[r];
      do k++, (v = r + "-" + k);
      while (this.seen.hasOwnProperty(v));
    }
    return p || ((this.seen[r] = k), (this.seen[v] = 0)), v;
  }
  slug(r, p = {}) {
    const v = this.serialize(r);
    return this.getNextSafeSlug(v, p.dryrun);
  }
}
class Parser {
  constructor(r) {
    (this.options = r || defaults),
      (this.options.renderer = this.options.renderer || new Renderer()),
      (this.renderer = this.options.renderer),
      (this.renderer.options = this.options),
      (this.textRenderer = new TextRenderer()),
      (this.slugger = new Slugger());
  }
  static parse(r, p) {
    return new Parser(p).parse(r);
  }
  static parseInline(r, p) {
    return new Parser(p).parseInline(r);
  }
  parse(r, p = !0) {
    let v = "",
      k,
      x,
      S,
      I,
      F,
      O,
      L,
      U,
      N,
      j,
      R,
      q,
      Q,
      K,
      V,
      H,
      G,
      Y,
      J;
    const Z = r.length;
    for (k = 0; k < Z; k++) {
      if (
        ((j = r[k]),
        this.options.extensions &&
          this.options.extensions.renderers &&
          this.options.extensions.renderers[j.type] &&
          ((J = this.options.extensions.renderers[j.type].call(
            { parser: this },
            j
          )),
          J !== !1 ||
            ![
              "space",
              "hr",
              "heading",
              "code",
              "table",
              "blockquote",
              "list",
              "html",
              "paragraph",
              "text",
            ].includes(j.type)))
      ) {
        v += J || "";
        continue;
      }
      switch (j.type) {
        case "space":
          continue;
        case "hr": {
          v += this.renderer.hr();
          continue;
        }
        case "heading": {
          v += this.renderer.heading(
            this.parseInline(j.tokens),
            j.depth,
            unescape$1(this.parseInline(j.tokens, this.textRenderer)),
            this.slugger
          );
          continue;
        }
        case "code": {
          v += this.renderer.code(j.text, j.lang, j.escaped);
          continue;
        }
        case "table": {
          for (U = "", L = "", I = j.header.length, x = 0; x < I; x++)
            L += this.renderer.tablecell(this.parseInline(j.header[x].tokens), {
              header: !0,
              align: j.align[x],
            });
          for (
            U += this.renderer.tablerow(L), N = "", I = j.rows.length, x = 0;
            x < I;
            x++
          ) {
            for (O = j.rows[x], L = "", F = O.length, S = 0; S < F; S++)
              L += this.renderer.tablecell(this.parseInline(O[S].tokens), {
                header: !1,
                align: j.align[S],
              });
            N += this.renderer.tablerow(L);
          }
          v += this.renderer.table(U, N);
          continue;
        }
        case "blockquote": {
          (N = this.parse(j.tokens)), (v += this.renderer.blockquote(N));
          continue;
        }
        case "list": {
          for (
            R = j.ordered,
              q = j.start,
              Q = j.loose,
              I = j.items.length,
              N = "",
              x = 0;
            x < I;
            x++
          )
            (V = j.items[x]),
              (H = V.checked),
              (G = V.task),
              (K = ""),
              V.task &&
                ((Y = this.renderer.checkbox(H)),
                Q
                  ? V.tokens.length > 0 && V.tokens[0].type === "paragraph"
                    ? ((V.tokens[0].text = Y + " " + V.tokens[0].text),
                      V.tokens[0].tokens &&
                        V.tokens[0].tokens.length > 0 &&
                        V.tokens[0].tokens[0].type === "text" &&
                        (V.tokens[0].tokens[0].text =
                          Y + " " + V.tokens[0].tokens[0].text))
                    : V.tokens.unshift({ type: "text", text: Y })
                  : (K += Y)),
              (K += this.parse(V.tokens, Q)),
              (N += this.renderer.listitem(K, G, H));
          v += this.renderer.list(N, R, q);
          continue;
        }
        case "html": {
          v += this.renderer.html(j.text);
          continue;
        }
        case "paragraph": {
          v += this.renderer.paragraph(this.parseInline(j.tokens));
          continue;
        }
        case "text": {
          for (
            N = j.tokens ? this.parseInline(j.tokens) : j.text;
            k + 1 < Z && r[k + 1].type === "text";

          )
            (j = r[++k]),
              (N +=
                `
` + (j.tokens ? this.parseInline(j.tokens) : j.text));
          v += p ? this.renderer.paragraph(N) : N;
          continue;
        }
        default: {
          const X = 'Token with "' + j.type + '" type was not found.';
          if (this.options.silent) {
            console.error(X);
            return;
          } else throw new Error(X);
        }
      }
    }
    return v;
  }
  parseInline(r, p) {
    p = p || this.renderer;
    let v = "",
      k,
      x,
      S;
    const I = r.length;
    for (k = 0; k < I; k++) {
      if (
        ((x = r[k]),
        this.options.extensions &&
          this.options.extensions.renderers &&
          this.options.extensions.renderers[x.type] &&
          ((S = this.options.extensions.renderers[x.type].call(
            { parser: this },
            x
          )),
          S !== !1 ||
            ![
              "escape",
              "html",
              "link",
              "image",
              "strong",
              "em",
              "codespan",
              "br",
              "del",
              "text",
            ].includes(x.type)))
      ) {
        v += S || "";
        continue;
      }
      switch (x.type) {
        case "escape": {
          v += p.text(x.text);
          break;
        }
        case "html": {
          v += p.html(x.text);
          break;
        }
        case "link": {
          v += p.link(x.href, x.title, this.parseInline(x.tokens, p));
          break;
        }
        case "image": {
          v += p.image(x.href, x.title, x.text);
          break;
        }
        case "strong": {
          v += p.strong(this.parseInline(x.tokens, p));
          break;
        }
        case "em": {
          v += p.em(this.parseInline(x.tokens, p));
          break;
        }
        case "codespan": {
          v += p.codespan(x.text);
          break;
        }
        case "br": {
          v += p.br();
          break;
        }
        case "del": {
          v += p.del(this.parseInline(x.tokens, p));
          break;
        }
        case "text": {
          v += p.text(x.text);
          break;
        }
        default: {
          const F = 'Token with "' + x.type + '" type was not found.';
          if (this.options.silent) {
            console.error(F);
            return;
          } else throw new Error(F);
        }
      }
    }
    return v;
  }
}
function marked($, r, p) {
  if (typeof $ > "u" || $ === null)
    throw new Error("marked(): input parameter is undefined or null");
  if (typeof $ != "string")
    throw new Error(
      "marked(): input parameter is of type " +
        Object.prototype.toString.call($) +
        ", string expected"
    );
  if (
    (typeof r == "function" && ((p = r), (r = null)),
    (r = merge({}, marked.defaults, r || {})),
    checkSanitizeDeprecation(r),
    p)
  ) {
    const k = r.highlight;
    let x;
    try {
      x = Lexer.lex($, r);
    } catch (F) {
      return p(F);
    }
    const S = function (F) {
      let O;
      if (!F)
        try {
          r.walkTokens && marked.walkTokens(x, r.walkTokens),
            (O = Parser.parse(x, r));
        } catch (L) {
          F = L;
        }
      return (r.highlight = k), F ? p(F) : p(null, O);
    };
    if (!k || k.length < 3 || (delete r.highlight, !x.length)) return S();
    let I = 0;
    marked.walkTokens(x, function (F) {
      F.type === "code" &&
        (I++,
        setTimeout(() => {
          k(F.text, F.lang, function (O, L) {
            if (O) return S(O);
            L != null && L !== F.text && ((F.text = L), (F.escaped = !0)),
              I--,
              I === 0 && S();
          });
        }, 0));
    }),
      I === 0 && S();
    return;
  }
  function v(k) {
    if (
      ((k.message += `
Please report this to https://github.com/markedjs/marked.`),
      r.silent)
    )
      return (
        "<p>An error occurred:</p><pre>" + escape(k.message + "", !0) + "</pre>"
      );
    throw k;
  }
  try {
    const k = Lexer.lex($, r);
    if (r.walkTokens) {
      if (r.async)
        return Promise.all(marked.walkTokens(k, r.walkTokens))
          .then(() => Parser.parse(k, r))
          .catch(v);
      marked.walkTokens(k, r.walkTokens);
    }
    return Parser.parse(k, r);
  } catch (k) {
    v(k);
  }
}
marked.options = marked.setOptions = function ($) {
  return merge(marked.defaults, $), changeDefaults(marked.defaults), marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults;
marked.use = function (...$) {
  const r = marked.defaults.extensions || { renderers: {}, childTokens: {} };
  $.forEach((p) => {
    const v = merge({}, p);
    if (
      ((v.async = marked.defaults.async || v.async),
      p.extensions &&
        (p.extensions.forEach((k) => {
          if (!k.name) throw new Error("extension name required");
          if (k.renderer) {
            const x = r.renderers[k.name];
            x
              ? (r.renderers[k.name] = function (...S) {
                  let I = k.renderer.apply(this, S);
                  return I === !1 && (I = x.apply(this, S)), I;
                })
              : (r.renderers[k.name] = k.renderer);
          }
          if (k.tokenizer) {
            if (!k.level || (k.level !== "block" && k.level !== "inline"))
              throw new Error("extension level must be 'block' or 'inline'");
            r[k.level]
              ? r[k.level].unshift(k.tokenizer)
              : (r[k.level] = [k.tokenizer]),
              k.start &&
                (k.level === "block"
                  ? r.startBlock
                    ? r.startBlock.push(k.start)
                    : (r.startBlock = [k.start])
                  : k.level === "inline" &&
                    (r.startInline
                      ? r.startInline.push(k.start)
                      : (r.startInline = [k.start])));
          }
          k.childTokens && (r.childTokens[k.name] = k.childTokens);
        }),
        (v.extensions = r)),
      p.renderer)
    ) {
      const k = marked.defaults.renderer || new Renderer();
      for (const x in p.renderer) {
        const S = k[x];
        k[x] = (...I) => {
          let F = p.renderer[x].apply(k, I);
          return F === !1 && (F = S.apply(k, I)), F;
        };
      }
      v.renderer = k;
    }
    if (p.tokenizer) {
      const k = marked.defaults.tokenizer || new Tokenizer();
      for (const x in p.tokenizer) {
        const S = k[x];
        k[x] = (...I) => {
          let F = p.tokenizer[x].apply(k, I);
          return F === !1 && (F = S.apply(k, I)), F;
        };
      }
      v.tokenizer = k;
    }
    if (p.walkTokens) {
      const k = marked.defaults.walkTokens;
      v.walkTokens = function (x) {
        let S = [];
        return (
          S.push(p.walkTokens.call(this, x)),
          k && (S = S.concat(k.call(this, x))),
          S
        );
      };
    }
    marked.setOptions(v);
  });
};
marked.walkTokens = function ($, r) {
  let p = [];
  for (const v of $)
    switch (((p = p.concat(r.call(marked, v))), v.type)) {
      case "table": {
        for (const k of v.header) p = p.concat(marked.walkTokens(k.tokens, r));
        for (const k of v.rows)
          for (const x of k) p = p.concat(marked.walkTokens(x.tokens, r));
        break;
      }
      case "list": {
        p = p.concat(marked.walkTokens(v.items, r));
        break;
      }
      default:
        marked.defaults.extensions &&
        marked.defaults.extensions.childTokens &&
        marked.defaults.extensions.childTokens[v.type]
          ? marked.defaults.extensions.childTokens[v.type].forEach(function (
              k
            ) {
              p = p.concat(marked.walkTokens(v[k], r));
            })
          : v.tokens && (p = p.concat(marked.walkTokens(v.tokens, r)));
    }
  return p;
};
marked.parseInline = function ($, r) {
  if (typeof $ > "u" || $ === null)
    throw new Error(
      "marked.parseInline(): input parameter is undefined or null"
    );
  if (typeof $ != "string")
    throw new Error(
      "marked.parseInline(): input parameter is of type " +
        Object.prototype.toString.call($) +
        ", string expected"
    );
  (r = merge({}, marked.defaults, r || {})), checkSanitizeDeprecation(r);
  try {
    const p = Lexer.lexInline($, r);
    return (
      r.walkTokens && marked.walkTokens(p, r.walkTokens),
      Parser.parseInline(p, r)
    );
  } catch (p) {
    if (
      ((p.message += `
Please report this to https://github.com/markedjs/marked.`),
      r.silent)
    )
      return (
        "<p>An error occurred:</p><pre>" + escape(p.message + "", !0) + "</pre>"
      );
    throw p;
  }
};
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.parse = marked;
marked.options;
marked.setOptions;
marked.use;
marked.walkTokens;
marked.parseInline;
Parser.parse;
Lexer.lex;
const key = {};
function create_else_block$n($) {
  let r;
  return {
    c() {
      r = text($[1]);
    },
    m(p, v) {
      insert(p, r, v);
    },
    p(p, v) {
      v & 2 && set_data(r, p[1]);
    },
    i: noop$1,
    o: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
function create_if_block_5($) {
  let r, p;
  const v = $[5].default,
    k = create_slot(v, $, $[4], null);
  return {
    c() {
      (r = element("h6")), k && k.c(), attr(r, "id", $[2]);
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, S) {
      k &&
        k.p &&
        (!p || S & 16) &&
        update_slot_base(
          k,
          v,
          x,
          x[4],
          p
            ? get_slot_changes(v, x[4], S, null)
            : get_all_dirty_from_scope(x[4]),
          null
        ),
        (!p || S & 4) && attr(r, "id", x[2]);
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function create_if_block_4($) {
  let r, p;
  const v = $[5].default,
    k = create_slot(v, $, $[4], null);
  return {
    c() {
      (r = element("h5")), k && k.c(), attr(r, "id", $[2]);
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, S) {
      k &&
        k.p &&
        (!p || S & 16) &&
        update_slot_base(
          k,
          v,
          x,
          x[4],
          p
            ? get_slot_changes(v, x[4], S, null)
            : get_all_dirty_from_scope(x[4]),
          null
        ),
        (!p || S & 4) && attr(r, "id", x[2]);
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function create_if_block_3$1($) {
  let r, p;
  const v = $[5].default,
    k = create_slot(v, $, $[4], null);
  return {
    c() {
      (r = element("h4")), k && k.c(), attr(r, "id", $[2]);
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, S) {
      k &&
        k.p &&
        (!p || S & 16) &&
        update_slot_base(
          k,
          v,
          x,
          x[4],
          p
            ? get_slot_changes(v, x[4], S, null)
            : get_all_dirty_from_scope(x[4]),
          null
        ),
        (!p || S & 4) && attr(r, "id", x[2]);
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function create_if_block_2$3($) {
  let r, p;
  const v = $[5].default,
    k = create_slot(v, $, $[4], null);
  return {
    c() {
      (r = element("h3")), k && k.c(), attr(r, "id", $[2]);
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, S) {
      k &&
        k.p &&
        (!p || S & 16) &&
        update_slot_base(
          k,
          v,
          x,
          x[4],
          p
            ? get_slot_changes(v, x[4], S, null)
            : get_all_dirty_from_scope(x[4]),
          null
        ),
        (!p || S & 4) && attr(r, "id", x[2]);
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function create_if_block_1$l($) {
  let r, p;
  const v = $[5].default,
    k = create_slot(v, $, $[4], null);
  return {
    c() {
      (r = element("h2")), k && k.c(), attr(r, "id", $[2]);
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, S) {
      k &&
        k.p &&
        (!p || S & 16) &&
        update_slot_base(
          k,
          v,
          x,
          x[4],
          p
            ? get_slot_changes(v, x[4], S, null)
            : get_all_dirty_from_scope(x[4]),
          null
        ),
        (!p || S & 4) && attr(r, "id", x[2]);
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function create_if_block$17($) {
  let r, p;
  const v = $[5].default,
    k = create_slot(v, $, $[4], null);
  return {
    c() {
      (r = element("h1")), k && k.c(), attr(r, "id", $[2]);
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, S) {
      k &&
        k.p &&
        (!p || S & 16) &&
        update_slot_base(
          k,
          v,
          x,
          x[4],
          p
            ? get_slot_changes(v, x[4], S, null)
            : get_all_dirty_from_scope(x[4]),
          null
        ),
        (!p || S & 4) && attr(r, "id", x[2]);
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function create_fragment$2P($) {
  let r, p, v, k;
  const x = [
      create_if_block$17,
      create_if_block_1$l,
      create_if_block_2$3,
      create_if_block_3$1,
      create_if_block_4,
      create_if_block_5,
      create_else_block$n,
    ],
    S = [];
  function I(F, O) {
    return F[0] === 1
      ? 0
      : F[0] === 2
      ? 1
      : F[0] === 3
      ? 2
      : F[0] === 4
      ? 3
      : F[0] === 5
      ? 4
      : F[0] === 6
      ? 5
      : 6;
  }
  return (
    (r = I($)),
    (p = S[r] = x[r]($)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        S[r].m(F, O), insert(F, v, O), (k = !0);
      },
      p(F, [O]) {
        let L = r;
        (r = I(F)),
          r === L
            ? S[r].p(F, O)
            : (group_outros(),
              transition_out(S[L], 1, 1, () => {
                S[L] = null;
              }),
              check_outros(),
              (p = S[r]),
              p ? p.p(F, O) : ((p = S[r] = x[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        k || (transition_in(p), (k = !0));
      },
      o(F) {
        transition_out(p), (k = !1);
      },
      d(F) {
        S[r].d(F), F && detach(v);
      },
    }
  );
}
function instance$2x($, r, p) {
  let v,
    { $$slots: k = {}, $$scope: x } = r,
    { depth: S } = r,
    { raw: I } = r,
    { text: F } = r;
  const { slug: O, getOptions: L } = getContext(key),
    U = L();
  return (
    ($.$$set = (N) => {
      "depth" in N && p(0, (S = N.depth)),
        "raw" in N && p(1, (I = N.raw)),
        "text" in N && p(3, (F = N.text)),
        "$$scope" in N && p(4, (x = N.$$scope));
    }),
    ($.$$.update = () => {
      $.$$.dirty & 8 &&
        p(2, (v = U.headerIds ? U.headerPrefix + O(F) : void 0));
    }),
    [S, I, v, F, x, k]
  );
}
class Heading extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2x, create_fragment$2P, safe_not_equal, {
        depth: 0,
        raw: 1,
        text: 3,
      });
  }
}
function create_fragment$2O($) {
  let r, p;
  const v = $[1].default,
    k = create_slot(v, $, $[0], null);
  return {
    c() {
      (r = element("p")), k && k.c();
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, [S]) {
      k &&
        k.p &&
        (!p || S & 1) &&
        update_slot_base(
          k,
          v,
          x,
          x[0],
          p
            ? get_slot_changes(v, x[0], S, null)
            : get_all_dirty_from_scope(x[0]),
          null
        );
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function instance$2w($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r;
  return (
    ($.$$set = (x) => {
      "$$scope" in x && p(0, (k = x.$$scope));
    }),
    [k, v]
  );
}
class Paragraph extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2w, create_fragment$2O, safe_not_equal, {});
  }
}
function create_fragment$2N($) {
  let r;
  const p = $[3].default,
    v = create_slot(p, $, $[2], null);
  return {
    c() {
      v && v.c();
    },
    m(k, x) {
      v && v.m(k, x), (r = !0);
    },
    p(k, [x]) {
      v &&
        v.p &&
        (!r || x & 4) &&
        update_slot_base(
          v,
          p,
          k,
          k[2],
          r
            ? get_slot_changes(p, k[2], x, null)
            : get_all_dirty_from_scope(k[2]),
          null
        );
    },
    i(k) {
      r || (transition_in(v, k), (r = !0));
    },
    o(k) {
      transition_out(v, k), (r = !1);
    },
    d(k) {
      v && v.d(k);
    },
  };
}
function instance$2v($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r,
    { text: x } = r,
    { raw: S } = r;
  return (
    ($.$$set = (I) => {
      "text" in I && p(0, (x = I.text)),
        "raw" in I && p(1, (S = I.raw)),
        "$$scope" in I && p(2, (k = I.$$scope));
    }),
    [x, S, k, v]
  );
}
class Text extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2v, create_fragment$2N, safe_not_equal, {
        text: 0,
        raw: 1,
      });
  }
}
function create_fragment$2M($) {
  let r, p;
  return {
    c() {
      (r = element("img")),
        src_url_equal(r.src, (p = $[0])) || attr(r, "src", p),
        attr(r, "title", $[1]),
        attr(r, "alt", $[2]);
    },
    m(v, k) {
      insert(v, r, k);
    },
    p(v, [k]) {
      k & 1 && !src_url_equal(r.src, (p = v[0])) && attr(r, "src", p),
        k & 2 && attr(r, "title", v[1]),
        k & 4 && attr(r, "alt", v[2]);
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      v && detach(r);
    },
  };
}
function instance$2u($, r, p) {
  let { href: v = "" } = r,
    { title: k = void 0 } = r,
    { text: x = "" } = r;
  return (
    ($.$$set = (S) => {
      "href" in S && p(0, (v = S.href)),
        "title" in S && p(1, (k = S.title)),
        "text" in S && p(2, (x = S.text));
    }),
    [v, k, x]
  );
}
let Image$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2u, create_fragment$2M, safe_not_equal, {
        href: 0,
        title: 1,
        text: 2,
      });
  }
};
function create_fragment$2L($) {
  let r, p;
  const v = $[3].default,
    k = create_slot(v, $, $[2], null);
  return {
    c() {
      (r = element("a")),
        k && k.c(),
        attr(r, "href", $[0]),
        attr(r, "title", $[1]);
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, [S]) {
      k &&
        k.p &&
        (!p || S & 4) &&
        update_slot_base(
          k,
          v,
          x,
          x[2],
          p
            ? get_slot_changes(v, x[2], S, null)
            : get_all_dirty_from_scope(x[2]),
          null
        ),
        (!p || S & 1) && attr(r, "href", x[0]),
        (!p || S & 2) && attr(r, "title", x[1]);
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function instance$2t($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r,
    { href: x = "" } = r,
    { title: S = void 0 } = r;
  return (
    ($.$$set = (I) => {
      "href" in I && p(0, (x = I.href)),
        "title" in I && p(1, (S = I.title)),
        "$$scope" in I && p(2, (k = I.$$scope));
    }),
    [x, S, k, v]
  );
}
class Link extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2t, create_fragment$2L, safe_not_equal, {
        href: 0,
        title: 1,
      });
  }
}
function create_fragment$2K($) {
  let r, p;
  const v = $[1].default,
    k = create_slot(v, $, $[0], null);
  return {
    c() {
      (r = element("em")), k && k.c();
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, [S]) {
      k &&
        k.p &&
        (!p || S & 1) &&
        update_slot_base(
          k,
          v,
          x,
          x[0],
          p
            ? get_slot_changes(v, x[0], S, null)
            : get_all_dirty_from_scope(x[0]),
          null
        );
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function instance$2s($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r;
  return (
    ($.$$set = (x) => {
      "$$scope" in x && p(0, (k = x.$$scope));
    }),
    [k, v]
  );
}
class Em extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2s, create_fragment$2K, safe_not_equal, {});
  }
}
function create_fragment$2J($) {
  let r, p;
  const v = $[1].default,
    k = create_slot(v, $, $[0], null);
  return {
    c() {
      (r = element("del")), k && k.c();
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, [S]) {
      k &&
        k.p &&
        (!p || S & 1) &&
        update_slot_base(
          k,
          v,
          x,
          x[0],
          p
            ? get_slot_changes(v, x[0], S, null)
            : get_all_dirty_from_scope(x[0]),
          null
        );
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function instance$2r($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r;
  return (
    ($.$$set = (x) => {
      "$$scope" in x && p(0, (k = x.$$scope));
    }),
    [k, v]
  );
}
class Del extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2r, create_fragment$2J, safe_not_equal, {});
  }
}
function create_fragment$2I($) {
  let r,
    p = $[0].replace(/`/g, "") + "",
    v;
  return {
    c() {
      (r = element("code")), (v = text(p));
    },
    m(k, x) {
      insert(k, r, x), append(r, v);
    },
    p(k, [x]) {
      x & 1 && p !== (p = k[0].replace(/`/g, "") + "") && set_data(v, p);
    },
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r);
    },
  };
}
function instance$2q($, r, p) {
  let { raw: v } = r;
  return (
    ($.$$set = (k) => {
      "raw" in k && p(0, (v = k.raw));
    }),
    [v]
  );
}
class Codespan extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2q, create_fragment$2I, safe_not_equal, {
        raw: 0,
      });
  }
}
function create_fragment$2H($) {
  let r, p;
  const v = $[1].default,
    k = create_slot(v, $, $[0], null);
  return {
    c() {
      (r = element("strong")), k && k.c();
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, [S]) {
      k &&
        k.p &&
        (!p || S & 1) &&
        update_slot_base(
          k,
          v,
          x,
          x[0],
          p
            ? get_slot_changes(v, x[0], S, null)
            : get_all_dirty_from_scope(x[0]),
          null
        );
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function instance$2p($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r;
  return (
    ($.$$set = (x) => {
      "$$scope" in x && p(0, (k = x.$$scope));
    }),
    [k, v]
  );
}
class Strong extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2p, create_fragment$2H, safe_not_equal, {});
  }
}
function create_fragment$2G($) {
  let r, p;
  const v = $[1].default,
    k = create_slot(v, $, $[0], null);
  return {
    c() {
      (r = element("table")), k && k.c();
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, [S]) {
      k &&
        k.p &&
        (!p || S & 1) &&
        update_slot_base(
          k,
          v,
          x,
          x[0],
          p
            ? get_slot_changes(v, x[0], S, null)
            : get_all_dirty_from_scope(x[0]),
          null
        );
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function instance$2o($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r;
  return (
    ($.$$set = (x) => {
      "$$scope" in x && p(0, (k = x.$$scope));
    }),
    [k, v]
  );
}
class Table extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2o, create_fragment$2G, safe_not_equal, {});
  }
}
function create_fragment$2F($) {
  let r, p;
  const v = $[1].default,
    k = create_slot(v, $, $[0], null);
  return {
    c() {
      (r = element("thead")), k && k.c();
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, [S]) {
      k &&
        k.p &&
        (!p || S & 1) &&
        update_slot_base(
          k,
          v,
          x,
          x[0],
          p
            ? get_slot_changes(v, x[0], S, null)
            : get_all_dirty_from_scope(x[0]),
          null
        );
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function instance$2n($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r;
  return (
    ($.$$set = (x) => {
      "$$scope" in x && p(0, (k = x.$$scope));
    }),
    [k, v]
  );
}
class TableHead extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2n, create_fragment$2F, safe_not_equal, {});
  }
}
function create_fragment$2E($) {
  let r, p;
  const v = $[1].default,
    k = create_slot(v, $, $[0], null);
  return {
    c() {
      (r = element("tbody")), k && k.c();
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, [S]) {
      k &&
        k.p &&
        (!p || S & 1) &&
        update_slot_base(
          k,
          v,
          x,
          x[0],
          p
            ? get_slot_changes(v, x[0], S, null)
            : get_all_dirty_from_scope(x[0]),
          null
        );
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function instance$2m($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r;
  return (
    ($.$$set = (x) => {
      "$$scope" in x && p(0, (k = x.$$scope));
    }),
    [k, v]
  );
}
class TableBody extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2m, create_fragment$2E, safe_not_equal, {});
  }
}
function create_fragment$2D($) {
  let r, p;
  const v = $[1].default,
    k = create_slot(v, $, $[0], null);
  return {
    c() {
      (r = element("tr")), k && k.c();
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, [S]) {
      k &&
        k.p &&
        (!p || S & 1) &&
        update_slot_base(
          k,
          v,
          x,
          x[0],
          p
            ? get_slot_changes(v, x[0], S, null)
            : get_all_dirty_from_scope(x[0]),
          null
        );
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function instance$2l($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r;
  return (
    ($.$$set = (x) => {
      "$$scope" in x && p(0, (k = x.$$scope));
    }),
    [k, v]
  );
}
class TableRow extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2l, create_fragment$2D, safe_not_equal, {});
  }
}
function create_else_block$m($) {
  let r, p;
  const v = $[3].default,
    k = create_slot(v, $, $[2], null);
  return {
    c() {
      (r = element("td")), k && k.c(), attr(r, "align", $[1]);
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, S) {
      k &&
        k.p &&
        (!p || S & 4) &&
        update_slot_base(
          k,
          v,
          x,
          x[2],
          p
            ? get_slot_changes(v, x[2], S, null)
            : get_all_dirty_from_scope(x[2]),
          null
        ),
        (!p || S & 2) && attr(r, "align", x[1]);
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function create_if_block$16($) {
  let r, p;
  const v = $[3].default,
    k = create_slot(v, $, $[2], null);
  return {
    c() {
      (r = element("th")), k && k.c(), attr(r, "align", $[1]);
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, S) {
      k &&
        k.p &&
        (!p || S & 4) &&
        update_slot_base(
          k,
          v,
          x,
          x[2],
          p
            ? get_slot_changes(v, x[2], S, null)
            : get_all_dirty_from_scope(x[2]),
          null
        ),
        (!p || S & 2) && attr(r, "align", x[1]);
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function create_fragment$2C($) {
  let r, p, v, k;
  const x = [create_if_block$16, create_else_block$m],
    S = [];
  function I(F, O) {
    return F[0] ? 0 : 1;
  }
  return (
    (r = I($)),
    (p = S[r] = x[r]($)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        S[r].m(F, O), insert(F, v, O), (k = !0);
      },
      p(F, [O]) {
        let L = r;
        (r = I(F)),
          r === L
            ? S[r].p(F, O)
            : (group_outros(),
              transition_out(S[L], 1, 1, () => {
                S[L] = null;
              }),
              check_outros(),
              (p = S[r]),
              p ? p.p(F, O) : ((p = S[r] = x[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        k || (transition_in(p), (k = !0));
      },
      o(F) {
        transition_out(p), (k = !1);
      },
      d(F) {
        S[r].d(F), F && detach(v);
      },
    }
  );
}
function instance$2k($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r,
    { header: x } = r,
    { align: S } = r;
  return (
    ($.$$set = (I) => {
      "header" in I && p(0, (x = I.header)),
        "align" in I && p(1, (S = I.align)),
        "$$scope" in I && p(2, (k = I.$$scope));
    }),
    [x, S, k, v]
  );
}
class TableCell extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2k, create_fragment$2C, safe_not_equal, {
        header: 0,
        align: 1,
      });
  }
}
function create_else_block$l($) {
  let r, p;
  const v = $[3].default,
    k = create_slot(v, $, $[2], null);
  return {
    c() {
      (r = element("ul")), k && k.c();
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, S) {
      k &&
        k.p &&
        (!p || S & 4) &&
        update_slot_base(
          k,
          v,
          x,
          x[2],
          p
            ? get_slot_changes(v, x[2], S, null)
            : get_all_dirty_from_scope(x[2]),
          null
        );
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function create_if_block$15($) {
  let r, p;
  const v = $[3].default,
    k = create_slot(v, $, $[2], null);
  return {
    c() {
      (r = element("ol")), k && k.c(), attr(r, "start", $[1]);
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, S) {
      k &&
        k.p &&
        (!p || S & 4) &&
        update_slot_base(
          k,
          v,
          x,
          x[2],
          p
            ? get_slot_changes(v, x[2], S, null)
            : get_all_dirty_from_scope(x[2]),
          null
        ),
        (!p || S & 2) && attr(r, "start", x[1]);
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function create_fragment$2B($) {
  let r, p, v, k;
  const x = [create_if_block$15, create_else_block$l],
    S = [];
  function I(F, O) {
    return F[0] ? 0 : 1;
  }
  return (
    (r = I($)),
    (p = S[r] = x[r]($)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        S[r].m(F, O), insert(F, v, O), (k = !0);
      },
      p(F, [O]) {
        let L = r;
        (r = I(F)),
          r === L
            ? S[r].p(F, O)
            : (group_outros(),
              transition_out(S[L], 1, 1, () => {
                S[L] = null;
              }),
              check_outros(),
              (p = S[r]),
              p ? p.p(F, O) : ((p = S[r] = x[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        k || (transition_in(p), (k = !0));
      },
      o(F) {
        transition_out(p), (k = !1);
      },
      d(F) {
        S[r].d(F), F && detach(v);
      },
    }
  );
}
function instance$2j($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r,
    { ordered: x } = r,
    { start: S } = r;
  return (
    ($.$$set = (I) => {
      "ordered" in I && p(0, (x = I.ordered)),
        "start" in I && p(1, (S = I.start)),
        "$$scope" in I && p(2, (k = I.$$scope));
    }),
    [x, S, k, v]
  );
}
class List extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2j, create_fragment$2B, safe_not_equal, {
        ordered: 0,
        start: 1,
      });
  }
}
function create_fragment$2A($) {
  let r, p;
  const v = $[1].default,
    k = create_slot(v, $, $[0], null);
  return {
    c() {
      (r = element("li")), k && k.c();
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, [S]) {
      k &&
        k.p &&
        (!p || S & 1) &&
        update_slot_base(
          k,
          v,
          x,
          x[0],
          p
            ? get_slot_changes(v, x[0], S, null)
            : get_all_dirty_from_scope(x[0]),
          null
        );
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function instance$2i($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r;
  return (
    ($.$$set = (x) => {
      "$$scope" in x && p(0, (k = x.$$scope));
    }),
    [k, v]
  );
}
class ListItem extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2i, create_fragment$2A, safe_not_equal, {});
  }
}
function create_fragment$2z($) {
  let r;
  return {
    c() {
      r = element("hr");
    },
    m(p, v) {
      insert(p, r, v);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
class Hr extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$2z, safe_not_equal, {});
  }
}
function create_fragment$2y($) {
  let r, p;
  return {
    c() {
      (r = new HtmlTag(!1)), (p = empty()), (r.a = p);
    },
    m(v, k) {
      r.m($[0], v, k), insert(v, p, k);
    },
    p(v, [k]) {
      k & 1 && r.p(v[0]);
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      v && detach(p), v && r.d();
    },
  };
}
function instance$2h($, r, p) {
  let { text: v } = r;
  return (
    ($.$$set = (k) => {
      "text" in k && p(0, (v = k.text));
    }),
    [v]
  );
}
class Html extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2h, create_fragment$2y, safe_not_equal, {
        text: 0,
      });
  }
}
function create_fragment$2x($) {
  let r, p;
  const v = $[1].default,
    k = create_slot(v, $, $[0], null);
  return {
    c() {
      (r = element("blockquote")), k && k.c();
    },
    m(x, S) {
      insert(x, r, S), k && k.m(r, null), (p = !0);
    },
    p(x, [S]) {
      k &&
        k.p &&
        (!p || S & 1) &&
        update_slot_base(
          k,
          v,
          x,
          x[0],
          p
            ? get_slot_changes(v, x[0], S, null)
            : get_all_dirty_from_scope(x[0]),
          null
        );
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function instance$2g($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r;
  return (
    ($.$$set = (x) => {
      "$$scope" in x && p(0, (k = x.$$scope));
    }),
    [k, v]
  );
}
class Blockquote extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2g, create_fragment$2x, safe_not_equal, {});
  }
}
function create_fragment$2w($) {
  let r, p, v;
  return {
    c() {
      (r = element("pre")),
        (p = element("code")),
        (v = text($[1])),
        attr(r, "class", $[0]);
    },
    m(k, x) {
      insert(k, r, x), append(r, p), append(p, v);
    },
    p(k, [x]) {
      x & 2 && set_data(v, k[1]), x & 1 && attr(r, "class", k[0]);
    },
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r);
    },
  };
}
function instance$2f($, r, p) {
  let { lang: v } = r,
    { text: k } = r;
  return (
    ($.$$set = (x) => {
      "lang" in x && p(0, (v = x.lang)), "text" in x && p(1, (k = x.text));
    }),
    [v, k]
  );
}
class Code extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2f, create_fragment$2w, safe_not_equal, {
        lang: 0,
        text: 1,
      });
  }
}
function create_fragment$2v($) {
  let r, p;
  const v = $[1].default,
    k = create_slot(v, $, $[0], null);
  return {
    c() {
      (r = element("br")), k && k.c();
    },
    m(x, S) {
      insert(x, r, S), k && k.m(x, S), (p = !0);
    },
    p(x, [S]) {
      k &&
        k.p &&
        (!p || S & 1) &&
        update_slot_base(
          k,
          v,
          x,
          x[0],
          p
            ? get_slot_changes(v, x[0], S, null)
            : get_all_dirty_from_scope(x[0]),
          null
        );
    },
    i(x) {
      p || (transition_in(k, x), (p = !0));
    },
    o(x) {
      transition_out(k, x), (p = !1);
    },
    d(x) {
      x && detach(r), k && k.d(x);
    },
  };
}
function instance$2e($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r;
  return (
    ($.$$set = (x) => {
      "$$scope" in x && p(0, (k = x.$$scope));
    }),
    [k, v]
  );
}
class Br extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2e, create_fragment$2v, safe_not_equal, {});
  }
}
const defaultRenderers = {
    heading: Heading,
    paragraph: Paragraph,
    text: Text,
    image: Image$1,
    link: Link,
    em: Em,
    strong: Strong,
    codespan: Codespan,
    del: Del,
    table: Table,
    tablehead: TableHead,
    tablebody: TableBody,
    tablerow: TableRow,
    tablecell: TableCell,
    list: List,
    orderedlistitem: null,
    unorderedlistitem: null,
    listitem: ListItem,
    hr: Hr,
    html: Html,
    blockquote: Blockquote,
    code: Code,
    br: Br,
  },
  defaultOptions = {
    baseUrl: null,
    breaks: !1,
    gfm: !0,
    headerIds: !0,
    headerPrefix: "",
    highlight: null,
    langPrefix: "language-",
    mangle: !0,
    pedantic: !1,
    renderer: null,
    sanitize: !1,
    sanitizer: null,
    silent: !1,
    smartLists: !1,
    smartypants: !1,
    tokenizer: null,
    xhtml: !1,
  };
function create_fragment$2u($) {
  let r, p;
  return (
    (r = new Parser$1({ props: { tokens: $[0], renderers: $[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, [k]) {
        const x = {};
        k & 1 && (x.tokens = v[0]), k & 2 && (x.renderers = v[1]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function instance$2d($, r, p) {
  let v,
    k,
    x,
    S,
    { source: I = [] } = r,
    { renderers: F = {} } = r,
    { options: O = {} } = r,
    { isInline: L = !1 } = r;
  const U = createEventDispatcher();
  let N, j, R;
  return (
    setContext(key, { slug: (q) => (k ? k.slug(q) : ""), getOptions: () => x }),
    onMount(() => {
      p(7, (R = !0));
    }),
    ($.$$set = (q) => {
      "source" in q && p(2, (I = q.source)),
        "renderers" in q && p(3, (F = q.renderers)),
        "options" in q && p(4, (O = q.options)),
        "isInline" in q && p(5, (L = q.isInline));
    }),
    ($.$$.update = () => {
      $.$$.dirty & 4 && p(8, (v = Array.isArray(I))),
        $.$$.dirty & 4 && (k = I ? new Slugger() : void 0),
        $.$$.dirty & 16 && p(9, (x = { ...defaultOptions, ...O })),
        $.$$.dirty & 869 &&
          (v
            ? p(0, (N = I))
            : (p(6, (j = new Lexer(x))),
              p(0, (N = L ? j.inlineTokens(I) : j.lex(I))),
              U("parsed", { tokens: N }))),
        $.$$.dirty & 8 && p(1, (S = { ...defaultRenderers, ...F })),
        $.$$.dirty & 385 && R && !v && U("parsed", { tokens: N });
    }),
    [N, S, I, F, O, L, j, R, v, x]
  );
}
class SvelteMarkdown extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2d, create_fragment$2u, safe_not_equal, {
        source: 2,
        renderers: 3,
        options: 4,
        isInline: 5,
      });
  }
}
const markdownviewer = "";
function create_fragment$2t($) {
  let r, p, v, k, x, S, I, F;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (S = element("h3")),
        (S.textContent = "Render failed"),
        (I = space()),
        (F = element("p")),
        (F.textContent =
          "The markdown content could not be parsed. The opened file may be empty."),
        src_url_equal(v.src, (k = warning)) || attr(v, "src", k),
        attr(v, "alt", "Error"),
        attr(p, "class", "content"),
        attr(r, "class", "unreadable");
    },
    m(O, L) {
      insert(O, r, L),
        append(r, p),
        append(p, v),
        append(p, x),
        append(p, S),
        append(p, I),
        append(p, F);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(O) {
      O && detach(r);
    },
  };
}
class Unreadable extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$2t, safe_not_equal, {});
  }
}
function create_if_block$14($) {
  let r, p, v, k;
  const x = [create_if_block_1$k, create_else_block$k],
    S = [];
  function I(F, O) {
    return F[1] ? 0 : 1;
  }
  return (
    (r = I($)),
    (p = S[r] = x[r]($)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        S[r].m(F, O), insert(F, v, O), (k = !0);
      },
      p(F, O) {
        let L = r;
        (r = I(F)),
          r === L
            ? S[r].p(F, O)
            : (group_outros(),
              transition_out(S[L], 1, 1, () => {
                S[L] = null;
              }),
              check_outros(),
              (p = S[r]),
              p ? p.p(F, O) : ((p = S[r] = x[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        k || (transition_in(p), (k = !0));
      },
      o(F) {
        transition_out(p), (k = !1);
      },
      d(F) {
        S[r].d(F), F && detach(v);
      },
    }
  );
}
function create_else_block$k($) {
  let r, p;
  return (
    (r = new Unreadable({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_1$k($) {
  let r, p, v;
  return (
    (p = new SvelteMarkdown({ props: { source: $[1] } })),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          attr(r, "class", "markdownrenderer");
      },
      m(k, x) {
        insert(k, r, x), mount_component(p, r, null), (v = !0);
      },
      p(k, x) {
        const S = {};
        x & 2 && (S.source = k[1]), p.$set(S);
      },
      i(k) {
        v || (transition_in(p.$$.fragment, k), (v = !0));
      },
      o(k) {
        transition_out(p.$$.fragment, k), (v = !1);
      },
      d(k) {
        k && detach(r), destroy_component(p);
      },
    }
  );
}
function create_fragment$2s($) {
  let r,
    p,
    v = $[0] && create_if_block$14($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[0]
        ? v
          ? (v.p(k, x), x & 1 && transition_in(v, 1))
          : ((v = create_if_block$14(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$2c($, r, p) {
  let v;
  component_subscribe($, TextEditorContent, (I) => p(3, (v = I)));
  let { app: k } = r,
    x = "",
    S = "";
  return (
    WindowStore.subscribe(() => {
      if ((getWindow("TextEditor"), !k)) return;
      const I = k.openedFile;
      !I ||
        !I.mime.startsWith("text/") ||
        ((x = new TextDecoder().decode(I.data)),
        p(1, (S = k.openedFile ? x : v)));
    }),
    TextEditorContent.subscribe(() => {
      closeFile("MarkDownViewer"),
        setTitleSuffix("", "MarkDownViewer"),
        p(1, (S = k.openedFile ? x : v));
    }),
    ($.$$set = (I) => {
      "app" in I && p(0, (k = I.app));
    }),
    [k, S]
  );
}
let MarkDownViewer$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2c, create_fragment$2s, safe_not_equal, {
        app: 0,
      });
  }
};
const MarkDownViewer = {
    info: {
      name: "Markdown Viewer",
      description: "View .MD files",
      author: "ArcOS Team",
      version: "1.0.0",
      icon: icon$3,
      builtin: !0,
      hidden: !0,
    },
    size: { w: 700, h: 550 },
    pos: { x: 30, y: 40 },
    minSize: { w: 400, h: 300 },
    maxSize: { w: 1e3, h: 800 },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: MarkDownViewer$1,
    glass: !1,
    fileMimes: ["text/plain; charset=utf-8", "text/markdown; charset=utf-8"],
    events: {
      openFile($) {
        $.openedFile && setTitleSuffix(` - ${$.openedFile.path}`, $.id);
      },
    },
  },
  logo$4 = "./assets/mediaplayer-8f0c4cdf.svg",
  mediaplayer = "";
function create_if_block$13($) {
  let r,
    p,
    v = !1,
    k,
    x,
    S,
    I,
    F;
  function O() {
    cancelAnimationFrame(k),
      r.paused || ((k = raf(O)), (v = !0)),
      $[13].call(r);
  }
  let L = $[1] && create_if_block_1$j($);
  return {
    c() {
      (r = element("audio")),
        (x = space()),
        L && L.c(),
        (S = empty()),
        src_url_equal(r.src, (p = $[5])) || attr(r, "src", p),
        (r.controls = !0),
        (r.autoplay = !0),
        $[3] === void 0 && add_render_callback(() => $[12].call(r));
    },
    m(U, N) {
      insert(U, r, N),
        $[11](r),
        insert(U, x, N),
        L && L.m(U, N),
        insert(U, S, N),
        I ||
          ((F = [
            listen(r, "durationchange", $[12]),
            listen(r, "timeupdate", O),
            listen(r, "timeupdate", $[9]),
          ]),
          (I = !0));
    },
    p(U, N) {
      N & 32 && !src_url_equal(r.src, (p = U[5])) && attr(r, "src", p),
        !v && N & 16 && !isNaN(U[4]) && (r.currentTime = U[4]),
        (v = !1),
        U[1]
          ? L
            ? L.p(U, N)
            : ((L = create_if_block_1$j(U)), L.c(), L.m(S.parentNode, S))
          : L && (L.d(1), (L = null));
    },
    d(U) {
      U && detach(r),
        $[11](null),
        U && detach(x),
        L && L.d(U),
        U && detach(S),
        (I = !1),
        run_all(F);
    },
  };
}
function create_if_block_1$j($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U,
    N,
    j,
    R,
    q,
    Q,
    K,
    V,
    H = formatTime($[4]) + "",
    G,
    Y,
    J = formatTime($[3]) + "",
    Z,
    X,
    ee,
    te,
    ie,
    ue,
    oe,
    se,
    re,
    le,
    ae = $[0].openedFile.path + "",
    ne,
    ce,
    de,
    fe;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("div")),
        (k = element("button")),
        (x = text("play_arrow")),
        (I = space()),
        (F = element("button")),
        (O = text("pause")),
        (L = space()),
        (U = element("div")),
        (N = element("button")),
        (N.textContent = "fast_rewind"),
        (j = space()),
        (R = element("button")),
        (R.textContent = "fast_forward"),
        (q = space()),
        (Q = element("button")),
        (Q.textContent = "stop"),
        (K = space()),
        (V = element("div")),
        (G = text(H)),
        (Y = text(" / ")),
        (Z = text(J)),
        (X = space()),
        (ee = element("div")),
        (te = element("div")),
        (ie = space()),
        (ue = element("div")),
        (oe = element("img")),
        (le = element("span")),
        (ne = text(ae)),
        attr(k, "class", "material-icons-round"),
        (k.disabled = S = !$[6] && $[2] < 100),
        attr(F, "class", "material-icons-round"),
        (F.disabled = $[6]),
        attr(v, "class", "group"),
        attr(N, "class", "material-icons-round"),
        attr(R, "class", "material-icons-round"),
        attr(U, "class", "group"),
        attr(Q, "class", "material-icons-round"),
        attr(V, "class", "right"),
        attr(p, "class", "controls"),
        attr(te, "class", "inner"),
        set_style(te, "width", $[2] + "%"),
        attr(ee, "class", "bar"),
        src_url_equal(oe.src, (se = getMimeIcon($[0].openedFile.name))) ||
          attr(oe, "src", se),
        attr(oe, "alt", (re = $[0].openedFile.name)),
        attr(ue, "class", "filename"),
        attr(ue, "title", (ce = $[0].openedFile.path)),
        attr(r, "class", "media-player");
    },
    m(pe, _e) {
      insert(pe, r, _e),
        append(r, p),
        append(p, v),
        append(v, k),
        append(k, x),
        append(v, I),
        append(v, F),
        append(F, O),
        append(p, L),
        append(p, U),
        append(U, N),
        append(U, j),
        append(U, R),
        append(p, q),
        append(p, Q),
        append(p, K),
        append(p, V),
        append(V, G),
        append(V, Y),
        append(V, Z),
        append(r, X),
        append(r, ee),
        append(ee, te),
        append(r, ie),
        append(r, ue),
        append(ue, oe),
        append(ue, le),
        append(le, ne),
        de ||
          ((fe = [
            listen(k, "click", $[14]),
            listen(F, "click", $[15]),
            listen(N, "click", $[7]),
            listen(R, "click", $[8]),
            listen(Q, "click", $[10]),
          ]),
          (de = !0));
    },
    p(pe, _e) {
      _e & 68 && S !== (S = !pe[6] && pe[2] < 100) && (k.disabled = S),
        _e & 64 && (F.disabled = pe[6]),
        _e & 16 && H !== (H = formatTime(pe[4]) + "") && set_data(G, H),
        _e & 8 && J !== (J = formatTime(pe[3]) + "") && set_data(Z, J),
        _e & 4 && set_style(te, "width", pe[2] + "%"),
        _e & 1 &&
          !src_url_equal(oe.src, (se = getMimeIcon(pe[0].openedFile.name))) &&
          attr(oe, "src", se),
        _e & 1 && re !== (re = pe[0].openedFile.name) && attr(oe, "alt", re),
        _e & 1 && ae !== (ae = pe[0].openedFile.path + "") && set_data(ne, ae),
        _e & 1 && ce !== (ce = pe[0].openedFile.path) && attr(ue, "title", ce);
    },
    d(pe) {
      pe && detach(r), (de = !1), run_all(fe);
    },
  };
}
function create_fragment$2r($) {
  let r,
    p = $[0].openedFile && create_if_block$13($);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, k) {
      p && p.m(v, k), insert(v, r, k);
    },
    p(v, [k]) {
      v[0].openedFile
        ? p
          ? p.p(v, k)
          : ((p = create_if_block$13(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function formatTime($) {
  const r = Math.floor($ / 60),
    p = Math.floor($ % 60);
  return `${r}:${p.toString().padStart(2, "0")}`;
}
function instance$2b($, r, p) {
  let v,
    { app: k } = r,
    x = 0,
    S = 0,
    I = 0,
    F = "",
    O = "",
    L = !0;
  WindowStore.subscribe(() => {
    !k.openedFile ||
      !v ||
      O == k.openedFile.name ||
      ((O = k.openedFile.name),
      p(
        5,
        (F = URL.createObjectURL(
          new Blob([k.openedFile.data], { type: k.openedFile.mime })
        ))
      ),
      setTimeout(() => {
        v.play();
      }));
  });
  function U() {
    p(1, (v.currentTime -= 10), v);
  }
  function N() {
    p(1, (v.currentTime += 10), v);
  }
  function j() {
    p(2, (x = (v.currentTime / v.duration) * 100)), p(6, (L = v.paused));
  }
  function R() {
    p(1, (v.currentTime = 0), v), v.pause();
  }
  onMount(() => {
    registerShortcuts([
      {
        key: "space",
        action: () => {
          v == null || v.pause();
        },
      },
    ]);
  });
  function q(G) {
    binding_callbacks[G ? "unshift" : "push"](() => {
      (v = G), p(1, v);
    });
  }
  function Q() {
    (S = this.duration), p(3, S);
  }
  function K() {
    (I = this.currentTime), p(4, I);
  }
  const V = () => v.play(),
    H = () => v.pause();
  return (
    ($.$$set = (G) => {
      "app" in G && p(0, (k = G.app));
    }),
    [k, v, x, S, I, F, L, U, N, j, R, q, Q, K, V, H]
  );
}
class MediaPlayer extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2b, create_fragment$2r, safe_not_equal, {
        app: 0,
      });
  }
}
const MediaPlayerApp = {
    info: {
      name: "Media Player",
      description: "Play audio files",
      builtin: !0,
      version: "2.0.0",
      author: "Izaak Kuipers",
      icon: logo$4,
      hidden: !0,
    },
    size: { w: 442, h: NaN },
    pos: { x: 100, y: 100 },
    minSize: { w: 442, h: NaN },
    maxSize: { w: 442, h: NaN },
    controls: { min: !0, max: !1, cls: !0 },
    state: {
      headless: !1,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: MediaPlayer,
    glass: !0,
    fileMimes: ["audio/x-flac", "audio/wave", "audio/mpeg"],
    events: {
      open: ($) => {
        if (!$.openedFile)
          return (
            disposeTrayIcon("MediaPlayerApp"), closeWindow("MediaPlayerApp")
          );
        createTrayIcon({
          onOpen() {
            openWindow("MediaPlayerApp");
          },
          image: logo$4,
          identifier: "MediaPlayerApp",
        });
      },
      close() {
        disposeTrayIcon("MediaPlayerApp");
      },
    },
  },
  logo$3 = "./assets/messaging-9e309b2f.svg";
async function deleteMessage($) {
  const r = get_store_value(ConnectedServer);
  return r
    ? !(await apiCall(
        r,
        "messages/delete",
        { id: btoa($) },
        get_store_value(UserToken)
      ))
    : !1;
}
const MessagingUpdaters = writable([]);
function messageSubscribe($) {
  const r = get_store_value(MessagingUpdaters);
  r.push($), MessagingUpdaters.set(r);
}
function messageUpdateTrigger() {
  const $ = get_store_value(MessagingUpdaters);
  for (let r = 0; r < $.length; r++) $[r]();
}
const messageSidebarActions = [
    {
      icon: "add",
      name: "New Message",
      action() {
        replyMessageId.set(null), creatingMessage.set(!0);
      },
    },
  ],
  messageItemActions = [
    {
      icon: "reply",
      name: "Reply",
      async action($) {
        replyMessageId.set($.id), creatingMessage.set(!0);
      },
    },
    {
      icon: "save",
      name: "Save to ArcFS",
      async action($) {
        const r = new Blob([$.body], { type: "text/markdown" });
        await createDirectory("./Messages");
        const p = `Message from ${$.sender} - ${$.id}.md`,
          v = `./Messages/${p}`;
        await writeFile(v, r),
          openWindow("FileManager"),
          await fbClass.goToDirectory("./Messages"),
          setTimeout(() => {
            FileBrowserSelectedFilename.set(p);
          });
      },
    },
    {
      icon: "delete",
      name: "Delete message for everyone",
      async action($) {
        createOverlayableError(
          {
            title: "Delete message?",
            message: `Are you sure you want to delete this message from ${$.sender}? This cannot be undone.`,
            image: warning,
            buttons: [
              {
                caption: "Delete",
                action: async () => {
                  await deleteMessage($.id),
                    messageUpdateTrigger(),
                    selectedMessageId.set(null);
                },
              },
              { caption: "Cancel", action: () => {} },
            ],
          },
          "MessagingApp"
        );
      },
    },
  ];
async function getSentMessages() {
  const $ = await getMessages();
  let r = [];
  for (let p = 0; p < $.length; p++)
    $[p].sender == get_store_value(UserName) && r.push($[p]);
  return r;
}
async function getReceivedMessages() {
  const $ = await getMessages();
  let r = [];
  for (let p = 0; p < $.length; p++)
    $[p].receiver == get_store_value(UserName) && r.push($[p]);
  return r;
}
async function getUnreadMessages() {
  const $ = await getReceivedMessages();
  let r = [];
  for (let p = 0; p < $.length; p++) $[p].read || r.push($[p]);
  return r;
}
const messagingPage = writable(null);
messagingPage.subscribe(() => {
  setTimeout(messageUpdateTrigger, 100);
});
selectedMessageId.subscribe(() => {
  messageUpdateTrigger(), creatingMessage.set(!1);
});
const MessagingPages = {
    unread: {
      name: "Unread",
      icon: "mark_email_unread",
      msgGetter: getUnreadMessages,
    },
    inbox: { name: "Inbox", icon: "inbox", msgGetter: getReceivedMessages },
    sent: { name: "Sent", icon: "send", msgGetter: getSentMessages },
  },
  pfp1 = "./assets/1-ce0ed19a.png",
  pfp10 = "./assets/10-a17f4986.png",
  pfp11 = "./assets/11-0772df5b.png",
  pfp12 = "./assets/12-e9d77a32.png",
  pfp13 = "./assets/13-0dcda114.png",
  pfp14 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAALdElEQVR42uzRMREAIAwEsAcZ+LfCgg8GXKCi1yWxkLHPu0lWWjBTAgECECAAAQIQIAABAhAgAAECECAAAQIQIIDP3llHt5F8Wfh7Vd0tNMiWZcbQMC0zMzMz47/LzMzMvDvMzMw8GQyzKZYtVne99bF0frYTZeJkd8jWPecmZnjfg6o6Ktnjg5YIp0m1XQHvddDVGFDFVCrYxSW8hTx2qYCpVEG18X6RNoD3ItuD49P03P0gI3/+D0z+8u+y7Wd/jW0/t+xf+g0mfvcPGf7nfyPz2OMEs7MAYEy7Bf1/BN8WimTueZDsrXcT33tgJdtFHRgBz4AnYAUNLC6dpDI+ysInfSILn/wpVIaGQARU2xVwPsH38osM/e2/MPJnf0dq95vYahVrBLEWXbFp/m9BZKU1pd55m6Frr2bqT/+A3N234y3mQUwbwLkGX+oRfdfcTPbGOxo93hiKIrxglD2iOAAF0BZzwpE4dJDhq/+T8X/6G9Jv7QbVd58PbQCCilmxCSv07H6UvjvvQOohIkIF+APf8TVBxLcGjkeMYgAQWPc/QAOERCFdLz3PxD//NX0P34uplM8EoQ3Aq+TpPP4qg6/dxI4Hf5+pZ/6SQOdBBAGmBW6wylGBF41yp3FEcnaoGCGYm2b45v9h+Jar8RfmW0FoAwhKc2T3PMjIi1fTu/dh/GgBkwUABTqAnQ4M0AnsVMGwQYnBVCv0PX4/Y9f/K/HjR06F0AZQ6pnk4Cd8D2997k9z7OKvptqZQ7IKnqJARuHX6obfWfaf1yxfHwkogG58OescXa89z9gN/0zq0J5TIbSHcOQnyQ9eyv5P/sEVEPNXfSakfVBFgV0q/GRo+OZI6ERQAIQNSwAgve8tRm/6t+X/3wCkDWBViqhDjWVx4BL2fdGPMfdZnw0iALimI0A5F+n6ShAheXQ/o7f9Bx37dgPSBnCqxDnqHd2c+KZvoLx9EpzjvCSAyOksxJCYPsLIXf9Nx4E3QKQNoBWEysQos1/+RWgQsGGJQs3BUh3ma3CyBqUIIj1tLsRnjjB839WkDr/TGkL7LAjyn/nJK1Ugzp21zUhCMX01WCjDiWUfX/bREhwpNV5eqn8MhNKshBOHGHngmuX/D54GoQ3AKbVcH/lP+QT0bAdsRrGjdaS7Dk7BrWETOShHcLLaqIhatK4Sksf2MfzwdcROnlgHoQ0AUGsoXHUZYWfHmQ/WVJCUIt0RCmBpLQWqESzWkYoD9GMQOg6/xdDjN+MX8mshtAGIUyojQ9T7+5AzAWi2H7UKFiR2lr4WKZRDqLrVtwFd+15i4Lk7sNUyiNAG0FSUTlHry8K7AfAUADwgdTaqgCpSc1B36wZ/z5tPkd39MBKFANAGoKjnEaWTZw2qGMAA3QqWs0sVCRWiJgQRTFgj98oDdO97AQDaAARUkXp4ljIRxDZBZIAEoGf/2qq6ZnenIIJXKTD44p2kp/eCSLsF2XIZf3YekDPucrUmiAhigBRIDpANAgZQXf2SIsTy08sQ7iBYmgORrQtARQhOzBA7dgKVFsFqSquAA/EBAzKikAKUDUpAZBWaCOkTexjYfS+2XgFkawJgBcA0tlKEhIWUB2kfkhYCA0ZAFKqClgUTAwToBJlQ8DYCQQFAAE+AplEy+5+nZ9/ToG6LAlDFKxaQuEAmBtkYDCRgOAVjaRhNQi6BxnzcosV4YAIAkBGQMQXDRpZFgICRJgQAMGGV3FsP0TGzB0S25gyQMETWHq4ZwBOIW+gKYCiBTnUQJTtRNdgEiAd4INsUGXNgAd3ALBAB36xCEENQPMnAm/eu/I/I1gOgnoe2mr+6JnYxg4slcS6OeGBTIBbwQSYcMhlCUgEFlTVdR4GmBQAwTbhmFUp6di+5vY9gojqIbK0ZEKWSYC3r1BKIIQo7ULWYAGy6CcGC5CLMZBXpq0EsAgEARaDpNVqtMKEppefwc/S+8yS2WETFgMjWmAH1TDcuFmxomEYuQaQdACsQvE5WB3PcIX1VTH8BySw7VkJMFagDEahbX1YJ27AIINh6maFXbmf8un+g+9UXMLUqKmZzAxCg3ttL2NkJ6IY+I9RuItIAiAdeR8MmAAzgOSReRZJLmOAkVmYx9ROY2iwSFoAQUBBZXXE1ZRKO7uKbjP/X3zJ6w7+TPvQO4hyIbOIK6O6iMjyE6EYAKIqlbvuIbCcgIGBijWrwO8GmwcRBfBDPISZEtIZEFcSVEa0gJgIDWIGUB3ELACLoWBqvK6T32YeZvPqvGXzk5sZRNoDI5gPgEgmKu3ahxgLKRqT41IN+6okcamMAIIr4YBPgpRswvK6mO8EmIqzUMK7SAGIVfK/hlAe+ARQCg27vgrRPsDBL/5N3MnnbP5Dd/Ri2UkBFNtkqyBgKl15C2N0Fyoal4hHGe6llxql3DxIlOlHPBxUQAQNiBLEG8Q1m2VZCvGoRm5/Hzs1i5heQQhXqCiIAoEC3j06kUWtBlcTMQYYfv47xx/6TzuNvIi4Ckc1xQUNUKU1MULjwQjLPPolybkcMzovjkknwcphaDdkzjxSrqBUwFsQ0Amksag2IBWegatBIoFIDzzQtAIDAUAIWa7AUgggmqtN16FWShaPMb/9EZic/mVqiB9CPNgBUiZJJ5j7zs+h48zVsvQRyHg9NsR4u7UNWYG4RhDWbLgMiQPNlBESacHyE6JT1r0LMwmga3VtA1AEKIviVRfr3PkS6eJATU5/FYs9OVCygH907YqLK0qWXsvDxnwgAel4gG87GoNMDtGlavAyoUuoZ4fhFX0AYS4Pq6V8vE1D4+CuYu+TTqHYPNGGxAiS9sI+xt24kd+gRbFgG5KMLAFVcPMH0l34ZpYmp1Yw7HwUGemMterSsAe6opXs4dukXcWLnZzM7+SmoOfVkT0AUm64z/SlfyJ4v+WEOfso3MTv1SZQ6hwj9FF69yODBB8gdeRzR6CMMAEAd5ZExjn7NN1Lt6z//E0oBugLw5EywV4J/9MovZ3HoQtR6zGz7NPKDF7f8YsnCcTKzr1DtzDK37RM5dNXXsfeTvpt9l30rh7d/GdPDn0I1ngF0E9ySVGXx0ss57L6N4duuIX7yOKqGc1bcgm+gthaigkIlM8zRT/hy8mOXAAKqKy3o2M7Px6/lSS0dBOy6xMhMv8xC9iJK6SHUWGqJDNVED0tsB9XNdk9YWLj84znwLd9H/oLLUGuRc6kGBaw0vOZxqc4GLExdyYHP/nby45eCyDrwlY6BZQhfRDWZXR9UEWKVeXqWIRgXAYA2viaqm/eidmFqFwe+8fs58oVfT3FwArUeotqEoatuNbWdIs41Au8FLA3v4PBnfSMHP/tbKPWNnZHcUu82jm3/QsJYB+DWAeqa202sPPOe7oY/fE9fLwKqBPk50ofeouPomyTyx/DDAtbUER8ITMOx5uU+Y3EVQ/2wUMqOsjR1EYXRndTTXRu6+C3q6D32HIP778ELS2sCLhyd+HxOjH7mFgKwFgSChDX88hJ+aYGgkl/ZM1hC1EC6O05oA/K1gNBLU7OdhMkOnOcj6Dm0C0E0JHvsWQYOPoBfaxw/iDqWuibZd9G3EPppQLcQgFNgKAKAAKCoQi4bJ3IwN18F4RyD3gpCRGbmZQYO3E+sPI8AoZ9kz8XfRmEZhKjbHEcR5yxVBG2xGW4GXB3C/1WKimE+dwW1WIbckcdI5/fjjMW48P28Kd9WoWuCcqqfRPE4oo5Sx3Cr7G8DUAWU90BK5CVY6p4COFPw2wBQBXkv77hp+wmbWsnzDNneGAO55LIT9GXjxAKLCO+12gASccvwQIKh/iS+J8R8s/xygtHhFD3dMax9Tym0W1C97jg+U+H4dKXF/q3hj5Laf8it3YL+tz06FgAAAAAY5G89in2lkAAECECAAAQIQIAABAhAgAAEDAQgQAACBCBAAAHVjZKnIJJ7jgAAAABJRU5ErkJggg==",
  pfp15 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAO9UlEQVR42u3cBXAcy3YG4P8/3TMLlgwyM+g+vMz4mJn5FYeZizlUGIaiYFGYmZmTy2BfEDMvDXT3iXekzZPKtsC5Wj3YX2MxfnvO6d7RyPyDH1X0cuMIeukB9YB6QD2gryygXnpAPaAeUA+oB9QD6gH1gHqx2NOQiiKq7AFtCAkN6hw1AICNQVFoIdUDIjWEttA97/8HEiNPv3Zh4njaNMbCRCC/jKTsXuloCPd96G9P3faCejlz6+Xa7MDUixcmrlxcnj7sc5oIxirahnvM1Dnl2n2dD//NqTde1mYFUBKIHKzTNF6cPDZx+dLUS+frC32qsDHE7GVB2S7rqG7QoQQU0dwiiyhh4OzEwIWx1zeqcyOnxl+4NDt8plUrkd0fUl2voEIHPue9H/7rM7e/oI1C55qoEkoajygHkCzvn3753MTli/PjJ7JW94dUAdRNnXs+8Hdn73y2UzubZXX60BZSwWwcUujWkCqAuqpz17M3qh2QAAGFFgdZOFGVpO7VkLJfJjqqQZ3XoBSRKII1cL74eCV174ZUUUF7qxNU1WXqs5CnvpXkjcxlWj54sHrqGLzfYkgRydKuDqkCaA91VMHYQ3JXy1vLmWulxrUkrTemV6IjpwbufC2cA7ndIXWlGFIzA6/iTsrusU4Zk8P4z3/E6MtSX4q8k3IUHRuIbh8Mh1deap04UjkxgPz6RhQtKtBqYgntP7zQf2L2lgee6Aypc/WFflXYCJQvMyASHZ2/PXvXc9fXCW2dZ/8r/PovuqSlRkhQPZczGR0qP/HEyffe3XjsoeRG5xtUV6d5UHVCIoqgJW0EmqtDanzgwujrG31zo+fGL79mdui4SwzILxsgopgqvOu9/1jUTvUGUxm0uPJsWFrEseP0ToOHelhBHOnMqJtxp+Mzh0Pq5LrlEwEm0KfaaDWXEp/6yqFD0aGD8EZdFXmwpnbi/N+eOPVLK0PxP/7FT3pfJhXgXgMR6OhcuO+pG+i0QwESvOODptHQF55sF1Fwql7VqQD3v7XygW8+hWAIxfWyOKvLKz5paDWSowcA35p9fK7/7NH+c31ojGo6rulMyBrG1EUvqhp2ocV2rrPZbpAEPPr6+flvjCaHzcjLfmU+eB/69vPcoD37mogK5EpeZz/AMv/tH/BXf2RKJaWGo0fitz+8fFKenPuHxepjVZocStDSRIxK+cpACIYEwJsD6r5OJ4Q6wOHkeTk5aIBOPDRRBTo62j7aMZCIYpD7936sdqBv9k9+U0Ub45fTX31OP/7m5tmDNe/3RXFFg3YGlXOupEFoFXrzQN3XKdIh0LQtgo4GCYp2aASMQAMofEuTaSTjmoxLmLn7Uvb38T21WlSphEa9/M+Pv+GLH/x3WxYNAWsRUL3bFxTFx99M7B7qrGfaWCwEbYFChAz5nKaTbZd0Cm4ZmgPiEJUrevpM64nHq3E1McbX6nHldJ8Y+Hz9khWc6ytsdBdarCs6gELXygaMAWkTuJpm00jG2jT5AkIKALTFEQFKBeAefWTs8gsHarU4beLN71nsO2t8snFBp7q8T9fou19BBKF5yjve888X7nuys2ZtJ1ocWOsgsUCAa2g+jmQc6bhmc/BNQEHTRpHKuo/S1aLzqbl4cfnbvv3xoVf6q5X8jbcthsyQig1pA0H3YKPY0Ul4+7v+9dL9T2xDZ/1Yse0DQEiQTrXLJB3TdAa+BvWAtMmkBLAjEq7bmD6XY0ebx07VoQwtc90eyl0/0H2gdTqDD/6PNss30lk3VkyBItAMbqk9UJKx9uN8EZp11KKiy3TdceN0jDQzAEQU1wld1tdloGt1irlzXRQIJAIM4IuxMlPM2gnk8/AtAGtqrK6rL935gFfcKMrclcEuAt1Y50YL81RnrMzCNYBQoJiNYyVsa2oRqlQFqeQ2x79xeZUAwK4AXdtZ9NcszCmyOc0miw6aRmdhLmZtvHGs7CC01ABjMsRQZ0PGLY24CuT2daeC1um8818GH/zvonYIKa1bmKc6HbR47cK87thxKEzms9ZU/YUXjy4mB+9508qJs4lPZQsjIrQraB/RHSBFlvCOq7XzyNPaHKD1cHVNZ5FMtF3yzRfmmw+F6YrL5pb/9YnBP/unWxH0X/8n/ZbvevbEyabPNzcK6mPvq2QXWowaHG99+5ODD/23LjaQPaPp+E4W5puPKkKW5VHf/7w0WO335bJbWiz/8z+d/PjnrmhmbjyhSQbfBmq3mO5qBZEhz+TY6X957eu+LbxSRZ5Ckx0uzDcfDRpXuVSv5N5GMQJsqYKVegmBW7VYCCH2rhjSusvXB5HwOXXpebqJtTVISqDpFIti10ICNho4mvfvd65tpLmzJ060IKq6iSsI9a7sQwnc9QuoSEGWnlI9StGNw6UrEVver+9+11AUa71eunBp5ZFHxpEaUjfzYXC+osHs+gxSBYk8G8jzvlJ5CV2PiIYsuv2u2WMnWvPzlQsXlquVfKsJDVCdKwVvunHSnoTLK0l6qFSdUQcS3Q7hU3v8WOP4yXrIzJY6nXMd+4LSUlW5yy1G9d6k6REw/38uSXqzrUmqz8W1rAZsQ6dosbxPFYB2YR8Ugpo0OVEAKcAdf1UFDcVQQSiCCxpUBDd/z2vrqHP7VLv1u3lVZK1ToL+5G0RiyWoumc9sSG3FxEdjVK1vGopil9KuuD50q4KUQKt1srOuy053w/PP1Jav1Hwanho6Nzp3tO+gPvaBpdfd2/AtS+6WUZ73A12qIIJIkiNQQ3hs/yy4gpYLz9eWXmrEffLnT9/39CvnIuv8Ap/48TNf/PqXHnjznG/a3akjdXm/dutCcnIVKMSg29HcyZbz5nw+cE6enbr0zMi5A/uTcsX178/L/fyD3764NFsyUdBd8ZHcVdk1ICGy9ERwFTIHuG1XZPW8tF9Yjl4YO10uexiBMSqmVNF6q/TsMwMo+d25/ElcXgG70mKqgCDPDru8P45zDdsjIjQAwlK/5D5qZGVbAg1NwUEDibC4WMauRKGSd86WdaGCIMRVnSw/CMl0J1/SlsVUTLyPUQyKiBEa0rL92IiNFPqq4xAqIcTF2bJutRio3tk0OQxmALd/O9qyYWT7D/rjx5tejbFo0wjFUAxOn20g8NVhUVE1qkKTm9IibdP7KrvSYp12CUyS45B8R5VuImMVtPrIwxPPvHDcB2OiNkm9Fp+/sPL61y2E1MjNr2JUFQCkN7YJkyKUkubJhfk7ZqYebdQuGWnDdQMIUFVkyUkgx45CRLHJPQdft/Sxj17+0z8bTFoWwLnztc985nlrg88NqTstFoCAiuQSJaAP2YGlxVvnZx6Ynbl/aeHOpNWviiju1HqXgICkdRpUQHdqZKz4XB58eGLwlqWx8f2l2F8aXCpFfic6VG0fIt5ELUiKYNPW8cWp22enH5yfva+2MuhyocAYRHEAVNUA3QMiiVbrSIETsPOQ8Gl0ZCA5crwJZUjNdnQKFCFVxEmcQHxIq/Nzt6wsXkV5YH7urlbzoAaIabvEJd9xFBTpNlDa3itGhAdk+5tphQBKtg/vRPO134WSukWxMBibIsoQJKkfnhq5e2zkntHRuxfmLwqPHOg3/X0olVQ1hMDio8xeXkheAB3XUKI41dLWQKqgpQkiNYTY+zIQVpk2KxZATC5xCnGaVxYWzo6P3T4yfO/ExBtrKydCiK3NoyhVTC/X2ExL/dVKtVI2hqpQxZ4BqZJEnh31+T5rc9Xy1qAmhl9MVuJG+lilMrbv4FBwFfWWDNcsz6vFkuHqAWSNg1Njt40O3z08ctfc7KWkdYCEjdIobgmbgBSHJZnnfmG5Xm8k1Wp5X6VkjABQ3bsKyvNDWX7ARrXCawue5uxLS9MHnnvlFydn70iz6Yu3/O2jb/7Zctz0PuqsRDDGSdSEydWVlhZPjY/fOjx0z/jYrctLJ50vGeMim1Yqy2AxVgKDCEES2ml7IUMItUazlaSVclwtl6w1HaauzyDv4iQ9VN03D3CzYjN2ZWIkmZt+fuRnXx6/O/hx1fjx//7UwuLZj378+w2V4hglgOatAzOTrxsduWt4+O6ZqcFm86ACkc1slMalRNf2xAY3vjlUlXI1hGorybLMleKoXI6tMSRUu1pBwQVJk6OQ53DDKI3JmvXW/ESuR0an7gh+gYwB9O+fHnrpocf/5+P3v/nnV6ZeNzn1+pGhe8bGbltcOJPnZUoe2bRcWekUF0MQ7GDPrhCRgjHNcud9ZO1VKWs7TF0AAlQDstZJbHKHXkFKWlsh4MOh3B0QWfv+vI/KlZWnn/jQxPitE2O3NRoHg4o1qbGpjRJVaqAG0+kd7Di61vdtJ9J730rUWhNH5mq6BQQkrVOAxw2ikBAsfG4NJiY/6EPVsBlAXW0F42q1o1dLxkStUrleiFOVQc3aR+88JNdESa63EoIaQshyNUGtkavZbSASSJJj1/7WcHVYkEFswlLDlPgfl3/oysQPGFlW5boLPmmMMyYLgRqk+MBtlz83MKy3AICggQSFAhaFtPqCMVKEXbrKlUTSOgo1QFh3X1GNSRG12ivRwi0jw2966cW3zc7cGtnlENZk1t+0CrOOeP1bCSg7ngS18yZtB4SCIFikABAaEWvaENashrIattPNVayzmU6PBVcGoGrEpGJbUFNfvjA2+sjwK2+bmb6t1eqnSeJoyQdRYJVyPcE6EoJKLQhWFdYefenLCSmy+vOLFWOtMda0H1kxIqb9iEU2SHd5mV8HJMjTo6AzpXlolDROTk0+NDL0junJexrNA4pgTKNSWfQBwVswUKFY27V0HKCqof0vaKdBWMS0w8KiDRFZa420OURkFULAjQTrH+ue/82q6uq9jZOTYx80Eo0OfWhq8sF6fSAEGJOVyyuFC4OaoEGhGgqIVYrVB1AIMfJ/RWEKC1NUx+q8IEGuQSg6tFo8CtDO6/ll+3fzqgihfTgHkQAm7ec9Q/BB0cbQtTohSaEhCw+x0mmJ9gPXKVxTDvjSgCL2MvZmUAlrtRjMzrelrAhjAjQsIlyNyGpH8Nqm6BxYy0aFjR/1lQbUWdRBkVjkBps6haJDoDe2RvfTFaBrvPAVkd5/0dUD6gH1gHpAPaAeUC89oB5QD6gH1APqAfWAekC9/C8SKX7bqPpkgQAAAABJRU5ErkJggg==",
  pfp16 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAANoklEQVR42uzRQQ2AQBAEwdkLHgDvaEIGTywcqwJ4VCetoOq6jzPJ1s/o9ZZ+7fd8kkYEAIAAABAAAAIAQAAACAAA/RVAAKqS0c+nvbOAbmNJFuitnhmRSWbHYXzMzJ+ZmZmZmZmZmZlxH3OWHmM48QuaZFmsga7/t4/XXp9EcdZe1lyfFh/qq+rqqtMaKw5JBbzvMEI8t0Dt/v3w2KtkXj2HzNdTAe8TBFqvHGHmF/+E+D/eQu+JFj2vNujZf5rgZBk0FfDeQQBV6vtfYOZX/hR7+Axj+64hO7iTzOSnkw9upvBCmWBq4YNOgs8HA1apPfEM83/4T8SzJTbfdCeFoVFsVEdtC3/4NljMw0tvpQFE2wdBUgHvMWpPP8/8H/4j0bkSPWPjDO3cB8ag0QLR9Jtg5F78gatAQ3jpGRqeIdo6kC5BG0aE5guvU/rjfyaeLmF84yY/09MHqoCgUYVo9jGS2hH8wSsJMnvJvziNP10DSQWsHyOEx08x/8f/QnRqGhXI9RcpbtoG1oIqDgSNa0RzT2FbM/jD1xEko+RfOItXbq1LQipAhKRUofQX/0H74HEwIALF8S1kMzkII4gTsHZFQrhANPdWIMEfvQ6/Ysi9dA5pxh/QErzv/N5P+U6gjw8UBDRKKP/T/VTf9CRYBYEgm2PTnqvJ5XvAKqK6ShgiaFQF4+EP7AQbwvQpBEjGekAkjYBLQ2g88wqV/3ocjRMQUIWeviHy2R60HUIYQRQhYQhuRBDHYGOShQPYxjRecRcmUyRzeI7g5GK6BF1ylTs9R/kf3kSyUAHBYYwwMDCCnyi0W9BuOwFYEBMgmTyS70d6hiCfJYmnkZ5+vPHLMARkX5/HW1wzH6TbUI0SKv/7JK3Xj4JhmSDI0VccRwbHkNFJZHwzMjyBFIfcRJMtIEEGPAMIiAd+AS/ejixeQ9CoIn6NKmdQolTABTGG9iuHqT6wHxILgkMt9F55Cz1f9UP42/YgfUXIZMF4rIXQgzc4DEBBQ6LGfprhEUBSAasQwTaaVP77cVfpIiwjnqH/7k8kuOle1kQV4IIJVyRDT+4qwniaxFYBSQWsLrgOUH/by6xCwe8v0nflLSwThWijBpUSuriA1hahWUOjNiQxCOAHkM1hBkYxoztQXyAw+Pke8sFuauHLoDYVsPztrzXc0mMrdTCrv9DZ8W3kBkbQV5/DHn0NfeMIOnsGrZVxk24TMIAxqGfA83DD95G+YTJXfDhKm2j2oFu+gtEi/q6IuN8DBSAV0HrlMM0XD4CwGoF8o4H8wS8Qz5zBffNR8DzU98H3cMNzjxHrgQVVQBWtzGPnT2GGNyGVCnZ6Cj0RELQniW/eAka6vBAT3L6+/Pf/S/u1Y2DOc8Ow5OirNSBsgyosISii4FBdGe51RQCsRYyHN7wFbVex1RKiYJoh8eQA2pPt8jpADOGJ067hhnAeRgz5IO8mEZGVyU4SiOKlYsyNpeJs9b1EEVqeRhtVTL4Iibr3TKlO5sgcWNvlAqyl8fZXiOfKFxTgG5+sn+m844mdiOXJluXJXx4uSWt5BskUEBMsvx4cmVkqzqRLBYiQlKs0nn0VrLIaUCDjBfhegKIXlYiLiAii1dHg5LRa2FoJKfRisj0Qhu49b7aCPzUP0L0CwmMnCadOg3BBMl4GTwxrogqJPT8awhCMj9xyL9z1kZhte5Glz9BsExyeQVoRSDcKsJbmy4ew1QYI5yFLAowYLpHV+cHlhhAxPmbrbhgaRfZeCxjESYrxT5XwZquAdJkAEWy9Qev1Y6B0JOMH65ZLHDsRlObRqcMAyOR2JNcDrSa025hyDX9qDlS7T0A8UyI6dQ6k00cMgQkQhHVjPFDQE4chSZDBUcwVN2H2XofZcTlYwT8+i4QxSJctQeHUWZeEO2FE3C5oXXg+5t6Pw//GH8H/zp/BfMSngAjkCvif87UE3/yT+F/7Q5h91+KdmscsNgDpokrYWsI3zqBh5wRoEHzj8W6jCn39eJ/weci+qzmPXB6iCOIY2iGmVMWbrpCMD4B2QwQIaBQTnZ4GS0dEDEbWIUAE6jXs/gexzz6NfeoB7P3/jE4dAUBPTxH/zk8R/+L3oi++FdNo451dAO2aJUiwrTbx7AIIF0QBIwZjDLqemYlCkv/6O+Jf/j7i3/xR4j/8eexzTy1Hn77yDHrgRWg0oB3hnStDnADdEgGNJrZSozNOwMYSsE2g2YAwhDhCZ6fBWqRvAAaGQAyoQhxj5ipIlIB0SwQ0WthmC+RiAsSNDSHiBgoszjsRZPNIb//qxl61ibQjQLojCdtm2yXgiyNsGOOBAIiLBpIYfB96+8HzQASwrhqWKOmOXZAIaByjSbLG5wRB1r8NveujMVffDAKowuAIBBknxXz8Z2NuvBMtz2Pf9M9IVIc4AQG0CyIABfS99P1Xhb4BvE/8XGTv1VwIJ+YdIwrRN47Dy4+D1S6qAwQQ2aCjDghQr2L3P4Sp10AABfI9yK7LwffRU8ehNIMuzKPHXkeNASPdIUAVTCZAfG+Nz61XgeC2of/5tyQP/CsIYC1m95X43/PzUOgj+d9/wD7232AttFowOYgGHmiXRIDkckgm4GIoiqpubBvaqC0/VhuD8dxjKmUXJXgeAJrPQOB3RwSgiunJYQp5UEA6fcyi6MYzvkOQQh/4PiRL9YEIIIDF9ubQrA9odzTjTD6HN9AH2nkZt2o3FgGqK/dqXWLGDyBsoZXyyvsIdrgPDfwu6QWpIrks/tggCB2xqk7Curainoe5/SPwvvRb8T7nqzGf+PmYm+4Cz0ejCBkYRIbHQAQ8cY04PAN0Sw4IfIItE2AuJsCSaLI+wb0DeJ/+Jci+awBWnX6Q4jDeN/4wTJ8h+fNfIznxGsmmQRC6JAIAjJDZPolks6CdBcR2HQIEtFnHPvMUevhVt+XUxRLLiDgJsnMfjExgBwrYiWI3dUMBhWDrJvyhftDOu6AoiViXgbBN8m9/TvTT30b8E9/kvuk062At9pH/cN3R+Pd/Fn3hLcTbRrHFAqh2kwDFHxkk2L75onVAmETr3wnFMSyW0Okz7kgK+QLUKySP/Cf2v/7WidBmlfiySTQTAHSXAFPIkb9yN3jSsRIOk9CJ2BCFXuTaW8F46KkT6Jk3wPNBDLbYQ7x3AqRLzwXlrt6L1995O9pOQqxaNoLkC8jIBAD2lWegWgYRUIh2T5CMF0G1CwWoktmxmezebR0FhHFIbOMNSdbaoms9JP/+lyvtBwXNBkTX70BzASjdKcD0Fijceg0SeBcsxmIbuzwgCOsmjrGP/hfJX/wmbvkRAVWSLUNEl02CAnTt6WjI33gV/qZRsJxHogmtuMV7BLUggsM3hDfvxg72gGoXC7BKMDlG4dZrQS68E2pEDdTGsI7uaKeji8lEkfCGnSACdPkvZCTw6b33ZuqPv91dCQtZPV/NwMfuuRJvYR6tliEKV/VxEOhgDxwKCPgB9PQh45sI79tJMtYPqqkA1JLds43C7ddR+a/HzssDLV+IP++ryQ5NuLM9evIYeu4UujAHtUVoNdE4Aqsrla7vQzaHm/DiMO53xVt2Ilt3E43laHvPA3U+EHjHP/E5DUzy/sQYWq8dYfqnfp94Zh6EZcTPsOf7fpfxT/mKZWGEIbRbaKsBzbp7jLXLAshkXeEluR7I5SGTAeOhJFQab6HRPoAjFbCCJgmlP/s3yv/4JlBdlTsnPvUr2P19v4MJsmyEVjTFYv1JrLYAgfRaEatzQf/H3k1251awrKL67OO03/SP6IGX0Nmz0Kgt5QJ78YQbR7gImZshPnuIeuOlTpOfRoBDcNeKmP+dv8O22iArp+R2je5heGQrDAy6Y+YMjiD9RbfOk80jmQwgaBRC2IJ6DZe0F+ZcN7Rx704ad+8EoTPpNePE7YhaLx6k+vBbVrWmF+slBv0epFxaPmgLAvLOYUAAq4CCWlAFq4Q37qJ17TgYAdVUwMWr4x6Kn/1xtI+dIvz/gcFRbVdpJSGFII+iFy60lBXELFW8gzQ/5RZc0WWVtUgv2GQtmd1bGfz8T8Ab6AXF0Y5DKu0Kil6yTO3N0fykm4h3jnWY/FRAR3ruupH+T/0Il5xRsCilZpnIxqyJAoFH86OuIbxlNwjvFqkAVSQTUPy0j6T3I24DI4hCPaxTbVXXbs4ZoX3HZbQ/6lrUCUwFrC8fDPQy9CWfSs/t1wNCYi1zzdKaLer2dVupffINxD0+1saoJqhaQAFNBVwyVvHHhxn+6s+icPNVCLgIWGxVOkiD+r4iZz9xC4v5BeqN0zRa52i2Z2lH87SjMlFcI0maWI2cGND0spUXRXGHuHKX73Q/a2qfOkuUxBRz/XjG412p7Rtg+lN3EY7nUbVugAWxgAIWRUGWXudd+kdIGgEdUSXYOsHIN34+/R93D3UJma3OoqqIAgKVK4uc+bQdtCYKoCCACMjyH4DAEoqCrtQLoKmAS1uOPpuhr/gMFrf0UsklNEeynLtzhJOfso3WaA5UAVBAFRRlZXq1wzF5N9JWxCUhAtYSz5dhsUaSSaj3JiQmAbVLhbHBvHMYDyO+uxfxlx77y49FPEDSXtD6f4CnqCpoglULKKoWlhAEWfqsYICl50jajHvvIuDQ9B84vH9QziMtxFJSAamAlFRAKiAlFZAKSEkFpAJS/g9M6LHIZJg5/AAAAABJRU5ErkJggg==",
  pfp17 = "./assets/17-662a7167.png",
  pfp18 = "./assets/18-240e69f8.png",
  pfp19 = "./assets/19-42714701.png",
  pfp2 = "./assets/2-73afb162.png",
  pfp20 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAOI0lEQVR42uychZPcSJaHv5eiwgYzz5hxGJeZmXkDjinwmIPv/oNjZr5bZmYettfUbWpjQ3FJyne9itqtCnVry/b2gOz6RWQolI31vkeZAtFfeaHydGmkWcPTqpFGAEYAniKNAIw0AjACMNIIwAjASCMAIwAjjQCMAIw0AjACMJJL3qQMkQUEREYRsOLygfHsoVVDZ+tewjWb+wBURxGwUtIDgj1oMkMjim9hdvz9BEcP4zQX8C6dITj1BBJ1kbDTgyIjANclAR0TmFw+DSke9eBFyMWI0uFv0Ljt+ajr09z/IMH0YxROPopZhGI6TRAzAnBdimM0UkRZRhGl1ucJp3cTrt3K+Bf/E6ylcfsiCMfjyqt+htKjXyI4cwR34TLSbV01iBEABVQh6kInREmnEgXAX/gOtruWxu4X4p87hn9hmrGv/B+2UE48X72AK6/+Wca++gH8mRM49TnQGJARgGWNjoJj0JKLTgbE6x206qLGA+Ni44i4VQMsgsUUY9zWI1QO15l/3luofPczFA9/HdOqU37o88TVSUyrQXfdNmp3v5TJT/wd7twFxMYjAIOGR0DHfeyWCvbWKnZjOTnXggNGAAEBG7YJQ0AtAFRB7rOorWErM7TCbSAxhemHkVaUeHzpsS/R3bgzgVK/5+UJgOo3PgKqT0vr+vTflpIyfOLp+1ctjkns2gJ4BhBA08U3AdCtXQK1LJVDJ3gNROOUpj9AcOQs3lQD01RAUdejdt+r0KCId+EUhZMPY5o1ELkJb0tRkjQT3buO7lt3Eb5oM3ZTGVzTz//KNSrG734GR75Nffe7qb3oXhovnSDcHqCuQaKIsa99EP/sUWr3v4pwzRYw5iZciCnYjSXCV99C+NIt2A0lkJVZQInO48RTuOHDxP5mmjtfT+PFa2jfX8RWDFhLMPUY45/9F+q3vYDmvgdB9SYCIBDvnSB8/XbiA5PgmhU2gEG0jhd+HmPnsDJJt3IHzbt20XxBlXiNh2m38GdO4rRqxJWJxTF5kwAQiA+uJnzlNuz6EihPogQ3+hZ+92NE7r1E3u10t08uQhgj2uRj2g3GvvK/dDdsX6wLr0RF8g9guPFXEb5kCzoePEVhbzF2lqDzP0BEx38b4cZVNJ9bJl7nYTotSr2WNVq18QYGoBDvGCd80RZ0zB9u/BWHcDapC0YvEzmHCDdsofnsMnYMghOPJi1q49BzQeQGBKBg1xWJXrgZnQiepp1KgxMfxQ2/SuTeRWz2EG2u0rq3gjhdyg99Fqc+jy1WQPUGAqCgBYfo2RuSrgdVnj5JLx39J2om6PivobuzQnePi2nVaB54Nt0NO4AbCYBAfGAV8b5JEFZAwk+mGGPPYeIzQJeweBet2zdBaY7ikW/izF8C5AbZilDQ1QWie9eCb0BXwKgiIAYRQVW4emmqO/o2orN0gjfCJNgHW3SD+3EXLuFdOgVI/gFgILp9Fbqu0E89CkgKUnsGbZ2/SucXbBgS12ugynBDKYiDlNcjbpG+BCc+Q6H9r0TuHbTX76H80KeTCzlI7iOgX3jj/RO9E7vUGUVAFTv3BPbKQz86B/2xgWEjsA2LKsOJCSAuzsZ7kUoJsPTVxdgzuJHFsSdxvIcx4SyogOQdgIF43zg64YK1y6cClR6cGNQCAequAXGAbKkoGijosOLThOgKYMFaUAvokig08VmIzxBtFMJNPv7xbs4jQEEnfOzuCmBBs/K99odabPEg3fV/CKYK6LDrNEPkILVvIif/AGwTVEFtdioE1BfCHT7eqRCJNN8RYLeV0Mme96MZxVZ6gDQZasaxwV5whvfiyHAAhFcAD1SXAgBIF3FRog0O8aSDeyECySsA3xDvKIMD0gv7bMspYhVREFWEGO3/zPXfJyTSN7iCaB909i8RbBGizQ7uxSinEaBgJz10gw82ThU0TQWD9OZ688qKSwZBLwGbykYKKkK0yUEfF6Sj+YwA3RSgRQFr0442YPQlXvrkSOkNXaYeaQoSCEI8KcTjBvd8DJI3AK5gFwHgaA+ApG0/MKeg9qoiwBjTv37bO6oqIoK19uoAZNejvlRRH+K1sgggbylIQcsOdk2v+KYLqcogiN65BbIjQETodLscmz5DsRDQbLUpFQu02h0qpSK1RpNdt2yh4PtYVbIhaH8ASDYIBOI1BnVB4rwBmHChbLJ7f9JRkF0DVJVavcGluXn++UMfZ+uGdUydneHWTRs5NXN+0fBbOXxiip9+2xuYHKtSrZQxIlkR0B+pxL+c4gnQgiB1BckLAAFd5aCegsbZvX86J9kBANr3/G4Y8g8f+CjVcpn3vO6VlAoBi56fREK706FULPLgHQf53hPf5+jUKX7+XW+mUiqhfSOnAKSKsGZ9CLBFxVbA1PMUAQ7YVQ7IYPoRYMhCTH84ABEU5RsPPc7lRc/ft+PWxLv377yl/7MDtUCMEMWWcrHAV7/7SJKeHrj9EMYBILUGSKdFAdHlF2Uu2DFgJk8APEHHDagFqymbZ8HQ3qB/VJg+O8PMpctJeikEfmJkAUT6EFQVtXBg13b2bN/GP/zvR/A8l/tvP7jUy1WXB7DcskBIRlwlR12QggYCJUAtoiwxKiJLG0BdvgYsGj3xaiApvB/4zBfYvmXzonEP0Ot+ktTz0OGjvP4lz08K8mJqwnPdIV0QaYsv/f8sYMCWFXVA4pxEgBYM+IrYuB/WOuhl9kfzMgBA7A8GiPaLo6KoKgBWlXqzRbfbZVDdMEzm1dqBbKNIyviSDAUd0usqDEaGFgFHIBcAFCiAOgP9tsrSNlQULAAgqQhg0LgR7cTgJN79/je+GiMCA2nonoP7uWv/XlzXIY5tAkjVHfxVfahWkQEAw5fzoJ4kQzqAPNMBCBAAYkGFVGXLWAtoVgpK0k+1XGKuViPo+Fhrk/TSDcPkGEZRcoziGNdx6HTDpCvyfRdZNgVZ0PgadvQUHEFdASQnKcgbBABgsz+wDkbA0pS8UG9w7uJl/vmDHyfwPWbna+y5dStHTp5i68b1TJ09x7aNGzg9cyE5P3fhUlI3Vo2PocMWYsJVgVCj4Dp5akMV1C7T5WT320AqBSkIHNi5nU3r1mCMwXWcpP9fPTnOutWrGK9WEuOPV8vcunljcr59y6YkFRWDACOyfKelNqP/z/4f1Wh+ImDwQw5fhGXvhgrCoT07kcFgGXoc5KnLpCCArAhIw0qlytxEgCponDJ8JowMAAZEltRlHXoclPTHYA1I784KqXNN702Dao4AxIBVMAqaYXzJSA0KxA2kew7isWHdynC7iAPtC2CjjK0IAc24MGDpHQWx5AeAdBVsyicF0BQEBSS1EMPg1B6m8PjPgfF/LAAbQ9SGoQzCeQhrgx1XZsyALJmWGIhyBICOIrHtG5fBay+pVlOlZ39FevMSt3AajwGgQyJNmoAyXCKA6UdA5m8Xlih0kFByFAEtoGvBTXlSpkUFUTDlCcSYq73km0C2fohqRlFPSwzG85FUg6BD/qLpGCSSHG1Ht0HaihYtaPZOaCo0kOIYUhhLtS0ABmTpz0sUEXtNUJuFaPkptf3oG2pXxTQMkpsUJCAdQRYUnbCgw4wiy1RTBfEg2AAIdGfAhiAp7152axnwxsEpQTgHcQtIX4HTflqywxfCpmbA5igFEYHMCmyx13eHs3jI2jcujjcDBr38QfT8v4DtDBhTlgdQ2YPZ8BrwJtDGcXTmA9C9ktHtKED2DWMCEgnOggNKjlKQglwyEAKuki1dfq6wDVn7NihsBUDWvgWd/wokhdkB6EcAtr+4Mj6y+tlQ3glqkYm7oHkCvfhZEGH4qnwpCGm5mAU3f7elyKyDLBh0dQx6jYs4HBB3gKaL4KCqIAoMbqyl210vlQ8dQEGzoGdwEQUFZ9bFtA1Inh7QEJCWYGYcUK5NItA5jV75CIRXkjyuVz6Otk+AGBiUKSDi9RcUtguzX4f2DNg21I+gC49eJfil5xIJ7oUAYsnhEzIWzGk3AYFcIz3bRs/9DXr01xbHr6Nn/hTixkD+d5BVL0O2/w6y9X1Q2t632/z3sCf/Aj3x59jpvyeBgVyXE5kFD/eKn+N3RTgQ3dvG7g5Buf4NPTGA9PN+5QBm5x9hTZXwBwZfHDr9NxDVBveVfrI3ZFmh8NgY/lQ5x++KiMA55iH168mhAuIkI71uEG89eKtAY0CRYA04xdTPmus3voA76+PNFEHz/JCegFx2MEc9iFkZiaCtY9A8CiKoxmj9KIQLK7iOMfjHy0hSfPMMAMCSADBn3BX6MCYp0nbqj9Ezf4me/Q905oNg2yvTqMeCf7KMeykAAcg1gH5H5DwUIBedlftQzSfQc/8AFz8F4Swr9Yu9s8UEAPZGelJeQGYN7rcC5NJKQZBkKLJyxj9XJDhcRboZZsn5g9pJBLhfDzDnHJ4xEsAK/nSJ4LExTMsBIecAhhRl52sFzPc9CAXkaTV+YvDC4SrBE9nGzz+ANISawf12gPv1AnLBAQvIU/w/RJKknOJ3JvFPVJDQgNws744WIBLMCRf3i8VFGD0QkYA8STCkd+ga3JkChYcmKHxvHOeyD3qzvrhVQBqCHPaQKRddG2M3ReiaGC0reJqGkf2gZdacJfFu03CTbQX3YoCZ95K5DNg38WsrARzQoqJjMTpp0TELFYsWEiCoCwhgwEYxYaMFqqCAFSSWxLjScTCNxVF3cRa8BIB0DSggPFM0+8wBkOXlDuAq6in49CAoGEAVG8egQNw3PpEgkUnOsQCA8P/t3QEGACAMQNFF9z9mAHWEAiDIION9doIHDNsdgCTKSy0qNCudr8/ng4YAABAAAAIAQAAACAAAAQCgfmaEfu131wYAeAuzlsd+jwAAAABJRU5ErkJggg==",
  pfp21 = "./assets/21-6ad724fd.png",
  pfp22 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAK60lEQVR42u2c9Vsbe9rG++v7rrsbrvVUca2gdcEtuFuBc07d3V3gCO6aAPGECe6QhHq7S/+KvadTo8bMwByydK7rwXU+1/3oVxaIYjt4+4zxgHhAPCAeEA+IB8QD4gHxgHjjAfGAeEDsjAfEAxJSxgOaQoQQxRCieE1rsrI1VdGaJm9NUYoT1K8+L/xSAVFoQER+qIG4+21P/eUB+akh4tgQcXRQebK36aL223uK47VtGbKX30x8YYCEBJ5cc60YLMYn8g3/zpqYzDTA/kMa3pkg38/SPcwb0h4l7hW257YD6JcBSNghjtcoT1UPao7rn+aABUAA0McNXwKv59nDvYc0V0rESSqQndeAhAQCjfa7u+MTBXhyIKBp+Gb9oz09NVfbMqUko/kJSNjRmqLorroG4TCj80ZNz7P6W8+1Z0vAaB4CEiequ0pvgQ7lU6ytT3QBmQ6M5hsg9ZUS3cM9lHZmYvpn2Z3FtxHI5hEgISEpEI8MHJg5HSoejRsKUAGQIpongOI0XRU3GCCgwahfcgb15P8iIEI81Sj5jI7spSEfBgFb9yBPebKGLLWNHxAJIk7bGqdtEarro6U1keLKiOaK8Ca8rooQ1UZK1LcKUcswQUBLRMj60KYxAyK54J3qSPGtnfcO+exPd4uNXLNlh8AzcImD3+LV/ovXbFnqGukU0Fyden8ya9YBjfQeosoiYwQENI0x8ts7i/K80ncKvL3tFjlbmTlY/AvmSJoJZQ7m//JdYyPTCCcmZ11BWbr7+fKDDcYGiEKjuLb9ZrxT8Hr7JY6WJiCC106Wph+ag7lJkM+y3tHkCbL2mWXTP8lRXywTxRgRIDLofhdcnuoaA8l8kstUQLG7Vg8aUrkAhLjWcfu7FiMBBDRNMcrTgac3L3UGl2nRvAGUFLZ2+H4aF4BgaPSNQkGgUxfVnu+d6WlrD+HQQUOZg5lJhtBp5GG6gRtAmBnNPSBxHIE8BbdytbKghEPf1pqZ7M/z0j/nhA5GJd1V1+c4zUM7NVFtKa5RzlbmTgzpwFxszG5d33L/RTZHgDBvI+tp4ZwBIpCwcjxTXKwsWNBBmg9wtJeqGOR4ppl+XP+VbH8TMv2cKeio32EPGxvKsxgDMjcpyHAfe5yBh+HOuspvop6eA0Cod+7u+g4FMaIyOzqBTvai9qj7zOXDqJ4eG/tGdrBx5iJawDhtRUuEjrtY0rEw9VhocfViIPPwzIbRgOz0zHuOBUzlcybwtLuNDavQY+pqa35k73pkd/blD8OKEatGWEECI+4BUZkrsjVklR87+cDy09wG9KiemToXe8MkF/NcTHU5B0TJ59zm8yzlY24Ss32Vtj+BfeZi3bs+2oOFth8DEFJ7vFMI+nIWed3fwa6hKZyTwEwjGI0O72Od9RfQr5u/D6n0XbSSRWp3sTY7c9xX/5z25JADRlgXokpHrgBhMHgy4LirlSVTOuhLwzcJOgcSqdAzV6Z/nKu+VAoRcQUIY9MM9zjG/mVh6mZnfufWVgahhzMRDXUcI7c8CDkARHXtyF8AxFg+gYKe4WRO5cNgkHaZFBEngMrDGgIWr0W4ZQQI89YLp/05rnoYNLED0tPYBMABoDhtUVDJOjtykMo0eUmUMVwnLwZNrKGAUf/BANCNHXe8bO0BiNFULDnCYfgBNTY0FtMW3Zt9QEhhV7Zd97SxY5rjz53y414+zLwMS6/YTzT3gNB5eS2xrKoJYTwV475obM9ph4i4cLGFTACRYw1VZxz3CZ7x2rT8SP3sAyoKKqVWu+gn+LCA5X1jKUYVgKj2Fckei0KznebDGwOWOEAX9CN0UrgD+4UdLk1bWDj7gOqiJKGr/VEo0geUk+hCzlWNDBDCUFfJrVl2MVhLrCbTPYERoPx09/Gn3DeoLBaFKm5w0qyeCjzpam3JAFAaAGUYIaAuAOJi3FEcWu23eBXCEE1A2Qkuo0bpYp0lt2ffxWBYg090Dse8lWYWSwxdOzTzII0uF4XCi5yXr8n3YTOETtwrQpDmZOR6ccslDxtbjFzpAArxndEGF4DQP8kY644ZrNrSe92754J77zWvgfJNo9oo/aN0EhPrnv5SKTeAYonaqLbw1YEI1TQ7VQURy6ZQhGqeZgy37tbmCxR+f5Y6/lKy8mcSwU8kK34qdfilfOMfiawlQ4079I/T8Z1stlcdauDExSgRnd98HiJCxThtq+G5yLK8PAitBlM6On1yzxlXuffvJct/IhHAfgo0r0wA+wk+L3P/TdehteOjCcwYodUY3N+eJeEIEIxoiJYlOIUAEB0RnTriw2xUBjq6JAhHsvrnlGQ+YSQmyIpIWzQ+FM+A0SQ5nBYnsm9W6c6GAsmq+l/ThqG4oDWDBrpxGvqH13QdcZCs+hmlGjoGmrr7qXTD9vNsnEFjPu5gbicDTnjaTtPcw8t8VtmI2iLpTjwmswert8hcf01ph5YJyKjUX+QDQLS24uu+ku1r5h7Qy213Bd5ZqBun9bWThzbSDZ+GFE2cjWQ5SYe+4ftVQaZ0ghH8qw/+RQ2DuFYQ1Z2h+XD57PYyeNmu9UuJPhoLqpPZw6JdMrffvJEPIxENVmyeNvFj5Ud1vgJb8zgGNCXrt2d5JLpZW4HRZzaTXT4fiDA0LaCei+5vQg9TEXUdXmt4Po1/kdvOyPNSP+4mzvpo2d4N+evsFn8qZmNVfue6JZicTROJnmaQyWvZ/7MD1JFkr3+Y9qlIRB1zVZ2t5GDhkAajZqHqwpaL25d7AsenpHSwwHv8ScZnHkD/KI1IXYRHZQdIHWmhMyR/5vf3Nl6iog8HgOhhKgmtyfZI2mC/DOXPVExkOlsvsC4t3Y1I9GlA6UTGYtYK0kRb6SZSPg4Ipzf6D0q/EkE+c3sUgZQSTmmkukb7LFxBRuh3ttzD0YI2LpOphZ9xtK4Da9gBwk8RWUtRQ32UDnoLxGbQMZbDLE1CJSrJvevzQlf5bbBfiv0OIEWa+b8Sw9ZoB5DRPgboRU5/oQ8KaBaAYD0XPZDmP1Z55mqLCqlzmlwCYo6JWs4v3F18IuB4rmdqnFNQ8EpfnIg6lRs8osv5SFKbzEabrvD9E/M0/xOZ5+9GJCFUmp9CB9vLym6SoUdo3AfqqM1XqAmqI8Q1USLV5eJx3dcQ/4eJjPQyAeNCkcheihgPIu96FrSDzXdYiafocACIA16UieI6lGeqRvrJs7wfiki59e94Zvp0FD5/GpFS8plyupe4WwTtcLQNmHsTEuiJBqRn9M9y3sUEFQxWbqYGHXToyFx/01/k++6P4/VwzyHVmUrsIuf+KALHjFDXEoWFWAsmH+wNpueZAyWBCt8/k4wEn4o7JB1w7LuzUf+ULK9Ig3Am8nFgVZLXSgpnXpybJ19Lv2nprr42Nv415R2vVNAe3JFsL3X+FYmJJPXKqA8xY9QIrYeadoCmYfJlLn+Q3992TnGihrpgaJ7d3UEgDcPjOktuwTuwaxcPPPEiS38/Zah2a+felaogE/mGP8i9fidf/wfVzn9q85cPVmzSGRLxPchTEGBP3RXcJyAm4zExj6/HIfAaJweUp6uRmweUJ0dH9ukeFuge5oyPpYz1xo4SUWM9sePDKeOG3DHd3iHiOLxJfamsfU8b+OLHv5QLlqhxBLbs4vIkTNdRBGuuFxN3vod13CxWXyxXHK2T5LcifiEM45spNF/oHWYUr5Z3jCICm8d3mPHXBPKAeEC88YB4QDwgHhAPiAfEA+IB8fZfZ/srY3Y0xdYAAAAASUVORK5CYII=",
  pfp23 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAC31BMVEXu7u7v7+/w8PDy8vL09PT19fX39/f4+Pjx8fH7+/v9/f3+/v7////29vb8/Pz6+vr5+fnz8/P//v7/+Pb/7+r/4Nf/0cP/xrT/vqv/u6b//Pv/7un/0sT/spv/mHj/glv/eE7/c0j/b0P/bUD/bD//9vP/1sn/qpD/hmD/bD7/az3/9fL/y7v/lnb/dUv/az7/+vn/08b/lnX/ckf/6uP/d03/bT///fz/1Mf/i2f/+ff/wKz/elH/9/T/s5z/r5b/cUX/+fj//f3/+/n/ckb/imb/pIj/kG3/noH/iGT/xbT/x7X/fVX/8u7/+vj/7Ob/wK3/hWD/bkH/m3z/5t//v6z/cET/uaT/49r/l3j/bUH/nH3/knD/jmr/mHn/jGn/6OH/wa3/b0L/vKf/5t7/59//gFn/flb/5Nz/zr//dkz/0sP/pYr/ooX/n4H/oob/eVD/3NH/5d7/2Mz/ybj/3tT/2c7/eE//8e3/sJj/f1j/dkv/glz/t6H/9PD/7+n/iGP/7ej/van/h2L/g13/tqD/+PX/mXr/cEP/xLH/p4z/qI3/uaP/rZP/rJL/9/X/wa7/fFP/xLL/r5f/6uT/6eL/dEj/yLf/4dj/elL/jmv/8Oz/vqr/xbP/w7H/dEn/j2z/8+//oYX/+/r/yrr///7/qo//zb7/oIL//v3/rZT/0MH/o4f/sJf/rpX/9PH/tJ3/e1L/zLz/f1f/tZ//3NL/qY//hV//qI7//Pz/eU//u6f/k3L/z8D/8Ov/3tP/0ML/3dP/lHT/kW//uKL/sZn/p4v/dEr/fFT/dUr/iWX/pYn/lXX/lHP/q5H/6+X/gVv/xrX/08X/jWr/noD/oIP/jGj/c0n/nX//nH7/0sX/l3f/2s7/4Nb/4df/2c3/5+D/6OL/v6v/rJP/flf/49v/t6D/5Nv/uqX/fVT/jmz/0cL/z8H/8u//m33/tp//8ez/yrn/18v/39b/iWSUsVjxAAAG0UlEQVR42uzR1QECQQwEUNYtl3Oj/z5x+MHWcF4BkZnFx/gjlHEhpdqQUnBGSc7hWihjnYMT56xRQpMs05k0Di5yRrLUHVocp1/bUeiU8RLhLpQ6erwFLzZqBREI3lAEd8FKCFKysPMLC4FsEfAErRwEcxX1jsdAFOMZU40QCWuf+dxCNMvj5zdt1w/jNM/TOPRd28RuqC/OX64pqwol12EYOMfMzJezwmldZmbuY2Zm/v95EzhwIhd2OBVU2tX66Pjk9OxcuCAA5EI4Pzs9OT46RDtsDOEX278oyYqgaioAsQCgaqqgyJKI8TCQ6UlEP7rh81MViAugUr/P0BEtDVDrxLonPBAMhSkQFEDDoWDAk7LOv7gVz31F5CiNES5iNCpHPBe3wiXATXA8kSRABgJIMhF3E82hYcLtb6l0hpKhoJl0yu18+JJmXGHZnKCSEaAKuawrdQZ9X1Zd9fMFICMBCnlXh1XsBZplY4o5vD7eIVdks2eRAViGS2kByMgAIV1ieZ4fNkAio5IxoGYS/BEwBiJJSsYCTUZwFnAJlWUyNuTyICFNsCYUjAIZExANspY0wR4xYxJ6iDpWoFJKYZBVaJpKbNCQzhjG1ACKjXDMpq5SrckhP/DFU681lIJqNwsbKM3IhkSfM0CztX1Y0tsdnptm0t3DXv/W7Zg9gk/k7mie2ZBk/+c7d+/ZJ3G/ghvqg4eH1mP66PETq59fYnY0z9NQXLYHeHrkfOg+o6j2n287Af0X9ghynKejuZs/HCmqmf7y1dWX1xcEwZu3VwHvqlaKcnSzzhyPgmMBTNXtXn95/wFhAT5+uo74/MXMEb5ySJhkfOhENdO/9W7c3XdkR/THjYjUTzBHOGH8aBK/gq3HGiHw67dV+c/fVyaRhpfmWOGfydd/RqwBSLIkiJ7CL9Rab+PnIn/HTJ369/mGwR2tbdu2bdu2bdvG2bcO66pX09c11VMdGBReV2Vl5nsvr8fnryLdsxdZll3HXXQmfBQP4PGzZYl6sS7Vu0/ffv0HDAQGZStH4MFDgApDhwWGj5ATMHKUnMF+TzzAR0U/Im9AfpfRYyCXj23KxDXHDYRrfNVEgKojXAhPyBJywsRJACbLh0ABr/KM1Dz2yRjTlNoApmZRLBo1p7kxfVjCEbjyDOS+7kk0cxaA2XNIRtmn5LIKUEJ+FTF3IDCvkXhTEOZHseD//Yc+W4iMyYvodbgX5wBLYrNDJRQANQ1KyiX20mVAmzcVSUZ8+Qr3yqpxCE7VcZOwag69GV/kAz5ebctfS6qJoACUIgnQB1izlt/dR6t16L0+9A6BmnaYh7J9343TBhewUQJQKUMAqgVMkjW7EGF56U2btzCT4xDzlu8GRrdu48KUKO8GBpACoL8iayjQezDH3Xlge050x86CyGefRXbt7rInZ8DeuFHOzgH2OcoV6YNMpYAhfo6Pamj/gXD04KHD644cjFZYd7RmfMx5eBmgFumDrDxT8V0CgPzwomPHKzb2eBpXHF9/kRxKBDgh9M9USTT7ZDR2RYls3Tp12u8/fcZK7KJ8Ngelz9n6RFNKhTg/Cd8eVSscETORWvdS5PQLQl8qlGLH/fMQ3WlMjcTFDFy6zPpip5RrWvQFsCBkClDzCnB1EanlWt9wqJwLrauYsutWXeE6QWrDSdIyxbUcpF83vCNxIxe9bwqlZSZr+hRcB7S5ZXQEWiTnHgiSpulraAvfdiOcYnQEUT6MkXdYQ1t0xIvafiIDZ0JRKfAFcLctaYiXljryvSXI3Fi1eICq3y/DkhTWUEc9+XXS5rtQZn+xMoQveOAamqYlv3r6Tq3uAw8SW6Xa+x8Cj1qRnr7rBQgvniHX7kp6Bq58H2i8mJMLEK2EqncQ6HKTHK08oEZdAE81J7mE0ovAqjc8QIvraZpDcFrHHwDP6qrFi0CNjHWq1vsR2DTfT0VxU6f/T2GgcbWqZjJWI8TnPsrAmtY/t7IEJfSGXya0XoNot7mORogbWglcpVQOUPrX3+ZGLFswyQ8L24rMHfB7aSDnjz9ZYyUYmyFU86hvEuBa0rNUp7/8Uzp3nuJf3KnZ/SUuYNLfF2qS1gwxt3M4td4/sf2wbNOQ5l5v8yGblgFw/XvgcSob2DkGhhRxcO6T+0+XFQ4se9rzydwgk4EhZWapyZhGznY6/uz5g4cPXzx/drzDy4iMuomlZm4KEtuUlhro1SuQmkY201tTMNfAFDS3Nem/gQHhYU36D8wSHlrORh9azsY1tEzXwXH6D+9TPkFB/ykW+k8SUT7NRf+JOvpPNVI+WTrw070IK3gJT1jTdcqd/osG6L/sgf5gFAAAwljXMphbLwMAAAAASUVORK5CYII=",
  pfp24 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAHDklEQVR42u3chXMbSRbH8WNmpoJjZiZ7mUGKzMwOMzOzMcyMZmYWS2NFG9X9O9/zW+iKXVqN7yxX7Yy66hdOJjWfeq1+3e6ZD2G8lSA6GkgDaSANpIE0kAbSQBpI54MNNP14bjQQysVvMO6hb4j2bkn/MBNeAoaSSjEgRRN6RO8gZ86xdTsVlRQUkpcvKSykqpodOzl/kYERwlHFlEJAUi+Hj1JSypIlOBw4nXMiv+lyUVbOiRoGR8UoFYDkPgPTXL1BZdU7EAKUIO/8haXLuH1PKk6YbAmkdHxh6hrIyZlLY8qUn8/ZC4IrRnYFCkaobyQrK76OmZGwnrsodWRboGu3yM0110lgVFDAvYdSRDYDklsaGJG5yVzHzGjlKkanlJFNgGRcHDu5IBoVl4vGMzaqIFU+ZeWqfBZYRDKpjUkR2QUoEuPiZVyuhdKoZGVx865c1iZAwWl278HhSBaQXOrwYcJROwDJQJjysXyFGl/JGWWrihjvkovbAWhonJLSpAItoeQN2rYSNmwB1DdEYWGSgQrf5OZruO9jxKwP1D9MYVGSgQocXH2a3pWEAhiPLQ40MklZWbIryMG1Z2h5nomr1gdyB1i9ZlGAmtLoKifoFiNLAqk2+uBhHI7kAzU/RfOzjJ6yOFAkxo07ZGYtClBTOh15+EfFyMJLjTG3aoWSDTSTpxk+hhG1+HbH2fNkZCwOUDptLnx9GDErb3dMeFm3PilFJEDFb3JDAYkRA7sJR6wJpIxaOyhNQkstQKtf497TQqOAWl/H0ypFZO1N+xu3F9hVi062k5oXVPkoI/o2EA5jPLYyUDjKzbv/996Q6OQ42fcy96V85gK1vMTkHSkiqwKpdHSzeQuZmTgd/4OUS0YWjc/zQETiJY2eZYT8UkTWBpL22s+V6/KxnZs7X6AsJw3P06I44qX5ecYvWRxIGQlTgOZ2du2Z135j1hvU/Jnm9ARAUkSdJQQmxcgmhxei/5nXhqzTRfFT1HyZu3+i6emERs8wWm+j4y+RGBeuJAJyOch+jZJ09nyDug9x6Xs0JS6idDpy8A9LEdkBaDpGSwd5eTid8Qun8m/s/zLHPzmjI2n8BHd+n7iIJEOHMKL2AHqMNyQnYByOOJN61mvs+hb1QqPChW/yMM2kiNqceLsxYhYHUkbd/axYOfv4i5PsTDb+npqPCMqTafgYt35tVkTpDOwgPG0LILUze+iInKTKL6CoiPUbuH6DvgZu/IOGT1I72+jcV3nwLxOg1tdwN0sRWR5IGQUjjE7S3S9YniDSCsQITNGznyu/of5jion6j3DjZ+ZF1LuWUAjjsfWBVOKc4xQmvEN0rOfCD6h7b8Sd+SL3/2EC1PIikzdtAWQeGSm4O2ku5+y3EKMPc+1HApEoaXRXEfSKkc2BVE8QfsT4Pe67OP0lTn2Ge38xGWjNzzF2PmWAFFMozPBFbj3H9Z/z8N9mi48iAhNilCpA6oMp6GP4NF1VND8vEO9r9DQjNbatIHOmkF9W8F2lsgqLvwpJpz0L36D8/ZQCUkySwBSjDXTkikhcpsH9GI9SE0gxvYV/hKHDtC0RI8mTi4838XZixFIWSDFF8fbIOqP1tdlM6fRvIWykMpBKjHBE1hm966RXbEp7r298hakHGDEN9B5TKMTkLbqrpRsSpjR6VhEKSqFpIPX5Ld3A+HnphpqeloZg4poGijvNTUg31J5JV4U6MaOB5k5z+AZlmpu8rSvo/ZnCEWT5GtVAZtWkgeYdDaSBNJAGmrsVrYEUSiRGOIovJGc9xz34wu98STolXyygRKRnC8tzcW1dXL7G0eNs3Ex5BRWVbN7K8ZPy6HhHD+Nu/IaJl1WAzEX8YcbdcttXrgvBDERlJXl5cvrV4VCvF3jn5/Kb+flUVbN1GydruXaTzl4mPCZeFgBSLiJiMOGlq1du70St3GpVldz2bJFEz4Upr8xM8guoXsq2HdTUyVnH7n4mfQSmlZR1gEKPeNhKTZ3cTHW1iMhpO6eJiGmUl9MpFywokIdXd+yitoHWTsJRiwDJ6xVCbNrCm2/OU2SBXvIf7d4rpWQZIG+IjZvUcZZFj8PBrt0aSANpoPlHA2mgDZtkclFT2OLNYk4Hb7xhJSBJMMKtexw4xNp1lJSQkyP3k4wpf9bbu3JyKS1l3QZ53vN+kzX6oLnvcPMEGRrjQTNnzrP/oDzaW1xC9vy9lIiMVoEuKRX0GfpzF2lqZXgCb1BoLNFJJ1iISWa83AEGRrnXxOmz7N3PqtUUF5OdPcvrCRGhnAFdvVZwZ4gftAi3JyiXisTmLMcsBmTuFYzg9sthzbsPaDwjrfCKlRQWUVQscDN8p88J5cCosJqIWBzI3Oud861T4sXAiIgEI/KbcUX0jqJE7yjqPWkNpIF0NJAG0kAaSANpIEvnvy7V3Oc1ANVFAAAAAElFTkSuQmCC",
  pfp25 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAILUlEQVR42u2cA9TkyhLHP1yba9u2bdu2bWUPnnmsZ+uzbc185tq2N5mk379vL8eTZDMzu33O/97VZLby2+rqqupKAo5UEyfi4oA4IA6IA+KAOCAOiAPigN5dcUAcEAfEAQlW4oAYhaM19Of7K8nuCrKjnGwrg+hPdlWQfZX4I3zAy7wCvIVmTyVZXUwm5ZK+6aRNImkQR76NJl9EQvQn9ePob/ZJpx9YVYwPew1TgMFoDlaRtSVkRBZplkA+iyTBYSQghFCF2iiEKiiMfBpJmsaT4VlkTTG9XHgrATE0y4pI91TyZRQJDGVQ3FYIvQTO1S2VLC1kmN4WQOxO1pWQXmlwGdytVn0aQXqmwQ3Zl/s5INwAYu3EXPJ9NO5NT30XTSbk0i8X/BcQTN9cRhfF+2E602HC13ZJIZtKieCPgGD0iiLSOF5/LlZqFEeWFxHB7wAtMJPvY3Rm4WS5zTf5FaB5JvJ1FEw3Tl9FkTkmfwAEV19kJt9E29mn3wsj74ezDd5K+jDCPwncVvBlQDAOWW9tm5X1YTgZlyP/+LjllyctB6st60vleSZ5TI7cO01plajUi1Vwb8gGP6D4NLGrFUNWFhPBNwHBrK3lyI+tjcY9LzDLZffFC0/E80/o/889EU8+EqseiKX3xII7YupNKeyK9Ifz0q9+wLcB+Mzy2By5VxplF+yhHyHn3lpGBB8EtL+K5m+BNhZjuUVclYDmzOPXdPa5wAs6/1znHj/Hd19MvCHNN8ueZgk9Umn1K/gUIFgzJQ9rxE7oaZ6gwE3OAoonYuzAq/Cu2C9d8WitwYxJub7kQaCzvgTr334N1SNNKbnHAKkRnGtjqcXTYITEHcWN4COADmJxpTosMkdly1gvWgAhKnkKiC20A1XeBsTcZ6GZfBLhENAck3zikUo6EOLRfLMaQB9HsF3f24BQLrZLctamWFcqq3YfXAjvw46mLldqm6RDNRug0X3mm8lH4c6s3F9lQaxVDQipANIldYCQf80zeRUQFnmnZGcmInX+xUlNgEx3xZaJKgFBHZJhpJcAsbzZeQ8M+fHvzyMJUh+h029KtWMU1fXHZxFkJWp9b3nQkEzX9RGy5HMaAOFyjXXv4ExveJBQjZMZ9GJcNJJRK6TeVA8Irvf7cxLcUAughnHUVMFgQEeryZJC8lGEC0CtElkarR4QQhgCmZa6H3vI4kIYbLgHjchyfRSBDahUQxqNyhabIL6qQZwyPleekCs3jFMCPWc0PMtwD0JpStOfEBeAkMJoSaNx4doSuU+6gkhU81CEUPcOzPAwZocgIYLBRgFi7rOtHPWOa8uQBJ/UkEYjBf/tKUv8dboPvihfEdQGZyqe9mRhsGAkoBVFyOVdA9pYKqve46HTj8Xjj8DFemtLuykN9YQRTF1eZCAgDBTMyEcL1bVl+6osFyggncUYDctyNx7B1On5MNtAQKOz3Vr8K4plFkreBKN0TxiNyjYQEHx1YIYbm24IzsWUf16keRDrt56jAi8mHRhl3JJGuMMohAzIMG6JQdi/GSB3msQKItFvTln+fF6KvCql35JQXqGdWv1APPVIfMGO4VPHaGS2HOgKECYDDhsG6FAVhjTcBcQGM9AGRdWG/nT9WKVtktI3neY1aOZvKpMPV1uA70/npairUtUDNYwyKSOnfhQCg2G2zwByzstKL/DNKpDRgT6raq1l3ZJGwY80ADJsiakQZTQiW8Hqe0FHHSOctQU6zOmxxLwUpLXTGZWt4PZwkxpjdvZtxsjbQRr75Zgc3dxnSKYVHU2Mcm5j77fNIZGXGJoHIV7oM/WDqbq/XHDSUVPTAPj7RenLKOtJopkFxuZBGFD9NEIzoBA0a7S7j60Tici/Xo0AMHVVsbG12M4KNMP0Gcn472WdPSj0imQ1XlI3luzUVKxq3+k1aFKeXHRP1CsGFd8Tp+bLVn7aje3xRgLCep6aR4L1CEOoJGebdGDE6GAyxKqKhpFT8mCw4R1FTE9+q9PsKu6BZYla2vtAPNdkTQeCkTDV6I4iW2W90mCBnozMqhjhEsCdY02HCUbCVC+di6Fv/0mEnoxmeM6I0cEitbveYR6MFLx5spoCO/RkND1fNlFGHtCB6zmKhp1TYKRXz+bx5MTnkTozmkYZITlyTQfuNtMxHRi2rMirZ/MsEqEuo+WPfgoKI9iqC+6AkQs6cDdHdGASDDvkC/NBW8v1n6gPCiWT8+R8ysg+HSzDaY7pQDCJnmT4yAgeji6/jDKGEaUD54KLBTmmA2NgkuBTU66T8nDIqz+jia8zYnSm5MlBTg55wkHW98aAMak4Mpt88AYY4cQZh4Wsz4+TjElO6cCAUdkwxicHybGh4sD+Qz0YYQOqH6ewEINw2z5ZWVYkLy+SOyQrTujAhUdmwwwDBsk1PHc5Pkfzk4UheBBMweJ6EdfceTgBf+n4XGqA4ONP+6D1O9dE6mhrhgBNk3jF/WIYDQ2MIx72l8eh6Gh5KbxATUhSManZNYVsQDnqd08c7q9E3UAHvJw7gpacu1EcpgTYkxl++1Dv9nJMCWECCn0ffRps7NEzcEew24FU0P8fC2eYUGFh5op26YPUkQrBhbgcOxock6GB3qIXC6Cnt5++dgF7DS2ya8egFwFfYDfvQLTfiI/hw4hoSIhwOXZxfJUvv1hAOymaDVAXWFlMfQGpU5903D/1r1aJEP0Jftk3nYzMoiFmVTFtuR9kXN7Bt79ALBFHrN1HBUdjqTD+yKfe/sLFAXFAHBAHxAFxQBwQB8TFAXFAHBAHxAFxQBwQB8TFAXFA2vR/9QcEJHdEdqEAAAAASUVORK5CYII=",
  pfp26 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAACfFBMVEUAiXsAiHsAiHoAinwBjH0Cjn8CkIADkoEDk4EBjX4DlIMHn4oKqZEMsZcOuJsQvp8RwaESw6MSxKMCj38GnIgLrJMPup0SxaQTyaYUy6gUzKkUzKgBi3wEl4QKq5IQvZ8TyKYFmocMspcSxKQTy6gSy6gRy6gRy6cQy6cAinsEl4UNspcSxqUVy6giy6syy61Jy7JgzLZxzLh8zLqBzLwKqpIdy6o7y69rzLiazMDCzMfgzc3uzc/2zdD7zdH+zdL/zdIFm4cPu50UyqhwzLmzzMTkzc35zdH/ztP/z9T/ytD/yc8Jp48Wy6g/y7CPzL7Zzcv6zdH/z9P+x839usT7pbT4j6P2fpb1cYz0aYbzZIMMsJYTyac1y67hzc3+xMv7qbf3gpnzXn7wQmnuNF7tLVntKFXtJlTtJ1QMsZYOtpofy6puzLjUzcr9zdL4jKHyWXrvN2DtKVYDk4IPuZw4y6+ozML1zdD3g5rwSG3tLFhWy7TPzcn+xcz4kaXxTHDtK1ftJ1UYy6ltzLjlzc3/zdP8sr70ZoTuMFvvKVcZy6l6zLr/zNH6m6zpKVXHJ0zwzdD+yc/4iZ7vOGHuKValJkM5ICb+yM72f5fuMlzqKVVyIzUeHx+KJDwiHyDCJ0s4ICbuMVynzMKoJkToKVW/J0ptIzR+IzjXKFDSKE96IzdwIzTFJ0uOzL7lKVRmIjJ9IzjnKVR0IzYhHx9vIzRwIzUgHx87ICbLJ03vKVbDJ0s1ICU+y7DOJ05uIzQzICQ0ICW3JkjwKVeuJkUxICTYzcvmKVTAJ0qvJkXgKFLdKFLgzcygJUKNJDzGJ0vrKVWLJDw8ICewJkagJUEqughNAAAFa0lEQVR42uzUU7zrWBQG8LVSJtlpjs+5tse2bdu2nsfzPLZt2zPXtm2zaXaS4nSv2Wmv2kkPrp7u93ROsf4L/QVhN2cvILMX2Au0/+O0WwBEUtAPkB+BRLsQUISKWwK0JZ4idgmAVLulNoLwOaAtygaknQWUjiiTQQqAY76xUuwMgJ0iiG6xuo4yIPwBZJzi6jSi3AraUQD7I+ImUSgeipTdIJcvIEo1Ec2mHQIwsv8C1S/PsAoDjkxJ4j7h9ZqSox0ABjQhzpb1WVyp33xi8DQJuCpsPvM6keZS6E+0elZ7AQydMS7sl++PMh6q/5vAI5X89fhE86G/5aldAEYuxX8F6HBkylyiasbW8hLYStiu181KjAIHlBONt3PUDgCjN3/rL/80RJybruuEiK4ABlvCQdGksGJ9vC8R/eGf4sK3s9RmAB/Cj/36FyBOAdYbcaNgUB6u1BDN57A/0Xe+cDU9Q20EMHqvrK+r5+HwmkEoY0FwTJKZsfEY+sFzpPBiltoEYOQWuR/9OkQcdhxipqR8I6wpIWJEQ4+VzAdSuPCtHLUFCF/+j6x/G37PTsH1G6BkOZ0RaHnJoqC2jv7i59MbUrjgzeY2AAN6Vf0t+1cjv50pl1+6nZ4oAVpYuid5il/PyHlyhpOTC2a1CuAJM8MC6i77nZ2POKHstv0LwOyyax9M9D0//Yv1oDQPHEytABg5Zo4Adpk6/MxYciGD0vRUJeAthDKhZ1Xm12O8Lzgo/YbnqGVgAEvMBHZBTI1FY+X9yxM3SGDtGigXjrayGS8jf60DU3xWiwAOWK0K/fTD34mfGp1WqN9zYcmOVPBKNlR8m++b/TN905jfHcVrmkUtAZ3NpAD9jCn1h9hxq1Cgys1uT/SEkv+iWrLwv5k2xq/b/zcHlCpreQuA0k3fAOyIqnmHaouK/Vcj4vqFEJye9Yi4ujhDD3dcn+RoDrXOElEZ6BzNCDjkhhfUw7TCgXt2xA1KzcLlFep3QVzTlCzMwHu6Y7373hsPSiy7vCKAnaMusAEbDDZIsYolwgiI+Hsg0Hgg5vJesngTU8zg9hN3ctCyy6niBF1zAHU9LTgintrc5ACUGb0mELgA0fO8dZsXmEiPBnPheoDI0ooT1LIcMe2Vp1if4oV94SBEHBd8hJ6HZTxv2Zb3zPQ8/shdLlfCfEMFQKlhGWDdDOyip7dVcY6cWvHI+43St70Xd5aRvYRDjG8UwQDUh0GvMUON1WkN2h83vmlN3troQPM6CAZUI0ysADhsBwCuFwCOzbYXCKBqKGBWmbpZDTuWTZZjJS0QtkdBgKIaCHVMAlENdiRuVgJ8PZDtiSAAdQN0jSWYGWI7BPC8xVPcdcB2AicIaQYx7a1HmansICAs/uQtLkfbzQcBYY2RoTHDMA3YsdiWbXPXRu42BwERjYmExljCZDsIcCvFuZtSuJsLAqKaLkyNKU2mXnwUd5u8BtqSRj1afKQ71mrBXUtx3GwAgFEtDqZuaGbCB47vNOkgxA+h9fTv3jAum1nuAynLtR0L0m6WAoCYFgMjwXQzocmuOnearxyMv7Y+w+lr80JkM1n5STdlOTxlQ8bN7FkgeEU9R7d1RREf+K89uzZYIAiDMPwrnl05dIOkSCNoIzRBDZRAjjtEuMuT3RawvvvNvHN3i/wh+2vKH5r7KsBn579rVXDW3esFx5dMX/S9bAlSixUQXkA6MvEbdHbiF8t3b0C8hfIm0NtYb8Tvo4R4+yGUkB4/gRIgDNm1v3yL4hwPpDhS81CQYs3dOWT7EsweouViU6BlA8fv4P16ebeCavEDeN8HFLuI5WcFIhYQEqmYywd1Pmr0YWkYWIcDhAPgtgHMWJmdVvJ1GgAAAABJRU5ErkJggg==",
  pfp27 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAFHUlEQVR42u3cA5zrShvH8a7x8tq2bdu2bdu2bdu2bSOdam3v1sr8bp9r34NumvTM//McrIpvMMlgffhN/V0ZAgNkgAyQATJABsgAGSBTBsgAGSADZIAMkAEyQKbcClRJcCpUPf4KVA0GSCD8VahGeg6g50DaNyfxDv2n0bUzIzfRvDSB/0hNoUCWj9Y1Gb6G3qPJ9WDHyIQB8kPkegGijxN7htF7CE495QFF5qN1dUbvBtBJsPljdP5Hr4FzGDiXyLxTBpDlI/B/Ys/JO88P8s+x0Vl0jt5Dfzw9lTlQ06J070vaz0RF50l+KAddywplDRT4D9En0Bl0lkmIzsm53CpXIFVF0yLEnmWSo9Py4z2HoOrLEah1DTJKWqvJTCZMaLZyBOrYAnuUyU/qEzo2J/Cv8gLq2JrYC8UB0hnyA3Rsg1U+QNUMX08Rkx+hcwdUTVkAqWraNmDsQXSOYkWnyQTpPQp/lfeBQrOQ9jMeGbkNVedxIFUt95zJDyh+8iRelyY/0OhZIMtH2/pkQthxxinZFrlH8+4eJKdSO8b4JfWltI+B/3gRqEJ04i9hRxm/SJM/ROcuWJ4DUrWM3IEDsWN07Y6q8RSQqqF9Y6KPQZ7xjs5Ik993IqraO0DhueXc7GTG7kc1eARI1UivTepTnItN4i16DyfwHy8AtW9GJiJNu8PJdUhvnOV+oK490SmcT9qic3sC/3UzUCVduxJ/WXYf56OzchPbvQ+Wa4FUg9yUljA6SfcBqFpXAqlaOfvEnga7dEBZafL7T0eM3AYUWUjujNyQ6OME/u0yIFVD66qkv6b00STfldHawP9cA2T56NhWdh87gUuS66V5GSzX7EFyatRZ3JNMkM6dCfzfBUCqiu69iL+CTuKe6Cx2lJ6DsUoP9G9puVwYnZGbD1VbUiBVT8eWxJ4HjdsiTX6YgfNQ9aUDal6SbAdoXJv4i3LzUSKgSlqWJ23h5iTfRzr2/1MKoLZ1RcdO8k954dOPjrvjxhPuvKmIVXjAwsNOeJPvNNCP1z72GBOQ4++40bfByr6NVytiFR6w8LBMSJLvEpnPcSBVJz3BE3ZvUdjg8pY2W7OIVXjAwsMyIbGjjD1McBpngZoWk9MzeAAIZOQyNJOzQMHpiD4KtgeAdJbBiwj821mg8BxEn/AEkCQ/QPtGWI4BWT7aN8GOeuQQs0m8S9PiDh9iUzN4CTrlkUPsUlSDw61YAyO3gvbGIZb2E57VWaDAv2WsTidBux0o/a3MzFZ1jgJJhWdn9F4vAFkluFCUCvxfxjPB1UB2XMZ4I/OXAkjVSFdZ7Dl00rVAch6ILIC/snQdZt17ozOuBLIRoAd+bL9KBtS6mqyCy4TAdheQDJCdIh0ype60r5QBlv4zXLQH6Qzk5f4rOC2WS4Z9Wlcn+pQsENTJ0gMl3pTu+rZ1ijKLungzEgONMi0oEybbTLYdSR70eALd/MsyKTQ6TfwFGbzsO0FoLDdOXqihZUWZGD1wDrk+WW6abUUnTrjlBN/GqxcbaPUTbj5OOsNA+hWiT8r/m5eUw0o1uH4KXnAqYQpOLXN0ew844YolfZsUU0dqk7VOuGJRmhen9whpyIP/JzQj/kpPLmY5/tK5fRutXXhLRazCAxYeFuXD8vxiFt8td860xhFLrn3UEkWswgPefOdMqLJYDpX6unL08+qiV+Fhy2hBnSp6uW5JpvnlJqYMkAEyQAbIABkgA2SATBkgA2SADJABMkAGyACZ+g5eG3xTXD3mYQAAAABJRU5ErkJggg==",
  pfp28 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAALQklEQVR42uzWA3crQRQA4Pfrn2qbR81xbLM2Ytt2ptPYdu56x/db/iL/QwMutOWM7fYO+YhJC1N0HCD+QbdX9oyDhjzk4uIjKVlK0p9Slb+IuZH0f4pxeljDZ2/FSX9/0vEWH8cMHOQlleviJWVjyC49pL811QNKES6WsjIkZz6cohe9Il9VLS/J/SKnr6UHj25GgC4AqC2Q9MILQAA0VKCgUghAbYFUAARAAARAfQOtA1AdELseyPcp6RbICndQR6BzAAIgAOoLSMtnb9cARfXcjkCszcSsAgmPg+MBCqkFswxEAKC2QHcEGwB1D9T2PwiAmgIx1lO+DwAaCpAXgLoAkpz7AAiAAAiAhg8UM3J4++EyED6Om9gAVALyknIuyhdTRV3O4lzqckbJUuKUSkUAwrkpO92sePykqy2Kh7SdjlMWEUjF+WoOVIqnsl1coL+1QO+S5iJNgc4ACIC6AvJSkI+Kt4WDuQMyM4VH3+SbBXAbyRKGj/keM8MxY1gyhJmZ4djMzBhmZjPLgjAzM4NZHDmcGLffv5rKbWmtbPIotuSqv1yj0Ux25nNPT3ev818AApSSDCoMoNlDacEo2hpPugJ0it5qoLFpXg0CKEcGlPvvAwKdU0vIrw25P08dn+LV41WaNYQqczmz5rSqRACUTPvXmoGmNQECHRhLdBeeS6enSPYU5/Jsfa9fcl1fpiwPqlahtn8g3bRuRgMiJjzCdPIAO32tBhDczdF51P8XoNPY7XXO/QVyeaah1y9I9jR5fwEjAouayk2GY4e0h4/eKdmGKc4G6OqOs8IU9hdQF3bZANqWQN1f4Vyfuz/hk7oBf2B2xBvUuH9QSbrVbfPbZnI6QBYlwsLN8+/BfcCO8PNghhF7w1e2FvRLwYJAB+rw1AMLss0/nAwQxJnV2kNHERBvXXgX3+Lvw1j/w3wQxDdAKsuT0XFuQEJ1Gck6/5UFH4Vti28xGA5I9Xyd3WKtCBBZIDSUZMolUw4aIkZwNw/ioNEsDmJ0WgkgJjUZ0qhqDlXNJf1ye5H0OrgkJtbZ+gBp55Mxm8wFpJ1LZoU0hVYJyLCKtPNIu4B0Sx6TRaNZVWdQtBJAkJKMmWRMJ3Px49Dhrqk2KqbNmRl4t6qQLGJAu5HHOhsg5mugx6FjVm0qni7v3u3TjvId62ZRtc2sBuO6k4ryLQvuGU8cJIsTAGJFDKOCtPn4ifYjMeFkhYV9+8+P2/zzkzapyT5NByAFQemj0cQ8essGhLVKAQILBDXFwRTfgwLaUWw3KvCj8iz0S1nZdc3yReFvfdbuHx+3CQ7+WuSJbCq2DgFox9JbDBCMX7zbK2kU05W6vMjiQP4nAuVQOZ1f2ZRRg0mpv5B5t7LAcDHzB8/xb3zSFhaUkuTDSZqbIwPCgZo5mOTPCJkEhDaU2JP0BSK/A688cPiAb78fO3zMkPfadHjj07afdXLZrmE+yPkAwdccX0CDfgPDYeloff/fk/xpxoj6/pz2z8CYH21t14Y58m5dcaaY64H5vP15+6io7+8Jt5gacjhAylrtRkQliiTCzWLjNREcK0Oo8wuNnV+u7/e7hp4/q+/zKwaIl+uzlO1J19f9COj47sUTpoyEybz7RYf323TEFTY1xffalWx2EvnYUr+aDKvRcChAFiVSdtT6UBvD/3azWS42jwzL7bm6/n+4823Hhp4/tzloLs9Q+vcCICuj6yW5ezbOyV4bp8hOOn9oea1BIfgp3VLSLbZqiYMBYiuDKbG2zRHbN516/5Rzex51QlTFUFEl2YMj1v1V5KUYYycguM5L7HcQhSPRhdC4pnQkQFJhYVUehbkwHwRMtcPf4NxfYjVD8v1SfNlLi+W6kGGtA1qQBCPUDL9+z3pzPdPY7TWSWW+0CW/AQ0vTsZrSOkgILJHomvPRcCJAjNHppXytZ+KbNPDXNP6fNG0Abjf0S03RF9KBmZTjRRnf4yQ+sDVI5XSA2IZNxVSaQRdXU0kG2o+gc3EVJfWmvj/DTQdfjqo++XxBe6eTxRkBiR0wL7VUnlGeTRGu8OU2VWr2nuPYfLJonBSQRcVZ1LfL8yvOpJWfXnuzLI9jOJr6naJA6vwio2MjMErth9DcAQAprdLMaMD7vMc8Yve0hUXZSYgD5d26deraddS4oRmrYm6W54sZmRSU0AP5GgICJChiQDCiK2lsijQgtsLmAaRObdySZNwZf2XL1Gs6AKp+NKBavWLurKCPO8hYDgGh8X7bjnGxHncqUJ8XOJIun4I6ci7P3R/7Qd3AP9kAgk0hazm3/JGAtk03YXmbk0yqVO5JAwKdE1Hrb/lNqPXufz3I4/bm1Wx7UqpWI9v8Qu6K3ArlizYubm3d3JFkIRH9sF2nwsxEmw3Dfyf2sg8IFjT+DbqaLglIdX/rshtB32F5N/0mHYveAkZPDhCMdkdCyV3fEeQpI08X8pBT9ADaO1saUL2hGKWvv334Jaxm3KQRx3YtPntgmYfXBPBC59ffjUFxQ6AMH6QKpa4vczhfkIw/a5zbC8QsaMYgEHwYGjIrafdMiuyHhWF5WORt37HbEiuVTxLQoZi9DV49rI935eXhQuF9aHMyfOfDXhMjF09K9B4xdsj4ySN2rp/N0ogTe5ZM/nr0iLFDQ0K/uVGah7k21bX47qDD4m9kcLVD/kadnqYp79Cpxfafgk4sYGMihfYmD7Y2yKXeq9f+uKPK5rAgOVYgMArsTnkhVGH/XShnVt6pLMC1das8r95YzDobTcpb5fnovF2R32hWind7NY1/uTro16gEcF1e4vr/ikJkdGTuQ+mU51B2EAV0E+jwkgsW9GR9kKbGe4CYkbc7zZ9MJ5eR3cvbYq9cz3okLOL4Qr5aUuhPe6chp7MzkvWcWEJzJ5GXm4hOjc/gY9GbnqAPEhg1wPnd8xlmw4hhiupPqhj8PoWd/zfiQ0qbXEwMtyybiqPgdGzRQHKY+ZGYHarUxuYKFLmDsQdu+U0UM2KmNHMc7ZpB2oL/EpNUSb8qn3ZOp+lj8LimdG76TTkQexiLbOZIelfCJWNgMOfpBncoxuTfleZNBiY4pv8Wk+iQwjx3TKO5E8mvaxM0LpynuyEwbGfCFWVLSDWwiE1J166ELa7z7stMSYwJe5g2mj8Fp1ewP9iwn4VJQ2FTMP30clJE0NRR5NelCRpIXuvd73LYsk3J1YxO8wNijDQptYdjdlX7fyc2JaYfXMjLlcJ607xJpIikQ/OpJJPfrVkJz8LEEDAWQg8GYNjVTDo4n4rCac5EXOGMe1M0eHS1vwdCEHVKHaPTQgAJmLYkGS6Fr7B6bhfIjjWBFBq4iaMH8gckzZe3rK0pfJx5eAEdXcQLDXzckkLFkZTmAygIRDGFgbaHxgWCP74YvhqJhYCmpQFijHC77Y6/UBYys8ZnENYtOnQCKR4WZP3WpzPvrQK6U2APXmjgo4+7lYjcCgVic0XCdJf7PkNKQ2fDFeLRjE6LBCQ+cXV74s+WhM676zsKLhM7ERnUw6gxSY9k3PHP3vEdczVswe7488KZaumAxNZUvz2x4kxkvikwEFGl1T3JpGFJQ8F0/CM13gNxb56OLER8LFiNowESMEHrk+/sjj93NjJXFxSNwL/eu7fVrGSMF0MmEutnYzC4zrv3bd9x2qCYM5F5OMLrU+4KtR6HBiQitS6lBo4cqSN+/1dD5+uConDv3PEdCz9S4zMQVgahgY/gaPH3ANCroQtORyowBeUnTUqNmIuzABKRYpvkwGtD8q1NSZatSfrtiWUI7SA08BGd+AoDMEyYwvSvduigBAAACAFY/9Z3CXyLDJZg20Gh7OWLuiAECRIkSJAgQYLGCBIkSJAgQYI4CBD5MYF/GSMAAAAASUVORK5CYII=",
  pfp29 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAKBklEQVR42u3bBVQbWRcH8Ky7L7Lui9XdWxLqtsbZeonggXq7UleCQ93d3d0V9yRIHHciZGLzvsukX85mXXlTzpzzrzf2y30yd2ZYftGIye+EAWKAGCAGiAFigBggBogBYsIAMUAMEAPEADFADFCrRESFAfpVmiGJdWP2nB++vtgvmmSAnGgGxxpH77o88d44ftGHU7MGfHV0y9CkGj8RA9RCYB2xKffbKzN5Eg+B3EUgc4Wf+cXvTrr/DVTT4LhmXEwsOugMW1P6zem4gNzuD2lkbvZQTG/ypJ+NuxY5cnOWX4yVYmqjQBwRYouQb5RT/BIaxh7cPzl9qKDkLUrH7dcCZC5T8zp9dWblkDVyXxFpfyw8G0fUFoCoTxKNvkiyBW83LTlmSL6g3XKtaeMVbfT5yvkpsdNKOgXCaJL9ug5f5goRyj9epO61tmz8dunmLTfL117UrTqpj9xN+K+xDo5BbGcmDuRRAbJ/w1M2WjZeacosrqqrLyX0atKoQiYVIlQWo1xnzCrRnj5VPX+xum+g7C2w+BnNXGWHPZXhuY376g1pJmMhaZIjk5IkVGaDuqlRI1VV7L/TELbDNDSWBCbIsFjzqDjDyDjDkBgr9cXQGAh0xiTaoF4UZeVWOwrl4hw1IjTwgWv0905Ufz9T4QWlZNcJk3+wrYKv1F2wEnJElML/hDg91tQSeGx1bene241Bm6tj9m+5cJF759qXt699deKccP7O0yNiDRx6AoHOhPWWC5m1hEFNufxhNACR07h3kboPT/bmLKX3tbo4wiiFv//jx5qgGDXV5TdNxT2QhOWILufVfad+GBWn49ANCHTGr7feFVeTf+zy82oq1p5KKB37oH6jjVA6lcwfM6mR9gySdUJilj1gZMx7Pmb/NnoBgc7YRBvUDqXzlwOP0jbnQDXZdf5iNKjxMCr+4KdGqTeHjYlv4tCqglZf0JoM1Mf7e6Fo/n6qlyPJMw4gTdrn45I1HBE9gNgiFLDZoigvp+YdLFGj5hykHOQAKnnQyT+pkkYVBHscmxGXjj2lqDYJSZ61A50+HwJrPy3mICjjr5JtefJKZMILpEH6FCTzBB35A5/QjelQ1/iB7OMrYhcB+zfcQJASg5x/68yQqUtv9l1I0mUf5BuFYs82Wppx60DMqtPXpb3C6j24qH0IGrAYO5AIDY43jN578mDhAUTQAujM7dqOQaQnD3nxUEch8l2BCwiGd4xl5Na0cTdCeYUfn6tdjAgNHYBupFd3DSU9uQDUkh5z8ACRw9fJ/c8t5+Z3FFBH5GdrltATqF0wGrisdYEGx5q/OLR/SqavQOZub+XAMdSRqjk0GWLHb9T7CNBnAchh1HNe6wJBa31K+pBAxRv/7064hUpcb94LQboS+1YYZ0yq2/cv/Ri/ZabogN8MeQsQF3USInZUKwINTaqdkuHnaAPy5W7rzn5WL5pIVmYhE14gNTJKbYrhlrzHTXnPZF3pPXZeDixn7YJglGECAp0Zee/kRvU2zBxhSTmMzBrMG0XteVTk/vBoQ8pau3UhDDRvAeq3EJYUHEA8ueuGsx4NMzg6Ice4cQ7ZKMVaRApULkTixxxAm3fMs6/3vX/ABBRa6H5rTXdDxGBdJEc3e6T5zj58QKWo8TgqegdJWmjgZ8Udj4kLbntQU3Wv73EAwfiam/WecsEAfYSfLtJPF8ExLJ9sK7qGTDhmH/0DpPSFwlHd+3T/vtDYDSL/H1K9+TYvjBUE4yv6+ic1s9l60LFHyDHtDEd6casvZ0pUMR2qpiHjDd6Sy148EpZ5e+1AYA7quwALkMJ102nPxukc3U+AiLXjUFNOaw80owxpvoXyacx8PXDZeR++FYAgn1O7IR9cqxgA7TrqTdE4gNjN8XyyoQAPUAELjMoefHD4oGDNlsUJG1fMEB3qG17VIRyxV9EEKILdHBtE1uMEsk/S9nmayH3u5pkR46LEVOMV3xCjF5BzgOnK5Qmj4vScaGyTtK+e3kB1We7BG7LYIpzLPH2BIPrcV2ZvuwZA+DaKwsF0rqCK9I8C1kkBCOehBj2BQMda8OT+U98NizHjPVjtA0cbNAGyiB8j8p8y5LxgyHmpKuP9g6fnfJ1YzYnG2+4451E7i62PwAs0DoCsYtb9oqdXXhwbtvK4MO48d614WCwBOpgbZmGFb13Y3JnaKGIGggqqK2StOMb35Js6RiLfh30yDC3XfVMyB4GOY6DNznk3JaGnXsjBDgTzTmXqO7wllzpNs1/HhbNpv6ylaS9z5VNG32W89yC+uyE2CNWLcQJRRjfPDB84r4HqtOI87WOG0z7B9/wjZC68lhXNbVb221cvfGNtLMAOpM16RZhwadAqfECOc6rxh5PTpM9FF78WLHMLkLmsVHP0zbmIwApEZcP+lb74gURozaFkUvxYk+TxS4XP/1jy2goNR0cHIAnryMlIPxFJA6DDSSTVBibFrFLJ47eVfYz0ADp4YiZHhGgEZA8p64wM2diBbAWPJ+xKHLSKfkCIDkASVk2aW0BUim8UDYDW0hLoyEF+71lGDh2AVu7dC/0EJMELJEea8Y6NYv71rqPn5GPcKDoFbgBYuvtwzu2BloKnsQERclQ6Hmhs4sczL/cZP/+uBxd1mU4PIA51CZ5/UsWGI3Hq1M9JAGrGUEHN8kDpDZ91Wxf6zZB7chGEFkDOd6+QvHV5526stRionbRJg4i/EOohKvj5rzxEhcwtsRHKTUdz+wtLvfnWh6fD6Abk2FgLthIZRVVyjdJYfwVpj6OmU38iJ+F/6mpuSGWKour7Cv0Zhe6cQnv+96I7K9dekKgludLKvMKKbElleGLzZ1OBBkJjIMjQ2JZLgr9dQ6w6cDb/7giLxAUVvYoKX//NFL1iFrulXPlqWvS1/tOJIasypl4OjyzuMEP52XSFx69E+Tn8U2gO+5s96wfMq+kTYesT2ZJOwSS40B3IMdwg7Cg0cqEqYeNy9b2PYB/wq91i+HvZbc9Va+P6Ccs9qInDIwC1C6sfmLx73F0OvwTaKW9St4/Z4yKQvxEg/mTMifDu89O9+Bb4/45QLvQHcmbqMgPeq/XLedkH9wc3ZL6BJE46NWnuO3fPGDlbAqfSnT4hF0J2mqkaujNqclYXgRxcXAOpO339r37dT3TOJ7j5V0QeRaCuM6mi4KKOgUY4ZX7jzEg41YmkLGgYXzzxzZRFN9oLTB7c3/yE3nxLj/mZY45HBOR7THgwgL1+c4eIGgdNGwHyoj6PJ6+FqWdY3cLEjReO+8+N3d0tpImi+YMAh0+wodeSO13mFEOhUc/WFoHsob58W+cggyfXaUz9GSYnmrYKZI8n/NwKeUSBnMMAzUCemIA8AWgavYEg/RainvNwhbr0l95AVGLw5Z/fN8+kDQExQAwQA8QAMUBMGCAGiAFigBggBogBYoCY/A/WHbioOxyUEwAAAABJRU5ErkJggg==",
  pfp3 = "./assets/3-f0871c58.png",
  pfp4 = "./assets/4-61f6a6d6.png",
  pfp5 = "./assets/5-17c42ca6.png",
  pfp6 = "./assets/6-ae5f3eff.png",
  pfp7 = "./assets/7-8a53975d.png",
  pfp8 = "./assets/8-0ff7188c.png",
  pfp9 = "./assets/9-fdbbb4a2.png",
  pfp =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIAAgMAAACJFjxpAAAADFBMVEXFxcX////p6enW1tbAmiBwAAAFiElEQVR4AezAgQAAAACAoP2pF6kAAAAAAAAAAAAAAIDbu2MkvY0jiuMWWQoUmI50BB+BgRTpCAz4G6C8CJDrC3AEXGKPoMTlYA/gAJfwETawI8cuBs5Nk2KtvfiLW+gLfK9m+r3X82G653+JP/zjF8afP1S//y+An4/i51//AsB4aH+/QPD6EQAY/zwZwN8BAP50bh786KP4+VT+3fs4/noigEc+jnHeJrzxX+NWMDDh4g8+EXcnLcC9T8U5S/CdT8bcUeBEIrwBOiI8ki7Ba5+NrePgWUy89/nYyxQ8Iw3f+pWY4h1gb3eAW7sDTPEOsLc7wK1TIeDuDB+I/OA1QOUHv/dFsZQkhKkh4QlEfOULYz2nGj2/Nn1LmwR/86VxlCoAW6kCsHRGANx1RgCMo5Qh2EsZgrXNQZZShp5Liv7Il8eIc5C91EHY2hxk6bwYmNscZIReDBwtCdhbErC1JGBpScBcOgFMLQsZMQs5Whayd+UQsLYsZGlZyNyykKllISNmIUfAwifw8NXvTojAjGFrdYi11SGWVoeYWx1i6lmQCiEjFkKOVgjZ+xxIhZCtFULWHkCqxCw9gNQKmP9vNHzipdEPrRcxtVbAeDkAvve0iM2QozVD9hfjhp4YP/UrkJYDbD2AtBxgfSkAvvHEeNcDSAsilgtAWxIy91J8AXgZAJ5e33+4tuACcAG4AFwALgBXRXQB6AFcB5MXAuA6nl9/0Vx/011/1V5/1/dfTPJvRtdnu/zL6beeFO/7r+fXBYbrEkt/j+i6ytXfpuvvE/ZXOnsA/a3a/l5xf7O6v1t+Xe/vOyz6HpO8yyboM8o7rfJes77bru83THk48p7TvOs27zvOO6/73vO++z7l4cgnMPQzKPopHC0N9noSSz6LJp/Gk88jyicy5TOp6qlc+VyyfDJbPpuuns6XzyfMJzTmMyrrKZ35nNJ8Ums+q7af1tvPK+4nNodEnPKp3fnc8npyez67/qVP7+/fL8hfcMjfsOhf8cjfMclfcnn9+BkOnLECP8Q58OYeyJ40eoyF6Ee/En/JHlP6mIlRVXprF4BxtAvArV0AxtEuALd2ARhHuwDc2gVgHPX/hFv9fMBddjIGeKg/WCxlCsI46u+Ga5mCcJd+sIG9UkGAW32ZbApFAHhod4Bb3eo04h3god0BbiUHYApVCNjbHeBW+QDAXT4a7qg7r7e214057vg0QhkEHkoSwq0kIdydXw4/Q3H8hjYJ3vL0WConBJhCHQaOToeBrU0BljYFmEoVgHGUKgAPnREAt84IgLuqFgAYSUEOAHszDwuAtSkHAZhLGYIpdCLgKGUIHtocZG1zkLmUIRhxDnJU1RDA1uYga5uDzKUOwhTnIEfnxcDe5iBrcyQAYGlzkKkUYhhxDrKXQgxbSwLWUohhbknA1JKAEZOAvSUBW0sC1pYEzC0JmFoSMMJyCDhaFrK3JGDtyiFgaVnI3LKQqWUhI2YhR8tC9paFrC0LWVoWMrcsZGpZyIhZyNGykL2rSIGtlQHWVgZYWhlgbmWAqZUBRiwDHK0MsLcywNbKAGsOoNUhllaHmFsdYmp1iBHrEEerQ+w5gFYI2VodYm11iKXVIeYcQCuETK0QMmIh5MgBtELI3gohWyuErDmAVolZWiFkzgG0SszUKjGjfj6gVmKOVonZcwCtFbB9HQC+ozWDbz1bvGu9iKW1AuYcQOtFTLEX1GbIaFegN0OOHEBrhuw5gNYM2XIArRuz5gDacoB3bTnAEktxXQ4wfw0AvveM8b4tiJjSJOwLIsbXsAKeNeKCiOO3D+AVbUl0AfjGs8ZPbUnIdgFoa1LWC0BblfMuB9AeC1j6gqQE0J9LmC8AOYD2ZMb7i4bt2ZTpWoHfPoB7Tj2fXzT8N1X41vkq/QHOAAAAAElFTkSuQmCC",
  ProfilePictures = {
    pfp1,
    pfp2,
    pfp3,
    pfp4,
    pfp5,
    pfp6,
    pfp7,
    pfp8,
    pfp9,
    pfp10,
    pfp11,
    pfp12,
    pfp13,
    pfp14,
    pfp15,
    pfp16,
    pfp17,
    pfp18,
    pfp19,
    pfp20,
    pfp21,
    pfp22,
    pfp23,
    pfp24,
    pfp25,
    pfp26,
    pfp27,
    pfp28,
    pfp29,
    def: pfp,
  };
function getProfilePicture($) {
  return typeof $ == "number"
    ? ProfilePictures[`pfp${$}`] || pfp
    : $.toString();
}
async function applyCustomPfp($) {
  const r = get_store_value(UserData);
  (r.acc.profilePicture = $), UserData.set(r);
}
const ProfilePicture_svelte_svelte_type_style_lang$1 = "";
function create_fragment$2q($) {
  let r, p;
  return {
    c() {
      (r = element("div")),
        attr(r, "class", (p = "pfprenderer " + $[2] + " pfp svelte-ypct2")),
        set_style(r, "background-image", "url('" + $[0] + "')"),
        set_style(r, "height", $[1] + "px");
    },
    m(v, k) {
      insert(v, r, k);
    },
    p(v, [k]) {
      k & 4 &&
        p !== (p = "pfprenderer " + v[2] + " pfp svelte-ypct2") &&
        attr(r, "class", p),
        k & 1 && set_style(r, "background-image", "url('" + v[0] + "')"),
        k & 2 && set_style(r, "height", v[1] + "px");
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      v && detach(r);
    },
  };
}
function instance$2a($, r, p) {
  let { src: v } = r,
    { height: k } = r,
    { className: x = "" } = r;
  return (
    ($.$$set = (S) => {
      "src" in S && p(0, (v = S.src)),
        "height" in S && p(1, (k = S.height)),
        "className" in S && p(2, (x = S.className));
    }),
    [v, k, x]
  );
}
let ProfilePicture$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$2a, create_fragment$2q, safe_not_equal, {
        src: 0,
        height: 1,
        className: 2,
      });
  }
};
function create_fragment$2p($) {
  let r,
    p = $[0].icon + "",
    v,
    k,
    x,
    S;
  return {
    c() {
      (r = element("button")),
        (v = text(p)),
        attr(r, "class", "material-icons-round"),
        attr(r, "title", (k = $[0].name));
    },
    m(I, F) {
      insert(I, r, F),
        append(r, v),
        x ||
          ((S = listen(r, "click", function () {
            is_function($[0].action) && $[0].action.apply(this, arguments);
          })),
          (x = !0));
    },
    p(I, [F]) {
      ($ = I),
        F & 1 && p !== (p = $[0].icon + "") && set_data(v, p),
        F & 1 && k !== (k = $[0].name) && attr(r, "title", k);
    },
    i: noop$1,
    o: noop$1,
    d(I) {
      I && detach(r), (x = !1), S();
    },
  };
}
function instance$29($, r, p) {
  let { action: v } = r;
  return (
    ($.$$set = (k) => {
      "action" in k && p(0, (v = k.action));
    }),
    [v]
  );
}
class Action extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$29, create_fragment$2p, safe_not_equal, {
        action: 0,
      });
  }
}
function create_fragment$2o($) {
  let r,
    p = $[0].icon + "",
    v,
    k,
    x,
    S;
  return {
    c() {
      (r = element("button")),
        (v = text(p)),
        attr(r, "class", "material-icons-round"),
        attr(r, "title", (k = $[0].name)),
        toggle_class(r, "active", $[1] && $[0].name == $[1].name);
    },
    m(I, F) {
      insert(I, r, F),
        append(r, v),
        x || ((S = listen(r, "click", $[2])), (x = !0));
    },
    p(I, [F]) {
      F & 1 && p !== (p = I[0].icon + "") && set_data(v, p),
        F & 1 && k !== (k = I[0].name) && attr(r, "title", k),
        F & 3 && toggle_class(r, "active", I[1] && I[0].name == I[1].name);
    },
    i: noop$1,
    o: noop$1,
    d(I) {
      I && detach(r), (x = !1), S();
    },
  };
}
function instance$28($, r, p) {
  let v;
  component_subscribe($, messagingPage, (S) => p(1, (v = S)));
  let { data: k } = r;
  function x() {
    set_store_value(messagingPage, (v = k), v);
  }
  return (
    ($.$$set = (S) => {
      "data" in S && p(0, (k = S.data));
    }),
    [k, v, x]
  );
}
let Page$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$28, create_fragment$2o, safe_not_equal, {
        data: 0,
      });
  }
};
function get_each_context$z($, r, p) {
  const v = $.slice();
  return (v[2] = r[p]), v;
}
function get_each_context_1$4($, r, p) {
  const v = $.slice();
  return (v[5] = r[p]), v;
}
function create_each_block_1$4($) {
  let r, p;
  return (
    (r = new Page$1({ props: { data: $[5][1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$z($) {
  let r, p;
  return (
    (r = new Action({ props: { action: $[2] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$2n($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L = Object.entries(MessagingPages),
    U = [];
  for (let Q = 0; Q < L.length; Q += 1)
    U[Q] = create_each_block_1$4(get_each_context_1$4($, L, Q));
  const N = (Q) =>
    transition_out(U[Q], 1, 1, () => {
      U[Q] = null;
    });
  let j = messageSidebarActions,
    R = [];
  for (let Q = 0; Q < j.length; Q += 1)
    R[Q] = create_each_block$z(get_each_context$z($, j, Q));
  const q = (Q) =>
    transition_out(R[Q], 1, 1, () => {
      R[Q] = null;
    });
  return (
    (F = new ProfilePicture$1({ props: { src: $[0], height: 20 } })),
    {
      c() {
        (r = element("div")), (p = element("div"));
        for (let Q = 0; Q < U.length; Q += 1) U[Q].c();
        (v = space()), (k = element("hr")), (x = space()), (S = element("div"));
        for (let Q = 0; Q < R.length; Q += 1) R[Q].c();
        (I = space()),
          create_component(F.$$.fragment),
          attr(p, "class", "pages"),
          attr(S, "class", "actions"),
          attr(r, "class", "sidebar");
      },
      m(Q, K) {
        insert(Q, r, K), append(r, p);
        for (let V = 0; V < U.length; V += 1) U[V] && U[V].m(p, null);
        append(r, v), append(r, k), append(r, x), append(r, S);
        for (let V = 0; V < R.length; V += 1) R[V] && R[V].m(S, null);
        append(r, I), mount_component(F, r, null), (O = !0);
      },
      p(Q, [K]) {
        if (K & 0) {
          L = Object.entries(MessagingPages);
          let H;
          for (H = 0; H < L.length; H += 1) {
            const G = get_each_context_1$4(Q, L, H);
            U[H]
              ? (U[H].p(G, K), transition_in(U[H], 1))
              : ((U[H] = create_each_block_1$4(G)),
                U[H].c(),
                transition_in(U[H], 1),
                U[H].m(p, null));
          }
          for (group_outros(), H = L.length; H < U.length; H += 1) N(H);
          check_outros();
        }
        if (K & 0) {
          j = messageSidebarActions;
          let H;
          for (H = 0; H < j.length; H += 1) {
            const G = get_each_context$z(Q, j, H);
            R[H]
              ? (R[H].p(G, K), transition_in(R[H], 1))
              : ((R[H] = create_each_block$z(G)),
                R[H].c(),
                transition_in(R[H], 1),
                R[H].m(S, null));
          }
          for (group_outros(), H = j.length; H < R.length; H += 1) q(H);
          check_outros();
        }
        const V = {};
        K & 1 && (V.src = Q[0]), F.$set(V);
      },
      i(Q) {
        if (!O) {
          for (let K = 0; K < L.length; K += 1) transition_in(U[K]);
          for (let K = 0; K < j.length; K += 1) transition_in(R[K]);
          transition_in(F.$$.fragment, Q), (O = !0);
        }
      },
      o(Q) {
        U = U.filter(Boolean);
        for (let K = 0; K < U.length; K += 1) transition_out(U[K]);
        R = R.filter(Boolean);
        for (let K = 0; K < R.length; K += 1) transition_out(R[K]);
        transition_out(F.$$.fragment, Q), (O = !1);
      },
      d(Q) {
        Q && detach(r),
          destroy_each(U, Q),
          destroy_each(R, Q),
          destroy_component(F);
      },
    }
  );
}
function instance$27($, r, p) {
  let v;
  component_subscribe($, UserData, (x) => p(1, (v = x)));
  let k;
  return (
    UserData.subscribe(() => {
      p(0, (k = getProfilePicture(v.acc.profilePicture)));
    }),
    [k]
  );
}
let SideBar$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$27, create_fragment$2n, safe_not_equal, {});
  }
};
const messaging$1 = "",
  pfpCache = {};
async function getUserPfp($) {
  if (!get_store_value(ConnectedServer)) return pfp;
  if (pfpCache[$]) return getProfilePicture(pfpCache[$]);
  const p = await getUsers();
  return p[$]
    ? ((pfpCache[$] = getProfilePicture(p[$].acc.profilePicture)), pfpCache[$])
    : pfp;
}
const partialFilters = ["#", "](", "![", "!", ">", "|", "(", ")"];
function filterPartial($) {
  let r = $;
  for (let p = 0; p < partialFilters.length; p++)
    r = r.split(partialFilters[p]).join("");
  return r;
}
function create_if_block$12($) {
  let r, p, v;
  return {
    c() {
      (r = element("span")),
        (p = text("reply")),
        attr(r, "class", "material-icons-round"),
        attr(r, "title", (v = $[0].replyingTo));
    },
    m(k, x) {
      insert(k, r, x), append(r, p);
    },
    p(k, x) {
      x & 1 && v !== (v = k[0].replyingTo) && attr(r, "title", v);
    },
    d(k) {
      k && detach(r);
    },
  };
}
function create_fragment$2m($) {
  let r,
    p,
    v,
    k,
    x,
    S = ($[1] ? $[0].receiver : $[0].sender) + "",
    I,
    F,
    O,
    L,
    U = (filterPartial($[0].partialBody) || "(no content)") + "",
    N,
    j,
    R,
    q = dayjs($[0].timestamp).format("DD-MM HH:mm") + "",
    Q,
    K,
    V,
    H;
  p = new ProfilePicture$1({ props: { src: $[2], height: 26 } });
  let G = $[0].replyingTo && create_if_block$12($);
  return {
    c() {
      (r = element("button")),
        create_component(p.$$.fragment),
        (v = space()),
        (k = element("div")),
        (x = element("p")),
        (I = text(S)),
        (F = space()),
        G && G.c(),
        (O = space()),
        (L = element("p")),
        (N = text(U)),
        (j = space()),
        (R = element("div")),
        (Q = text(q)),
        attr(x, "class", "username"),
        attr(L, "class", "partial"),
        attr(k, "class", "content"),
        attr(R, "class", "timestamp"),
        attr(r, "class", "message"),
        toggle_class(r, "selected", $[3] == $[0].id);
    },
    m(Y, J) {
      insert(Y, r, J),
        mount_component(p, r, null),
        append(r, v),
        append(r, k),
        append(k, x),
        append(x, I),
        append(x, F),
        G && G.m(x, null),
        append(k, O),
        append(k, L),
        append(L, N),
        append(r, j),
        append(r, R),
        append(R, Q),
        (K = !0),
        V || ((H = listen(r, "click", $[4])), (V = !0));
    },
    p(Y, [J]) {
      const Z = {};
      J & 4 && (Z.src = Y[2]),
        p.$set(Z),
        (!K || J & 3) &&
          S !== (S = (Y[1] ? Y[0].receiver : Y[0].sender) + "") &&
          set_data(I, S),
        Y[0].replyingTo
          ? G
            ? G.p(Y, J)
            : ((G = create_if_block$12(Y)), G.c(), G.m(x, null))
          : G && (G.d(1), (G = null)),
        (!K || J & 1) &&
          U !==
            (U = (filterPartial(Y[0].partialBody) || "(no content)") + "") &&
          set_data(N, U),
        (!K || J & 1) &&
          q !== (q = dayjs(Y[0].timestamp).format("DD-MM HH:mm") + "") &&
          set_data(Q, q),
        (!K || J & 9) && toggle_class(r, "selected", Y[3] == Y[0].id);
    },
    i(Y) {
      K || (transition_in(p.$$.fragment, Y), (K = !0));
    },
    o(Y) {
      transition_out(p.$$.fragment, Y), (K = !1);
    },
    d(Y) {
      Y && detach(r), destroy_component(p), G && G.d(), (V = !1), H();
    },
  };
}
function instance$26($, r, p) {
  let v;
  component_subscribe($, selectedMessageId, (O) => p(3, (v = O)));
  let { item: k } = r,
    x = !1,
    S = "";
  onMount(F), messageSubscribe(F);
  function I() {
    set_store_value(selectedMessageId, (v = k.id), v);
  }
  async function F() {
    p(2, (S = await getUserPfp(x ? k.receiver : k.sender)));
  }
  return (
    messagingPage.subscribe((O) => {
      p(1, (x = O.name == "Sent"));
    }),
    ($.$$set = (O) => {
      "item" in O && p(0, (k = O.item));
    }),
    [k, x, S, v, I]
  );
}
class MessageItem extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$26, create_fragment$2m, safe_not_equal, {
        item: 0,
      });
  }
}
function get_each_context$y($, r, p) {
  const v = $.slice();
  return (v[5] = r[p]), v;
}
function create_if_block$11($) {
  let r,
    p,
    v = $[2].name + "",
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U,
    N,
    j = $[0],
    R = [];
  for (let K = 0; K < j.length; K += 1)
    R[K] = create_each_block$y(get_each_context$y($, j, K));
  const q = (K) =>
    transition_out(R[K], 1, 1, () => {
      R[K] = null;
    });
  let Q = !$[0].length && create_if_block_1$i($);
  return {
    c() {
      (r = element("div")),
        (p = element("p")),
        (k = text(v)),
        (x = space()),
        (S = element("button")),
        (S.textContent = "sync"),
        (I = space()),
        (F = element("div"));
      for (let K = 0; K < R.length; K += 1) R[K].c();
      (O = space()),
        Q && Q.c(),
        attr(p, "class", "title"),
        attr(S, "class", "material-icons-round refresh"),
        attr(r, "class", "header"),
        attr(F, "class", "list");
    },
    m(K, V) {
      insert(K, r, V),
        append(r, p),
        append(p, k),
        append(r, x),
        append(r, S),
        insert(K, I, V),
        insert(K, F, V);
      for (let H = 0; H < R.length; H += 1) R[H] && R[H].m(F, null);
      append(F, O),
        Q && Q.m(F, null),
        (L = !0),
        U || ((N = listen(S, "click", $[3])), (U = !0));
    },
    p(K, V) {
      if (
        ((!L || V & 4) && v !== (v = K[2].name + "") && set_data(k, v), V & 1)
      ) {
        j = K[0];
        let H;
        for (H = 0; H < j.length; H += 1) {
          const G = get_each_context$y(K, j, H);
          R[H]
            ? (R[H].p(G, V), transition_in(R[H], 1))
            : ((R[H] = create_each_block$y(G)),
              R[H].c(),
              transition_in(R[H], 1),
              R[H].m(F, O));
        }
        for (group_outros(), H = j.length; H < R.length; H += 1) q(H);
        check_outros();
      }
      K[0].length
        ? Q && (Q.d(1), (Q = null))
        : Q
        ? Q.p(K, V)
        : ((Q = create_if_block_1$i(K)), Q.c(), Q.m(F, null));
    },
    i(K) {
      if (!L) {
        for (let V = 0; V < j.length; V += 1) transition_in(R[V]);
        L = !0;
      }
    },
    o(K) {
      R = R.filter(Boolean);
      for (let V = 0; V < R.length; V += 1) transition_out(R[V]);
      L = !1;
    },
    d(K) {
      K && detach(r),
        K && detach(I),
        K && detach(F),
        destroy_each(R, K),
        Q && Q.d(),
        (U = !1),
        N();
    },
  };
}
function create_each_block$y($) {
  let r, p;
  return (
    (r = new MessageItem({ props: { item: $[5] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.item = v[5]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_1$i($) {
  let r,
    p = $[1] ? "Loading..." : "No messages!",
    v;
  return {
    c() {
      (r = element("div")), (v = text(p)), attr(r, "class", "noitems");
    },
    m(k, x) {
      insert(k, r, x), append(r, v);
    },
    p(k, x) {
      x & 2 &&
        p !== (p = k[1] ? "Loading..." : "No messages!") &&
        set_data(v, p);
    },
    d(k) {
      k && detach(r);
    },
  };
}
function create_fragment$2l($) {
  let r,
    p,
    v = $[2] && create_if_block$11($);
  return {
    c() {
      (r = element("div")), v && v.c(), attr(r, "class", "listbar");
    },
    m(k, x) {
      insert(k, r, x), v && v.m(r, null), (p = !0);
    },
    p(k, [x]) {
      k[2]
        ? v
          ? (v.p(k, x), x & 4 && transition_in(v, 1))
          : ((v = create_if_block$11(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r, null))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      k && detach(r), v && v.d();
    },
  };
}
function sort($) {
  return $.sort(function (r, p) {
    return new Date(p.timestamp).getTime() - new Date(r.timestamp).getTime();
  });
}
function isSame($, r) {
  if ($.length != r.length) return !1;
  for (let p = 0; p < r.length; p++) {
    let v = !1;
    for (let k = 0; k < $.length; k++) $[k].id == r[p].id && (v = !0);
    if (!v) return !1;
  }
  return !0;
}
function instance$25($, r, p) {
  let v;
  component_subscribe($, messagingPage, (F) => p(2, (v = F)));
  let k = [],
    x = !1;
  onMount(() => {
    messageUpdateTrigger();
  }),
    messageSubscribe(S);
  async function S() {
    if ((p(1, (x = !0)), !v)) return;
    const F = await v.msgGetter();
    isSame(k, F) || I(sort(F)), p(1, (x = !1));
  }
  function I(F) {
    p(0, (k = [])),
      setTimeout(() => {
        p(0, (k = F));
      });
  }
  return [k, x, v, S];
}
class ListBar extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$25, create_fragment$2l, safe_not_equal, {});
  }
}
async function sendMessage($, r) {
  const p = await get_store_value(ConnectedServer);
  return p
    ? !(await apiCall(
        p,
        "messages/send",
        { target: btoa($) },
        get_store_value(UserToken),
        null,
        r
      ))
    : !1;
}
async function replyToMessage($, r, p) {
  const v = await get_store_value(ConnectedServer);
  return v
    ? !(await apiCall(
        v,
        "messages/reply",
        { target: btoa(r), id: $ },
        get_store_value(UserToken),
        null,
        p
      ))
    : !1;
}
function create_if_block$10($) {
  let r,
    p = 2e3 - $[1].length + "",
    v;
  return {
    c() {
      (r = element("div")),
        (v = text(p)),
        attr(r, "class", "counter"),
        toggle_class(r, "critical", $[1].length > 1980);
    },
    m(k, x) {
      insert(k, r, x), append(r, v);
    },
    p(k, x) {
      x & 2 && p !== (p = 2e3 - k[1].length + "") && set_data(v, p),
        x & 2 && toggle_class(r, "critical", k[1].length > 1980);
    },
    d(k) {
      k && detach(r);
    },
  };
}
function create_fragment$2k($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U,
    N = $[3] ? "Reply" : "Send",
    j,
    R,
    q,
    Q,
    K = $[1].length > 1950 && create_if_block$10($);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("button")),
        (v.textContent = "remove_red_eye"),
        (k = space()),
        (x = element("button")),
        (x.textContent = "edit"),
        (S = space()),
        K && K.c(),
        (I = space()),
        (F = element("div")),
        (O = element("button")),
        (O.textContent = "Delete"),
        (L = space()),
        (U = element("button")),
        (j = text(N)),
        attr(v, "class", "material-icons-round"),
        toggle_class(v, "selected", $[0]),
        attr(x, "class", "material-icons-round"),
        toggle_class(x, "selected", !$[0]),
        attr(p, "class", "view-group"),
        (U.disabled = R = !$[1] || !$[2]),
        attr(F, "class", "right"),
        attr(r, "class", "editor-send");
    },
    m(V, H) {
      insert(V, r, H),
        append(r, p),
        append(p, v),
        append(p, k),
        append(p, x),
        append(r, S),
        K && K.m(r, null),
        append(r, I),
        append(r, F),
        append(F, O),
        append(F, L),
        append(F, U),
        append(U, j),
        q ||
          ((Q = [
            listen(v, "click", $[7]),
            listen(x, "click", $[6]),
            listen(O, "click", $[5]),
            listen(U, "click", $[4]),
          ]),
          (q = !0));
    },
    p(V, [H]) {
      H & 1 && toggle_class(v, "selected", V[0]),
        H & 1 && toggle_class(x, "selected", !V[0]),
        V[1].length > 1950
          ? K
            ? K.p(V, H)
            : ((K = create_if_block$10(V)), K.c(), K.m(r, I))
          : K && (K.d(1), (K = null)),
        H & 8 && N !== (N = V[3] ? "Reply" : "Send") && set_data(j, N),
        H & 6 && R !== (R = !V[1] || !V[2]) && (U.disabled = R);
    },
    i: noop$1,
    o: noop$1,
    d(V) {
      V && detach(r), K && K.d(), (q = !1), run_all(Q);
    },
  };
}
function instance$24($, r, p) {
  let v;
  component_subscribe($, replyMessageId, (U) => p(3, (v = U)));
  let { content: k } = r,
    { target: x } = r,
    { viewing: S } = r;
  async function I() {
    v ? await replyToMessage(v, x, k) : await sendMessage(x, k),
      creatingMessage.set(!1),
      messageUpdateTrigger();
  }
  function F() {
    createOverlayableError(
      {
        title: "Delete message?",
        message:
          "Are you sure you want to delete this draft? This cannot be undone.",
        image: warning,
        buttons: [
          {
            caption: "Delete",
            action: () => {
              creatingMessage.set(!1), messageUpdateTrigger();
            },
          },
          { caption: "Cancel", action: () => {} },
        ],
      },
      "MessagingApp"
    );
  }
  function O() {
    p(0, (S = !1));
  }
  function L() {
    p(0, (S = !0));
  }
  return (
    ($.$$set = (U) => {
      "content" in U && p(1, (k = U.content)),
        "target" in U && p(2, (x = U.target)),
        "viewing" in U && p(0, (S = U.viewing));
    }),
    [S, k, x, v, I, F, O, L]
  );
}
class Bottom extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$24, create_fragment$2k, safe_not_equal, {
        content: 1,
        target: 2,
        viewing: 0,
      });
  }
}
function create_fragment$2j($) {
  let r,
    p,
    v,
    k,
    x = ($[0][0] || "<unknown>") + "",
    S,
    I,
    F,
    O;
  return (
    (p = new ProfilePicture$1({ props: { src: $[1] || pfp, height: 24 } })),
    {
      c() {
        (r = element("button")),
          create_component(p.$$.fragment),
          (v = space()),
          (k = element("p")),
          (S = text(x)),
          attr(r, "class", "user");
      },
      m(L, U) {
        insert(L, r, U),
          mount_component(p, r, null),
          append(r, v),
          append(r, k),
          append(k, S),
          (I = !0),
          F || ((O = listen(r, "click", $[2])), (F = !0));
      },
      p(L, [U]) {
        const N = {};
        U & 2 && (N.src = L[1] || pfp),
          p.$set(N),
          (!I || U & 1) &&
            x !== (x = (L[0][0] || "<unknown>") + "") &&
            set_data(S, x);
      },
      i(L) {
        I || (transition_in(p.$$.fragment, L), (I = !0));
      },
      o(L) {
        transition_out(p.$$.fragment, L), (I = !1);
      },
      d(L) {
        L && detach(r), destroy_component(p), (F = !1), O();
      },
    }
  );
}
function instance$23($, r, p) {
  let { selecting: v } = r,
    { target: k } = r,
    { entry: x } = r,
    { pfp: S } = r,
    I;
  onMount(async () => {
    p(1, (I = await getUserPfp(x[0])));
  });
  function F() {
    p(3, (v = !1)), p(4, (k = x[0])), p(5, (S = I));
  }
  return (
    ($.$$set = (O) => {
      "selecting" in O && p(3, (v = O.selecting)),
        "target" in O && p(4, (k = O.target)),
        "entry" in O && p(0, (x = O.entry)),
        "pfp" in O && p(5, (S = O.pfp));
    }),
    [x, I, F, v, k, S]
  );
}
let User$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$23, create_fragment$2j, safe_not_equal, {
        selecting: 3,
        target: 4,
        entry: 0,
        pfp: 5,
      });
  }
};
function get_each_context$x($, r, p) {
  const v = $.slice();
  return (v[10] = r[p]), v;
}
function create_each_block$x($) {
  let r, p, v, k, x;
  function S(L) {
    $[6](L);
  }
  function I(L) {
    $[7](L);
  }
  function F(L) {
    $[8](L);
  }
  let O = { entry: $[10] };
  return (
    $[0] !== void 0 && (O.target = $[0]),
    $[3] !== void 0 && (O.selecting = $[3]),
    $[2] !== void 0 && (O.pfp = $[2]),
    (r = new User$1({ props: O })),
    binding_callbacks.push(() => bind$1(r, "target", S)),
    binding_callbacks.push(() => bind$1(r, "selecting", I)),
    binding_callbacks.push(() => bind$1(r, "pfp", F)),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(L, U) {
        mount_component(r, L, U), (x = !0);
      },
      p(L, U) {
        const N = {};
        U & 2 && (N.entry = L[10]),
          !p &&
            U & 1 &&
            ((p = !0), (N.target = L[0]), add_flush_callback(() => (p = !1))),
          !v &&
            U & 8 &&
            ((v = !0),
            (N.selecting = L[3]),
            add_flush_callback(() => (v = !1))),
          !k &&
            U & 4 &&
            ((k = !0), (N.pfp = L[2]), add_flush_callback(() => (k = !1))),
          r.$set(N);
      },
      i(L) {
        x || (transition_in(r.$$.fragment, L), (x = !0));
      },
      o(L) {
        transition_out(r.$$.fragment, L), (x = !1);
      },
      d(L) {
        destroy_component(r, L);
      },
    }
  );
}
function create_fragment$2i($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F = $[4] ? "Reply" : "Send",
    O,
    L,
    U,
    N,
    j = ($[4] ? `#${$[4]} (${$[0]})` : $[0] || "Please select") + "",
    R,
    q,
    Q,
    K,
    V,
    H;
  k = new ProfilePicture$1({ props: { src: $[2] || pfp, height: 32 } });
  let G = $[1],
    Y = [];
  for (let Z = 0; Z < G.length; Z += 1)
    Y[Z] = create_each_block$x(get_each_context$x($, G, Z));
  const J = (Z) =>
    transition_out(Y[Z], 1, 1, () => {
      Y[Z] = null;
    });
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("div")),
        create_component(k.$$.fragment),
        (x = space()),
        (S = element("div")),
        (I = element("p")),
        (O = text(F)),
        (L = text(" to:")),
        (U = space()),
        (N = element("p")),
        (R = text(j)),
        (q = space()),
        (Q = element("div"));
      for (let Z = 0; Z < Y.length; Z += 1) Y[Z].c();
      attr(I, "class", "header"),
        attr(v, "class", "current"),
        attr(p, "class", "target-selector"),
        attr(Q, "class", "target-options"),
        toggle_class(Q, "visible", $[3]),
        attr(r, "class", "target-wrapper");
    },
    m(Z, X) {
      insert(Z, r, X),
        append(r, p),
        append(p, v),
        mount_component(k, v, null),
        append(v, x),
        append(v, S),
        append(S, I),
        append(I, O),
        append(I, L),
        append(S, U),
        append(S, N),
        append(N, R),
        append(r, q),
        append(r, Q);
      for (let ee = 0; ee < Y.length; ee += 1) Y[ee] && Y[ee].m(Q, null);
      (K = !0), V || ((H = listen(p, "click", $[5])), (V = !0));
    },
    p(Z, [X]) {
      const ee = {};
      if (
        (X & 4 && (ee.src = Z[2] || pfp),
        k.$set(ee),
        (!K || X & 16) && F !== (F = Z[4] ? "Reply" : "Send") && set_data(O, F),
        (!K || X & 17) &&
          j !==
            (j =
              (Z[4] ? `#${Z[4]} (${Z[0]})` : Z[0] || "Please select") + "") &&
          set_data(R, j),
        X & 15)
      ) {
        G = Z[1];
        let te;
        for (te = 0; te < G.length; te += 1) {
          const ie = get_each_context$x(Z, G, te);
          Y[te]
            ? (Y[te].p(ie, X), transition_in(Y[te], 1))
            : ((Y[te] = create_each_block$x(ie)),
              Y[te].c(),
              transition_in(Y[te], 1),
              Y[te].m(Q, null));
        }
        for (group_outros(), te = G.length; te < Y.length; te += 1) J(te);
        check_outros();
      }
      (!K || X & 8) && toggle_class(Q, "visible", Z[3]);
    },
    i(Z) {
      if (!K) {
        transition_in(k.$$.fragment, Z);
        for (let X = 0; X < G.length; X += 1) transition_in(Y[X]);
        K = !0;
      }
    },
    o(Z) {
      transition_out(k.$$.fragment, Z), (Y = Y.filter(Boolean));
      for (let X = 0; X < Y.length; X += 1) transition_out(Y[X]);
      K = !1;
    },
    d(Z) {
      Z && detach(r), destroy_component(k), destroy_each(Y, Z), (V = !1), H();
    },
  };
}
function instance$22($, r, p) {
  let v;
  component_subscribe($, replyMessageId, (j) => p(4, (v = j)));
  let { users: k } = r,
    { target: x } = r,
    S = "",
    I = !1;
  async function F() {
    p(2, (S = await getUserPfp(x)));
  }
  function O() {
    if (v) return p(3, (I = !1));
    p(3, (I = !I));
  }
  replyMessageId.subscribe(() => setTimeout(F, 500));
  function L(j) {
    (x = j), p(0, x);
  }
  function U(j) {
    (I = j), p(3, I);
  }
  function N(j) {
    (S = j), p(2, S);
  }
  return (
    ($.$$set = (j) => {
      "users" in j && p(1, (k = j.users)),
        "target" in j && p(0, (x = j.target));
    }),
    [x, k, S, I, v, O, L, U, N]
  );
}
class TargetSelector extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$22, create_fragment$2i, safe_not_equal, {
        users: 1,
        target: 0,
      });
  }
}
function create_else_block$j($) {
  let r, p, v;
  return (
    (p = new SvelteMarkdown({ props: { source: $[2] } })),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          attr(r, "class", "markdownrenderer");
      },
      m(k, x) {
        insert(k, r, x), mount_component(p, r, null), (v = !0);
      },
      p(k, x) {
        const S = {};
        x & 4 && (S.source = k[2]), p.$set(S);
      },
      i(k) {
        v || (transition_in(p.$$.fragment, k), (v = !0));
      },
      o(k) {
        transition_out(p.$$.fragment, k), (v = !1);
      },
      d(k) {
        k && detach(r), destroy_component(p);
      },
    }
  );
}
function create_if_block$$($) {
  let r, p, v;
  return {
    c() {
      (r = element("textarea")),
        attr(r, "placeholder", "New message"),
        attr(r, "maxlength", "2000");
    },
    m(k, x) {
      insert(k, r, x),
        set_input_value(r, $[2]),
        p || ((v = listen(r, "input", $[5])), (p = !0));
    },
    p(k, x) {
      x & 4 && set_input_value(r, k[2]);
    },
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_fragment$2h($) {
  let r, p, v, k, x, S, I, F, O, L;
  function U(V) {
    $[4](V);
  }
  let N = { users: $[0] };
  $[1] !== void 0 && (N.target = $[1]),
    (p = new TargetSelector({ props: N })),
    binding_callbacks.push(() => bind$1(p, "target", U));
  const j = [create_if_block$$, create_else_block$j],
    R = [];
  function q(V, H) {
    return V[3] ? 1 : 0;
  }
  (x = q($)), (S = R[x] = j[x]($));
  function Q(V) {
    $[6](V);
  }
  let K = { target: $[1], content: $[2] };
  return (
    $[3] !== void 0 && (K.viewing = $[3]),
    (F = new Bottom({ props: K })),
    binding_callbacks.push(() => bind$1(F, "viewing", Q)),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (k = space()),
          S.c(),
          (I = space()),
          create_component(F.$$.fragment),
          attr(r, "class", "editor");
      },
      m(V, H) {
        insert(V, r, H),
          mount_component(p, r, null),
          insert(V, k, H),
          R[x].m(V, H),
          insert(V, I, H),
          mount_component(F, V, H),
          (L = !0);
      },
      p(V, [H]) {
        const G = {};
        H & 1 && (G.users = V[0]),
          !v &&
            H & 2 &&
            ((v = !0), (G.target = V[1]), add_flush_callback(() => (v = !1))),
          p.$set(G);
        let Y = x;
        (x = q(V)),
          x === Y
            ? R[x].p(V, H)
            : (group_outros(),
              transition_out(R[Y], 1, 1, () => {
                R[Y] = null;
              }),
              check_outros(),
              (S = R[x]),
              S ? S.p(V, H) : ((S = R[x] = j[x](V)), S.c()),
              transition_in(S, 1),
              S.m(I.parentNode, I));
        const J = {};
        H & 2 && (J.target = V[1]),
          H & 4 && (J.content = V[2]),
          !O &&
            H & 8 &&
            ((O = !0), (J.viewing = V[3]), add_flush_callback(() => (O = !1))),
          F.$set(J);
      },
      i(V) {
        L ||
          (transition_in(p.$$.fragment, V),
          transition_in(S),
          transition_in(F.$$.fragment, V),
          (L = !0));
      },
      o(V) {
        transition_out(p.$$.fragment, V),
          transition_out(S),
          transition_out(F.$$.fragment, V),
          (L = !1);
      },
      d(V) {
        V && detach(r),
          destroy_component(p),
          V && detach(k),
          R[x].d(V),
          V && detach(I),
          destroy_component(F, V);
      },
    }
  );
}
function instance$21($, r, p) {
  let v = [],
    k = "",
    x = "",
    S = !1;
  onMount(async () => {
    p(0, (v = Object.entries(await getUsers())));
  }),
    replyMessageId.subscribe(async (L) => {
      if (!L) return;
      const U = await getMessage(L);
      U && p(1, (k = U.sender));
    });
  function I(L) {
    (k = L), p(1, k);
  }
  function F() {
    (x = this.value), p(2, x);
  }
  function O(L) {
    (S = L), p(3, S);
  }
  return [v, k, x, S, I, F, O];
}
class Editor extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$21, create_fragment$2h, safe_not_equal, {});
  }
}
function create_fragment$2g($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (S = element("p")),
        (S.textContent = "No content."),
        (I = space()),
        (F = element("p")),
        (F.textContent = "Please select a message or create a new one."),
        (O = space()),
        (L = element("br")),
        (U = space()),
        (N = element("button")),
        (N.textContent = "New Message"),
        src_url_equal(v.src, (k = logo$3)) || attr(v, "src", k),
        attr(v, "alt", "Messaging"),
        attr(S, "class", "header"),
        attr(p, "class", "no-content"),
        attr(r, "class", "no-content-wrapper");
    },
    m(q, Q) {
      insert(q, r, Q),
        append(r, p),
        append(p, v),
        append(p, x),
        append(p, S),
        append(p, I),
        append(p, F),
        append(p, O),
        append(p, L),
        append(p, U),
        append(p, N),
        j || ((R = listen(N, "click", $[1])), (j = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(q) {
      q && detach(r), (j = !1), R();
    },
  };
}
function instance$20($, r, p) {
  let v;
  return (
    component_subscribe($, creatingMessage, (x) => p(0, (v = x))),
    [v, () => set_store_value(creatingMessage, (v = !0), v)]
  );
}
class NoContent extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$20, create_fragment$2g, safe_not_equal, {});
  }
}
const content = "";
async function getPartialTree($) {
  const r = get_store_value(ConnectedServer);
  return r
    ? (
        await apiCall(
          r,
          "messages/thread",
          { id: btoa($) },
          get_store_value(UserToken)
        )
      ).data
    : !1;
}
async function getParentMessage($) {
  const r = await getMessages();
  let p;
  for (let k = 0; k < r.length; k++) r[k].id == $ && (p = r[k].replyingTo);
  if (!p) return;
  const v = await getMessage(p);
  return v.replyingTo ? await getParentMessage(p) : v;
}
function get_each_context$w($, r, p) {
  const v = $.slice();
  return (v[4] = r[p]), v;
}
function create_if_block$_($) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        src_url_equal(p.src, (v = warning)) || attr(p, "src", v),
        attr(p, "alt", ""),
        attr(r, "class", "material-icons-round"),
        attr(r, "title", "Receiver no longer exists");
    },
    m(k, x) {
      insert(k, r, x), append(r, p);
    },
    p: noop$1,
    d(k) {
      k && detach(r);
    },
  };
}
function create_each_block$w($) {
  let r,
    p = $[4].icon + "",
    v,
    k,
    x;
  function S() {
    return $[3]($[4]);
  }
  return {
    c() {
      (r = element("button")),
        (v = text(p)),
        attr(r, "class", "material-icons-round"),
        attr(r, "title", $[4].name);
    },
    m(I, F) {
      insert(I, r, F),
        append(r, v),
        k || ((x = listen(r, "click", S)), (k = !0));
    },
    p(I, F) {
      $ = I;
    },
    d(I) {
      I && detach(r), (k = !1), x();
    },
  };
}
function create_fragment$2f($) {
  let r,
    p,
    v,
    k,
    x,
    S = $[0].sender + "",
    I,
    F,
    O,
    L = $[2]($[0].timestamp) + "",
    U,
    N,
    j,
    R = $[0].receiver.startsWith("deleted#"),
    q,
    Q;
  p = new ProfilePicture$1({ props: { height: 32, src: $[1] } });
  let K = R && create_if_block$_(),
    V = messageItemActions,
    H = [];
  for (let G = 0; G < V.length; G += 1)
    H[G] = create_each_block$w(get_each_context$w($, V, G));
  return {
    c() {
      (r = element("div")),
        create_component(p.$$.fragment),
        (v = space()),
        (k = element("div")),
        (x = element("p")),
        (I = text(S)),
        (F = space()),
        (O = element("p")),
        (U = text(L)),
        (N = space()),
        (j = element("div")),
        K && K.c(),
        (q = space());
      for (let G = 0; G < H.length; G += 1) H[G].c();
      attr(x, "class", "name"),
        attr(O, "class", "id"),
        attr(k, "class", "context"),
        attr(j, "class", "actions"),
        attr(r, "class", "message-header");
    },
    m(G, Y) {
      insert(G, r, Y),
        mount_component(p, r, null),
        append(r, v),
        append(r, k),
        append(k, x),
        append(x, I),
        append(k, F),
        append(k, O),
        append(O, U),
        append(r, N),
        append(r, j),
        K && K.m(j, null),
        append(j, q);
      for (let J = 0; J < H.length; J += 1) H[J] && H[J].m(j, null);
      Q = !0;
    },
    p(G, [Y]) {
      const J = {};
      if (
        (Y & 2 && (J.src = G[1]),
        p.$set(J),
        (!Q || Y & 1) && S !== (S = G[0].sender + "") && set_data(I, S),
        (!Q || Y & 1) &&
          L !== (L = G[2](G[0].timestamp) + "") &&
          set_data(U, L),
        Y & 1 && (R = G[0].receiver.startsWith("deleted#")),
        R
          ? K
            ? K.p(G, Y)
            : ((K = create_if_block$_()), K.c(), K.m(j, q))
          : K && (K.d(1), (K = null)),
        Y & 1)
      ) {
        V = messageItemActions;
        let Z;
        for (Z = 0; Z < V.length; Z += 1) {
          const X = get_each_context$w(G, V, Z);
          H[Z]
            ? H[Z].p(X, Y)
            : ((H[Z] = create_each_block$w(X)), H[Z].c(), H[Z].m(j, null));
        }
        for (; Z < H.length; Z += 1) H[Z].d(1);
        H.length = V.length;
      }
    },
    i(G) {
      Q || (transition_in(p.$$.fragment, G), (Q = !0));
    },
    o(G) {
      transition_out(p.$$.fragment, G), (Q = !1);
    },
    d(G) {
      G && detach(r), destroy_component(p), K && K.d(), destroy_each(H, G);
    },
  };
}
function instance$1$($, r, p) {
  let { message: v } = r,
    k = "";
  onMount(async () => {
    p(1, (k = await getUserPfp(v.sender)));
  }),
    messageSubscribe(async () => {
      p(1, (k = await getUserPfp(v.sender)));
    });
  function x(I) {
    return dayjs(I).format("DD MMM, HH:mm");
  }
  const S = (I) => I.action(v);
  return (
    ($.$$set = (I) => {
      "message" in I && p(0, (v = I.message));
    }),
    [v, k, x, S]
  );
}
class Header extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1$, create_fragment$2f, safe_not_equal, {
        message: 0,
      });
  }
}
function create_if_block$Z($) {
  let r,
    p,
    v,
    k,
    x,
    S = $[1] ? "Loading..." : "View Thread",
    I,
    F,
    O;
  return {
    c() {
      (r = element("div")),
        (p = element("p")),
        (p.textContent = "Message is part of a thread."),
        (v = space()),
        (k = element("div")),
        (x = element("button")),
        (I = text(S)),
        attr(p, "class", "caption"),
        (x.disabled = $[1]),
        attr(k, "class", "right"),
        attr(r, "class", "reply-wrapper");
    },
    m(L, U) {
      insert(L, r, U),
        append(r, p),
        append(r, v),
        append(r, k),
        append(k, x),
        append(x, I),
        F || ((O = listen(x, "click", $[2])), (F = !0));
    },
    p(L, U) {
      U & 2 &&
        S !== (S = L[1] ? "Loading..." : "View Thread") &&
        set_data(I, S),
        U & 2 && (x.disabled = L[1]);
    },
    d(L) {
      L && detach(r), (F = !1), O();
    },
  };
}
function create_fragment$2e($) {
  let r, p, v, k, x, S, I;
  (r = new Header({ props: { message: $[0] } })),
    (k = new SvelteMarkdown({ props: { source: $[0].body } }));
  let F = ($[0].replyingTo || $[0].replies) && create_if_block$Z($);
  return {
    c() {
      create_component(r.$$.fragment),
        (p = space()),
        (v = element("div")),
        create_component(k.$$.fragment),
        (x = space()),
        F && F.c(),
        (S = empty()),
        attr(v, "class", "markdownrenderer");
    },
    m(O, L) {
      mount_component(r, O, L),
        insert(O, p, L),
        insert(O, v, L),
        mount_component(k, v, null),
        insert(O, x, L),
        F && F.m(O, L),
        insert(O, S, L),
        (I = !0);
    },
    p(O, [L]) {
      const U = {};
      L & 1 && (U.message = O[0]), r.$set(U);
      const N = {};
      L & 1 && (N.source = O[0].body),
        k.$set(N),
        O[0].replyingTo || O[0].replies
          ? F
            ? F.p(O, L)
            : ((F = create_if_block$Z(O)), F.c(), F.m(S.parentNode, S))
          : F && (F.d(1), (F = null));
    },
    i(O) {
      I ||
        (transition_in(r.$$.fragment, O),
        transition_in(k.$$.fragment, O),
        (I = !0));
    },
    o(O) {
      transition_out(r.$$.fragment, O),
        transition_out(k.$$.fragment, O),
        (I = !1);
    },
    d(O) {
      destroy_component(r, O),
        O && detach(p),
        O && detach(v),
        destroy_component(k),
        O && detach(x),
        F && F.d(O),
        O && detach(S);
    },
  };
}
function instance$1_($, r, p) {
  let { message: v } = r,
    k = !1;
  async function x() {
    p(1, (k = !0));
    const S =
      v.replies && !v.replyingTo ? v.id : (await getParentMessage(v.id)).id;
    threadMessageId.set(S),
      showOverlay("thread", "MessagingApp"),
      p(1, (k = !1));
  }
  return (
    ($.$$set = (S) => {
      "message" in S && p(0, (v = S.message));
    }),
    [v, k, x]
  );
}
class Viewer extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1_, create_fragment$2e, safe_not_equal, {
        message: 0,
      });
  }
}
function create_else_block$i($) {
  let r, p;
  return (
    (r = new NoContent({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_1$h($) {
  let r, p;
  return (
    (r = new Editor({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$Y($) {
  let r, p;
  return (
    (r = new Viewer({ props: { message: $[0] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.message = v[0]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$2d($) {
  let r, p, v, k;
  const x = [create_if_block$Y, create_if_block_1$h, create_else_block$i],
    S = [];
  function I(F, O) {
    return F[0] && !F[1] ? 0 : F[1] ? 1 : 2;
  }
  return (
    (p = I($)),
    (v = S[p] = x[p]($)),
    {
      c() {
        (r = element("div")), v.c(), attr(r, "class", "content");
      },
      m(F, O) {
        insert(F, r, O), S[p].m(r, null), (k = !0);
      },
      p(F, [O]) {
        let L = p;
        (p = I(F)),
          p === L
            ? S[p].p(F, O)
            : (group_outros(),
              transition_out(S[L], 1, 1, () => {
                S[L] = null;
              }),
              check_outros(),
              (v = S[p]),
              v ? v.p(F, O) : ((v = S[p] = x[p](F)), v.c()),
              transition_in(v, 1),
              v.m(r, null));
      },
      i(F) {
        k || (transition_in(v), (k = !0));
      },
      o(F) {
        transition_out(v), (k = !1);
      },
      d(F) {
        F && detach(r), S[p].d();
      },
    }
  );
}
function instance$1Z($, r, p) {
  let v;
  component_subscribe($, creatingMessage, (x) => p(1, (v = x)));
  let k;
  return (
    selectedMessageId.subscribe(async (x) => {
      if (!x) return p(0, (k = null));
      const S = await getMessage(x);
      if (!S)
        return createOverlayableError(
          {
            title: "Can't open message",
            message: `No message with ID ${x} could be found on ArcAPI.`,
            buttons: [{ caption: "OK", action() {} }],
            image: logo$3,
          },
          "MessagingApp"
        );
      p(0, (k = null)),
        setTimeout(() => {
          p(0, (k = S));
        });
    }),
    [k, v]
  );
}
let Content$2 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1Z, create_fragment$2d, safe_not_equal, {});
  }
};
function create_if_block$X($) {
  let r, p, v, k;
  return (
    (r = new ListBar({})),
    (v = new Content$2({})),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          create_component(v.$$.fragment);
      },
      m(x, S) {
        mount_component(r, x, S),
          insert(x, p, S),
          mount_component(v, x, S),
          (k = !0);
      },
      i(x) {
        k ||
          (transition_in(r.$$.fragment, x),
          transition_in(v.$$.fragment, x),
          (k = !0));
      },
      o(x) {
        transition_out(r.$$.fragment, x),
          transition_out(v.$$.fragment, x),
          (k = !1);
      },
      d(x) {
        destroy_component(r, x), x && detach(p), destroy_component(v, x);
      },
    }
  );
}
function create_fragment$2c($) {
  let r, p, v, k;
  r = new SideBar$1({});
  let x = $[0] && create_if_block$X();
  return {
    c() {
      create_component(r.$$.fragment), (p = space()), x && x.c(), (v = empty());
    },
    m(S, I) {
      mount_component(r, S, I),
        insert(S, p, I),
        x && x.m(S, I),
        insert(S, v, I),
        (k = !0);
    },
    p(S, [I]) {
      S[0]
        ? x
          ? I & 1 && transition_in(x, 1)
          : ((x = create_if_block$X()),
            x.c(),
            transition_in(x, 1),
            x.m(v.parentNode, v))
        : x &&
          (group_outros(),
          transition_out(x, 1, 1, () => {
            x = null;
          }),
          check_outros());
    },
    i(S) {
      k || (transition_in(r.$$.fragment, S), transition_in(x), (k = !0));
    },
    o(S) {
      transition_out(r.$$.fragment, S), transition_out(x), (k = !1);
    },
    d(S) {
      destroy_component(r, S), S && detach(p), x && x.d(S), S && detach(v);
    },
  };
}
function instance$1Y($, r, p) {
  let v;
  return (
    component_subscribe($, messagingPage, (k) => p(0, (v = k))),
    onMount(() => {
      set_store_value(messagingPage, (v = MessagingPages.inbox), v);
    }),
    [v]
  );
}
let MessagingApp$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1Y, create_fragment$2c, safe_not_equal, {});
  }
};
const thread = "";
function create_fragment$2b($) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.textContent = "close"),
        attr(r, "class", "overlay-close material-icons-round");
    },
    m(k, x) {
      insert(k, r, x), p || ((v = listen(r, "click", $[0])), (p = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function instance$1X($, r, p) {
  let { app: v } = r,
    { id: k } = r;
  function x() {
    hideOverlay(k, v.id);
  }
  return (
    ($.$$set = (S) => {
      "app" in S && p(1, (v = S.app)), "id" in S && p(2, (k = S.id));
    }),
    [x, v, k]
  );
}
class CloseButton extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1X, create_fragment$2b, safe_not_equal, {
        app: 1,
        id: 2,
      });
  }
}
function get_each_context$v($, r, p) {
  const v = $.slice();
  return (v[1] = r[p]), v;
}
function create_if_block$W($) {
  let r,
    p,
    v = $[0],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$v(get_each_context$v($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 1) {
        v = S[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$v(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$v(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_each_block$v($) {
  let r, p;
  return (
    (r = new Item$2({ props: { item: $[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.item = v[1]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$2a($) {
  let r,
    p,
    v = $[0] && create_if_block$W($);
  return {
    c() {
      (r = element("div")), v && v.c(), attr(r, "class", "branch");
    },
    m(k, x) {
      insert(k, r, x), v && v.m(r, null), (p = !0);
    },
    p(k, [x]) {
      k[0]
        ? v
          ? (v.p(k, x), x & 1 && transition_in(v, 1))
          : ((v = create_if_block$W(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r, null))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      k && detach(r), v && v.d();
    },
  };
}
function instance$1W($, r, p) {
  let { items: v = [] } = r;
  return (
    ($.$$set = (k) => {
      "items" in k && p(0, (v = k.items));
    }),
    [v]
  );
}
class Branch extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1W, create_fragment$2a, safe_not_equal, {
        items: 0,
      });
  }
}
function create_if_block$V($) {
  let r,
    p,
    v,
    k,
    x,
    S = $[0].sender + "",
    I,
    F,
    O,
    L = $[0].partialBody + "",
    U,
    N = $[0].partialBody.length > 29 ? "..." : "",
    j,
    R,
    q,
    Q = $[0].id + "",
    K,
    V,
    H,
    G,
    Y,
    J;
  p = new ProfilePicture$1({ props: { src: $[1], height: 32 } });
  let Z = $[0].replies && create_if_block_1$g($);
  return {
    c() {
      (r = element("button")),
        create_component(p.$$.fragment),
        (v = space()),
        (k = element("div")),
        (x = element("p")),
        (I = text(S)),
        (F = space()),
        (O = element("p")),
        (U = text(L)),
        (j = text(N)),
        (R = space()),
        (q = element("div")),
        (K = text(Q)),
        (V = space()),
        Z && Z.c(),
        (H = empty()),
        attr(x, "class", "name"),
        attr(O, "class", "partial"),
        attr(k, "class", "context"),
        attr(q, "class", "id"),
        attr(r, "class", "item");
    },
    m(X, ee) {
      insert(X, r, ee),
        mount_component(p, r, null),
        append(r, v),
        append(r, k),
        append(k, x),
        append(x, I),
        append(k, F),
        append(k, O),
        append(O, U),
        append(O, j),
        append(r, R),
        append(r, q),
        append(q, K),
        insert(X, V, ee),
        Z && Z.m(X, ee),
        insert(X, H, ee),
        (G = !0),
        Y || ((J = listen(r, "click", $[2])), (Y = !0));
    },
    p(X, ee) {
      const te = {};
      ee & 2 && (te.src = X[1]),
        p.$set(te),
        (!G || ee & 1) && S !== (S = X[0].sender + "") && set_data(I, S),
        (!G || ee & 1) && L !== (L = X[0].partialBody + "") && set_data(U, L),
        (!G || ee & 1) &&
          N !== (N = X[0].partialBody.length > 29 ? "..." : "") &&
          set_data(j, N),
        (!G || ee & 1) && Q !== (Q = X[0].id + "") && set_data(K, Q),
        X[0].replies
          ? Z
            ? (Z.p(X, ee), ee & 1 && transition_in(Z, 1))
            : ((Z = create_if_block_1$g(X)),
              Z.c(),
              transition_in(Z, 1),
              Z.m(H.parentNode, H))
          : Z &&
            (group_outros(),
            transition_out(Z, 1, 1, () => {
              Z = null;
            }),
            check_outros());
    },
    i(X) {
      G || (transition_in(p.$$.fragment, X), transition_in(Z), (G = !0));
    },
    o(X) {
      transition_out(p.$$.fragment, X), transition_out(Z), (G = !1);
    },
    d(X) {
      X && detach(r),
        destroy_component(p),
        X && detach(V),
        Z && Z.d(X),
        X && detach(H),
        (Y = !1),
        J();
    },
  };
}
function create_if_block_1$g($) {
  let r, p;
  return (
    (r = new Branch({ props: { items: $[0].replies } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.items = v[0].replies), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$29($) {
  let r,
    p,
    v = $[0] && create_if_block$V($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[0]
        ? v
          ? (v.p(k, x), x & 1 && transition_in(v, 1))
          : ((v = create_if_block$V(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$1V($, r, p) {
  let v;
  component_subscribe($, selectedMessageId, (I) => p(3, (v = I)));
  let { item: k } = r,
    x = "";
  onMount(async () => {
    p(1, (x = await getUserPfp(k.sender)));
  });
  function S() {
    set_store_value(selectedMessageId, (v = k.id), v),
      hideOverlay("thread", "MessagingApp"),
      threadMessageId.set(null);
  }
  return (
    ($.$$set = (I) => {
      "item" in I && p(0, (k = I.item));
    }),
    [k, x, S]
  );
}
let Item$2 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1V, create_fragment$29, safe_not_equal, {
        item: 0,
      });
  }
};
function create_fragment$28($) {
  let r, p, v, k, x, S, I, F;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (S = element("h3")),
        (S.textContent = "Unable to load thread"),
        (I = space()),
        (F = element("p")),
        (F.textContent = `The thread could not be found. Please make sure the owner exists and try
      again.`),
        src_url_equal(v.src, (k = warning)) || attr(v, "src", k),
        attr(v, "alt", "Error"),
        attr(F, "class", "caption"),
        attr(p, "class", "content"),
        attr(r, "class", "notfound");
    },
    m(O, L) {
      insert(O, r, L),
        append(r, p),
        append(p, v),
        append(p, x),
        append(p, S),
        append(p, I),
        append(p, F);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(O) {
      O && detach(r);
    },
  };
}
class NotFound extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$28, safe_not_equal, {});
  }
}
function create_else_block$h($) {
  let r, p;
  return (
    (r = new NotFound({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$U($) {
  let r,
    p,
    v = $[2].id + "",
    k,
    x,
    S,
    I;
  return (
    (S = new Item$2({ props: { item: $[2] } })),
    {
      c() {
        (r = element("h3")),
          (p = text("Thread of #")),
          (k = text(v)),
          (x = space()),
          create_component(S.$$.fragment),
          attr(r, "class", "header");
      },
      m(F, O) {
        insert(F, r, O),
          append(r, p),
          append(r, k),
          insert(F, x, O),
          mount_component(S, F, O),
          (I = !0);
      },
      p(F, O) {
        (!I || O & 4) && v !== (v = F[2].id + "") && set_data(k, v);
        const L = {};
        O & 4 && (L.item = F[2]), S.$set(L);
      },
      i(F) {
        I || (transition_in(S.$$.fragment, F), (I = !0));
      },
      o(F) {
        transition_out(S.$$.fragment, F), (I = !1);
      },
      d(F) {
        F && detach(r), F && detach(x), destroy_component(S, F);
      },
    }
  );
}
function create_fragment$27($) {
  let r, p, v, k, x, S;
  r = new CloseButton({ props: { app: $[0], id: $[1] } });
  const I = [create_if_block$U, create_else_block$h],
    F = [];
  function O(L, U) {
    return L[3] && L[2] ? 0 : 1;
  }
  return (
    (v = O($)),
    (k = F[v] = I[v]($)),
    {
      c() {
        create_component(r.$$.fragment), (p = space()), k.c(), (x = empty());
      },
      m(L, U) {
        mount_component(r, L, U),
          insert(L, p, U),
          F[v].m(L, U),
          insert(L, x, U),
          (S = !0);
      },
      p(L, [U]) {
        const N = {};
        U & 1 && (N.app = L[0]), U & 2 && (N.id = L[1]), r.$set(N);
        let j = v;
        (v = O(L)),
          v === j
            ? F[v].p(L, U)
            : (group_outros(),
              transition_out(F[j], 1, 1, () => {
                F[j] = null;
              }),
              check_outros(),
              (k = F[v]),
              k ? k.p(L, U) : ((k = F[v] = I[v](L)), k.c()),
              transition_in(k, 1),
              k.m(x.parentNode, x));
      },
      i(L) {
        S || (transition_in(r.$$.fragment, L), transition_in(k), (S = !0));
      },
      o(L) {
        transition_out(r.$$.fragment, L), transition_out(k), (S = !1);
      },
      d(L) {
        destroy_component(r, L), L && detach(p), F[v].d(L), L && detach(x);
      },
    }
  );
}
function instance$1U($, r, p) {
  let v;
  component_subscribe($, threadMessageId, (I) => p(3, (v = I)));
  let k,
    { app: x } = r,
    { id: S } = r;
  return (
    threadMessageId.subscribe(async (I) => {
      if (!I) return;
      p(2, (k = null));
      const F = await getPartialTree(v);
      F && p(2, (k = F));
    }),
    ($.$$set = (I) => {
      "app" in I && p(0, (x = I.app)), "id" in I && p(1, (S = I.id));
    }),
    [x, S, k, v]
  );
}
class Thread extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1U, create_fragment$27, safe_not_equal, {
        app: 0,
        id: 1,
      });
  }
}
const overlays = {
    thread: {
      info: { name: "Thread View", author: "ArcOS Team", version: "1.0.0" },
      size: { w: 550, h: 400 },
      show: !1,
      content: Thread,
    },
  },
  MessagingApp = {
    info: {
      name: "Messaging",
      description: "Send messages to other ArcOS users",
      builtin: !0,
      version: "1.0.7",
      author: "ArcOS Team",
      icon: logo$3,
    },
    size: { w: 700, h: 450 },
    pos: { x: 100, y: 100 },
    minSize: { w: 700, h: 450 },
    maxSize: { w: 1e3, h: 600 },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    overlays,
    content: MessagingApp$1,
    glass: !0,
  },
  logo$2 = "./assets/settings-ade5abd9.svg",
  SettingsApp$2 = "",
  currentSettingsPage = writable(null),
  currentCollapsibleT = writable(null);
function setSettingsPage($) {
  Log({
    source: "apps/SettingsApp",
    level: LogLevel.info,
    msg: `Opening settings page '${$.name}'`,
  }),
    currentCollapsibleT.set(null),
    currentSettingsPage.set($),
    hotSwapAppIcon($.icon, "SettingsApp"),
    setTitleSuffix(` - ${$.name}`, "SettingsApp");
}
function create_if_block$T($) {
  let r, p, v;
  var k = $[2].content;
  function x(S) {
    return {};
  }
  return (
    k && (r = construct_svelte_component(k, x())),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(S, I) {
        r && mount_component(r, S, I), insert(S, p, I), (v = !0);
      },
      p(S, I) {
        if (I & 4 && k !== (k = S[2].content)) {
          if (r) {
            group_outros();
            const F = r;
            transition_out(F.$$.fragment, 1, 0, () => {
              destroy_component(F, 1);
            }),
              check_outros();
          }
          k
            ? ((r = construct_svelte_component(k, x())),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        }
      },
      i(S) {
        v || (r && transition_in(r.$$.fragment, S), (v = !0));
      },
      o(S) {
        r && transition_out(r.$$.fragment, S), (v = !1);
      },
      d(S) {
        S && detach(p), r && destroy_component(r, S);
      },
    }
  );
}
function create_fragment$26($) {
  let r,
    p,
    v,
    k,
    x = $[2] && create_if_block$T($);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        x && x.c(),
        attr(p, "class", (v = "inner " + $[1])),
        attr(r, "class", "content"),
        toggle_class(r, "collapsed", $[0].collapsed);
    },
    m(S, I) {
      insert(S, r, I), append(r, p), x && x.m(p, null), (k = !0);
    },
    p(S, [I]) {
      S[2]
        ? x
          ? (x.p(S, I), I & 4 && transition_in(x, 1))
          : ((x = create_if_block$T(S)),
            x.c(),
            transition_in(x, 1),
            x.m(p, null))
        : x &&
          (group_outros(),
          transition_out(x, 1, 1, () => {
            x = null;
          }),
          check_outros()),
        (!k || (I & 2 && v !== (v = "inner " + S[1]))) && attr(p, "class", v),
        (!k || I & 1) && toggle_class(r, "collapsed", S[0].collapsed);
    },
    i(S) {
      k || (transition_in(x), (k = !0));
    },
    o(S) {
      transition_out(x), (k = !1);
    },
    d(S) {
      S && detach(r), x && x.d();
    },
  };
}
function instance$1T($, r, p) {
  let v;
  component_subscribe($, UserData, (F) => p(4, (v = F)));
  let { appdata: k } = r,
    x = "",
    S,
    I;
  return (
    currentSettingsPage.subscribe((F) => {
      if ((clearTimeout(I), p(1, (x = "static")), v && !v.sh.anim && F))
        return p(2, (S = F));
      !F ||
        (S && F.name == S.name) ||
        (p(1, (x = "slide-out-right")),
        (I = setTimeout(() => {
          p(2, (S = F)),
            p(1, (x = "slide-in-left")),
            (I = setTimeout(() => {
              p(1, (x = "static"));
            }, 301));
        }, 500)));
    }),
    ($.$$set = (F) => {
      "appdata" in F && p(0, (k = F.appdata));
    }),
    [k, x, S]
  );
}
let Content$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1T, create_fragment$26, safe_not_equal, {
        appdata: 0,
      });
  }
};
const usericon = "./assets/account-a7a14557.svg",
  logo$1 = "./assets/desktop-2a5e3c36.svg",
  appearance = "./assets/personalization-61b4520f.svg",
  shellIcon = "./assets/taskbar-24d42588.svg",
  windowsIcon = "./assets/windows-2ef194f6.svg",
  about = "",
  dmMutators = [],
  dmProps = writable([]),
  DevModeOverride = writable(!1);
function updateDevModeProps() {
  dmProps.set([]);
  let $ = [];
  for (let r = 0; r < dmMutators.length; r++) {
    const p = [],
      v = dmMutators[r],
      k = get_store_value(dmMutators[r].store),
      x = v.fallback || "",
      S = v.value,
      I = v.suffix || "",
      F = k ? `${S ? k[S] : k} ${I}` : `<${x}>`;
    p.push(v.caption, F), $.push(p);
  }
  dmProps.set($);
}
function create_else_block$g($) {
  let r, p;
  return {
    c() {
      (r = element("h3")), (p = text($[2])), attr(r, "class", "header");
    },
    m(v, k) {
      insert(v, r, k), append(r, p);
    },
    p(v, k) {
      k & 4 && set_data(p, v[2]);
    },
    d(v) {
      v && detach(r);
    },
  };
}
function create_if_block$S($) {
  let r, p, v, k;
  return {
    c() {
      (r = element("div")), (p = text($[2])), attr(r, "class", "header");
    },
    m(x, S) {
      insert(x, r, S),
        append(r, p),
        v || ((k = listen(r, "click", $[4])), (v = !0));
    },
    p(x, S) {
      S & 4 && set_data(p, x[2]);
    },
    d(x) {
      x && detach(r), (v = !1), k();
    },
  };
}
function create_fragment$25($) {
  let r, p, v, k;
  function x(L, U) {
    return L[1] ? create_if_block$S : create_else_block$g;
  }
  let S = x($),
    I = S($);
  const F = $[6].default,
    O = create_slot(F, $, $[5], null);
  return {
    c() {
      (r = element("div")),
        I.c(),
        (p = space()),
        (v = element("div")),
        O && O.c(),
        attr(v, "class", "section-content"),
        attr(r, "class", "section"),
        toggle_class(r, "collapsible", $[1]),
        toggle_class(r, "collapsed", $[0]),
        toggle_class(r, "opt", $[3]);
    },
    m(L, U) {
      insert(L, r, U),
        I.m(r, null),
        append(r, p),
        append(r, v),
        O && O.m(v, null),
        (k = !0);
    },
    p(L, [U]) {
      S === (S = x(L)) && I
        ? I.p(L, U)
        : (I.d(1), (I = S(L)), I && (I.c(), I.m(r, p))),
        O &&
          O.p &&
          (!k || U & 32) &&
          update_slot_base(
            O,
            F,
            L,
            L[5],
            k
              ? get_slot_changes(F, L[5], U, null)
              : get_all_dirty_from_scope(L[5]),
            null
          ),
        (!k || U & 2) && toggle_class(r, "collapsible", L[1]),
        (!k || U & 1) && toggle_class(r, "collapsed", L[0]),
        (!k || U & 8) && toggle_class(r, "opt", L[3]);
    },
    i(L) {
      k || (transition_in(O, L), (k = !0));
    },
    o(L) {
      transition_out(O, L), (k = !1);
    },
    d(L) {
      L && detach(r), I.d(), O && O.d(L);
    },
  };
}
function instance$1S($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r,
    { collapsible: x = !1 } = r,
    { header: S } = r,
    { collapsed: I = !0 } = r,
    { opt: F = !1 } = r;
  currentCollapsibleT.subscribe((L) => {
    !L || !x || p(0, (I = S != L));
  });
  function O() {
    p(0, (I = !I)), I || currentCollapsibleT.set(S);
  }
  return (
    ($.$$set = (L) => {
      "collapsible" in L && p(1, (x = L.collapsible)),
        "header" in L && p(2, (S = L.header)),
        "collapsed" in L && p(0, (I = L.collapsed)),
        "opt" in L && p(3, (F = L.opt)),
        "$$scope" in L && p(5, (k = L.$$scope));
    }),
    [I, x, S, F, O, k, v]
  );
}
class Section extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1S, create_fragment$25, safe_not_equal, {
        collapsible: 1,
        header: 2,
        collapsed: 0,
        opt: 3,
      });
  }
}
function getCPU() {
  return { cores: navigator.hardwareConcurrency || 4 };
}
const GPU_VENDOR_REGEX = /(intel|nvidia|sis|amd|apple|powervr)\W? (.+)/i,
  GPU_RENDERER_REGEX = /(((?:radeon|adreno|geforce|mali).+))/i,
  GPU_CLEANUP_REGEX = / ?(\(.+?\)| direct3d.+| opengl.+|\/.+$| gpu$)/gi;
function getGPU() {
  const $ = {
      supported: "WebGLRenderingContext" in globalThis,
      active: !1,
      vendor: void 0,
      model: void 0,
    },
    r = document.createElement("canvas"),
    p =
      r.getContext("webgl2") ||
      r.getContext("webgl") ||
      r.getContext("experimental-webgl");
  if (!p) return $;
  $.active = !0;
  const v = p.getExtension("WEBGL_debug_renderer_info");
  $.vendor = p.getParameter(v.UNMASKED_VENDOR_WEBGL);
  const k = p.getParameter(v.UNMASKED_RENDERER_WEBGL) ?? "",
    x = k.match(GPU_VENDOR_REGEX),
    S = k.match(GPU_RENDERER_REGEX);
  return (
    x && ($.vendor = x[1]),
    ($.model = S ? S[1] : k),
    ($.model = $.model.replace(GPU_CLEANUP_REGEX, "")),
    $
  );
}
function getMEM() {
  return { kb: (navigator.deviceMemory || 1) * 1024 ** 3 };
}
const defaultNetwork = {
  downlink: 0,
  effectiveType: "0G",
  rtt: 0,
  saveData: !1,
  online: !1,
};
function getNET() {
  const $ = navigator.connection;
  return $ || defaultNetwork;
}
function getDeviceInfo() {
  return { gpu: getGPU(), cpu: getCPU(), mem: getMEM(), net: getNET() };
}
var u$1 = {};
e(u$1, {
  getName: () => n$1,
  getTauriVersion: () => s$1,
  getVersion: () => i,
  hide: () => t,
  show: () => o$1,
});
async function i() {
  return a$1({ __tauriModule: "App", message: { cmd: "getAppVersion" } });
}
async function n$1() {
  return a$1({ __tauriModule: "App", message: { cmd: "getAppName" } });
}
async function s$1() {
  return a$1({ __tauriModule: "App", message: { cmd: "getTauriVersion" } });
}
async function o$1() {
  return a$1({ __tauriModule: "App", message: { cmd: "show" } });
}
async function t() {
  return a$1({ __tauriModule: "App", message: { cmd: "hide" } });
}
var c = {};
e(c, {
  isRegistered: () => u,
  register: () => s,
  registerAll: () => n,
  unregister: () => a,
  unregisterAll: () => l,
});
async function s($, r) {
  return a$1({
    __tauriModule: "GlobalShortcut",
    message: { cmd: "register", shortcut: $, handler: s$4(r) },
  });
}
async function n($, r) {
  return a$1({
    __tauriModule: "GlobalShortcut",
    message: { cmd: "registerAll", shortcuts: $, handler: s$4(r) },
  });
}
async function u($) {
  return a$1({
    __tauriModule: "GlobalShortcut",
    message: { cmd: "isRegistered", shortcut: $ },
  });
}
async function a($) {
  return a$1({
    __tauriModule: "GlobalShortcut",
    message: { cmd: "unregister", shortcut: $ },
  });
}
async function l() {
  return a$1({
    __tauriModule: "GlobalShortcut",
    message: { cmd: "unregisterAll" },
  });
}
const blocks = ["Ctrl+R", "F5", "Ctrl+Shift+R", "Ctrl+P", "F3", "Ctrl+F", "F7"];
async function define() {
  doRegister(), E$1(c$2.WINDOW_BLUR, l), E$1(c$2.WINDOW_FOCUS, doRegister);
}
function doRegister() {
  l();
  for (let $ = 0; $ < blocks.length; $++) {
    const r = blocks[$];
    s(r, unset);
  }
  s("Alt+Enter", async () => {
    const $ = await b.isFullscreen();
    await b.setFullscreen(!$);
  });
}
function unset() {
  if (document.hasFocus()) return !1;
}
async function inTauri() {
  try {
    return !!(await i());
  } catch {
    return !1;
  }
}
function create_if_block$R($) {
  let r, p;
  return (
    (r = new Section({
      props: {
        header: "Your System",
        collapsible: !0,
        $$slots: { default: [create_default_slot$9] },
        $$scope: { ctx: $ },
      },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 11 && (x.$$scope = { dirty: k, ctx: v }), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_default_slot$9($) {
  let r,
    p,
    v,
    k,
    x = $[0].cpu.cores + "",
    S,
    I,
    F,
    O,
    L,
    U,
    N,
    j,
    R = formatBytes($[0].mem.kb) + "",
    q,
    Q,
    K,
    V,
    H,
    G,
    Y,
    J,
    Z = $[0].gpu.vendor + "",
    X,
    ee,
    te = $[0].gpu.model + "",
    ie,
    ue,
    oe,
    se,
    re,
    le,
    ae = $[1] ? "Desktop app" : "Browser",
    ne,
    ce,
    de;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (p.textContent = "Processor"),
        (v = space()),
        (k = element("div")),
        (S = text(x)),
        (I = text(" cores")),
        (F = space()),
        (O = element("div")),
        (L = element("div")),
        (L.textContent = "Memory"),
        (U = space()),
        (N = element("div")),
        (j = text("~ ")),
        (q = text(R)),
        (Q = space()),
        (K = element("button")),
        (K.textContent = "help"),
        (V = space()),
        (H = element("div")),
        (G = element("div")),
        (G.textContent = "Graphics card"),
        (Y = space()),
        (J = element("div")),
        (X = text(Z)),
        (ee = space()),
        (ie = text(te)),
        (ue = space()),
        (oe = element("div")),
        (se = element("div")),
        (se.textContent = "ArcOS Mode"),
        (re = space()),
        (le = element("div")),
        (ne = text(ae)),
        attr(p, "class", "key"),
        attr(k, "class", "value"),
        attr(r, "class", "row"),
        attr(L, "class", "key"),
        attr(K, "class", "material-icons-round info"),
        attr(N, "class", "value"),
        attr(O, "class", "row"),
        attr(G, "class", "key"),
        attr(J, "class", "value"),
        attr(H, "class", "row"),
        attr(se, "class", "key"),
        attr(le, "class", "value"),
        attr(oe, "class", "row");
    },
    m(fe, pe) {
      insert(fe, r, pe),
        append(r, p),
        append(r, v),
        append(r, k),
        append(k, S),
        append(k, I),
        insert(fe, F, pe),
        insert(fe, O, pe),
        append(O, L),
        append(O, U),
        append(O, N),
        append(N, j),
        append(N, q),
        append(N, Q),
        append(N, K),
        insert(fe, V, pe),
        insert(fe, H, pe),
        append(H, G),
        append(H, Y),
        append(H, J),
        append(J, X),
        append(J, ee),
        append(J, ie),
        insert(fe, ue, pe),
        insert(fe, oe, pe),
        append(oe, se),
        append(oe, re),
        append(oe, le),
        append(le, ne),
        ce || ((de = listen(K, "click", $[2])), (ce = !0));
    },
    p(fe, pe) {
      pe & 1 && x !== (x = fe[0].cpu.cores + "") && set_data(S, x),
        pe & 1 && R !== (R = formatBytes(fe[0].mem.kb) + "") && set_data(q, R),
        pe & 1 && Z !== (Z = fe[0].gpu.vendor + "") && set_data(X, Z),
        pe & 1 && te !== (te = fe[0].gpu.model + "") && set_data(ie, te),
        pe & 2 &&
          ae !== (ae = fe[1] ? "Desktop app" : "Browser") &&
          set_data(ne, ae);
    },
    d(fe) {
      fe && detach(r),
        fe && detach(F),
        fe && detach(O),
        fe && detach(V),
        fe && detach(H),
        fe && detach(ue),
        fe && detach(oe),
        (ce = !1),
        de();
    },
  };
}
function create_fragment$24($) {
  let r,
    p,
    v = $[0] && create_if_block$R($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[0]
        ? v
          ? (v.p(k, x), x & 1 && transition_in(v, 1))
          : ((v = create_if_block$R(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$1R($, r, p) {
  let v,
    k = !1;
  onMount(async () => {
    p(0, (v = await getDeviceInfo())), p(1, (k = await inTauri()));
  });
  function x() {
    createOverlayableError(
      {
        title: "Information about system memory",
        message:
          "The memory amount visible to ArcOS may be less than you actually have. This is not a bug, but rather a limitation of the browser you are running. Most browsers can only detect up to 8GB of RAM.",
        buttons: [{ caption: "Understood", action() {} }],
      },
      "SettingsApp"
    );
  }
  return [v, k, x];
}
class SystemSection extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1R, create_fragment$24, safe_not_equal, {});
  }
}
function create_default_slot_2$3($) {
  let r, p, v;
  return {
    c() {
      (r =
        text(`The whole ArcOS project is licensed under GPLv3. More information about the
    license and the project as a whole can be found in the README file of the
    `)),
        (p = element("a")),
        (p.textContent = "ArcOS project page"),
        (v = text(".")),
        attr(p, "href", "https://github.com/IzK-ArcOS"),
        attr(p, "target", "_blank");
    },
    m(k, x) {
      insert(k, r, x), insert(k, p, x), insert(k, v, x);
    },
    p: noop$1,
    d(k) {
      k && detach(r), k && detach(p), k && detach(v);
    },
  };
}
function create_default_slot_1$4($) {
  let r, p;
  return {
    c() {
      (r = text(`Thanks to the following people:
    `)),
        (p = element("ul")),
        (p.innerHTML = `<li>Papirus Development Team for their icon set</li> 
      <li>SWHFotografie for wallpapers img08 and img13</li> 
      <li>Kees van Voorthuizen for wallpaper img14</li>`);
    },
    m(v, k) {
      insert(v, r, k), insert(v, p, k);
    },
    p: noop$1,
    d(v) {
      v && detach(r), v && detach(p);
    },
  };
}
function create_default_slot$8($) {
  let r, p, v, k;
  return {
    c() {
      (r =
        text(`ArcOS started of as a weekend project, but these days it is a huge project
    with tons of amazing features. Every version of this project up to this
    point has been lead by me, Izaak Kuipers.`)),
        (p = element("br")),
        (v = element("br")),
        (k = text(`Feel free to visit our
    GitHub for more information about the project, and how you can contribute to
    it.`));
    },
    m(x, S) {
      insert(x, r, S), insert(x, p, S), insert(x, v, S), insert(x, k, S);
    },
    p: noop$1,
    d(x) {
      x && detach(r), x && detach(p), x && detach(v), x && detach(k);
    },
  };
}
function create_fragment$23($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K;
  return (
    (L = new SystemSection({})),
    (N = new Section({
      props: {
        header: "License Information",
        collapsible: !0,
        collapsed: !0,
        $$slots: { default: [create_default_slot_2$3] },
        $$scope: { ctx: $ },
      },
    })),
    (R = new Section({
      props: {
        header: "Credits",
        collapsible: !0,
        collapsed: !0,
        $$slots: { default: [create_default_slot_1$4] },
        $$scope: { ctx: $ },
      },
    })),
    (Q = new Section({
      props: {
        header: "About",
        collapsible: !0,
        collapsed: !0,
        $$slots: { default: [create_default_slot$8] },
        $$scope: { ctx: $ },
      },
    })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          (v = element("div")),
          (k = element("img")),
          (S = space()),
          (I = element("div")),
          (F = element("h1")),
          (F.textContent = `ArcOS v${ArcOSVersion}`),
          (O = space()),
          create_component(L.$$.fragment),
          (U = space()),
          create_component(N.$$.fragment),
          (j = space()),
          create_component(R.$$.fragment),
          (q = space()),
          create_component(Q.$$.fragment),
          src_url_equal(k.src, (x = logo$d)) || attr(k, "src", x),
          attr(k, "alt", "ArcOS"),
          attr(k, "class", "logo"),
          attr(F, "class", "name"),
          attr(I, "class", "text"),
          attr(p, "class", "product"),
          attr(r, "class", "about-page");
      },
      m(V, H) {
        insert(V, r, H),
          append(r, p),
          append(p, v),
          append(v, k),
          append(p, S),
          append(p, I),
          append(I, F),
          append(r, O),
          mount_component(L, r, null),
          append(r, U),
          mount_component(N, r, null),
          append(r, j),
          mount_component(R, r, null),
          append(r, q),
          mount_component(Q, r, null),
          (K = !0);
      },
      p(V, [H]) {
        const G = {};
        H & 16 && (G.$$scope = { dirty: H, ctx: V }), N.$set(G);
        const Y = {};
        H & 16 && (Y.$$scope = { dirty: H, ctx: V }), R.$set(Y);
        const J = {};
        H & 16 && (J.$$scope = { dirty: H, ctx: V }), Q.$set(J);
      },
      i(V) {
        K ||
          (transition_in(L.$$.fragment, V),
          transition_in(N.$$.fragment, V),
          transition_in(R.$$.fragment, V),
          transition_in(Q.$$.fragment, V),
          (K = !0));
      },
      o(V) {
        transition_out(L.$$.fragment, V),
          transition_out(N.$$.fragment, V),
          transition_out(R.$$.fragment, V),
          transition_out(Q.$$.fragment, V),
          (K = !1);
      },
      d(V) {
        V && detach(r),
          destroy_component(L),
          destroy_component(N),
          destroy_component(R),
          destroy_component(Q);
      },
    }
  );
}
function instance$1Q($, r, p) {
  return (
    component_subscribe($, UserData, (v) => p(0, v)),
    component_subscribe($, UserName, (v) => p(1, v)),
    []
  );
}
class About extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1Q, create_fragment$23, safe_not_equal, {});
  }
}
const account$1 = "";
function create_fragment$22($) {
  let r, p, v, k, x, S, I, F, O, L;
  const U = $[3].default,
    N = create_slot(U, $, $[2], null);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("h3")),
        (k = text($[0])),
        (x = space()),
        (S = element("p")),
        (I = text($[1])),
        (F = space()),
        (O = element("div")),
        N && N.c(),
        attr(v, "class", "header"),
        attr(S, "class", "context"),
        attr(O, "class", "opt-sel"),
        attr(r, "class", "section opt");
    },
    m(j, R) {
      insert(j, r, R),
        append(r, p),
        append(p, v),
        append(v, k),
        append(p, x),
        append(p, S),
        append(S, I),
        append(r, F),
        append(r, O),
        N && N.m(O, null),
        (L = !0);
    },
    p(j, [R]) {
      (!L || R & 1) && set_data(k, j[0]),
        (!L || R & 2) && set_data(I, j[1]),
        N &&
          N.p &&
          (!L || R & 4) &&
          update_slot_base(
            N,
            U,
            j,
            j[2],
            L
              ? get_slot_changes(U, j[2], R, null)
              : get_all_dirty_from_scope(j[2]),
            null
          );
    },
    i(j) {
      L || (transition_in(N, j), (L = !0));
    },
    o(j) {
      transition_out(N, j), (L = !1);
    },
    d(j) {
      j && detach(r), N && N.d(j);
    },
  };
}
function instance$1P($, r, p) {
  let { $$slots: v = {}, $$scope: k } = r,
    { title: x } = r,
    { context: S } = r;
  return (
    ($.$$set = (I) => {
      "title" in I && p(0, (x = I.title)),
        "context" in I && p(1, (S = I.context)),
        "$$scope" in I && p(2, (k = I.$$scope));
    }),
    [x, S, k, v]
  );
}
class OptionSection extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1P, create_fragment$22, safe_not_equal, {
        title: 0,
        context: 1,
      });
  }
}
function create_default_slot_2$2($) {
  let r, p, v;
  return {
    c() {
      (r = element("button")), (r.textContent = "Change...");
    },
    m(k, x) {
      insert(k, r, x), p || ((v = listen(r, "click", $[1])), (p = !0));
    },
    p: noop$1,
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_1$3($) {
  let r, p, v;
  return {
    c() {
      (r = element("button")), (r.textContent = "Change...");
    },
    m(k, x) {
      insert(k, r, x), p || ((v = listen(r, "click", $[2])), (p = !0));
    },
    p: noop$1,
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot$7($) {
  let r, p, v;
  return {
    c() {
      (r = element("button")), (r.textContent = "Delete account...");
    },
    m(k, x) {
      insert(k, r, x), p || ((v = listen(r, "click", $[0])), (p = !0));
    },
    p: noop$1,
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_fragment$21($) {
  let r, p, v, k, x, S;
  return (
    (r = new OptionSection({
      props: {
        title: "Change username",
        context: "Migrate your userdata to another username.",
        $$slots: { default: [create_default_slot_2$2] },
        $$scope: { ctx: $ },
      },
    })),
    (v = new OptionSection({
      props: {
        title: "Change password",
        context: "Change the password you use to log in.",
        $$slots: { default: [create_default_slot_1$3] },
        $$scope: { ctx: $ },
      },
    })),
    (x = new OptionSection({
      props: {
        title: "Delete account",
        context: "Delete your ArcOS account",
        $$slots: { default: [create_default_slot$7] },
        $$scope: { ctx: $ },
      },
    })),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          create_component(v.$$.fragment),
          (k = space()),
          create_component(x.$$.fragment);
      },
      m(I, F) {
        mount_component(r, I, F),
          insert(I, p, F),
          mount_component(v, I, F),
          insert(I, k, F),
          mount_component(x, I, F),
          (S = !0);
      },
      p(I, [F]) {
        const O = {};
        F & 8 && (O.$$scope = { dirty: F, ctx: I }), r.$set(O);
        const L = {};
        F & 8 && (L.$$scope = { dirty: F, ctx: I }), v.$set(L);
        const U = {};
        F & 8 && (U.$$scope = { dirty: F, ctx: I }), x.$set(U);
      },
      i(I) {
        S ||
          (transition_in(r.$$.fragment, I),
          transition_in(v.$$.fragment, I),
          transition_in(x.$$.fragment, I),
          (S = !0));
      },
      o(I) {
        transition_out(r.$$.fragment, I),
          transition_out(v.$$.fragment, I),
          transition_out(x.$$.fragment, I),
          (S = !1);
      },
      d(I) {
        destroy_component(r, I),
          I && detach(p),
          destroy_component(v, I),
          I && detach(k),
          destroy_component(x, I);
      },
    }
  );
}
function instance$1O($) {
  function r() {
    createOverlayableError(
      {
        title: "Delete ArcOS Account",
        message:
          "Are you sure you want to delete your ArcOS account? This will delete any and all user data associated with this account. These changes cannot be reverted.",
        image: warning,
        buttons: [
          { action: () => deleteUser(), caption: "Proceed" },
          { action: () => {}, caption: "Back to safety" },
        ],
      },
      "SettingsApp"
    );
  }
  function p() {
    showOverlay("changeUsername", "SettingsApp");
  }
  function v() {
    showOverlay("changePswd", "SettingsApp");
  }
  return [r, p, v];
}
class DangerZone extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1O, create_fragment$21, safe_not_equal, {});
  }
}
function create_if_block$Q($) {
  let r;
  return {
    c() {
      r = text("(developer)");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$20($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U,
    N = (localStorage.getItem("arcos-server") || location.hostname) + "",
    j,
    R,
    q,
    Q,
    K;
  v = new ProfilePicture$1({ props: { src: $[0], height: 52 } });
  let V = $[2] && create_if_block$Q();
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        create_component(v.$$.fragment),
        (k = space()),
        (x = element("button")),
        (x.textContent = "edit"),
        (S = space()),
        (I = element("div")),
        (F = element("p")),
        (O = text($[1])),
        (L = space()),
        (U = element("p")),
        (j = text(N)),
        (R = space()),
        V && V.c(),
        attr(x, "class", "change material-icons-round"),
        attr(F, "class", "username"),
        attr(U, "class", "host"),
        attr(U, "data-caller", "accountpage-hostname"),
        attr(r, "class", "info");
    },
    m(H, G) {
      insert(H, r, G),
        append(r, p),
        mount_component(v, p, null),
        append(p, k),
        append(p, x),
        append(r, S),
        append(r, I),
        append(I, F),
        append(F, O),
        append(I, L),
        append(I, U),
        append(U, j),
        append(U, R),
        V && V.m(U, null),
        (q = !0),
        Q || ((K = listen(x, "click", $[3])), (Q = !0));
    },
    p(H, [G]) {
      const Y = {};
      G & 1 && (Y.src = H[0]),
        v.$set(Y),
        (!q || G & 2) && set_data(O, H[1]),
        H[2]
          ? V || ((V = create_if_block$Q()), V.c(), V.m(U, null))
          : V && (V.d(1), (V = null));
    },
    i(H) {
      q || (transition_in(v.$$.fragment, H), (q = !0));
    },
    o(H) {
      transition_out(v.$$.fragment, H), (q = !1);
    },
    d(H) {
      H && detach(r), destroy_component(v), V && V.d(), (Q = !1), K();
    },
  };
}
function instance$1N($, r, p) {
  let v, k;
  component_subscribe($, UserName, (I) => p(1, (v = I))),
    component_subscribe($, DevModeOverride, (I) => p(2, (k = I)));
  let x = "";
  UserData.subscribe((I) => {
    p(0, (x = getProfilePicture(I.acc.profilePicture)));
  });
  function S() {
    showOverlay("pfpSel", "SettingsApp");
  }
  return [x, v, k, S];
}
class Profile extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1N, create_fragment$20, safe_not_equal, {});
  }
}
function create_fragment$1$($) {
  let r, p, v, k, x;
  return (
    (p = new Profile({})),
    (k = new DangerZone({})),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          create_component(k.$$.fragment),
          attr(r, "class", "settingspage-account");
      },
      m(S, I) {
        insert(S, r, I),
          mount_component(p, r, null),
          append(r, v),
          mount_component(k, r, null),
          (x = !0);
      },
      p: noop$1,
      i(S) {
        x ||
          (transition_in(p.$$.fragment, S),
          transition_in(k.$$.fragment, S),
          (x = !0));
      },
      o(S) {
        transition_out(p.$$.fragment, S),
          transition_out(k.$$.fragment, S),
          (x = !1);
      },
      d(S) {
        S && detach(r), destroy_component(p), destroy_component(k);
      },
    }
  );
}
class Account extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$1$, safe_not_equal, {});
  }
}
const apps$1 = "";
function create_fragment$1_($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F = $[0].info.name + "",
    O,
    L,
    U,
    N = $[0].info.description + "",
    j,
    R,
    q;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (x = space()),
        (S = element("div")),
        (I = element("p")),
        (O = text(F)),
        (L = space()),
        (U = element("p")),
        (j = text(N)),
        src_url_equal(
          p.src,
          (v = getOriginalIcon($[0].id) || getAppIcon($[0]))
        ) || attr(p, "src", v),
        attr(p, "alt", (k = $[0].info.name)),
        attr(p, "class", "icon"),
        attr(I, "class", "title"),
        attr(U, "class", "description"),
        attr(S, "class", "info"),
        attr(r, "class", "appbutton"),
        toggle_class(r, "disabled", $[0].disabled);
    },
    m(Q, K) {
      insert(Q, r, K),
        append(r, p),
        append(r, x),
        append(r, S),
        append(S, I),
        append(I, O),
        append(S, L),
        append(S, U),
        append(U, j),
        R || ((q = listen(r, "click", $[1])), (R = !0));
    },
    p(Q, [K]) {
      K & 1 &&
        !src_url_equal(
          p.src,
          (v = getOriginalIcon(Q[0].id) || getAppIcon(Q[0]))
        ) &&
        attr(p, "src", v),
        K & 1 && k !== (k = Q[0].info.name) && attr(p, "alt", k),
        K & 1 && F !== (F = Q[0].info.name + "") && set_data(O, F),
        K & 1 && N !== (N = Q[0].info.description + "") && set_data(j, N),
        K & 1 && toggle_class(r, "disabled", Q[0].disabled);
    },
    i: noop$1,
    o: noop$1,
    d(Q) {
      Q && detach(r), (R = !1), q();
    },
  };
}
function instance$1M($, r, p) {
  let { app: v } = r;
  function k() {
    closeWindow("AppInfo"),
      setTimeout(() => {
        AppInfoId.set(v.id), openWindow("AppInfo");
      }, 300);
  }
  return (
    ($.$$set = (x) => {
      "app" in x && p(0, (v = x.app));
    }),
    [v, k]
  );
}
let AppButton$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1M, create_fragment$1_, safe_not_equal, {
        app: 0,
      });
  }
};
function create_else_block$f($) {
  let r = $[0].id + "",
    p;
  return {
    c() {
      p = text(r);
    },
    m(v, k) {
      insert(v, p, k);
    },
    p(v, k) {
      k & 1 && r !== (r = v[0].id + "") && set_data(p, r);
    },
    d(v) {
      v && detach(p);
    },
  };
}
function create_if_block$P($) {
  let r = $[0].parentId + "",
    p,
    v,
    k = $[0].id + "",
    x;
  return {
    c() {
      (p = text(r)), (v = text(".")), (x = text(k));
    },
    m(S, I) {
      insert(S, p, I), insert(S, v, I), insert(S, x, I);
    },
    p(S, I) {
      I & 1 && r !== (r = S[0].parentId + "") && set_data(p, r),
        I & 1 && k !== (k = S[0].id + "") && set_data(x, k);
    },
    d(S) {
      S && detach(p), S && detach(v), S && detach(x);
    },
  };
}
function create_fragment$1Z($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L = $[0].info.name + "",
    U,
    N,
    j,
    R;
  function q(V, H) {
    return V[0].parentId ? create_if_block$P : create_else_block$f;
  }
  let Q = q($),
    K = Q($);
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (x = space()),
        (S = element("div")),
        (I = element("p")),
        K.c(),
        (F = space()),
        (O = element("p")),
        (U = text(L)),
        (N = text(" (hidden)")),
        src_url_equal(p.src, (v = getAppIcon($[0]))) || attr(p, "src", v),
        attr(p, "alt", (k = $[0].info.name)),
        attr(p, "class", "icon"),
        attr(I, "class", "title"),
        attr(O, "class", "description"),
        attr(S, "class", "info"),
        attr(r, "class", "appbutton"),
        toggle_class(r, "disabled", $[0].disabled);
    },
    m(V, H) {
      insert(V, r, H),
        append(r, p),
        append(r, x),
        append(r, S),
        append(S, I),
        K.m(I, null),
        append(S, F),
        append(S, O),
        append(O, U),
        append(O, N),
        j || ((R = listen(r, "click", $[1])), (j = !0));
    },
    p(V, [H]) {
      H & 1 &&
        !src_url_equal(p.src, (v = getAppIcon(V[0]))) &&
        attr(p, "src", v),
        H & 1 && k !== (k = V[0].info.name) && attr(p, "alt", k),
        Q === (Q = q(V)) && K
          ? K.p(V, H)
          : (K.d(1), (K = Q(V)), K && (K.c(), K.m(I, null))),
        H & 1 && L !== (L = V[0].info.name + "") && set_data(U, L),
        H & 1 && toggle_class(r, "disabled", V[0].disabled);
    },
    i: noop$1,
    o: noop$1,
    d(V) {
      V && detach(r), K.d(), (j = !1), R();
    },
  };
}
function instance$1L($, r, p) {
  let { app: v } = r;
  function k() {
    closeWindow("AppInfo"),
      setTimeout(() => {
        AppInfoId.set(v.id), openWindow("AppInfo");
      }, 300);
  }
  return (
    ($.$$set = (x) => {
      "app" in x && p(0, (v = x.app));
    }),
    [v, k]
  );
}
class HiddenAppButton extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1L, create_fragment$1Z, safe_not_equal, {
        app: 0,
      });
  }
}
function get_each_context$u($, r, p) {
  const v = $.slice();
  return (v[2] = r[p]), v;
}
function get_each_context_1$3($, r, p) {
  const v = $.slice();
  return (v[2] = r[p]), v;
}
function create_each_block_1$3($) {
  let r, p;
  return (
    (r = new AppButton$1({ props: { app: $[2] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 2 && (x.app = v[2]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$u($) {
  let r, p;
  return (
    (r = new HiddenAppButton({ props: { app: $[2] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.app = v[2]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1Y($) {
  let r,
    p,
    v,
    k,
    x,
    S = $[1],
    I = [];
  for (let N = 0; N < S.length; N += 1)
    I[N] = create_each_block_1$3(get_each_context_1$3($, S, N));
  const F = (N) =>
    transition_out(I[N], 1, 1, () => {
      I[N] = null;
    });
  let O = $[0],
    L = [];
  for (let N = 0; N < O.length; N += 1)
    L[N] = create_each_block$u(get_each_context$u($, O, N));
  const U = (N) =>
    transition_out(L[N], 1, 1, () => {
      L[N] = null;
    });
  return {
    c() {
      (r = element("h1")),
        (r.textContent = "Applications"),
        (p = space()),
        (v = element("div"));
      for (let N = 0; N < I.length; N += 1) I[N].c();
      k = space();
      for (let N = 0; N < L.length; N += 1) L[N].c();
      attr(v, "class", "apps");
    },
    m(N, j) {
      insert(N, r, j), insert(N, p, j), insert(N, v, j);
      for (let R = 0; R < I.length; R += 1) I[R] && I[R].m(v, null);
      append(v, k);
      for (let R = 0; R < L.length; R += 1) L[R] && L[R].m(v, null);
      x = !0;
    },
    p(N, [j]) {
      if (j & 2) {
        S = N[1];
        let R;
        for (R = 0; R < S.length; R += 1) {
          const q = get_each_context_1$3(N, S, R);
          I[R]
            ? (I[R].p(q, j), transition_in(I[R], 1))
            : ((I[R] = create_each_block_1$3(q)),
              I[R].c(),
              transition_in(I[R], 1),
              I[R].m(v, k));
        }
        for (group_outros(), R = S.length; R < I.length; R += 1) F(R);
        check_outros();
      }
      if (j & 1) {
        O = N[0];
        let R;
        for (R = 0; R < O.length; R += 1) {
          const q = get_each_context$u(N, O, R);
          L[R]
            ? (L[R].p(q, j), transition_in(L[R], 1))
            : ((L[R] = create_each_block$u(q)),
              L[R].c(),
              transition_in(L[R], 1),
              L[R].m(v, null));
        }
        for (group_outros(), R = O.length; R < L.length; R += 1) U(R);
        check_outros();
      }
    },
    i(N) {
      if (!x) {
        for (let j = 0; j < S.length; j += 1) transition_in(I[j]);
        for (let j = 0; j < O.length; j += 1) transition_in(L[j]);
        x = !0;
      }
    },
    o(N) {
      I = I.filter(Boolean);
      for (let j = 0; j < I.length; j += 1) transition_out(I[j]);
      L = L.filter(Boolean);
      for (let j = 0; j < L.length; j += 1) transition_out(L[j]);
      x = !1;
    },
    d(N) {
      N && detach(r),
        N && detach(p),
        N && detach(v),
        destroy_each(I, N),
        destroy_each(L, N);
    },
  };
}
function instance$1K($, r, p) {
  let v = [],
    k = [];
  return (
    WindowStore.subscribe((x) => {
      p(0, (v = [])), p(1, (k = []));
      for (let S = 0; S < x.length; S++)
        x[S].info.hidden ? v.push(x[S]) : k.push(x[S]);
    }),
    [v, k]
  );
}
class Apps extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1K, create_fragment$1Y, safe_not_equal, {});
  }
}
const desktop$2 = "";
async function directSingleUpload($, r) {
  $.endsWith("/") && $.slice(0, -1);
  const p = document.createElement("input");
  (p.type = "file"), (p.accept = r);
  const v = writable();
  return (
    (p.onchange = async () => {
      p.files.length || v.set("");
      const x = p.files[0];
      v.set(await fileUpload(x, $));
    }),
    p.click(),
    new Promise((k) => {
      v.subscribe((x) => {
        x && k(x);
      });
    })
  );
}
async function fileUpload($, r) {
  const p = new Blob([new Uint8Array(await $.arrayBuffer())]),
    v = `${r}/${$.name}`.split("//").join("/"),
    k = {
      name: $.name,
      path: v,
      data: await $.arrayBuffer(),
      mime: "ArcOS Uploadable",
    };
  FileBrowserUploadFile.set(k);
  const x = await writeFile(v, p);
  return fbClass.refresh(), x ? v : "";
}
const img0 =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABIAAAAKICAIAAACHSRZaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAiSSURBVHhe7cEBDQAAAMKg909tDjcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALhTAzCGAAGNmWH9AAAAAElFTkSuQmCC",
  img01 = "./assets/img01-bbc2eae0.png",
  img02 = "./assets/img02-6950200c.png",
  img03 = "./assets/img03-87b2d378.png",
  img04 = "./assets/img04-9d473c5a.png",
  img05 = "./assets/img05-3c6c1958.png",
  img06 = "./assets/img06-e2fa3f96.jpg",
  img07 = "./assets/img07-788d74d9.jpg",
  img08 = "./assets/img08-feb75f17.jpg",
  img09 = "./assets/img09-99f29be6.png",
  img10 = "./assets/img10-6840e15c.png",
  img11 = "./assets/img11-d41c172b.jpg",
  img12 = "./assets/img12-c9a4396e.png",
  img13 = "./assets/img13-0a31c489.png",
  img14 = "./assets/img14-54c8328b.jpg",
  Wallpapers = {
    img0,
    img04,
    img05,
    img01,
    img02,
    img03,
    img08,
    img13,
    img14,
    img06,
    img07,
    img09,
    img10,
    img11,
    img12,
  },
  getters = [
    [
      "@local:",
      async ($) => await wallpaperFromFS(atob($.replace("@local:", ""))),
    ],
    ["img", ($) => Wallpapers[$] || img04],
  ];
async function getWallpaper($) {
  if (
    (Log({
      msg: `Getting wallpaper ${$.startsWith("img") ? $ : "<custom>"}`,
      source: "userlogic/wallpapers.ts: getWallpaper",
      level: LogLevel.info,
    }),
    !$)
  )
    return img04;
  for (let r = 0; r < getters.length; r++)
    if ($.startsWith(getters[r][0])) return await getters[r][1]($);
  return $;
}
async function wallpaperFromFS($) {
  Log({
    source: "wallpapers.ts: wallpaperFromFS",
    msg: `Reading wallpaper from path "${$}"...`,
    level: LogLevel.info,
  });
  const r = await readFile($);
  return r
    ? URL.createObjectURL(new Blob([new Uint8Array(r)], { type: "image/jpeg" }))
    : (Log({
        source: "wallpapers.ts: wallpaperFromFS",
        msg: `Unable to get wallpaper "${$}"`,
        level: LogLevel.error,
      }),
      img04);
}
function create_fragment$1X($) {
  let r, p, v, k;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = space()),
        (k = element("div")),
        (k.innerHTML = `<div class="fake-titlebar">Window Title</div> 
    <div class="fake-body">Window body</div>`),
        attr(p, "class", "fake-taskbar"),
        toggle_class(p, "colored", $[1].sh.taskbar.colored),
        toggle_class(p, "docked", $[1].sh.taskbar.docked),
        attr(k, "class", "fake-window"),
        attr(r, "class", "current"),
        set_style(r, "background-image", "url(" + $[0] + ")");
    },
    m(x, S) {
      insert(x, r, S), append(r, p), append(r, v), append(r, k);
    },
    p(x, [S]) {
      S & 2 && toggle_class(p, "colored", x[1].sh.taskbar.colored),
        S & 2 && toggle_class(p, "docked", x[1].sh.taskbar.docked),
        S & 1 && set_style(r, "background-image", "url(" + x[0] + ")");
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r);
    },
  };
}
function instance$1J($, r, p) {
  let v;
  component_subscribe($, UserData, (x) => p(1, (v = x)));
  let k = "";
  return (
    UserData.subscribe(async () => {
      p(0, (k = await getWallpaper(v.sh.desktop.wallpaper)));
    }),
    [k, v]
  );
}
class Current extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1J, create_fragment$1X, safe_not_equal, {});
  }
}
function create_if_block$O($) {
  let r;
  return {
    c() {
      (r = element("span")),
        (r.textContent = "block"),
        attr(r, "class", "material-icons-round none");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$1W($) {
  let r,
    p,
    v,
    k,
    x = $[0][0] == "img0" && create_if_block$O();
  return {
    c() {
      (r = element("div")),
        x && x.c(),
        attr(r, "class", "wallpaper"),
        set_style(r, "background-image", "url(" + $[0][1] + ")"),
        attr(r, "title", (p = $[0][0] == "img0" ? "(none)" : $[0][0])),
        toggle_class(r, "selected", $[1].sh.desktop.wallpaper == $[0][0]);
    },
    m(S, I) {
      insert(S, r, I),
        x && x.m(r, null),
        v || ((k = listen(r, "click", $[2])), (v = !0));
    },
    p(S, [I]) {
      S[0][0] == "img0"
        ? x || ((x = create_if_block$O()), x.c(), x.m(r, null))
        : x && (x.d(1), (x = null)),
        I & 1 && set_style(r, "background-image", "url(" + S[0][1] + ")"),
        I & 1 &&
          p !== (p = S[0][0] == "img0" ? "(none)" : S[0][0]) &&
          attr(r, "title", p),
        I & 3 &&
          toggle_class(r, "selected", S[1].sh.desktop.wallpaper == S[0][0]);
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r), x && x.d(), (v = !1), k();
    },
  };
}
function instance$1I($, r, p) {
  let v;
  component_subscribe($, UserData, (S) => p(1, (v = S)));
  let { wallpaper: k } = r;
  function x() {
    set_store_value(UserData, (v.sh.desktop.wallpaper = k[0]), v);
  }
  return (
    ($.$$set = (S) => {
      "wallpaper" in S && p(0, (k = S.wallpaper));
    }),
    [k, v, x]
  );
}
class ImageSelector extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1I, create_fragment$1W, safe_not_equal, {
        wallpaper: 0,
      });
  }
}
const sleep = ($) => new Promise((r) => setTimeout(r, $));
function create_fragment$1V($) {
  let r, p, v, k;
  return {
    c() {
      (r = element("div")),
        attr(r, "class", "wallpaper"),
        set_style(r, "background-image", "url(" + $[0].url + ")"),
        attr(r, "title", (p = $[0].path)),
        toggle_class(
          r,
          "selected",
          $[1].sh.desktop.wallpaper == $[2]($[0].path)
        );
    },
    m(x, S) {
      insert(x, r, S), v || ((k = listen(r, "click", $[3])), (v = !0));
    },
    p(x, [S]) {
      S & 1 && set_style(r, "background-image", "url(" + x[0].url + ")"),
        S & 1 && p !== (p = x[0].path) && attr(r, "title", p),
        S & 7 &&
          toggle_class(
            r,
            "selected",
            x[1].sh.desktop.wallpaper == x[2](x[0].path)
          );
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r), (v = !1), k();
    },
  };
}
function instance$1H($, r, p) {
  let v;
  component_subscribe($, UserData, (I) => p(1, (v = I)));
  let { wallpaper: k } = r;
  const x = (I) => `@local:${btoa(I)}`;
  function S() {
    const I = get_store_value(UserData);
    (I.sh.desktop.wallpaper = x(k.path)), UserData.set(I);
  }
  return (
    ($.$$set = (I) => {
      "wallpaper" in I && p(0, (k = I.wallpaper));
    }),
    [k, v, x, S]
  );
}
let Wallpaper$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1H, create_fragment$1V, safe_not_equal, {
        wallpaper: 0,
      });
  }
};
function get_each_context$t($, r, p) {
  const v = $.slice();
  return (v[5] = r[p]), v;
}
function create_if_block$N($) {
  let r,
    p,
    v = $[0],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$t(get_each_context$t($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 1) {
        v = S[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$t(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$t(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_each_block$t($) {
  let r, p;
  return (
    (r = new Wallpaper$1({ props: { wallpaper: $[5] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.wallpaper = v[5]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1U($) {
  let r,
    p,
    v = !$[1] && create_if_block$N($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[1]
        ? v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros())
        : v
        ? (v.p(k, x), x & 2 && transition_in(v, 1))
        : ((v = create_if_block$N(k)),
          v.c(),
          transition_in(v, 1),
          v.m(r.parentNode, r));
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
async function createUrl($) {
  const r = new Blob([new Uint8Array($)], { type: "image/*" });
  return URL.createObjectURL(r);
}
function instance$1G($, r, p) {
  let v = [],
    k = !1,
    x = 0;
  UserData.subscribe(S);
  async function S() {
    const F = [];
    if ((await I()).length == x) return;
    x = 0;
    const O = await getDirectory("./Wallpapers");
    if (O) {
      for (let L = 0; L < O.files.length; L++) {
        const U = O.files[L],
          { scopedPath: N, mime: j } = U;
        if (!j.startsWith("image")) continue;
        x++;
        const R = await readFile(N);
        R && F.push({ path: N, url: await createUrl(R) });
      }
      await sleep(5),
        F.length != v.length &&
          (p(1, (k = !0)),
          p(0, (v = F)),
          setTimeout(() => {
            p(1, (k = !1));
          }));
    }
  }
  async function I() {
    const F = [],
      O = await getDirectory("./Wallpapers");
    if (!O) return [];
    for (let L = 0; L < O.files.length; L++) {
      const U = O.files[L],
        { mime: N } = U;
      N.startsWith("image") && F.push(U.scopedPath);
    }
    return F;
  }
  return [v, k];
}
class FilesystemWallpapers extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1G, create_fragment$1U, safe_not_equal, {});
  }
}
function get_each_context$s($, r, p) {
  const v = $.slice();
  return (v[2] = r[p]), v;
}
function create_each_block$s($) {
  let r, p;
  return (
    (r = new ImageSelector({ props: { wallpaper: $[2] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1T($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q;
  k = new Current({});
  let Q = Object.entries(Wallpapers),
    K = [];
  for (let H = 0; H < Q.length; H += 1)
    K[H] = create_each_block$s(get_each_context$s($, Q, H));
  const V = (H) =>
    transition_out(K[H], 1, 1, () => {
      K[H] = null;
    });
  return (
    (F = new FilesystemWallpapers({})),
    {
      c() {
        (r = element("div")),
          (p = element("h1")),
          (p.textContent = "Wallpaper"),
          (v = space()),
          create_component(k.$$.fragment),
          (x = space()),
          (S = element("div"));
        for (let H = 0; H < K.length; H += 1) K[H].c();
        (I = space()),
          create_component(F.$$.fragment),
          (O = space()),
          (L = element("div")),
          (L.textContent = "upload"),
          (U = space()),
          (N = element("div")),
          (N.textContent = "travel_explore"),
          attr(L, "class", "wallpaper nobg customwp material-icons-round"),
          attr(L, "title", "Upload wallpaper"),
          attr(N, "class", "wallpaper nobg customwp material-icons-round"),
          attr(N, "title", "Wallpaper from URL"),
          attr(S, "class", "wallpapers"),
          attr(r, "class", "desktop-page");
      },
      m(H, G) {
        insert(H, r, G),
          append(r, p),
          append(r, v),
          mount_component(k, r, null),
          append(r, x),
          append(r, S);
        for (let Y = 0; Y < K.length; Y += 1) K[Y] && K[Y].m(S, null);
        append(S, I),
          mount_component(F, S, null),
          append(S, O),
          append(S, L),
          append(S, U),
          append(S, N),
          (j = !0),
          R ||
            ((q = [listen(L, "click", $[1]), listen(N, "click", $[0])]),
            (R = !0));
      },
      p(H, [G]) {
        if (G & 0) {
          Q = Object.entries(Wallpapers);
          let Y;
          for (Y = 0; Y < Q.length; Y += 1) {
            const J = get_each_context$s(H, Q, Y);
            K[Y]
              ? (K[Y].p(J, G), transition_in(K[Y], 1))
              : ((K[Y] = create_each_block$s(J)),
                K[Y].c(),
                transition_in(K[Y], 1),
                K[Y].m(S, I));
          }
          for (group_outros(), Y = Q.length; Y < K.length; Y += 1) V(Y);
          check_outros();
        }
      },
      i(H) {
        if (!j) {
          transition_in(k.$$.fragment, H);
          for (let G = 0; G < Q.length; G += 1) transition_in(K[G]);
          transition_in(F.$$.fragment, H), (j = !0);
        }
      },
      o(H) {
        transition_out(k.$$.fragment, H), (K = K.filter(Boolean));
        for (let G = 0; G < K.length; G += 1) transition_out(K[G]);
        transition_out(F.$$.fragment, H), (j = !1);
      },
      d(H) {
        H && detach(r),
          destroy_component(k),
          destroy_each(K, H),
          destroy_component(F),
          (R = !1),
          run_all(q);
      },
    }
  );
}
function instance$1F($) {
  function r() {
    showOverlay("customWallpaper", "SettingsApp");
  }
  async function p() {
    await createDirectory("./Wallpapers");
    const v = await directSingleUpload(
        "./Wallpapers",
        "image/png, image/jpeg, image/gif, image/svg+xml"
      ),
      k = get_store_value(UserData);
    (k.sh.desktop.wallpaper = `@local:${btoa(v)}`), UserData.set(k);
  }
  return [r, p];
}
let Desktop$2 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1F, create_fragment$1T, safe_not_equal, {});
  }
};
const DefaultThemes = {
    arcDark: {
      author: "ArcOS Team",
      version: "1.0.0",
      name: "ArcOS Dark",
      anim: !0,
      noGlass: !1,
      sharp: !1,
      theme: "dark",
      wallpaper: "img04",
      taskbarCentered: !1,
      taskbarLabels: !1,
      taskbarPosition: "",
      docked: !1,
      accent: "70D6FF",
      smallStart: !0,
      titleButtons: "default",
      titlebarLarge: !1,
      titlebarLeft: !1,
      taskbarColored: !1,
    },
    arcLight: {
      author: "ArcOS Team",
      version: "1.0.0",
      name: "ArcOS Light",
      anim: !0,
      noGlass: !1,
      sharp: !1,
      theme: "light",
      wallpaper: "img05",
      taskbarCentered: !1,
      taskbarLabels: !1,
      taskbarPosition: "",
      docked: !1,
      accent: "70D6FF",
      smallStart: !0,
      titleButtons: "default",
      titlebarLarge: !1,
      titlebarLeft: !1,
      taskbarColored: !1,
    },
    theHague: {
      author: "Aron Wagener",
      version: "1.0.0",
      name: "The Hague",
      anim: !0,
      noGlass: !1,
      sharp: !1,
      theme: "dark",
      wallpaper: "img13",
      taskbarCentered: !1,
      taskbarLabels: !0,
      taskbarPosition: "",
      docked: !0,
      accent: "0A0",
      smallStart: !1,
      titleButtons: "default",
      titlebarLarge: !0,
      titlebarLeft: !1,
      taskbarColored: !1,
    },
    wacky: {
      author: "Izaak Kuipers",
      version: "1.0.0",
      name: "Wacky",
      anim: !0,
      noGlass: !1,
      sharp: !1,
      theme: "dark",
      wallpaper: "img03",
      taskbarCentered: !0,
      taskbarLabels: !0,
      taskbarPosition: "vertical",
      docked: !1,
      accent: "fa0",
      smallStart: !0,
      titleButtons: "og",
      titlebarLarge: !0,
      titlebarLeft: !0,
      taskbarColored: !1,
    },
    performance: {
      author: "ArcOS Team",
      version: "1.0.0",
      name: "Optimal Performance",
      anim: !1,
      noGlass: !0,
      sharp: !0,
      theme: "dark",
      wallpaper: "img0",
      taskbarCentered: !1,
      taskbarLabels: !1,
      taskbarPosition: "",
      docked: !0,
      accent: "FFF",
      smallStart: !0,
      titleButtons: "default",
      titlebarLarge: !1,
      titlebarLeft: !1,
      taskbarColored: !1,
    },
    wandelbos: {
      version: "1.0.0",
      name: "Wandelbos",
      author: "Izaak",
      anim: !0,
      noGlass: !1,
      sharp: !1,
      theme: "dark",
      wallpaper: "img08",
      accent: "91F5AD",
      docked: !0,
      taskbarCentered: !1,
      taskbarLabels: !1,
      taskbarPosition: "",
      smallStart: !0,
      titleButtons: "default",
      titlebarLarge: !1,
      titlebarLeft: !1,
      taskbarColored: !0,
    },
    scheveningen: {
      version: "1.0.0",
      name: "Scheveningen",
      author: "Izaak & keesvv",
      anim: !0,
      noGlass: !1,
      sharp: !1,
      theme: "dark",
      wallpaper: "img14",
      accent: "264653",
      docked: !0,
      taskbarCentered: !1,
      taskbarLabels: !1,
      taskbarPosition: "",
      smallStart: !0,
      titleButtons: "default",
      titlebarLarge: !1,
      titlebarLeft: !1,
      taskbarColored: !0,
    },
  },
  accentColors = [
    "F94144",
    "F3722C",
    "F8961E",
    "F9C74F",
    "90BE6D",
    "43AA8B",
    "577590",
    "264653",
    "E63946",
    "F1FAEE",
    "A8DADC",
    "457B9D",
    "1D3557",
    "F72585",
    "7209B7",
    "03045E",
    "FF70A6",
    "F61067",
    "D62828",
    "F49E4C",
    "E2C044",
    "E9FF70",
    "C2E812",
    "61E786",
    "91F5AD",
    "70D6FF",
    "AFCBFF",
    "A09BE7",
  ],
  Color_svelte_svelte_type_style_lang = "";
function create_fragment$1S($) {
  let r, p, v, k;
  return {
    c() {
      (r = element("button")),
        attr(r, "class", "color ol svelte-17jz46c"),
        set_style(r, "background", "#" + $[0]),
        attr(r, "data-caller", "appearance-accentselector"),
        attr(r, "data-hex", $[0]),
        attr(r, "title", (p = "#" + $[0].toUpperCase())),
        toggle_class(r, "selected", $[0] == $[1].sh.desktop.accent);
    },
    m(x, S) {
      insert(x, r, S), v || ((k = listen(r, "click", $[2])), (v = !0));
    },
    p(x, [S]) {
      S & 1 && set_style(r, "background", "#" + x[0]),
        S & 1 && attr(r, "data-hex", x[0]),
        S & 1 && p !== (p = "#" + x[0].toUpperCase()) && attr(r, "title", p),
        S & 3 && toggle_class(r, "selected", x[0] == x[1].sh.desktop.accent);
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r), (v = !1), k();
    },
  };
}
function instance$1E($, r, p) {
  let v;
  component_subscribe($, UserData, (S) => p(1, (v = S)));
  let { color: k } = r;
  function x() {
    set_store_value(UserData, (v.sh.desktop.accent = k), v);
  }
  return (
    ($.$$set = (S) => {
      "color" in S && p(0, (k = S.color));
    }),
    [k, v, x]
  );
}
class Color extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1E, create_fragment$1S, safe_not_equal, {
        color: 0,
      });
  }
}
const AccentColor_svelte_svelte_type_style_lang = "";
function get_each_context$r($, r, p) {
  const v = $.slice();
  return (v[0] = r[p]), v;
}
function create_each_block$r($) {
  let r, p;
  return (
    (r = new Color({ props: { color: $[0] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1R($) {
  let r, p, v, k;
  r = new OptionSection({
    props: {
      title: "Accent Color",
      context: "Choose an accent color for ArcOS",
    },
  });
  let x = accentColors,
    S = [];
  for (let F = 0; F < x.length; F += 1)
    S[F] = create_each_block$r(get_each_context$r($, x, F));
  const I = (F) =>
    transition_out(S[F], 1, 1, () => {
      S[F] = null;
    });
  return {
    c() {
      create_component(r.$$.fragment), (p = space()), (v = element("div"));
      for (let F = 0; F < S.length; F += 1) S[F].c();
      attr(v, "class", "wrapper svelte-1xz38z7");
    },
    m(F, O) {
      mount_component(r, F, O), insert(F, p, O), insert(F, v, O);
      for (let L = 0; L < S.length; L += 1) S[L] && S[L].m(v, null);
      k = !0;
    },
    p(F, [O]) {
      if (O & 0) {
        x = accentColors;
        let L;
        for (L = 0; L < x.length; L += 1) {
          const U = get_each_context$r(F, x, L);
          S[L]
            ? (S[L].p(U, O), transition_in(S[L], 1))
            : ((S[L] = create_each_block$r(U)),
              S[L].c(),
              transition_in(S[L], 1),
              S[L].m(v, null));
        }
        for (group_outros(), L = x.length; L < S.length; L += 1) I(L);
        check_outros();
      }
    },
    i(F) {
      if (!k) {
        transition_in(r.$$.fragment, F);
        for (let O = 0; O < x.length; O += 1) transition_in(S[O]);
        k = !0;
      }
    },
    o(F) {
      transition_out(r.$$.fragment, F), (S = S.filter(Boolean));
      for (let O = 0; O < S.length; O += 1) transition_out(S[O]);
      k = !1;
    },
    d(F) {
      destroy_component(r, F),
        F && detach(p),
        F && detach(v),
        destroy_each(S, F);
    },
  };
}
class AccentColor extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$1R, safe_not_equal, {});
  }
}
function create_fragment$1Q($) {
  let r, p, v, k, x, S, I, F, O, L, U;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("div")),
        attr(v, "class", "accent"),
        set_style(v, "color", $[0][1].accent),
        attr(p, "class", (k = "mockup-window theme-" + $[0][1].theme)),
        attr(r, "class", "themerenderer"),
        attr(r, "title", (x = $[0][1].name + " by " + $[0][1].author)),
        set_style(r, "background-image", "url(" + $[2] + ")"),
        set_style(r, "--accent", "#" + $[0][1].accent),
        attr(r, "data-id", (S = $[0][0])),
        attr(
          r,
          "data-caller",
          (I = "themerenderer-" + ($[1] ? "user" : "system"))
        ),
        attr(r, "data-name", (F = $[0][1].name)),
        attr(r, "data-json", (O = JSON.stringify($[0][1]))),
        toggle_class(r, "sharp", $[0][1].sharp);
    },
    m(N, j) {
      insert(N, r, j),
        append(r, p),
        append(p, v),
        L || ((U = listen(r, "click", $[3])), (L = !0));
    },
    p(N, [j]) {
      j & 1 && set_style(v, "color", N[0][1].accent),
        j & 1 &&
          k !== (k = "mockup-window theme-" + N[0][1].theme) &&
          attr(p, "class", k),
        j & 1 &&
          x !== (x = N[0][1].name + " by " + N[0][1].author) &&
          attr(r, "title", x),
        j & 4 && set_style(r, "background-image", "url(" + N[2] + ")"),
        j & 1 && set_style(r, "--accent", "#" + N[0][1].accent),
        j & 1 && S !== (S = N[0][0]) && attr(r, "data-id", S),
        j & 2 &&
          I !== (I = "themerenderer-" + (N[1] ? "user" : "system")) &&
          attr(r, "data-caller", I),
        j & 1 && F !== (F = N[0][1].name) && attr(r, "data-name", F),
        j & 1 && O !== (O = JSON.stringify(N[0][1])) && attr(r, "data-json", O),
        j & 1 && toggle_class(r, "sharp", N[0][1].sharp);
    },
    i: noop$1,
    o: noop$1,
    d(N) {
      N && detach(r), (L = !1), U();
    },
  };
}
function instance$1D($, r, p) {
  let { theme: v } = r,
    { user: k = !1 } = r,
    x = "";
  function S() {
    loadTheme(v[1]);
  }
  return (
    onMount(async () => {
      p(2, (x = await getWallpaper(v[1].wallpaper)));
    }),
    ($.$$set = (I) => {
      "theme" in I && p(0, (v = I.theme)), "user" in I && p(1, (k = I.user));
    }),
    [v, k, x, S]
  );
}
class ThemeRenderer extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1D, create_fragment$1Q, safe_not_equal, {
        theme: 0,
        user: 1,
      });
  }
}
function get_each_context$q($, r, p) {
  const v = $.slice();
  return (v[4] = r[p]), v;
}
function get_each_context_1$2($, r, p) {
  const v = $.slice();
  return (v[4] = r[p]), v;
}
function create_each_block_1$2($) {
  let r, p;
  return (
    (r = new ThemeRenderer({ props: { theme: $[4] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$M($) {
  let r,
    p,
    v = Object.entries($[1].sh.userThemes),
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$q(get_each_context$q($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 2) {
        v = Object.entries(S[1].sh.userThemes);
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$q(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$q(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_each_block$q($) {
  let r, p;
  return (
    (r = new ThemeRenderer({ props: { theme: $[4], user: !0 } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 2 && (x.theme = v[4]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1P($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F = Object.entries(DefaultThemes),
    O = [];
  for (let N = 0; N < F.length; N += 1)
    O[N] = create_each_block_1$2(get_each_context_1$2($, F, N));
  const L = (N) =>
    transition_out(O[N], 1, 1, () => {
      O[N] = null;
    });
  let U = !$[0] && $[1].sh.userThemes && create_if_block$M($);
  return {
    c() {
      r = element("div");
      for (let N = 0; N < O.length; N += 1) O[N].c();
      (p = space()),
        U && U.c(),
        (v = space()),
        (k = element("button")),
        (k.textContent = "save"),
        attr(k, "class", "themerenderer save material-icons-round"),
        attr(k, "title", "Save current theme"),
        attr(r, "class", "themes");
    },
    m(N, j) {
      insert(N, r, j);
      for (let R = 0; R < O.length; R += 1) O[R] && O[R].m(r, null);
      append(r, p),
        U && U.m(r, null),
        append(r, v),
        append(r, k),
        (x = !0),
        S || ((I = listen(k, "click", $[2])), (S = !0));
    },
    p(N, [j]) {
      if (j & 0) {
        F = Object.entries(DefaultThemes);
        let R;
        for (R = 0; R < F.length; R += 1) {
          const q = get_each_context_1$2(N, F, R);
          O[R]
            ? (O[R].p(q, j), transition_in(O[R], 1))
            : ((O[R] = create_each_block_1$2(q)),
              O[R].c(),
              transition_in(O[R], 1),
              O[R].m(r, p));
        }
        for (group_outros(), R = F.length; R < O.length; R += 1) L(R);
        check_outros();
      }
      !N[0] && N[1].sh.userThemes
        ? U
          ? (U.p(N, j), j & 3 && transition_in(U, 1))
          : ((U = create_if_block$M(N)), U.c(), transition_in(U, 1), U.m(r, v))
        : U &&
          (group_outros(),
          transition_out(U, 1, 1, () => {
            U = null;
          }),
          check_outros());
    },
    i(N) {
      if (!x) {
        for (let j = 0; j < F.length; j += 1) transition_in(O[j]);
        transition_in(U), (x = !0);
      }
    },
    o(N) {
      O = O.filter(Boolean);
      for (let j = 0; j < O.length; j += 1) transition_out(O[j]);
      transition_out(U), (x = !1);
    },
    d(N) {
      N && detach(r), destroy_each(O, N), U && U.d(), (S = !1), I();
    },
  };
}
function instance$1C($, r, p) {
  let v;
  component_subscribe($, UserData, (I) => p(1, (v = I)));
  let k = 0,
    x = !1;
  return (
    UserData.subscribe((I) => {
      const F = Object.entries(I.sh.userThemes);
      k != F.length &&
        ((k = F.length),
        p(0, (x = !0)),
        setTimeout(() => {
          p(0, (x = !1));
        }));
    }),
    [x, v, () => showOverlay("saveTheme", "SettingsApp")]
  );
}
class Themes extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1C, create_fragment$1P, safe_not_equal, {});
  }
}
function create_default_slot$6($) {
  let r, p, v, k, x, S, I, F;
  return {
    c() {
      (r = element("select")),
        (p = element("option")),
        (p.textContent = "Darkmode"),
        (v = element("option")),
        (v.textContent = "Lightmode"),
        (k = element("option")),
        (k.textContent = "Amoled"),
        (x = element("option")),
        (x.textContent = "Science Fiction"),
        (S = element("option")),
        (S.textContent = "High contrast"),
        (p.__value = "dark"),
        (p.value = p.__value),
        (v.__value = "light"),
        (v.value = v.__value),
        (k.__value = "amoled"),
        (k.value = k.__value),
        (x.__value = "scifi"),
        (x.value = x.__value),
        (S.__value = "hc"),
        (S.value = S.__value),
        attr(r, "name", "aa"),
        attr(r, "id", "bb"),
        $[0].sh.desktop.theme === void 0 &&
          add_render_callback(() => $[1].call(r));
    },
    m(O, L) {
      insert(O, r, L),
        append(r, p),
        append(r, v),
        append(r, k),
        append(r, x),
        append(r, S),
        select_option(r, $[0].sh.desktop.theme, !0),
        I || ((F = listen(r, "change", $[1])), (I = !0));
    },
    p(O, L) {
      L & 1 && select_option(r, O[0].sh.desktop.theme);
    },
    d(O) {
      O && detach(r), (I = !1), F();
    },
  };
}
function create_fragment$1O($) {
  let r, p, v, k, x, S, I, F, O, L, U, N;
  return (
    (x = new Current({})),
    (I = new Themes({})),
    (O = new OptionSection({
      props: {
        title: "Style",
        context: "Change the style of the UI",
        $$slots: { default: [create_default_slot$6] },
        $$scope: { ctx: $ },
      },
    })),
    (U = new AccentColor({})),
    {
      c() {
        (r = element("h1")),
          (r.textContent = "Appearance"),
          (p = space()),
          (v = element("div")),
          (k = element("div")),
          create_component(x.$$.fragment),
          (S = space()),
          create_component(I.$$.fragment),
          (F = space()),
          create_component(O.$$.fragment),
          (L = space()),
          create_component(U.$$.fragment),
          attr(k, "class", "desktop-page"),
          attr(v, "class", "settingspage-themes");
      },
      m(j, R) {
        insert(j, r, R),
          insert(j, p, R),
          insert(j, v, R),
          append(v, k),
          mount_component(x, k, null),
          append(v, S),
          mount_component(I, v, null),
          insert(j, F, R),
          mount_component(O, j, R),
          insert(j, L, R),
          mount_component(U, j, R),
          (N = !0);
      },
      p(j, [R]) {
        const q = {};
        R & 5 && (q.$$scope = { dirty: R, ctx: j }), O.$set(q);
      },
      i(j) {
        N ||
          (transition_in(x.$$.fragment, j),
          transition_in(I.$$.fragment, j),
          transition_in(O.$$.fragment, j),
          transition_in(U.$$.fragment, j),
          (N = !0));
      },
      o(j) {
        transition_out(x.$$.fragment, j),
          transition_out(I.$$.fragment, j),
          transition_out(O.$$.fragment, j),
          transition_out(U.$$.fragment, j),
          (N = !1);
      },
      d(j) {
        j && detach(r),
          j && detach(p),
          j && detach(v),
          destroy_component(x),
          destroy_component(I),
          j && detach(F),
          destroy_component(O, j),
          j && detach(L),
          destroy_component(U, j);
      },
    }
  );
}
function instance$1B($, r, p) {
  let v;
  component_subscribe($, UserData, (x) => p(0, (v = x)));
  function k() {
    (v.sh.desktop.theme = select_value(this)), UserData.set(v);
  }
  return [v, k];
}
let Personalization$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1B, create_fragment$1O, safe_not_equal, {});
  }
};
function create_default_slot_9($) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch");
    },
    m(k, x) {
      insert(k, r, x),
        (r.checked = $[0].sh.taskbar.isLauncher),
        p || ((v = listen(r, "change", $[1])), (p = !0));
    },
    p(k, x) {
      x & 1 && (r.checked = k[0].sh.taskbar.isLauncher);
    },
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_if_block$L($) {
  let r, p, v, k, x, S;
  return (
    (r = new OptionSection({
      props: {
        title: "Center taskbar buttons",
        context: "Centers the taskbar app buttons",
        $$slots: { default: [create_default_slot_8] },
        $$scope: { ctx: $ },
      },
    })),
    (v = new OptionSection({
      props: {
        title: "Taskbar app labels",
        context: "Display app names on the taskbar",
        $$slots: { default: [create_default_slot_7] },
        $$scope: { ctx: $ },
      },
    })),
    (x = new OptionSection({
      props: {
        title: "Taskbar position",
        context: "Where do you want the taskbar?",
        $$slots: { default: [create_default_slot_6$1] },
        $$scope: { ctx: $ },
      },
    })),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          create_component(v.$$.fragment),
          (k = space()),
          create_component(x.$$.fragment);
      },
      m(I, F) {
        mount_component(r, I, F),
          insert(I, p, F),
          mount_component(v, I, F),
          insert(I, k, F),
          mount_component(x, I, F),
          (S = !0);
      },
      p(I, F) {
        const O = {};
        F & 2049 && (O.$$scope = { dirty: F, ctx: I }), r.$set(O);
        const L = {};
        F & 2049 && (L.$$scope = { dirty: F, ctx: I }), v.$set(L);
        const U = {};
        F & 2049 && (U.$$scope = { dirty: F, ctx: I }), x.$set(U);
      },
      i(I) {
        S ||
          (transition_in(r.$$.fragment, I),
          transition_in(v.$$.fragment, I),
          transition_in(x.$$.fragment, I),
          (S = !0));
      },
      o(I) {
        transition_out(r.$$.fragment, I),
          transition_out(v.$$.fragment, I),
          transition_out(x.$$.fragment, I),
          (S = !1);
      },
      d(I) {
        destroy_component(r, I),
          I && detach(p),
          destroy_component(v, I),
          I && detach(k),
          destroy_component(x, I);
      },
    }
  );
}
function create_default_slot_8($) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch");
    },
    m(k, x) {
      insert(k, r, x),
        (r.checked = $[0].sh.taskbar.centered),
        p || ((v = listen(r, "change", $[2])), (p = !0));
    },
    p(k, x) {
      x & 1 && (r.checked = k[0].sh.taskbar.centered);
    },
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_7($) {
  let r, p, v, k;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch"),
        (r.disabled = p = !!$[0].sh.taskbar.pos);
    },
    m(x, S) {
      insert(x, r, S),
        (r.checked = $[0].sh.taskbar.labels),
        v || ((k = listen(r, "change", $[3])), (v = !0));
    },
    p(x, S) {
      S & 1 && p !== (p = !!x[0].sh.taskbar.pos) && (r.disabled = p),
        S & 1 && (r.checked = x[0].sh.taskbar.labels);
    },
    d(x) {
      x && detach(r), (v = !1), k();
    },
  };
}
function create_default_slot_6$1($) {
  let r, p, v, k, x, S;
  return {
    c() {
      (r = element("select")),
        (p = element("option")),
        (p.textContent = "Left"),
        (v = element("option")),
        (v.textContent = "Bottom"),
        (k = element("option")),
        (k.textContent = "Right"),
        (p.__value = "vertical"),
        (p.value = p.__value),
        (v.__value = ""),
        (v.value = v.__value),
        (k.__value = "vertical-right"),
        (k.value = k.__value),
        $[0].sh.taskbar.pos === void 0 &&
          add_render_callback(() => $[4].call(r));
    },
    m(I, F) {
      insert(I, r, F),
        append(r, p),
        append(r, v),
        append(r, k),
        select_option(r, $[0].sh.taskbar.pos, !0),
        x || ((S = listen(r, "change", $[4])), (x = !0));
    },
    p(I, F) {
      F & 1 && select_option(r, I[0].sh.taskbar.pos);
    },
    d(I) {
      I && detach(r), (x = !1), S();
    },
  };
}
function create_default_slot_5$1($) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch");
    },
    m(k, x) {
      insert(k, r, x),
        (r.checked = $[0].sh.start.small),
        p || ((v = listen(r, "change", $[5])), (p = !0));
    },
    p(k, x) {
      x & 1 && (r.checked = k[0].sh.start.small);
    },
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_4$1($) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch");
    },
    m(k, x) {
      insert(k, r, x),
        (r.checked = $[0].sh.showHiddenApps),
        p ||
          ((v = [listen(r, "change", $[6]), listen(r, "click", updateStores)]),
          (p = !0));
    },
    p(k, x) {
      x & 1 && (r.checked = k[0].sh.showHiddenApps);
    },
    d(k) {
      k && detach(r), (p = !1), run_all(v);
    },
  };
}
function create_default_slot_3$1($) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch");
    },
    m(k, x) {
      insert(k, r, x),
        (r.checked = $[0].sh.noQuickSettings),
        p || ((v = listen(r, "change", $[7])), (p = !0));
    },
    p(k, x) {
      x & 1 && (r.checked = k[0].sh.noQuickSettings);
    },
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_2$1($) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch");
    },
    m(k, x) {
      insert(k, r, x),
        (r.checked = $[0].sh.taskbar.docked),
        p || ((v = listen(r, "change", $[8])), (p = !0));
    },
    p(k, x) {
      x & 1 && (r.checked = k[0].sh.taskbar.docked);
    },
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_1$2($) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "id", "a"),
        attr(r, "class", "switch");
    },
    m(k, x) {
      insert(k, r, x),
        (r.checked = $[0].sh.taskbar.colored),
        p || ((v = listen(r, "change", $[9])), (p = !0));
    },
    p(k, x) {
      x & 1 && (r.checked = k[0].sh.taskbar.colored);
    },
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot$5($) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "class", "switch");
    },
    m(k, x) {
      insert(k, r, x),
        (r.checked = $[0].sh.compactContext),
        p || ((v = listen(r, "change", $[10])), (p = !0));
    },
    p(k, x) {
      x & 1 && (r.checked = k[0].sh.compactContext);
    },
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_fragment$1N($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K, V, H, G, Y, J, Z;
  v = new OptionSection({
    props: {
      title: "Launcher Mode",
      context: "Use a GNOME-style launcher instead of the taskbar",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx: $ },
    },
  });
  let X = !$[0].sh.taskbar.isLauncher && create_if_block$L($);
  return (
    (F = new OptionSection({
      props: {
        title: "Small start menu",
        context: "Make the start menu smaller",
        $$slots: { default: [create_default_slot_5$1] },
        $$scope: { ctx: $ },
      },
    })),
    (L = new OptionSection({
      props: {
        title: "Show hidden apps",
        context: "Display hidden apps in the start menu",
        $$slots: { default: [create_default_slot_4$1] },
        $$scope: { ctx: $ },
      },
    })),
    (R = new OptionSection({
      props: {
        title: "Hide quick settings",
        context: "Hide quick settings in the action center",
        $$slots: { default: [create_default_slot_3$1] },
        $$scope: { ctx: $ },
      },
    })),
    (Q = new OptionSection({
      props: {
        title: "Dock shell",
        context: "Dock the taskbar and action center",
        $$slots: { default: [create_default_slot_2$1] },
        $$scope: { ctx: $ },
      },
    })),
    (V = new OptionSection({
      props: {
        title: "Colored shell",
        context: "Apply the accent color to the shell",
        $$slots: { default: [create_default_slot_1$2] },
        $$scope: { ctx: $ },
      },
    })),
    (J = new OptionSection({
      props: {
        title: "Compact context menu",
        context: "Make the context menu more compact",
        $$slots: { default: [create_default_slot$5] },
        $$scope: { ctx: $ },
      },
    })),
    {
      c() {
        (r = element("h1")),
          (r.textContent = "Shell"),
          (p = space()),
          create_component(v.$$.fragment),
          (k = space()),
          X && X.c(),
          (x = space()),
          (S = element("hr")),
          (I = space()),
          create_component(F.$$.fragment),
          (O = space()),
          create_component(L.$$.fragment),
          (U = space()),
          (N = element("hr")),
          (j = space()),
          create_component(R.$$.fragment),
          (q = space()),
          create_component(Q.$$.fragment),
          (K = space()),
          create_component(V.$$.fragment),
          (H = space()),
          (G = element("hr")),
          (Y = space()),
          create_component(J.$$.fragment);
      },
      m(ee, te) {
        insert(ee, r, te),
          insert(ee, p, te),
          mount_component(v, ee, te),
          insert(ee, k, te),
          X && X.m(ee, te),
          insert(ee, x, te),
          insert(ee, S, te),
          insert(ee, I, te),
          mount_component(F, ee, te),
          insert(ee, O, te),
          mount_component(L, ee, te),
          insert(ee, U, te),
          insert(ee, N, te),
          insert(ee, j, te),
          mount_component(R, ee, te),
          insert(ee, q, te),
          mount_component(Q, ee, te),
          insert(ee, K, te),
          mount_component(V, ee, te),
          insert(ee, H, te),
          insert(ee, G, te),
          insert(ee, Y, te),
          mount_component(J, ee, te),
          (Z = !0);
      },
      p(ee, [te]) {
        const ie = {};
        te & 2049 && (ie.$$scope = { dirty: te, ctx: ee }),
          v.$set(ie),
          ee[0].sh.taskbar.isLauncher
            ? X &&
              (group_outros(),
              transition_out(X, 1, 1, () => {
                X = null;
              }),
              check_outros())
            : X
            ? (X.p(ee, te), te & 1 && transition_in(X, 1))
            : ((X = create_if_block$L(ee)),
              X.c(),
              transition_in(X, 1),
              X.m(x.parentNode, x));
        const ue = {};
        te & 2049 && (ue.$$scope = { dirty: te, ctx: ee }), F.$set(ue);
        const oe = {};
        te & 2049 && (oe.$$scope = { dirty: te, ctx: ee }), L.$set(oe);
        const se = {};
        te & 2049 && (se.$$scope = { dirty: te, ctx: ee }), R.$set(se);
        const re = {};
        te & 2049 && (re.$$scope = { dirty: te, ctx: ee }), Q.$set(re);
        const le = {};
        te & 2049 && (le.$$scope = { dirty: te, ctx: ee }), V.$set(le);
        const ae = {};
        te & 2049 && (ae.$$scope = { dirty: te, ctx: ee }), J.$set(ae);
      },
      i(ee) {
        Z ||
          (transition_in(v.$$.fragment, ee),
          transition_in(X),
          transition_in(F.$$.fragment, ee),
          transition_in(L.$$.fragment, ee),
          transition_in(R.$$.fragment, ee),
          transition_in(Q.$$.fragment, ee),
          transition_in(V.$$.fragment, ee),
          transition_in(J.$$.fragment, ee),
          (Z = !0));
      },
      o(ee) {
        transition_out(v.$$.fragment, ee),
          transition_out(X),
          transition_out(F.$$.fragment, ee),
          transition_out(L.$$.fragment, ee),
          transition_out(R.$$.fragment, ee),
          transition_out(Q.$$.fragment, ee),
          transition_out(V.$$.fragment, ee),
          transition_out(J.$$.fragment, ee),
          (Z = !1);
      },
      d(ee) {
        ee && detach(r),
          ee && detach(p),
          destroy_component(v, ee),
          ee && detach(k),
          X && X.d(ee),
          ee && detach(x),
          ee && detach(S),
          ee && detach(I),
          destroy_component(F, ee),
          ee && detach(O),
          destroy_component(L, ee),
          ee && detach(U),
          ee && detach(N),
          ee && detach(j),
          destroy_component(R, ee),
          ee && detach(q),
          destroy_component(Q, ee),
          ee && detach(K),
          destroy_component(V, ee),
          ee && detach(H),
          ee && detach(G),
          ee && detach(Y),
          destroy_component(J, ee);
      },
    }
  );
}
function instance$1A($, r, p) {
  let v;
  component_subscribe($, UserData, (R) => p(0, (v = R)));
  function k() {
    (v.sh.taskbar.isLauncher = this.checked), UserData.set(v);
  }
  function x() {
    (v.sh.taskbar.centered = this.checked), UserData.set(v);
  }
  function S() {
    (v.sh.taskbar.labels = this.checked), UserData.set(v);
  }
  function I() {
    (v.sh.taskbar.pos = select_value(this)), UserData.set(v);
  }
  function F() {
    (v.sh.start.small = this.checked), UserData.set(v);
  }
  function O() {
    (v.sh.showHiddenApps = this.checked), UserData.set(v);
  }
  function L() {
    (v.sh.noQuickSettings = this.checked), UserData.set(v);
  }
  function U() {
    (v.sh.taskbar.docked = this.checked), UserData.set(v);
  }
  function N() {
    (v.sh.taskbar.colored = this.checked), UserData.set(v);
  }
  function j() {
    (v.sh.compactContext = this.checked), UserData.set(v);
  }
  return [v, k, x, S, I, F, O, L, U, N, j];
}
let Shell$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1A, create_fragment$1N, safe_not_equal, {});
  }
};
function create_default_slot_6($) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "class", "switch");
    },
    m(k, x) {
      insert(k, r, x),
        (r.checked = $[0].sh.window.bigtb),
        p || ((v = listen(r, "change", $[1])), (p = !0));
    },
    p(k, x) {
      x & 1 && (r.checked = k[0].sh.window.bigtb);
    },
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_5($) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "class", "switch");
    },
    m(k, x) {
      insert(k, r, x),
        (r.checked = $[0].sh.window.lefttb),
        p || ((v = listen(r, "change", $[2])), (p = !0));
    },
    p(k, x) {
      x & 1 && (r.checked = k[0].sh.window.lefttb);
    },
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_4($) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "class", "switch");
    },
    m(k, x) {
      insert(k, r, x),
        (r.checked = $[0].sh.window.centertb),
        p || ((v = listen(r, "change", $[3])), (p = !0));
    },
    p(k, x) {
      x & 1 && (r.checked = k[0].sh.window.centertb);
    },
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_3($) {
  let r, p, v;
  return {
    c() {
      (r = element("button")), (r.textContent = "Change...");
    },
    m(k, x) {
      insert(k, r, x), p || ((v = listen(r, "click", $[4])), (p = !0));
    },
    p: noop$1,
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_2($) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "class", "switch");
    },
    m(k, x) {
      insert(k, r, x),
        (r.checked = $[0].sh.anim),
        p || ((v = listen(r, "change", $[5])), (p = !0));
    },
    p(k, x) {
      x & 1 && (r.checked = k[0].sh.anim);
    },
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot_1$1($) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "class", "switch");
    },
    m(k, x) {
      insert(k, r, x),
        (r.checked = $[0].sh.noGlass),
        p || ((v = listen(r, "change", $[6])), (p = !0));
    },
    p(k, x) {
      x & 1 && (r.checked = k[0].sh.noGlass);
    },
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_default_slot$4($) {
  let r, p, v;
  return {
    c() {
      (r = element("input")),
        attr(r, "type", "checkbox"),
        attr(r, "class", "switch");
    },
    m(k, x) {
      insert(k, r, x),
        (r.checked = $[0].sh.desktop.sharp),
        p || ((v = listen(r, "change", $[7])), (p = !0));
    },
    p(k, x) {
      x & 1 && (r.checked = k[0].sh.desktop.sharp);
    },
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_fragment$1M($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K, V;
  return (
    (v = new OptionSection({
      props: {
        title: "Large titlebar",
        context: "Make the titlebars larger",
        $$slots: { default: [create_default_slot_6] },
        $$scope: { ctx: $ },
      },
    })),
    (x = new OptionSection({
      props: {
        title: "Left titlebar buttons",
        context: "Swap the title and window controls",
        $$slots: { default: [create_default_slot_5] },
        $$scope: { ctx: $ },
      },
    })),
    (I = new OptionSection({
      props: {
        title: "Center window title",
        context: "Put the window title in the center of the titlebar.",
        $$slots: { default: [create_default_slot_4] },
        $$scope: { ctx: $ },
      },
    })),
    (O = new OptionSection({
      props: {
        title: "Titlebar Buttons",
        context: "Change the titlebar controls",
        $$slots: { default: [create_default_slot_3] },
        $$scope: { ctx: $ },
      },
    })),
    (j = new OptionSection({
      props: {
        title: "Animations",
        context: "Display animations in ArcOS",
        $$slots: { default: [create_default_slot_2] },
        $$scope: { ctx: $ },
      },
    })),
    (q = new OptionSection({
      props: {
        title: "No glass",
        context: "Disable glass effects in ArcOS",
        $$slots: { default: [create_default_slot_1$1] },
        $$scope: { ctx: $ },
      },
    })),
    (K = new OptionSection({
      props: {
        title: "Sharp corners",
        context: "Disable rounding in all of ArcOS",
        $$slots: { default: [create_default_slot$4] },
        $$scope: { ctx: $ },
      },
    })),
    {
      c() {
        (r = element("h1")),
          (r.textContent = "Windows"),
          (p = space()),
          create_component(v.$$.fragment),
          (k = space()),
          create_component(x.$$.fragment),
          (S = space()),
          create_component(I.$$.fragment),
          (F = space()),
          create_component(O.$$.fragment),
          (L = space()),
          (U = element("hr")),
          (N = space()),
          create_component(j.$$.fragment),
          (R = space()),
          create_component(q.$$.fragment),
          (Q = space()),
          create_component(K.$$.fragment);
      },
      m(H, G) {
        insert(H, r, G),
          insert(H, p, G),
          mount_component(v, H, G),
          insert(H, k, G),
          mount_component(x, H, G),
          insert(H, S, G),
          mount_component(I, H, G),
          insert(H, F, G),
          mount_component(O, H, G),
          insert(H, L, G),
          insert(H, U, G),
          insert(H, N, G),
          mount_component(j, H, G),
          insert(H, R, G),
          mount_component(q, H, G),
          insert(H, Q, G),
          mount_component(K, H, G),
          (V = !0);
      },
      p(H, [G]) {
        const Y = {};
        G & 257 && (Y.$$scope = { dirty: G, ctx: H }), v.$set(Y);
        const J = {};
        G & 257 && (J.$$scope = { dirty: G, ctx: H }), x.$set(J);
        const Z = {};
        G & 257 && (Z.$$scope = { dirty: G, ctx: H }), I.$set(Z);
        const X = {};
        G & 256 && (X.$$scope = { dirty: G, ctx: H }), O.$set(X);
        const ee = {};
        G & 257 && (ee.$$scope = { dirty: G, ctx: H }), j.$set(ee);
        const te = {};
        G & 257 && (te.$$scope = { dirty: G, ctx: H }), q.$set(te);
        const ie = {};
        G & 257 && (ie.$$scope = { dirty: G, ctx: H }), K.$set(ie);
      },
      i(H) {
        V ||
          (transition_in(v.$$.fragment, H),
          transition_in(x.$$.fragment, H),
          transition_in(I.$$.fragment, H),
          transition_in(O.$$.fragment, H),
          transition_in(j.$$.fragment, H),
          transition_in(q.$$.fragment, H),
          transition_in(K.$$.fragment, H),
          (V = !0));
      },
      o(H) {
        transition_out(v.$$.fragment, H),
          transition_out(x.$$.fragment, H),
          transition_out(I.$$.fragment, H),
          transition_out(O.$$.fragment, H),
          transition_out(j.$$.fragment, H),
          transition_out(q.$$.fragment, H),
          transition_out(K.$$.fragment, H),
          (V = !1);
      },
      d(H) {
        H && detach(r),
          H && detach(p),
          destroy_component(v, H),
          H && detach(k),
          destroy_component(x, H),
          H && detach(S),
          destroy_component(I, H),
          H && detach(F),
          destroy_component(O, H),
          H && detach(L),
          H && detach(U),
          H && detach(N),
          destroy_component(j, H),
          H && detach(R),
          destroy_component(q, H),
          H && detach(Q),
          destroy_component(K, H);
      },
    }
  );
}
function instance$1z($, r, p) {
  let v;
  component_subscribe($, UserData, (U) => p(0, (v = U)));
  function k() {
    (v.sh.window.bigtb = this.checked), UserData.set(v);
  }
  function x() {
    (v.sh.window.lefttb = this.checked), UserData.set(v);
  }
  function S() {
    (v.sh.window.centertb = this.checked), UserData.set(v);
  }
  const I = () => showOverlay("changeTitleButtons", "SettingsApp");
  function F() {
    (v.sh.anim = this.checked), UserData.set(v);
  }
  function O() {
    (v.sh.noGlass = this.checked), UserData.set(v);
  }
  function L() {
    (v.sh.desktop.sharp = this.checked), UserData.set(v);
  }
  return [v, k, x, S, I, F, O, L];
}
class Windows extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1z, create_fragment$1M, safe_not_equal, {});
  }
}
const SettingsPages = [
  { name: "Account", icon: usericon, content: Account, sep: !0 },
  { name: "Appearance", icon: appearance, content: Personalization$1 },
  { name: "Shell", icon: shellIcon, content: Shell$1 },
  { name: "Windows", icon: windowsIcon, content: Windows },
  { name: "Wallpaper", icon: logo$1, content: Desktop$2, sep: !0 },
  { name: "Apps", icon: appSettings, content: Apps, sep: !0 },
  { name: "About", icon: logo$d, content: About },
];
function getSettingsPage($) {
  for (let r = 0; r < SettingsPages.length; r++)
    if (SettingsPages[r].name == $) return SettingsPages[r];
  return null;
}
function openByKey($) {
  const r = getSettingsPage($);
  r &&
    (openWindow("SettingsApp"),
    setTimeout(() => {
      currentSettingsPage.set(r);
    }));
}
function create_if_block_1$f($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I = $[0].name + "",
    F,
    O,
    L,
    U;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (x = space()),
        (S = element("span")),
        (F = text(I)),
        src_url_equal(p.src, (v = $[0].icon)) || attr(p, "src", v),
        attr(p, "alt", (k = $[0].name)),
        attr(p, "class", "icon"),
        attr(S, "class", "caption"),
        attr(r, "class", "page"),
        (r.disabled = O = $[0].disabled),
        toggle_class(r, "selected", $[1] && $[0].name == $[1].name);
    },
    m(N, j) {
      insert(N, r, j),
        append(r, p),
        append(r, x),
        append(r, S),
        append(S, F),
        L || ((U = listen(r, "click", $[2])), (L = !0));
    },
    p(N, j) {
      j & 1 && !src_url_equal(p.src, (v = N[0].icon)) && attr(p, "src", v),
        j & 1 && k !== (k = N[0].name) && attr(p, "alt", k),
        j & 1 && I !== (I = N[0].name + "") && set_data(F, I),
        j & 1 && O !== (O = N[0].disabled) && (r.disabled = O),
        j & 3 && toggle_class(r, "selected", N[1] && N[0].name == N[1].name);
    },
    d(N) {
      N && detach(r), (L = !1), U();
    },
  };
}
function create_if_block$K($) {
  let r;
  return {
    c() {
      r = element("hr");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$1L($) {
  let r,
    p,
    v = !$[0].hidden && create_if_block_1$f($),
    k = $[0].sep && create_if_block$K();
  return {
    c() {
      v && v.c(), (r = space()), k && k.c(), (p = empty());
    },
    m(x, S) {
      v && v.m(x, S), insert(x, r, S), k && k.m(x, S), insert(x, p, S);
    },
    p(x, [S]) {
      x[0].hidden
        ? v && (v.d(1), (v = null))
        : v
        ? v.p(x, S)
        : ((v = create_if_block_1$f(x)), v.c(), v.m(r.parentNode, r)),
        x[0].sep
          ? k || ((k = create_if_block$K()), k.c(), k.m(p.parentNode, p))
          : k && (k.d(1), (k = null));
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      v && v.d(x), x && detach(r), k && k.d(x), x && detach(p);
    },
  };
}
function instance$1y($, r, p) {
  let v;
  component_subscribe($, currentSettingsPage, (S) => p(1, (v = S)));
  let { page: k } = r;
  const x = () => setSettingsPage(k);
  return (
    ($.$$set = (S) => {
      "page" in S && p(0, (k = S.page));
    }),
    [k, v, x]
  );
}
class Page extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1y, create_fragment$1L, safe_not_equal, {
        page: 0,
      });
  }
}
function create_if_block$J($) {
  let r;
  return {
    c() {
      (r = element("span")),
        (r.textContent = "bug_report"),
        attr(r, "class", "material-icons-round developer");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$1K($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j;
  v = new ProfilePicture$1({ props: { src: $[0], height: 36 } });
  let R = $[2] && create_if_block$J();
  return {
    c() {
      (r = element("div")),
        (p = element("span")),
        create_component(v.$$.fragment),
        (k = space()),
        (x = element("div")),
        (S = element("p")),
        (I = text($[1])),
        (F = space()),
        R && R.c(),
        (O = space()),
        (L = element("p")),
        (L.textContent = `${
          localStorage.getItem("arcos-server") || location.hostname
        }`),
        attr(S, "class", "name"),
        attr(L, "class", "hostname"),
        attr(x, "class", "username"),
        attr(r, "class", "userprofile");
    },
    m(q, Q) {
      insert(q, r, Q),
        append(r, p),
        mount_component(v, p, null),
        append(r, k),
        append(r, x),
        append(x, S),
        append(S, I),
        append(S, F),
        R && R.m(S, null),
        append(x, O),
        append(x, L),
        (U = !0),
        N || ((j = listen(p, "click", $[3])), (N = !0));
    },
    p(q, [Q]) {
      const K = {};
      Q & 1 && (K.src = q[0]),
        v.$set(K),
        (!U || Q & 2) && set_data(I, q[1]),
        q[2]
          ? R || ((R = create_if_block$J()), R.c(), R.m(S, null))
          : R && (R.d(1), (R = null));
    },
    i(q) {
      U || (transition_in(v.$$.fragment, q), (U = !0));
    },
    o(q) {
      transition_out(v.$$.fragment, q), (U = !1);
    },
    d(q) {
      q && detach(r), destroy_component(v), R && R.d(), (N = !1), j();
    },
  };
}
function instance$1x($, r, p) {
  let v, k, x;
  component_subscribe($, UserData, (F) => p(4, (v = F))),
    component_subscribe($, UserName, (F) => p(1, (k = F))),
    component_subscribe($, DevModeOverride, (F) => p(2, (x = F)));
  let S = "";
  UserData.subscribe(() => {
    p(0, (S = getProfilePicture(v.acc.profilePicture)));
  });
  function I() {
    typeof v.acc.profilePicture == "string" &&
      showOverlay("largePfp", "SettingsApp");
  }
  return [S, k, x, I];
}
class UserProfile extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1x, create_fragment$1K, safe_not_equal, {});
  }
}
function get_each_context$p($, r, p) {
  const v = $.slice();
  return (v[4] = r[p]), v;
}
function create_if_block$I($) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.innerHTML = '<span class="material-icons-round">menu</span>'),
        attr(r, "class", "page menu"),
        toggle_class(r, "active", $[0].collapsed);
    },
    m(k, x) {
      insert(k, r, x), p || ((v = listen(r, "click", $[1])), (p = !0));
    },
    p(k, x) {
      x & 1 && toggle_class(r, "active", k[0].collapsed);
    },
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_each_block$p($) {
  let r, p;
  return (
    (r = new Page({ props: { page: $[4] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1J($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I = $[0] && create_if_block$I($),
    F = SettingsPages,
    O = [];
  for (let U = 0; U < F.length; U += 1)
    O[U] = create_each_block$p(get_each_context$p($, F, U));
  const L = (U) =>
    transition_out(O[U], 1, 1, () => {
      O[U] = null;
    });
  return (
    (x = new UserProfile({})),
    {
      c() {
        (r = element("div")), (p = element("div")), I && I.c(), (v = space());
        for (let U = 0; U < O.length; U += 1) O[U].c();
        (k = space()),
          create_component(x.$$.fragment),
          attr(p, "class", "pages"),
          attr(r, "class", "sidebar"),
          toggle_class(r, "collapsed", $[0].collapsed);
      },
      m(U, N) {
        insert(U, r, N), append(r, p), I && I.m(p, null), append(p, v);
        for (let j = 0; j < O.length; j += 1) O[j] && O[j].m(p, null);
        append(r, k), mount_component(x, r, null), (S = !0);
      },
      p(U, [N]) {
        if (
          (U[0]
            ? I
              ? I.p(U, N)
              : ((I = create_if_block$I(U)), I.c(), I.m(p, v))
            : I && (I.d(1), (I = null)),
          N & 0)
        ) {
          F = SettingsPages;
          let j;
          for (j = 0; j < F.length; j += 1) {
            const R = get_each_context$p(U, F, j);
            O[j]
              ? (O[j].p(R, N), transition_in(O[j], 1))
              : ((O[j] = create_each_block$p(R)),
                O[j].c(),
                transition_in(O[j], 1),
                O[j].m(p, null));
          }
          for (group_outros(), j = F.length; j < O.length; j += 1) L(j);
          check_outros();
        }
        (!S || N & 1) && toggle_class(r, "collapsed", U[0].collapsed);
      },
      i(U) {
        if (!S) {
          for (let N = 0; N < F.length; N += 1) transition_in(O[N]);
          transition_in(x.$$.fragment, U), (S = !0);
        }
      },
      o(U) {
        O = O.filter(Boolean);
        for (let N = 0; N < O.length; N += 1) transition_out(O[N]);
        transition_out(x.$$.fragment, U), (S = !1);
      },
      d(U) {
        U && detach(r), I && I.d(), destroy_each(O, U), destroy_component(x);
      },
    }
  );
}
function instance$1w($, r, p) {
  let v;
  component_subscribe($, UserData, (I) => p(3, (v = I)));
  let { appdata: k } = r,
    { app: x } = r;
  function S() {
    p(0, (k.collapsed = !k.collapsed), k),
      set_store_value(UserData, (v.appdata[x.id] = k), v);
  }
  return (
    ($.$$set = (I) => {
      "appdata" in I && p(0, (k = I.appdata)), "app" in I && p(2, (x = I.app));
    }),
    [k, S, x]
  );
}
class Sidebar extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1w, create_fragment$1J, safe_not_equal, {
        appdata: 0,
        app: 2,
      });
  }
}
function create_fragment$1I($) {
  let r, p, v, k, x;
  function S(F) {
    $[2](F);
  }
  let I = { app: $[1] };
  return (
    $[0] !== void 0 && (I.appdata = $[0]),
    (r = new Sidebar({ props: I })),
    binding_callbacks.push(() => bind$1(r, "appdata", S)),
    (k = new Content$1({ props: { appdata: $[0] } })),
    {
      c() {
        create_component(r.$$.fragment),
          (v = space()),
          create_component(k.$$.fragment);
      },
      m(F, O) {
        mount_component(r, F, O),
          insert(F, v, O),
          mount_component(k, F, O),
          (x = !0);
      },
      p(F, [O]) {
        const L = {};
        O & 2 && (L.app = F[1]),
          !p &&
            O & 1 &&
            ((p = !0), (L.appdata = F[0]), add_flush_callback(() => (p = !1))),
          r.$set(L);
        const U = {};
        O & 1 && (U.appdata = F[0]), k.$set(U);
      },
      i(F) {
        x ||
          (transition_in(r.$$.fragment, F),
          transition_in(k.$$.fragment, F),
          (x = !0));
      },
      o(F) {
        transition_out(r.$$.fragment, F),
          transition_out(k.$$.fragment, F),
          (x = !1);
      },
      d(F) {
        destroy_component(r, F), F && detach(v), destroy_component(k, F);
      },
    }
  );
}
function instance$1v($, r, p) {
  let { appdata: v } = r,
    { app: k } = r;
  function x(S) {
    (v = S), p(0, v);
  }
  return (
    ($.$$set = (S) => {
      "appdata" in S && p(0, (v = S.appdata)), "app" in S && p(1, (k = S.app));
    }),
    [v, k, x]
  );
}
let SettingsApp$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1v, create_fragment$1I, safe_not_equal, {
        appdata: 0,
        app: 1,
      });
  }
};
const ProfilePicture_svelte_svelte_type_style_lang = "";
function get_each_context$o($, r, p) {
  const v = $.slice();
  return (v[8] = r[p]), (v[10] = p), v;
}
function create_each_block$o($) {
  let r, p, v, k, x, S;
  function I() {
    return $[7]($[10]);
  }
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (k = space()),
        src_url_equal(p.src, (v = $[8])) || attr(p, "src", v),
        attr(p, "alt", `${$[10] + 1}`),
        attr(p, "class", "svelte-2jlx4b"),
        attr(r, "class", "svelte-2jlx4b"),
        toggle_class(r, "selected", $[10] + 1 == $[1].acc.profilePicture);
    },
    m(F, O) {
      insert(F, r, O),
        append(r, p),
        append(r, k),
        x || ((S = listen(r, "click", I)), (x = !0));
    },
    p(F, O) {
      ($ = F),
        O & 1 && !src_url_equal(p.src, (v = $[8])) && attr(p, "src", v),
        O & 2 &&
          toggle_class(r, "selected", $[10] + 1 == $[1].acc.profilePicture);
    },
    d(F) {
      F && detach(r), (x = !1), S();
    },
  };
}
function create_fragment$1H($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U = $[0],
    N = [];
  for (let j = 0; j < U.length; j += 1)
    N[j] = create_each_block$o(get_each_context$o($, U, j));
  return {
    c() {
      (r = element("div")),
        (r.innerHTML = `<h2 class="header">Change Profile Picture</h2> 
  <p class="subheader">Choose one of the following profile pictures:</p>`),
        (p = space()),
        (v = element("div"));
      for (let j = 0; j < N.length; j += 1) N[j].c();
      (k = space()),
        (x = element("div")),
        (S = element("button")),
        (S.textContent = "Custom..."),
        (I = space()),
        (F = element("button")),
        (F.textContent = "Cancel"),
        attr(r, "class", "overlay-head"),
        attr(v, "class", "wrapper svelte-2jlx4b"),
        attr(F, "class", "cancel svelte-2jlx4b"),
        attr(x, "class", "cancel-wrapper svelte-2jlx4b");
    },
    m(j, R) {
      insert(j, r, R), insert(j, p, R), insert(j, v, R);
      for (let q = 0; q < N.length; q += 1) N[q] && N[q].m(v, null);
      insert(j, k, R),
        insert(j, x, R),
        append(x, S),
        append(x, I),
        append(x, F),
        O ||
          ((L = [listen(S, "click", $[4]), listen(F, "click", $[3])]),
          (O = !0));
    },
    p(j, [R]) {
      if (R & 7) {
        U = j[0];
        let q;
        for (q = 0; q < U.length; q += 1) {
          const Q = get_each_context$o(j, U, q);
          N[q]
            ? N[q].p(Q, R)
            : ((N[q] = create_each_block$o(Q)), N[q].c(), N[q].m(v, null));
        }
        for (; q < N.length; q += 1) N[q].d(1);
        N.length = U.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(j) {
      j && detach(r),
        j && detach(p),
        j && detach(v),
        destroy_each(N, j),
        j && detach(k),
        j && detach(x),
        (O = !1),
        run_all(L);
    },
  };
}
function instance$1u($, r, p) {
  let v;
  component_subscribe($, UserData, (U) => p(1, (v = U)));
  let k = [],
    { id: x } = r,
    { app: S } = r;
  onMount(() => {
    p(0, (k = Object.values(ProfilePictures)));
  });
  function I(U) {
    set_store_value(UserData, (v.acc.profilePicture = U), v), F();
  }
  function F() {
    hideOverlay(x, S.id);
  }
  function O() {
    showOverlay("customPfp", "SettingsApp");
  }
  const L = (U) => I(U + 1);
  return (
    ($.$$set = (U) => {
      "id" in U && p(5, (x = U.id)), "app" in U && p(6, (S = U.app));
    }),
    [k, v, I, F, O, x, S, L]
  );
}
class ProfilePicture extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1u, create_fragment$1H, safe_not_equal, {
        id: 5,
        app: 6,
      });
  }
}
const customPfp = "";
function create_fragment$1G($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K, V, H;
  return (
    (v = new ProfilePicture$1({
      props: { src: $[1] ? $[0] : pfp, height: 50 },
    })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          create_component(v.$$.fragment),
          (k = space()),
          (x = element("div")),
          (S = element("p")),
          (S.textContent = "Enter the URL to a custom profile picture:"),
          (I = space()),
          (F = element("input")),
          (O = space()),
          (L = element("div")),
          (U = element("div")),
          (N = element("button")),
          (N.textContent = "Cancel"),
          (j = space()),
          (R = element("button")),
          (q = text("Apply")),
          attr(F, "type", "url"),
          attr(F, "placeholder", "https://example.com/image.png"),
          (R.disabled = Q = !$[0] || !$[1]),
          attr(L, "class", "apply"),
          attr(x, "class", "field"),
          attr(r, "class", "custompfp-wrapper");
      },
      m(G, Y) {
        insert(G, r, Y),
          append(r, p),
          mount_component(v, p, null),
          append(r, k),
          append(r, x),
          append(x, S),
          append(x, I),
          append(x, F),
          set_input_value(F, $[0]),
          append(x, O),
          append(x, L),
          append(L, U),
          append(U, N),
          append(U, j),
          append(U, R),
          append(R, q),
          (K = !0),
          V ||
            ((H = [
              listen(F, "input", $[5]),
              listen(F, "input", $[2]),
              listen(N, "click", $[4]),
              listen(R, "click", $[3]),
            ]),
            (V = !0));
      },
      p(G, [Y]) {
        const J = {};
        Y & 3 && (J.src = G[1] ? G[0] : pfp),
          v.$set(J),
          Y & 1 && F.value !== G[0] && set_input_value(F, G[0]),
          (!K || (Y & 3 && Q !== (Q = !G[0] || !G[1]))) && (R.disabled = Q);
      },
      i(G) {
        K || (transition_in(v.$$.fragment, G), (K = !0));
      },
      o(G) {
        transition_out(v.$$.fragment, G), (K = !1);
      },
      d(G) {
        G && detach(r), destroy_component(v), (V = !1), run_all(H);
      },
    }
  );
}
async function checkImage$1($) {
  const r = new Image();
  return (
    (r.src = $),
    new Promise((p) => {
      (r.onload = () => p(!0)), (r.onerror = () => p(!1));
    })
  );
}
function instance$1t($, r, p) {
  let v = "",
    k = !1;
  async function x() {
    const O = await checkImage$1(v);
    p(1, (k = O));
  }
  function S() {
    applyCustomPfp(v),
      hideOverlay("customPfp", "SettingsApp"),
      hideOverlay("pfpSel", "SettingsApp");
  }
  function I() {
    hideOverlay("customPfp", "SettingsApp");
  }
  UserData.subscribe((O) => {
    typeof O.acc.profilePicture == "string" && p(0, (v = O.acc.profilePicture)),
      x();
  });
  function F() {
    (v = this.value), p(0, v);
  }
  return [v, k, x, S, I, F];
}
class CustomProfilePicture extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1t, create_fragment$1G, safe_not_equal, {});
  }
}
const ProfilePictureView_svelte_svelte_type_style_lang = "";
function create_fragment$1F($) {
  let r, p, v, k, x, S, I, F, O, L, U;
  return (
    (r = new CloseButton({ props: { id: $[0], app: $[1] } })),
    (x = new ProfilePicture$1({
      props: { src: $[2].acc.profilePicture.toString(), height: 150 },
    })),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          (v = element("div")),
          (k = element("div")),
          create_component(x.$$.fragment),
          (S = space()),
          (I = element("h1")),
          (F = text($[3])),
          (O = space()),
          (L = element("p")),
          (L.textContent = `${
            localStorage.getItem("arcos-server") || location.hostname
          }`),
          attr(I, "class", "svelte-1hdmb0y"),
          attr(L, "class", "hostname svelte-1hdmb0y"),
          attr(k, "class", "flex-stop"),
          attr(v, "class", "center-flex text-center");
      },
      m(N, j) {
        mount_component(r, N, j),
          insert(N, p, j),
          insert(N, v, j),
          append(v, k),
          mount_component(x, k, null),
          append(k, S),
          append(k, I),
          append(I, F),
          append(k, O),
          append(k, L),
          (U = !0);
      },
      p(N, [j]) {
        const R = {};
        j & 1 && (R.id = N[0]), j & 2 && (R.app = N[1]), r.$set(R);
        const q = {};
        j & 4 && (q.src = N[2].acc.profilePicture.toString()),
          x.$set(q),
          (!U || j & 8) && set_data(F, N[3]);
      },
      i(N) {
        U ||
          (transition_in(r.$$.fragment, N),
          transition_in(x.$$.fragment, N),
          (U = !0));
      },
      o(N) {
        transition_out(r.$$.fragment, N),
          transition_out(x.$$.fragment, N),
          (U = !1);
      },
      d(N) {
        destroy_component(r, N),
          N && detach(p),
          N && detach(v),
          destroy_component(x);
      },
    }
  );
}
function instance$1s($, r, p) {
  let v, k;
  component_subscribe($, UserData, (I) => p(2, (v = I))),
    component_subscribe($, UserName, (I) => p(3, (k = I)));
  let { id: x } = r,
    { app: S } = r;
  return (
    ($.$$set = (I) => {
      "id" in I && p(0, (x = I.id)), "app" in I && p(1, (S = I.app));
    }),
    [x, S, v, k]
  );
}
class ProfilePictureView extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1s, create_fragment$1F, safe_not_equal, {
        id: 0,
        app: 1,
      });
  }
}
const udataExplorer = "";
function create_if_block$H($) {
  let r, p, v;
  return {
    c() {
      (r = element("div")),
        (p = text($[1])),
        attr(r, "class", "value"),
        attr(r, "data-type", (v = typeof $[1])),
        attr(r, "data-value", $[1]);
    },
    m(k, x) {
      insert(k, r, x), append(r, p);
    },
    p(k, x) {
      x & 2 && set_data(p, k[1]),
        x & 2 && v !== (v = typeof k[1]) && attr(r, "data-type", v),
        x & 2 && attr(r, "data-value", k[1]);
    },
    d(k) {
      k && detach(r);
    },
  };
}
function create_fragment$1E($) {
  let r,
    p,
    v,
    k,
    x = typeof $[1] != "object" && create_if_block$H($);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = text($[0])),
        (k = space()),
        x && x.c(),
        attr(p, "class", "key"),
        attr(r, "class", "nodeinstance");
    },
    m(S, I) {
      insert(S, r, I),
        append(r, p),
        append(p, v),
        append(r, k),
        x && x.m(r, null);
    },
    p(S, [I]) {
      I & 1 && set_data(v, S[0]),
        typeof S[1] != "object"
          ? x
            ? x.p(S, I)
            : ((x = create_if_block$H(S)), x.c(), x.m(r, null))
          : x && (x.d(1), (x = null));
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r), x && x.d();
    },
  };
}
function instance$1r($, r, p) {
  let { key: v } = r,
    { value: k } = r;
  return (
    ($.$$set = (x) => {
      "key" in x && p(0, (v = x.key)), "value" in x && p(1, (k = x.value));
    }),
    [v, k]
  );
}
class Node extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1r, create_fragment$1E, safe_not_equal, {
        key: 0,
        value: 1,
      });
  }
}
function get_each_context$n($, r, p) {
  const v = $.slice();
  return (v[3] = r[p]), v;
}
function create_if_block$G($) {
  let r,
    p,
    v = Object.entries($[1]),
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$n(get_each_context$n($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 2) {
        v = Object.entries(S[1]);
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$n(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$n(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_each_block$n($) {
  let r, p;
  return (
    (r = new Branch_1({ props: { key: $[3][0], value: $[3][1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 2 && (x.key = v[3][0]), k & 2 && (x.value = v[3][1]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1D($) {
  let r, p, v, k;
  p = new Node({ props: { key: $[0], value: $[1] } });
  let x = typeof $[1] == "object" && create_if_block$G($);
  return {
    c() {
      (r = element("div")),
        create_component(p.$$.fragment),
        (v = space()),
        x && x.c(),
        toggle_class(r, "indent", !$[2]);
    },
    m(S, I) {
      insert(S, r, I),
        mount_component(p, r, null),
        append(r, v),
        x && x.m(r, null),
        (k = !0);
    },
    p(S, [I]) {
      const F = {};
      I & 1 && (F.key = S[0]),
        I & 2 && (F.value = S[1]),
        p.$set(F),
        typeof S[1] == "object"
          ? x
            ? (x.p(S, I), I & 2 && transition_in(x, 1))
            : ((x = create_if_block$G(S)),
              x.c(),
              transition_in(x, 1),
              x.m(r, null))
          : x &&
            (group_outros(),
            transition_out(x, 1, 1, () => {
              x = null;
            }),
            check_outros()),
        (!k || I & 4) && toggle_class(r, "indent", !S[2]);
    },
    i(S) {
      k || (transition_in(p.$$.fragment, S), transition_in(x), (k = !0));
    },
    o(S) {
      transition_out(p.$$.fragment, S), transition_out(x), (k = !1);
    },
    d(S) {
      S && detach(r), destroy_component(p), x && x.d();
    },
  };
}
function instance$1q($, r, p) {
  let { key: v } = r,
    { value: k } = r,
    { top: x = !1 } = r;
  return (
    ($.$$set = (S) => {
      "key" in S && p(0, (v = S.key)),
        "value" in S && p(1, (k = S.value)),
        "top" in S && p(2, (x = S.top));
    }),
    [v, k, x]
  );
}
class Branch_1 extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1q, create_fragment$1D, safe_not_equal, {
        key: 0,
        value: 1,
        top: 2,
      });
  }
}
function get_each_context$m($, r, p) {
  const v = $.slice();
  return (v[4] = r[p]), v;
}
function create_if_block$F($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L = Object.entries($[2]),
    U = [];
  for (let j = 0; j < L.length; j += 1)
    U[j] = create_each_block$m(get_each_context$m($, L, j));
  const N = (j) =>
    transition_out(U[j], 1, 1, () => {
      U[j] = null;
    });
  return {
    c() {
      (r = element("div")),
        (p = element("h2")),
        (v = text("User Data for ")),
        (k = text($[3])),
        (x = space()),
        (S = element("p")),
        (S.textContent = "Below is a tree view of your user data:"),
        (I = space());
      for (let j = 0; j < U.length; j += 1) U[j].c();
      (F = empty()),
        attr(p, "class", "header"),
        attr(S, "class", "subheader"),
        attr(r, "class", "overlay-head");
    },
    m(j, R) {
      insert(j, r, R),
        append(r, p),
        append(p, v),
        append(p, k),
        append(r, x),
        append(r, S),
        insert(j, I, R);
      for (let q = 0; q < U.length; q += 1) U[q] && U[q].m(j, R);
      insert(j, F, R), (O = !0);
    },
    p(j, R) {
      if (((!O || R & 8) && set_data(k, j[3]), R & 4)) {
        L = Object.entries(j[2]);
        let q;
        for (q = 0; q < L.length; q += 1) {
          const Q = get_each_context$m(j, L, q);
          U[q]
            ? (U[q].p(Q, R), transition_in(U[q], 1))
            : ((U[q] = create_each_block$m(Q)),
              U[q].c(),
              transition_in(U[q], 1),
              U[q].m(F.parentNode, F));
        }
        for (group_outros(), q = L.length; q < U.length; q += 1) N(q);
        check_outros();
      }
    },
    i(j) {
      if (!O) {
        for (let R = 0; R < L.length; R += 1) transition_in(U[R]);
        O = !0;
      }
    },
    o(j) {
      U = U.filter(Boolean);
      for (let R = 0; R < U.length; R += 1) transition_out(U[R]);
      O = !1;
    },
    d(j) {
      j && detach(r), j && detach(I), destroy_each(U, j), j && detach(F);
    },
  };
}
function create_else_block$e($) {
  let r, p;
  return (
    (r = new Node({ props: { key: $[4][0], value: $[4][1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 4 && (x.key = v[4][0]), k & 4 && (x.value = v[4][1]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_1$e($) {
  let r, p;
  return (
    (r = new Branch_1({ props: { key: $[4][0], value: $[4][1], top: !0 } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 4 && (x.key = v[4][0]), k & 4 && (x.value = v[4][1]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$m($) {
  let r, p, v, k, x;
  const S = [create_if_block_1$e, create_else_block$e],
    I = [];
  function F(O, L) {
    return typeof O[4][1] == "object" ? 0 : 1;
  }
  return (
    (p = F($)),
    (v = I[p] = S[p]($)),
    {
      c() {
        (r = element("div")),
          v.c(),
          (k = space()),
          attr(r, "class", "toplevel-item");
      },
      m(O, L) {
        insert(O, r, L), I[p].m(r, null), append(r, k), (x = !0);
      },
      p(O, L) {
        let U = p;
        (p = F(O)),
          p === U
            ? I[p].p(O, L)
            : (group_outros(),
              transition_out(I[U], 1, 1, () => {
                I[U] = null;
              }),
              check_outros(),
              (v = I[p]),
              v ? v.p(O, L) : ((v = I[p] = S[p](O)), v.c()),
              transition_in(v, 1),
              v.m(r, k));
      },
      i(O) {
        x || (transition_in(v), (x = !0));
      },
      o(O) {
        transition_out(v), (x = !1);
      },
      d(O) {
        O && detach(r), I[p].d();
      },
    }
  );
}
function create_fragment$1C($) {
  let r, p, v, k;
  r = new CloseButton({ props: { app: $[0], id: $[1] } });
  let x = $[2] && create_if_block$F($);
  return {
    c() {
      create_component(r.$$.fragment), (p = space()), x && x.c(), (v = empty());
    },
    m(S, I) {
      mount_component(r, S, I),
        insert(S, p, I),
        x && x.m(S, I),
        insert(S, v, I),
        (k = !0);
    },
    p(S, [I]) {
      const F = {};
      I & 1 && (F.app = S[0]),
        I & 2 && (F.id = S[1]),
        r.$set(F),
        S[2]
          ? x
            ? (x.p(S, I), I & 4 && transition_in(x, 1))
            : ((x = create_if_block$F(S)),
              x.c(),
              transition_in(x, 1),
              x.m(v.parentNode, v))
          : x &&
            (group_outros(),
            transition_out(x, 1, 1, () => {
              x = null;
            }),
            check_outros());
    },
    i(S) {
      k || (transition_in(r.$$.fragment, S), transition_in(x), (k = !0));
    },
    o(S) {
      transition_out(r.$$.fragment, S), transition_out(x), (k = !1);
    },
    d(S) {
      destroy_component(r, S), S && detach(p), x && x.d(S), S && detach(v);
    },
  };
}
function instance$1p($, r, p) {
  let v, k;
  component_subscribe($, UserData, (I) => p(2, (v = I))),
    component_subscribe($, UserName, (I) => p(3, (k = I)));
  let { app: x } = r,
    { id: S } = r;
  return (
    ($.$$set = (I) => {
      "app" in I && p(0, (x = I.app)), "id" in I && p(1, (S = I.id));
    }),
    [x, S, v, k]
  );
}
class UserDataExplorer extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1p, create_fragment$1C, safe_not_equal, {
        app: 0,
        id: 1,
      });
  }
}
const passwordIcon = "./assets/password-d04179f1.svg",
  changePswd = "";
function create_fragment$1B($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K, V, H, G, Y, J, Z;
  return (
    (v = new ProfilePicture$1({ props: { src: $[0], height: 50 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          create_component(v.$$.fragment),
          (k = space()),
          (x = element("div")),
          (S = element("p")),
          (S.textContent = "Fill out this form to change your password:"),
          (I = space()),
          (F = element("input")),
          (O = space()),
          (L = element("input")),
          (U = space()),
          (N = element("input")),
          (j = space()),
          (R = element("div")),
          (q = element("div")),
          (Q = element("button")),
          (Q.textContent = "Cancel"),
          (K = space()),
          (V = element("button")),
          (H = text("Change")),
          attr(F, "type", "password"),
          attr(F, "name", "current"),
          attr(F, "placeholder", "Current password"),
          attr(L, "type", "password"),
          attr(L, "name", "current"),
          attr(L, "placeholder", "New password"),
          attr(N, "type", "password"),
          attr(N, "name", "current"),
          attr(N, "placeholder", "Confirm new password"),
          (V.disabled = G = $[2] != $[3] || !$[2] || !$[3]),
          attr(R, "class", "apply"),
          attr(x, "class", "field"),
          attr(r, "class", "changepswd-wrapper");
      },
      m(X, ee) {
        insert(X, r, ee),
          append(r, p),
          mount_component(v, p, null),
          append(r, k),
          append(r, x),
          append(x, S),
          append(x, I),
          append(x, F),
          set_input_value(F, $[1]),
          append(x, O),
          append(x, L),
          set_input_value(L, $[2]),
          append(x, U),
          append(x, N),
          set_input_value(N, $[3]),
          append(x, j),
          append(x, R),
          append(R, q),
          append(q, Q),
          append(q, K),
          append(q, V),
          append(V, H),
          (Y = !0),
          J ||
            ((Z = [
              listen(F, "input", $[8]),
              listen(L, "input", $[9]),
              listen(N, "input", $[10]),
              listen(Q, "click", $[4]),
              listen(V, "click", $[5]),
            ]),
            (J = !0));
      },
      p(X, [ee]) {
        const te = {};
        ee & 1 && (te.src = X[0]),
          v.$set(te),
          ee & 2 && F.value !== X[1] && set_input_value(F, X[1]),
          ee & 4 && L.value !== X[2] && set_input_value(L, X[2]),
          ee & 8 && N.value !== X[3] && set_input_value(N, X[3]),
          (!Y || (ee & 12 && G !== (G = X[2] != X[3] || !X[2] || !X[3]))) &&
            (V.disabled = G);
      },
      i(X) {
        Y || (transition_in(v.$$.fragment, X), (Y = !0));
      },
      o(X) {
        transition_out(v.$$.fragment, X), (Y = !1);
      },
      d(X) {
        X && detach(r), destroy_component(v), (J = !1), run_all(Z);
      },
    }
  );
}
function instance$1o($, r, p) {
  let v;
  component_subscribe($, UserName, (K) => p(11, (v = K)));
  let k = "",
    { id: x } = r,
    { app: S } = r,
    I = "",
    F = "",
    O = "";
  UserData.subscribe((K) => {
    p(0, (k = getProfilePicture(K.acc.profilePicture)));
  });
  function L() {
    hideOverlay(x, S.id);
  }
  function U() {
    j(), L();
  }
  async function N() {
    if (!(await changePassword(v, I, F, O)))
      return createOverlayableError(
        {
          title: "Couldn't change password",
          message:
            "An error occured while changing your password. Please make sure the entered information is correct, and then try again.",
          buttons: [{ caption: "OK", action: j }],
          image: passwordIcon,
        },
        S.id
      );
    createOverlayableError(
      {
        title: "Password changed.",
        message: "Your password has been updated successfully.",
        buttons: [{ caption: "OK", action: U }],
        image: passwordIcon,
      },
      S.id
    );
  }
  function j() {
    p(1, (I = "")), p(2, (F = "")), p(3, (O = ""));
  }
  function R() {
    (I = this.value), p(1, I);
  }
  function q() {
    (F = this.value), p(2, F);
  }
  function Q() {
    (O = this.value), p(3, O);
  }
  return (
    ($.$$set = (K) => {
      "id" in K && p(6, (x = K.id)), "app" in K && p(7, (S = K.app));
    }),
    [k, I, F, O, L, N, x, S, R, q, Q]
  );
}
class ChangePassword extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1o, create_fragment$1B, safe_not_equal, {
        id: 6,
        app: 7,
      });
  }
}
const changeUname = "";
function create_fragment$1A($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K, V, H, G, Y, J;
  return (
    (v = new ProfilePicture$1({ props: { src: $[0], height: 50 } })),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          create_component(v.$$.fragment),
          (k = space()),
          (x = element("div")),
          (S = element("p")),
          (I = text($[2])),
          (F = space()),
          (O = element("p")),
          (O.textContent = "Enter a new username"),
          (L = space()),
          (U = element("input")),
          (N = space()),
          (j = element("div")),
          (R = element("div")),
          (q = element("button")),
          (q.textContent = "Cancel"),
          (Q = space()),
          (K = element("button")),
          (V = text("Change")),
          attr(S, "class", "username"),
          attr(U, "type", "text"),
          attr(U, "name", "current"),
          attr(U, "placeholder", "New username"),
          (K.disabled = H = !$[1]),
          attr(j, "class", "apply"),
          attr(x, "class", "field"),
          attr(r, "class", "changename-wrapper");
      },
      m(Z, X) {
        insert(Z, r, X),
          append(r, p),
          mount_component(v, p, null),
          append(r, k),
          append(r, x),
          append(x, S),
          append(S, I),
          append(x, F),
          append(x, O),
          append(x, L),
          append(x, U),
          set_input_value(U, $[1]),
          append(x, N),
          append(x, j),
          append(j, R),
          append(R, q),
          append(R, Q),
          append(R, K),
          append(K, V),
          (G = !0),
          Y ||
            ((J = [
              listen(U, "input", $[7]),
              listen(q, "click", $[4]),
              listen(K, "click", $[3]),
            ]),
            (Y = !0));
      },
      p(Z, [X]) {
        const ee = {};
        X & 1 && (ee.src = Z[0]),
          v.$set(ee),
          (!G || X & 4) && set_data(I, Z[2]),
          X & 2 && U.value !== Z[1] && set_input_value(U, Z[1]),
          (!G || (X & 2 && H !== (H = !Z[1]))) && (K.disabled = H);
      },
      i(Z) {
        G || (transition_in(v.$$.fragment, Z), (G = !0));
      },
      o(Z) {
        transition_out(v.$$.fragment, Z), (G = !1);
      },
      d(Z) {
        Z && detach(r), destroy_component(v), (Y = !1), run_all(J);
      },
    }
  );
}
function instance$1n($, r, p) {
  let v;
  component_subscribe($, UserName, (j) => p(2, (v = j)));
  let k = "",
    { id: x } = r,
    { app: S } = r,
    I = "";
  UserData.subscribe((j) => {
    p(0, (k = getProfilePicture(j.acc.profilePicture)));
  });
  async function F() {
    if (!(await changeUsername(v, I)))
      return createOverlayableError(
        {
          title: "Can't rename user",
          message:
            "An error occured while trying to rename your account. Please make sure the information is correct, and then try again.",
          buttons: [{ caption: "OK", action: L }],
          image: usericon,
        },
        "SettingsApp"
      );
    createOverlayableError(
      {
        title: "Username changed.",
        message: "Your username has been updated successfully.",
        buttons: [{ caption: "OK", action: U }],
        image: usericon,
      },
      "SettingsApp"
    );
  }
  function O() {
    hideOverlay(x, S.id);
  }
  function L() {
    p(1, (I = ""));
  }
  function U() {
    L(), O();
  }
  function N() {
    (I = this.value), p(1, I);
  }
  return (
    ($.$$set = (j) => {
      "id" in j && p(5, (x = j.id)), "app" in j && p(6, (S = j.app));
    }),
    [k, I, v, F, O, x, S, N]
  );
}
class ChangeUsername extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1n, create_fragment$1A, safe_not_equal, {
        id: 5,
        app: 6,
      });
  }
}
const changetitlebuttons = "",
  Default_svelte_svelte_type_style_lang = "";
function create_fragment$1z($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j;
  return {
    c() {
      (r = element("button")),
        (p = text("minimize")),
        (k = space()),
        (x = element("button")),
        (S = text("crop_square")),
        (F = space()),
        (O = element("button")),
        (L = text("close")),
        attr(r, "class", "material-icons-round reset svelte-63zn7"),
        (r.disabled = v = !$[0].controls.min || $[1]),
        attr(x, "class", "material-icons-round reset svelte-63zn7"),
        (x.disabled = I = !$[0].controls.max || $[1]),
        attr(O, "class", "material-icons-round reset svelte-63zn7"),
        (O.disabled = U = !$[0].controls.cls || $[1]);
    },
    m(R, q) {
      insert(R, r, q),
        append(r, p),
        insert(R, k, q),
        insert(R, x, q),
        append(x, S),
        insert(R, F, q),
        insert(R, O, q),
        append(O, L),
        N ||
          ((j = [
            listen(r, "click", function () {
              is_function($[2]) && $[2].apply(this, arguments);
            }),
            listen(x, "click", function () {
              is_function($[3]) && $[3].apply(this, arguments);
            }),
            listen(O, "click", function () {
              is_function($[4]) && $[4].apply(this, arguments);
            }),
          ]),
          (N = !0));
    },
    p(R, [q]) {
      ($ = R),
        q & 3 && v !== (v = !$[0].controls.min || $[1]) && (r.disabled = v),
        q & 3 && I !== (I = !$[0].controls.max || $[1]) && (x.disabled = I),
        q & 3 && U !== (U = !$[0].controls.cls || $[1]) && (O.disabled = U);
    },
    i: noop$1,
    o: noop$1,
    d(R) {
      R && detach(r),
        R && detach(k),
        R && detach(x),
        R && detach(F),
        R && detach(O),
        (N = !1),
        run_all(j);
    },
  };
}
function instance$1m($, r, p) {
  let { app: v } = r,
    { isBoot: k } = r,
    { min: x } = r,
    { max: S } = r,
    { cls: I } = r;
  return (
    ($.$$set = (F) => {
      "app" in F && p(0, (v = F.app)),
        "isBoot" in F && p(1, (k = F.isBoot)),
        "min" in F && p(2, (x = F.min)),
        "max" in F && p(3, (S = F.max)),
        "cls" in F && p(4, (I = F.cls));
    }),
    [v, k, x, S, I]
  );
}
class Default extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1m, create_fragment$1z, safe_not_equal, {
        app: 0,
        isBoot: 1,
        min: 2,
        max: 3,
        cls: 4,
      });
  }
}
const Traffic_svelte_svelte_type_style_lang = "";
function create_fragment$1y($) {
  let r, p, v, k, x, S, I, F, O, L;
  return {
    c() {
      (r = element("button")),
        (v = space()),
        (k = element("button")),
        (S = space()),
        (I = element("button")),
        attr(r, "class", "traffic-cls reset svelte-1ti4j67"),
        (r.disabled = p = !$[0].controls.cls || $[1]),
        attr(k, "class", "traffic-min reset svelte-1ti4j67"),
        (k.disabled = x = !$[0].controls.min || $[1]),
        attr(I, "class", "traffic-max reset svelte-1ti4j67"),
        (I.disabled = F = !$[0].controls.max || $[1]);
    },
    m(U, N) {
      insert(U, r, N),
        insert(U, v, N),
        insert(U, k, N),
        insert(U, S, N),
        insert(U, I, N),
        O ||
          ((L = [
            listen(r, "click", function () {
              is_function($[4]) && $[4].apply(this, arguments);
            }),
            listen(k, "click", function () {
              is_function($[2]) && $[2].apply(this, arguments);
            }),
            listen(I, "click", function () {
              is_function($[3]) && $[3].apply(this, arguments);
            }),
          ]),
          (O = !0));
    },
    p(U, [N]) {
      ($ = U),
        N & 3 && p !== (p = !$[0].controls.cls || $[1]) && (r.disabled = p),
        N & 3 && x !== (x = !$[0].controls.min || $[1]) && (k.disabled = x),
        N & 3 && F !== (F = !$[0].controls.max || $[1]) && (I.disabled = F);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r),
        U && detach(v),
        U && detach(k),
        U && detach(S),
        U && detach(I),
        (O = !1),
        run_all(L);
    },
  };
}
function instance$1l($, r, p) {
  let { app: v } = r,
    { isBoot: k } = r,
    { min: x } = r,
    { max: S } = r,
    { cls: I } = r;
  return (
    ($.$$set = (F) => {
      "app" in F && p(0, (v = F.app)),
        "isBoot" in F && p(1, (k = F.isBoot)),
        "min" in F && p(2, (x = F.min)),
        "max" in F && p(3, (S = F.max)),
        "cls" in F && p(4, (I = F.cls));
    }),
    [v, k, x, S, I]
  );
}
class Traffic extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1l, create_fragment$1y, safe_not_equal, {
        app: 0,
        isBoot: 1,
        min: 2,
        max: 3,
        cls: 4,
      });
  }
}
const OG_svelte_svelte_type_style_lang = "";
function create_fragment$1x($) {
  let r, p, v, k, x, S, I, F, O;
  return {
    c() {
      (r = element("button")),
        (p = text("🗕")),
        (k = space()),
        (x = element("button")),
        (S = text("✖")),
        attr(r, "class", "reset svelte-1f14mwt"),
        (r.disabled = v = $[1] || !$[0].controls.min),
        attr(x, "class", "reset close svelte-1f14mwt"),
        (x.disabled = I = $[1] || !$[0].controls.cls);
    },
    m(L, U) {
      insert(L, r, U),
        append(r, p),
        insert(L, k, U),
        insert(L, x, U),
        append(x, S),
        F ||
          ((O = [
            listen(r, "click", function () {
              is_function($[2]) && $[2].apply(this, arguments);
            }),
            listen(x, "click", function () {
              is_function($[3]) && $[3].apply(this, arguments);
            }),
          ]),
          (F = !0));
    },
    p(L, [U]) {
      ($ = L),
        U & 3 && v !== (v = $[1] || !$[0].controls.min) && (r.disabled = v),
        U & 3 && I !== (I = $[1] || !$[0].controls.cls) && (x.disabled = I);
    },
    i: noop$1,
    o: noop$1,
    d(L) {
      L && detach(r), L && detach(k), L && detach(x), (F = !1), run_all(O);
    },
  };
}
function instance$1k($, r, p) {
  let { app: v } = r,
    { isBoot: k } = r,
    { min: x } = r,
    { cls: S } = r;
  return (
    ($.$$set = (I) => {
      "app" in I && p(0, (v = I.app)),
        "isBoot" in I && p(1, (k = I.isBoot)),
        "min" in I && p(2, (x = I.min)),
        "cls" in I && p(3, (S = I.cls));
    }),
    [v, k, x, S]
  );
}
class OG extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1k, create_fragment$1x, safe_not_equal, {
        app: 0,
        isBoot: 1,
        min: 2,
        cls: 3,
      });
  }
}
const titlebarButtons = {
    default: { caption: "Default", author: "ArcOS Team", content: Default },
    traffic: { caption: "Traffic Lights", author: "Apple", content: Traffic },
    og: { caption: "O.G.", author: "WebOSv3 Team", content: OG },
  },
  DummyApp = {
    info: {
      name: "Dummy",
      description: "I'm a dummy!",
      builtin: !0,
      version: "1.0.0",
      author: "Robots",
      icon: logo$a,
    },
    pos: { x: 0, y: 0 },
    minSize: { w: 0, h: 0 },
    maxSize: { w: 0, h: 0 },
    size: { w: 0, h: 0 },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { fll: !1, max: !1, min: !1 },
    },
    glass: !1,
    content: null,
  };
function create_fragment$1w($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F = $[0].caption + "",
    O,
    L,
    U,
    N,
    j = $[0].author + "",
    R,
    q,
    Q,
    K = $[2].sh.window.buttons == $[1] ? "Applied" : "Apply",
    V,
    H,
    G,
    Y,
    J;
  var Z = $[0].content;
  function X(ee) {
    return { props: { app: DummyApp } };
  }
  return (
    Z && (k = construct_svelte_component(Z, X())),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          (v = element("div")),
          k && create_component(k.$$.fragment),
          (x = space()),
          (S = element("div")),
          (I = element("p")),
          (O = text(F)),
          (L = space()),
          (U = element("p")),
          (N = text("By: ")),
          (R = text(j)),
          (q = space()),
          (Q = element("button")),
          (V = text(K)),
          attr(v, "class", "tb"),
          attr(p, "class", "preview"),
          attr(I, "class", "title"),
          attr(U, "class", "author"),
          attr(S, "class", "details"),
          attr(Q, "class", "apply"),
          (Q.disabled = H = $[2].sh.window.buttons == $[1]),
          attr(r, "class", "item");
      },
      m(ee, te) {
        insert(ee, r, te),
          append(r, p),
          append(p, v),
          k && mount_component(k, v, null),
          append(r, x),
          append(r, S),
          append(S, I),
          append(I, O),
          append(S, L),
          append(S, U),
          append(U, N),
          append(U, R),
          append(r, q),
          append(r, Q),
          append(Q, V),
          (G = !0),
          Y || ((J = listen(Q, "click", $[3])), (Y = !0));
      },
      p(ee, [te]) {
        if (te & 1 && Z !== (Z = ee[0].content)) {
          if (k) {
            group_outros();
            const ie = k;
            transition_out(ie.$$.fragment, 1, 0, () => {
              destroy_component(ie, 1);
            }),
              check_outros();
          }
          Z
            ? ((k = construct_svelte_component(Z, X())),
              create_component(k.$$.fragment),
              transition_in(k.$$.fragment, 1),
              mount_component(k, v, null))
            : (k = null);
        }
        (!G || te & 1) && F !== (F = ee[0].caption + "") && set_data(O, F),
          (!G || te & 1) && j !== (j = ee[0].author + "") && set_data(R, j),
          (!G || te & 6) &&
            K !==
              (K = ee[2].sh.window.buttons == ee[1] ? "Applied" : "Apply") &&
            set_data(V, K),
          (!G || (te & 6 && H !== (H = ee[2].sh.window.buttons == ee[1]))) &&
            (Q.disabled = H);
      },
      i(ee) {
        G || (k && transition_in(k.$$.fragment, ee), (G = !0));
      },
      o(ee) {
        k && transition_out(k.$$.fragment, ee), (G = !1);
      },
      d(ee) {
        ee && detach(r), k && destroy_component(k), (Y = !1), J();
      },
    }
  );
}
function instance$1j($, r, p) {
  let v;
  component_subscribe($, UserData, (I) => p(2, (v = I)));
  let { data: k } = r,
    { id: x } = r;
  function S() {
    set_store_value(UserData, (v.sh.window.buttons = x), v);
  }
  return (
    ($.$$set = (I) => {
      "data" in I && p(0, (k = I.data)), "id" in I && p(1, (x = I.id));
    }),
    [k, x, v, S]
  );
}
let Item$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1j, create_fragment$1w, safe_not_equal, {
        data: 0,
        id: 1,
      });
  }
};
function get_each_context$l($, r, p) {
  const v = $.slice();
  return (v[2] = r[p]), v;
}
function create_each_block$l($) {
  let r, p;
  return (
    (r = new Item$1({ props: { id: $[2][0], data: $[2][1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1v($) {
  let r, p, v, k, x, S, I, F;
  r = new CloseButton({ props: { app: $[0], id: $[1] } });
  let O = Object.entries(titlebarButtons),
    L = [];
  for (let N = 0; N < O.length; N += 1)
    L[N] = create_each_block$l(get_each_context$l($, O, N));
  const U = (N) =>
    transition_out(L[N], 1, 1, () => {
      L[N] = null;
    });
  return {
    c() {
      create_component(r.$$.fragment),
        (p = space()),
        (v = element("h3")),
        (v.textContent = "Titlebar buttons"),
        (k = space()),
        (x = element("p")),
        (x.textContent = "Choose one of the titlebar button styles:"),
        (S = space());
      for (let N = 0; N < L.length; N += 1) L[N].c();
      (I = empty()), attr(v, "class", "header"), attr(x, "class", "subheader");
    },
    m(N, j) {
      mount_component(r, N, j),
        insert(N, p, j),
        insert(N, v, j),
        insert(N, k, j),
        insert(N, x, j),
        insert(N, S, j);
      for (let R = 0; R < L.length; R += 1) L[R] && L[R].m(N, j);
      insert(N, I, j), (F = !0);
    },
    p(N, [j]) {
      const R = {};
      if ((j & 1 && (R.app = N[0]), j & 2 && (R.id = N[1]), r.$set(R), j & 0)) {
        O = Object.entries(titlebarButtons);
        let q;
        for (q = 0; q < O.length; q += 1) {
          const Q = get_each_context$l(N, O, q);
          L[q]
            ? (L[q].p(Q, j), transition_in(L[q], 1))
            : ((L[q] = create_each_block$l(Q)),
              L[q].c(),
              transition_in(L[q], 1),
              L[q].m(I.parentNode, I));
        }
        for (group_outros(), q = O.length; q < L.length; q += 1) U(q);
        check_outros();
      }
    },
    i(N) {
      if (!F) {
        transition_in(r.$$.fragment, N);
        for (let j = 0; j < O.length; j += 1) transition_in(L[j]);
        F = !0;
      }
    },
    o(N) {
      transition_out(r.$$.fragment, N), (L = L.filter(Boolean));
      for (let j = 0; j < L.length; j += 1) transition_out(L[j]);
      F = !1;
    },
    d(N) {
      destroy_component(r, N),
        N && detach(p),
        N && detach(v),
        N && detach(k),
        N && detach(x),
        N && detach(S),
        destroy_each(L, N),
        N && detach(I);
    },
  };
}
function instance$1i($, r, p) {
  let { app: v } = r,
    { id: k } = r;
  return (
    ($.$$set = (x) => {
      "app" in x && p(0, (v = x.app)), "id" in x && p(1, (k = x.id));
    }),
    [v, k]
  );
}
class ChangeTitleButtons extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1i, create_fragment$1v, safe_not_equal, {
        app: 0,
        id: 1,
      });
  }
}
const customWallpaper = "";
function create_fragment$1u($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K, V, H;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (S = element("div")),
        (I = element("p")),
        (I.textContent = "Enter the URL to a custom wallpaper:"),
        (F = space()),
        (O = element("input")),
        (L = space()),
        (U = element("div")),
        (N = element("div")),
        (j = element("button")),
        (j.textContent = "Cancel"),
        (R = space()),
        (q = element("button")),
        (Q = text("Apply")),
        src_url_equal(v.src, (k = logo$1)) || attr(v, "src", k),
        attr(v, "alt", ""),
        attr(O, "type", "url"),
        attr(O, "placeholder", "https://example.com/image.png"),
        (q.disabled = K = !$[1] || !$[0]),
        attr(U, "class", "apply"),
        attr(S, "class", "field"),
        attr(r, "class", "customwallpaper-wrapper");
    },
    m(G, Y) {
      insert(G, r, Y),
        append(r, p),
        append(p, v),
        append(r, x),
        append(r, S),
        append(S, I),
        append(S, F),
        append(S, O),
        set_input_value(O, $[1]),
        append(S, L),
        append(S, U),
        append(U, N),
        append(N, j),
        append(N, R),
        append(N, q),
        append(q, Q),
        V ||
          ((H = [
            listen(O, "input", $[5]),
            listen(O, "input", $[3]),
            listen(j, "click", $[4]),
            listen(q, "click", $[2]),
          ]),
          (V = !0));
    },
    p(G, [Y]) {
      Y & 2 && O.value !== G[1] && set_input_value(O, G[1]),
        Y & 3 && K !== (K = !G[1] || !G[0]) && (q.disabled = K);
    },
    i: noop$1,
    o: noop$1,
    d(G) {
      G && detach(r), (V = !1), run_all(H);
    },
  };
}
async function checkImage($) {
  const r = new Image();
  return (
    (r.src = $),
    new Promise((p) => {
      (r.onload = () => p(!0)), (r.onerror = () => p(!1));
    })
  );
}
function instance$1h($, r, p) {
  let v;
  component_subscribe($, UserData, (L) => p(6, (v = L)));
  let k = !1,
    x;
  function S() {
    set_store_value(UserData, (v.sh.desktop.wallpaper = x), v), F();
  }
  onMount(() => {
    v.sh.desktop.wallpaper.startsWith("http") &&
      p(1, (x = v.sh.desktop.wallpaper));
  });
  async function I() {
    const L = await checkImage(x);
    p(0, (k = L));
  }
  function F() {
    hideOverlay("customWallpaper", "SettingsApp");
  }
  UserData.subscribe((L) => {
    typeof L.sh.desktop.wallpaper == "string" &&
      L.sh.desktop.wallpaper.startsWith("http") &&
      p(1, (x = L.sh.desktop.wallpaper)),
      I();
  });
  function O() {
    (x = this.value), p(1, x);
  }
  return [k, x, S, I, F, O];
}
class CustomWallpaper extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1h, create_fragment$1u, safe_not_equal, {});
  }
}
const savetheme = "";
function create_fragment$1t($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K, V, H;
  return (
    (Q = new Current({})),
    {
      c() {
        (r = element("div")),
          (p = element("h3")),
          (p.textContent = "Save theme"),
          (v = space()),
          (k = element("p")),
          (k.textContent = "Choose a name for your theme:"),
          (x = space()),
          (S = element("input")),
          (I = space()),
          (F = element("div")),
          (O = element("button")),
          (L = text("Save")),
          (N = space()),
          (j = element("button")),
          (j.textContent = "Cancel"),
          (R = space()),
          (q = element("div")),
          create_component(Q.$$.fragment),
          attr(p, "class", "header"),
          attr(S, "type", "text"),
          (O.disabled = U = !$[0]),
          attr(F, "class", "actions"),
          attr(r, "class", "form"),
          attr(q, "class", "desktop-page");
      },
      m(G, Y) {
        insert(G, r, Y),
          append(r, p),
          append(r, v),
          append(r, k),
          append(r, x),
          append(r, S),
          set_input_value(S, $[0]),
          append(r, I),
          append(r, F),
          append(F, O),
          append(O, L),
          append(F, N),
          append(F, j),
          insert(G, R, Y),
          insert(G, q, Y),
          mount_component(Q, q, null),
          (K = !0),
          V ||
            ((H = [
              listen(S, "input", $[3]),
              listen(O, "click", $[2]),
              listen(j, "click", $[1]),
            ]),
            (V = !0));
      },
      p(G, [Y]) {
        Y & 1 && S.value !== G[0] && set_input_value(S, G[0]),
          (!K || (Y & 1 && U !== (U = !G[0]))) && (O.disabled = U);
      },
      i(G) {
        K || (transition_in(Q.$$.fragment, G), (K = !0));
      },
      o(G) {
        transition_out(Q.$$.fragment, G), (K = !1);
      },
      d(G) {
        G && detach(r),
          G && detach(R),
          G && detach(q),
          destroy_component(Q),
          (V = !1),
          run_all(H);
      },
    }
  );
}
function instance$1g($, r, p) {
  let v;
  function k() {
    hideOverlay("saveTheme", "SettingsApp");
  }
  function x() {
    saveCurrentTheme(v), k();
  }
  function S() {
    (v = this.value), p(0, v);
  }
  return [v, k, x, S];
}
class SaveTheme extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1g, create_fragment$1t, safe_not_equal, {});
  }
}
const theme = "./assets/themes-1332e1fc.svg",
  saveToFS = {
    caption: "Save to ArcFS",
    action: async ($, r) => {
      const p = new Blob([r.json], { type: "application/json" });
      await createDirectory("./Themes");
      const v = `${r.name}.arctheme`,
        k = `./Themes/${v}`;
      await writeFile(k, p),
        openWindow("FileManager"),
        await fbClass.goToDirectory("./Themes"),
        setTimeout(() => {
          FileBrowserSelectedFilename.set(v);
        });
    },
    icon: "save",
  },
  SettingsAppContext = {
    "themerenderer-user": [
      {
        caption: "Delete",
        action: ($, r) => {
          createOverlayableError(
            {
              title: "Delete theme?",
              message: "Are you sure you want to delete this theme?",
              image: theme,
              buttons: [
                {
                  caption: "Delete",
                  action() {
                    deleteCustomTheme(r.id);
                  },
                },
                { caption: "Cancel", action() {} },
              ],
            },
            "SettingsApp"
          );
        },
        icon: "delete",
      },
      saveToFS,
    ],
    "themerenderer-system": [saveToFS],
    "accountpage-hostname": [
      {
        caption: "View user data",
        action: () => {
          showOverlay("udataExplorer", "SettingsApp");
        },
        icon: "account_tree",
      },
      {
        caption: "Copy server",
        action: () => {
          navigator.clipboard.writeText(
            localStorage.getItem("arcos-server") || "localhost"
          );
        },
        icon: "copy",
      },
    ],
    "appearance-accentselector": [
      {
        caption: "Copy color code",
        action: ($, r) => {
          navigator.clipboard.writeText(`#${r.hex}`);
        },
        icon: "copy",
      },
    ],
  },
  ProfilePictureOverlays = {
    pfpSel: {
      info: {
        name: "Profile Picture Selector",
        version: "1.0.0",
        author: "ArcOS Team",
      },
      content: ProfilePicture,
      size: { w: 382, h: 410 },
      show: !1,
    },
    customPfp: {
      info: {
        name: "Custom Profile Picture",
        version: "1.0.0",
        author: "ArcOS Team",
      },
      content: CustomProfilePicture,
      size: { w: 350, h: 125 },
      show: !1,
    },
    largePfp: {
      info: {
        name: "View Profile Picture",
        version: "1.0.0",
        author: "ArcOS Team",
      },
      content: ProfilePictureView,
      size: { w: 320, h: 360 },
      show: !1,
    },
    changeTitleButtons: {
      info: {
        name: "Change Titlebar Buttons",
        version: "1.0.0",
        author: "ArcOS Team",
      },
      content: ChangeTitleButtons,
      size: { w: 400, h: 300 },
      show: !1,
    },
  },
  AccountPageOverlays = {
    udataExplorer: {
      info: {
        name: "User Data Explorer",
        version: "1.0.0",
        author: "ArcOS Team",
      },
      content: UserDataExplorer,
      size: { w: 550, h: 400 },
      show: !1,
    },
    changePswd: {
      info: { name: "Change Password", version: "1.0.0", author: "ArcOS Team" },
      content: ChangePassword,
      size: { w: 370, h: 195 },
      show: !1,
    },
    changeUsername: {
      info: { name: "Change Username", version: "1.0.0", author: "ArcOS Team" },
      content: ChangeUsername,
      size: { w: 370, h: 155 },
      show: !1,
    },
  },
  DesktopOverlays = {
    customWallpaper: {
      info: {
        name: "Custom Wallpaper",
        version: "1.0.0",
        author: "ArcOS Team",
      },
      content: CustomWallpaper,
      size: { w: 370, h: 118 },
      show: !1,
    },
  },
  ThemeOverlays = {
    saveTheme: {
      info: { name: "Save Theme", version: "1.0.0", author: "ArcOS Team" },
      content: SaveTheme,
      size: { w: 450, h: 170 },
      show: !1,
    },
  },
  SettingsApp = {
    info: {
      name: "System Settings",
      description: "Change the way ArcOS works",
      builtin: !0,
      version: "4.0.0",
      author: "ArcOS Team",
      icon: logo$2,
    },
    size: { w: 730, h: 500 },
    pos: { x: 30, y: 40 },
    minSize: { w: 730, h: 500 },
    maxSize: { w: 1100, h: 600 },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: SettingsApp$1,
    glass: !0,
    overlays: {
      ...ProfilePictureOverlays,
      ...AccountPageOverlays,
      ...DesktopOverlays,
      ...ThemeOverlays,
    },
    events: {
      close() {
        currentSettingsPage.set(SettingsPages[0]);
      },
      open() {
        currentSettingsPage.set(SettingsPages[0]);
      },
    },
    contextMenu: SettingsAppContext,
  },
  actioncenter$1 = "";
function get_each_context$k($, r, p) {
  const v = $.slice();
  return (v[3] = r[p]), v;
}
function create_else_block$d($) {
  let r,
    p = $[0][1].icon + "",
    v;
  return {
    c() {
      (r = element("span")),
        (v = text(p)),
        attr(r, "class", "material-icons-round");
    },
    m(k, x) {
      insert(k, r, x), append(r, v);
    },
    p(k, x) {
      x & 1 && p !== (p = k[0][1].icon + "") && set_data(v, p);
    },
    d(k) {
      k && detach(r);
    },
  };
}
function create_if_block$E($) {
  let r, p, v;
  return {
    c() {
      (r = element("img")),
        src_url_equal(r.src, (p = $[0][1].image)) || attr(r, "src", p),
        attr(r, "alt", (v = $[0][1].title));
    },
    m(k, x) {
      insert(k, r, x);
    },
    p(k, x) {
      x & 1 && !src_url_equal(r.src, (p = k[0][1].image)) && attr(r, "src", p),
        x & 1 && v !== (v = k[0][1].title) && attr(r, "alt", v);
    },
    d(k) {
      k && detach(r);
    },
  };
}
function create_each_block$k($) {
  let r,
    p = $[3].caption + "",
    v,
    k,
    x;
  return {
    c() {
      (r = element("button")), (v = text(p));
    },
    m(S, I) {
      insert(S, r, I),
        append(r, v),
        k ||
          ((x = listen(r, "click", function () {
            is_function($[2]($[3].action)) &&
              $[2]($[3].action).apply(this, arguments);
          })),
          (k = !0));
    },
    p(S, I) {
      ($ = S), I & 1 && p !== (p = $[3].caption + "") && set_data(v, p);
    },
    d(S) {
      S && detach(r), (k = !1), x();
    },
  };
}
function create_fragment$1s($) {
  let r,
    p,
    v,
    k = $[0][1].title + "",
    x,
    S,
    I,
    F,
    O,
    L = $[0][1].message + "",
    U,
    N,
    j,
    R,
    q;
  function Q(Y, J) {
    return Y[0][1].image ? create_if_block$E : create_else_block$d;
  }
  let K = Q($),
    V = K($),
    H = $[0][1].buttons,
    G = [];
  for (let Y = 0; Y < H.length; Y += 1)
    G[Y] = create_each_block$k(get_each_context$k($, H, Y));
  return {
    c() {
      (r = element("div")),
        (p = element("p")),
        V.c(),
        (v = space()),
        (x = text(k)),
        (S = space()),
        (I = element("button")),
        (I.textContent = "close"),
        (F = space()),
        (O = element("p")),
        (U = space()),
        (N = element("div")),
        (j = element("div"));
      for (let Y = 0; Y < G.length; Y += 1) G[Y].c();
      attr(I, "class", "close material-icons-round"),
        attr(p, "class", "title"),
        attr(O, "class", "content"),
        attr(j, "class", "inner"),
        attr(N, "class", "buttons"),
        attr(r, "class", "notification ac");
    },
    m(Y, J) {
      insert(Y, r, J),
        append(r, p),
        V.m(p, null),
        append(p, v),
        append(p, x),
        append(p, S),
        append(p, I),
        append(r, F),
        append(r, O),
        (O.innerHTML = L),
        append(r, U),
        append(r, N),
        append(N, j);
      for (let Z = 0; Z < G.length; Z += 1) G[Z] && G[Z].m(j, null);
      R || ((q = listen(I, "click", $[1])), (R = !0));
    },
    p(Y, [J]) {
      if (
        (K === (K = Q(Y)) && V
          ? V.p(Y, J)
          : (V.d(1), (V = K(Y)), V && (V.c(), V.m(p, v))),
        J & 1 && k !== (k = Y[0][1].title + "") && set_data(x, k),
        J & 1 && L !== (L = Y[0][1].message + "") && (O.innerHTML = L),
        J & 5)
      ) {
        H = Y[0][1].buttons;
        let Z;
        for (Z = 0; Z < H.length; Z += 1) {
          const X = get_each_context$k(Y, H, Z);
          G[Z]
            ? G[Z].p(X, J)
            : ((G[Z] = create_each_block$k(X)), G[Z].c(), G[Z].m(j, null));
        }
        for (; Z < G.length; Z += 1) G[Z].d(1);
        G.length = H.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(Y) {
      Y && detach(r), V.d(), destroy_each(G, Y), (R = !1), q();
    },
  };
}
function instance$1f($, r, p) {
  let { notification: v } = r;
  function k() {
    deleteNotification(v[0]), CurrentNotification.set(null);
  }
  function x(S) {
    return () => {
      S(), k(), ActionCenterOpened.set(!1);
    };
  }
  return (
    ($.$$set = (S) => {
      "notification" in S && p(0, (v = S.notification));
    }),
    [v, k, x]
  );
}
class Notification extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1f, create_fragment$1s, safe_not_equal, {
        notification: 0,
      });
  }
}
function get_each_context$j($, r, p) {
  const v = $.slice();
  return (v[1] = r[p]), v;
}
function create_each_block$j($) {
  let r, p;
  return (
    (r = new Notification({ props: { notification: $[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.notification = v[1]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$D($) {
  let r;
  return {
    c() {
      (r = element("p")),
        (r.textContent = "You have no notifications"),
        attr(r, "class", "none");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$1r($) {
  let r,
    p,
    v = Object.entries($[0]).length == 0,
    k,
    x = Object.entries($[0]),
    S = [];
  for (let O = 0; O < x.length; O += 1)
    S[O] = create_each_block$j(get_each_context$j($, x, O));
  const I = (O) =>
    transition_out(S[O], 1, 1, () => {
      S[O] = null;
    });
  let F = v && create_if_block$D();
  return {
    c() {
      r = element("div");
      for (let O = 0; O < S.length; O += 1) S[O].c();
      (p = space()), F && F.c(), attr(r, "class", "notifications");
    },
    m(O, L) {
      insert(O, r, L);
      for (let U = 0; U < S.length; U += 1) S[U] && S[U].m(r, null);
      append(r, p), F && F.m(r, null), (k = !0);
    },
    p(O, [L]) {
      if (L & 1) {
        x = Object.entries(O[0]);
        let U;
        for (U = 0; U < x.length; U += 1) {
          const N = get_each_context$j(O, x, U);
          S[U]
            ? (S[U].p(N, L), transition_in(S[U], 1))
            : ((S[U] = create_each_block$j(N)),
              S[U].c(),
              transition_in(S[U], 1),
              S[U].m(r, p));
        }
        for (group_outros(), U = x.length; U < S.length; U += 1) I(U);
        check_outros();
      }
      L & 1 && (v = Object.entries(O[0]).length == 0),
        v
          ? F || ((F = create_if_block$D()), F.c(), F.m(r, null))
          : F && (F.d(1), (F = null));
    },
    i(O) {
      if (!k) {
        for (let L = 0; L < x.length; L += 1) transition_in(S[L]);
        k = !0;
      }
    },
    o(O) {
      S = S.filter(Boolean);
      for (let L = 0; L < S.length; L += 1) transition_out(S[L]);
      k = !1;
    },
    d(O) {
      O && detach(r), destroy_each(S, O), F && F.d();
    },
  };
}
function instance$1e($, r, p) {
  let v;
  return component_subscribe($, NotificationStore, (k) => p(0, (v = k))), [v];
}
class Notifications extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1e, create_fragment$1r, safe_not_equal, {});
  }
}
function reloadApps() {
  const $ = get_store_value(WindowStore);
  for (let r = 0; r < $.length; r++) $[r].info.builtin && $.splice(r, 1);
  WindowStore.set($),
    setTimeout(() => {
      importDefault(),
        makeNotification({
          title: "Reloaded",
          message:
            "All applications have been reloaded. Any unsaved information across all apps has been lost.",
          icon: "autorenew",
          buttons: [
            {
              caption: "Open Apps Settings",
              action: () => {
                openByKey("Apps");
              },
            },
          ],
        });
    }, 100);
}
const QuickSettings = [
  {
    icon: "motion_photos_on",
    iconOff: "motion_photos_off",
    getter($) {
      return $.sh.anim;
    },
    setter($) {
      return ($.sh.anim = !$.sh.anim), UserData.set($), $.sh.anim;
    },
    caption: "Animations",
  },
  {
    icon: "blur_on",
    iconOff: "blur_off",
    getter($) {
      return !$.sh.noGlass;
    },
    setter($) {
      return ($.sh.noGlass = !$.sh.noGlass), UserData.set($), !$.sh.noGlass;
    },
    caption: "Transparency",
  },
  {
    icon: "call_to_action",
    iconOff: "call_to_action",
    getter($) {
      return $.sh.taskbar.docked;
    },
    setter($) {
      return (
        ($.sh.taskbar.docked = !$.sh.taskbar.docked),
        UserData.set($),
        $.sh.taskbar.docked
      );
    },
    caption: "Dock Taskbar",
  },
  {
    icon: "dark_mode",
    iconOff: "light_mode",
    getter($) {
      return $.sh.desktop.theme == "dark";
    },
    setter($) {
      const r = $.sh.desktop.theme;
      return (
        ($.sh.desktop.theme = r == "dark" ? "light" : "dark"),
        UserData.set($),
        $.sh.desktop.theme == "dark"
      );
    },
    caption: "Dark mode",
  },
  {
    icon: "",
    iconOff: "",
    getter() {
      return !1;
    },
    setter() {
      return !1;
    },
    caption: "",
  },
  {
    icon: "",
    iconOff: "",
    getter() {
      return !1;
    },
    setter() {
      return !1;
    },
    caption: "",
  },
  {
    icon: "",
    iconOff: "",
    getter() {
      return !1;
    },
    setter() {
      return !1;
    },
    caption: "",
  },
  {
    icon: "search",
    iconOff: "search",
    getter() {
      return !1;
    },
    setter() {
      return showArcFind.set(!0), !1;
    },
    caption: "Search",
  },
  {
    icon: "logout",
    iconOff: "logout",
    getter() {
      return !1;
    },
    setter() {
      return openWindow("Exit"), !1;
    },
    caption: "Exit",
  },
];
function create_fragment$1q($) {
  let r,
    p = ($[1] ? $[0].icon : $[0].iconOff) + "",
    v,
    k,
    x,
    S = $[0].caption + "",
    I,
    F,
    O;
  return {
    c() {
      (r = element("button")),
        (v = text(p)),
        (k = space()),
        (x = element("p")),
        (I = text(S)),
        attr(x, "class", "caption"),
        attr(r, "class", "setting material-icons-round"),
        toggle_class(r, "active", $[1]);
    },
    m(L, U) {
      insert(L, r, U),
        append(r, v),
        append(r, k),
        append(r, x),
        append(x, I),
        F || ((O = listen(r, "click", $[2])), (F = !0));
    },
    p(L, [U]) {
      U & 3 &&
        p !== (p = (L[1] ? L[0].icon : L[0].iconOff) + "") &&
        set_data(v, p),
        U & 1 && S !== (S = L[0].caption + "") && set_data(I, S),
        U & 2 && toggle_class(r, "active", L[1]);
    },
    i: noop$1,
    o: noop$1,
    d(L) {
      L && detach(r), (F = !1), O();
    },
  };
}
function instance$1d($, r, p) {
  let v;
  component_subscribe($, UserData, (I) => p(3, (v = I)));
  let k = !1,
    { setting: x } = r;
  function S() {
    x.setter(v), p(1, (k = x.getter(v)));
  }
  return (
    onMount(() => {
      p(1, (k = x.getter(v)));
    }),
    UserData.subscribe((I) => {
      p(1, (k = x.getter(I)));
    }),
    ($.$$set = (I) => {
      "setting" in I && p(0, (x = I.setting));
    }),
    [x, k, S]
  );
}
class Setting extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$1d, create_fragment$1q, safe_not_equal, {
        setting: 0,
      });
  }
}
function get_each_context$i($, r, p) {
  const v = $.slice();
  return (v[0] = r[p]), v;
}
function create_each_block$i($) {
  let r, p;
  return (
    (r = new Setting({ props: { setting: $[0] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1p($) {
  let r,
    p,
    v = QuickSettings,
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$i(get_each_context$i($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      r = element("div");
      for (let S = 0; S < k.length; S += 1) k[S].c();
      attr(r, "class", "quicksettings");
    },
    m(S, I) {
      insert(S, r, I);
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(r, null);
      p = !0;
    },
    p(S, [I]) {
      if (I & 0) {
        v = QuickSettings;
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$i(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$i(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      S && detach(r), destroy_each(k, S);
    },
  };
}
class QuickSettings_1 extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$1p, safe_not_equal, {});
  }
}
function create_fragment$1o($) {
  let r,
    p,
    v = $[0].sh.noQuickSettings ? "Expand" : "Collapse",
    k,
    x,
    S;
  return {
    c() {
      (r = element("div")),
        (p = element("button")),
        (k = text(v)),
        attr(p, "class", "toggle"),
        attr(r, "class", "quicksettings-toggle");
    },
    m(I, F) {
      insert(I, r, F),
        append(r, p),
        append(p, k),
        x || ((S = listen(p, "click", $[1])), (x = !0));
    },
    p(I, [F]) {
      F & 1 &&
        v !== (v = I[0].sh.noQuickSettings ? "Expand" : "Collapse") &&
        set_data(k, v);
    },
    i: noop$1,
    o: noop$1,
    d(I) {
      I && detach(r), (x = !1), S();
    },
  };
}
function instance$1c($, r, p) {
  let v;
  component_subscribe($, UserData, (x) => p(0, (v = x)));
  function k() {
    set_store_value(
      UserData,
      (v.sh.noQuickSettings = !v.sh.noQuickSettings),
      v
    );
  }
  return [v, k];
}
class QuickSettingsToggle extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1c, create_fragment$1o, safe_not_equal, {});
  }
}
function create_fragment$1n($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q;
  return (
    (F = new Notifications({})),
    (L = new QuickSettingsToggle({})),
    (N = new QuickSettings_1({})),
    {
      c() {
        (r = element("div")),
          (p = element("h3")),
          (v = text("Notifications ")),
          (k = element("button")),
          (x = text("Clear")),
          (I = space()),
          create_component(F.$$.fragment),
          (O = space()),
          create_component(L.$$.fragment),
          (U = space()),
          create_component(N.$$.fragment),
          attr(k, "class", "clear"),
          (k.disabled = S = !Object.entries($[3]).length),
          attr(p, "class", "title"),
          attr(r, "class", "actioncenter"),
          set_style(r, "z-index", $[2] + 4),
          toggle_class(r, "docked", $[1].sh.taskbar.docked),
          toggle_class(r, "launcher", $[1].sh.taskbar.isLauncher),
          toggle_class(r, "opened", $[0]),
          toggle_class(r, "noquick", $[1].sh.noQuickSettings),
          toggle_class(r, "colored", $[1].sh.taskbar.colored);
      },
      m(Q, K) {
        insert(Q, r, K),
          append(r, p),
          append(p, v),
          append(p, k),
          append(k, x),
          append(r, I),
          mount_component(F, r, null),
          append(r, O),
          mount_component(L, r, null),
          append(r, U),
          mount_component(N, r, null),
          (j = !0),
          R || ((q = listen(k, "click", $[4])), (R = !0));
      },
      p(Q, [K]) {
        (!j || (K & 8 && S !== (S = !Object.entries(Q[3]).length))) &&
          (k.disabled = S),
          (!j || K & 4) && set_style(r, "z-index", Q[2] + 4),
          (!j || K & 2) && toggle_class(r, "docked", Q[1].sh.taskbar.docked),
          (!j || K & 2) &&
            toggle_class(r, "launcher", Q[1].sh.taskbar.isLauncher),
          (!j || K & 1) && toggle_class(r, "opened", Q[0]),
          (!j || K & 2) && toggle_class(r, "noquick", Q[1].sh.noQuickSettings),
          (!j || K & 2) && toggle_class(r, "colored", Q[1].sh.taskbar.colored);
      },
      i(Q) {
        j ||
          (transition_in(F.$$.fragment, Q),
          transition_in(L.$$.fragment, Q),
          transition_in(N.$$.fragment, Q),
          (j = !0));
      },
      o(Q) {
        transition_out(F.$$.fragment, Q),
          transition_out(L.$$.fragment, Q),
          transition_out(N.$$.fragment, Q),
          (j = !1);
      },
      d(Q) {
        Q && detach(r),
          destroy_component(F),
          destroy_component(L),
          destroy_component(N),
          (R = !1),
          q();
      },
    }
  );
}
function instance$1b($, r, p) {
  let v, k, x;
  component_subscribe($, UserData, (F) => p(1, (v = F))),
    component_subscribe($, maxZIndex, (F) => p(2, (k = F))),
    component_subscribe($, NotificationStore, (F) => p(3, (x = F)));
  let S = !1;
  ActionCenterOpened.subscribe((F) => p(0, (S = F)));
  function I() {
    NotificationStore.set({}), CurrentNotification.set(null);
  }
  return [S, v, k, x, I];
}
class ActionCenter extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1b, create_fragment$1n, safe_not_equal, {});
  }
}
function get_each_context$h($, r, p) {
  const v = $.slice();
  return (v[8] = r[p]), v;
}
function create_if_block$C($) {
  let r,
    p,
    v = $[0].title + "",
    k,
    x,
    S,
    I,
    F,
    O = $[0].message + "",
    L,
    U,
    N,
    j;
  function R(H, G) {
    return H[0].image ? create_if_block_1$d : create_else_block$c;
  }
  let q = R($),
    Q = q($),
    K = $[0].buttons,
    V = [];
  for (let H = 0; H < K.length; H += 1)
    V[H] = create_each_block$h(get_each_context$h($, K, H));
  return {
    c() {
      (r = element("p")),
        Q.c(),
        (p = space()),
        (k = text(v)),
        (x = space()),
        (S = element("button")),
        (S.textContent = "close"),
        (I = space()),
        (F = element("p")),
        (L = space()),
        (U = element("div"));
      for (let H = 0; H < V.length; H += 1) V[H].c();
      attr(S, "class", "close material-icons-round"),
        attr(r, "class", "title"),
        attr(F, "class", "message"),
        attr(U, "class", "buttons");
    },
    m(H, G) {
      insert(H, r, G),
        Q.m(r, null),
        append(r, p),
        append(r, k),
        append(r, x),
        append(r, S),
        insert(H, I, G),
        insert(H, F, G),
        (F.innerHTML = O),
        insert(H, L, G),
        insert(H, U, G);
      for (let Y = 0; Y < V.length; Y += 1) V[Y] && V[Y].m(U, null);
      N || ((j = listen(S, "click", $[4])), (N = !0));
    },
    p(H, G) {
      if (
        (q === (q = R(H)) && Q
          ? Q.p(H, G)
          : (Q.d(1), (Q = q(H)), Q && (Q.c(), Q.m(r, p))),
        G & 1 && v !== (v = H[0].title + "") && set_data(k, v),
        G & 1 && O !== (O = H[0].message + "") && (F.innerHTML = O),
        G & 33)
      ) {
        K = H[0].buttons;
        let Y;
        for (Y = 0; Y < K.length; Y += 1) {
          const J = get_each_context$h(H, K, Y);
          V[Y]
            ? V[Y].p(J, G)
            : ((V[Y] = create_each_block$h(J)), V[Y].c(), V[Y].m(U, null));
        }
        for (; Y < V.length; Y += 1) V[Y].d(1);
        V.length = K.length;
      }
    },
    d(H) {
      H && detach(r),
        Q.d(),
        H && detach(I),
        H && detach(F),
        H && detach(L),
        H && detach(U),
        destroy_each(V, H),
        (N = !1),
        j();
    },
  };
}
function create_else_block$c($) {
  let r,
    p = $[0].icon + "",
    v;
  return {
    c() {
      (r = element("span")),
        (v = text(p)),
        attr(r, "class", "material-icons-round");
    },
    m(k, x) {
      insert(k, r, x), append(r, v);
    },
    p(k, x) {
      x & 1 && p !== (p = k[0].icon + "") && set_data(v, p);
    },
    d(k) {
      k && detach(r);
    },
  };
}
function create_if_block_1$d($) {
  let r, p, v;
  return {
    c() {
      (r = element("img")),
        src_url_equal(r.src, (p = $[0].image)) || attr(r, "src", p),
        attr(r, "alt", (v = $[0].title));
    },
    m(k, x) {
      insert(k, r, x);
    },
    p(k, x) {
      x & 1 && !src_url_equal(r.src, (p = k[0].image)) && attr(r, "src", p),
        x & 1 && v !== (v = k[0].title) && attr(r, "alt", v);
    },
    d(k) {
      k && detach(r);
    },
  };
}
function create_each_block$h($) {
  let r,
    p = $[8].caption + "",
    v,
    k,
    x;
  return {
    c() {
      (r = element("button")), (v = text(p));
    },
    m(S, I) {
      insert(S, r, I),
        append(r, v),
        k ||
          ((x = listen(r, "click", function () {
            is_function($[5]($[8].action)) &&
              $[5]($[8].action).apply(this, arguments);
          })),
          (k = !0));
    },
    p(S, I) {
      ($ = S), I & 1 && p !== (p = $[8].caption + "") && set_data(v, p);
    },
    d(S) {
      S && detach(r), (k = !1), x();
    },
  };
}
function create_fragment$1m($) {
  let r,
    p = $[0] && create_if_block$C($);
  return {
    c() {
      (r = element("div")),
        p && p.c(),
        attr(r, "class", "notification"),
        set_style(r, "z-index", $[3] + 4),
        toggle_class(r, "hidden", !$[0] || $[1]),
        toggle_class(r, "colored", $[2].sh.taskbar.colored),
        toggle_class(r, "nobutt", $[0] && !$[0].buttons.length);
    },
    m(v, k) {
      insert(v, r, k), p && p.m(r, null);
    },
    p(v, [k]) {
      v[0]
        ? p
          ? p.p(v, k)
          : ((p = create_if_block$C(v)), p.c(), p.m(r, null))
        : p && (p.d(1), (p = null)),
        k & 8 && set_style(r, "z-index", v[3] + 4),
        k & 3 && toggle_class(r, "hidden", !v[0] || v[1]),
        k & 4 && toggle_class(r, "colored", v[2].sh.taskbar.colored),
        k & 1 && toggle_class(r, "nobutt", v[0] && !v[0].buttons.length);
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      v && detach(r), p && p.d();
    },
  };
}
function instance$1a($, r, p) {
  let v, k, x;
  component_subscribe($, NotificationStore, (U) => p(7, (v = U))),
    component_subscribe($, UserData, (U) => p(2, (k = U))),
    component_subscribe($, maxZIndex, (U) => p(3, (x = U)));
  let S = null,
    I = !1,
    F;
  CurrentNotification.subscribe((U) => {
    if (U) {
      p(1, (I = !0)),
        p(0, (S = null)),
        (F = U),
        setTimeout(() => {
          p(1, (I = !1)), p(0, (S = v[U]));
        }, 250);
      return;
    }
    p(1, (I = !0)),
      setTimeout(() => {
        p(0, (S = null));
      }, 300);
  });
  function O() {
    closeNotification();
  }
  function L(U) {
    return () => {
      U(), O(), deleteNotification(F);
    };
  }
  return [S, I, k, x, O, L];
}
class PushNotification extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1a, create_fragment$1m, safe_not_equal, {});
  }
}
function getWindowElement($) {
  return document.querySelector(`window#${$.id}`);
}
function getWindowElementByEvent($) {
  const r = $.composedPath();
  for (let p = 0; p < r.length; p++) {
    const v = r[p].tagName;
    if (v && v.toLowerCase() == "window") return r[p];
  }
}
function create_if_block$B($) {
  let r,
    p = $[0].info.name + "",
    v;
  return {
    c() {
      (r = element("span")), (v = text(p));
    },
    m(k, x) {
      insert(k, r, x), append(r, v);
    },
    p(k, x) {
      x & 1 && p !== (p = k[0].info.name + "") && set_data(v, p);
    },
    d(k) {
      k && detach(r);
    },
  };
}
function create_fragment$1l($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F = $[1] && create_if_block$B($);
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (x = space()),
        F && F.c(),
        src_url_equal(
          p.src,
          (v = getOriginalIcon($[0].id) || getAppIcon($[0]))
        ) || attr(p, "src", v),
        attr(p, "alt", (k = $[0].info.name)),
        attr(p, "class", "icon"),
        attr(r, "class", "appbutton"),
        toggle_class(r, "minimized", $[2]),
        toggle_class(r, "activated", $[0].id == $[3]);
    },
    m(O, L) {
      insert(O, r, L),
        append(r, p),
        append(r, x),
        F && F.m(r, null),
        S || ((I = listen(r, "click", $[4])), (S = !0));
    },
    p(O, [L]) {
      L & 1 &&
        !src_url_equal(
          p.src,
          (v = getOriginalIcon(O[0].id) || getAppIcon(O[0]))
        ) &&
        attr(p, "src", v),
        L & 1 && k !== (k = O[0].info.name) && attr(p, "alt", k),
        O[1]
          ? F
            ? F.p(O, L)
            : ((F = create_if_block$B(O)), F.c(), F.m(r, null))
          : F && (F.d(1), (F = null)),
        L & 4 && toggle_class(r, "minimized", O[2]),
        L & 9 && toggle_class(r, "activated", O[0].id == O[3]);
    },
    i: noop$1,
    o: noop$1,
    d(O) {
      O && detach(r), F && F.d(), (S = !1), I();
    },
  };
}
function instance$19($, r, p) {
  let v, k;
  component_subscribe($, maxZIndex, (O) => p(5, (v = O))),
    component_subscribe($, focusedWindowId, (O) => p(3, (k = O)));
  let { app: x } = r,
    S = !1,
    I = !1;
  UserData.subscribe((O) => {
    p(1, (S = O.sh.taskbar.labels));
  }),
    WindowStore.subscribe(() => {
      p(2, (I = isMinimized(x.id)));
    });
  function F() {
    k == x.id
      ? p(0, (x.state.windowState.min = !x.state.windowState.min), x)
      : p(0, (x.state.windowState.min = !1), x),
      updateStores(),
      set_store_value(maxZIndex, v++, v),
      set_store_value(focusedWindowId, (k = x.id), k);
    const O = getWindowElement(x);
    O.style.zIndex = v.toString();
  }
  return (
    ($.$$set = (O) => {
      "app" in O && p(0, (x = O.app));
    }),
    [x, S, I, k, F]
  );
}
class TaskbarButton extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$19, create_fragment$1l, safe_not_equal, {
        app: 0,
      });
  }
}
const upload = "./assets/upload-54369c84.svg";
function get_each_context$g($, r, p) {
  const v = $.slice();
  return (v[8] = r[p]), v;
}
function create_else_block$b($) {
  let r, p, v;
  return {
    c() {
      (r = element("img")),
        src_url_equal(r.src, (p = $[8].image)) || attr(r, "src", p),
        attr(r, "alt", (v = $[8].identifier));
    },
    m(k, x) {
      insert(k, r, x);
    },
    p(k, x) {
      x & 4 && !src_url_equal(r.src, (p = k[8].image)) && attr(r, "src", p),
        x & 4 && v !== (v = k[8].identifier) && attr(r, "alt", v);
    },
    d(k) {
      k && detach(r);
    },
  };
}
function create_if_block_1$c($) {
  let r,
    p = $[8].icon + "",
    v;
  return {
    c() {
      (r = element("span")),
        (v = text(p)),
        attr(r, "class", "material-icons-round");
    },
    m(k, x) {
      insert(k, r, x), append(r, v);
    },
    p(k, x) {
      x & 4 && p !== (p = k[8].icon + "") && set_data(v, p);
    },
    d(k) {
      k && detach(r);
    },
  };
}
function create_each_block$g($) {
  let r, p, v;
  function k(F, O) {
    return F[8].icon ? create_if_block_1$c : create_else_block$b;
  }
  let x = k($),
    S = x($);
  function I() {
    return $[7]($[8]);
  }
  return {
    c() {
      (r = element("button")), S.c(), attr(r, "class", "icon");
    },
    m(F, O) {
      insert(F, r, O),
        S.m(r, null),
        p || ((v = listen(r, "click", I)), (p = !0));
    },
    p(F, O) {
      ($ = F),
        x === (x = k($)) && S
          ? S.p($, O)
          : (S.d(1), (S = x($)), S && (S.c(), S.m(r, null)));
    },
    d(F) {
      F && detach(r), S.d(), (p = !1), v();
    },
  };
}
function create_if_block$A($) {
  let r, p;
  return {
    c() {
      (r = element("div")), (p = text($[1])), attr(r, "class", "clock");
    },
    m(v, k) {
      insert(v, r, k), append(r, p);
    },
    p(v, k) {
      k & 2 && set_data(p, v[1]);
    },
    d(v) {
      v && detach(r);
    },
  };
}
function create_fragment$1k($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U,
    N,
    j = $[2],
    R = [];
  for (let V = 0; V < j.length; V += 1)
    R[V] = create_each_block$g(get_each_context$g($, j, V));
  let q = $[0] && create_if_block$A($);
  const Q = $[6].default,
    K = create_slot(Q, $, $[5], null);
  return {
    c() {
      r = element("div");
      for (let V = 0; V < R.length; V += 1) R[V].c();
      (p = space()),
        (v = element("button")),
        (k = element("img")),
        (S = space()),
        q && q.c(),
        (I = space()),
        (F = element("button")),
        (F.textContent = "notifications"),
        (O = space()),
        K && K.c(),
        src_url_equal(k.src, (x = upload)) || attr(k, "src", x),
        attr(k, "alt", "Committing"),
        attr(v, "class", "icon committer"),
        toggle_class(v, "inactive", !$[3]),
        attr(F, "class", "material-icons-round ac-open"),
        toggle_class(F, "opened", $[4]),
        attr(r, "class", "tray");
    },
    m(V, H) {
      insert(V, r, H);
      for (let G = 0; G < R.length; G += 1) R[G] && R[G].m(r, null);
      append(r, p),
        append(r, v),
        append(v, k),
        append(r, S),
        q && q.m(r, null),
        append(r, I),
        append(r, F),
        append(r, O),
        K && K.m(r, null),
        (L = !0),
        U || ((N = listen(F, "click", toggleActionCenter)), (U = !0));
    },
    p(V, [H]) {
      if (H & 4) {
        j = V[2];
        let G;
        for (G = 0; G < j.length; G += 1) {
          const Y = get_each_context$g(V, j, G);
          R[G]
            ? R[G].p(Y, H)
            : ((R[G] = create_each_block$g(Y)), R[G].c(), R[G].m(r, p));
        }
        for (; G < R.length; G += 1) R[G].d(1);
        R.length = j.length;
      }
      (!L || H & 8) && toggle_class(v, "inactive", !V[3]),
        V[0]
          ? q
            ? q.p(V, H)
            : ((q = create_if_block$A(V)), q.c(), q.m(r, I))
          : q && (q.d(1), (q = null)),
        (!L || H & 16) && toggle_class(F, "opened", V[4]),
        K &&
          K.p &&
          (!L || H & 32) &&
          update_slot_base(
            K,
            Q,
            V,
            V[5],
            L
              ? get_slot_changes(Q, V[5], H, null)
              : get_all_dirty_from_scope(V[5]),
            null
          );
    },
    i(V) {
      L || (transition_in(K, V), (L = !0));
    },
    o(V) {
      transition_out(K, V), (L = !1);
    },
    d(V) {
      V && detach(r),
        destroy_each(R, V),
        q && q.d(),
        K && K.d(V),
        (U = !1),
        N();
    },
  };
}
function instance$18($, r, p) {
  let v, k, x;
  component_subscribe($, trayIcons, (U) => p(2, (v = U))),
    component_subscribe($, committingUserData, (U) => p(3, (k = U))),
    component_subscribe($, ActionCenterOpened, (U) => p(4, (x = U)));
  let { $$slots: S = {}, $$scope: I } = r,
    { hasClock: F = !0 } = r,
    O = "";
  onMount(() => {
    setInterval(() => {
      p(1, (O = dayjs().format("HH:mm")));
    });
  });
  const L = (U) => U.onOpen(U);
  return (
    ($.$$set = (U) => {
      "hasClock" in U && p(0, (F = U.hasClock)),
        "$$scope" in U && p(5, (I = U.$$scope));
    }),
    [F, O, v, k, x, I, S, L]
  );
}
class Tray extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$18, create_fragment$1k, safe_not_equal, {
        hasClock: 0,
      });
  }
}
const TaskbarContent_svelte_svelte_type_style_lang = "";
function get_each_context$f($, r, p) {
  const v = $.slice();
  return (v[2] = r[p]), v;
}
function create_if_block_1$b($) {
  let r, p;
  return (
    (r = new TaskbarButton({ props: { app: $[2] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 2 && (x.app = v[2]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$f($) {
  let r,
    p,
    v = !$[2].disabled && create_if_block_1$b($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, x) {
      k[2].disabled
        ? v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros())
        : v
        ? (v.p(k, x), x & 2 && transition_in(v, 1))
        : ((v = create_if_block_1$b(k)),
          v.c(),
          transition_in(v, 1),
          v.m(r.parentNode, r));
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function create_else_block$a($) {
  let r, p, v;
  return (
    (p = new Spinner({ props: { height: 24 } })),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          attr(r, "class", "tray svelte-1vsr6ui");
      },
      m(k, x) {
        insert(k, r, x), mount_component(p, r, null), (v = !0);
      },
      i(k) {
        v || (transition_in(p.$$.fragment, k), (v = !0));
      },
      o(k) {
        transition_out(p.$$.fragment, k), (v = !1);
      },
      d(k) {
        k && detach(r), destroy_component(p);
      },
    }
  );
}
function create_if_block$z($) {
  let r, p;
  return (
    (r = new Tray({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$1j($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I = $[1],
    F = [];
  for (let j = 0; j < I.length; j += 1)
    F[j] = create_each_block$f(get_each_context$f($, I, j));
  const O = (j) =>
      transition_out(F[j], 1, 1, () => {
        F[j] = null;
      }),
    L = [create_if_block$z, create_else_block$a],
    U = [];
  function N(j, R) {
    return j[0] ? 0 : 1;
  }
  return (
    (v = N($)),
    (k = U[v] = L[v]($)),
    {
      c() {
        r = element("div");
        for (let j = 0; j < F.length; j += 1) F[j].c();
        (p = space()), k.c(), (x = empty()), attr(r, "class", "buttons");
      },
      m(j, R) {
        insert(j, r, R);
        for (let q = 0; q < F.length; q += 1) F[q] && F[q].m(r, null);
        insert(j, p, R), U[v].m(j, R), insert(j, x, R), (S = !0);
      },
      p(j, [R]) {
        if (R & 2) {
          I = j[1];
          let Q;
          for (Q = 0; Q < I.length; Q += 1) {
            const K = get_each_context$f(j, I, Q);
            F[Q]
              ? (F[Q].p(K, R), transition_in(F[Q], 1))
              : ((F[Q] = create_each_block$f(K)),
                F[Q].c(),
                transition_in(F[Q], 1),
                F[Q].m(r, null));
          }
          for (group_outros(), Q = I.length; Q < F.length; Q += 1) O(Q);
          check_outros();
        }
        let q = v;
        (v = N(j)),
          v !== q &&
            (group_outros(),
            transition_out(U[q], 1, 1, () => {
              U[q] = null;
            }),
            check_outros(),
            (k = U[v]),
            k || ((k = U[v] = L[v](j)), k.c()),
            transition_in(k, 1),
            k.m(x.parentNode, x));
      },
      i(j) {
        if (!S) {
          for (let R = 0; R < I.length; R += 1) transition_in(F[R]);
          transition_in(k), (S = !0);
        }
      },
      o(j) {
        F = F.filter(Boolean);
        for (let R = 0; R < F.length; R += 1) transition_out(F[R]);
        transition_out(k), (S = !1);
      },
      d(j) {
        j && detach(r),
          destroy_each(F, j),
          j && detach(p),
          U[v].d(j),
          j && detach(x);
      },
    }
  );
}
function instance$17($, r, p) {
  let v = !1,
    k = [];
  return (
    WindowStore.subscribe(() => {
      p(1, (k = getOpenedStore()));
    }),
    onMount(() => {
      p(0, (v = !1)),
        setTimeout(() => {
          p(0, (v = !0));
        }, 3e3);
    }),
    [v, k]
  );
}
class TaskbarContent extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$17, create_fragment$1j, safe_not_equal, {});
  }
}
function create_fragment$1i($) {
  let r, p, v, k;
  const x = $[4].default,
    S = create_slot(x, $, $[3], null);
  return (
    (v = new TaskbarContent({})),
    {
      c() {
        (r = element("div")),
          S && S.c(),
          (p = space()),
          create_component(v.$$.fragment),
          attr(r, "class", "taskbar-h newtb"),
          set_style(r, "z-index", $[0] + 5),
          attr(r, "data-caller", "shell-taskbar"),
          toggle_class(r, "docked", $[1].sh.taskbar.docked),
          toggle_class(r, "centered", $[1].sh.taskbar.centered),
          toggle_class(r, "colored", $[1].sh.taskbar.colored),
          toggle_class(r, "visible", $[1].sh.taskbar.pos == "" && !$[2]);
      },
      m(I, F) {
        insert(I, r, F),
          S && S.m(r, null),
          append(r, p),
          mount_component(v, r, null),
          (k = !0);
      },
      p(I, [F]) {
        S &&
          S.p &&
          (!k || F & 8) &&
          update_slot_base(
            S,
            x,
            I,
            I[3],
            k
              ? get_slot_changes(x, I[3], F, null)
              : get_all_dirty_from_scope(I[3]),
            null
          ),
          (!k || F & 1) && set_style(r, "z-index", I[0] + 5),
          (!k || F & 2) && toggle_class(r, "docked", I[1].sh.taskbar.docked),
          (!k || F & 2) &&
            toggle_class(r, "centered", I[1].sh.taskbar.centered),
          (!k || F & 2) && toggle_class(r, "colored", I[1].sh.taskbar.colored),
          (!k || F & 6) &&
            toggle_class(r, "visible", I[1].sh.taskbar.pos == "" && !I[2]);
      },
      i(I) {
        k || (transition_in(S, I), transition_in(v.$$.fragment, I), (k = !0));
      },
      o(I) {
        transition_out(S, I), transition_out(v.$$.fragment, I), (k = !1);
      },
      d(I) {
        I && detach(r), S && S.d(I), destroy_component(v);
      },
    }
  );
}
function instance$16($, r, p) {
  let v, k, x;
  component_subscribe($, maxZIndex, (F) => p(0, (v = F))),
    component_subscribe($, UserData, (F) => p(1, (k = F))),
    component_subscribe($, isFullscreenWindow, (F) => p(2, (x = F)));
  let { $$slots: S = {}, $$scope: I } = r;
  return (
    ($.$$set = (F) => {
      "$$scope" in F && p(3, (I = F.$$scope));
    }),
    [v, k, x, I, S]
  );
}
class HorizontalTaskbar extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$16, create_fragment$1i, safe_not_equal, {});
  }
}
function create_fragment$1h($) {
  let r, p, v, k, x, S, I;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        src_url_equal(
          p.src,
          (v = getOriginalIcon($[0].id) || $[0].info.icon)
        ) || attr(p, "src", v),
        attr(p, "alt", (k = $[0].info.name)),
        attr(r, "title", (x = $[0].info.name)),
        toggle_class(r, "minimized", $[1]),
        toggle_class(r, "activated", $[0].id == $[2]);
    },
    m(F, O) {
      insert(F, r, O),
        append(r, p),
        S || ((I = listen(r, "click", $[3])), (S = !0));
    },
    p(F, [O]) {
      O & 1 &&
        !src_url_equal(
          p.src,
          (v = getOriginalIcon(F[0].id) || F[0].info.icon)
        ) &&
        attr(p, "src", v),
        O & 1 && k !== (k = F[0].info.name) && attr(p, "alt", k),
        O & 1 && x !== (x = F[0].info.name) && attr(r, "title", x),
        O & 2 && toggle_class(r, "minimized", F[1]),
        O & 5 && toggle_class(r, "activated", F[0].id == F[2]);
    },
    i: noop$1,
    o: noop$1,
    d(F) {
      F && detach(r), (S = !1), I();
    },
  };
}
function instance$15($, r, p) {
  let v, k;
  component_subscribe($, maxZIndex, (F) => p(4, (v = F))),
    component_subscribe($, focusedWindowId, (F) => p(2, (k = F)));
  let { app: x } = r,
    S = !1;
  WindowStore.subscribe(() => {
    p(1, (S = isMinimized(x.id)));
  });
  function I() {
    k == x.id
      ? p(0, (x.state.windowState.min = !x.state.windowState.min), x)
      : p(0, (x.state.windowState.min = !1), x),
      updateStores(),
      set_store_value(maxZIndex, v++, v),
      set_store_value(focusedWindowId, (k = x.id), k);
    const F = getWindowElement(x);
    F.style.zIndex = v.toString();
  }
  return (
    ($.$$set = (F) => {
      "app" in F && p(0, (x = F.app));
    }),
    [x, S, k, I]
  );
}
class AppButton extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$15, create_fragment$1h, safe_not_equal, {
        app: 0,
      });
  }
}
function create_fragment$1g($) {
  let r, p, v;
  return {
    c() {
      (r = element("div")),
        attr(r, "class", "launcher-bar-trigger"),
        set_style(r, "z-index", $[0] + 21);
    },
    m(k, x) {
      insert(k, r, x),
        p ||
          ((v = [listen(r, "mouseenter", $[1]), listen(r, "mouseleave", $[2])]),
          (p = !0));
    },
    p(k, [x]) {
      x & 1 && set_style(r, "z-index", k[0] + 21);
    },
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r), (p = !1), run_all(v);
    },
  };
}
function instance$14($, r, p) {
  let v;
  component_subscribe($, maxZIndex, (O) => p(0, (v = O)));
  let { visible: k = !1 } = r,
    { dockfocused: x } = r,
    { interval: S } = r;
  function I() {
    p(3, (k = !0));
  }
  function F() {
    clearTimeout(S),
      !x &&
        p(
          4,
          (S = setTimeout(() => {
            p(3, (k = !1));
          }, 1e3))
        );
  }
  return (
    ($.$$set = (O) => {
      "visible" in O && p(3, (k = O.visible)),
        "dockfocused" in O && p(5, (x = O.dockfocused)),
        "interval" in O && p(4, (S = O.interval));
    }),
    [v, I, F, k, S, x]
  );
}
class Trigger extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$14, create_fragment$1g, safe_not_equal, {
        visible: 3,
        dockfocused: 5,
        interval: 4,
      });
  }
}
function get_each_context$e($, r, p) {
  const v = $.slice();
  return (v[11] = r[p]), v;
}
function create_if_block$y($) {
  let r, p;
  return (
    (r = new AppButton({ props: { app: $[11] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.app = v[11]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$e($) {
  let r,
    p,
    v = !$[11].info.hidden && create_if_block$y($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, x) {
      k[11].info.hidden
        ? v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros())
        : v
        ? (v.p(k, x), x & 1 && transition_in(v, 1))
        : ((v = create_if_block$y(k)),
          v.c(),
          transition_in(v, 1),
          v.m(r.parentNode, r));
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function create_fragment$1f($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U,
    N,
    j,
    R,
    q = $[0],
    Q = [];
  for (let Y = 0; Y < q.length; Y += 1)
    Q[Y] = create_each_block$e(get_each_context$e($, q, Y));
  const K = (Y) =>
    transition_out(Q[Y], 1, 1, () => {
      Q[Y] = null;
    });
  function V(Y) {
    $[9](Y);
  }
  function H(Y) {
    $[10](Y);
  }
  let G = { dockfocused: $[2] };
  return (
    $[1] !== void 0 && (G.visible = $[1]),
    $[3] !== void 0 && (G.interval = $[3]),
    (O = new Trigger({ props: G })),
    binding_callbacks.push(() => bind$1(O, "visible", V)),
    binding_callbacks.push(() => bind$1(O, "interval", H)),
    {
      c() {
        (r = element("div")),
          (p = element("button")),
          (v = element("img")),
          (S = space()),
          (I = element("div"));
        for (let Y = 0; Y < Q.length; Y += 1) Q[Y].c();
        (F = space()),
          create_component(O.$$.fragment),
          src_url_equal(v.src, (k = logo$d)) || attr(v, "src", k),
          attr(v, "alt", "ArcOS"),
          attr(p, "class", "apps"),
          (p.disabled = x = !!$[0].filter(func).length),
          attr(I, "class", "opened-apps"),
          attr(r, "class", "launcher-bar"),
          set_style(r, "z-index", $[5] + 20),
          toggle_class(r, "colored", $[4].sh.taskbar.colored),
          toggle_class(r, "visible", $[1]);
      },
      m(Y, J) {
        insert(Y, r, J), append(r, p), append(p, v), append(r, S), append(r, I);
        for (let Z = 0; Z < Q.length; Z += 1) Q[Z] && Q[Z].m(I, null);
        insert(Y, F, J),
          mount_component(O, Y, J),
          (N = !0),
          j ||
            ((R = [
              listen(p, "click", $[8]),
              listen(r, "mouseenter", $[6]),
              listen(r, "mouseleave", $[7]),
            ]),
            (j = !0));
      },
      p(Y, [J]) {
        if (
          ((!N || (J & 1 && x !== (x = !!Y[0].filter(func).length))) &&
            (p.disabled = x),
          J & 1)
        ) {
          q = Y[0];
          let X;
          for (X = 0; X < q.length; X += 1) {
            const ee = get_each_context$e(Y, q, X);
            Q[X]
              ? (Q[X].p(ee, J), transition_in(Q[X], 1))
              : ((Q[X] = create_each_block$e(ee)),
                Q[X].c(),
                transition_in(Q[X], 1),
                Q[X].m(I, null));
          }
          for (group_outros(), X = q.length; X < Q.length; X += 1) K(X);
          check_outros();
        }
        (!N || J & 32) && set_style(r, "z-index", Y[5] + 20),
          (!N || J & 16) && toggle_class(r, "colored", Y[4].sh.taskbar.colored),
          (!N || J & 2) && toggle_class(r, "visible", Y[1]);
        const Z = {};
        J & 4 && (Z.dockfocused = Y[2]),
          !L &&
            J & 2 &&
            ((L = !0), (Z.visible = Y[1]), add_flush_callback(() => (L = !1))),
          !U &&
            J & 8 &&
            ((U = !0), (Z.interval = Y[3]), add_flush_callback(() => (U = !1))),
          O.$set(Z);
      },
      i(Y) {
        if (!N) {
          for (let J = 0; J < q.length; J += 1) transition_in(Q[J]);
          transition_in(O.$$.fragment, Y), (N = !0);
        }
      },
      o(Y) {
        Q = Q.filter(Boolean);
        for (let J = 0; J < Q.length; J += 1) transition_out(Q[J]);
        transition_out(O.$$.fragment, Y), (N = !1);
      },
      d(Y) {
        Y && detach(r),
          destroy_each(Q, Y),
          Y && detach(F),
          destroy_component(O, Y),
          (j = !1),
          run_all(R);
      },
    }
  );
}
const func = ($) => $.id == "AppLauncher";
function instance$13($, r, p) {
  let v, k;
  component_subscribe($, UserData, (R) => p(4, (v = R))),
    component_subscribe($, maxZIndex, (R) => p(5, (k = R)));
  let x = [],
    S = !1,
    I = !1,
    F;
  WindowStore.subscribe(() => {
    p(0, (x = getOpenedStore()));
  });
  function O() {
    p(2, (I = !0)), clearTimeout(F);
  }
  function L() {
    p(2, (I = !1)),
      p(
        3,
        (F = setTimeout(() => {
          p(1, (S = !1));
        }, 1e3))
      );
  }
  function U() {
    openWindow("AppLauncher");
  }
  function N(R) {
    (S = R), p(1, S);
  }
  function j(R) {
    (F = R), p(3, F);
  }
  return [x, S, I, F, v, k, O, L, U, N, j];
}
class Bar extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$13, create_fragment$1f, safe_not_equal, {});
  }
}
function create_default_slot$3($) {
  let r = Object.entries($[3]).length + "",
    p,
    v;
  return {
    c() {
      (p = text(r)), (v = text(" Notifications"));
    },
    m(k, x) {
      insert(k, p, x), insert(k, v, x);
    },
    p(k, x) {
      x & 8 && r !== (r = Object.entries(k[3]).length + "") && set_data(p, r);
    },
    d(k) {
      k && detach(p), k && detach(v);
    },
  };
}
function create_fragment$1e($) {
  let r, p, v;
  return (
    (p = new Tray({
      props: {
        hasClock: !1,
        $$slots: { default: [create_default_slot$3] },
        $$scope: { ctx: $ },
      },
    })),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          attr(r, "class", "launcher-topbar"),
          set_style(r, "z-index", $[2] + 22),
          toggle_class(r, "docked", $[0].sh.taskbar.docked),
          toggle_class(r, "colored", $[0].sh.taskbar.colored),
          toggle_class(r, "visible", !$[1]);
      },
      m(k, x) {
        insert(k, r, x), mount_component(p, r, null), (v = !0);
      },
      p(k, [x]) {
        const S = {};
        x & 24 && (S.$$scope = { dirty: x, ctx: k }),
          p.$set(S),
          (!v || x & 4) && set_style(r, "z-index", k[2] + 22),
          (!v || x & 1) && toggle_class(r, "docked", k[0].sh.taskbar.docked),
          (!v || x & 1) && toggle_class(r, "colored", k[0].sh.taskbar.colored),
          (!v || x & 2) && toggle_class(r, "visible", !k[1]);
      },
      i(k) {
        v || (transition_in(p.$$.fragment, k), (v = !0));
      },
      o(k) {
        transition_out(p.$$.fragment, k), (v = !1);
      },
      d(k) {
        k && detach(r), destroy_component(p);
      },
    }
  );
}
function instance$12($, r, p) {
  let v, k, x, S;
  return (
    component_subscribe($, UserData, (I) => p(0, (v = I))),
    component_subscribe($, isFullscreenWindow, (I) => p(1, (k = I))),
    component_subscribe($, maxZIndex, (I) => p(2, (x = I))),
    component_subscribe($, NotificationStore, (I) => p(3, (S = I))),
    [v, k, x, S]
  );
}
class TopBar extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$12, create_fragment$1e, safe_not_equal, {});
  }
}
function create_fragment$1d($) {
  let r, p, v, k;
  return (
    (r = new Bar({})),
    (v = new TopBar({})),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          create_component(v.$$.fragment);
      },
      m(x, S) {
        mount_component(r, x, S),
          insert(x, p, S),
          mount_component(v, x, S),
          (k = !0);
      },
      p: noop$1,
      i(x) {
        k ||
          (transition_in(r.$$.fragment, x),
          transition_in(v.$$.fragment, x),
          (k = !0));
      },
      o(x) {
        transition_out(r.$$.fragment, x),
          transition_out(v.$$.fragment, x),
          (k = !1);
      },
      d(x) {
        destroy_component(r, x), x && detach(p), destroy_component(v, x);
      },
    }
  );
}
class Launcher extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$1d, safe_not_equal, {});
  }
}
const shade = "";
function create_fragment$1c($) {
  let r, p, v;
  return {
    c() {
      (r = element("div")),
        attr(r, "class", "shellshade"),
        set_style(r, "z-index", $[1] + 3),
        toggle_class(r, "visible", $[0]);
    },
    m(k, x) {
      insert(k, r, x), p || ((v = listen(r, "click", $[2])), (p = !0));
    },
    p(k, [x]) {
      x & 2 && set_style(r, "z-index", k[1] + 3),
        x & 1 && toggle_class(r, "visible", k[0]);
    },
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function instance$11($, r, p) {
  let v, k, x, S;
  component_subscribe($, ActionCenterOpened, (O) => p(3, (v = O))),
    component_subscribe($, startOpened, (O) => p(4, (k = O))),
    component_subscribe($, showShellShade, (O) => p(0, (x = O))),
    component_subscribe($, maxZIndex, (O) => p(1, (S = O))),
    ActionCenterOpened.subscribe(I),
    startOpened.subscribe(I);
  function I() {
    set_store_value(showShellShade, (x = k || v), x);
  }
  function F() {
    startOpened.set(!1), ActionCenterOpened.set(!1);
  }
  return [x, S, F];
}
class Shade extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$11, create_fragment$1c, safe_not_equal, {});
  }
}
function create_fragment$1b($) {
  let r, p, v, k;
  const x = $[4].default,
    S = create_slot(x, $, $[3], null);
  return (
    (v = new TaskbarContent({})),
    {
      c() {
        (r = element("div")),
          S && S.c(),
          (p = space()),
          create_component(v.$$.fragment),
          attr(r, "class", "taskbar-v newtb"),
          set_style(r, "z-index", $[0] + 5),
          attr(r, "data-caller", "shell-taskbar"),
          toggle_class(r, "docked", $[1].sh.taskbar.docked),
          toggle_class(r, "centered", $[1].sh.taskbar.centered),
          toggle_class(r, "colored", $[1].sh.taskbar.colored),
          toggle_class(r, "visible", $[1].sh.taskbar.pos != "" && !$[2]),
          toggle_class(r, "right", $[1].sh.taskbar.pos == "vertical-right");
      },
      m(I, F) {
        insert(I, r, F),
          S && S.m(r, null),
          append(r, p),
          mount_component(v, r, null),
          (k = !0);
      },
      p(I, [F]) {
        S &&
          S.p &&
          (!k || F & 8) &&
          update_slot_base(
            S,
            x,
            I,
            I[3],
            k
              ? get_slot_changes(x, I[3], F, null)
              : get_all_dirty_from_scope(I[3]),
            null
          ),
          (!k || F & 1) && set_style(r, "z-index", I[0] + 5),
          (!k || F & 2) && toggle_class(r, "docked", I[1].sh.taskbar.docked),
          (!k || F & 2) &&
            toggle_class(r, "centered", I[1].sh.taskbar.centered),
          (!k || F & 2) && toggle_class(r, "colored", I[1].sh.taskbar.colored),
          (!k || F & 6) &&
            toggle_class(r, "visible", I[1].sh.taskbar.pos != "" && !I[2]),
          (!k || F & 2) &&
            toggle_class(r, "right", I[1].sh.taskbar.pos == "vertical-right");
      },
      i(I) {
        k || (transition_in(S, I), transition_in(v.$$.fragment, I), (k = !0));
      },
      o(I) {
        transition_out(S, I), transition_out(v.$$.fragment, I), (k = !1);
      },
      d(I) {
        I && detach(r), S && S.d(I), destroy_component(v);
      },
    }
  );
}
function instance$10($, r, p) {
  let v, k, x;
  component_subscribe($, maxZIndex, (F) => p(0, (v = F))),
    component_subscribe($, UserData, (F) => p(1, (k = F))),
    component_subscribe($, isFullscreenWindow, (F) => p(2, (x = F)));
  let { $$slots: S = {}, $$scope: I } = r;
  return (
    ($.$$set = (F) => {
      "$$scope" in F && p(3, (I = F.$$scope));
    }),
    [v, k, x, I, S]
  );
}
class VerticalTaskbar extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$10, create_fragment$1b, safe_not_equal, {});
  }
}
function create_fragment$1a($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K;
  return (
    (v = new ProfilePicture$1({ props: { src: $[0], height: 21 } })),
    {
      c() {
        (r = element("div")),
          (p = element("h1")),
          create_component(v.$$.fragment),
          (k = space()),
          (x = text($[1])),
          (S = space()),
          (I = element("div")),
          (F = element("button")),
          (F.textContent = "search"),
          (O = space()),
          (L = element("button")),
          (L.textContent = "settings"),
          (U = space()),
          (N = element("div")),
          (j = space()),
          (R = element("button")),
          (R.textContent = "power_settings_new"),
          attr(p, "class", "username"),
          attr(F, "class", "material-icons-round"),
          attr(F, "title", "Search (Alt+Shift+S)"),
          attr(L, "class", "material-icons-round"),
          attr(N, "class", "sep"),
          attr(R, "class", "material-icons-round"),
          attr(I, "class", "options"),
          attr(r, "class", "bottom");
      },
      m(V, H) {
        insert(V, r, H),
          append(r, p),
          mount_component(v, p, null),
          append(p, k),
          append(p, x),
          append(r, S),
          append(r, I),
          append(I, F),
          append(I, O),
          append(I, L),
          append(I, U),
          append(I, N),
          append(I, j),
          append(I, R),
          (q = !0),
          Q ||
            ((K = [
              listen(F, "click", $[4]),
              listen(L, "click", $[3]),
              listen(R, "click", $[2]),
            ]),
            (Q = !0));
      },
      p(V, [H]) {
        const G = {};
        H & 1 && (G.src = V[0]), v.$set(G), (!q || H & 2) && set_data(x, V[1]);
      },
      i(V) {
        q || (transition_in(v.$$.fragment, V), (q = !0));
      },
      o(V) {
        transition_out(v.$$.fragment, V), (q = !1);
      },
      d(V) {
        V && detach(r), destroy_component(v), (Q = !1), run_all(K);
      },
    }
  );
}
function instance$$($, r, p) {
  let v, k;
  component_subscribe($, UserData, (O) => p(5, (v = O))),
    component_subscribe($, UserName, (O) => p(1, (k = O)));
  let x;
  function S() {
    openWindow("Exit"), startOpened.set(!1);
  }
  function I() {
    openWindow("SettingsApp"), startOpened.set(!1);
  }
  function F() {
    showArcFind.set(!0), startOpened.set(!1);
  }
  return (
    UserData.subscribe(() => {
      p(0, (x = getProfilePicture(v.acc.profilePicture)));
    }),
    [x, k, S, I, F]
  );
}
class BottomPane extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$$, create_fragment$1a, safe_not_equal, {});
  }
}
function create_fragment$19($) {
  let r,
    p,
    v,
    k,
    x,
    S = $[0].info.name + "",
    I,
    F,
    O,
    L;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (x = space()),
        (I = text(S)),
        src_url_equal(
          p.src,
          (v = getOriginalIcon($[0].id) || getAppIcon($[0]))
        ) || attr(p, "src", v),
        attr(p, "class", "icon"),
        attr(p, "alt", (k = $[0].info.name)),
        attr(r, "class", "item"),
        (r.disabled = F = $[0].opened);
    },
    m(U, N) {
      insert(U, r, N),
        append(r, p),
        append(r, x),
        append(r, I),
        O || ((L = listen(r, "click", $[1])), (O = !0));
    },
    p(U, [N]) {
      N & 1 &&
        !src_url_equal(
          p.src,
          (v = getOriginalIcon(U[0].id) || getAppIcon(U[0]))
        ) &&
        attr(p, "src", v),
        N & 1 && k !== (k = U[0].info.name) && attr(p, "alt", k),
        N & 1 && S !== (S = U[0].info.name + "") && set_data(I, S),
        N & 1 && F !== (F = U[0].opened) && (r.disabled = F);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r), (O = !1), L();
    },
  };
}
function instance$_($, r, p) {
  let { app: v } = r,
    { onopen: k = () => {} } = r;
  function x() {
    openWindow(v.id), updateStores(), startOpened.set(!1), k();
  }
  return (
    ($.$$set = (S) => {
      "app" in S && p(0, (v = S.app)), "onopen" in S && p(2, (k = S.onopen));
    }),
    [v, x, k]
  );
}
class AppListItem extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$_, create_fragment$19, safe_not_equal, {
        app: 0,
        onopen: 2,
      });
  }
}
function get_each_context$d($, r, p) {
  const v = $.slice();
  return (v[1] = r[p]), v;
}
function create_if_block$x($) {
  let r, p;
  return (
    (r = new AppListItem({ props: { app: $[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.app = v[1]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$d($) {
  let r = isPopulatable($[1]),
    p,
    v,
    k = r && create_if_block$x($);
  return {
    c() {
      k && k.c(), (p = empty());
    },
    m(x, S) {
      k && k.m(x, S), insert(x, p, S), (v = !0);
    },
    p(x, S) {
      S & 1 && (r = isPopulatable(x[1])),
        r
          ? k
            ? (k.p(x, S), S & 1 && transition_in(k, 1))
            : ((k = create_if_block$x(x)),
              k.c(),
              transition_in(k, 1),
              k.m(p.parentNode, p))
          : k &&
            (group_outros(),
            transition_out(k, 1, 1, () => {
              k = null;
            }),
            check_outros());
    },
    i(x) {
      v || (transition_in(k), (v = !0));
    },
    o(x) {
      transition_out(k), (v = !1);
    },
    d(x) {
      k && k.d(x), x && detach(p);
    },
  };
}
function create_fragment$18($) {
  let r,
    p,
    v = $[0],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$d(get_each_context$d($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      r = element("div");
      for (let S = 0; S < k.length; S += 1) k[S].c();
      attr(r, "class", "left");
    },
    m(S, I) {
      insert(S, r, I);
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(r, null);
      p = !0;
    },
    p(S, [I]) {
      if (I & 1) {
        v = S[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$d(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$d(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      S && detach(r), destroy_each(k, S);
    },
  };
}
function instance$Z($, r, p) {
  let v;
  return component_subscribe($, WindowStore, (k) => p(0, (v = k))), [v];
}
class LeftPane extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$Z, create_fragment$18, safe_not_equal, {});
  }
}
function create_fragment$17($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F = $[0].name + "",
    O,
    L,
    U;
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (I = element("div")),
        (O = text(F)),
        src_url_equal(v.src, (k = folder)) || attr(v, "src", k),
        attr(v, "alt", (x = $[0].name)),
        attr(p, "class", "image"),
        attr(I, "class", "caption"),
        attr(r, "class", "link dir");
    },
    m(N, j) {
      insert(N, r, j),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, I),
        append(I, O),
        L || ((U = listen(r, "click", $[1])), (L = !0));
    },
    p(N, [j]) {
      j & 1 && x !== (x = N[0].name) && attr(v, "alt", x),
        j & 1 && F !== (F = N[0].name + "") && set_data(O, F);
    },
    i: noop$1,
    o: noop$1,
    d(N) {
      N && detach(r), (L = !1), U();
    },
  };
}
function instance$Y($, r, p) {
  let { dir: v } = r;
  function k() {
    startOpened.set(!1),
      openWindow("FileManager"),
      setTimeout(() => {
        fbClass.goToDirectory(v.scopedPath);
      });
  }
  return (
    ($.$$set = (x) => {
      "dir" in x && p(0, (v = x.dir));
    }),
    [v, k]
  );
}
class DirLink extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$Y, create_fragment$17, safe_not_equal, { dir: 0 });
  }
}
function get_each_context$c($, r, p) {
  const v = $.slice();
  return (v[1] = r[p]), v;
}
function create_each_block$c($) {
  let r, p;
  return (
    (r = new DirLink({ props: { dir: $[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.dir = v[1]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$16($) {
  let r,
    p,
    v = $[0],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$c(get_each_context$c($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      r = element("div");
      for (let S = 0; S < k.length; S += 1) k[S].c();
      attr(r, "class", "right");
    },
    m(S, I) {
      insert(S, r, I);
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(r, null);
      p = !0;
    },
    p(S, [I]) {
      if (I & 1) {
        v = S[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$c(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$c(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      S && detach(r), destroy_each(k, S);
    },
  };
}
function instance$X($, r, p) {
  let v = [];
  return (
    FileBrowserDirContents.subscribe(async () => {
      p(0, (v = (await getDirectory("./")).directories));
    }),
    [v]
  );
}
class RightPane extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$X, create_fragment$16, safe_not_equal, {});
  }
}
function create_if_block$w($) {
  let r, p, v, k, x, S, I;
  return (
    (p = new LeftPane({})),
    (k = new RightPane({})),
    (S = new BottomPane({})),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          create_component(k.$$.fragment),
          (x = space()),
          create_component(S.$$.fragment),
          attr(r, "class", "startmenu"),
          set_style(r, "z-index", $[1] + 4),
          toggle_class(r, "open", $[2]),
          toggle_class(r, "small", $[0].sh.start.small),
          toggle_class(r, "colored", $[0].sh.taskbar.colored);
      },
      m(F, O) {
        insert(F, r, O),
          mount_component(p, r, null),
          append(r, v),
          mount_component(k, r, null),
          append(r, x),
          mount_component(S, r, null),
          (I = !0);
      },
      p(F, O) {
        (!I || O & 2) && set_style(r, "z-index", F[1] + 4),
          (!I || O & 4) && toggle_class(r, "open", F[2]),
          (!I || O & 1) && toggle_class(r, "small", F[0].sh.start.small),
          (!I || O & 1) && toggle_class(r, "colored", F[0].sh.taskbar.colored);
      },
      i(F) {
        I ||
          (transition_in(p.$$.fragment, F),
          transition_in(k.$$.fragment, F),
          transition_in(S.$$.fragment, F),
          (I = !0));
      },
      o(F) {
        transition_out(p.$$.fragment, F),
          transition_out(k.$$.fragment, F),
          transition_out(S.$$.fragment, F),
          (I = !1);
      },
      d(F) {
        F && detach(r),
          destroy_component(p),
          destroy_component(k),
          destroy_component(S);
      },
    }
  );
}
function create_fragment$15($) {
  let r,
    p,
    v = $[0] && create_if_block$w($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[0]
        ? v
          ? (v.p(k, x), x & 1 && transition_in(v, 1))
          : ((v = create_if_block$w(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$W($, r, p) {
  let v, k, x;
  return (
    component_subscribe($, UserData, (S) => p(0, (v = S))),
    component_subscribe($, maxZIndex, (S) => p(1, (k = S))),
    component_subscribe($, startOpened, (S) => p(2, (x = S))),
    [v, k, x]
  );
}
class StartMenu extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$W, create_fragment$15, safe_not_equal, {});
  }
}
function create_fragment$14($) {
  let r, p, v, k, x;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        src_url_equal(p.src, (v = logo$d)) || attr(p, "src", v),
        attr(p, "alt", "ArcOS Logo"),
        attr(r, "class", "start"),
        toggle_class(r, "open", $[0]);
    },
    m(S, I) {
      insert(S, r, I),
        append(r, p),
        k || ((x = listen(r, "click", $[1])), (k = !0));
    },
    p(S, [I]) {
      I & 1 && toggle_class(r, "open", S[0]);
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r), (k = !1), x();
    },
  };
}
function instance$V($, r, p) {
  let v;
  component_subscribe($, startOpened, (x) => p(0, (v = x)));
  function k() {
    set_store_value(startOpened, (v = !v), v);
  }
  return [v, k];
}
class StartButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$V, create_fragment$14, safe_not_equal, {});
  }
}
function create_else_block$9($) {
  let r, p;
  return (
    (r = new Launcher({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$v($) {
  let r, p, v, k;
  return (
    (r = new HorizontalTaskbar({
      props: {
        $$slots: { default: [create_default_slot_1] },
        $$scope: { ctx: $ },
      },
    })),
    (v = new VerticalTaskbar({
      props: {
        $$slots: { default: [create_default_slot$2] },
        $$scope: { ctx: $ },
      },
    })),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          create_component(v.$$.fragment);
      },
      m(x, S) {
        mount_component(r, x, S),
          insert(x, p, S),
          mount_component(v, x, S),
          (k = !0);
      },
      i(x) {
        k ||
          (transition_in(r.$$.fragment, x),
          transition_in(v.$$.fragment, x),
          (k = !0));
      },
      o(x) {
        transition_out(r.$$.fragment, x),
          transition_out(v.$$.fragment, x),
          (k = !1);
      },
      d(x) {
        destroy_component(r, x), x && detach(p), destroy_component(v, x);
      },
    }
  );
}
function create_default_slot_1($) {
  let r, p;
  return (
    (r = new StartButton({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_default_slot$2($) {
  let r, p;
  return (
    (r = new StartButton({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$13($) {
  let r, p, v, k, x, S, I, F, O, L, U;
  (r = new Shade({})), (v = new StartMenu({}));
  const N = [create_if_block$v, create_else_block$9],
    j = [];
  function R(q, Q) {
    return q[0].sh.taskbar.isLauncher ? 1 : 0;
  }
  return (
    (x = R($)),
    (S = j[x] = N[x]($)),
    (F = new ActionCenter({})),
    (L = new PushNotification({})),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          create_component(v.$$.fragment),
          (k = space()),
          S.c(),
          (I = space()),
          create_component(F.$$.fragment),
          (O = space()),
          create_component(L.$$.fragment);
      },
      m(q, Q) {
        mount_component(r, q, Q),
          insert(q, p, Q),
          mount_component(v, q, Q),
          insert(q, k, Q),
          j[x].m(q, Q),
          insert(q, I, Q),
          mount_component(F, q, Q),
          insert(q, O, Q),
          mount_component(L, q, Q),
          (U = !0);
      },
      p(q, [Q]) {
        let K = x;
        (x = R(q)),
          x !== K &&
            (group_outros(),
            transition_out(j[K], 1, 1, () => {
              j[K] = null;
            }),
            check_outros(),
            (S = j[x]),
            S || ((S = j[x] = N[x](q)), S.c()),
            transition_in(S, 1),
            S.m(I.parentNode, I));
      },
      i(q) {
        U ||
          (transition_in(r.$$.fragment, q),
          transition_in(v.$$.fragment, q),
          transition_in(S),
          transition_in(F.$$.fragment, q),
          transition_in(L.$$.fragment, q),
          (U = !0));
      },
      o(q) {
        transition_out(r.$$.fragment, q),
          transition_out(v.$$.fragment, q),
          transition_out(S),
          transition_out(F.$$.fragment, q),
          transition_out(L.$$.fragment, q),
          (U = !1);
      },
      d(q) {
        destroy_component(r, q),
          q && detach(p),
          destroy_component(v, q),
          q && detach(k),
          j[x].d(q),
          q && detach(I),
          destroy_component(F, q),
          q && detach(O),
          destroy_component(L, q);
      },
    }
  );
}
function instance$U($, r, p) {
  let v;
  return component_subscribe($, UserData, (k) => p(0, (v = k))), [v];
}
class Shell extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$U, create_fragment$13, safe_not_equal, {});
  }
}
const ArcShell = {
    info: {
      name: "ArcShell",
      description: "The ArcOS Shell",
      builtin: !0,
      version: ArcOSVersion,
      author: "ArcOS Team",
      icon: logo$d,
      custom: !0,
    },
    size: { w: NaN, h: NaN },
    pos: { x: 0, y: 0 },
    minSize: { w: NaN, h: NaN },
    maxSize: { w: NaN, h: NaN },
    controls: { min: !1, max: !1, cls: !1 },
    state: {
      headless: !0,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !0 },
    },
    content: Shell,
    glass: !1,
    events: {},
    disabledWarning: {
      title: "Limited functionality",
      message:
        "The ArcOS Shell is disabled, rendering the taskbar, start menu and action center unusable.<br><br>You can still access ArcFind using <b>Alt+Shift+S</b> or the Application Manager using <b>Alt+Shift+Z</b>.",
    },
    contextMenu: {
      "shell-taskbar": [
        {
          caption: "Application Manager",
          action: () => {
            openWindow("AppMan");
          },
        },
        SEP_ITEM,
        {
          icon: "settings",
          caption: "Shell settings",
          action: () => {
            openWindow("SettingsApp"),
              setTimeout(() => {
                openByKey("Shell");
              });
          },
        },
      ],
    },
  },
  showShellShade = writable(!1),
  SaveNewFile_svelte_svelte_type_style_lang = "";
function create_fragment$12($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K, V;
  return {
    c() {
      (r = element("div")),
        (p = element("img")),
        (k = space()),
        (x = element("div")),
        (S = element("p")),
        (S.textContent = "Enter a path to save this file to:"),
        (I = space()),
        (F = element("input")),
        (O = space()),
        (L = element("div")),
        (U = element("div")),
        (N = element("button")),
        (j = text("Save")),
        (q = space()),
        (Q = element("button")),
        (Q.textContent = "Cancel"),
        src_url_equal(p.src, (v = icon)) || attr(p, "src", v),
        attr(p, "alt", "Save File"),
        attr(p, "class", "svelte-demxce"),
        attr(S, "class", "caption svelte-demxce"),
        attr(F, "type", "text"),
        attr(F, "class", "svelte-demxce"),
        attr(x, "class", "inner"),
        attr(r, "class", "wrapper svelte-demxce"),
        (N.disabled = R = !$[0]),
        attr(U, "class", "inner svelte-demxce"),
        attr(L, "class", "actions svelte-demxce");
    },
    m(H, G) {
      insert(H, r, G),
        append(r, p),
        append(r, k),
        append(r, x),
        append(x, S),
        append(x, I),
        append(x, F),
        set_input_value(F, $[0]),
        insert(H, O, G),
        insert(H, L, G),
        append(L, U),
        append(U, N),
        append(N, j),
        append(U, q),
        append(U, Q),
        K ||
          ((V = [
            listen(F, "input", $[3]),
            listen(N, "click", $[2]),
            listen(Q, "click", $[1]),
          ]),
          (K = !0));
    },
    p(H, [G]) {
      G & 1 && F.value !== H[0] && set_input_value(F, H[0]),
        G & 1 && R !== (R = !H[0]) && (N.disabled = R);
    },
    i: noop$1,
    o: noop$1,
    d(H) {
      H && detach(r), H && detach(O), H && detach(L), (K = !1), run_all(V);
    },
  };
}
function instance$T($, r, p) {
  let v = "";
  function k() {
    hideOverlay("saveNewFile", "TextEditor");
  }
  async function x() {
    await saveTextEditorFile(get_store_value(TextEditorContent), {
      name: null,
      path: v,
      data: null,
      mime: "",
    });
    const I = v.split("/");
    await openUserFile({
      filename: I[I.length - 1],
      mime: "text/plain",
      scopedPath: v,
    }),
      k();
  }
  function S() {
    (v = this.value), p(0, v);
  }
  return [v, k, x, S];
}
class SaveNewFile extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$T, create_fragment$12, safe_not_equal, {});
  }
}
const TextEditor = {
    info: {
      name: "Text Editor",
      description: "Edit plain text files",
      builtin: !0,
      version: "1.0.0",
      author: "Izaak Kuipers",
      hidden: !1,
      icon: logo$c,
    },
    size: { w: 700, h: 550 },
    pos: { x: 30, y: 40, centered: !0 },
    minSize: { w: 400, h: 300 },
    maxSize: { w: 1e3, h: 800 },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: TextView,
    glass: !0,
    fileMimes: ["text/plain; charset=utf-8"],
    overlays: {
      saveNewFile: {
        info: { name: "Save file", author: "Izaak Kuipers", version: "1.0.1" },
        size: { w: NaN, h: NaN },
        show: !1,
        content: SaveNewFile,
      },
    },
  },
  desktopicons = "";
function create_fragment$11($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I = $[0].info.name + "",
    F,
    O,
    L;
  return {
    c() {
      (r = element("button")),
        (p = element("img")),
        (x = space()),
        (S = element("p")),
        (F = text(I)),
        src_url_equal(
          p.src,
          (v = getOriginalIcon($[0].id) || $[0].info.icon)
        ) || attr(p, "src", v),
        attr(p, "alt", (k = $[0].info.name)),
        attr(S, "class", "name"),
        attr(r, "class", "desktopIcon");
    },
    m(U, N) {
      insert(U, r, N),
        append(r, p),
        append(r, x),
        append(r, S),
        append(S, F),
        O || ((L = listen(r, "dblclick", $[1])), (O = !0));
    },
    p(U, [N]) {
      N & 1 &&
        !src_url_equal(
          p.src,
          (v = getOriginalIcon(U[0].id) || U[0].info.icon)
        ) &&
        attr(p, "src", v),
        N & 1 && k !== (k = U[0].info.name) && attr(p, "alt", k),
        N & 1 && I !== (I = U[0].info.name + "") && set_data(F, I);
    },
    i: noop$1,
    o: noop$1,
    d(U) {
      U && detach(r), (O = !1), L();
    },
  };
}
function instance$S($, r, p) {
  let { app: v } = r;
  function k() {
    openWindow(v.id);
  }
  return (
    ($.$$set = (x) => {
      "app" in x && p(0, (v = x.app));
    }),
    [v, k]
  );
}
class DesktopIcon extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$S, create_fragment$11, safe_not_equal, { app: 0 });
  }
}
function get_each_context$b($, r, p) {
  const v = $.slice();
  return (v[2] = r[p]), v;
}
function create_if_block$u($) {
  let r,
    p,
    v = $[1],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$b(get_each_context$b($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      r = element("div");
      for (let S = 0; S < k.length; S += 1) k[S].c();
      attr(r, "class", "desktopIcons"),
        toggle_class(r, "launcher", $[0].sh.taskbar.isLauncher),
        toggle_class(
          r,
          "undocked-launcher",
          $[0].sh.taskbar.isLauncher && !$[0].sh.taskbar.docked
        );
    },
    m(S, I) {
      insert(S, r, I);
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(r, null);
      p = !0;
    },
    p(S, I) {
      if (I & 2) {
        v = S[1];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$b(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$b(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
      (!p || I & 1) && toggle_class(r, "launcher", S[0].sh.taskbar.isLauncher),
        (!p || I & 1) &&
          toggle_class(
            r,
            "undocked-launcher",
            S[0].sh.taskbar.isLauncher && !S[0].sh.taskbar.docked
          );
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      S && detach(r), destroy_each(k, S);
    },
  };
}
function create_if_block_1$a($) {
  let r, p;
  return (
    (r = new DesktopIcon({ props: { app: $[2] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 2 && (x.app = v[2]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$b($) {
  let r = isPopulatable($[2]),
    p,
    v,
    k = r && create_if_block_1$a($);
  return {
    c() {
      k && k.c(), (p = empty());
    },
    m(x, S) {
      k && k.m(x, S), insert(x, p, S), (v = !0);
    },
    p(x, S) {
      S & 2 && (r = isPopulatable(x[2])),
        r
          ? k
            ? (k.p(x, S), S & 2 && transition_in(k, 1))
            : ((k = create_if_block_1$a(x)),
              k.c(),
              transition_in(k, 1),
              k.m(p.parentNode, p))
          : k &&
            (group_outros(),
            transition_out(k, 1, 1, () => {
              k = null;
            }),
            check_outros());
    },
    i(x) {
      v || (transition_in(k), (v = !0));
    },
    o(x) {
      transition_out(k), (v = !1);
    },
    d(x) {
      k && k.d(x), x && detach(p);
    },
  };
}
function create_fragment$10($) {
  let r,
    p,
    v = $[0].sh.desktop.icons && create_if_block$u($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[0].sh.desktop.icons
        ? v
          ? (v.p(k, x), x & 1 && transition_in(v, 1))
          : ((v = create_if_block$u(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$R($, r, p) {
  let v, k;
  return (
    component_subscribe($, UserData, (x) => p(0, (v = x))),
    component_subscribe($, WindowStore, (x) => p(1, (k = x))),
    [v, k]
  );
}
class DesktopIcons extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$R, create_fragment$10, safe_not_equal, {});
  }
}
const snapzones = "",
  draggingId = writable(),
  leftZoneTriggered = writable(!1),
  rightZoneTriggered = writable(!1);
function create_fragment$$($) {
  let r, p, v, k;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = space()),
        (k = element("div")),
        attr(p, "class", "visualizer"),
        attr(p, "id", "snapZoneLeft"),
        toggle_class(p, "triggered", $[0]),
        attr(k, "class", "trigger"),
        attr(k, "id", "snapTriggerLeft"),
        attr(r, "class", "leftzone");
    },
    m(x, S) {
      insert(x, r, S), append(r, p), append(r, v), append(r, k);
    },
    p(x, [S]) {
      S & 1 && toggle_class(p, "triggered", x[0]);
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r);
    },
  };
}
function instance$Q($, r, p) {
  let v;
  return component_subscribe($, leftZoneTriggered, (k) => p(0, (v = k))), [v];
}
class LeftZone extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$Q, create_fragment$$, safe_not_equal, {});
  }
}
function create_fragment$_($) {
  let r, p, v, k;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = space()),
        (k = element("div")),
        attr(p, "class", "visualizer"),
        attr(p, "id", "snapZoneRight"),
        toggle_class(p, "triggered", $[0]),
        attr(k, "class", "trigger"),
        attr(k, "id", "snapTriggerRight"),
        attr(r, "class", "rightzone");
    },
    m(x, S) {
      insert(x, r, S), append(r, p), append(r, v), append(r, k);
    },
    p(x, [S]) {
      S & 1 && toggle_class(p, "triggered", x[0]);
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      x && detach(r);
    },
  };
}
function instance$P($, r, p) {
  let v;
  return component_subscribe($, rightZoneTriggered, (k) => p(0, (v = k))), [v];
}
class RightZone extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$P, create_fragment$_, safe_not_equal, {});
  }
}
function create_fragment$Z($) {
  let r, p, v, k, x;
  return (
    (p = new LeftZone({})),
    (k = new RightZone({})),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          create_component(k.$$.fragment),
          attr(r, "class", "snapzones"),
          set_style(r, "z-index", $[1] + 5),
          toggle_class(r, "docked", $[0].sh.taskbar.docked),
          toggle_class(r, "launcher", $[0].sh.taskbar.isLauncher);
      },
      m(S, I) {
        insert(S, r, I),
          mount_component(p, r, null),
          append(r, v),
          mount_component(k, r, null),
          (x = !0);
      },
      p(S, [I]) {
        (!x || I & 2) && set_style(r, "z-index", S[1] + 5),
          (!x || I & 1) && toggle_class(r, "docked", S[0].sh.taskbar.docked),
          (!x || I & 1) &&
            toggle_class(r, "launcher", S[0].sh.taskbar.isLauncher);
      },
      i(S) {
        x ||
          (transition_in(p.$$.fragment, S),
          transition_in(k.$$.fragment, S),
          (x = !0));
      },
      o(S) {
        transition_out(p.$$.fragment, S),
          transition_out(k.$$.fragment, S),
          (x = !1);
      },
      d(S) {
        S && detach(r), destroy_component(p), destroy_component(k);
      },
    }
  );
}
function instance$O($, r, p) {
  let v, k;
  return (
    component_subscribe($, UserData, (x) => p(0, (v = x))),
    component_subscribe($, maxZIndex, (x) => p(1, (k = x))),
    [v, k]
  );
}
class SnapZones extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$O, create_fragment$Z, safe_not_equal, {});
  }
}
function create_fragment$Y($) {
  let r, p, v, k, x;
  return (
    (p = new DesktopIcons({})),
    (k = new SnapZones({})),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          create_component(k.$$.fragment),
          attr(r, "class", "wallpaper fullscreen"),
          set_style(r, "background-image", "url(" + $[0] + ")"),
          attr(r, "data-caller", "shell-wallpaper");
      },
      m(S, I) {
        insert(S, r, I),
          mount_component(p, r, null),
          insert(S, v, I),
          mount_component(k, S, I),
          (x = !0);
      },
      p(S, [I]) {
        (!x || I & 1) && set_style(r, "background-image", "url(" + S[0] + ")");
      },
      i(S) {
        x ||
          (transition_in(p.$$.fragment, S),
          transition_in(k.$$.fragment, S),
          (x = !0));
      },
      o(S) {
        transition_out(p.$$.fragment, S),
          transition_out(k.$$.fragment, S),
          (x = !1);
      },
      d(S) {
        S && detach(r),
          destroy_component(p),
          S && detach(v),
          destroy_component(k, S);
      },
    }
  );
}
function instance$N($, r, p) {
  let v;
  component_subscribe($, UserData, (x) => p(1, (v = x)));
  let k = "";
  return (
    UserData.subscribe(async () => {
      const x = await getWallpaper(v.sh.desktop.wallpaper);
      x != k && p(0, (k = x));
    }),
    [k]
  );
}
class Wallpaper extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$N, create_fragment$Y, safe_not_equal, {});
  }
}
const DesktopWallpaper = {
  info: {
    name: "Wallpaper",
    description: "The ArcOS wallpaper",
    builtin: !0,
    version: ArcOSVersion,
    author: "ArcOS Team",
    icon: logo$1,
    custom: !0,
  },
  size: { w: NaN, h: NaN },
  pos: { x: 0, y: 0 },
  minSize: { w: NaN, h: NaN },
  maxSize: { w: NaN, h: NaN },
  controls: { min: !1, max: !1, cls: !1 },
  state: {
    headless: !0,
    resizable: !1,
    windowState: { min: !1, max: !1, fll: !0 },
  },
  content: Wallpaper,
  glass: !1,
  events: {},
  disabledWarning: {
    title: "No Wallpaper",
    message:
      "The Wallpaper is disabled, so you don't have a wallpaper or any desktop icons. Please re-enable the DesktopWallpaper application to return this fuctionality.",
  },
  contextMenu: {
    "shell-wallpaper": [
      {
        caption: "Show desktop icons",
        action: () => {
          const $ = get_store_value(UserData);
          ($.sh.desktop.icons = !$.sh.desktop.icons), UserData.set($);
        },
        icon: "apps",
        isActive: () => get_store_value(UserData).sh.desktop.icons,
      },
      SEP_ITEM,
      {
        caption: "File Manager",
        action: () => {
          openWindow("FileManager");
        },
        image: fileManager,
      },
      {
        caption: "Application Manager",
        action: () => {
          openWindow("AppMan");
        },
        image: appMan,
      },
      {
        caption: "App settings",
        action: () => {
          openByKey("Apps");
        },
        image: appSettings,
      },
      SEP_ITEM,
      { caption: "Shut down", action: shutdown, icon: "power_settings_new" },
      { caption: "Restart", action: () => restart$1(!1), icon: "refresh" },
      SEP_ITEM,
      {
        caption: "Personalize",
        action: () => {
          openByKey("Appearance");
        },
        image: appearance,
      },
    ],
  },
};
function generateCSS($, r) {
  let p = "";
  return (
    (p += `min-width: ${$.minSize.w}px;`),
    (p += `min-height: ${$.minSize.h}px;`),
    (p += `max-width: ${$.maxSize.w}px;`),
    (p += `max-height: ${$.maxSize.h}px;`),
    r && ((p += `left: ${$.pos.x}px;`), (p += `top: ${$.pos.y}px;`)),
    (p += `width: ${$.size.w}px;`),
    (p += `height: ${$.size.h}px;`),
    p
  );
}
function generateOverlayCSS($) {
  let r = "";
  return (
    (r += `min-width: ${$.size.w}px;`),
    (r += `min-height: ${$.size.h}px;`),
    (r += `max-width: ${$.size.w}px;`),
    (r += `max-height: ${$.size.h}px;`),
    (r += `width: ${$.size.w}px;`),
    (r += `height: ${$.size.h}px;`),
    r
  );
}
function centerWindow($) {
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++)
    r[p].id == $ && ((r[p].pos = calculatePos(r[p])), WindowStore.set(r));
}
function calculatePos($) {
  const r = getWindowElement($),
    p = r.offsetWidth,
    v = r.offsetHeight,
    k = document.body.offsetWidth,
    x = document.body.offsetHeight,
    S = (k - p) / 2,
    I = (x - v) / 2;
  return (
    (r.style.left = `${S}px`),
    (r.style.top = `${I}px`),
    { x: S, y: I, centered: !0 }
  );
}
function loadWindow($, r) {
  if (isLoaded($))
    return Log({
      level: LogLevel.error,
      msg: `Window ${$} already exists in WindowStore.`,
      source: "AppLogic: loadWindow",
    });
  const p = get_store_value(WindowStore),
    v = { ...r, id: $ },
    k = [],
    x = Object.entries(v.children || {});
  for (let F = 0; F < x.length; F++)
    k.push({
      ...x[F][1],
      id: x[F][0],
      parentId: $,
      opened: !1,
      info: { ...x[F][1].info, hidden: !0 },
    });
  const S = get_store_value(UserData);
  S.disabledApps || ((S.disabledApps = []), UserData.set(S)),
    S &&
      S.disabledApps.includes($) &&
      !SystemApps.includes($) &&
      (v.disabled = !0),
    p.push(v);
  for (let F = 0; F < k.length; F++) p.push(k[F]);
  WindowStore.set(p), registerAppShortcuts($, r);
  const I = get_store_value(UserData).disabledApps;
  r.disabledWarning &&
    I.includes($) &&
    makeNotification({
      ...r.disabledWarning,
      buttons: [],
      image: r.info.icon,
      timeout: 6e3,
    }),
    setTimeout(() => {
      r.pos.centered && centerWindow($);
    }, 300),
    Log({
      level: LogLevel.info,
      msg: `Loaded ${$} into WindowStore.`,
      source: "AppLogic: loadWindow",
    });
}
const arcterm$1 = "";
function getSwitches($) {
  Log({
    source: "ArcTerm",
    msg: `getSwitches: parsing argv with ${$.length} items...`,
    level: LogLevel.info,
  });
  let r = {},
    p = "";
  const v = "--";
  for (let k = 0; k < $.length; k++)
    if ($[k].startsWith(v)) {
      const x = $[k].replace(v, "");
      (p = x == p ? p : x), r[p] || (r[p] = "");
    } else p && (r[p] += `${$[k]} `);
  for (const k in r) r[k] = r[k].trim();
  return r;
}
function switchExists($, r) {
  Log({ source: "ArcTerm", msg: `switchExists: ${r}`, level: LogLevel.info });
  const p = getSwitches($);
  for (const v in p) if (v == r) return !0;
  return !1;
}
const AppList = {
  keyword: "applist",
  exec($, r, p) {
    const v = switchExists(r, "open")
      ? getOpenedStore()
      : get_store_value(WindowStore);
    header(p);
    for (let k = 0; k < v.length; k++) output(p, v[k]);
  },
  description: "List all- or opened ArcOS apps.",
  syntax: "([opened?])",
};
function output($, r) {
  const p = r.id.padEnd(30, " "),
    v = r.info.name.padEnd(30, " "),
    k = r.info.version;
  $.std.writeColor(`${v}[${p}]${k}`, "gray");
}
function header($) {
  const r = "Name".padEnd(30, " "),
    p = "ID".padEnd(30, " "),
    k = `${r}${p}Version`;
  $.std.writeColor(`[${k}]`, "yellow"), $.std.writeSeperator(k.length);
}
const colors = "red,orange,yellow,green,aqua,blue,purple".split(","),
  ArcFetch = {
    keyword: "arcfetch",
    async exec($, r, p) {
      p.std.writeLine(`
`),
        await graphic(p),
        p.std.writeLine(""),
        colorBar(p);
    },
    description: "Show system information",
  };
async function getItems($) {
  const r = getDeviceInfo(),
    p = await inTauri();
  return Object.entries({
    Server: `${localStorage.getItem("arcos-server")} @ rev ${minArcAPI}`,
    Username: get_store_value(UserName),
    Processor: `${r.cpu.cores} cores`,
    GPU: `${r.gpu.vendor} ${r.gpu.model}`,
    Memory: `~ ${formatBytes(r.mem.kb)}`,
    Mode:
      (p ? "Desktop" : "Browser") +
      ` (state ${get_store_value(CurrentState).key})`,
    Reference: $.referenceId,
  });
}
function colorBar($) {
  $.std.write(`
                            `);
  for (let r = 0; r < colors.length; r++)
    $.std.writeColor("[██ ]", colors[r], "white", !0);
}
async function graphic($) {
  const r = await getItems($),
    p = [
      "        ",
      "    _   ",
      "   /_\\  ",
      "  / _ \\ ",
      " /_/ \\_\\",
      "        ",
      "        ",
    ];
  for (let v = 0; v < p.length; v++)
    $.std.writeColor(`  [${p[v]}]    `, "blue", "white", !0),
      r[v] &&
        $.std.writeColor(
          `[${r[v][0].padEnd(12, " ")}]: ${r[v][1]}`,
          "purple",
          "white",
          !0
        ),
      $.std.writeLine("");
}
const ATConf = {
    keyword: "atconf",
    async exec($, r, p) {
      const v = {
        name: "arcterm.conf",
        path: p.env.config.configPath,
        data: await readFile(p.env.config.configPath),
        mime: "application/json",
      };
      FileLoaders.editFile.loader(v);
    },
    description: "Edit ArcTerm configuration",
  },
  Cd = {
    keyword: "cd",
    async exec($, r, p) {
      const v = r.join(" "),
        k = (p.path != "./" ? `${p.path}/${v}` : v).replaceAll("//", "/");
      if (v == "..") {
        p.path = getParentDirectory(p.path);
        return;
      }
      if (v != ".") {
        if (!(await getDirectory(k)))
          return p.std.writeLine(`Can't change to "${v}": Path not found`);
        p.path = k;
      }
    },
    description: "Change directory",
    syntax: "[<path>]",
  },
  Clear = {
    keyword: "clear",
    exec($, r, p) {
      (p.input.current = null),
        setTimeout(() => {
          p.std.clear(), p.input.unlock();
        });
    },
    description: "Clears the screen",
  },
  Colors = {
    keyword: "colors",
    exec($, r, p) {
      const v =
          r.join(" ").trim() || "The quick brown fox jumps over the lazy dog.",
        k = [
          "gray",
          "white",
          "red",
          "orange",
          "yellow",
          "green",
          "aqua",
          "blue",
          "purple",
        ];
      for (let x = 0; x < k.length; x++)
        p.std.writeColor(`${k[x].padEnd(10, " ")}: [${v}]`, k[x]);
    },
    description: "Print out all ArcTerm colors",
    syntax: "([sample?])",
  },
  Dir = {
    keyword: "dir",
    async exec($, r, p) {
      const v = p.path,
        k = await getDirectory(v),
        x = k.directories,
        S = k.files;
      let I = 0;
      p.std.writeColor(
        `
Directory contents of [${v}]
`,
        "blue"
      );
      for (let L = 0; L < x.length; L++) {
        const U = x[L].name,
          N = "     <DIR>";
        p.std.writeColor(`[${N}] ${U}`, "gray", "white");
      }
      for (let L = 0; L < S.length; L++) {
        const U = S[L].filename,
          N = `${S[L].size}`.padStart(10, " ");
        (I += S[L].size), p.std.writeColor(`[${N}] ${U}`, "gray", "white");
      }
      p.std.writeLine("");
      const F = formatBytes(I).padStart(10, " "),
        O = `(${I} bytes)`;
      p.std.writeLine(`${F} ${O}`);
    },
    description: "List the contents of the current directory",
    syntax: "<[path]>",
  },
  Echo = {
    keyword: "echo",
    exec($, r, p) {
      const v = r.join(" ").match(/"(.*?)"/);
      if (v && v.length > 1) {
        const k = p.vars.replace(v[1]);
        p.std.writeLine(k);
        return;
      }
      p.std.Error("Unable to echo: syntax invalid!");
    },
    description: "Echo a string.",
    syntax: '"<[string]>"',
  },
  Vars = {
    keyword: "vars",
    async exec($, r, p) {
      const v = Object.entries(await p.vars.getAll());
      for (let k = 0; k < v.length; k++) {
        if (!v[k][1].value) continue;
        const x = v[k][1].value,
          S = v[k][0].padEnd(20, " "),
          I = v[k][1].readOnly ? "#" : " ";
        p.std.writeColor(`${I} [${S}]: `, "aqua", "white", !0),
          p.std.write(`${x}`),
          p.std.writeLine("");
      }
    },
    description: "List the variables",
  },
  Exit = {
    keyword: "exit",
    exec($, r, p) {
      if (!p.app)
        return p.std.Error(
          "can't close ArcTerm: no associated app in constructor"
        );
      closeWindow(p.app.id);
    },
    description: "Quit ArcTerm",
  },
  Help = {
    keyword: "help",
    exec($, r, p) {
      if (switchExists(r, "count"))
        return p.std.writeColor(
          `ArcTerm has [${p.commands.length}] commands.`,
          "aqua"
        );
      if (r[0]) return specific(r[0], p);
      all(p);
    },
    description: "Display a list of built-in commands",
    syntax: "([command?])",
  };
function all($) {
  const r = $.commands.sort((p, v) => (v.keyword < p.keyword ? 1 : -1));
  for (let p = 0; p < r.length; p++) {
    const v = r[p].keyword.toUpperCase().padEnd(15, " "),
      k = r[p].description;
    $.std.writeColor(`[${v}]${k}`, "orange");
  }
}
function specific($, r) {
  const p = r.commandHandler.getCommand($);
  if (!p || p.keyword == defaultCommand.keyword)
    return r.std.Error(`${$}: command not found.`);
  r.std.writeColor(`[${p.keyword.toUpperCase()}]: ${p.description}`, "blue"),
    r.std.writeLine(`
`),
    r.std.writeColor(`Usage: [${p.keyword}] ${p.syntax || ""}`, "blue");
}
const History = {
  keyword: "history",
  exec($, r, p) {
    if (r.includes("clear")) return clear(p);
    const v = p.commandHandler.history;
    for (let k = 0; k < v.length; k++) {
      const x = `${k}`.padStart(3, "0");
      p.std.writeColor(`[${x}]: ${v[k]}`, "yellow");
    }
  },
  description: "Show the command history",
  syntax: "([clear?])",
};
function clear($) {
  const r = $.commandHandler.history.length;
  ($.commandHandler.history = []),
    $.std.writeColor(
      `[SUCCESS]: History cleared, ${r} items removed.`,
      "green"
    );
}
const Kill = {
    keyword: "kill",
    exec($, r, p) {
      const v = r[0];
      if (!v) return p.std.Error("Missing application ID.");
      const k = getWindow(v);
      if (!k) return p.std.Error(`${v}: app not found.`);
      closeWindow(v), p.std.writeLine(`Closed ${k.info.name}`);
    },
    description: "Terminate a program",
    syntax: '"<[appId]>"',
  },
  LogDump = {
    keyword: "logdump",
    async exec($, r, p) {
      const v = `LogDump-${Math.floor(Math.random() * 1e9)}.txt`;
      p.std.writeColor(
        `Writing log to [./${v}]...
`,
        "purple"
      );
      const k = get_store_value(log);
      let x = `-- [START OF LOG] --
`;
      const S = k.length,
        I = p.std.writeColor(`Item [0] of [${S}] processed.`, "blue");
      for (let O = 0; O < k.length; O++) {
        const L = O + 1,
          U = Math.floor((100 / S) * (O + 1));
        p.std.updateColor(
          I,
          `Item [${L}] of [${S}] ([${U}%]) processed.`,
          "blue"
        ),
          (x += `[${k[O].timestamp} | ${k[O].source}] ${k[O].msg}
`),
          await sleep(5);
      }
      const F = new Blob([x], { type: "text/plain" });
      await writeFile(`./${v}`, F),
        p.vars.set("ldout", v),
        p.std.writeColor(
          `
Wrote [${x.length}] bytes.`,
          "purple"
        ),
        fbClass.refresh();
    },
    description: "Dump the log to a file",
  },
  Mkdir = {
    keyword: "mkdir",
    async exec($, r, p) {
      const v = p.path,
        k = r.join(" "),
        x = (v != "./" ? `${v}/${k}` : k).replaceAll("//", "/");
      await createDirectory(x), p.std.writeLine(`Directory '${k}' created.`);
    },
    description: "Create a directory",
    syntax: '"<[name]>"',
  },
  oa = {
    keyword: "oa",
    exec($, r, p) {
      const v = get_store_value(WindowStore);
      for (let k = 0; k < v.length; k++)
        v[k].info.custom ||
          (p.std.writeColor(`Opening [${v[k].id}]`, "orange"),
          openWindow(v[k].id, !0));
    },
    description: "Open all apps",
  },
  Open = {
    keyword: "open",
    exec($, r, p) {
      const v = r[0],
        k = getWindow(v);
      if (!k) return p.std.Error(`${v}: app not found.`);
      openWindow(v, !0), p.std.writeLine(`Opened ${k.info.name}`);
    },
    description: "Open a window",
    syntax: '"<[appId]>"',
  };
class ArcTermConfig {
  constructor(r, p) {
    me(this, "env");
    me(this, "configPath", "./arcterm.conf");
    me(this, "configKeys", ["prompt", "greeting", "logo", "promptColor"]);
    Log({
      source: `ArcTerm ${p.referenceId}`,
      msg: "Creating new ArcTermConfig",
      level: LogLevel.info,
    }),
      (this.env = r),
      this.loadConfigFile();
  }
  getConfig() {
    const r = {};
    for (let p = 0; p < this.configKeys.length; p++) {
      const v = this.configKeys[p];
      r[v] = this.env[v];
    }
    return r;
  }
  loadConfig(r) {
    for (let p = 0; p < this.configKeys.length; p++) {
      const v = this.configKeys[p],
        k = this.env[v] != null && r,
        x = typeof this.env[v] == typeof r[v];
      k && x && (this.env[v] = r[v]);
    }
  }
  async loadConfigFile() {
    if (!get_store_value(UserData)) return;
    const r = await readFile(this.configPath);
    if (!r) return this.writeConfig();
    const v = new TextDecoder("utf-8").decode(new Uint8Array(r));
    let k;
    try {
      k = JSON.parse(v);
    } catch {
      k = {};
    }
    this.loadConfig(k);
  }
  async writeConfig() {
    const r = {};
    for (let v = 0; v < this.configKeys.length; v++) {
      const k = this.configKeys[v];
      r[k] = this.env[k];
    }
    const p = new Blob([JSON.stringify(r, null, 2)], {
      type: "application/json",
    });
    await writeFile(this.configPath, p);
  }
}
class ArcTermEnv {
  constructor(r) {
    me(this, "config");
    me(this, "prompt", "[&u]: [~/&p] $ ");
    me(this, "promptColor", "green");
    me(
      this,
      "greeting",
      `ArcTerm & ArcOS v${ArcOSVersion}

Licensed under GPLv3. Created by the ArcOS team.`
    );
    me(this, "logo", !0);
    Log({
      source: `ArcTerm ${r.referenceId}`,
      msg: "Creating new ArcTermEnv",
      level: LogLevel.info,
    }),
      (this.config = new ArcTermConfig(this, r));
  }
}
const Reload = {
    keyword: "reload",
    async exec($, r, p) {
      p.dispose(),
        setTimeout(async () => {
          await p.initialize();
        });
    },
    description: "Reload the ArcTerm configuration",
  },
  Restart$1 = {
    keyword: "restart",
    exec($, r, p) {
      if (get_store_value(CurrentState).key == "desktop") return restart$1(!1);
      p.std.writeColor("[RESTART]: Terminating NOW.", "green"),
        setTimeout(() => {
          location.reload();
        }, 1e3);
    },
    description: "Restart ArcOS",
  },
  Rf = {
    keyword: "rf",
    async exec($, r, p) {
      const v = p.path,
        k = r.join(" ").trim(),
        x = await getDirectory(v);
      for (let S = 0; S < x.files.length; S++) {
        const I = x.files[S];
        if (I.filename == k) {
          const F = await readFile(I.scopedPath);
          if (!F) return p.std.Error("Could not read the file.");
          if (!I.mime.includes("text/"))
            return p.std.Error("Not attempting to read non-text file.");
          const L = new TextDecoder("utf-8").decode(new Uint8Array(F));
          p.std.writeLine(L);
          return;
        }
      }
      p.std.Error("The file doesn't exist on ArcFS.");
    },
    description: "Read a file from ArcFS",
    syntax: "<[filename]>",
  },
  DEFSIZE = 20,
  Ri = {
    keyword: "ri",
    async exec($, r, p) {
      const v = getSwitches(r),
        k = v.file,
        x = v.url;
      let S;
      try {
        S = parseInt(v.height);
      } catch {
        S = DEFSIZE;
      }
      if (
        (p.std.writeLine(`
`),
        k)
      )
        return await displayFile(p, k, S || DEFSIZE);
      if (x) return displayUrl(p, x, S || DEFSIZE);
      p.std.Error("Missing parameters.");
    },
    description: "Display image from ArcFS or URL",
  };
async function displayFile($, r, p) {
  const v = $.path,
    k = await getDirectory(v);
  for (let x = 0; x < k.files.length; x++) {
    const S = k.files[x];
    if (S.filename == r) {
      const I = await readFile(S.scopedPath);
      if (!I) return $.std.Error("Could not read the file.");
      const F = new Blob([new Uint8Array(I)], { type: S.mime }),
        O = URL.createObjectURL(F);
      $.std.writeImage(O, p);
      return;
    }
  }
}
function displayUrl($, r, p) {
  $.std.writeImage(r, p || DEFSIZE);
}
const Rm = {
    keyword: "rm",
    async exec($, r, p) {
      const v = p.path,
        k = r.join(" "),
        x = (v != "./" ? `${v}/${k}` : k).replaceAll("//", "/");
      try {
        await deleteItem(x);
      } catch {
        p.std.Error(`Unable to delete "${k}"`);
      }
    },
    description: "Delete a file or folder",
    syntax: '"<[name]>"',
  },
  Run = {
    keyword: "run",
    async exec($, r, p) {
      const v = p.path,
        k = r.join(" ").trim(),
        x = await getDirectory(v);
      for (let S = 0; S < x.files.length; S++) {
        const I = x.files[S];
        if (I.filename == k) {
          p.std.writeLine(`Opening ${k} (${I.size} Bytes)`), o(I);
          return;
        }
      }
      p.std.Error("The file doesn't exist on ArcFS.");
    },
    description: "Run a file from your ArcFS account.",
    syntax: '"<[filename]>"',
  };
async function o($) {
  const r = $.scopedPath;
  r.startsWith("./") && ($.scopedPath = r.replace("./", ""));
  const p = await openUserFile($);
  WindowStore.set(get_store_value(WindowStore)),
    p != !0 && openWithDialog({ ...p, anymime: !0 });
}
const Set$1 = {
    keyword: "set",
    async exec($, r, p) {
      const v = r[0],
        k = r.join(" ").match(/"(.*?)"/);
      if (!k || k.length < 2) {
        (await p.vars.delete(v)) ||
          p.std.Error(
            "Can't delete variable: deletion isn't allowed or the variable is read-only."
          );
        return;
      }
      const x = k[1];
      (await p.vars.set(v, x)) ||
        p.std.Error("Can't update variable: the variable is readonly.");
    },
    description: "Set a variable",
    syntax: '<[key]> "<[value]>"',
  },
  Shutdown$1 = {
    keyword: "shutdown",
    exec($, r, p) {
      if (get_store_value(CurrentState).key == "desktop") return shutdown();
      p.std.writeColor("[SHUTDOWN]: Terminating NOW.", "green"),
        setTimeout(() => {
          applyState("turnedoff");
        }, 1e3);
    },
    description: "Turn off ArcOS",
  },
  Tauri = {
    keyword: "tauri",
    async exec($, r, p) {
      const v = await inTauri();
      p.std.writeColor(
        `[STATUS]: You are ${v ? "in the Desktop app" : "in the Web version"}`,
        "aqua"
      );
    },
    description: "Check if you are in the desktop app or not",
  },
  UDD = {
    keyword: "udd",
    async exec($, r, p) {
      const v = `./UserDump-${Math.floor(Math.random() * 1e9)}.txt`;
      p.std.writeColor(
        `Writing log to [${v}]...
`,
        "purple"
      );
      const k = new Blob([JSON.stringify(get_store_value(UserData), null, 2)], {
        type: "text/plain",
      });
      await writeFile(v, k);
    },
    description: "Dump the userdata to a file",
  },
  Users = {
    keyword: "users",
    async exec($, r, p) {
      const v = await getUsers(),
        k = Object.entries(v),
        x = Object.keys(v);
      for (let S = 0; S < k.length; S++) {
        const I = k[S][1].acc.admin ? "Administrator" : "Regular user",
          F = k[S][0].padEnd(getMaxLength(x), " ");
        p.std.writeColor(`[${F}]: ${I}`, "blue");
      }
    },
    description: "Display ArcAPI users",
  };
function getMaxLength($) {
  let r = 0;
  for (let p = 0; p < $.length; p++) $[p].length > r && (r = $[p].length);
  return r + 5;
}
const Ver = {
    keyword: "ver",
    exec($, r, p) {
      p.std.writeColor(`ArcOS & ArcTerm [v${ArcOSVersion}]`, "blue");
    },
    description: "Display the version number",
  },
  Config = {
    keyword: "config",
    exec($, r, p) {
      const v = Object.entries(p.env.config.getConfig());
      for (let k = 0; k < v.length; k++) {
        const x = v[k][1].toString(),
          S = v[k][0].padEnd(20, " ");
        p.std.writeColor(`# [${S}]: `, "blue", "white", !0),
          p.std.write(`${x}`),
          p.std.writeLine("");
      }
    },
    description: "List configuration options",
  },
  Read = {
    keyword: "read",
    async exec($, r, p) {
      const v = getSwitches(r),
        k = v.prompt || "?",
        x = v.var,
        S = switchExists(r, "mask");
      x || p.std.Error("Missing variable");
      const I = await p.std.read(`${k} `, "", 100, S);
      p.vars.set(x, I) ||
        p.std.Error("Unable to set variable: it is read-only!");
    },
    description: "Read user input to a variable",
    syntax: "--[var]=[variable] --[mask]? --[prompt]?=[...]",
  },
  Reset = {
    keyword: "reset",
    async exec($, r, p) {
      if (
        (p.std
          .writeLine(`Are you sure you want to reset ArcOS? This will not affect any ArcAPI data.

`),
        (await p.std.read("Y/N [", "]", 1)).toLowerCase() != "y")
      )
        return p.std.Error("Reset aborted.");
      localStorage.clear(), location.reload(), await sleep(3e3);
    },
    description: "Reset local ArcOS instance",
  },
  Logout = {
    keyword: "logout",
    exec($, r, p) {
      if (p.app) return p.std.Error("This command requires ArcTerm Mode");
      localStorage.removeItem("arcos-remembered-token"),
        UserName.set(void 0),
        p.dispose(),
        setTimeout(() => {
          p.initialize();
        });
    },
    description: "Logout ArcTerm Mode",
  },
  Exec = {
    keyword: "exec",
    async exec($, r, p) {
      const v = p.path,
        k = r.join(" ").trim(),
        x = await getDirectory(v);
      for (let S = 0; S < x.files.length; S++) {
        const I = x.files[S];
        if (I.filename == k) {
          const F = await readFile(I.scopedPath);
          if (!F) return p.std.Error("Could not read the file.");
          if (!I.mime.includes("text/"))
            return p.std.Error("Not attempting to read non-text file.");
          const U = new TextDecoder("utf-8").decode(new Uint8Array(F)).split(`
`);
          p.input.processCommands(U);
          return;
        }
      }
    },
    description: "Execute ArcTerm commands from a file",
    syntax: "<[filename]>",
  },
  Verbose = {
    keyword: "verbose",
    exec($, r, p) {
      const v = switchExists(r, "off"),
        k = switchExists(r, "on");
      if (v && k) return p.std.Error("Can't accept both --on and --off.");
      if (!v && !k) return p.std.Error("Missing --on or --off.");
      k && (p.std.verbose = !0), v && (p.std.verbose = !1);
    },
    description: "Set verbose mode on or off.",
    syntax: "--[on]? --[off]?",
  },
  Desktop$1 = {
    keyword: "desktop",
    exec($, r, p) {
      if (p.app) return p.std.Error("You already are in the ArcOS desktop!");
      if (get_store_value(previouslyLoaded))
        return p.std.Error(
          "The desktop may not be initialized twice in one instance. Please use [RESTART]."
        );
      applyState("desktop");
    },
    description: "Switch to Desktop",
  },
  defaultCommand = {
    keyword: "default",
    exec: ($, r, p) => {
      $ && p.std.Error(`${$}: command not found.`);
    },
    description: "Default command",
  },
  arcCommands = [
    ArcFetch,
    Cd,
    Clear,
    Colors,
    Dir,
    Echo,
    Vars,
    Exit,
    Help,
    History,
    LogDump,
    Logout,
    Mkdir,
    Rm,
    Reload,
    Restart$1,
    Shutdown$1,
    Tauri,
    UDD,
    Ver,
    Reset,
    Rf,
    Ri,
    Users,
    Read,
    Set$1,
    Config,
    Exec,
    Verbose,
    Desktop$1,
  ],
  desktopSpecific = [AppList, ATConf, Kill, oa, Open, Run];
class ArcTermCommandHandler {
  constructor(r) {
    me(this, "term");
    me(this, "history", []);
    Log({
      source: `ArcTerm ${r.referenceId}`,
      msg: "Creating new ArcTermCommandHandler",
      level: LogLevel.info,
    }),
      (this.term = r);
  }
  async evaluate(r, p) {
    this.history.push(`${r} ${p.join(" ")}`.trim());
    const v = this.getCommand(r);
    this.term.input && (this.term.input.current.disabled = !0),
      await v.exec(r, p, this.term),
      !(!this.term.std || !this.term.input) &&
        (this.term.std.verbose &&
          this.term.std.writeLine(`
`),
        this.term.input.unlock());
  }
  getCommand(r) {
    const p = r.toLowerCase();
    for (let v = 0; v < this.term.commands.length; v++)
      if (this.term.commands[v].keyword.toLowerCase() == p)
        return this.term.commands[v];
    return defaultCommand;
  }
}
function initError($) {
  createOverlayableError(
    {
      title: "Can't initialize terminal",
      message:
        "The terminal instance is missing a valid target element. Please restart and try again.",
      buttons: [
        {
          caption: "Close",
          action() {
            closeWindow($);
          },
        },
      ],
      image: logo$7,
    },
    $
  );
}
class ArcTermInput {
  constructor(r) {
    me(this, "lockInput", !1);
    me(this, "target");
    me(this, "env");
    me(this, "term");
    me(this, "current");
    Log({
      source: `ArcTerm ${r.referenceId}`,
      msg: "Creating new ArcTermInput",
      level: LogLevel.info,
    }),
      (this.target = r.target),
      (this.env = r.env),
      (this.term = r),
      this.commandLoop();
  }
  commandLoop() {
    setInterval(() => {
      if (this.lockInput) return;
      this.lock();
      const r = this.createPrompt();
      r && this.target.append(r);
    });
  }
  lock() {
    this.lockInput = !0;
  }
  unlock() {
    this.lockInput = !1;
  }
  getPrompt() {
    const r = get_store_value(UserName),
      p = localStorage.getItem("arcos-server"),
      v = (this.term.path || "./").replace("./", "");
    return this.env.prompt.replace("&u", r).replace("&s", p).replace("&p", v);
  }
  createPrompt() {
    if ((this.current && (this.current.disabled = !0), !this.term.std)) return;
    const r = document.createElement("div"),
      p = document.createElement("div"),
      v = document.createElement("input");
    return (
      (r.className = "prompt"),
      this.term.std.writeColor(
        this.getPrompt(),
        this.env.promptColor,
        "white",
        !0,
        r
      ),
      (v.id = `input#${Math.floor(Math.random() * 1e9)}`),
      (v.spellcheck = !1),
      v.addEventListener("keydown", (k) => this.processInputEvent(k, v)),
      (this.current = v),
      (p.className = "inner"),
      p.append(v),
      r.append(p),
      setTimeout(() => {
        this.term.app &&
          get_store_value(focusedWindowId) == this.term.app.id &&
          v.focus();
      }),
      r
    );
  }
  async processInputEvent(r, p) {
    const v = p.value.split("&&");
    switch (r.key.toLowerCase()) {
      case "enter":
        this.processCommands(v);
        break;
      case "f2":
        this.restorePreviousCommand();
        break;
    }
  }
  restorePreviousCommand() {
    const r = this.term.commandHandler.history,
      p = r[r.length - 1];
    !this.current || !p || (this.current.value = p);
  }
  async processCommands(r) {
    for (let p = 0; p < r.length; p++) {
      const k = this.term.vars.replace(r[p].trim()).split(" "),
        x = k[0];
      k.shift(), await this.term.commandHandler.evaluate(x, k), this.lock();
    }
    this.unlock();
  }
}
function ArcTermIntro($) {
  if (!$.env.logo) return;
  const r = [
    "   [_]         _____            ",
    "  [/_\\]  _ _ _|_   _|__ _ _ _ __ ",
    " [/ _ \\]| '_/ _|| |/ -_) '_| '  \\",
    "[/_/ \\_\\]_| \\__||_|\\___|_| |_|_|_|",
  ];
  for (let p = 0; p < r.length; p++) $.std.writeColor(r[p], "blue");
  $.std.writeLine(`
`);
}
class ArcTermStd {
  constructor(r) {
    me(this, "target");
    me(this, "app");
    me(this, "term");
    me(this, "env");
    me(this, "verbose", !0);
    Log({
      source: `ArcTerm ${r.referenceId}`,
      msg: "Creating new ArcTermStd",
      level: LogLevel.info,
    }),
      (this.target = r.target),
      (this.app = r.app),
      (this.term = r),
      (this.env = r.env);
  }
  writeLine(r, p = !1, v = this.target) {
    const k = document.createElement("div");
    return (
      (k.className = "part"),
      p && (k.className += " inline"),
      (k.innerText = r),
      v.appendChild(k),
      k
    );
  }
  writeSeperator(r) {
    this.writeLine("".padEnd(r, "-"));
  }
  Error(r) {
    this.verbose && this.writeColor(`[Error]: ${r}`, "red");
  }
  write(r, p = this.target) {
    return this.writeLine(r, !0, p);
  }
  update(r, p) {
    if (!r) return !1;
    (r.innerText = ""), this.write(p, this.target);
  }
  updateColor(r, p, v) {
    if (!r) return !1;
    (r.innerText = ""), this.writeColor(p, v, "white", !1, r);
  }
  writeColor(r, p, v = "white", k = !1, x = this.target) {
    const S = r.split(/(\[[^\]]*\])/),
      I = document.createElement("div");
    (I.className = "part "), k && (I.className += " inline");
    for (let F = 0; F < S.length; F++) {
      const O = document.createElement("span"),
        L = S[F].startsWith("[") && S[F].endsWith("]"),
        U = S[F].replaceAll("[", "").replaceAll("]", "");
      (O.className = `clr-${L ? p : v}`), (O.innerText = U), I.append(O);
    }
    return x.append(I), I;
  }
  writeImage(r, p) {
    const v = document.createElement("img");
    (v.className = "image"),
      (v.style.height = `${p}em`),
      (v.src = r),
      this.target.append(v);
  }
  clear() {
    this.target.innerText = "";
  }
  async read(r, p, v, k = !1, x = "") {
    if (!this.target) return "";
    const S = this.term.input.current,
      I = writable(!1),
      F = document.createElement("div"),
      O = document.createElement("input");
    return (
      k && (O.type = "password"),
      (O.style.width = `${v * 8.41}px`),
      (O.maxLength = v),
      (O.value = x),
      (F.className = "userinput"),
      F.append(r, O, p),
      this.target.append(F),
      (this.term.input.current = O),
      O.addEventListener("keydown", (L) => {
        L.key.toLowerCase() == "enter" && ((O.disabled = !0), I.set(!0));
      }),
      new Promise((L) => {
        I.subscribe((U) => {
          U && ((this.term.input.current = S), L(O.value));
        });
      })
    );
  }
}
class ArcTermUtil {
  constructor(r) {
    me(this, "term");
    me(this, "reference", "");
    this.setReference(),
      Log({
        source: `ArcTerm ${this.reference}`,
        msg: "Creating new ArcTermUtil",
        level: LogLevel.info,
      }),
      (this.term = r);
  }
  getReference() {
    return this.reference;
  }
  setReference() {
    const r = () => Math.floor(Math.random() * 1e6);
    this.reference = `${r()}-${r()}-${r()}-${r()}`;
  }
  flushAccent() {
    this.term.app ||
      this.term.target.setAttribute(
        "style",
        `--terminal-accent: var(--clr-${this.term.env.promptColor}-fg);`
      );
  }
  intro() {
    !this.term ||
      !this.term.std ||
      (ArcTermIntro(this.term),
      this.term.std.writeColor(
        `${this.term.env.greeting}

`,
        this.term.env.promptColor
      ));
  }
}
function getArcTermStore($) {
  return (
    Log({
      source: `ArcTerm ${$.referenceId}`,
      msg: "Creating new ArcTermVariableStore",
      level: LogLevel.info,
    }),
    {
      prompt: {
        get: () => $.env.prompt,
        set: async (r) => {
          ($.env.prompt = r), await $.env.config.writeConfig();
        },
        canDelete: !1,
        readOnly: !1,
      },
      server: {
        get: () => localStorage.getItem("arcos-server"),
        readOnly: !0,
        canDelete: !1,
      },
      username: {
        get: () => get_store_value(UserName),
        readOnly: !0,
        canDelete: !1,
      },
      version: { get: () => ArcOSVersion, readOnly: !0, canDelete: !1 },
      pwd: {
        get: () => $.path,
        set: async (r) => {
          if (!(await getDirectory(r)))
            return $.std.Error("pwd: Directory doesn't exist, falling back.");
          $.path = r;
        },
        canDelete: !1,
        readOnly: !1,
      },
      color: {
        get: () => $.env.promptColor,
        set: async (r) => {
          if (!colors.includes(r))
            return $.std.Error("color is invalid, falling back.");
          ($.env.promptColor = r),
            await $.env.config.writeConfig(),
            $.util.flushAccent();
        },
        canDelete: !1,
        readOnly: !1,
      },
      ref: { get: () => $.referenceId, readOnly: !0, canDelete: !1 },
    }
  );
}
class ArcTermVariables {
  constructor(r) {
    me(this, "term");
    me(this, "store", {});
    Log({
      source: `ArcTerm ${r.referenceId}`,
      msg: "Creating new ArcTermVariables",
      level: LogLevel.info,
    }),
      (this.term = r),
      (this.store = getArcTermStore(this.term));
  }
  async getAll() {
    const r = {},
      p = Object.entries(this.store);
    for (let v = 0; v < p.length; v++) {
      const k = p[v][0],
        x = this.get(k),
        S = p[v][1].readOnly;
      r[k] = { value: x, readOnly: S };
    }
    return r;
  }
  get(r) {
    return this.store[r] ? this.store[r].get() : r;
  }
  async set(r, p) {
    if (!this.store[r]) {
      const k = {
        get: () => k.value,
        set: (x) => (k.value = x),
        readOnly: !1,
        canDelete: !0,
        value: p,
      };
      return (this.store[r] = k), !0;
    }
    if (this.store[r].readOnly) return !1;
    const v = this.store[r];
    return v ? (await v.set(p), !0) : !1;
  }
  async delete(r) {
    return !this.store[r] || this.store[r].readOnly
      ? !1
      : (await this.set(r, ""), !0);
  }
  replace(r) {
    const p = this.parseInlineNames(r);
    if (!p.length) return r;
    for (let v = 0; v < p.length; v++) {
      const k = `$${p[v]}`,
        x = this.get(p[v]);
      r = r.replace(k, x == p[v] && k ? k : x);
    }
    return r;
  }
  parseInlineNames(r) {
    const p = /\$([a-zA-Z_][a-zA-Z0-9_]*)/g,
      v = [];
    let k;
    for (; (k = p.exec(r)); ) v.push(k[1]);
    return v;
  }
}
let ArcTerm$1 = class {
  constructor(r, p, v, k) {
    me(this, "target");
    me(this, "commands");
    me(this, "app");
    me(this, "std");
    me(this, "util");
    me(this, "env");
    me(this, "vars");
    me(this, "input");
    me(this, "path");
    me(this, "commandHandler");
    me(this, "referenceId");
    me(this, "onload");
    (this.target = r),
      (this.commands = p),
      (this.app = v),
      (this.onload = k),
      this.initialize();
  }
  async initialize() {
    if (
      ((this.util = new ArcTermUtil(this)),
      (this.referenceId = this.util.getReference()),
      Log({
        source: `ArcTerm ${this.referenceId}`,
        msg: "Initializing new ArcTerm",
        level: LogLevel.info,
      }),
      !this.target)
    )
      return initError(this.app.id);
    (this.target.innerText = `Starting ArcTerm v${ArcOSVersion}...`),
      this.target.removeAttribute("style"),
      (this.path = "./"),
      (this.commandHandler = new ArcTermCommandHandler(this)),
      (this.env = new ArcTermEnv(this)),
      (this.vars = new ArcTermVariables(this)),
      setTimeout(async () => {
        (this.std = new ArcTermStd(this)),
          (this.input = new ArcTermInput(this)),
          this.input.lock(),
          this.onload && (await this.onload(this)),
          await sleep(100),
          this.input.unlock(),
          this.util.intro(),
          this.util.flushAccent();
      }, 100);
  }
  dispose() {
    this.target &&
      (this.std.clear(),
      (this.std = null),
      (this.env = null),
      this.input.lock(),
      (this.input = null));
  }
};
function create_fragment$X($) {
  let r, p, v;
  return {
    c() {
      (r = element("div")), attr(r, "class", "terminal-renderer");
    },
    m(k, x) {
      insert(k, r, x), $[3](r), p || ((v = listen(r, "click", $[1])), (p = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r), $[3](null), (p = !1), v();
    },
  };
}
function instance$M($, r, p) {
  let { app: v } = r,
    k,
    x;
  onMount(() => {
    p(
      2,
      (v.events.close = () => {
        k && (k.dispose(), (k = null));
      }),
      v
    ),
      p(
        2,
        (v.events.open = () => {
          k ||
            (k = new ArcTerm$1(
              x,
              [...arcCommands, ...desktopSpecific],
              v,
              (F) => {
                F.std.clear();
              }
            )),
            v.state.windowState.fll && fullscreenToggle(v.id);
        }),
        v
      ),
      p(
        2,
        (v.events.blur = () => {
          k && k.input && k.input.current && (k.input.current.disabled = !0);
        }),
        v
      ),
      p(
        2,
        (v.events.focus = () => {
          k && k.input && k.input.current && (k.input.current.disabled = !1);
        }),
        v
      );
  });
  function S() {
    !k || !k.input || !k.input.current || k.input.current.focus();
  }
  function I(F) {
    binding_callbacks[F ? "unshift" : "push"](() => {
      (x = F), p(0, x);
    });
  }
  return (
    ($.$$set = (F) => {
      "app" in F && p(2, (v = F.app));
    }),
    [x, S, v, I]
  );
}
let ArcTerm_1$1 = class extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$M, create_fragment$X, safe_not_equal, { app: 2 });
  }
};
const ArcTerm = {
    info: {
      name: "ArcTerm",
      description: "ArcOS Terminal",
      builtin: !0,
      version: "2.0.0",
      author: "ArcOS Team",
      icon: logo$7,
    },
    size: { w: 640, h: 480 },
    pos: { x: 60, y: 60 },
    minSize: { w: 350, h: 250 },
    maxSize: { w: NaN, h: NaN },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !0,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: ArcTerm_1$1,
    glass: !0,
    events: {
      keyboardShortcuts: [
        {
          alt: !0,
          key: "f",
          action($) {
            fullscreenToggle($.id);
          },
        },
      ],
    },
  },
  logo = "./assets/helpcenter-dc574bdf.svg",
  HelpCenter$2 = "";
function create_if_block$t($) {
  let r,
    p = $[0].title + "",
    v,
    k,
    x;
  return {
    c() {
      (r = element("button")), (v = text(p)), attr(r, "class", "redirect");
    },
    m(S, I) {
      insert(S, r, I),
        append(r, v),
        k || ((x = listen(r, "click", $[1])), (k = !0));
    },
    p(S, I) {
      I & 1 && p !== (p = S[0].title + "") && set_data(v, p);
    },
    d(S) {
      S && detach(r), (k = !1), x();
    },
  };
}
function create_fragment$W($) {
  let r,
    p = $[0] && create_if_block$t($);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, k) {
      p && p.m(v, k), insert(v, r, k);
    },
    p(v, [k]) {
      v[0]
        ? p
          ? p.p(v, k)
          : ((p = create_if_block$t(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$L($, r, p) {
  let { id: v } = r,
    k;
  onMount(() => {
    p(0, (k = helpCenterArticles[v]));
  });
  function x() {
    currentArticle.set(v);
  }
  return (
    ($.$$set = (S) => {
      "id" in S && p(2, (v = S.id));
    }),
    [k, x, v]
  );
}
class Redirect extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$L, create_fragment$W, safe_not_equal, { id: 2 });
  }
}
function create_fragment$V($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R;
  return (
    (x = new Redirect({ props: { id: "personalization" } })),
    (I = new Redirect({ props: { id: "arctermConfiguration" } })),
    (O = new Redirect({ props: { id: "appsTurnOnAndOff" } })),
    (j = new Redirect({ props: { id: "homePageChanges" } })),
    {
      c() {
        (r = element("h1")),
          (r.textContent = "ArcOS Help Center"),
          (p = space()),
          (v = element("p")),
          (v.textContent = `Welcome to the ArcOS help center. Got a question or a problem to solve?
  There's a good chance that the information you're looking for already happens
  to be in this very app. Perhaps one of these common articles can help you out?`),
          (k = space()),
          create_component(x.$$.fragment),
          (S = space()),
          create_component(I.$$.fragment),
          (F = space()),
          create_component(O.$$.fragment),
          (L = space()),
          (U = element("hr")),
          (N = space()),
          create_component(j.$$.fragment);
      },
      m(q, Q) {
        insert(q, r, Q),
          insert(q, p, Q),
          insert(q, v, Q),
          insert(q, k, Q),
          mount_component(x, q, Q),
          insert(q, S, Q),
          mount_component(I, q, Q),
          insert(q, F, Q),
          mount_component(O, q, Q),
          insert(q, L, Q),
          insert(q, U, Q),
          insert(q, N, Q),
          mount_component(j, q, Q),
          (R = !0);
      },
      p: noop$1,
      i(q) {
        R ||
          (transition_in(x.$$.fragment, q),
          transition_in(I.$$.fragment, q),
          transition_in(O.$$.fragment, q),
          transition_in(j.$$.fragment, q),
          (R = !0));
      },
      o(q) {
        transition_out(x.$$.fragment, q),
          transition_out(I.$$.fragment, q),
          transition_out(O.$$.fragment, q),
          transition_out(j.$$.fragment, q),
          (R = !1);
      },
      d(q) {
        q && detach(r),
          q && detach(p),
          q && detach(v),
          q && detach(k),
          destroy_component(x, q),
          q && detach(S),
          destroy_component(I, q),
          q && detach(F),
          destroy_component(O, q),
          q && detach(L),
          q && detach(U),
          q && detach(N),
          destroy_component(j, q);
      },
    }
  );
}
class HomePage extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$V, safe_not_equal, {});
  }
}
function create_fragment$U($) {
  let r, p, v;
  return {
    c() {
      (r = element("h1")),
        (r.textContent = "Not implemented"),
        (p = space()),
        (v = element("p")),
        (v.textContent =
          "This article has not yet been written. Sorry about that.");
    },
    m(k, x) {
      insert(k, r, x), insert(k, p, x), insert(k, v, x);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r), k && detach(p), k && detach(v);
    },
  };
}
class NotImplemented extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$U, safe_not_equal, {});
  }
}
function create_fragment$T($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K, V, H, G;
  return (
    (U = new Redirect({ props: { id: "personalizationShell" } })),
    (H = new Redirect({ props: { id: "personalizationDesktop" } })),
    {
      c() {
        (r = element("h1")),
          (r.textContent = "Personalization"),
          (p = space()),
          (v = element("p")),
          (v.textContent = `One of the key things we care about in ArcOS is customization; the ability to
  change every aspect of your desktop precisely how you like it. I like to think
  we did a pretty good job, with a ton of options and things to tweak.`),
          (k = space()),
          (x = element("p")),
          (x.textContent = `In this help center article, you will learn what customization options there
  are, and more.`),
          (S = space()),
          (I = element("h2")),
          (I.textContent = "The shell"),
          (F = space()),
          (O = element("p")),
          (O.innerHTML = `The shell is <b>the Taskbar</b>, <b>Start Menu</b>, <b>Action Center</b> and
  <b>ArcFind</b>. It too can be customized. You can customize the shell by going
  to the Shell page in Settings. From there you can change the behaviour of
  every component of the shell.`),
          (L = space()),
          create_component(U.$$.fragment),
          (N = space()),
          (j = element("h2")),
          (j.textContent = "Desktop"),
          (R = space()),
          (q = element("p")),
          (q.textContent = `The very first thing you see every time you log in. On the desktop you'll find
  your desktop icons and the wallpaper. The wallpaper can be changed using
  either a built-in wallpaper or a custom one via URL or ArcFS file.`),
          (Q = space()),
          (K = element("p")),
          (K.textContent = `Do you want to save your current options? Good news, you can! On the
  Appearance page of the Settings app, you can click on the save icon to save
  your current appearance as a theme so that you can easily switch between
  different styles.`),
          (V = space()),
          create_component(H.$$.fragment);
      },
      m(Y, J) {
        insert(Y, r, J),
          insert(Y, p, J),
          insert(Y, v, J),
          insert(Y, k, J),
          insert(Y, x, J),
          insert(Y, S, J),
          insert(Y, I, J),
          insert(Y, F, J),
          insert(Y, O, J),
          insert(Y, L, J),
          mount_component(U, Y, J),
          insert(Y, N, J),
          insert(Y, j, J),
          insert(Y, R, J),
          insert(Y, q, J),
          insert(Y, Q, J),
          insert(Y, K, J),
          insert(Y, V, J),
          mount_component(H, Y, J),
          (G = !0);
      },
      p: noop$1,
      i(Y) {
        G ||
          (transition_in(U.$$.fragment, Y),
          transition_in(H.$$.fragment, Y),
          (G = !0));
      },
      o(Y) {
        transition_out(U.$$.fragment, Y),
          transition_out(H.$$.fragment, Y),
          (G = !1);
      },
      d(Y) {
        Y && detach(r),
          Y && detach(p),
          Y && detach(v),
          Y && detach(k),
          Y && detach(x),
          Y && detach(S),
          Y && detach(I),
          Y && detach(F),
          Y && detach(O),
          Y && detach(L),
          destroy_component(U, Y),
          Y && detach(N),
          Y && detach(j),
          Y && detach(R),
          Y && detach(q),
          Y && detach(Q),
          Y && detach(K),
          Y && detach(V),
          destroy_component(H, Y);
      },
    }
  );
}
class Personalization extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$T, safe_not_equal, {});
  }
}
const desktop$1 = {
    personalizationDesktop: {
      title: "Desktop",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "personalization",
    },
    personalizationDesktopThemes: {
      title: "Themes",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "personalizationDesktop",
    },
    personalizationDesktopCustomWallpapers: {
      title: "Wallpapers",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "personalizationDesktop",
    },
  },
  shell = {
    personalizationShell: {
      title: "Shell",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "personalization",
    },
    personalizationShellColoring: {
      title: "Coloring",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "personalizationShell",
    },
    personalizationShellTaskbar: {
      title: "Taskbar",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "personalizationShell",
    },
    personalizationShellStartMenu: {
      title: "Start Menu",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "personalizationShell",
    },
    personalizationShellActionCenter: {
      title: "Action Center",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "personalizationShell",
    },
  },
  windows = {
    personalizationWindows: {
      title: "Windows",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "personalization",
    },
    personalizationWindowsTitlebar: {
      title: "Titlebar",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "personalizationWindows",
    },
  },
  personalization = {
    personalization: {
      title: "Personalization",
      content: Personalization,
      authors: ["Izaak Kuipers"],
      sep: !0,
    },
    personalizationPerformance: {
      title: "Performance",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "personalization",
    },
    ...shell,
    ...desktop$1,
    ...windows,
  },
  actioncenter = {
    actionCenter: {
      title: "Action Center",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      sep: !0,
    },
    actionCenterNotifications: {
      title: "Notifications",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "actionCenter",
    },
    actionCenterQuickActions: {
      title: "Quick Actions",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "actionCenter",
    },
  },
  accounts = {
    accounts: {
      title: "Accounts",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      sep: !0,
    },
    accountsChangeCred: {
      title: "Changing my Credentials",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "accounts",
    },
    accountsChangeProfile: {
      title: "Changing my Profile Picture",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "accounts",
    },
    accountsDelete: {
      title: "Deleting my Account",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "accounts",
    },
  },
  configuration = {
    arctermConfiguration: {
      title: "Configuration",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "arcterm",
    },
    arctermConfigurationPrompt: {
      title: "Prompt",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "arctermConfiguration",
    },
    arctermConfigurationIntro: {
      title: "Intro",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "arctermConfiguration",
    },
  },
  arcterm = {
    arcterm: {
      title: "ArcTerm",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      sep: !0,
    },
    ...configuration,
    arctermMode: {
      title: "ArcTerm Mode",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "arcterm",
    },
  },
  arcfs = {
    arcfs: {
      title: "ArcFS",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      sep: !0,
    },
    arcfsUploading: {
      title: "Uploading Files",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "arcfs",
    },
    arcfsDownloading: {
      title: "Downloading Files",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "arcfs",
    },
    arcfsOpenWith: {
      title: "Open With",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "arcfs",
    },
    arcfsLimitations: {
      title: "Limitations",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "arcfs",
    },
    arcfsQuota: {
      title: "ArcFS Quota",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "arcfs",
    },
  },
  arcfind$1 = {
    arcfind: {
      title: "ArcFind",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      sep: !0,
    },
    arcfindTypes: {
      title: "Types of Results",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "arcfind",
    },
    arcfindInitialIndex: {
      title: "Initial Index",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "arcfind",
    },
  },
  messaging = {
    appsMessaging: {
      title: "Messaging",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "apps",
    },
    appsMessagingSending: {
      title: "Sending",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "appsMessaging",
    },
    appsMessagingReceiving: {
      title: "Receiving",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "appsMessaging",
    },
    appsMessagingDeleting: {
      title: "Deleting",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "appsMessaging",
    },
    appsMessagingReplies: {
      title: "Replies",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "appsMessaging",
    },
    appsMessagingLimitations: {
      title: "Limitations",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "appsMessaging",
    },
  },
  apps = {
    apps: {
      title: "Apps",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      sep: !0,
    },
    appsSystem: {
      title: "About System Apps",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "apps",
    },
    appsTurnOnAndOff: {
      title: "Turn apps on and off",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "apps",
    },
    ...messaging,
  },
  logging = {
    logging: {
      title: "Logging",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
    },
    loggingTypes: {
      title: "Log Types",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "logging",
    },
    loggingDevTools: {
      title: "Developer Tools",
      authors: ["Izaak Kuipers"],
      content: NotImplemented,
      parentId: "logging",
    },
  };
async function getLatestRelease() {
  try {
    return await (
      await fetch(
        "https://api.github.com/repos/IzK-ArcOS/ArcOS-Frontend/releases/latest",
        { cache: "no-store" }
      )
    ).json();
  } catch {
    return null;
  }
}
async function getLatestVersion() {
  const $ = parseVersion(ArcOSVersion);
  try {
    const r = await getLatestRelease();
    if (!r) return $;
    const p = parseVersion(filterTagName(r.tag_name));
    return versionBigger(p, $) ? p : $;
  } catch {
    return $;
  }
}
function parseVersion($) {
  const r = $.split(".");
  return [r[0], r[1], r[2]].map((p) => {
    try {
      return parseInt(p);
    } catch {
      return 0;
    }
  });
}
function filterTagName($) {
  return $.split("-")[0];
}
function versionBigger($, r) {
  for (let p = 0; p < $.length; p++) if ($[p] > r[p]) return !0;
  return !1;
}
async function checkForUpdates() {
  if (!(await inTauri())) return;
  const $ = await getLatestVersion();
  if (versionBigger($, parseVersion(ArcOSVersion))) {
    const r = `v${$.join(".")}`,
      p = "https://github.com/IzK-ArcOS/ArcOS-Frontend/releases/latest";
    makeNotification({
      icon: "sync",
      title: "Updates available!",
      message: `ArcOS Desktop ${r} is available for download. Install it to get the latest features.`,
      buttons: [{ caption: "Open", action: () => window.open(p, "_blank") }],
    });
  }
}
function create_else_block$8($) {
  let r, p, v, k, x;
  return (
    (p = new Spinner({ props: { height: 32 } })),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          (k = element("p")),
          (k.textContent = "Reading items..."),
          attr(k, "class", "caption"),
          attr(r, "class", "loading");
      },
      m(S, I) {
        insert(S, r, I),
          mount_component(p, r, null),
          append(r, v),
          append(r, k),
          (x = !0);
      },
      p: noop$1,
      i(S) {
        x || (transition_in(p.$$.fragment, S), (x = !0));
      },
      o(S) {
        transition_out(p.$$.fragment, S), (x = !1);
      },
      d(S) {
        S && detach(r), destroy_component(p);
      },
    }
  );
}
function create_if_block_1$9($) {
  let r;
  return {
    c() {
      (r = element("p")),
        (r.textContent = `ArcOS is currently unable to get the latest release information from the
    github repository. Please try again later.`);
    },
    m(p, v) {
      insert(p, r, v);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
function create_if_block$s($) {
  let r,
    p,
    v = $[0].tag_name + "",
    k,
    x,
    S,
    I;
  return (
    (S = new SvelteMarkdown({ props: { source: $[0].body } })),
    {
      c() {
        (r = element("h3")),
          (p = text("Changelog for ArcOS v")),
          (k = text(v)),
          (x = space()),
          create_component(S.$$.fragment);
      },
      m(F, O) {
        insert(F, r, O),
          append(r, p),
          append(r, k),
          insert(F, x, O),
          mount_component(S, F, O),
          (I = !0);
      },
      p(F, O) {
        (!I || O & 1) && v !== (v = F[0].tag_name + "") && set_data(k, v);
        const L = {};
        O & 1 && (L.source = F[0].body), S.$set(L);
      },
      i(F) {
        I || (transition_in(S.$$.fragment, F), (I = !0));
      },
      o(F) {
        transition_out(S.$$.fragment, F), (I = !1);
      },
      d(F) {
        F && detach(r), F && detach(x), destroy_component(S, F);
      },
    }
  );
}
function create_fragment$S($) {
  let r, p, v, k;
  const x = [create_if_block$s, create_if_block_1$9, create_else_block$8],
    S = [];
  function I(F, O) {
    return F[0] ? 0 : F[1] ? 2 : 1;
  }
  return (
    (r = I($)),
    (p = S[r] = x[r]($)),
    {
      c() {
        p.c(), (v = empty());
      },
      m(F, O) {
        S[r].m(F, O), insert(F, v, O), (k = !0);
      },
      p(F, [O]) {
        let L = r;
        (r = I(F)),
          r === L
            ? S[r].p(F, O)
            : (group_outros(),
              transition_out(S[L], 1, 1, () => {
                S[L] = null;
              }),
              check_outros(),
              (p = S[r]),
              p ? p.p(F, O) : ((p = S[r] = x[r](F)), p.c()),
              transition_in(p, 1),
              p.m(v.parentNode, v));
      },
      i(F) {
        k || (transition_in(p), (k = !0));
      },
      o(F) {
        transition_out(p), (k = !1);
      },
      d(F) {
        S[r].d(F), F && detach(v);
      },
    }
  );
}
function instance$K($, r, p) {
  let v,
    k = !1;
  return (
    onMount(async () => {
      p(1, (k = !0)), p(0, (v = await getLatestRelease())), p(1, (k = !1));
    }),
    [v, k]
  );
}
class RecentChanges extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$K, create_fragment$S, safe_not_equal, {});
  }
}
const helpCenterArticles = {
    homePage: {
      title: "Home",
      content: HomePage,
      sep: !0,
      authors: ["Izaak Kuipers"],
    },
    homePageChanges: {
      title: "Recent Changes",
      content: RecentChanges,
      authors: ["Izaak Kuipers"],
      parentId: "homePage",
    },
    ...personalization,
    ...actioncenter,
    ...accounts,
    ...arcterm,
    ...arcfs,
    ...arcfind$1,
    ...apps,
    ...logging,
  },
  currentArticle = writable();
function create_if_block$r($) {
  let r, p, v;
  var k = helpCenterArticles[$[0]].content;
  function x(S) {
    return {};
  }
  return (
    k && (r = construct_svelte_component(k, x())),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(S, I) {
        r && mount_component(r, S, I), insert(S, p, I), (v = !0);
      },
      p(S, I) {
        if (I & 1 && k !== (k = helpCenterArticles[S[0]].content)) {
          if (r) {
            group_outros();
            const F = r;
            transition_out(F.$$.fragment, 1, 0, () => {
              destroy_component(F, 1);
            }),
              check_outros();
          }
          k
            ? ((r = construct_svelte_component(k, x())),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        }
      },
      i(S) {
        v || (r && transition_in(r.$$.fragment, S), (v = !0));
      },
      o(S) {
        r && transition_out(r.$$.fragment, S), (v = !1);
      },
      d(S) {
        S && detach(p), r && destroy_component(r, S);
      },
    }
  );
}
function create_fragment$R($) {
  let r,
    p,
    v = $[0] && helpCenterArticles[$[0]] && create_if_block$r($);
  return {
    c() {
      (r = element("div")),
        v && v.c(),
        attr(r, "class", "article-renderer markdownrenderer");
    },
    m(k, x) {
      insert(k, r, x), v && v.m(r, null), (p = !0);
    },
    p(k, [x]) {
      k[0] && helpCenterArticles[k[0]]
        ? v
          ? (v.p(k, x), x & 1 && transition_in(v, 1))
          : ((v = create_if_block$r(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r, null))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      k && detach(r), v && v.d();
    },
  };
}
function instance$J($, r, p) {
  let v;
  return component_subscribe($, currentArticle, (k) => p(0, (v = k))), [v];
}
class ArticleRenderer extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$J, create_fragment$R, safe_not_equal, {});
  }
}
function get_each_context$a($, r, p) {
  const v = $.slice();
  return (v[5] = r[p]), v;
}
function create_if_block_1$8($) {
  let r, p;
  return (
    (r = new Article_1({
      props: { article: $[5][1], id: $[5][0], articles: $[2] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 4 && (x.article = v[5][1]),
          k & 4 && (x.id = v[5][0]),
          k & 4 && (x.articles = v[2]),
          r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$a($) {
  let r,
    p,
    v = $[5][1].parentId == $[1] && create_if_block_1$8($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, x) {
      k[5][1].parentId == k[1]
        ? v
          ? (v.p(k, x), x & 6 && transition_in(v, 1))
          : ((v = create_if_block_1$8(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function create_if_block$q($) {
  let r;
  return {
    c() {
      r = element("hr");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$Q($) {
  let r,
    p = $[0].title + "",
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U = $[2],
    N = [];
  for (let q = 0; q < U.length; q += 1)
    N[q] = create_each_block$a(get_each_context$a($, U, q));
  const j = (q) =>
    transition_out(N[q], 1, 1, () => {
      N[q] = null;
    });
  let R = $[0].sep && create_if_block$q();
  return {
    c() {
      (r = element("button")),
        (v = text(p)),
        (k = space()),
        (x = element("div"));
      for (let q = 0; q < N.length; q += 1) N[q].c();
      (S = space()),
        R && R.c(),
        (I = empty()),
        attr(r, "class", "article-link"),
        toggle_class(r, "selected", $[3] == $[1]),
        attr(x, "class", "indent");
    },
    m(q, Q) {
      insert(q, r, Q), append(r, v), insert(q, k, Q), insert(q, x, Q);
      for (let K = 0; K < N.length; K += 1) N[K] && N[K].m(x, null);
      insert(q, S, Q),
        R && R.m(q, Q),
        insert(q, I, Q),
        (F = !0),
        O || ((L = listen(r, "click", $[4])), (O = !0));
    },
    p(q, [Q]) {
      if (
        ((!F || Q & 1) && p !== (p = q[0].title + "") && set_data(v, p),
        (!F || Q & 10) && toggle_class(r, "selected", q[3] == q[1]),
        Q & 6)
      ) {
        U = q[2];
        let K;
        for (K = 0; K < U.length; K += 1) {
          const V = get_each_context$a(q, U, K);
          N[K]
            ? (N[K].p(V, Q), transition_in(N[K], 1))
            : ((N[K] = create_each_block$a(V)),
              N[K].c(),
              transition_in(N[K], 1),
              N[K].m(x, null));
        }
        for (group_outros(), K = U.length; K < N.length; K += 1) j(K);
        check_outros();
      }
      q[0].sep
        ? R || ((R = create_if_block$q()), R.c(), R.m(I.parentNode, I))
        : R && (R.d(1), (R = null));
    },
    i(q) {
      if (!F) {
        for (let Q = 0; Q < U.length; Q += 1) transition_in(N[Q]);
        F = !0;
      }
    },
    o(q) {
      N = N.filter(Boolean);
      for (let Q = 0; Q < N.length; Q += 1) transition_out(N[Q]);
      F = !1;
    },
    d(q) {
      q && detach(r),
        q && detach(k),
        q && detach(x),
        destroy_each(N, q),
        q && detach(S),
        R && R.d(q),
        q && detach(I),
        (O = !1),
        L();
    },
  };
}
function instance$I($, r, p) {
  let v;
  component_subscribe($, currentArticle, (F) => p(3, (v = F)));
  let { article: k } = r,
    { id: x } = r,
    { articles: S = [] } = r;
  function I() {
    currentArticle.set(x);
  }
  return (
    ($.$$set = (F) => {
      "article" in F && p(0, (k = F.article)),
        "id" in F && p(1, (x = F.id)),
        "articles" in F && p(2, (S = F.articles));
    }),
    [k, x, S, v, I]
  );
}
class Article_1 extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$I, create_fragment$Q, safe_not_equal, {
        article: 0,
        id: 1,
        articles: 2,
      });
  }
}
function get_each_context$9($, r, p) {
  const v = $.slice();
  return (v[1] = r[p]), v;
}
function create_if_block$p($) {
  let r, p;
  return (
    (r = new Article_1({
      props: { article: $[1][1], id: $[1][0], articles: $[0] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.article = v[1][1]),
          k & 1 && (x.id = v[1][0]),
          k & 1 && (x.articles = v[0]),
          r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$9($) {
  let r,
    p,
    v = !$[1][1].parentId && create_if_block$p($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, x) {
      k[1][1].parentId
        ? v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros())
        : v
        ? (v.p(k, x), x & 1 && transition_in(v, 1))
        : ((v = create_if_block$p(k)),
          v.c(),
          transition_in(v, 1),
          v.m(r.parentNode, r));
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function create_fragment$P($) {
  let r,
    p,
    v = $[0],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$9(get_each_context$9($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      r = element("div");
      for (let S = 0; S < k.length; S += 1) k[S].c();
      attr(r, "class", "sidebar");
    },
    m(S, I) {
      insert(S, r, I);
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(r, null);
      p = !0;
    },
    p(S, [I]) {
      if (I & 1) {
        v = S[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$9(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$9(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      S && detach(r), destroy_each(k, S);
    },
  };
}
function instance$H($, r, p) {
  let v = [];
  return (
    onMount(() => {
      p(0, (v = Object.entries(helpCenterArticles)));
    }),
    [v]
  );
}
class SideBar extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$H, create_fragment$P, safe_not_equal, {});
  }
}
function create_fragment$O($) {
  let r, p, v, k;
  return (
    (r = new ArticleRenderer({})),
    (v = new SideBar({})),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          create_component(v.$$.fragment);
      },
      m(x, S) {
        mount_component(r, x, S),
          insert(x, p, S),
          mount_component(v, x, S),
          (k = !0);
      },
      p: noop$1,
      i(x) {
        k ||
          (transition_in(r.$$.fragment, x),
          transition_in(v.$$.fragment, x),
          (k = !0));
      },
      o(x) {
        transition_out(r.$$.fragment, x),
          transition_out(v.$$.fragment, x),
          (k = !1);
      },
      d(x) {
        destroy_component(r, x), x && detach(p), destroy_component(v, x);
      },
    }
  );
}
let HelpCenter$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$O, safe_not_equal, {});
  }
};
const HelpCenter = {
    info: {
      name: "Help Center",
      description: "You have questions, I have answers.",
      builtin: !0,
      version: "1.0.0",
      author: "ArcOS Team",
      icon: logo,
      hidden: !0,
    },
    size: { w: 800, h: 600 },
    pos: { x: 30, y: 40 },
    minSize: { w: 800, h: 600 },
    maxSize: { w: 901, h: 700 },
    controls: { min: !0, max: !0, cls: !0 },
    state: {
      headless: !1,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !1 },
    },
    content: HelpCenter$1,
    glass: !0,
    events: {
      open() {
        createOverlayableError(
          {
            title: "Caution!",
            message:
              "This application is still in development past the release of 5.0.6. It was hidden to prevent you from seeing this half finished help center. Do not take the content or UI serious.",
            buttons: [{ caption: "OK", action() {} }],
          },
          "HelpCenter"
        );
      },
    },
  },
  AppLauncher$2 = "",
  arcfind = "";
function create_fragment$N($) {
  let r, p, v, k;
  return (
    (p = new Spinner({ props: { height: 30 } })),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = element("span")),
          (v.textContent = "Searching..."),
          attr(v, "class", "caption"),
          attr(r, "class", "loading");
      },
      m(x, S) {
        insert(x, r, S), mount_component(p, r, null), append(r, v), (k = !0);
      },
      p: noop$1,
      i(x) {
        k || (transition_in(p.$$.fragment, x), (k = !0));
      },
      o(x) {
        transition_out(p.$$.fragment, x), (k = !1);
      },
      d(x) {
        x && detach(r), destroy_component(p);
      },
    }
  );
}
let Loading$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$N, safe_not_equal, {});
  }
};
function create_fragment$M($) {
  let r;
  return {
    c() {
      (r = element("div")),
        (r.textContent = "No items matched your search."),
        attr(r, "class", "no-results");
    },
    m(p, v) {
      insert(p, r, v);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
class NoResults extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$M, safe_not_equal, {});
  }
}
function create_if_block$o($) {
  let r,
    p = $[0].description + "",
    v;
  return {
    c() {
      (r = element("p")), (v = text(p)), attr(r, "class", "description");
    },
    m(k, x) {
      insert(k, r, x), append(r, v);
    },
    p(k, x) {
      x & 1 && p !== (p = k[0].description + "") && set_data(v, p);
    },
    d(k) {
      k && detach(r);
    },
  };
}
function create_fragment$L($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O = $[0].caption + "",
    L,
    U,
    N,
    j,
    R = $[0].description && create_if_block$o($);
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        (v = element("img")),
        (S = space()),
        (I = element("div")),
        (F = element("p")),
        (L = text(O)),
        (U = space()),
        R && R.c(),
        src_url_equal(v.src, (k = $[0].image || searchIcon)) ||
          attr(v, "src", k),
        attr(v, "alt", (x = $[0].caption)),
        attr(p, "class", "image"),
        attr(F, "class", "title"),
        attr(I, "class", "context"),
        attr(r, "class", "result"),
        toggle_class(r, "selected", $[1] == $[2]);
    },
    m(q, Q) {
      insert(q, r, Q),
        append(r, p),
        append(p, v),
        append(r, S),
        append(r, I),
        append(I, F),
        append(F, L),
        append(I, U),
        R && R.m(I, null),
        N || ((j = listen(r, "click", $[3])), (N = !0));
    },
    p(q, [Q]) {
      Q & 1 &&
        !src_url_equal(v.src, (k = q[0].image || searchIcon)) &&
        attr(v, "src", k),
        Q & 1 && x !== (x = q[0].caption) && attr(v, "alt", x),
        Q & 1 && O !== (O = q[0].caption + "") && set_data(L, O),
        q[0].description
          ? R
            ? R.p(q, Q)
            : ((R = create_if_block$o(q)), R.c(), R.m(I, null))
          : R && (R.d(1), (R = null)),
        Q & 6 && toggle_class(r, "selected", q[1] == q[2]);
    },
    i: noop$1,
    o: noop$1,
    d(q) {
      q && detach(r), R && R.d(), (N = !1), j();
    },
  };
}
function instance$G($, r, p) {
  let { result: v } = r,
    { index: k } = r,
    { resultIndex: x } = r;
  function S() {
    v.action(v), showArcFind.set(!1), closeWindow("AppLauncher");
  }
  return (
    ($.$$set = (I) => {
      "result" in I && p(0, (v = I.result)),
        "index" in I && p(1, (k = I.index)),
        "resultIndex" in I && p(2, (x = I.resultIndex));
    }),
    [v, k, x, S]
  );
}
class Result extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$G, create_fragment$L, safe_not_equal, {
        result: 0,
        index: 1,
        resultIndex: 2,
      });
  }
}
function get_each_context$8($, r, p) {
  const v = $.slice();
  return (v[16] = r[p]), (v[18] = p), v;
}
function create_if_block_1$7($) {
  let r, p, v, k;
  const x = [create_if_block_2$2, create_if_block_3, create_else_block$7],
    S = [];
  function I(F, O) {
    return F[6].length ? 0 : F[3] ? 1 : 2;
  }
  return (
    (p = I($)),
    (v = S[p] = x[p]($)),
    {
      c() {
        (r = element("div")), v.c(), attr(r, "class", "results");
      },
      m(F, O) {
        insert(F, r, O), S[p].m(r, null), (k = !0);
      },
      p(F, O) {
        let L = p;
        (p = I(F)),
          p === L
            ? S[p].p(F, O)
            : (group_outros(),
              transition_out(S[L], 1, 1, () => {
                S[L] = null;
              }),
              check_outros(),
              (v = S[p]),
              v ? v.p(F, O) : ((v = S[p] = x[p](F)), v.c()),
              transition_in(v, 1),
              v.m(r, null));
      },
      i(F) {
        k || (transition_in(v), (k = !0));
      },
      o(F) {
        transition_out(v), (k = !1);
      },
      d(F) {
        F && detach(r), S[p].d();
      },
    }
  );
}
function create_else_block$7($) {
  let r, p;
  return (
    (r = new NoResults({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_3($) {
  let r, p;
  return (
    (r = new Loading$1({})),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_2$2($) {
  let r,
    p,
    v = $[6],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$8(get_each_context$8($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 68) {
        v = S[6];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$8(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$8(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_each_block$8($) {
  let r, p;
  return (
    (r = new Result({
      props: { index: $[2], result: $[16], resultIndex: $[18] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 4 && (x.index = v[2]), k & 64 && (x.result = v[16]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$n($) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.textContent = "close"),
        attr(r, "class", "material-icons-round close");
    },
    m(k, x) {
      insert(k, r, x), p || ((v = listen(r, "click", $[11])), (p = !0));
    },
    p: noop$1,
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_fragment$K($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U,
    N = $[4] && create_if_block_1$7($),
    j = !$[0] && create_if_block$n($);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("form")),
        (k = element("input")),
        (x = space()),
        (S = element("button")),
        (S.textContent = "search"),
        (I = space()),
        N && N.c(),
        (F = space()),
        j && j.c(),
        attr(k, "type", "text"),
        attr(k, "placeholder", "Search ArcOS"),
        attr(S, "class", "material-icons-round"),
        attr(p, "class", "arcfind"),
        attr(r, "class", "arcfind-wrapper"),
        set_style(r, "z-index", $[7] + 30),
        toggle_class(r, "inlined", $[0]),
        toggle_class(r, "show", $[8] || $[0]);
    },
    m(R, q) {
      insert(R, r, q),
        append(r, p),
        append(p, v),
        append(v, k),
        set_input_value(k, $[1]),
        $[14](k),
        append(p, x),
        append(p, S),
        append(r, I),
        N && N.m(r, null),
        append(r, F),
        j && j.m(r, null),
        (O = !0),
        L ||
          ((U = [
            listen(k, "input", $[13]),
            listen(k, "input", $[9]),
            listen(k, "keydown", $[12]),
            listen(v, "submit", $[10]),
          ]),
          (L = !0));
    },
    p(R, [q]) {
      q & 2 && k.value !== R[1] && set_input_value(k, R[1]),
        R[4]
          ? N
            ? (N.p(R, q), q & 16 && transition_in(N, 1))
            : ((N = create_if_block_1$7(R)),
              N.c(),
              transition_in(N, 1),
              N.m(r, F))
          : N &&
            (group_outros(),
            transition_out(N, 1, 1, () => {
              N = null;
            }),
            check_outros()),
        R[0]
          ? j && (j.d(1), (j = null))
          : j
          ? j.p(R, q)
          : ((j = create_if_block$n(R)), j.c(), j.m(r, null)),
        (!O || q & 128) && set_style(r, "z-index", R[7] + 30),
        (!O || q & 1) && toggle_class(r, "inlined", R[0]),
        (!O || q & 257) && toggle_class(r, "show", R[8] || R[0]);
    },
    i(R) {
      O || (transition_in(N), (O = !0));
    },
    o(R) {
      transition_out(N), (O = !1);
    },
    d(R) {
      R && detach(r), $[14](null), N && N.d(), j && j.d(), (L = !1), run_all(U);
    },
  };
}
function instance$F($, r, p) {
  let v, k;
  component_subscribe($, maxZIndex, (H) => p(7, (v = H))),
    component_subscribe($, showArcFind, (H) => p(8, (k = H)));
  let { inlined: x = !1 } = r,
    S = "",
    I = 0,
    F = !1,
    O = !1,
    L,
    U = [];
  async function N() {
    if (!S) return p(4, (O = !1));
    p(4, (O = !0)), p(3, (F = !0));
    const H = [],
      G = await Search(S);
    for (let Y = 0; Y < G.length; Y++) H.push(G[Y].item);
    p(2, (I = -1)), p(6, (U = H.slice(0, 6))), p(3, (F = !1));
  }
  function j(H) {
    if ((H.preventDefault(), !!U.length)) {
      if ((p(1, (S = "")), I != -1)) {
        U[I].action(U[I]), R(), showArcFind.set(!1);
        return;
      }
      U[0].action(U[0]), R(), showArcFind.set(!1);
    }
  }
  function R() {
    p(6, (U = [])), p(1, (S = "")), p(2, (I = -1)), p(4, (O = !1));
  }
  function q() {
    R(), showArcFind.set(!1);
  }
  showArcFind.subscribe((H) => {
    R(), H && setTimeout(() => L.focus(), 100);
  });
  function Q(H) {
    const G = H.key.toLowerCase();
    if (G == "escape") {
      R(), showArcFind.set(!1);
      return;
    }
    if (!U.length) return p(2, (I = -1));
    let Y = U.length - 1;
    switch (G) {
      case "arrowup":
        p(2, I--, I), I < 0 && p(2, (I = Y));
        break;
      case "arrowdown":
        p(2, I++, I), I > Y && p(2, (I = 0));
        break;
    }
  }
  function K() {
    (S = this.value), p(1, S);
  }
  function V(H) {
    binding_callbacks[H ? "unshift" : "push"](() => {
      (L = H), p(5, L);
    });
  }
  return (
    ($.$$set = (H) => {
      "inlined" in H && p(0, (x = H.inlined));
    }),
    [x, S, I, F, O, L, U, v, k, N, j, q, Q, K, V]
  );
}
class ArcFind extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$F, create_fragment$K, safe_not_equal, {
        inlined: 0,
      });
  }
}
function get_each_context$7($, r, p) {
  const v = $.slice();
  return (v[2] = r[p]), v;
}
function create_if_block$m($) {
  let r, p;
  return (
    (r = new AppListItem({ props: { app: $[2], onopen: $[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.app = v[2]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$7($) {
  let r = isPopulatable($[2]),
    p,
    v,
    k = r && create_if_block$m($);
  return {
    c() {
      k && k.c(), (p = empty());
    },
    m(x, S) {
      k && k.m(x, S), insert(x, p, S), (v = !0);
    },
    p(x, S) {
      S & 1 && (r = isPopulatable(x[2])),
        r
          ? k
            ? (k.p(x, S), S & 1 && transition_in(k, 1))
            : ((k = create_if_block$m(x)),
              k.c(),
              transition_in(k, 1),
              k.m(p.parentNode, p))
          : k &&
            (group_outros(),
            transition_out(k, 1, 1, () => {
              k = null;
            }),
            check_outros());
    },
    i(x) {
      v || (transition_in(k), (v = !0));
    },
    o(x) {
      transition_out(k), (v = !1);
    },
    d(x) {
      k && k.d(x), x && detach(p);
    },
  };
}
function create_fragment$J($) {
  let r, p, v, k;
  r = new ArcFind({ props: { inlined: !0 } });
  let x = $[0],
    S = [];
  for (let F = 0; F < x.length; F += 1)
    S[F] = create_each_block$7(get_each_context$7($, x, F));
  const I = (F) =>
    transition_out(S[F], 1, 1, () => {
      S[F] = null;
    });
  return {
    c() {
      create_component(r.$$.fragment), (p = space()), (v = element("div"));
      for (let F = 0; F < S.length; F += 1) S[F].c();
      attr(v, "class", "apps");
    },
    m(F, O) {
      mount_component(r, F, O), insert(F, p, O), insert(F, v, O);
      for (let L = 0; L < S.length; L += 1) S[L] && S[L].m(v, null);
      k = !0;
    },
    p(F, [O]) {
      if (O & 1) {
        x = F[0];
        let L;
        for (L = 0; L < x.length; L += 1) {
          const U = get_each_context$7(F, x, L);
          S[L]
            ? (S[L].p(U, O), transition_in(S[L], 1))
            : ((S[L] = create_each_block$7(U)),
              S[L].c(),
              transition_in(S[L], 1),
              S[L].m(v, null));
        }
        for (group_outros(), L = x.length; L < S.length; L += 1) I(L);
        check_outros();
      }
    },
    i(F) {
      if (!k) {
        transition_in(r.$$.fragment, F);
        for (let O = 0; O < x.length; O += 1) transition_in(S[O]);
        k = !0;
      }
    },
    o(F) {
      transition_out(r.$$.fragment, F), (S = S.filter(Boolean));
      for (let O = 0; O < S.length; O += 1) transition_out(S[O]);
      k = !1;
    },
    d(F) {
      destroy_component(r, F),
        F && detach(p),
        F && detach(v),
        destroy_each(S, F);
    },
  };
}
function instance$E($, r, p) {
  let v;
  return (
    component_subscribe($, WindowStore, (x) => p(0, (v = x))),
    focusedWindowId.subscribe((x) => {
      x != "AppLauncher" && closeWindow("AppLauncher");
    }),
    [v, () => closeWindow("AppLauncher")]
  );
}
let AppLauncher$1 = class extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$E, create_fragment$J, safe_not_equal, {});
  }
};
const AppLauncher = {
    info: {
      name: "AppLauncher",
      description: "ArcOS.Shell.Launcher.AppLauncher",
      builtin: !0,
      version: "1.0.0",
      author: "ArcOS Team",
      icon: logo$a,
      hidden: !0,
    },
    size: { w: NaN, h: NaN },
    pos: { x: 0, y: 0 },
    minSize: { w: NaN, h: NaN },
    maxSize: { w: NaN, h: NaN },
    controls: { min: !1, max: !1, cls: !0 },
    state: {
      headless: !0,
      resizable: !1,
      windowState: { min: !1, max: !1, fll: !0 },
    },
    content: AppLauncher$1,
    glass: !0,
  },
  DefaultApps = {
    ErrCre: ErrorCreator,
    FileManager: FileBrowserApp,
    TextEditor,
    CalculatorApp,
    MessagingApp,
    SettingsApp,
    AppMan: AppManager,
    LoggerApp,
    AppPoker,
    Exit: Exit$1,
    AppInfo: AppInfo$1,
    ImageViewer,
    OpenWithApp,
    MarkDownViewer,
    MediaPlayerApp,
    ArcShell,
    AppLauncher,
    DesktopWallpaper,
    DonutApp,
    ArcTerm,
    HelpCenter,
  },
  SystemApps = [
    "AppMan",
    "Exit",
    "SettingsApp",
    "PfpSelector",
    "AppInfo",
    "LoggerApp",
    "FileManager",
  ];
async function importDefault($ = !1) {
  Log({
    msg: "Importing default applications",
    source: "imports.ts: importDefault",
    level: LogLevel.info,
  });
  const r = Object.entries(DefaultApps);
  for (let p = 0; p < r.length; p++)
    Log({
      msg: `Importing default application "${r[p][0]}"...`,
      source: "imports.ts: importDefault",
      level: LogLevel.info,
    }),
      await loadWindow(r[p][0], r[p][1]),
      $ && openWindow(r[p][0]);
  updateStores();
}
function disableApp($) {
  if (
    (Log({
      msg: `Disabling app ${$}`,
      source: "enabling.ts: disableApp",
      level: LogLevel.info,
    }),
    SystemApps.includes($))
  )
    return errorMessage(
      "Can't disable application",
      `App "${$}" is a system application. System applications are core to ArcOS and cannot be disabled without breaking certain functionality.`,
      null,
      "AppLogic",
      { caption: "OK", action: () => {} }
    );
  const r = get_store_value(UserData);
  closeWindow($), r.disabledApps.includes($) || r.disabledApps.push($);
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++) p[v].id == $ && (p[v].disabled = !0);
  UserData.set(r), WindowStore.set(p), updateStores();
}
function enableApp($) {
  Log({
    msg: `Enabling app ${$}`,
    source: "enabling.ts: enableApp",
    level: LogLevel.info,
  });
  const r = get_store_value(UserData);
  for (let v = 0; v < r.disabledApps.length; v++)
    r.disabledApps[v] == $ && r.disabledApps.splice(v, 1);
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++) p[v].id == $ && (p[v].disabled = !1);
  WindowStore.set(p), UserData.set(r), updateStores();
}
function findAppToOpen($) {
  Log({
    source: "fs/open.ts: findAppToOpen",
    msg: `Compiling a list of file handlers that can open mimtype "${$}"...`,
    level: LogLevel.info,
  });
  const r = [],
    p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++)
    p[v].fileMimes && p[v].fileMimes.includes($) && r.push(p[v].id);
  return r;
}
function findLoaderToOpen($) {
  let r = [];
  const p = Object.entries(FileLoaders);
  for (let v = 0; v < p.length; v++) {
    const x = p[v][1];
    for (let S = 0; S < x.extensions.length; S++)
      $.endsWith(x.extensions[S]) && r.push(x);
    x.extensions.length || r.push(x);
  }
  return r;
}
function getAllFileHandlers() {
  Log({
    source: "fs/open.ts: getAllFileHandlers",
    msg: "Compiling a list of file handler IDs...",
    level: LogLevel.info,
  });
  const $ = [],
    r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++) r[p].fileMimes && $.push(r[p].id);
  return $;
}
function openWithDialog($) {
  if (isDisabled("OpenWithApp"))
    return errorMessage(
      "Can't open file",
      `The OpenWithApp application is disabled, so you can't choose an app to open ${$.name}.`,
      null,
      null,
      { caption: "OK", action() {} },
      {
        caption: "Enable OpenWithApp",
        action() {
          enableApp("OpenWithApp"),
            OpenWithFile.set($),
            openWindow("OpenWithApp");
        },
      }
    );
  Log({
    source: "fs/open.ts: openWithDialog",
    msg: `Opening ArcOS.OpenWith for "${$.name}"`,
    level: LogLevel.info,
  }),
    OpenWithFile.set($),
    openWindow("OpenWithApp");
}
function openWith($, r, p) {
  Log({
    source: "fs/open.ts: openWith",
    msg: `Opening ${r.name} with ArcOS.${$}`,
    level: LogLevel.info,
  });
  const v = get_store_value(WindowStore);
  for (let k = 0; k < v.length; k++) {
    const x = v[k];
    if (!(!x.fileMimes || (!x.fileMimes.includes(r.mime) && !p) || $ != x.id))
      return (
        (x.openedFile = r),
        openWindow($),
        focusedWindowId.set($),
        x.events && x.events.openFile && x.events.openFile(x),
        !0
      );
  }
  return !1;
}
async function openUserFile($) {
  Log({
    source: "fs/open.ts: openUserFile",
    msg: `Converting "${$.filename}": UserFile -> ArcFile: to make openable`,
    level: LogLevel.info,
  });
  let r = {
    data: await readFile($.scopedPath),
    name: $.filename,
    path: $.scopedPath,
    mime: $.mime,
  };
  const p = findAppToOpen($.mime),
    v = findLoaderToOpen($.filename);
  return !(p.length > 0) && !(v.length > 1)
    ? r
    : p.length > 0
    ? openWith(p[0], r) || r
    : (v.length == 2 && v[0].loader(r), !0);
}
async function compileSearchableFiles() {
  const $ = get_store_value(ConnectedServer);
  if (!$) return [];
  const r = [],
    v = (await apiCall($, "fs/tree", {}, get_store_value(UserToken))).data;
  for (let k = 0; k < v.length; k++)
    r.push({
      caption: v[k].filename,
      action: async () => {
        const x = makeNotification({
            title: "Loading file",
            message: `Loading file ${v[k].filename} from the ArcAPI. This can take a while, depending on your internet connection and the size of the file.`,
            buttons: [],
            image: searchIcon,
          }),
          S = v[k].scopedPath;
        S.startsWith("./") && (v[k].scopedPath = S.replace("./", ""));
        const I = await openUserFile(v[k]);
        deleteNotification(x),
          closeNotification(),
          WindowStore.set(get_store_value(WindowStore)),
          I != !0 && openWithDialog({ ...I, anymime: !0 });
      },
      description: v[k].scopedPath.replace(`/${v[k].filename}`, ""),
      image: fileIcon,
    });
  return r;
}
FileBrowserCurrentDir.subscribe(() => {});
function compileSearchableSettingsPages() {
  const $ = [],
    r = SettingsPages;
  for (let p = 0; p < r.length; p++) {
    const v = r[p];
    $.push({
      image: v.icon,
      caption: v.name,
      action: () => {
        openWindow("SettingsApp"),
          setTimeout(() => {
            currentSettingsPage.set(v);
          });
      },
    });
  }
  return $;
}
const searchProviders = [
    compileSearchableApps,
    compileSearchableSettingsPages,
    compileSearchableFiles,
  ],
  powerOptions = [
    {
      caption: "Shutdown",
      description: "Leave the desktop and turn off ArcOS",
      action: shutdown,
      image: shutdownIcon,
    },
    {
      caption: "Restart",
      description: "Leave the desktop and reload ArcOS",
      action: () => restart$1(!1),
      image: shutdownIcon,
    },
  ];
async function getSearchItems() {
  let $ = [...powerOptions];
  for (let r = 0; r < searchProviders.length; r++)
    $.push(...(await searchProviders[r]()));
  return console.log($), $;
}
const showArcFind = writable(!1);
async function Search($) {
  const r = await getSearchItems(),
    p = { includeScore: !0, keys: ["caption", "description"] };
  return new Fuse(r, p).search($);
}
const previouslyLoaded = writable(!1),
  startOpened = writable(!1),
  loggingOff = writable(!1),
  shuttingDown = writable(!1),
  restarting = writable(!1),
  showDesktop = writable(!1),
  desktopClassNames = writable("");
function assignDesktopListeners() {
  UserData.subscribe(($) => {
    if ($) {
      const r = $;
      let p = "";
      r.sh.taskbar.docked && (p += "tbdocked "),
        r.sh.anim || (p += "noani "),
        r.sh.noGlass && (p += "noglass "),
        r.sh.window.bigtb && (p += "bigtitlebars "),
        r.sh.desktop.sharp && (p += "sharp "),
        r.sh.taskbar.isLauncher && (p += "is-launcher "),
        r.sh.taskbar.docked && (p += "tb-docked "),
        desktopClassNames.set(p);
    }
  }),
    AppPokerData.subscribe(($) => {
      $ ? openWindow("AppPoker") : closeWindow("AppPoker");
    }),
    loggingOff.subscribe(($) => {
      $ &&
        (showDesktop.set(!1),
        setTimeout(() => {
          applyState("logoff"), loggingOff.set(!1);
        }, 500));
    }),
    restarting.subscribe(($) => {
      $ &&
        (showDesktop.set(!1),
        setTimeout(() => {
          applyState("restart"), restarting.set(!1);
        }, 500));
    }),
    shuttingDown.subscribe(($) => {
      $ &&
        (showDesktop.set(!1),
        setTimeout(() => {
          applyState("shutdown"), shuttingDown.set(!1);
        }, 500));
    }),
    registerShortcuts([
      {
        key: "q",
        alt: !0,
        action() {
          getOpenedStore().length
            ? (getWindow(get_store_value(focusedWindowId)).state.windowState
                .fll && isFullscreenWindow.set(!1),
              closeWindow(get_store_value(focusedWindowId)))
            : openWindow("Exit"),
            startOpened.set(!1),
            ActionCenterOpened.set(!1),
            CurrentNotification.set(null),
            focusedWindowId.set(null);
        },
        global: !0,
      },
      {
        key: "r",
        alt: !0,
        shift: !0,
        action() {
          startOpened.set(!1),
            ActionCenterOpened.set(!1),
            reloadApps(),
            setTimeout(() => {
              isFullscreenWindow.set(!0);
            }, 100),
            setTimeout(() => {
              isFullscreenWindow.set(!1);
            }, 1e3);
        },
        global: !0,
      },
      {
        key: "s",
        shift: !0,
        alt: !0,
        global: !0,
        action: () => {
          if (get_store_value(UserData).sh.taskbar.isLauncher)
            return openWindow("AppLauncher"), showArcFind.set(!1);
          isOpened("AppLauncher")
            ? showArcFind.set(!1)
            : showArcFind.set(!get_store_value(showArcFind));
        },
      },
      {
        key: "n",
        alt: !0,
        global: !0,
        action: () => {
          ActionCenterOpened.set(!get_store_value(ActionCenterOpened));
        },
      },
      {
        key: "z",
        alt: !0,
        shift: !0,
        global: !0,
        action: () => {
          openWindow("AppMan");
        },
      },
    ]);
}
function openWindow($, r = !1) {
  Log({
    msg: `Opening ${$}`,
    source: "events.ts: openWindow",
    level: LogLevel.info,
  });
  const p = getWindow($);
  if (!isLoaded($) || isOpened($)) {
    const k = getWindowElement(p);
    if (!k) return;
    maxZIndex.set(get_store_value(maxZIndex) + 1),
      (k.style.zIndex = `${get_store_value(maxZIndex)}`),
      unminimizeWindow(p);
    return;
  }
  if (p.parentId && !isOpened(p.parentId)) {
    if (!r)
      return (
        Log({
          source: "events.ts: openWindow",
          msg: `The parent "${p.parentId}" of child window "${p.id}" must be opened before the child can be opened.`,
          level: LogLevel.error,
        }),
        !1
      );
    openWindow(p.parentId);
  }
  const v = get_store_value(WindowStore);
  for (let k = 0; k < v.length; k++) v[k].id == $ && (v[k].opened = !0);
  return (
    WindowStore.set(v),
    setTimeout(() => {
      const k = getWindowElement(p);
      k &&
        (maxZIndex.set(get_store_value(maxZIndex) + 1),
        (k.style.zIndex = `${get_store_value(maxZIndex)}`),
        focusedWindowId.set($));
    }, 10),
    startOpened.set(!1),
    ActionCenterOpened.set(!1),
    updateStores(),
    focusedWindowId.set($),
    p.events && p.events.open && p.events.open(p),
    !0
  );
}
function closeChildWindow($, r) {
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++)
    if (p[v].parentId == $.id && p[v].id == r) return closeWindow(r), !0;
  return !1;
}
function closeWindow($) {
  if (
    (Log({
      msg: `Closing ${$}`,
      source: "events.ts: closeWindow",
      level: LogLevel.info,
    }),
    !isOpened($))
  )
    return !1;
  const r = get_store_value(WindowStore),
    p = getWindow($);
  for (let v = 0; v < r.length; v++)
    if (r[v] && r[v].id == $) {
      (r[v].opened = !1), (r[v].openedFile = null);
      break;
    }
  if (p.children) {
    const v = Object.entries(p.children);
    for (let k = 0; k < v.length; k++) closeChildWindow(p, v[k][0]);
  }
  if (p.errorOverlays)
    for (let v = 0; v < p.errorOverlays.length; v++)
      destroyOverlayableError(p.errorOverlays[v].id, p.id);
  if (p.overlays) {
    const v = Object.entries(p.overlays);
    for (let k = 0; k < v.length; k++) hideOverlay(v[k][0], $);
  }
  return (
    (p.snapped = !1),
    WindowStore.set(r),
    p.events && p.events.close && p.events.close(p),
    !0
  );
}
function maximizeWindow($) {
  Log({
    msg: `Switching maximized state of ${$.id}`,
    source: "events.ts: maximizeWindow",
    level: LogLevel.info,
  }),
    ($.state.windowState.max = !$.state.windowState.max),
    focusedWindowId.set($.id),
    $.events && $.events.maximize && $.events.maximize($),
    updateStores();
}
function minimizeWindow($) {
  if (
    (Log({
      msg: `Switching minimized state of ${$.id}`,
      source: "events.ts: minimizeWindow",
      level: LogLevel.info,
    }),
    ($.state.windowState.min = !$.state.windowState.min),
    focusedWindowId.set(null),
    $.state.windowState.min)
  ) {
    const r = getWindowElement($);
    r.style.zIndex = "0";
  }
  $.events && $.events.minimize && $.events.minimize($), updateStores();
}
function unminimizeWindow($) {
  Log({
    msg: `Disabling minimized state of ${$.id}`,
    source: "events.ts: unminimizeWindow",
    level: LogLevel.info,
  });
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++)
    r[p].id == $.id && (r[p].state.windowState.min = !1);
  focusedWindowId.set($.id), WindowStore.set(r);
}
function fullscreenToggle($) {
  Log({
    msg: `Switching fullscreen state of ${$}`,
    source: "events.ts: fullscreenToggle",
    level: LogLevel.info,
  });
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++)
    r[p].id == $ && (r[p].state.windowState.fll = !r[p].state.windowState.fll);
  WindowStore.set(r);
}
function shutdown() {
  let $ = 0;
  const r = get_store_value(WindowStore);
  for (let p = 0; p < r.length; p++)
    ($ += 50),
      setTimeout(() => {
        closeWindow(r[p].id);
      }, $);
  logoffToken(), shuttingDown.set(!0);
}
function restart$1($ = !1) {
  let r = 0;
  const p = get_store_value(WindowStore);
  for (let v = 0; v < p.length; v++)
    (r += 50),
      setTimeout(() => {
        closeWindow(p[v].id);
      }, r);
  $ && (localStorage.removeItem("arcos-remembered-token"), logoffToken()),
    restarting.set(!0);
}
const source = "UserLogic: UserData watch";
let commitTimeout;
function commitUserdata($) {
  if ($) {
    if (
      (clearTimeout(commitTimeout),
      committingUserData.set(!0),
      get_store_value(UserName))
    ) {
      Log({ level: LogLevel.info, msg: "Change Detected, committing", source }),
        DevModeOverride.set($.devmode);
      const r = setUserdata($);
      unsetStatus(),
        r ||
          (Log({
            level: LogLevel.error,
            msg: "Commit failed, setter returned false",
            source,
          }),
          get_store_value(BugReportData) || commitFailed());
      return;
    }
    unsetStatus(),
      Log({ level: LogLevel.warn, msg: "Not committing, no username", source });
  }
}
function unsetStatus() {
  commitTimeout = setTimeout(() => {
    committingUserData.set(!1);
  }, 1500);
}
function commitFailed() {
  BugReportData.set([
    !0,
    {
      icon: "person_off",
      title: "User data commit failed",
      message:
        "The user data could not be saved. This happens if the<br>user data is altered while ArcOS is running.",
      details: "UserLogic: UserData watch: setter returned false",
      button: {
        action: () => {
          applyState("fts");
        },
        caption: "Reset",
      },
    },
  ]);
}
const committingUserData = writable(!1);
async function getUsers() {
  Log({
    msg: "Getting users",
    source: "userlogic/main.ts: getUsers",
    level: LogLevel.info,
  });
  const $ = get_store_value(ConnectedServer);
  if (!$) return [];
  const r = await apiCall($, "users/get", {}, null, null);
  let p = {};
  const v = r.data;
  for (let k = 0; k < v.length; k++) p[v[k].username] = v[k];
  return p;
}
async function deleteUser() {
  Log({
    msg: "Delete users",
    source: "userlogic/main.ts: deleteUsers",
    level: LogLevel.info,
  });
  const $ = get_store_value(ConnectedServer),
    r = get_store_value(UserToken);
  $ &&
    (apiCall($, "user/delete", {}, r),
    get_store_value(CurrentState).name == "Desktop" && restart$1());
}
async function getUserdata($) {
  Log({
    msg: `Getting userdata for "${$}"`,
    source: "userlogic/main.ts: getUserdata",
    level: LogLevel.info,
  });
  const r = await getUsers();
  if (r[$]) return r[$];
}
async function setUserdata($) {
  Log({
    msg: "Setting userdata",
    source: "userlogic/main.ts: setUserdata",
    level: LogLevel.info,
  });
  const r = get_store_value(ConnectedServer);
  if (!r) return !1;
  (
    await apiCall(
      r,
      "user/properties/update",
      {},
      get_store_value(UserToken),
      null,
      JSON.stringify($)
    )
  ).valid &&
    Log({
      msg: "Userdata committed to API",
      source: "userlogic/main.ts: setUserdata",
      level: LogLevel.info,
    });
}
UserData.subscribe(commitUserdata);
function create_if_block$l($) {
  let r, p, v, k, x, S, I, F, O, L, U, N;
  return (
    (p = new ProfilePicture$1({ props: { src: $[3], height: 151 } })),
    (F = new Spinner({ props: { height: 23 } })),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          (k = element("h1")),
          (x = text($[1])),
          (S = space()),
          (I = element("h3")),
          create_component(F.$$.fragment),
          (O = text(" ")),
          (L = element("span")),
          (U = text($[0])),
          attr(r, "class", "userlogin show");
      },
      m(j, R) {
        insert(j, r, R),
          mount_component(p, r, null),
          append(r, v),
          append(r, k),
          append(k, x),
          append(r, S),
          append(r, I),
          mount_component(F, I, null),
          append(I, O),
          append(I, L),
          append(L, U),
          (N = !0);
      },
      p(j, R) {
        const q = {};
        R & 8 && (q.src = j[3]),
          p.$set(q),
          (!N || R & 2) && set_data(x, j[1]),
          (!N || R & 1) && set_data(U, j[0]);
      },
      i(j) {
        N ||
          (transition_in(p.$$.fragment, j),
          transition_in(F.$$.fragment, j),
          (N = !0));
      },
      o(j) {
        transition_out(p.$$.fragment, j),
          transition_out(F.$$.fragment, j),
          (N = !1);
      },
      d(j) {
        j && detach(r), destroy_component(p), destroy_component(F);
      },
    }
  );
}
function create_fragment$I($) {
  let r,
    p,
    v = $[2] && $[3] && create_if_block$l($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[2] && k[3]
        ? v
          ? (v.p(k, x), x & 12 && transition_in(v, 1))
          : ((v = create_if_block$l(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$D($, r, p) {
  let v, k;
  component_subscribe($, UserName, (L) => p(5, (v = L))),
    component_subscribe($, loginUsername, (L) => p(6, (k = L)));
  let { caption: x } = r,
    { username: S = "" } = r,
    I = "",
    F,
    O = "";
  return (
    onMount(async () => {
      p(1, (I = k || v || S)),
        p(2, (F = await getUserdata(I))),
        p(3, (O = await getUserPfp(I))),
        O == pfp && p(3, (O = logo$d));
    }),
    ($.$$set = (L) => {
      "caption" in L && p(0, (x = L.caption)),
        "username" in L && p(4, (S = L.username));
    }),
    [x, I, F, O, S]
  );
}
class Loading extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$D, create_fragment$I, safe_not_equal, {
        caption: 0,
        username: 4,
      });
  }
}
function create_fragment$H($) {
  let r, p;
  return (
    (r = new Loading({ props: { caption: "Welcome" } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
class AutoLogin extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$H, safe_not_equal, {});
  }
}
const userlogin = "";
function flush() {
  UserName.set(void 0),
    loginUsername.set(void 0),
    NotificationStore.set({}),
    ErrorMessages.set([]),
    DevModeOverride.set(!1);
}
function create_fragment$G($) {
  let r, p;
  return (
    (r = new Loading({ props: { caption: "Goodbye", username: $[0] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, [k]) {
        const x = {};
        k & 1 && (x.username = v[0]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function instance$C($, r, p) {
  let v;
  return (
    component_subscribe($, UserName, (k) => p(0, (v = k))),
    onMount(() => {
      setTimeout(() => {
        flush(), applyLoginState("selector");
      }, 2e3);
    }),
    [v]
  );
}
class Logoff extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$C, create_fragment$G, safe_not_equal, {});
  }
}
function create_fragment$F($) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.textContent = "Cancel"),
        attr(r, "class", "switchuser"),
        toggle_class(r, "show", $[0]);
    },
    m(k, x) {
      insert(k, r, x), p || ((v = listen(r, "click", $[1])), (p = !0));
    },
    p(k, [x]) {
      x & 1 && toggle_class(r, "show", k[0]);
    },
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function instance$B($, r, p) {
  let { show: v } = r;
  const k = () => applyLoginState("selector");
  return (
    ($.$$set = (x) => {
      "show" in x && p(0, (v = x.show));
    }),
    [v, k]
  );
}
class Cancel extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$B, create_fragment$F, safe_not_equal, { show: 0 });
  }
}
function create_fragment$E($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K, V;
  return (
    (r = new ProfilePicture$1({ props: { src: pfp, height: 151 } })),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          (v = element("h1")),
          (v.textContent = "New user"),
          (k = space()),
          (x = element("form")),
          (S = element("input")),
          (I = space()),
          (F = element("div")),
          (O = element("form")),
          (L = element("input")),
          (N = space()),
          (j = element("button")),
          (R = text("arrow_forward_ios")),
          attr(S, "type", "text"),
          attr(S, "placeholder", "Username"),
          attr(S, "class", "block"),
          (S.disabled = $[0]),
          attr(L, "type", "password"),
          attr(L, "placeholder", "Password"),
          attr(L, "class", "block"),
          (L.disabled = U = $[0] || !$[1]),
          (j.disabled = q = $[0] || !$[1] || !$[2]),
          attr(j, "class", "createbutton material-icons-round"),
          attr(F, "class", "input-wrapper");
      },
      m(H, G) {
        mount_component(r, H, G),
          insert(H, p, G),
          insert(H, v, G),
          insert(H, k, G),
          insert(H, x, G),
          append(x, S),
          set_input_value(S, $[1]),
          insert(H, I, G),
          insert(H, F, G),
          append(F, O),
          append(O, L),
          set_input_value(L, $[2]),
          append(F, N),
          append(F, j),
          append(j, R),
          (Q = !0),
          K ||
            ((V = [
              listen(S, "input", $[4]),
              listen(x, "submit", $[3]),
              listen(L, "input", $[5]),
              listen(O, "submit", $[3]),
              listen(j, "click", $[3]),
            ]),
            (K = !0));
      },
      p(H, [G]) {
        (!Q || G & 1) && (S.disabled = H[0]),
          G & 2 && S.value !== H[1] && set_input_value(S, H[1]),
          (!Q || (G & 3 && U !== (U = H[0] || !H[1]))) && (L.disabled = U),
          G & 4 && L.value !== H[2] && set_input_value(L, H[2]),
          (!Q || (G & 7 && q !== (q = H[0] || !H[1] || !H[2]))) &&
            (j.disabled = q);
      },
      i(H) {
        Q || (transition_in(r.$$.fragment, H), (Q = !0));
      },
      o(H) {
        transition_out(r.$$.fragment, H), (Q = !1);
      },
      d(H) {
        destroy_component(r, H),
          H && detach(p),
          H && detach(v),
          H && detach(k),
          H && detach(x),
          H && detach(I),
          H && detach(F),
          (K = !1),
          run_all(V);
      },
    }
  );
}
function instance$A($, r, p) {
  let v;
  component_subscribe($, ConnectedServer, (L) => p(6, (v = L)));
  let { loading: k } = r,
    { username: x } = r,
    { password: S } = r;
  async function I(L) {
    if ((L && L.preventDefault(), !x || !S || k)) return !1;
    loginUsername.set(x),
      p(0, (k = !0)),
      await apiCall(v, "user/create", {}, null, { username: x, password: S });
    const U = await loginUsingCreds(
      generateCredToken({ username: x, password: S })
    );
    return U
      ? (UserData.set(U), UserName.set(x), applyState("desktop"), !1)
      : p(0, (k = !1));
  }
  function F() {
    (x = this.value), p(1, x);
  }
  function O() {
    (S = this.value), p(2, S);
  }
  return (
    ($.$$set = (L) => {
      "loading" in L && p(0, (k = L.loading)),
        "username" in L && p(1, (x = L.username)),
        "password" in L && p(2, (S = L.password));
    }),
    [k, x, S, I, F, O]
  );
}
class Form extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$A, create_fragment$E, safe_not_equal, {
        loading: 0,
        username: 1,
        password: 2,
      });
  }
}
function create_else_block$6($) {
  let r, p;
  return (
    (r = new Loading({ props: { caption: "Welcome" } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block_1$6($) {
  let r, p, v, k, x;
  function S(L) {
    $[4](L);
  }
  function I(L) {
    $[5](L);
  }
  function F(L) {
    $[6](L);
  }
  let O = {};
  return (
    $[2] !== void 0 && (O.loading = $[2]),
    $[0] !== void 0 && (O.username = $[0]),
    $[1] !== void 0 && (O.password = $[1]),
    (r = new Form({ props: O })),
    binding_callbacks.push(() => bind$1(r, "loading", S)),
    binding_callbacks.push(() => bind$1(r, "username", I)),
    binding_callbacks.push(() => bind$1(r, "password", F)),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(L, U) {
        mount_component(r, L, U), (x = !0);
      },
      p(L, U) {
        const N = {};
        !p &&
          U & 4 &&
          ((p = !0), (N.loading = L[2]), add_flush_callback(() => (p = !1))),
          !v &&
            U & 1 &&
            ((v = !0), (N.username = L[0]), add_flush_callback(() => (v = !1))),
          !k &&
            U & 2 &&
            ((k = !0), (N.password = L[1]), add_flush_callback(() => (k = !1))),
          r.$set(N);
      },
      i(L) {
        x || (transition_in(r.$$.fragment, L), (x = !0));
      },
      o(L) {
        transition_out(r.$$.fragment, L), (x = !1);
      },
      d(L) {
        destroy_component(r, L);
      },
    }
  );
}
function create_if_block$k($) {
  let r, p;
  return (
    (r = new Cancel({ props: { show: $[3] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 8 && (x.show = v[3]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$D($) {
  let r, p, v, k, x;
  const S = [create_if_block_1$6, create_else_block$6],
    I = [];
  function F(L, U) {
    return L[2] ? 1 : 0;
  }
  (p = F($)), (v = I[p] = S[p]($));
  let O = !$[2] && create_if_block$k($);
  return {
    c() {
      (r = element("div")),
        v.c(),
        (k = space()),
        O && O.c(),
        attr(r, "class", "userlogin newuser"),
        toggle_class(r, "show", $[3]);
    },
    m(L, U) {
      insert(L, r, U),
        I[p].m(r, null),
        append(r, k),
        O && O.m(r, null),
        (x = !0);
    },
    p(L, [U]) {
      let N = p;
      (p = F(L)),
        p === N
          ? I[p].p(L, U)
          : (group_outros(),
            transition_out(I[N], 1, 1, () => {
              I[N] = null;
            }),
            check_outros(),
            (v = I[p]),
            v ? v.p(L, U) : ((v = I[p] = S[p](L)), v.c()),
            transition_in(v, 1),
            v.m(r, k)),
        L[2]
          ? O &&
            (group_outros(),
            transition_out(O, 1, 1, () => {
              O = null;
            }),
            check_outros())
          : O
          ? (O.p(L, U), U & 4 && transition_in(O, 1))
          : ((O = create_if_block$k(L)),
            O.c(),
            transition_in(O, 1),
            O.m(r, null)),
        (!x || U & 8) && toggle_class(r, "show", L[3]);
    },
    i(L) {
      x || (transition_in(v), transition_in(O), (x = !0));
    },
    o(L) {
      transition_out(v), transition_out(O), (x = !1);
    },
    d(L) {
      L && detach(r), I[p].d(), O && O.d();
    },
  };
}
function instance$z($, r, p) {
  let v = "",
    k = "",
    x = !1,
    S = !1;
  onMount(() => {
    setTimeout(() => {
      p(3, (S = !0));
    });
  });
  function I(L) {
    (x = L), p(2, x);
  }
  function F(L) {
    (v = L), p(0, v);
  }
  function O(L) {
    (k = L), p(1, k);
  }
  return [v, k, x, S, I, F, O];
}
class NewApiUser extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$z, create_fragment$D, safe_not_equal, {});
  }
}
function create_fragment$C($) {
  let r, p;
  return (
    (r = new Loading({ props: { caption: "Restarting" } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function instance$y($) {
  return (
    setTimeout(() => {
      location.reload();
    }, 2e3),
    []
  );
}
class Restart extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$y, create_fragment$C, safe_not_equal, {});
  }
}
function create_fragment$B($) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.textContent = "Create Account"),
        attr(r, "class", "createacc");
    },
    m(k, x) {
      insert(k, r, x), p || ((v = listen(r, "click", $[0])), (p = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function instance$x($) {
  return [() => applyLoginState("newapiuser")];
}
class CreateButton extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$x, create_fragment$B, safe_not_equal, {});
  }
}
function create_if_block$j($) {
  let r, p, v, k, x, S, I, F;
  return (
    (p = new ProfilePicture$1({ props: { src: $[2], height: 76 } })),
    {
      c() {
        (r = element("button")),
          create_component(p.$$.fragment),
          (v = space()),
          (k = element("p")),
          (x = text($[1])),
          attr(k, "class", "username"),
          attr(r, "class", "user");
      },
      m(O, L) {
        insert(O, r, L),
          mount_component(p, r, null),
          append(r, v),
          append(r, k),
          append(k, x),
          (S = !0),
          I || ((F = listen(r, "click", $[3])), (I = !0));
      },
      p(O, L) {
        const U = {};
        L & 4 && (U.src = O[2]), p.$set(U), (!S || L & 2) && set_data(x, O[1]);
      },
      i(O) {
        S || (transition_in(p.$$.fragment, O), (S = !0));
      },
      o(O) {
        transition_out(p.$$.fragment, O), (S = !1);
      },
      d(O) {
        O && detach(r), destroy_component(p), (I = !1), F();
      },
    }
  );
}
function create_fragment$A($) {
  let r,
    p,
    v = $[0].acc.enabled && create_if_block$j($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[0].acc.enabled
        ? v
          ? (v.p(k, x), x & 1 && transition_in(v, 1))
          : ((v = create_if_block$j(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$w($, r, p) {
  let v = "",
    { data: k } = r,
    { name: x } = r;
  function S() {
    loginUsername.set(x), applyLoginState("todesktop");
  }
  return (
    onMount(() => {
      p(2, (v = getProfilePicture(k.acc.profilePicture)));
    }),
    ($.$$set = (I) => {
      "data" in I && p(0, (k = I.data)), "name" in I && p(1, (x = I.name));
    }),
    [k, x, v, S]
  );
}
class User extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$w, create_fragment$A, safe_not_equal, {
        data: 0,
        name: 1,
      });
  }
}
function get_each_context$6($, r, p) {
  const v = $.slice();
  return (v[1] = r[p]), v;
}
function create_if_block$i($) {
  let r,
    p,
    v = Object.keys($[0]),
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$6(get_each_context$6($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 1) {
        v = Object.keys(S[0]);
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$6(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$6(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_each_block$6($) {
  let r, p;
  return (
    (r = new User({ props: { data: $[0][$[1]], name: $[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.data = v[0][v[1]]), k & 1 && (x.name = v[1]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$z($) {
  let r,
    p,
    v = $[0] && create_if_block$i($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[0]
        ? v
          ? (v.p(k, x), x & 1 && transition_in(v, 1))
          : ((v = create_if_block$i(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$v($, r, p) {
  let v;
  return (
    onMount(async () => {
      p(0, (v = await getUsers()));
    }),
    [v]
  );
}
class Populator extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$v, create_fragment$z, safe_not_equal, {});
  }
}
function create_fragment$y($) {
  let r, p, v, k, x;
  return (
    (p = new Populator({})),
    (k = new CreateButton({})),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          create_component(k.$$.fragment),
          attr(r, "class", "user-selector");
      },
      m(S, I) {
        insert(S, r, I),
          mount_component(p, r, null),
          append(r, v),
          mount_component(k, r, null),
          (x = !0);
      },
      p: noop$1,
      i(S) {
        x ||
          (transition_in(p.$$.fragment, S),
          transition_in(k.$$.fragment, S),
          (x = !0));
      },
      o(S) {
        transition_out(p.$$.fragment, S),
          transition_out(k.$$.fragment, S),
          (x = !1);
      },
      d(S) {
        S && detach(r), destroy_component(p), destroy_component(k);
      },
    }
  );
}
class Selector extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$y, safe_not_equal, {});
  }
}
function create_fragment$x($) {
  let r, p;
  return (
    (r = new Loading({ props: { caption: "Shutting down" } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function instance$u($) {
  return (
    onMount(() => {
      setTimeout(() => {
        flush(), applyState("turnedoff");
      }, 2e3);
    }),
    []
  );
}
class Shutdown extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$u, create_fragment$x, safe_not_equal, {});
  }
}
function create_fragment$w($) {
  let r, p, v, k, x, S, I, F;
  return {
    c() {
      (r = element("form")),
        (p = element("input")),
        (v = space()),
        (k = element("button")),
        (x = text("arrow_forward_ios")),
        (p.autofocus = !0),
        attr(p, "type", "password"),
        attr(p, "placeholder", "Password"),
        toggle_class(p, "wrongpswd", $[1]),
        attr(k, "class", "material-icons-round"),
        (k.disabled = S = !$[0]);
    },
    m(O, L) {
      insert(O, r, L),
        append(r, p),
        set_input_value(p, $[0]),
        insert(O, v, L),
        insert(O, k, L),
        append(k, x),
        p.focus(),
        I ||
          ((F = [
            listen(p, "input", $[6]),
            listen(p, "input", $[7]),
            listen(r, "submit", $[2]),
            listen(k, "click", $[3]),
          ]),
          (I = !0));
    },
    p(O, [L]) {
      L & 1 && p.value !== O[0] && set_input_value(p, O[0]),
        L & 2 && toggle_class(p, "wrongpswd", O[1]),
        L & 1 && S !== (S = !O[0]) && (k.disabled = S);
    },
    i: noop$1,
    o: noop$1,
    d(O) {
      O && detach(r), O && detach(v), O && detach(k), (I = !1), run_all(F);
    },
  };
}
function instance$t($, r, p) {
  let v;
  component_subscribe($, loginUsername, (N) => p(8, (v = N)));
  let { authenticating: k } = r,
    x,
    S = !1,
    { pfp: I = "" } = r;
  onMount(async () => {
    v || applyLoginState("selector"), p(5, (I = await getUserPfp(v)));
  });
  function F(N) {
    return N.preventDefault(), O(), !1;
  }
  async function O() {
    p(4, (k = !0));
    const N = await loginUsingCreds(
      generateCredToken({ username: v, password: x })
    );
    if (!N) {
      p(4, (k = !1)), p(1, (S = !0));
      return;
    }
    localStorage.setItem("arcos-remembered-token", btoa(`${v}:${x}`)),
      UserData.set(N),
      UserName.set(v),
      applyState("desktop");
  }
  function L() {
    (x = this.value), p(0, x);
  }
  const U = () => p(1, (S = !1));
  return (
    ($.$$set = (N) => {
      "authenticating" in N && p(4, (k = N.authenticating)),
        "pfp" in N && p(5, (I = N.pfp));
    }),
    [x, S, F, O, k, I, L, U]
  );
}
class Input extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$t, create_fragment$w, safe_not_equal, {
        authenticating: 4,
        pfp: 5,
      });
  }
}
function create_if_block_1$5($) {
  let r, p, v, k, x;
  return (
    (r = new ProfilePicture$1({ props: { src: $[1], height: 151 } })),
    {
      c() {
        create_component(r.$$.fragment),
          (p = space()),
          (v = element("h1")),
          (k = text($[2]));
      },
      m(S, I) {
        mount_component(r, S, I),
          insert(S, p, I),
          insert(S, v, I),
          append(v, k),
          (x = !0);
      },
      p(S, I) {
        const F = {};
        I & 2 && (F.src = S[1]), r.$set(F), (!x || I & 4) && set_data(k, S[2]);
      },
      i(S) {
        x || (transition_in(r.$$.fragment, S), (x = !0));
      },
      o(S) {
        transition_out(r.$$.fragment, S), (x = !1);
      },
      d(S) {
        destroy_component(r, S), S && detach(p), S && detach(v);
      },
    }
  );
}
function create_else_block$5($) {
  let r, p;
  return (
    (r = new Loading({ props: { caption: "Welcome" } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p: noop$1,
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$h($) {
  let r, p, v;
  return {
    c() {
      (r = element("button")),
        (r.textContent = "Cancel"),
        attr(r, "class", "switchuser");
    },
    m(k, x) {
      insert(k, r, x), p || ((v = listen(r, "click", $[3])), (p = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r), (p = !1), v();
    },
  };
}
function create_fragment$v($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U = !$[0] && create_if_block_1$5($);
  function N(V) {
    $[4](V);
  }
  function j(V) {
    $[5](V);
  }
  let R = {};
  $[0] !== void 0 && (R.authenticating = $[0]),
    $[1] !== void 0 && (R.pfp = $[1]),
    (k = new Input({ props: R })),
    binding_callbacks.push(() => bind$1(k, "authenticating", N)),
    binding_callbacks.push(() => bind$1(k, "pfp", j));
  const q = [create_if_block$h, create_else_block$5],
    Q = [];
  function K(V, H) {
    return V[0] ? 1 : 0;
  }
  return (
    (F = K($)),
    (O = Q[F] = q[F]($)),
    {
      c() {
        U && U.c(),
          (r = space()),
          (p = element("div")),
          (v = element("div")),
          create_component(k.$$.fragment),
          (I = space()),
          O.c(),
          attr(v, "class", "field"),
          toggle_class(v, "hidden", $[0]),
          attr(p, "class", "cloudlogin");
      },
      m(V, H) {
        U && U.m(V, H),
          insert(V, r, H),
          insert(V, p, H),
          append(p, v),
          mount_component(k, v, null),
          append(p, I),
          Q[F].m(p, null),
          (L = !0);
      },
      p(V, [H]) {
        V[0]
          ? U &&
            (group_outros(),
            transition_out(U, 1, 1, () => {
              U = null;
            }),
            check_outros())
          : U
          ? (U.p(V, H), H & 1 && transition_in(U, 1))
          : ((U = create_if_block_1$5(V)),
            U.c(),
            transition_in(U, 1),
            U.m(r.parentNode, r));
        const G = {};
        !x &&
          H & 1 &&
          ((x = !0),
          (G.authenticating = V[0]),
          add_flush_callback(() => (x = !1))),
          !S &&
            H & 2 &&
            ((S = !0), (G.pfp = V[1]), add_flush_callback(() => (S = !1))),
          k.$set(G),
          (!L || H & 1) && toggle_class(v, "hidden", V[0]);
        let Y = F;
        (F = K(V)),
          F === Y
            ? Q[F].p(V, H)
            : (group_outros(),
              transition_out(Q[Y], 1, 1, () => {
                Q[Y] = null;
              }),
              check_outros(),
              (O = Q[F]),
              O ? O.p(V, H) : ((O = Q[F] = q[F](V)), O.c()),
              transition_in(O, 1),
              O.m(p, null));
      },
      i(V) {
        L ||
          (transition_in(U),
          transition_in(k.$$.fragment, V),
          transition_in(O),
          (L = !0));
      },
      o(V) {
        transition_out(U),
          transition_out(k.$$.fragment, V),
          transition_out(O),
          (L = !1);
      },
      d(V) {
        U && U.d(V),
          V && detach(r),
          V && detach(p),
          destroy_component(k),
          Q[F].d();
      },
    }
  );
}
function instance$s($, r, p) {
  let v;
  component_subscribe($, loginUsername, (O) => p(2, (v = O)));
  let { authenticating: k = !1 } = r,
    x;
  async function S() {
    loginUsername.set(void 0), applyLoginState("selector");
  }
  function I(O) {
    (k = O), p(0, k);
  }
  function F(O) {
    (x = O), p(1, x);
  }
  return (
    ($.$$set = (O) => {
      "authenticating" in O && p(0, (k = O.authenticating));
    }),
    [k, x, v, S, I, F]
  );
}
class AuthForm extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$s, create_fragment$v, safe_not_equal, {
        authenticating: 0,
      });
  }
}
function create_fragment$u($) {
  let r, p, v, k;
  function x(I) {
    $[2](I);
  }
  let S = {};
  return (
    $[0] !== void 0 && (S.authenticating = $[0]),
    (p = new AuthForm({ props: S })),
    binding_callbacks.push(() => bind$1(p, "authenticating", x)),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          attr(r, "class", "userlogin"),
          toggle_class(r, "show", $[1]);
      },
      m(I, F) {
        insert(I, r, F), mount_component(p, r, null), (k = !0);
      },
      p(I, [F]) {
        const O = {};
        !v &&
          F & 1 &&
          ((v = !0),
          (O.authenticating = I[0]),
          add_flush_callback(() => (v = !1))),
          p.$set(O),
          (!k || F & 2) && toggle_class(r, "show", I[1]);
      },
      i(I) {
        k || (transition_in(p.$$.fragment, I), (k = !0));
      },
      o(I) {
        transition_out(p.$$.fragment, I), (k = !1);
      },
      d(I) {
        I && detach(r), destroy_component(p);
      },
    }
  );
}
function instance$r($, r, p) {
  let v = !1,
    k = !1;
  onMount(async () => {
    setTimeout(() => {
      p(1, (k = !0));
    }, 10);
  });
  function x(S) {
    (v = S), p(0, v);
  }
  return [v, k, x];
}
class UserLogin extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$r, create_fragment$u, safe_not_equal, {});
  }
}
const LoginStates = new Map([
    [
      "selector",
      {
        name: "User Selector",
        content: Selector,
        attribs: { topbar: !0, darken: !1 },
        key: "selector",
      },
    ],
    [
      "todesktop",
      {
        name: "Login Redirector -> Desktop",
        content: UserLogin,
        attribs: { topbar: !1, darken: !0 },
        key: "todesktop",
      },
    ],
    [
      "logoff",
      {
        name: "Desktop -> Logoff -> User Selector",
        content: Logoff,
        attribs: { topbar: !1, darken: !0 },
        key: "logoff",
      },
    ],
    [
      "shutdown",
      {
        name: "Desktop -> Logoff -> End",
        content: Shutdown,
        attribs: { topbar: !1, darken: !0 },
        key: "shutdown",
      },
    ],
    [
      "restart",
      {
        name: "Desktop -> Logoff -> Boot",
        content: Restart,
        attribs: { topbar: !1, darken: !0 },
        key: "restart",
      },
    ],
    [
      "newapiuser",
      {
        name: "New User",
        content: NewApiUser,
        attribs: { topbar: !1, darken: !0 },
        key: "newapiuser",
      },
    ],
    [
      "autologin",
      {
        name: "Auto Login",
        content: AutoLogin,
        attribs: { topbar: !1, darken: !0 },
        key: "autologin",
      },
    ],
  ]),
  CurrentLoginState = writable(),
  loginUsername = writable();
function applyLoginState($) {
  if (LoginStates.has($)) {
    Log({
      level: LogLevel.info,
      source: "login/main.ts: applyLoginState",
      msg: `Applying state ${$}`,
    });
    const r = LoginStates.get($);
    CurrentLoginState.set(r);
    return;
  }
  InvalidStateBugrep("Login", $);
}
async function loginOnMount() {
  const $ = await getUsers(),
    r = localStorage.getItem("arcos-remembered-token"),
    p = get_store_value(CurrentLoginState),
    v = get_store_value(ConnectedServer);
  if (
    (setTimeout(() => {
      if (
        (p || applyLoginState(r ? "autologin" : "selector"),
        !Object.keys($).length && !r)
      ) {
        v ? applyLoginState("newapiuser") : applyState("fts");
        return;
      }
    }, 100),
    r && (!p || (p.key != "shutdown" && p.key != "restart")))
  ) {
    const k = await loginUsingCreds(r),
      x = atob(r).split(":")[0];
    if (!k) {
      applyLoginState("selector"),
        localStorage.removeItem("arcos-remembered-token");
      return;
    }
    loginUsername.set(x),
      UserData.set(k),
      UserName.set(x),
      setTimeout(() => {
        applyState("desktop");
      }, 2e3);
  }
}
async function loginUsingCreds($) {
  let [r, p] = atob($).split(":");
  const v = get_store_value(ConnectedServer);
  loginUsername.set(r);
  let k = await apiCall(get_store_value(ConnectedServer), "auth", {}, null, {
    username: r,
    password: p,
  });
  return !k.valid ||
    (UserToken.set(k.data.token),
    UserName.set(r),
    (k = await apiCall(
      v,
      "user/properties",
      {},
      get_store_value(UserToken),
      null
    )),
    !k.valid)
    ? !1
    : k;
}
async function rememberedLogin() {
  const $ = localStorage.getItem("arcos-remembered-token");
  if (!$) return !1;
  const [r, p] = atob($).split(":"),
    v = await loginUsingCreds(generateCredToken({ username: r, password: p }));
  return v ? (UserData.set(v), UserName.set(r), !0) : !1;
}
function ttlFetch($, r, p = 3e3) {
  return new Promise((v, k) => {
    const x = setTimeout(() => {
      k(new Error("TIMEOUT"));
    }, p);
    fetch($, r)
      .then((S) => {
        clearTimeout(x), v(S);
      })
      .catch((S) => {
        clearTimeout(x), k(S);
      });
  });
}
const TEST_MODES = [
  [!0, 443],
  [!1, 3333],
  [!0, 80],
  [!1, 80],
  [!0, 3333],
];
async function testConnection($) {
  for (let r = 0; r < TEST_MODES.length; r++) {
    const p = `http${TEST_MODES[r][0] ? "s" : ""}`,
      v = TEST_MODES[r][1],
      k = `${p}://${$}:${v}/connect`;
    Log({
      msg: `Testing ${$} on port ${v} and protocol ${p}...`,
      source: "api/test.ts: testConnection",
      level: LogLevel.info,
    });
    try {
      const x = await (await ttlFetch(k, {})).json();
      return (
        Log({
          msg: `Got a response from URL ${k}`,
          source: "api/test.ts: testConnection",
          level: LogLevel.warn,
        }),
        (x.revision || 0) < minArcAPI
          ? !1
          : (ConnectedServer.set(`${p}://${$}:${v}`), x && !!x.valid)
      );
    } catch {
      Log({
        msg: `Did not get a valid response from ${k}`,
        source: "api/test.ts: testConnection",
        level: LogLevel.error,
      });
      continue;
    }
  }
  return (
    Log({
      msg: `Can't connect to server ${$}: none of the modes match`,
      source: "api/test.ts: testConnection",
      level: LogLevel.critical,
    }),
    !1
  );
}
async function authPrompt($, r = "") {
  if (get_store_value(UserName)) return !0;
  let v = localStorage.getItem("arcos-server");
  if (
    (v || (v = await serverConnect($)),
    await rememberedLogin(),
    await sleep(250),
    get_store_value(UserName))
  )
    return await $.env.config.loadConfigFile(), !0;
  $.std.clear(),
    $.std.writeLine(`ArcTerm ${ArcOSVersion} - ${v}

`);
  const k = await $.std.read(`${v} login: `, "", 100, !1, r),
    x = await $.std.read("Password: ", "", 100, !0),
    S = generateCredToken({ username: k, password: x });
  return (
    localStorage.setItem("arcos-remembered-token", S),
    await rememberedLogin(),
    get_store_value(UserName)
      ? (await $.env.config.loadConfigFile(), !0)
      : await authPrompt($, k)
  );
}
async function serverConnect($) {
  $.std.clear(),
    $.std.writeLine(`ArcTerm ${ArcOSVersion} - Connect to server

`);
  const r = await $.std.read("Server: ", "", 50);
  return (
    $.std.writeLine(`Connecting to ${r}...`),
    (await testConnection(r))
      ? (localStorage.setItem("arcos-server", r), r)
      : ($.std.writeLine("Connection failed! Restarting..."),
        await sleep(1e3),
        location.reload(),
        await sleep(2e3),
        "")
  );
}
async function arcTermModeIntro($) {
  if (!(await authPrompt($))) return;
  const r = localStorage.getItem("arcos-server"),
    p = get_store_value(UserName),
    v = await getFSQuota(),
    k = formatBytes(v.used),
    x = formatBytes(v.max),
    S = ((100 / v.max) * v.used).toFixed(2),
    F = (await apiCall(get_store_value(ConnectedServer), "connect", {}))
      .platform;
  disclaimer($), auth($, p, F), api($, r), usage($, k, x, S);
}
function disclaimer($) {
  $.std.clear(),
    $.std.writeColor(
      `[█] You are currently in [ArcTerm mode].
[█] Commands that require the ArcOS desktop have been disabled.

`,
      "orange"
    ),
    $.std.writeColor(`ArcTerm reference ID: [${$.referenceId}]`, "blue");
}
function auth($, r, p) {
  $.std.writeColor(
    `
Authenticated as [${r}] at [${p}]`,
    "aqua",
    "white",
    !0
  );
}
function api($, r) {
  $.std.writeColor(` [(${r})]`, "gray", "white", !0);
}
function usage($, r, p, v) {
  $.std.writeColor(
    `
[ArcFS]: You are using [${r}] of [${p}] total (${v}%)
`,
    "yellow"
  );
}
function create_fragment$t($) {
  let r, p, v;
  return {
    c() {
      (r = element("div")),
        (r.textContent = "authenticating with ArcAPI..."),
        attr(r, "id", "target"),
        attr(r, "class", "terminal-renderer");
    },
    m(k, x) {
      insert(k, r, x), $[2](r), p || ((v = listen(r, "click", $[1])), (p = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r), $[2](null), (p = !1), v();
    },
  };
}
function instance$q($, r, p) {
  let v, k;
  onMount(async () => {
    v = new ArcTerm$1(k, arcCommands, null, arcTermModeIntro);
  });
  function x() {
    !v ||
      !v.input ||
      !v.input.current ||
      (v.input.current.focus(), k && k.scrollTo(0, k.scrollHeight));
  }
  setInterval(x, 10);
  function S(I) {
    binding_callbacks[I ? "unshift" : "push"](() => {
      (k = I), p(0, k);
    });
  }
  return [k, x, S];
}
class ArcTerm_1 extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$q, create_fragment$t, safe_not_equal, {});
  }
}
const Blank_svelte_svelte_type_style_lang = "";
function create_fragment$s($) {
  let r;
  return {
    c() {
      (r = element("div")), attr(r, "class", "fullscreen svelte-1b10uke");
    },
    m(p, v) {
      insert(p, r, v);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
class Blank extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$s, safe_not_equal, {});
  }
}
const boot = "";
function checkZones($, r, p) {
  const v = getBounds(),
    k = getWindow(p);
  if (p.startsWith("error_")) return;
  const x = k.state.resizable || k.controls.max;
  if (!k || !v) return;
  const S = v.lTrig,
    I = v.rTrig,
    F = x && $ > S.xStart && $ < S.xEnd && r > S.yStart && r < S.yEnd,
    O = x && $ > I.xStart && $ < I.xEnd && r > I.yStart && r < I.yEnd;
  leftZoneTriggered.set(F),
    rightZoneTriggered.set(O),
    draggingId.set(F || O ? p : null);
}
function getBounds() {
  const [$, r, p, v] = getZoneElements();
  if (!$ || !r || !p || !v) return !1;
  const k = document.body.offsetWidth;
  return {
    lTrig: {
      xStart: $.offsetLeft,
      xEnd: $.offsetLeft + $.offsetWidth,
      yStart: $.offsetTop,
      yEnd: $.offsetTop + $.offsetHeight,
    },
    rTrig: {
      xStart: k - r.offsetWidth,
      xEnd: k,
      yStart: r.offsetTop,
      yEnd: r.offsetTop + r.offsetHeight,
    },
    lZone: {
      xStart: p.offsetLeft,
      xEnd: p.offsetLeft + p.offsetWidth,
      yStart: p.offsetTop,
      yEnd: p.offsetTop + p.offsetHeight,
    },
    rZone: {
      xStart: k - v.offsetWidth,
      xEnd: k,
      yStart: v.offsetTop,
      yEnd: v.offsetTop + v.offsetHeight,
    },
  };
}
function getZoneElements() {
  const $ = document.querySelector("div.snapzones #snapTriggerLeft"),
    r = document.querySelector("div.snapzones #snapTriggerRight"),
    p = document.querySelector("div.snapzones #snapZoneLeft"),
    v = document.querySelector("div.snapzones #snapZoneRight"),
    k = [$, r, p, v];
  for (let x = 0; x < k.length; x++) if (!k[x]) return [null, null, null, null];
  return k;
}
function snapWindow($) {
  const r = get_store_value(leftZoneTriggered),
    p = get_store_value(rightZoneTriggered);
  (r || p) && draggingId.set($), r && snapLeft(), p && snapRight();
}
function snapLeft() {
  const [$, r, p] = getData();
  if (!p || !$) return;
  let [v, k, x, S] = [0, 0, 0, 0];
  const I = get_store_value(WindowStore);
  for (let F = 0; F < I.length; F++) {
    const O = I[F];
    O.id == r &&
      ((O.pos.x = v = $.lZone.xStart),
      (O.pos.y = k = $.lZone.yStart),
      (O.size.w = x = $.lZone.xEnd),
      (O.size.h = S = $.lZone.yEnd),
      (O.snapped = !0));
  }
  WindowStore.set(I), commitWindow(p, v, k, x, S);
}
function getData() {
  const $ = getBounds(),
    r = get_store_value(draggingId),
    p = getWindowElement(getWindow(r));
  return [$, r, p];
}
function snapRight() {
  const [$, r, p] = getData();
  if (!p || !$) return;
  let [v, k, x, S] = [0, 0, 0, 0];
  const I = get_store_value(WindowStore);
  for (let F = 0; F < I.length; F++) {
    const O = I[F];
    O.id == r &&
      ((O.pos.x = v = $.rZone.xStart),
      (O.pos.y = k = $.rZone.yStart),
      (O.size.w = x = $.rZone.xEnd - $.rZone.xStart),
      (O.size.h = S = $.rZone.yEnd - $.rZone.yStart),
      (O.snapped = !0));
  }
  WindowStore.set(I), commitWindow(p, v, k, x, S);
}
function commitWindow($, r, p, v, k) {
  setTimeout(() => {
    ($.style.left = r + "px"),
      ($.style.top = p + "px"),
      ($.style.width = v + "px"),
      ($.style.height = k + "px"),
      openWindow(get_store_value(draggingId));
  }, 5);
}
function dragWindow($, r, p) {
  if (!$ || !r || !p)
    return Log({
      msg: `Can't drag ${$.id}: one or more required elements are missing!`,
      source: "drag.ts: dragWindow",
      level: LogLevel.error,
    });
  ["mousedown", "touchstart"].forEach((v) =>
    r.addEventListener(v, (k) => {
      let x, S;
      if (
        !$.info.custom &&
        (focusedWindowId.set($.id), k.composedPath().includes(p))
      ) {
        let I = function (N, j) {
            (F = L - N), (O = U - j), (L = N), (U = j);
            let R = r.offsetTop - O;
            const q = r.offsetLeft - F;
            R < 0 && (R = 0),
              (r.style.top = R + "px"),
              (r.style.left = q + "px"),
              ($.pos.x = q),
              ($.pos.y = R),
              checkZones(L, U, $.id),
              ([N, j] = [L, U]);
          },
          F,
          O,
          L,
          U;
        k.preventDefault(),
          (document.onmousemove = (N) => {
            ($.snapped = !1),
              WindowStore.set(get_store_value(WindowStore)),
              I(N.clientX, N.clientY);
          }),
          (document.ontouchmove = (N) => {
            console.log(N),
              ($.snapped = !1),
              WindowStore.set(get_store_value(WindowStore)),
              !(!N.touches.length || v == "mousedown") &&
                I(N.touches[0].clientX, N.touches[0].clientY);
          }),
          (document.onmouseup = document.ontouchend =
            () => {
              checkZones(x, S, $.id),
                snapWindow($.id),
                leftZoneTriggered.set(!1),
                rightZoneTriggered.set(!1),
                (document.onmouseup = null),
                (document.onmousemove = null),
                (document.ontouchend = null),
                (document.ontouchmove = null);
            });
      }
    })
  );
}
function maxSizeExceedsLiteral($) {}
function minSizeExceedsLiteral($) {}
const error = "";
function get_each_context$5($, r, p) {
  const v = $.slice();
  return (v[6] = r[p]), v;
}
function create_if_block$g($) {
  let r, p, v, k;
  return {
    c() {
      (r = element("div")),
        (p = element("img")),
        src_url_equal(p.src, (v = $[0].image)) || attr(p, "src", v),
        attr(p, "alt", (k = $[0].title)),
        attr(r, "class", "errimg");
    },
    m(x, S) {
      insert(x, r, S), append(r, p);
    },
    p(x, S) {
      S & 1 && !src_url_equal(p.src, (v = x[0].image)) && attr(p, "src", v),
        S & 1 && k !== (k = x[0].title) && attr(p, "alt", k);
    },
    d(x) {
      x && detach(r);
    },
  };
}
function create_each_block$5($) {
  let r,
    p = $[6].caption + "",
    v,
    k,
    x;
  function S() {
    return $[4]($[6]);
  }
  return {
    c() {
      (r = element("button")), (v = text(p));
    },
    m(I, F) {
      insert(I, r, F),
        append(r, v),
        k || ((x = listen(r, "click", S)), (k = !0));
    },
    p(I, F) {
      ($ = I), F & 1 && p !== (p = $[6].caption + "") && set_data(v, p);
    },
    d(I) {
      I && detach(r), (k = !1), x();
    },
  };
}
function create_fragment$r($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F = $[0].title + "",
    O,
    L,
    U,
    N = $[0].message + "",
    j,
    R,
    q,
    Q,
    K = $[0].image && create_if_block$g($),
    V = $[0].buttons,
    H = [];
  for (let G = 0; G < V.length; G += 1)
    H[G] = create_each_block$5(get_each_context$5($, V, G));
  return {
    c() {
      (r = element("div")),
        (p = element("window")),
        (v = element("div")),
        (k = element("div")),
        K && K.c(),
        (x = space()),
        (S = element("div")),
        (I = element("h3")),
        (O = text(F)),
        (L = space()),
        (U = element("p")),
        (j = text(N)),
        (R = space()),
        (q = element("div")),
        (Q = element("div"));
      for (let G = 0; G < H.length; G += 1) H[G].c();
      attr(I, "class", "error-title"),
        attr(U, "class", "error-message"),
        attr(S, "class", "error-content"),
        attr(k, "class", "error-overlay"),
        attr(Q, "class", "inner"),
        attr(q, "class", "error-overlay-buttons"),
        attr(v, "class", "body overlay"),
        attr(p, "class", "window headless overlay overlayable-error"),
        toggle_class(p, "visible", $[1]),
        attr(r, "class", "overlay-wrapper"),
        toggle_class(r, "show", $[1]);
    },
    m(G, Y) {
      insert(G, r, Y),
        append(r, p),
        append(p, v),
        append(v, k),
        K && K.m(k, null),
        append(k, x),
        append(k, S),
        append(S, I),
        append(I, O),
        append(S, L),
        append(S, U),
        append(U, j),
        append(v, R),
        append(v, q),
        append(q, Q);
      for (let J = 0; J < H.length; J += 1) H[J] && H[J].m(Q, null);
    },
    p(G, [Y]) {
      if (
        (G[0].image
          ? K
            ? K.p(G, Y)
            : ((K = create_if_block$g(G)), K.c(), K.m(k, x))
          : K && (K.d(1), (K = null)),
        Y & 1 && F !== (F = G[0].title + "") && set_data(O, F),
        Y & 1 && N !== (N = G[0].message + "") && set_data(j, N),
        Y & 5)
      ) {
        V = G[0].buttons;
        let J;
        for (J = 0; J < V.length; J += 1) {
          const Z = get_each_context$5(G, V, J);
          H[J]
            ? H[J].p(Z, Y)
            : ((H[J] = create_each_block$5(Z)), H[J].c(), H[J].m(Q, null));
        }
        for (; J < H.length; J += 1) H[J].d(1);
        H.length = V.length;
      }
      Y & 2 && toggle_class(p, "visible", G[1]),
        Y & 2 && toggle_class(r, "show", G[1]);
    },
    i: noop$1,
    o: noop$1,
    d(G) {
      G && detach(r), K && K.d(), destroy_each(H, G);
    },
  };
}
function instance$p($, r, p) {
  let { app: v } = r,
    { error: k } = r,
    x = !1;
  function S() {
    p(1, (x = !1)),
      setTimeout(() => {
        destroyOverlayableError(k.id, v.id);
      }, 100);
  }
  onMount(() => {
    setTimeout(() => {
      p(1, (x = !0));
    }, 100);
  });
  function I(O) {
    O(), S();
  }
  const F = (O) => I(O.action);
  return (
    ($.$$set = (O) => {
      "app" in O && p(3, (v = O.app)), "error" in O && p(0, (k = O.error));
    }),
    [k, x, I, v, F]
  );
}
class OverlayableErrorWindow extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$p, create_fragment$r, safe_not_equal, {
        app: 3,
        error: 0,
      });
  }
}
function create_if_block$f($) {
  let r, p, v, k, x;
  var S = $[0].content;
  function I(F) {
    return { props: { overlay: F[0], app: F[1], id: F[2] } };
  }
  return (
    S && (k = construct_svelte_component(S, I($))),
    {
      c() {
        (r = element("div")),
          (p = element("window")),
          (v = element("div")),
          k && create_component(k.$$.fragment),
          attr(v, "class", "body overlay"),
          attr(p, "class", "window headless overlay"),
          attr(p, "style", $[4]),
          attr(p, "id", $[2]),
          toggle_class(p, "visible", $[3]),
          attr(r, "class", "overlay-wrapper"),
          toggle_class(r, "show", $[3]);
      },
      m(F, O) {
        insert(F, r, O),
          append(r, p),
          append(p, v),
          k && mount_component(k, v, null),
          (x = !0);
      },
      p(F, O) {
        const L = {};
        if (
          (O & 1 && (L.overlay = F[0]),
          O & 2 && (L.app = F[1]),
          O & 4 && (L.id = F[2]),
          O & 1 && S !== (S = F[0].content))
        ) {
          if (k) {
            group_outros();
            const U = k;
            transition_out(U.$$.fragment, 1, 0, () => {
              destroy_component(U, 1);
            }),
              check_outros();
          }
          S
            ? ((k = construct_svelte_component(S, I(F))),
              create_component(k.$$.fragment),
              transition_in(k.$$.fragment, 1),
              mount_component(k, v, null))
            : (k = null);
        } else S && k.$set(L);
        (!x || O & 16) && attr(p, "style", F[4]),
          (!x || O & 4) && attr(p, "id", F[2]),
          (!x || O & 8) && toggle_class(p, "visible", F[3]),
          (!x || O & 8) && toggle_class(r, "show", F[3]);
      },
      i(F) {
        x || (k && transition_in(k.$$.fragment, F), (x = !0));
      },
      o(F) {
        k && transition_out(k.$$.fragment, F), (x = !1);
      },
      d(F) {
        F && detach(r), k && destroy_component(k);
      },
    }
  );
}
function create_fragment$q($) {
  let r,
    p,
    v = $[0] && $[1] && create_if_block$f($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[0] && k[1]
        ? v
          ? (v.p(k, x), x & 3 && transition_in(v, 1))
          : ((v = create_if_block$f(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$o($, r, p) {
  let { overlay: v } = r,
    { app: k } = r,
    { id: x } = r,
    S = !1,
    I = "";
  return (
    onMount(() => {
      p(4, (I = generateOverlayCSS(v)));
    }),
    WindowStore.subscribe(() => {
      p(4, (I = generateOverlayCSS(v))),
        p(3, (S = k.overlays[x] ? k.overlays[x].show : !1));
    }),
    ($.$$set = (F) => {
      "overlay" in F && p(0, (v = F.overlay)),
        "app" in F && p(1, (k = F.app)),
        "id" in F && p(2, (x = F.id));
    }),
    [v, k, x, S, I]
  );
}
class OverlayableWindow extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$o, create_fragment$q, safe_not_equal, {
        overlay: 0,
        app: 1,
        id: 2,
      });
  }
}
function create_fragment$p($) {
  let r, p, v, k;
  var x = $[0].content;
  function S(O) {
    return { props: { app: O[0], appdata: O[1].appdata[O[0].id] || {} } };
  }
  x && (p = construct_svelte_component(x, S($)));
  const I = $[3].default,
    F = create_slot(I, $, $[2], null);
  return {
    c() {
      (r = element("div")),
        p && create_component(p.$$.fragment),
        (v = space()),
        F && F.c(),
        attr(r, "class", "body");
    },
    m(O, L) {
      insert(O, r, L),
        p && mount_component(p, r, null),
        append(r, v),
        F && F.m(r, null),
        (k = !0);
    },
    p(O, [L]) {
      const U = {};
      if (
        (L & 1 && (U.app = O[0]),
        L & 3 && (U.appdata = O[1].appdata[O[0].id] || {}),
        L & 1 && x !== (x = O[0].content))
      ) {
        if (p) {
          group_outros();
          const N = p;
          transition_out(N.$$.fragment, 1, 0, () => {
            destroy_component(N, 1);
          }),
            check_outros();
        }
        x
          ? ((p = construct_svelte_component(x, S(O))),
            create_component(p.$$.fragment),
            transition_in(p.$$.fragment, 1),
            mount_component(p, r, v))
          : (p = null);
      } else x && p.$set(U);
      F &&
        F.p &&
        (!k || L & 4) &&
        update_slot_base(
          F,
          I,
          O,
          O[2],
          k
            ? get_slot_changes(I, O[2], L, null)
            : get_all_dirty_from_scope(O[2]),
          null
        );
    },
    i(O) {
      k ||
        (p && transition_in(p.$$.fragment, O), transition_in(F, O), (k = !0));
    },
    o(O) {
      p && transition_out(p.$$.fragment, O), transition_out(F, O), (k = !1);
    },
    d(O) {
      O && detach(r), p && destroy_component(p), F && F.d(O);
    },
  };
}
function instance$n($, r, p) {
  let v;
  component_subscribe($, UserData, (I) => p(1, (v = I)));
  let { $$slots: k = {}, $$scope: x } = r,
    { app: S } = r;
  return (
    ($.$$set = (I) => {
      "app" in I && p(0, (S = I.app)), "$$scope" in I && p(2, (x = I.$$scope));
    }),
    [S, v, x, k]
  );
}
class Content extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$n, create_fragment$p, safe_not_equal, { app: 0 });
  }
}
function create_else_block$4($) {
  let r, p;
  return (
    (r = new Default({
      props: { app: $[1], cls: $[6], min: $[4], max: $[5], isBoot: $[2] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 2 && (x.app = v[1]), k & 4 && (x.isBoot = v[2]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$e($) {
  let r, p, v;
  var k = titlebarButtons[$[3].sh.window.buttons].content;
  function x(S) {
    return {
      props: { cls: S[6], min: S[4], max: S[5], app: S[1], isBoot: S[2] },
    };
  }
  return (
    k && (r = construct_svelte_component(k, x($))),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(S, I) {
        r && mount_component(r, S, I), insert(S, p, I), (v = !0);
      },
      p(S, I) {
        const F = {};
        if (
          (I & 2 && (F.app = S[1]),
          I & 4 && (F.isBoot = S[2]),
          I & 8 && k !== (k = titlebarButtons[S[3].sh.window.buttons].content))
        ) {
          if (r) {
            group_outros();
            const O = r;
            transition_out(O.$$.fragment, 1, 0, () => {
              destroy_component(O, 1);
            }),
              check_outros();
          }
          k
            ? ((r = construct_svelte_component(k, x(S))),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        } else k && r.$set(F);
      },
      i(S) {
        v || (r && transition_in(r.$$.fragment, S), (v = !0));
      },
      o(S) {
        r && transition_out(r.$$.fragment, S), (v = !1);
      },
      d(S) {
        S && detach(p), r && destroy_component(r, S);
      },
    }
  );
}
function create_fragment$o($) {
  let r,
    p,
    v = $[1].info.name + "",
    k,
    x = ($[1].info.titleSuffix || "") + "",
    S,
    I,
    F,
    O,
    L,
    U,
    N,
    j,
    R = $[1].info.name + "",
    q,
    Q = ($[1].info.titleSuffix || "") + "",
    K,
    V,
    H,
    G,
    Y,
    J,
    Z,
    X;
  const ee = [create_if_block$e, create_else_block$4],
    te = [];
  function ie(ue, oe) {
    return ue[3].sh.window.buttons ? 0 : 1;
  }
  return (
    (G = ie($)),
    (Y = te[G] = ee[G]($)),
    {
      c() {
        (r = element("div")),
          (p = element("div")),
          (k = text(v)),
          (S = text(x)),
          (I = space()),
          (F = element("p")),
          (O = element("img")),
          (N = space()),
          (j = element("span")),
          (q = text(R)),
          (K = text(Q)),
          (V = space()),
          (H = element("div")),
          Y.c(),
          attr(p, "class", "centeredtitle"),
          attr(O, "class", "icon"),
          src_url_equal(O.src, (L = getAppIcon($[1]))) || attr(O, "src", L),
          attr(O, "alt", (U = $[1].info.name)),
          attr(F, "class", "title"),
          attr(H, "class", "controls"),
          attr(r, "class", "titlebar"),
          toggle_class(r, "centered", $[3].sh.window.centertb);
      },
      m(ue, oe) {
        insert(ue, r, oe),
          append(r, p),
          append(p, k),
          append(p, S),
          append(r, I),
          append(r, F),
          append(F, O),
          append(F, N),
          append(F, j),
          append(j, q),
          append(j, K),
          append(r, V),
          append(r, H),
          te[G].m(H, null),
          $[8](r),
          (J = !0),
          Z || ((X = listen(r, "dblclick", $[5])), (Z = !0));
      },
      p(ue, [oe]) {
        (!J || oe & 2) && v !== (v = ue[1].info.name + "") && set_data(k, v),
          (!J || oe & 2) &&
            x !== (x = (ue[1].info.titleSuffix || "") + "") &&
            set_data(S, x),
          (!J || (oe & 2 && !src_url_equal(O.src, (L = getAppIcon(ue[1]))))) &&
            attr(O, "src", L),
          (!J || (oe & 2 && U !== (U = ue[1].info.name))) && attr(O, "alt", U),
          (!J || oe & 2) && R !== (R = ue[1].info.name + "") && set_data(q, R),
          (!J || oe & 2) &&
            Q !== (Q = (ue[1].info.titleSuffix || "") + "") &&
            set_data(K, Q);
        let se = G;
        (G = ie(ue)),
          G === se
            ? te[G].p(ue, oe)
            : (group_outros(),
              transition_out(te[se], 1, 1, () => {
                te[se] = null;
              }),
              check_outros(),
              (Y = te[G]),
              Y ? Y.p(ue, oe) : ((Y = te[G] = ee[G](ue)), Y.c()),
              transition_in(Y, 1),
              Y.m(H, null)),
          (!J || oe & 8) &&
            toggle_class(r, "centered", ue[3].sh.window.centertb);
      },
      i(ue) {
        J || (transition_in(Y), (J = !0));
      },
      o(ue) {
        transition_out(Y), (J = !1);
      },
      d(ue) {
        ue && detach(r), te[G].d(), $[8](null), (Z = !1), X();
      },
    }
  );
}
function instance$m($, r, p) {
  let v;
  component_subscribe($, UserData, (N) => p(3, (v = N)));
  let { exttransition: k = !1 } = r,
    { titlebar: x } = r,
    { app: S } = r,
    { isBoot: I = !1 } = r;
  function F() {
    p(1, (S.state.windowState.min = !S.state.windowState.min), S),
      updateStores();
  }
  function O() {
    S.controls.max &&
      (p(1, (S.state.windowState.max = !S.state.windowState.max), S),
      S.state.windowState.max
        ? p(7, (k = !0))
        : setTimeout(() => {
            p(7, (k = !1));
          }, 200),
      updateStores());
  }
  function L() {
    const N = S.id,
      j = N.startsWith("error_") ? parseInt(N.replace("error_", "")) : -1;
    j > 0 ? closeError(j) : closeWindow(S.id), I && p(1, (S.opened = !1), S);
  }
  function U(N) {
    binding_callbacks[N ? "unshift" : "push"](() => {
      (x = N), p(0, x);
    });
  }
  return (
    ($.$$set = (N) => {
      "exttransition" in N && p(7, (k = N.exttransition)),
        "titlebar" in N && p(0, (x = N.titlebar)),
        "app" in N && p(1, (S = N.app)),
        "isBoot" in N && p(2, (I = N.isBoot));
    }),
    [x, S, I, v, F, O, L, k, U]
  );
}
class Titlebar extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$m, create_fragment$o, safe_not_equal, {
        exttransition: 7,
        titlebar: 0,
        app: 1,
        isBoot: 2,
      });
  }
}
function get_each_context$4($, r, p) {
  const v = $.slice();
  return (v[21] = r[p]), v;
}
function get_each_context_1$1($, r, p) {
  const v = $.slice();
  return (v[24] = r[p]), v;
}
function create_default_slot$1($) {
  let r;
  const p = $[14].default,
    v = create_slot(p, $, $[18], null);
  return {
    c() {
      v && v.c();
    },
    m(k, x) {
      v && v.m(k, x), (r = !0);
    },
    p(k, x) {
      v &&
        v.p &&
        (!r || x & 262144) &&
        update_slot_base(
          v,
          p,
          k,
          k[18],
          r
            ? get_slot_changes(p, k[18], x, null)
            : get_all_dirty_from_scope(k[18]),
          null
        );
    },
    i(k) {
      r || (transition_in(v, k), (r = !0));
    },
    o(k) {
      transition_out(v, k), (r = !1);
    },
    d(k) {
      v && v.d(k);
    },
  };
}
function create_if_block_1$4($) {
  let r,
    p,
    v = Object.entries($[1].overlays),
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block_1$1(get_each_context_1$1($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 2) {
        v = Object.entries(S[1].overlays);
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_1$1(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block_1$1(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_each_block_1$1($) {
  let r, p;
  return (
    (r = new OverlayableWindow({
      props: { app: $[1], overlay: $[24][1], id: $[24][0] },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 2 && (x.app = v[1]),
          k & 2 && (x.overlay = v[24][1]),
          k & 2 && (x.id = v[24][0]),
          r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_if_block$d($) {
  let r,
    p,
    v = $[1].errorOverlays,
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$4(get_each_context$4($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = empty();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 2) {
        v = S[1].errorOverlays;
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$4(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$4(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_each_block$4($) {
  let r, p;
  return (
    (r = new OverlayableErrorWindow({ props: { error: $[21], app: $[1] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 2 && (x.error = v[21]), k & 2 && (x.app = v[1]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$n($) {
  let r, p, v, k, x, S, I, F, O, L, U, N;
  function j(V) {
    $[15](V);
  }
  function R(V) {
    $[16](V);
  }
  let q = { app: $[1], isBoot: $[4] };
  $[0] !== void 0 && (q.exttransition = $[0]),
    $[7] !== void 0 && (q.titlebar = $[7]),
    (p = new Titlebar({ props: q })),
    binding_callbacks.push(() => bind$1(p, "exttransition", j)),
    binding_callbacks.push(() => bind$1(p, "titlebar", R)),
    (S = new Content({
      props: {
        app: $[1],
        $$slots: { default: [create_default_slot$1] },
        $$scope: { ctx: $ },
      },
    }));
  let Q = $[1] && $[1].overlays && create_if_block_1$4($),
    K = $[1] && $[1].errorOverlays && create_if_block$d($);
  return {
    c() {
      (r = element("window")),
        create_component(p.$$.fragment),
        (x = space()),
        create_component(S.$$.fragment),
        (I = space()),
        Q && Q.c(),
        (F = space()),
        K && K.c(),
        attr(r, "style", $[5]),
        attr(r, "id", (O = $[1].id)),
        toggle_class(r, "window", !$[1].info.custom),
        toggle_class(r, "focused", $[1].id == $[8]),
        toggle_class(
          r,
          "headless",
          $[1].state.headless || $[1].state.windowState.fll
        ),
        toggle_class(r, "resizable", $[1].state.resizable),
        toggle_class(r, "min", $[1].state.windowState.min),
        toggle_class(r, "max", $[1].state.windowState.max || $[3]),
        toggle_class(r, "visible", $[1].opened || $[2]),
        toggle_class(r, "exttransition", $[0]),
        toggle_class(
          r,
          "fullscreen",
          $[1].state.windowState.fll || $[1].info.custom
        ),
        toggle_class(r, "glass", $[1].glass),
        toggle_class(r, "lefttb", $[9].sh.window.lefttb),
        toggle_class(r, "custom", $[1].info.custom),
        toggle_class(r, "child", !!$[1].parentId),
        toggle_class(r, "snapped", $[1].snapped),
        toggle_class(r, "snapping", $[1].id == $[10] && ($[11] || $[12]));
    },
    m(V, H) {
      insert(V, r, H),
        mount_component(p, r, null),
        append(r, x),
        mount_component(S, r, null),
        append(r, I),
        Q && Q.m(r, null),
        append(r, F),
        K && K.m(r, null),
        $[17](r),
        (L = !0),
        U || ((N = listen(r, "mousedown", $[13])), (U = !0));
    },
    p(V, [H]) {
      const G = {};
      H & 2 && (G.app = V[1]),
        H & 16 && (G.isBoot = V[4]),
        !v &&
          H & 1 &&
          ((v = !0),
          (G.exttransition = V[0]),
          add_flush_callback(() => (v = !1))),
        !k &&
          H & 128 &&
          ((k = !0), (G.titlebar = V[7]), add_flush_callback(() => (k = !1))),
        p.$set(G);
      const Y = {};
      H & 2 && (Y.app = V[1]),
        H & 262144 && (Y.$$scope = { dirty: H, ctx: V }),
        S.$set(Y),
        V[1] && V[1].overlays
          ? Q
            ? (Q.p(V, H), H & 2 && transition_in(Q, 1))
            : ((Q = create_if_block_1$4(V)),
              Q.c(),
              transition_in(Q, 1),
              Q.m(r, F))
          : Q &&
            (group_outros(),
            transition_out(Q, 1, 1, () => {
              Q = null;
            }),
            check_outros()),
        V[1] && V[1].errorOverlays
          ? K
            ? (K.p(V, H), H & 2 && transition_in(K, 1))
            : ((K = create_if_block$d(V)),
              K.c(),
              transition_in(K, 1),
              K.m(r, null))
          : K &&
            (group_outros(),
            transition_out(K, 1, 1, () => {
              K = null;
            }),
            check_outros()),
        (!L || H & 32) && attr(r, "style", V[5]),
        (!L || (H & 2 && O !== (O = V[1].id))) && attr(r, "id", O),
        (!L || H & 2) && toggle_class(r, "window", !V[1].info.custom),
        (!L || H & 258) && toggle_class(r, "focused", V[1].id == V[8]),
        (!L || H & 2) &&
          toggle_class(
            r,
            "headless",
            V[1].state.headless || V[1].state.windowState.fll
          ),
        (!L || H & 2) && toggle_class(r, "resizable", V[1].state.resizable),
        (!L || H & 2) && toggle_class(r, "min", V[1].state.windowState.min),
        (!L || H & 10) &&
          toggle_class(r, "max", V[1].state.windowState.max || V[3]),
        (!L || H & 6) && toggle_class(r, "visible", V[1].opened || V[2]),
        (!L || H & 1) && toggle_class(r, "exttransition", V[0]),
        (!L || H & 2) &&
          toggle_class(
            r,
            "fullscreen",
            V[1].state.windowState.fll || V[1].info.custom
          ),
        (!L || H & 2) && toggle_class(r, "glass", V[1].glass),
        (!L || H & 512) && toggle_class(r, "lefttb", V[9].sh.window.lefttb),
        (!L || H & 2) && toggle_class(r, "custom", V[1].info.custom),
        (!L || H & 2) && toggle_class(r, "child", !!V[1].parentId),
        (!L || H & 2) && toggle_class(r, "snapped", V[1].snapped),
        (!L || H & 7170) &&
          toggle_class(r, "snapping", V[1].id == V[10] && (V[11] || V[12]));
    },
    i(V) {
      L ||
        (transition_in(p.$$.fragment, V),
        transition_in(S.$$.fragment, V),
        transition_in(Q),
        transition_in(K),
        (L = !0));
    },
    o(V) {
      transition_out(p.$$.fragment, V),
        transition_out(S.$$.fragment, V),
        transition_out(Q),
        transition_out(K),
        (L = !1);
    },
    d(V) {
      V && detach(r),
        destroy_component(p),
        destroy_component(S),
        Q && Q.d(),
        K && K.d(),
        $[17](null),
        (U = !1),
        N();
    },
  };
}
function instance$l($, r, p) {
  let v, k, x, S, I;
  component_subscribe($, focusedWindowId, (X) => p(8, (v = X))),
    component_subscribe($, UserData, (X) => p(9, (k = X))),
    component_subscribe($, draggingId, (X) => p(10, (x = X))),
    component_subscribe($, leftZoneTriggered, (X) => p(11, (S = X))),
    component_subscribe($, rightZoneTriggered, (X) => p(12, (I = X)));
  let { $$slots: F = {}, $$scope: O } = r,
    { app: L = null } = r,
    { visible: U = !1 } = r,
    { max: N = !1 } = r,
    { isBoot: j = !1 } = r,
    R = "",
    q,
    Q = !1,
    K,
    { exttransition: V = !1 } = r;
  onMount(() => {
    focusedWindowId.set(L.id), H();
  });
  function H() {
    if (L.minSize.w > L.size.w || L.minSize.h > L.size.h) return void 0;
    if (L.maxSize.w < L.minSize.w || L.maxSize.h < L.minSize.h) return void 0;
    p(5, (R = generateCSS(L, !Q))),
      Q || (Q = !0),
      L.info.custom || dragWindow(L, q, K);
  }
  WindowStore.subscribe(() => {
    L.opened && !L.info.custom && dragWindow(L, q, K), H();
  });
  function G() {
    set_store_value(focusedWindowId, (v = L.id), v);
  }
  focusedWindowId.subscribe((X) => {
    !L ||
      !L.events ||
      (X == L.id && L.events.focus && L.events.focus(L),
      X != L.id && L.events.blur && L.events.blur(L));
  });
  function Y(X) {
    (V = X), p(0, V);
  }
  function J(X) {
    (K = X), p(7, K);
  }
  function Z(X) {
    binding_callbacks[X ? "unshift" : "push"](() => {
      (q = X), p(6, q);
    });
  }
  return (
    ($.$$set = (X) => {
      "app" in X && p(1, (L = X.app)),
        "visible" in X && p(2, (U = X.visible)),
        "max" in X && p(3, (N = X.max)),
        "isBoot" in X && p(4, (j = X.isBoot)),
        "exttransition" in X && p(0, (V = X.exttransition)),
        "$$scope" in X && p(18, (O = X.$$scope));
    }),
    [V, L, U, N, j, R, q, K, v, k, x, S, I, G, F, Y, J, Z, O]
  );
}
class Window extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$l, create_fragment$n, safe_not_equal, {
        app: 1,
        visible: 2,
        max: 3,
        isBoot: 4,
        exttransition: 0,
      });
  }
}
function create_fragment$m($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L,
    U,
    N,
    j,
    R,
    q = errored;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (p.textContent = `v${ArcOSVersion}`),
        (v = space()),
        (k = element("div")),
        (x = element("img")),
        (I = space()),
        (F = element("div")),
        (F.innerHTML = `<div class="line dark"></div> 
      <div class="subline dark inc"></div> 
      <div class="subline dark dec"></div>`),
        (O = space()),
        (L = element("p")),
        (N = space()),
        (j = empty()),
        attr(p, "class", "arcterm-load visible"),
        attr(x, "alt", "Logo"),
        attr(x, "class", "logo"),
        src_url_equal(x.src, (S = logo$d)) || attr(x, "src", S),
        attr(F, "class", "slider userdefined"),
        attr(L, "class", "status"),
        attr(k, "class", "center-absolute"),
        attr(r, "class", (U = $[1] + " boot fullscreen"));
    },
    m(Q, K) {
      insert(Q, r, K),
        append(r, p),
        append(r, v),
        append(r, k),
        append(k, x),
        append(k, I),
        append(k, F),
        append(k, O),
        append(k, L),
        (L.innerHTML = $[0]),
        insert(Q, N, K),
        insert(Q, j, K),
        (R = !0);
    },
    p(Q, [K]) {
      (!R || K & 1) && (L.innerHTML = Q[0]),
        (!R || (K & 2 && U !== (U = Q[1] + " boot fullscreen"))) &&
          attr(r, "class", U);
    },
    i(Q) {
      R || (transition_in(q), (R = !0));
    },
    o(Q) {
      transition_out(q), (R = !1);
    },
    d(Q) {
      Q && detach(r), Q && detach(N), Q && detach(j);
    },
  };
}
let targetState = "login",
  errored = !1;
function instance$k($, r, p) {
  let v = "",
    k = "",
    x = null,
    S = null,
    I = null,
    F = !1;
  onMount(async () => {
    p(0, (v = "&nbsp;")),
      (x = setTimeout(N, 500)),
      (S = setTimeout(U, 4e3)),
      (I = setTimeout(j, 4750)),
      (await L()) || p(0, (v = "Preparing ArcOS")),
      document.addEventListener("keydown", O);
  });
  function O(R) {
    !R.altKey ||
      R.key.toLowerCase() != "a" ||
      ((F = !0), p(0, (v = "Loading ArcTerm")));
  }
  async function L() {
    const R = localStorage.getItem("arcos-server");
    let q = !1;
    if (R)
      return (
        clearTimeout(x),
        clearTimeout(S),
        clearTimeout(I),
        setTimeout(N, 120),
        (q = await testConnection(R)),
        q
          ? (setTimeout(U, 2e3), setTimeout(j, 2750), q)
          : (U(),
            BugReportData.set([
              !0,
              {
                title: "Boot failed",
                icon: "warning",
                message:
                  "ArcOS can't connect to the remote server. Please ensure<br>the server is online, or try again at a later date.",
                button: { caption: "Retry", action: () => location.reload() },
                source: "Boot",
                details: `Can't connect to server ${R}: none of the modes match`,
              },
            ]))
      );
  }
  function U() {
    Log({ level: LogLevel.info, source: "Boot.svelte", msg: "Fade-out" }),
      p(1, (k = "fadeout"));
  }
  function N() {
    Log({ level: LogLevel.info, source: "Boot.svelte", msg: "Fade-in" }),
      p(1, (k = "fadein"));
  }
  async function j() {
    Log({ level: LogLevel.info, source: "Boot.svelte", msg: "Redirecting" }),
      removeEventListener("keydown", O),
      applyState(F ? "arcterm" : targetState);
  }
  return [v, k];
}
class Boot extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$k, create_fragment$m, safe_not_equal, {});
  }
}
const desktop = "";
async function importAutoLoaders() {
  const $ = get_store_value(UserData);
  if (!$.autoLoads) return !1;
  for (let r = 0; r < $.autoLoads.length; r++) {
    const p = $.autoLoads[r],
      v = { name: p, path: p, mime: "text/plain", data: await readFile(p) };
    (!loadAppFile(v) || !v.data) &&
      errorMessage(
        "Can't import app",
        `ArcOS failed to load app file "${p}". Please verify that this file exists and then try again.`,
        null,
        null,
        { caption: "Close", action() {} },
        {
          caption: "Don't load again",
          action() {
            const x = get_store_value(UserData);
            for (let S = 0; S < x.autoLoads.length; S++)
              x.autoLoads[S] == p && x.autoLoads.splice(S, 1);
            UserData.set(x);
          },
        }
      );
  }
}
const banned = ["tab", "pagedown", "pageup"];
function startKeyListener() {
  Log({
    source: "keyboard/listener.ts: startKeyListener",
    msg: "Starting key listener",
    level: LogLevel.info,
  }),
    document.addEventListener("keydown", processEvent);
}
function processEvent($) {
  if ($.key) {
    if (banned.includes($.key.toLowerCase())) return $.preventDefault(), !1;
    if (
      (unfocusActiveElement(), get_store_value(CurrentState).key == "desktop")
    )
      for (let r = 0; r < appShortcuts.length; r++) {
        const p = appShortcuts[r],
          v = p[1];
        for (let k = 0; k < v.length; k++) {
          const x = v[k].alt ? $.altKey : !0,
            S = v[k].ctrl ? $.ctrlKey : !0,
            I = v[k].shift ? $.shiftKey : !0,
            F = x && S && I,
            O = $.key.toLowerCase().trim(),
            L = v[k].key.trim().toLowerCase(),
            U = get_store_value(focusedWindowId) == p[0] || v[k].global;
          if (!F || (L != O && L) || !U) continue;
          const N = v[k].global ? null : getWindow(p[0]);
          v[k].action(N);
        }
      }
  }
}
function unfocusActiveElement() {
  const $ = document.activeElement;
  !$ ||
    $ instanceof HTMLInputElement ||
    $ instanceof HTMLTextAreaElement ||
    $.blur();
}
let interval;
const pollBlockList = [];
function startMessageCheckInterval() {
  (interval = setInterval(tick, 1e3 * 60)), tick();
}
async function tick() {
  if (!get_store_value(UserName)) return stopMessageCheckInterval();
  messageUpdateTrigger();
  const $ = (await getUnreadMessages()).sort(
    (p, v) => v.timestamp - p.timestamp
  );
  if (!$.length) return;
  const r = $[0];
  !r ||
    isOpened("MessagingApp") ||
    pollBlockList.includes(r.id) ||
    (pollBlockList.push(r.id),
    makeNotification({
      title: `New message from ${r.sender}`,
      message: `${r.partialBody}`,
      image: await getUserPfp(r.sender),
      buttons: [
        {
          caption: "Open Messages",
          action: () => {
            messageUpdateTrigger(), openWindow("MessagingApp");
          },
        },
      ],
    }));
}
function stopMessageCheckInterval() {
  clearInterval(interval);
}
const contextmenu = "";
function create_else_block$3($) {
  let r,
    p,
    v,
    k = $[0].caption + "",
    x,
    S,
    I;
  function F(U, N) {
    if (U[0].icon) return create_if_block_1$3;
    if (U[0].image) return create_if_block_2$1;
  }
  let O = F($),
    L = O && O($);
  return {
    c() {
      (r = element("button")),
        (p = element("div")),
        L && L.c(),
        (v = space()),
        (x = text(k)),
        attr(p, "class", "icon"),
        attr(r, "class", "contextmenu-item"),
        toggle_class(r, "active", $[1]);
    },
    m(U, N) {
      insert(U, r, N),
        append(r, p),
        L && L.m(p, null),
        append(r, v),
        append(r, x),
        S || ((I = listen(r, "click", $[2])), (S = !0));
    },
    p(U, N) {
      O === (O = F(U)) && L
        ? L.p(U, N)
        : (L && L.d(1), (L = O && O(U)), L && (L.c(), L.m(p, null))),
        N & 1 && k !== (k = U[0].caption + "") && set_data(x, k),
        N & 2 && toggle_class(r, "active", U[1]);
    },
    d(U) {
      U && detach(r), L && L.d(), (S = !1), I();
    },
  };
}
function create_if_block$c($) {
  let r;
  return {
    c() {
      r = element("hr");
    },
    m(p, v) {
      insert(p, r, v);
    },
    p: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
function create_if_block_2$1($) {
  let r, p, v;
  return {
    c() {
      (r = element("img")),
        src_url_equal(r.src, (p = $[0].image)) || attr(r, "src", p),
        attr(r, "alt", (v = $[0].caption));
    },
    m(k, x) {
      insert(k, r, x);
    },
    p(k, x) {
      x & 1 && !src_url_equal(r.src, (p = k[0].image)) && attr(r, "src", p),
        x & 1 && v !== (v = k[0].caption) && attr(r, "alt", v);
    },
    d(k) {
      k && detach(r);
    },
  };
}
function create_if_block_1$3($) {
  let r,
    p = $[0].icon + "",
    v;
  return {
    c() {
      (r = element("span")),
        (v = text(p)),
        attr(r, "class", "material-icons-round");
    },
    m(k, x) {
      insert(k, r, x), append(r, v);
    },
    p(k, x) {
      x & 1 && p !== (p = k[0].icon + "") && set_data(v, p);
    },
    d(k) {
      k && detach(r);
    },
  };
}
function create_fragment$l($) {
  let r;
  function p(x, S) {
    return x[0].sep ? create_if_block$c : create_else_block$3;
  }
  let v = p($),
    k = v($);
  return {
    c() {
      k.c(), (r = empty());
    },
    m(x, S) {
      k.m(x, S), insert(x, r, S);
    },
    p(x, [S]) {
      v === (v = p(x)) && k
        ? k.p(x, S)
        : (k.d(1), (k = v(x)), k && (k.c(), k.m(r.parentNode, r)));
    },
    i: noop$1,
    o: noop$1,
    d(x) {
      k.d(x), x && detach(r);
    },
  };
}
function instance$j($, r, p) {
  let { data: v } = r,
    { scope: k } = r,
    { scopeMap: x } = r,
    { window: S } = r,
    { show: I } = r,
    F = !1;
  function O() {
    v.action && v.action(S, x, k), p(3, (I = !1)), L();
  }
  onMount(L);
  async function L() {
    if (!v.isActive) return p(1, (F = !1));
    p(1, (F = await v.isActive()));
  }
  return (
    ($.$$set = (U) => {
      "data" in U && p(0, (v = U.data)),
        "scope" in U && p(4, (k = U.scope)),
        "scopeMap" in U && p(5, (x = U.scopeMap)),
        "window" in U && p(6, (S = U.window)),
        "show" in U && p(3, (I = U.show));
    }),
    [v, F, O, I, k, x, S]
  );
}
class Item extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$j, create_fragment$l, safe_not_equal, {
        data: 0,
        scope: 4,
        scopeMap: 5,
        window: 6,
        show: 3,
      });
  }
}
function get_each_context$3($, r, p) {
  const v = $.slice();
  return (v[13] = r[p]), v;
}
function create_each_block$3($) {
  let r, p, v;
  function k(S) {
    $[10](S);
  }
  let x = { window: $[4], scope: $[5], scopeMap: $[6], data: $[13] };
  return (
    $[2] !== void 0 && (x.show = $[2]),
    (r = new Item({ props: x })),
    binding_callbacks.push(() => bind$1(r, "show", k)),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(S, I) {
        mount_component(r, S, I), (v = !0);
      },
      p(S, I) {
        const F = {};
        I & 16 && (F.window = S[4]),
          I & 32 && (F.scope = S[5]),
          I & 64 && (F.scopeMap = S[6]),
          I & 8 && (F.data = S[13]),
          !p &&
            I & 4 &&
            ((p = !0), (F.show = S[2]), add_flush_callback(() => (p = !1))),
          r.$set(F);
      },
      i(S) {
        v || (transition_in(r.$$.fragment, S), (v = !0));
      },
      o(S) {
        transition_out(r.$$.fragment, S), (v = !1);
      },
      d(S) {
        destroy_component(r, S);
      },
    }
  );
}
function create_fragment$k($) {
  let r,
    p,
    v = $[3],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$3(get_each_context$3($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      r = element("div");
      for (let S = 0; S < k.length; S += 1) k[S].c();
      attr(r, "class", "contextmenu"),
        set_style(r, "top", $[1] + "px"),
        set_style(r, "left", $[0] + "px"),
        set_style(r, "z-index", $[9] + 10),
        toggle_class(r, "show", $[2]),
        toggle_class(r, "compact", $[8].sh.compactContext),
        toggle_class(r, "colored", $[8].sh.taskbar.colored);
    },
    m(S, I) {
      insert(S, r, I);
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(r, null);
      $[11](r), (p = !0);
    },
    p(S, [I]) {
      if (I & 124) {
        v = S[3];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$3(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$3(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
      (!p || I & 2) && set_style(r, "top", S[1] + "px"),
        (!p || I & 1) && set_style(r, "left", S[0] + "px"),
        (!p || I & 512) && set_style(r, "z-index", S[9] + 10),
        (!p || I & 4) && toggle_class(r, "show", S[2]),
        (!p || I & 256) && toggle_class(r, "compact", S[8].sh.compactContext),
        (!p || I & 256) && toggle_class(r, "colored", S[8].sh.taskbar.colored);
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      S && detach(r), destroy_each(k, S), $[11](null);
    },
  };
}
function instance$i($, r, p) {
  let v, k;
  component_subscribe($, UserData, (Q) => p(8, (v = Q))),
    component_subscribe($, maxZIndex, (Q) => p(9, (k = Q)));
  let x = 0,
    S = 0,
    I = !1,
    F = [],
    O,
    L,
    U,
    N;
  onMount(() => {
    document.addEventListener("contextmenu", j),
      document.addEventListener("mousedown", (Q) => {
        Q.button != 0 || Q.composedPath().includes(N) || p(2, (I = !1));
      });
  });
  function j(Q) {
    p(2, (I = !1)), p(3, (F = [])), Q.preventDefault();
    const K = getWindowElementByEvent(Q);
    if (!K) return;
    const V = getWindow(K.id),
      H = getCallerScope(Q);
    if (!H) return;
    const G = H == null ? void 0 : H.dataset.caller;
    setTimeout(() => {
      p(3, (F = getContextEntry(K.id, G) || [])),
        F.length &&
          (p(5, (L = G)),
          p(4, (O = V)),
          p(6, (U = H.dataset)),
          p(2, (I = !0)),
          setTimeout(() => {
            const Y = N.offsetWidth,
              J = N.offsetHeight;
            p(0, ([x, S] = composePosition(Q, Y, J)), x, p(1, S));
          }));
    });
  }
  function R(Q) {
    (I = Q), p(2, I);
  }
  function q(Q) {
    binding_callbacks[Q ? "unshift" : "push"](() => {
      (N = Q), p(7, N);
    });
  }
  return [x, S, I, F, O, L, U, N, v, k, R, q];
}
class ContextMenu extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$i, create_fragment$k, safe_not_equal, {});
  }
}
function create_fragment$j($) {
  let r,
    p = $[0].caption + "",
    v,
    k,
    x;
  return {
    c() {
      (r = element("button")), (v = text(p));
    },
    m(S, I) {
      insert(S, r, I),
        append(r, v),
        k || ((x = listen(r, "click", $[1])), (k = !0));
    },
    p(S, [I]) {
      I & 1 && p !== (p = S[0].caption + "") && set_data(v, p);
    },
    i: noop$1,
    o: noop$1,
    d(S) {
      S && detach(r), (k = !1), x();
    },
  };
}
function instance$h($, r, p) {
  let { button: v } = r,
    { msg: k } = r;
  function x() {
    v.action(), S();
  }
  function S() {
    closeError(k.id);
  }
  return (
    ($.$$set = (I) => {
      "button" in I && p(0, (v = I.button)), "msg" in I && p(2, (k = I.msg));
    }),
    [v, x, k]
  );
}
class Button extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$h, create_fragment$j, safe_not_equal, {
        button: 0,
        msg: 2,
      });
  }
}
function get_each_context$2($, r, p) {
  const v = $.slice();
  return (v[2] = r[p]), v;
}
function get_each_context_1($, r, p) {
  const v = $.slice();
  return (v[5] = r[p]), v;
}
function get_each_context_2($, r, p) {
  const v = $.slice();
  return (v[8] = r[p]), v;
}
function create_if_block$b($) {
  let r,
    p = $[5].message + "",
    v,
    k,
    x,
    S,
    I,
    F,
    O,
    L = $[5].buttons,
    U = [];
  for (let j = 0; j < L.length; j += 1)
    U[j] = create_each_block_2(get_each_context_2($, L, j));
  const N = (j) =>
    transition_out(U[j], 1, 1, () => {
      U[j] = null;
    });
  return {
    c() {
      (r = element("p")),
        (v = space()),
        (k = element("center")),
        (x = element("br")),
        (S = space());
      for (let j = 0; j < U.length; j += 1) U[j].c();
      (I = space()), (F = element("br"));
    },
    m(j, R) {
      insert(j, r, R),
        (r.innerHTML = p),
        insert(j, v, R),
        insert(j, k, R),
        append(k, x),
        append(k, S);
      for (let q = 0; q < U.length; q += 1) U[q] && U[q].m(k, null);
      append(k, I), append(k, F), (O = !0);
    },
    p(j, R) {
      if (
        ((!O || R & 2) && p !== (p = j[5].message + "") && (r.innerHTML = p),
        R & 2)
      ) {
        L = j[5].buttons;
        let q;
        for (q = 0; q < L.length; q += 1) {
          const Q = get_each_context_2(j, L, q);
          U[q]
            ? (U[q].p(Q, R), transition_in(U[q], 1))
            : ((U[q] = create_each_block_2(Q)),
              U[q].c(),
              transition_in(U[q], 1),
              U[q].m(k, I));
        }
        for (group_outros(), q = L.length; q < U.length; q += 1) N(q);
        check_outros();
      }
    },
    i(j) {
      if (!O) {
        for (let R = 0; R < L.length; R += 1) transition_in(U[R]);
        O = !0;
      }
    },
    o(j) {
      U = U.filter(Boolean);
      for (let R = 0; R < U.length; R += 1) transition_out(U[R]);
      O = !1;
    },
    d(j) {
      j && detach(r), j && detach(v), j && detach(k), destroy_each(U, j);
    },
  };
}
function create_each_block_2($) {
  let r, p;
  return (
    (r = new Button({ props: { button: $[8], msg: $[5] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 2 && (x.button = v[8]), k & 2 && (x.msg = v[5]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block_1($) {
  let r,
    p,
    v = `error_${$[5].id}` == $[2].id && create_if_block$b($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, x) {
      `error_${k[5].id}` == k[2].id
        ? v
          ? (v.p(k, x), x & 3 && transition_in(v, 1))
          : ((v = create_if_block$b(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function create_default_slot($) {
  let r,
    p,
    v = $[1],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block_1(get_each_context_1($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      for (let S = 0; S < k.length; S += 1) k[S].c();
      r = space();
    },
    m(S, I) {
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(S, I);
      insert(S, r, I), (p = !0);
    },
    p(S, I) {
      if (I & 3) {
        v = S[1];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context_1(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block_1(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r.parentNode, r));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      destroy_each(k, S), S && detach(r);
    },
  };
}
function create_each_block$2($) {
  let r, p;
  return (
    (r = new Window({
      props: {
        app: $[2],
        $$slots: { default: [create_default_slot] },
        $$scope: { ctx: $ },
      },
    })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.app = v[2]),
          k & 2051 && (x.$$scope = { dirty: k, ctx: v }),
          r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$i($) {
  let r,
    p,
    v = $[0],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$2(get_each_context$2($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      r = element("div");
      for (let S = 0; S < k.length; S += 1) k[S].c();
      attr(r, "class", "winstore");
    },
    m(S, I) {
      insert(S, r, I);
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(r, null);
      p = !0;
    },
    p(S, [I]) {
      if (I & 3) {
        v = S[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$2(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$2(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      S && detach(r), destroy_each(k, S);
    },
  };
}
function instance$g($, r, p) {
  let v, k;
  return (
    component_subscribe($, ErrorWindowStore, (x) => p(0, (v = x))),
    component_subscribe($, ErrorMessages, (x) => p(1, (k = x))),
    [v, k]
  );
}
class ErrorDialogStore extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$g, create_fragment$i, safe_not_equal, {});
  }
}
function get_each_context$1($, r, p) {
  const v = $.slice();
  return (v[2] = r[p]), v;
}
function create_if_block$a($) {
  let r, p;
  return (
    (r = new Window({ props: { app: $[2] } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      p(v, k) {
        const x = {};
        k & 1 && (x.app = v[2]), r.$set(x);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_each_block$1($) {
  let r,
    p,
    v = $[2] && !$[2].disabled && create_if_block$a($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, x) {
      k[2] && !k[2].disabled
        ? v
          ? (v.p(k, x), x & 1 && transition_in(v, 1))
          : ((v = create_if_block$a(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function create_fragment$h($) {
  let r,
    p,
    v = $[0],
    k = [];
  for (let S = 0; S < v.length; S += 1)
    k[S] = create_each_block$1(get_each_context$1($, v, S));
  const x = (S) =>
    transition_out(k[S], 1, 1, () => {
      k[S] = null;
    });
  return {
    c() {
      r = element("div");
      for (let S = 0; S < k.length; S += 1) k[S].c();
      attr(r, "class", "winstore");
    },
    m(S, I) {
      insert(S, r, I);
      for (let F = 0; F < k.length; F += 1) k[F] && k[F].m(r, null);
      p = !0;
    },
    p(S, [I]) {
      if (I & 1) {
        v = S[0];
        let F;
        for (F = 0; F < v.length; F += 1) {
          const O = get_each_context$1(S, v, F);
          k[F]
            ? (k[F].p(O, I), transition_in(k[F], 1))
            : ((k[F] = create_each_block$1(O)),
              k[F].c(),
              transition_in(k[F], 1),
              k[F].m(r, null));
        }
        for (group_outros(), F = v.length; F < k.length; F += 1) x(F);
        check_outros();
      }
    },
    i(S) {
      if (!p) {
        for (let I = 0; I < v.length; I += 1) transition_in(k[I]);
        p = !0;
      }
    },
    o(S) {
      k = k.filter(Boolean);
      for (let I = 0; I < k.length; I += 1) transition_out(k[I]);
      p = !1;
    },
    d(S) {
      S && detach(r), destroy_each(k, S);
    },
  };
}
function instance$f($, r, p) {
  let v;
  component_subscribe($, maxZIndex, (x) => p(1, (v = x)));
  let k = [];
  return (
    WindowStore.subscribe((x) => {
      p(0, (k = [])), x && p(0, (k = x));
      const S = getOpenedStore();
      for (let I = 0; I < S.length; I++)
        if (S[I].state.windowState.fll) return isFullscreenWindow.set(!0);
      isFullscreenWindow.set(!1);
    }),
    focusedWindowId.subscribe((x) => {
      var F;
      if ((F = getWindow(x)) != null && F.info.custom) return;
      if ((set_store_value(maxZIndex, v++, v), !x || x.startsWith("error_"))) {
        if (!x) return;
        const O = document.querySelector(`#${x}`);
        if (!O) return;
        O.style.zIndex = `${v}`;
        return;
      }
      const S = getWindow(x);
      if (!S) return;
      const I = getWindowElement(S);
      I && (I.style.zIndex = `${v}`);
    }),
    [k]
  );
}
class WindowStore_1 extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$f, create_fragment$h, safe_not_equal, {});
  }
}
async function checkLinux() {
  Log({
    source: "tauri/linux.ts",
    level: LogLevel.info,
    msg: "Checking if we're in Tauri and if we're on linux...",
  });
  const $ = navigator.userAgent.toLowerCase();
  if (!((await inTauri()) && $.includes("linux")))
    return Log({
      source: "tauri/linux.ts",
      level: LogLevel.warn,
      msg: "The answer is no, aborting.",
    });
  createOverlayableError(
    {
      title: "Important!",
      message:
        "You are running the ArcOS Desktop App on Linux. There will be inconsistencies and problems with doing this, such as poor performance and incorrect font rendering. It is recommended to run the Desktop App only on Windows until a solution to this problem has been found.",
      buttons: [{ caption: "OK", action() {} }],
    },
    "ArcShell"
  );
}
function create_if_block$9($) {
  let r, p, v, k, x, S, I, F, O, L;
  return (
    (p = new WindowStore_1({})),
    (k = new ErrorDialogStore({})),
    (S = new ContextMenu({})),
    (F = new ArcFind({})),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          create_component(k.$$.fragment),
          (x = space()),
          create_component(S.$$.fragment),
          (I = space()),
          create_component(F.$$.fragment),
          attr(
            r,
            "class",
            (O =
              "desktop theme-" +
              $[2].sh.desktop.theme +
              " tb-" +
              $[2].sh.taskbar.pos +
              " fullscreen " +
              $[1])
          ),
          set_style(
            r,
            "--accent",
            "#" + ($[2].sh.desktop.accent || "70D6FF"),
            1
          ),
          toggle_class(r, "show", $[0]);
      },
      m(U, N) {
        insert(U, r, N),
          mount_component(p, r, null),
          append(r, v),
          mount_component(k, r, null),
          append(r, x),
          mount_component(S, r, null),
          append(r, I),
          mount_component(F, r, null),
          (L = !0);
      },
      p(U, N) {
        (!L ||
          (N & 6 &&
            O !==
              (O =
                "desktop theme-" +
                U[2].sh.desktop.theme +
                " tb-" +
                U[2].sh.taskbar.pos +
                " fullscreen " +
                U[1]))) &&
          attr(r, "class", O),
          (!L || N & 4) &&
            set_style(
              r,
              "--accent",
              "#" + (U[2].sh.desktop.accent || "70D6FF"),
              1
            ),
          (!L || N & 7) && toggle_class(r, "show", U[0]);
      },
      i(U) {
        L ||
          (transition_in(p.$$.fragment, U),
          transition_in(k.$$.fragment, U),
          transition_in(S.$$.fragment, U),
          transition_in(F.$$.fragment, U),
          (L = !0));
      },
      o(U) {
        transition_out(p.$$.fragment, U),
          transition_out(k.$$.fragment, U),
          transition_out(S.$$.fragment, U),
          transition_out(F.$$.fragment, U),
          (L = !1);
      },
      d(U) {
        U && detach(r),
          destroy_component(p),
          destroy_component(k),
          destroy_component(S),
          destroy_component(F);
      },
    }
  );
}
function create_fragment$g($) {
  let r,
    p,
    v = $[2] && $[3] && !$[4] && create_if_block$9($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[2] && k[3] && !k[4]
        ? v
          ? (v.p(k, x), x & 28 && transition_in(v, 1))
          : ((v = create_if_block$9(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$e($, r, p) {
  let v, k, x, S;
  component_subscribe($, UserData, (L) => p(2, (v = L))),
    component_subscribe($, previouslyLoaded, (L) => p(5, (k = L))),
    component_subscribe($, UserName, (L) => p(3, (x = L))),
    component_subscribe($, loggingOff, (L) => p(4, (S = L)));
  let I = !1,
    F = "";
  desktopClassNames.subscribe((L) => p(1, (F = L))),
    showDesktop.subscribe((L) => p(0, (I = L))),
    onMount(async () => {
      if (k) {
        restart$1(!1);
        return;
      }
      set_store_value(previouslyLoaded, (k = !0), k),
        assignDesktopListeners(),
        importDefault(),
        O(),
        startKeyListener(),
        importAutoLoaders(),
        setTimeout(() => p(0, (I = !0)), 250),
        startMessageCheckInterval(),
        checkForUpdates(),
        checkLinux();
    });
  function O() {
    WindowStore.set([]),
      isFullscreenWindow.set(!1),
      updateStores(),
      startOpened.set(!1),
      loggingOff.set(!1),
      ErrorMessages.set([]),
      DevModeOverride.set(v.devmode);
  }
  return [I, F, v, x, S];
}
class Desktop extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$e, create_fragment$g, safe_not_equal, {});
  }
}
const fts = "",
  connect = "./assets/connect-7fe4df73.svg",
  finish = "./assets/finish-b74612a1.svg",
  license = "./assets/license-c775bee3.svg",
  account = "./assets/account-a7a14557.svg",
  wave = "./assets/wave-1b0d0ba8.svg";
function create_fragment$f($) {
  let r, p, v, k, x, S, I, F, O, L, U, N;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("button")),
        (k = element("span")),
        (k.textContent = "arrow_back_ios_new"),
        (S = space()),
        (I = element("div")),
        (F = element("button")),
        (O = element("span")),
        (O.textContent = "arrow_forward_ios"),
        attr(k, "class", "material-icons-round"),
        attr(v, "class", "nopad"),
        (v.disabled = x = $[0].back.disabled),
        attr(O, "class", "material-icons-round"),
        attr(F, "class", "nopad"),
        (F.disabled = L = $[0].forw.disabled),
        attr(I, "class", "alnr"),
        attr(r, "class", "nav");
    },
    m(j, R) {
      insert(j, r, R),
        append(r, p),
        append(p, v),
        append(v, k),
        append(r, S),
        append(r, I),
        append(I, F),
        append(F, O),
        U ||
          ((N = [listen(v, "click", $[1]), listen(F, "click", $[2])]),
          (U = !0));
    },
    p(j, [R]) {
      R & 1 && x !== (x = j[0].back.disabled) && (v.disabled = x),
        R & 1 && L !== (L = j[0].forw.disabled) && (F.disabled = L);
    },
    i: noop$1,
    o: noop$1,
    d(j) {
      j && detach(r), (U = !1), run_all(N);
    },
  };
}
function instance$d($, r, p) {
  let { data: v } = r;
  function k() {
    applyFTSState(v.back.redir);
  }
  function x() {
    applyFTSState(v.forw.redir);
  }
  return (
    ($.$$set = (S) => {
      "data" in S && p(0, (v = S.data));
    }),
    [v, k, x]
  );
}
class Nav extends SvelteComponent {
  constructor(r) {
    super(),
      init(this, r, instance$d, create_fragment$f, safe_not_equal, { data: 0 });
  }
}
const Auth_svelte_svelte_type_style_lang = "";
function create_if_block$8($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K, V, H, G, Y, J;
  const Z = [create_if_block_1$2, create_else_block$2],
    X = [];
  function ee(te, ie) {
    return te[3] ? 0 : 1;
  }
  return (
    (q = ee($)),
    (Q = X[q] = Z[q]($)),
    {
      c() {
        (r = element("div")),
          (p = element("img")),
          (k = space()),
          (x = element("h1")),
          (x.textContent = "Who are you?"),
          (S = space()),
          (I = element("p")),
          (I.textContent = "Let's get you logged in"),
          (F = space()),
          (O = element("input")),
          (L = space()),
          (U = element("div")),
          (N = element("input")),
          (j = space()),
          (R = element("button")),
          Q.c(),
          (V = space()),
          (H = element("button")),
          (H.textContent = "Change server"),
          src_url_equal(p.src, (v = account)) || attr(p, "src", v),
          attr(p, "alt", "Login"),
          attr(I, "class", "subtitle"),
          attr(r, "class", "header centered"),
          attr(O, "type", "text"),
          attr(O, "class", "fullwidth centered svelte-hmg2k4"),
          attr(O, "placeholder", "Username"),
          toggle_class(O, "error", $[2]),
          attr(N, "type", "password"),
          attr(N, "class", "fullwidth centered svelte-hmg2k4"),
          attr(N, "placeholder", "Password"),
          toggle_class(N, "error", $[2]),
          attr(R, "class", "login material-icons-round svelte-hmg2k4"),
          (R.disabled = K = !$[0] || !$[1] || $[3]),
          attr(U, "class", "input-wrap svelte-hmg2k4"),
          attr(H, "class", "flat centered");
      },
      m(te, ie) {
        insert(te, r, ie),
          append(r, p),
          append(r, k),
          append(r, x),
          append(r, S),
          append(r, I),
          insert(te, F, ie),
          insert(te, O, ie),
          set_input_value(O, $[0]),
          insert(te, L, ie),
          insert(te, U, ie),
          append(U, N),
          set_input_value(N, $[1]),
          append(U, j),
          append(U, R),
          X[q].m(R, null),
          insert(te, V, ie),
          insert(te, H, ie),
          (G = !0),
          Y ||
            ((J = [
              listen(O, "input", $[7]),
              listen(N, "input", $[8]),
              listen(R, "click", $[6]),
              listen(H, "click", $[5]),
            ]),
            (Y = !0));
      },
      p(te, ie) {
        ie & 1 && O.value !== te[0] && set_input_value(O, te[0]),
          (!G || ie & 4) && toggle_class(O, "error", te[2]),
          ie & 2 && N.value !== te[1] && set_input_value(N, te[1]),
          (!G || ie & 4) && toggle_class(N, "error", te[2]);
        let ue = q;
        (q = ee(te)),
          q !== ue &&
            (group_outros(),
            transition_out(X[ue], 1, 1, () => {
              X[ue] = null;
            }),
            check_outros(),
            (Q = X[q]),
            Q || ((Q = X[q] = Z[q](te)), Q.c()),
            transition_in(Q, 1),
            Q.m(R, null)),
          (!G || (ie & 11 && K !== (K = !te[0] || !te[1] || te[3]))) &&
            (R.disabled = K);
      },
      i(te) {
        G || (transition_in(Q), (G = !0));
      },
      o(te) {
        transition_out(Q), (G = !1);
      },
      d(te) {
        te && detach(r),
          te && detach(F),
          te && detach(O),
          te && detach(L),
          te && detach(U),
          X[q].d(),
          te && detach(V),
          te && detach(H),
          (Y = !1),
          run_all(J);
      },
    }
  );
}
function create_else_block$2($) {
  let r;
  return {
    c() {
      r = text("arrow_forward_ios");
    },
    m(p, v) {
      insert(p, r, v);
    },
    i: noop$1,
    o: noop$1,
    d(p) {
      p && detach(r);
    },
  };
}
function create_if_block_1$2($) {
  let r, p;
  return (
    (r = new Spinner({ props: { height: 16 } })),
    {
      c() {
        create_component(r.$$.fragment);
      },
      m(v, k) {
        mount_component(r, v, k), (p = !0);
      },
      i(v) {
        p || (transition_in(r.$$.fragment, v), (p = !0));
      },
      o(v) {
        transition_out(r.$$.fragment, v), (p = !1);
      },
      d(v) {
        destroy_component(r, v);
      },
    }
  );
}
function create_fragment$e($) {
  let r,
    p,
    v = !$[4] && create_if_block$8($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[4]
        ? v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros())
        : v
        ? (v.p(k, x), x & 16 && transition_in(v, 1))
        : ((v = create_if_block$8(k)),
          v.c(),
          transition_in(v, 1),
          v.m(r.parentNode, r));
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$c($, r, p) {
  let v = "",
    k = "",
    x = !1,
    S = !1,
    I = !0;
  onMount(async () => {
    (await getUsers()).length || applyFTSState("finish"), p(4, (I = !1));
  });
  function F() {
    ConnectedServer.set(void 0),
      localStorage.removeItem("arcos-server"),
      applyFTSState("connecttocloud");
  }
  async function O() {
    p(3, (S = !0));
    const N = generateCredToken({ username: v, password: k });
    if (!(await loginUsingCreds(N))) {
      p(2, (x = !0)),
        p(3, (S = !1)),
        setTimeout(() => {
          p(2, (x = !1));
        }, 1e3);
      return;
    }
    localStorage.setItem("arcos-remembered-token", N),
      applyFTSState("finish"),
      p(3, (S = !1));
  }
  function L() {
    (v = this.value), p(0, v);
  }
  function U() {
    (k = this.value), p(1, k);
  }
  return [v, k, x, S, I, F, O, L, U];
}
class Auth extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$c, create_fragment$e, safe_not_equal, {});
  }
}
const connecttocloud = "";
function create_else_block$1($) {
  let r;
  return {
    c() {
      r = text("Connecting...");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_if_block_1$1($) {
  let r;
  return {
    c() {
      r = text("Connect to server");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_if_block$7($) {
  let r;
  return {
    c() {
      (r = element("p")),
        (r.innerHTML =
          '<span class="material-icons-round">error</span>Connection to ArcAPI failed!'),
        attr(r, "class", "fullwidth centered connect-error");
    },
    m(p, v) {
      insert(p, r, v);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$d($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q, Q, K, V;
  function H(Z, X) {
    return Z[1] ? create_else_block$1 : create_if_block_1$1;
  }
  let G = H($),
    Y = G($),
    J = $[2] && create_if_block$7();
  return (
    (q = new Nav({
      props: {
        data: {
          back: { disabled: !1, redir: "license" },
          forw: { disabled: !0, redir: "authform" },
          prog: { max: 4, val: 3 },
        },
      },
    })),
    {
      c() {
        (r = element("div")),
          (p = element("img")),
          (k = space()),
          (x = element("h1")),
          (x.textContent = "Time to get connected"),
          (S = space()),
          (I = element("p")),
          (I.textContent = "Enter the hostname of your ArcAPI:"),
          (F = space()),
          (O = element("input")),
          (L = space()),
          (U = element("button")),
          Y.c(),
          (j = space()),
          J && J.c(),
          (R = space()),
          create_component(q.$$.fragment),
          src_url_equal(p.src, (v = connect)) || attr(p, "src", v),
          attr(p, "alt", "Mode"),
          attr(I, "class", "subtitle"),
          attr(r, "class", "header centered"),
          attr(O, "class", "fullwidth centered"),
          attr(O, "placeholder", "Server name"),
          attr(U, "class", "fullwidth option centered"),
          (U.disabled = N = !$[0] || $[1]);
      },
      m(Z, X) {
        insert(Z, r, X),
          append(r, p),
          append(r, k),
          append(r, x),
          append(r, S),
          append(r, I),
          insert(Z, F, X),
          insert(Z, O, X),
          set_input_value(O, $[0]),
          insert(Z, L, X),
          insert(Z, U, X),
          Y.m(U, null),
          insert(Z, j, X),
          J && J.m(Z, X),
          insert(Z, R, X),
          mount_component(q, Z, X),
          (Q = !0),
          K ||
            ((V = [listen(O, "input", $[4]), listen(U, "click", $[3])]),
            (K = !0));
      },
      p(Z, [X]) {
        X & 1 && O.value !== Z[0] && set_input_value(O, Z[0]),
          G !== (G = H(Z)) && (Y.d(1), (Y = G(Z)), Y && (Y.c(), Y.m(U, null))),
          (!Q || (X & 3 && N !== (N = !Z[0] || Z[1]))) && (U.disabled = N),
          Z[2]
            ? J || ((J = create_if_block$7()), J.c(), J.m(R.parentNode, R))
            : J && (J.d(1), (J = null));
      },
      i(Z) {
        Q || (transition_in(q.$$.fragment, Z), (Q = !0));
      },
      o(Z) {
        transition_out(q.$$.fragment, Z), (Q = !1);
      },
      d(Z) {
        Z && detach(r),
          Z && detach(F),
          Z && detach(O),
          Z && detach(L),
          Z && detach(U),
          Y.d(),
          Z && detach(j),
          J && J.d(Z),
          Z && detach(R),
          destroy_component(q, Z),
          (K = !1),
          run_all(V);
      },
    }
  );
}
function instance$b($, r, p) {
  let v = "",
    k = !1,
    x = !1;
  async function S() {
    p(1, (k = !0)),
      p(2, (x = !1)),
      (await testConnection(v))
        ? (localStorage.setItem("arcos-server", v), applyFTSState("authform"))
        : p(2, (x = !0)),
      p(1, (k = !1));
  }
  function I() {
    (v = this.value), p(0, v);
  }
  return [v, k, x, S, I];
}
class ConnectToCloud extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$b, create_fragment$d, safe_not_equal, {});
  }
}
function create_fragment$c($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j, R, q;
  return {
    c() {
      (r = element("div")),
        (p = element("img")),
        (k = space()),
        (x = element("h1")),
        (x.textContent = "Thank you!"),
        (S = space()),
        (I = element("p")),
        (I.textContent = "We greatly appreciate it."),
        (F = space()),
        (O = element("p")),
        (O.textContent = `Thank you for checking out ArcOS! We hope you'll enjoy it as much as we love
  making it. Please restart ArcOS to use your ArcOS instance.`),
        (L = space()),
        (U = element("br")),
        (N = space()),
        (j = element("button")),
        (j.textContent = "Restart"),
        src_url_equal(p.src, (v = finish)) || attr(p, "src", v),
        attr(p, "alt", "Mode"),
        attr(I, "class", "subtitle"),
        attr(r, "class", "header centered"),
        attr(O, "class", "fullwidth centered justified"),
        attr(j, "class", "fullwidth option centered");
    },
    m(Q, K) {
      insert(Q, r, K),
        append(r, p),
        append(r, k),
        append(r, x),
        append(r, S),
        append(r, I),
        insert(Q, F, K),
        insert(Q, O, K),
        insert(Q, L, K),
        insert(Q, U, K),
        insert(Q, N, K),
        insert(Q, j, K),
        R || ((q = listen(j, "click", restart)), (R = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(Q) {
      Q && detach(r),
        Q && detach(F),
        Q && detach(O),
        Q && detach(L),
        Q && detach(U),
        Q && detach(N),
        Q && detach(j),
        (R = !1),
        q();
    },
  };
}
function restart() {
  location.reload();
}
class Finish extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$c, safe_not_equal, {});
  }
}
function create_fragment$b($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j;
  return {
    c() {
      (r = element("div")),
        (p = element("img")),
        (k = space()),
        (x = element("h1")),
        (x.textContent = "License agreement"),
        (S = space()),
        (I = element("p")),
        (I.textContent = "By using ArcOS, you agree to the GPLv3 License."),
        (F = space()),
        (O = element("button")),
        (O.textContent = "Open license"),
        (L = space()),
        (U = element("button")),
        (U.textContent = "I Agree"),
        src_url_equal(p.src, (v = license)) || attr(p, "src", v),
        attr(p, "alt", "Mode"),
        attr(I, "class", "subtitle"),
        attr(r, "class", "header centered"),
        attr(O, "class", "fullwidth option centered"),
        attr(U, "class", "fullwidth option centered");
    },
    m(R, q) {
      insert(R, r, q),
        append(r, p),
        append(r, k),
        append(r, x),
        append(r, S),
        append(r, I),
        insert(R, F, q),
        insert(R, O, q),
        insert(R, L, q),
        insert(R, U, q),
        N ||
          ((j = [listen(O, "click", openIt), listen(U, "click", $[0])]),
          (N = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(R) {
      R && detach(r),
        R && detach(F),
        R && detach(O),
        R && detach(L),
        R && detach(U),
        (N = !1),
        run_all(j);
    },
  };
}
function openIt() {
  window.open("https://www.gnu.org/licenses/gpl-3.0-standalone.html", "_blank");
}
function instance$a($) {
  return [() => applyFTSState("connecttocloud")];
}
class License extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$a, create_fragment$b, safe_not_equal, {});
  }
}
const welcome = "";
function create_fragment$a($) {
  let r, p, v, k, x, S, I, F, O, L, U, N;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("img")),
        (x = space()),
        (S = element("h1")),
        (S.textContent = "Welcome"),
        (I = space()),
        (F = element("p")),
        (F.textContent = "Time to set-up ArcOS."),
        (O = space()),
        (L = element("button")),
        (L.textContent = "Let's begin"),
        src_url_equal(v.src, (k = logo$d)) || attr(v, "src", k),
        attr(v, "alt", "ArcOS"),
        attr(v, "class", "logo"),
        attr(S, "class", "center-header"),
        attr(F, "class", "center"),
        attr(r, "class", "center-flex");
    },
    m(j, R) {
      insert(j, r, R),
        append(r, p),
        append(p, v),
        append(p, x),
        append(p, S),
        append(p, I),
        append(p, F),
        append(p, O),
        append(p, L),
        U || ((N = listen(L, "click", $[0])), (U = !0));
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(j) {
      j && detach(r), (U = !1), N();
    },
  };
}
function instance$9($) {
  return [() => applyFTSState("license")];
}
class Welcome extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$9, create_fragment$a, safe_not_equal, {});
  }
}
const FTSStates = new Map([
    [
      "welcome",
      {
        name: "Welcome",
        content: Welcome,
        attribs: {},
        key: "welcome",
        image: wave,
      },
    ],
    [
      "license",
      {
        name: "License",
        content: License,
        attribs: {},
        key: "license",
        image: license,
      },
    ],
    [
      "connecttocloud",
      {
        name: "Connect to ArcOS",
        content: ConnectToCloud,
        attribs: {},
        key: "connecttocloud",
        image: connect,
      },
    ],
    [
      "authform",
      {
        name: "Authenticate",
        content: Auth,
        attribs: {},
        key: "authform",
        image: account,
      },
    ],
    [
      "finish",
      {
        name: "Finish",
        content: Finish,
        attribs: {},
        key: "finish",
        image: finish,
      },
    ],
  ]),
  CurrentFTSState = writable();
function applyFTSState($) {
  if (FTSStates.has($)) {
    Log({
      level: LogLevel.info,
      source: "applyFTSState",
      msg: `Applying state ${$}`,
    });
    const r = FTSStates.get($);
    CurrentFTSState.set(r);
    return;
  }
  InvalidStateBugrep("FirstTimeSetup", $);
}
function create_else_block($) {
  let r, p, v;
  return (
    (p = new Spinner({ props: { height: 60 } })),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          attr(r, "class", "center-absolute centertext");
      },
      m(k, x) {
        insert(k, r, x), mount_component(p, r, null), (v = !0);
      },
      p: noop$1,
      i(k) {
        v || (transition_in(p.$$.fragment, k), (v = !0));
      },
      o(k) {
        transition_out(p.$$.fragment, k), (v = !1);
      },
      d(k) {
        k && detach(r), destroy_component(p);
      },
    }
  );
}
function create_if_block$6($) {
  let r, p, v, k;
  var x = $[1].content;
  function S(I) {
    return {};
  }
  return (
    x && (p = construct_svelte_component(x, S())),
    {
      c() {
        (r = element("div")),
          p && create_component(p.$$.fragment),
          attr(r, "class", (v = "page " + $[0]));
      },
      m(I, F) {
        insert(I, r, F), p && mount_component(p, r, null), (k = !0);
      },
      p(I, F) {
        if (F & 2 && x !== (x = I[1].content)) {
          if (p) {
            group_outros();
            const O = p;
            transition_out(O.$$.fragment, 1, 0, () => {
              destroy_component(O, 1);
            }),
              check_outros();
          }
          x
            ? ((p = construct_svelte_component(x, S())),
              create_component(p.$$.fragment),
              transition_in(p.$$.fragment, 1),
              mount_component(p, r, null))
            : (p = null);
        }
        (!k || (F & 1 && v !== (v = "page " + I[0]))) && attr(r, "class", v);
      },
      i(I) {
        k || (p && transition_in(p.$$.fragment, I), (k = !0));
      },
      o(I) {
        p && transition_out(p.$$.fragment, I), (k = !1);
      },
      d(I) {
        I && detach(r), p && destroy_component(p);
      },
    }
  );
}
function create_fragment$9($) {
  let r, p, v, k, x;
  const S = [create_if_block$6, create_else_block],
    I = [];
  function F(O, L) {
    return O[1] ? 0 : 1;
  }
  return (
    (p = F($)),
    (v = I[p] = S[p]($)),
    {
      c() {
        (r = element("div")),
          v.c(),
          attr(r, "class", (k = "right " + ($[1] ? $[1].key : "")));
      },
      m(O, L) {
        insert(O, r, L), I[p].m(r, null), (x = !0);
      },
      p(O, [L]) {
        let U = p;
        (p = F(O)),
          p === U
            ? I[p].p(O, L)
            : (group_outros(),
              transition_out(I[U], 1, 1, () => {
                I[U] = null;
              }),
              check_outros(),
              (v = I[p]),
              v ? v.p(O, L) : ((v = I[p] = S[p](O)), v.c()),
              transition_in(v, 1),
              v.m(r, null)),
          (!x || (L & 2 && k !== (k = "right " + (O[1] ? O[1].key : "")))) &&
            attr(r, "class", k);
      },
      i(O) {
        x || (transition_in(v), (x = !0));
      },
      o(O) {
        transition_out(v), (x = !1);
      },
      d(O) {
        O && detach(r), I[p].d();
      },
    }
  );
}
function instance$8($, r, p) {
  let v;
  component_subscribe($, CurrentFTSState, (S) => p(1, (v = S)));
  let k = "",
    x = [];
  return (
    CurrentFTSState.subscribe((S) => {
      S && p(0, (k = S.name.split(" ")[0].toLowerCase()));
    }),
    onMount(() => {
      x = [];
      for (const S of FTSStates) x.push(S[0]);
    }),
    [k, v]
  );
}
class Right extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$8, create_fragment$9, safe_not_equal, {});
  }
}
function get_each_context($, r, p) {
  const v = $.slice();
  return (v[2] = r[p][0]), (v[3] = r[p][1]), v;
}
function create_each_block($) {
  let r,
    p,
    v,
    k,
    x = $[3].name + "",
    S,
    I;
  return {
    c() {
      (r = element("div")),
        (p = element("img")),
        (k = space()),
        (S = text(x)),
        (I = space()),
        src_url_equal(p.src, (v = $[3].image)) || attr(p, "src", v),
        attr(p, "alt", $[3].name),
        attr(r, "class", "state"),
        toggle_class(r, "activated", $[1] && $[1].key == $[2]);
    },
    m(F, O) {
      insert(F, r, O), append(r, p), append(r, k), append(r, S), append(r, I);
    },
    p(F, O) {
      O & 2 && toggle_class(r, "activated", F[1] && F[1].key == F[2]);
    },
    d(F) {
      F && detach(r);
    },
  };
}
function create_fragment$8($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I = [...FTSStates],
    F = [];
  for (let O = 0; O < I.length; O += 1)
    F[O] = create_each_block(get_each_context($, I, O));
  return (
    (x = new Right({})),
    {
      c() {
        (r = element("div")), (p = element("div")), (v = element("div"));
        for (let O = 0; O < F.length; O += 1) F[O].c();
        (k = space()),
          create_component(x.$$.fragment),
          attr(v, "class", "left"),
          attr(p, "class", "center-absolute"),
          attr(r, "class", "fts fullscreen"),
          toggle_class(r, "show", $[0]);
      },
      m(O, L) {
        insert(O, r, L), append(r, p), append(p, v);
        for (let U = 0; U < F.length; U += 1) F[U] && F[U].m(v, null);
        append(p, k), mount_component(x, p, null), (S = !0);
      },
      p(O, [L]) {
        if (L & 2) {
          I = [...FTSStates];
          let U;
          for (U = 0; U < I.length; U += 1) {
            const N = get_each_context(O, I, U);
            F[U]
              ? F[U].p(N, L)
              : ((F[U] = create_each_block(N)), F[U].c(), F[U].m(v, null));
          }
          for (; U < F.length; U += 1) F[U].d(1);
          F.length = I.length;
        }
        (!S || L & 1) && toggle_class(r, "show", O[0]);
      },
      i(O) {
        S || (transition_in(x.$$.fragment, O), (S = !0));
      },
      o(O) {
        transition_out(x.$$.fragment, O), (S = !1);
      },
      d(O) {
        O && detach(r), destroy_each(F, O), destroy_component(x);
      },
    }
  );
}
function instance$7($, r, p) {
  let v;
  component_subscribe($, CurrentFTSState, (x) => p(1, (v = x)));
  let k = !1;
  return (
    onMount(() => {
      setTimeout(() => p(0, (k = !0)), 500),
        setTimeout(() => applyFTSState("welcome"), 1e3);
    }),
    [k, v]
  );
}
class FirstTimeSetup extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$7, create_fragment$8, safe_not_equal, {});
  }
}
const login = "";
function create_if_block$5($) {
  let r;
  return {
    c() {
      (r = element("div")),
        attr(r, "class", "background fullscreen"),
        toggle_class(r, "zoom", $[0].attribs.darken);
    },
    m(p, v) {
      insert(p, r, v);
    },
    p(p, v) {
      v & 1 && toggle_class(r, "zoom", p[0].attribs.darken);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$7($) {
  let r,
    p = $[0] && create_if_block$5($);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, k) {
      p && p.m(v, k), insert(v, r, k);
    },
    p(v, [k]) {
      v[0]
        ? p
          ? p.p(v, k)
          : ((p = create_if_block$5(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$6($, r, p) {
  let v;
  return component_subscribe($, CurrentLoginState, (k) => p(0, (v = k))), [v];
}
class Background extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$6, create_fragment$7, safe_not_equal, {});
  }
}
function create_if_block$4($) {
  let r, p, v;
  var k = $[0].content;
  function x(S) {
    return {};
  }
  return (
    k && (p = construct_svelte_component(k, x())),
    {
      c() {
        (r = element("div")),
          p && create_component(p.$$.fragment),
          attr(r, "class", "center-absolute");
      },
      m(S, I) {
        insert(S, r, I), p && mount_component(p, r, null), (v = !0);
      },
      p(S, I) {
        if (I & 1 && k !== (k = S[0].content)) {
          if (p) {
            group_outros();
            const F = p;
            transition_out(F.$$.fragment, 1, 0, () => {
              destroy_component(F, 1);
            }),
              check_outros();
          }
          k
            ? ((p = construct_svelte_component(k, x())),
              create_component(p.$$.fragment),
              transition_in(p.$$.fragment, 1),
              mount_component(p, r, null))
            : (p = null);
        }
      },
      i(S) {
        v || (p && transition_in(p.$$.fragment, S), (v = !0));
      },
      o(S) {
        p && transition_out(p.$$.fragment, S), (v = !1);
      },
      d(S) {
        S && detach(r), p && destroy_component(p);
      },
    }
  );
}
function create_fragment$6($) {
  let r,
    p,
    v = $[0] && create_if_block$4($);
  return {
    c() {
      v && v.c(), (r = empty());
    },
    m(k, x) {
      v && v.m(k, x), insert(k, r, x), (p = !0);
    },
    p(k, [x]) {
      k[0]
        ? v
          ? (v.p(k, x), x & 1 && transition_in(v, 1))
          : ((v = create_if_block$4(k)),
            v.c(),
            transition_in(v, 1),
            v.m(r.parentNode, r))
        : v &&
          (group_outros(),
          transition_out(v, 1, 1, () => {
            v = null;
          }),
          check_outros());
    },
    i(k) {
      p || (transition_in(v), (p = !0));
    },
    o(k) {
      transition_out(v), (p = !1);
    },
    d(k) {
      v && v.d(k), k && detach(r);
    },
  };
}
function instance$5($, r, p) {
  let v;
  return component_subscribe($, CurrentLoginState, (k) => p(0, (v = k))), [v];
}
class Center extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$5, create_fragment$6, safe_not_equal, {});
  }
}
function create_if_block$3($) {
  let r;
  return {
    c() {
      (r = element("div")),
        attr(r, "class", "fullscreen darken"),
        toggle_class(r, "show", $[0].attribs.darken);
    },
    m(p, v) {
      insert(p, r, v);
    },
    p(p, v) {
      v & 1 && toggle_class(r, "show", p[0].attribs.darken);
    },
    d(p) {
      p && detach(r);
    },
  };
}
function create_fragment$5($) {
  let r,
    p = $[0] && create_if_block$3($);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, k) {
      p && p.m(v, k), insert(v, r, k);
    },
    p(v, [k]) {
      v[0]
        ? p
          ? p.p(v, k)
          : ((p = create_if_block$3(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$4($, r, p) {
  let v;
  return component_subscribe($, CurrentLoginState, (k) => p(0, (v = k))), [v];
}
class Darken extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$4, create_fragment$5, safe_not_equal, {});
  }
}
function create_if_block$2($) {
  let r, p, v, k, x, S, I, F, O, L, U, N, j;
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = text($[2])),
        (k = space()),
        (x = element("div")),
        (S = text($[0])),
        (I = space()),
        (F = element("div")),
        (O = element("button")),
        (O.innerHTML =
          '<span class="material-icons-round">power_settings_new</span>'),
        (L = space()),
        (U = element("button")),
        (U.innerHTML = '<span class="material-icons-round">restart_alt</span>'),
        attr(p, "class", "hostname"),
        attr(x, "class", "clock"),
        attr(O, "class", "nopad"),
        attr(U, "class", "nopad"),
        attr(F, "class", "right"),
        attr(r, "class", "topbar"),
        toggle_class(r, "show", ($[3].attribs.topbar || !1) && $[1]);
    },
    m(R, q) {
      insert(R, r, q),
        append(r, p),
        append(p, v),
        append(r, k),
        append(r, x),
        append(x, S),
        append(r, I),
        append(r, F),
        append(F, O),
        append(F, L),
        append(F, U),
        N ||
          ((j = [listen(O, "click", $[4]), listen(U, "click", $[5])]),
          (N = !0));
    },
    p(R, q) {
      q & 4 && set_data(v, R[2]),
        q & 1 && set_data(S, R[0]),
        q & 10 && toggle_class(r, "show", (R[3].attribs.topbar || !1) && R[1]);
    },
    d(R) {
      R && detach(r), (N = !1), run_all(j);
    },
  };
}
function create_fragment$4($) {
  let r,
    p = $[3] && create_if_block$2($);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, k) {
      p && p.m(v, k), insert(v, r, k);
    },
    p(v, [k]) {
      v[3]
        ? p
          ? p.p(v, k)
          : ((p = create_if_block$2(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$3($, r, p) {
  let v;
  component_subscribe($, CurrentLoginState, (O) => p(3, (v = O)));
  let k = "",
    x = !1,
    S = "";
  onMount(() => {
    setInterval(() => p(0, (k = dayjs().format("HH:mm"))), 500),
      setTimeout(() => p(1, (x = !0)), 750);
    const O = localStorage.getItem("arcos-server");
    p(2, (S = O ? `API: ${O}` : `Local: ${location.hostname}`));
  });
  function I() {
    loginUsername.set("ArcOS"), applyLoginState("shutdown");
  }
  function F() {
    loginUsername.set("ArcOS"), applyLoginState("restart");
  }
  return [k, x, S, v, I, F];
}
class Topbar extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$3, create_fragment$4, safe_not_equal, {});
  }
}
function create_fragment$3($) {
  let r, p, v, k, x, S, I, F, O;
  return (
    (p = new Background({})),
    (k = new Darken({})),
    (S = new Topbar({})),
    (F = new Center({})),
    {
      c() {
        (r = element("div")),
          create_component(p.$$.fragment),
          (v = space()),
          create_component(k.$$.fragment),
          (x = space()),
          create_component(S.$$.fragment),
          (I = space()),
          create_component(F.$$.fragment),
          attr(r, "class", "login fullscreen"),
          toggle_class(r, "show", $[0]);
      },
      m(L, U) {
        insert(L, r, U),
          mount_component(p, r, null),
          append(r, v),
          mount_component(k, r, null),
          append(r, x),
          mount_component(S, r, null),
          append(r, I),
          mount_component(F, r, null),
          (O = !0);
      },
      p(L, [U]) {
        (!O || U & 1) && toggle_class(r, "show", L[0]);
      },
      i(L) {
        O ||
          (transition_in(p.$$.fragment, L),
          transition_in(k.$$.fragment, L),
          transition_in(S.$$.fragment, L),
          transition_in(F.$$.fragment, L),
          (O = !0));
      },
      o(L) {
        transition_out(p.$$.fragment, L),
          transition_out(k.$$.fragment, L),
          transition_out(S.$$.fragment, L),
          transition_out(F.$$.fragment, L),
          (O = !1);
      },
      d(L) {
        L && detach(r),
          destroy_component(p),
          destroy_component(k),
          destroy_component(S),
          destroy_component(F);
      },
    }
  );
}
function instance$2($, r, p) {
  let v = !1;
  return (
    onMount(async () => {
      p(0, (v = !1)), await loginOnMount(), p(0, (v = !0));
    }),
    [v]
  );
}
class Login extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$2, create_fragment$3, safe_not_equal, {});
  }
}
const safetoturnoff = "./assets/safetoturnoff-95895ce6.png",
  TurnedOff_svelte_svelte_type_style_lang = "";
function create_fragment$2($) {
  let r, p, v;
  return {
    c() {
      (r = element("div")),
        (p = element("img")),
        src_url_equal(p.src, (v = safetoturnoff)) || attr(p, "src", v),
        attr(p, "alt", "It's now safe to turn off your computer."),
        attr(p, "class", "svelte-1kzg8gn"),
        attr(r, "class", "svelte-1kzg8gn");
    },
    m(k, x) {
      insert(k, r, x), append(r, p);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(k) {
      k && detach(r);
    },
  };
}
class TurnedOff extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, null, create_fragment$2, safe_not_equal, {});
  }
}
const States = new Map([
    ["boot", { name: "Booting...", content: Boot, attribs: {}, key: "boot" }],
    ["login", { name: "Login", content: Login, attribs: {}, key: "login" }],
    [
      "fts",
      {
        name: "First Time Setup",
        content: FirstTimeSetup,
        attribs: {},
        key: "fts",
      },
    ],
    [
      "desktop",
      { name: "Desktop", content: Desktop, attribs: {}, key: "desktop" },
    ],
    [
      "logoff",
      {
        name: "Logoff",
        content: Login,
        attribs: {},
        onload: () => {
          applyLoginState("logoff"), loginUsername.set(null);
        },
        key: "logoff",
      },
    ],
    [
      "restart",
      {
        name: "Restart",
        content: Login,
        attribs: {},
        onload: () => {
          applyLoginState("restart"), loginUsername.set(null);
        },
        key: "restart",
      },
    ],
    [
      "shutdown",
      {
        name: "Shutdown",
        content: Login,
        attribs: {},
        onload: () => {
          applyLoginState("shutdown"), loginUsername.set(null);
        },
        key: "shutdown",
      },
    ],
    [
      "arcterm",
      { name: "ArcTerm", content: ArcTerm_1, attribs: {}, key: "arcterm" },
    ],
    ["blank", { name: "", content: Blank, attribs: {}, key: "blank" }],
    [
      "turnedoff",
      {
        name: "Turned off",
        content: TurnedOff,
        attribs: {},
        key: "turnedoff",
        async onload() {
          await b.close();
        },
      },
    ],
  ]),
  CurrentState = writable(States[0]);
function applyState($) {
  if (States.has($)) {
    Log({
      level: LogLevel.info,
      source: "state/main.ts: applyState",
      msg: `Applying state ${$}`,
    });
    const r = States.get($);
    r.onload && r.onload(), CurrentState.set(r);
    const p = `ArcOS | ${r.name}`;
    document.title = p;
    try {
      b.setTitle(r.name);
    } catch {}
    $ != "desktop" && logoffToken();
    return;
  }
  InvalidStateBugrep("ArcOS State Switcher", $);
}
const BugReportData = writable();
function InvalidStateBugrep($, r) {
  BugReportData.set([
    !0,
    {
      icon: "broken_image",
      title: "Broken page",
      message:
        "ArcOS tried to open a page or location that doesn't exist.<br>This session can't continue. You can choose to restart.",
      button: { action: () => applyState("boot"), caption: "Restart" },
      source: $,
      details: `applyState for ${$}: Can't apply a non-existent state '${r}'.`,
    },
  ]),
    Log({
      level: LogLevel.warn,
      source: `applyState for ${$}`,
      msg: `Can't apply a non-existent state '${r}'.`,
    });
}
function create_if_block$1($) {
  let r,
    p,
    v,
    k,
    x,
    S,
    I,
    F,
    O = $[2].icon + "",
    L,
    U = $[2].title + "",
    N,
    j,
    R,
    q = $[2].message + "",
    Q,
    K,
    V,
    H,
    G = $[2].button && create_if_block_2($),
    Y = $[2].details && create_if_block_1($);
  return {
    c() {
      (r = element("div")),
        (p = element("div")),
        (v = element("div")),
        (k = element("img")),
        (S = space()),
        (I = element("h3")),
        (F = element("span")),
        (L = text(O)),
        (N = text(U)),
        (j = space()),
        (R = element("p")),
        (Q = space()),
        G && G.c(),
        (K = space()),
        (V = element("div")),
        Y && Y.c(),
        attr(k, "class", "logo"),
        src_url_equal(k.src, (x = logo$d)) || attr(k, "src", x),
        attr(k, "alt", "ArcOS"),
        attr(F, "class", "material-icons-round"),
        attr(p, "class", "content"),
        attr(V, "class", "details"),
        attr(r, "class", (H = "bugrep fullscreen " + $[1])),
        set_style(r, "z-index", $[3] * 10);
    },
    m(J, Z) {
      insert(J, r, Z),
        append(r, p),
        append(p, v),
        append(v, k),
        append(v, S),
        append(v, I),
        append(I, F),
        append(F, L),
        append(I, N),
        append(v, j),
        append(v, R),
        (R.innerHTML = q),
        append(r, Q),
        G && G.m(r, null),
        append(r, K),
        append(r, V),
        Y && Y.m(V, null);
    },
    p(J, Z) {
      Z & 4 && O !== (O = J[2].icon + "") && set_data(L, O),
        Z & 4 && U !== (U = J[2].title + "") && set_data(N, U),
        Z & 4 && q !== (q = J[2].message + "") && (R.innerHTML = q),
        J[2].button
          ? G
            ? G.p(J, Z)
            : ((G = create_if_block_2(J)), G.c(), G.m(r, K))
          : G && (G.d(1), (G = null)),
        J[2].details
          ? Y
            ? Y.p(J, Z)
            : ((Y = create_if_block_1(J)), Y.c(), Y.m(V, null))
          : Y && (Y.d(1), (Y = null)),
        Z & 2 && H !== (H = "bugrep fullscreen " + J[1]) && attr(r, "class", H),
        Z & 8 && set_style(r, "z-index", J[3] * 10);
    },
    d(J) {
      J && detach(r), G && G.d(), Y && Y.d();
    },
  };
}
function create_if_block_2($) {
  let r,
    p = $[2].button.caption + "",
    v,
    k,
    x;
  return {
    c() {
      (r = element("button")), (v = text(p));
    },
    m(S, I) {
      insert(S, r, I),
        append(r, v),
        k || ((x = listen(r, "click", $[4])), (k = !0));
    },
    p(S, I) {
      I & 4 && p !== (p = S[2].button.caption + "") && set_data(v, p);
    },
    d(S) {
      S && detach(r), (k = !1), x();
    },
  };
}
function create_if_block_1($) {
  let r,
    p,
    v,
    k = ($[2].source || "<anonymous>") + "",
    x,
    S,
    I,
    F,
    O,
    L,
    U = ($[2].details || "<anonymous>") + "",
    N;
  return {
    c() {
      (r = element("p")),
        (p = element("span")),
        (p.textContent = "Source :"),
        (v = space()),
        (x = text(k)),
        (S = space()),
        (I = element("p")),
        (F = element("span")),
        (F.textContent = "Details:"),
        (O = space()),
        (L = element("code")),
        (N = text(U)),
        attr(p, "class", "title"),
        attr(F, "class", "title");
    },
    m(j, R) {
      insert(j, r, R),
        append(r, p),
        append(r, v),
        append(r, x),
        insert(j, S, R),
        insert(j, I, R),
        append(I, F),
        append(I, O),
        append(I, L),
        append(L, N);
    },
    p(j, R) {
      R & 4 &&
        k !== (k = (j[2].source || "<anonymous>") + "") &&
        set_data(x, k),
        R & 4 &&
          U !== (U = (j[2].details || "<anonymous>") + "") &&
          set_data(N, U);
    },
    d(j) {
      j && detach(r), j && detach(S), j && detach(I);
    },
  };
}
function create_fragment$1($) {
  let r,
    p = $[0] && create_if_block$1($);
  return {
    c() {
      p && p.c(), (r = empty());
    },
    m(v, k) {
      p && p.m(v, k), insert(v, r, k);
    },
    p(v, [k]) {
      v[0]
        ? p
          ? p.p(v, k)
          : ((p = create_if_block$1(v)), p.c(), p.m(r.parentNode, r))
        : p && (p.d(1), (p = null));
    },
    i: noop$1,
    o: noop$1,
    d(v) {
      p && p.d(v), v && detach(r);
    },
  };
}
function instance$1($, r, p) {
  let v;
  component_subscribe($, maxZIndex, (F) => p(3, (v = F)));
  let k = !1,
    x = "",
    S;
  function I() {
    S.button.action(), BugReportData.set([!1, null]);
  }
  return (
    BugReportData.subscribe((F) => {
      F && (p(0, (k = F[0])), p(2, (S = F[1])), p(1, (x = k ? "show" : "")));
    }),
    [k, x, S, v, I]
  );
}
class BugReport extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance$1, create_fragment$1, safe_not_equal, {});
  }
}
const dmTriggers = [
  WindowStore,
  UserName,
  loginUsername,
  UserData,
  ConnectedServer,
  CurrentFTSState,
  CurrentLoginState,
  NotificationStore,
  currentSettingsPage,
  ErrorWindowStore,
  FileBrowserSelectedFilename,
  FileBrowserCurrentDir,
];
function assignDevMutators() {
  for (let $ = 0; $ < dmTriggers.length; $++)
    dmTriggers[$].subscribe(updateDevModeProps);
}
function create_if_block($) {
  let r, p, v;
  var k = $[1].content;
  function x(S) {
    return {};
  }
  return (
    k && (r = construct_svelte_component(k, x())),
    {
      c() {
        r && create_component(r.$$.fragment), (p = empty());
      },
      m(S, I) {
        r && mount_component(r, S, I), insert(S, p, I), (v = !0);
      },
      p(S, I) {
        if (I & 2 && k !== (k = S[1].content)) {
          if (r) {
            group_outros();
            const F = r;
            transition_out(F.$$.fragment, 1, 0, () => {
              destroy_component(F, 1);
            }),
              check_outros();
          }
          k
            ? ((r = construct_svelte_component(k, x())),
              create_component(r.$$.fragment),
              transition_in(r.$$.fragment, 1),
              mount_component(r, p.parentNode, p))
            : (r = null);
        }
      },
      i(S) {
        v || (r && transition_in(r.$$.fragment, S), (v = !0));
      },
      o(S) {
        r && transition_out(r.$$.fragment, S), (v = !1);
      },
      d(S) {
        S && detach(p), r && destroy_component(r, S);
      },
    }
  );
}
function create_fragment($) {
  let r,
    p,
    v,
    k,
    x = $[1] && create_if_block($);
  return (
    (v = new BugReport({})),
    {
      c() {
        (r = element("div")),
          x && x.c(),
          (p = space()),
          create_component(v.$$.fragment),
          attr(r, "class", "app fullscreen"),
          toggle_class(r, "floating", $[0]);
      },
      m(S, I) {
        insert(S, r, I),
          x && x.m(r, null),
          append(r, p),
          mount_component(v, r, null),
          (k = !0);
      },
      p(S, [I]) {
        S[1]
          ? x
            ? (x.p(S, I), I & 2 && transition_in(x, 1))
            : ((x = create_if_block(S)), x.c(), transition_in(x, 1), x.m(r, p))
          : x &&
            (group_outros(),
            transition_out(x, 1, 1, () => {
              x = null;
            }),
            check_outros()),
          (!k || I & 1) && toggle_class(r, "floating", S[0]);
      },
      i(S) {
        k || (transition_in(x), transition_in(v.$$.fragment, S), (k = !0));
      },
      o(S) {
        transition_out(x), transition_out(v.$$.fragment, S), (k = !1);
      },
      d(S) {
        S && detach(r), x && x.d(), destroy_component(v);
      },
    }
  );
}
function instance($, r, p) {
  let v;
  component_subscribe($, CurrentState, (x) => p(1, (v = x)));
  let k = !1;
  return (
    DevModeOverride.subscribe((x) => {
      x || p(0, (k = !1));
    }),
    applyState("boot"),
    onMount(() => {
      dmMutators.unshift({
        caption: "CurrentState",
        store: CurrentState,
        value: "key",
        fallback: "unknown",
      }),
        dmTriggers.unshift(CurrentState),
        updateDevModeProps(),
        assignDevMutators();
    }),
    (console.warn = (x, ...S) =>
      Log({ source: "Console", msg: x + S.join(" "), level: LogLevel.warn })),
    (console.error = (x, ...S) =>
      Log({ source: "Console", msg: x + S.join(" "), level: LogLevel.error })),
    window.addEventListener("beforeunload", logoffToken),
    [k, v]
  );
}
class App extends SvelteComponent {
  constructor(r) {
    super(), init(this, r, instance, create_fragment, safe_not_equal, {});
  }
}
new App({ target: document.getElementById("app") });
document.addEventListener("contextmenu", ($) => $.preventDefault());
define();

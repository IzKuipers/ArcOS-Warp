var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function noop$1() {
}
const identity = (x2) => x2;
function assign(tar, src) {
  for (const k2 in src)
    tar[k2] = src[k2];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || a2 && typeof a2 === "object" || typeof a2 === "function";
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop$1;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_2) => value = _2)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i2 = 0; i2 < len; i2 += 1) {
        merged[i2] = $$scope.dirty[i2] | lets[i2];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i2 = 0; i2 < length; i2++) {
      dirty[i2] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k2 in props)
    if (k2[0] !== "$")
      result[k2] = props[k2];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k2 in props)
    if (!keys.has(k2) && k2[0] !== "$")
      rest[k2] = props[k2];
  return rest;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$1;
}
const is_client = typeof window !== "undefined";
let now = is_client ? () => window.performance.now() : () => Date.now();
let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop$1;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
const globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);
function append(target, node) {
  target.appendChild(node);
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  style_element.textContent = "/* empty */";
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i2 = 0; i2 < iterations.length; i2 += 1) {
    if (iterations[i2])
      iterations[i2].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key2, value, important) {
  if (value == null) {
    node.style.removeProperty(key2);
  } else {
    node.style.setProperty(key2, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i2 = 0; i2 < select.options.length; i2 += 1) {
    const option = select.options[i2];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
class HtmlTag {
  constructor(is_svg = false) {
    /**
     * @private
     * @default false
     */
    __publicField(this, "is_svg", false);
    /** parent for creating node */
    __publicField(this, "e");
    /** html tag nodes */
    __publicField(this, "n");
    /** target */
    __publicField(this, "t");
    /** anchor */
    __publicField(this, "a");
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target.nodeName
        );
      else
        this.e = element(
          /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? "TEMPLATE" : target.nodeName
        );
      this.t = target.tagName !== "TEMPLATE" ? target : (
        /** @type {HTMLTemplateElement} */
        target.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i2 = 0; i2 < this.n.length; i2 += 1) {
      insert(this.t, this.n[i2], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
}
function construct_svelte_component(component, props) {
  return new component(props);
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash(str) {
  let hash2 = 5381;
  let i2 = str.length;
  while (i2--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i2);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a2, b2, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p2 = 0; p2 <= 1; p2 += step) {
    const t2 = a2 + (b2 - a2) * ease(p2);
    keyframes += p2 * 100 + `%{${fn(t2, 1 - t2)}}
`;
  }
  const rule = keyframes + `100% {${fn(b2, 1 - b2)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
let current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key2, context) {
  get_current_component().$$.context.set(key2, context);
  return context;
}
function getContext(key2) {
  return get_current_component().$$.context.get(key2);
}
const dirty_components = [];
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush$1);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush$1() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update$1(component.$$);
      }
    } catch (e2) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e2;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update$1($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c2) => fns.indexOf(c2) === -1 ? filtered.push(c2) : targets.push(c2));
  targets.forEach((c2) => c2());
  render_callbacks = filtered;
}
let promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block2, local) {
  if (block2 && block2.i) {
    outroing.delete(block2);
    block2.i(local);
  }
}
function transition_out(block2, local, detach2, callback) {
  if (block2 && block2.o) {
    if (outroing.has(block2))
      return;
    outroing.add(block2);
    outros.c.push(() => {
      outroing.delete(block2);
      if (callback) {
        if (detach2)
          block2.d(1);
        callback();
      }
    });
    block2.o(local);
  } else if (callback) {
    callback();
  }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
  const options = { direction: "in" };
  let config = fn(node, params, options);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;
  function cleanup() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function go() {
    const {
      delay = 0,
      duration = 300,
      easing = identity,
      tick: tick2 = noop$1,
      css
    } = config || null_transition;
    if (css)
      animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
    tick2(0, 1);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    if (task)
      task.abort();
    running = true;
    add_render_callback(() => dispatch(node, true, "start"));
    task = loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(1, 0);
          dispatch(node, true, "end");
          cleanup();
          return running = false;
        }
        if (now2 >= start_time) {
          const t2 = easing((now2 - start_time) / duration);
          tick2(t2, 1 - t2);
        }
      }
      return running;
    });
  }
  let started = false;
  return {
    start() {
      if (started)
        return;
      started = true;
      delete_rule(node);
      if (is_function(config)) {
        config = config(options);
        wait().then(go);
      } else {
        go();
      }
    },
    invalidate() {
      started = false;
    },
    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i2 = levels.length;
  while (i2--) {
    const o2 = levels[i2];
    const n2 = updates[i2];
    if (n2) {
      for (const key2 in o2) {
        if (!(key2 in n2))
          to_null_out[key2] = 1;
      }
      for (const key2 in n2) {
        if (!accounted_for[key2]) {
          update2[key2] = n2[key2];
          accounted_for[key2] = 1;
        }
      }
      levels[i2] = n2;
    } else {
      for (const key2 in o2) {
        accounted_for[key2] = 1;
      }
    }
  }
  for (const key2 in to_null_out) {
    if (!(key2 in update2))
      update2[key2] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
function bind$1(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block2) {
  block2 && block2.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop$1,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
      if (!$$.skip_bound && $$.bound[i2])
        $$.bound[i2](value);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    flush$1();
  }
  set_current_component(parent_component);
}
class SvelteComponent {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop$1;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop$1;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
}
const PUBLIC_VERSION = "4";
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
const subscriber_queue = [];
function writable(value, start = noop$1) {
  let stop2;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop2) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop$1) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop2 = start(set, update2) || noop$1;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop2) {
        stop2();
        stop2 = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
const main$1 = "";
const bugrep = "";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u3 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d3 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
      return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
    } }, m3 = function(t3, e3, n3) {
      var r3 = String(t3);
      return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
    }, v2 = { s: m3, z: function(t3) {
      var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
      return (e3 <= 0 ? "+" : "-") + m3(r3, 2, "0") + ":" + m3(i3, 2, "0");
    }, m: function t3(e3, n3) {
      if (e3.date() < n3.date())
        return -t3(n3, e3);
      var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c2), s3 = n3 - i3 < 0, u4 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
      return +(-(r3 + (n3 - i3) / (s3 ? i3 - u4 : u4 - i3)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c2, y: h2, w: o2, d: a2, D: d3, h: u3, m: s2, s: i2, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g2 = "en", D2 = {};
    D2[g2] = M2;
    var p2 = "$isDayjsObject", S2 = function(t3) {
      return t3 instanceof _2 || !(!t3 || !t3[p2]);
    }, w2 = function t3(e3, n3, r3) {
      var i3;
      if (!e3)
        return g2;
      if ("string" == typeof e3) {
        var s3 = e3.toLowerCase();
        D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
        var u4 = e3.split("-");
        if (!i3 && u4.length > 1)
          return t3(u4[0]);
      } else {
        var a3 = e3.name;
        D2[a3] = e3, i3 = a3;
      }
      return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
    }, O2 = function(t3, e3) {
      if (S2(t3))
        return t3.clone();
      var n3 = "object" == typeof e3 ? e3 : {};
      return n3.date = t3, n3.args = arguments, new _2(n3);
    }, b2 = v2;
    b2.l = w2, b2.i = S2, b2.w = function(t3, e3) {
      return O2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _2 = function() {
      function M3(t3) {
        this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
      }
      var m4 = M3.prototype;
      return m4.parse = function(t3) {
        this.$d = function(t4) {
          var e3 = t4.date, n3 = t4.utc;
          if (null === e3)
            return /* @__PURE__ */ new Date(NaN);
          if (b2.u(e3))
            return /* @__PURE__ */ new Date();
          if (e3 instanceof Date)
            return new Date(e3);
          if ("string" == typeof e3 && !/Z$/i.test(e3)) {
            var r3 = e3.match($2);
            if (r3) {
              var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
            }
          }
          return new Date(e3);
        }(t3), this.init();
      }, m4.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m4.$utils = function() {
        return b2;
      }, m4.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m4.isSame = function(t3, e3) {
        var n3 = O2(t3);
        return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
      }, m4.isAfter = function(t3, e3) {
        return O2(t3) < this.startOf(e3);
      }, m4.isBefore = function(t3, e3) {
        return this.endOf(e3) < O2(t3);
      }, m4.$g = function(t3, e3, n3) {
        return b2.u(t3) ? this[e3] : this.set(n3, t3);
      }, m4.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m4.valueOf = function() {
        return this.$d.getTime();
      }, m4.startOf = function(t3, e3) {
        var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = function(t4, e4) {
          var i3 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
          return r3 ? i3 : i3.endOf(a2);
        }, $3 = function(t4, e4) {
          return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
        }, y3 = this.$W, M4 = this.$M, m5 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
        switch (f3) {
          case h2:
            return r3 ? l3(1, 0) : l3(31, 11);
          case c2:
            return r3 ? l3(1, M4) : l3(0, M4 + 1);
          case o2:
            var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
            return l3(r3 ? m5 - D3 : m5 + (6 - D3), M4);
          case a2:
          case d3:
            return $3(v3 + "Hours", 0);
          case u3:
            return $3(v3 + "Minutes", 1);
          case s2:
            return $3(v3 + "Seconds", 2);
          case i2:
            return $3(v3 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m4.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m4.$set = function(t3, e3) {
        var n3, o3 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f3 + "Date", n3[d3] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u3] = f3 + "Hours", n3[s2] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $3 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === c2 || o3 === h2) {
          var y3 = this.clone().set(d3, 1);
          y3.$d[l3]($3), y3.init(), this.$d = y3.set(d3, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          l3 && this.$d[l3]($3);
        return this.init(), this;
      }, m4.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m4.get = function(t3) {
        return this[b2.p(t3)]();
      }, m4.add = function(r3, f3) {
        var d4, l3 = this;
        r3 = Number(r3);
        var $3 = b2.p(f3), y3 = function(t3) {
          var e3 = O2(l3);
          return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
        };
        if ($3 === c2)
          return this.set(c2, this.$M + r3);
        if ($3 === h2)
          return this.set(h2, this.$y + r3);
        if ($3 === a2)
          return y3(1);
        if ($3 === o2)
          return y3(7);
        var M4 = (d4 = {}, d4[s2] = e2, d4[u3] = n2, d4[i2] = t2, d4)[$3] || 1, m5 = this.$d.getTime() + r3 * M4;
        return b2.w(m5, this);
      }, m4.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m4.format = function(t3) {
        var e3 = this, n3 = this.$locale();
        if (!this.isValid())
          return n3.invalidDate || l2;
        var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b2.z(this), s3 = this.$H, u4 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i4, s4) {
          return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s4);
        }, d4 = function(t4) {
          return b2.s(s3 % 12 || 12, t4, "0");
        }, $3 = f3 || function(t4, e4, n4) {
          var r4 = t4 < 12 ? "AM" : "PM";
          return n4 ? r4.toLowerCase() : r4;
        };
        return r3.replace(y2, function(t4, r4) {
          return r4 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e3.$y).slice(-2);
              case "YYYY":
                return b2.s(e3.$y, 4, "0");
              case "M":
                return a3 + 1;
              case "MM":
                return b2.s(a3 + 1, 2, "0");
              case "MMM":
                return h3(n3.monthsShort, a3, c3, 3);
              case "MMMM":
                return h3(c3, a3);
              case "D":
                return e3.$D;
              case "DD":
                return b2.s(e3.$D, 2, "0");
              case "d":
                return String(e3.$W);
              case "dd":
                return h3(n3.weekdaysMin, e3.$W, o3, 2);
              case "ddd":
                return h3(n3.weekdaysShort, e3.$W, o3, 3);
              case "dddd":
                return o3[e3.$W];
              case "H":
                return String(s3);
              case "HH":
                return b2.s(s3, 2, "0");
              case "h":
                return d4(1);
              case "hh":
                return d4(2);
              case "a":
                return $3(s3, u4, true);
              case "A":
                return $3(s3, u4, false);
              case "m":
                return String(u4);
              case "mm":
                return b2.s(u4, 2, "0");
              case "s":
                return String(e3.$s);
              case "ss":
                return b2.s(e3.$s, 2, "0");
              case "SSS":
                return b2.s(e3.$ms, 3, "0");
              case "Z":
                return i3;
            }
            return null;
          }(t4) || i3.replace(":", "");
        });
      }, m4.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m4.diff = function(r3, d4, l3) {
        var $3, y3 = this, M4 = b2.p(d4), m5 = O2(r3), v3 = (m5.utcOffset() - this.utcOffset()) * e2, g3 = this - m5, D3 = function() {
          return b2.m(y3, m5);
        };
        switch (M4) {
          case h2:
            $3 = D3() / 12;
            break;
          case c2:
            $3 = D3();
            break;
          case f2:
            $3 = D3() / 3;
            break;
          case o2:
            $3 = (g3 - v3) / 6048e5;
            break;
          case a2:
            $3 = (g3 - v3) / 864e5;
            break;
          case u3:
            $3 = g3 / n2;
            break;
          case s2:
            $3 = g3 / e2;
            break;
          case i2:
            $3 = g3 / t2;
            break;
          default:
            $3 = g3;
        }
        return l3 ? $3 : b2.a($3);
      }, m4.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m4.$locale = function() {
        return D2[this.$L];
      }, m4.locale = function(t3, e3) {
        if (!t3)
          return this.$L;
        var n3 = this.clone(), r3 = w2(t3, e3, true);
        return r3 && (n3.$L = r3), n3;
      }, m4.clone = function() {
        return b2.w(this.$d, this);
      }, m4.toDate = function() {
        return new Date(this.valueOf());
      }, m4.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m4.toISOString = function() {
        return this.$d.toISOString();
      }, m4.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), k2 = _2.prototype;
    return O2.prototype = k2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u3], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d3]].forEach(function(t3) {
      k2[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), O2.extend = function(t3, e3) {
      return t3.$i || (t3(e3, _2, O2), t3.$i = true), O2;
    }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t3) {
      return O2(1e3 * t3);
    }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["info"] = 0] = "info";
  LogLevel2[LogLevel2["warn"] = 1] = "warn";
  LogLevel2[LogLevel2["error"] = 2] = "error";
  LogLevel2[LogLevel2["critical"] = 3] = "critical";
  return LogLevel2;
})(LogLevel || {});
const LogLevelData = {
  info: {
    capt: "INFO"
  },
  warn: {
    capt: "WARN"
  },
  error: {
    capt: "ERRR"
  },
  critical: {
    capt: "CRIT"
  }
};
var extendStatics = function(e2, t2) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
    e3.__proto__ = t3;
  } || function(e3, t3) {
    for (var n2 in t3)
      Object.prototype.hasOwnProperty.call(t3, n2) && (e3[n2] = t3[n2]);
  }, extendStatics(e2, t2);
};
function __extends(e2, t2) {
  if ("function" != typeof t2 && null !== t2)
    throw new TypeError("Class extends value " + String(t2) + " is not a constructor or null");
  function __() {
    this.constructor = e2;
  }
  extendStatics(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (__.prototype = t2.prototype, new __());
}
var __assign = function() {
  return __assign = Object.assign || function __assign2(e2) {
    for (var t2, n2 = 1, i2 = arguments.length; n2 < i2; n2++)
      for (var o2 in t2 = arguments[n2])
        Object.prototype.hasOwnProperty.call(t2, o2) && (e2[o2] = t2[o2]);
    return e2;
  }, __assign.apply(this, arguments);
};
function __awaiter(e2, t2, n2, i2) {
  return new (n2 || (n2 = Promise))(function(o2, r2) {
    function fulfilled(e3) {
      try {
        step(i2.next(e3));
      } catch (e4) {
        r2(e4);
      }
    }
    function rejected(e3) {
      try {
        step(i2.throw(e3));
      } catch (e4) {
        r2(e4);
      }
    }
    function step(e3) {
      e3.done ? o2(e3.value) : function adopt(e4) {
        return e4 instanceof n2 ? e4 : new n2(function(t3) {
          t3(e4);
        });
      }(e3.value).then(fulfilled, rejected);
    }
    step((i2 = i2.apply(e2, t2 || [])).next());
  });
}
function __generator(e2, t2) {
  var n2, i2, o2, r2, s2 = { label: 0, sent: function() {
    if (1 & o2[0])
      throw o2[1];
    return o2[1];
  }, trys: [], ops: [] };
  return r2 = { next: verb(0), throw: verb(1), return: verb(2) }, "function" == typeof Symbol && (r2[Symbol.iterator] = function() {
    return this;
  }), r2;
  function verb(a2) {
    return function(c2) {
      return function step(a3) {
        if (n2)
          throw new TypeError("Generator is already executing.");
        for (; r2 && (r2 = 0, a3[0] && (s2 = 0)), s2; )
          try {
            if (n2 = 1, i2 && (o2 = 2 & a3[0] ? i2.return : a3[0] ? i2.throw || ((o2 = i2.return) && o2.call(i2), 0) : i2.next) && !(o2 = o2.call(i2, a3[1])).done)
              return o2;
            switch (i2 = 0, o2 && (a3 = [2 & a3[0], o2.value]), a3[0]) {
              case 0:
              case 1:
                o2 = a3;
                break;
              case 4:
                return s2.label++, { value: a3[1], done: false };
              case 5:
                s2.label++, i2 = a3[1], a3 = [0];
                continue;
              case 7:
                a3 = s2.ops.pop(), s2.trys.pop();
                continue;
              default:
                if (!(o2 = s2.trys, (o2 = o2.length > 0 && o2[o2.length - 1]) || 6 !== a3[0] && 2 !== a3[0])) {
                  s2 = 0;
                  continue;
                }
                if (3 === a3[0] && (!o2 || a3[1] > o2[0] && a3[1] < o2[3])) {
                  s2.label = a3[1];
                  break;
                }
                if (6 === a3[0] && s2.label < o2[1]) {
                  s2.label = o2[1], o2 = a3;
                  break;
                }
                if (o2 && s2.label < o2[2]) {
                  s2.label = o2[2], s2.ops.push(a3);
                  break;
                }
                o2[2] && s2.ops.pop(), s2.trys.pop();
                continue;
            }
            a3 = t2.call(e2, s2);
          } catch (e3) {
            a3 = [6, e3], i2 = 0;
          } finally {
            n2 = o2 = 0;
          }
        if (5 & a3[0])
          throw a3[1];
        return { value: a3[0] ? a3[1] : void 0, done: true };
      }([a2, c2]);
    };
  }
}
var e$2, t$2 = function(e2) {
  function ClientResponseError(t2) {
    var n2, i2, o2, r2, s2 = this;
    return (s2 = e2.call(this, "ClientResponseError") || this).url = "", s2.status = 0, s2.response = {}, s2.isAbort = false, s2.originalError = null, Object.setPrototypeOf(s2, ClientResponseError.prototype), null !== t2 && "object" == typeof t2 && (s2.url = "string" == typeof t2.url ? t2.url : "", s2.status = "number" == typeof t2.status ? t2.status : 0, s2.isAbort = !!t2.isAbort, s2.originalError = t2.originalError, null !== t2.response && "object" == typeof t2.response ? s2.response = t2.response : null !== t2.data && "object" == typeof t2.data ? s2.response = t2.data : s2.response = {}), s2.originalError || t2 instanceof ClientResponseError || (s2.originalError = t2), "undefined" != typeof DOMException && t2 instanceof DOMException && (s2.isAbort = true), s2.name = "ClientResponseError " + s2.status, s2.message = null === (n2 = s2.response) || void 0 === n2 ? void 0 : n2.message, s2.message || (s2.isAbort ? s2.message = "The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation." : (null === (r2 = null === (o2 = null === (i2 = s2.originalError) || void 0 === i2 ? void 0 : i2.cause) || void 0 === o2 ? void 0 : o2.message) || void 0 === r2 ? void 0 : r2.includes("ECONNREFUSED ::1")) ? s2.message = "Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21)." : s2.message = "Something went wrong while processing your request."), s2;
  }
  return __extends(ClientResponseError, e2), Object.defineProperty(ClientResponseError.prototype, "data", { get: function() {
    return this.response;
  }, enumerable: false, configurable: true }), ClientResponseError.prototype.toJSON = function() {
    return __assign({}, this);
  }, ClientResponseError;
}(Error), n$2 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function cookieSerialize(e2, t2, i2) {
  var o2 = Object.assign({}, i2 || {}), r2 = o2.encode || defaultEncode;
  if (!n$2.test(e2))
    throw new TypeError("argument name is invalid");
  var s2 = r2(t2);
  if (s2 && !n$2.test(s2))
    throw new TypeError("argument val is invalid");
  var a2 = e2 + "=" + s2;
  if (null != o2.maxAge) {
    var c2 = o2.maxAge - 0;
    if (isNaN(c2) || !isFinite(c2))
      throw new TypeError("option maxAge is invalid");
    a2 += "; Max-Age=" + Math.floor(c2);
  }
  if (o2.domain) {
    if (!n$2.test(o2.domain))
      throw new TypeError("option domain is invalid");
    a2 += "; Domain=" + o2.domain;
  }
  if (o2.path) {
    if (!n$2.test(o2.path))
      throw new TypeError("option path is invalid");
    a2 += "; Path=" + o2.path;
  }
  if (o2.expires) {
    if (!function isDate2(e3) {
      return "[object Date]" === Object.prototype.toString.call(e3) || e3 instanceof Date;
    }(o2.expires) || isNaN(o2.expires.valueOf()))
      throw new TypeError("option expires is invalid");
    a2 += "; Expires=" + o2.expires.toUTCString();
  }
  if (o2.httpOnly && (a2 += "; HttpOnly"), o2.secure && (a2 += "; Secure"), o2.priority)
    switch ("string" == typeof o2.priority ? o2.priority.toLowerCase() : o2.priority) {
      case "low":
        a2 += "; Priority=Low";
        break;
      case "medium":
        a2 += "; Priority=Medium";
        break;
      case "high":
        a2 += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  if (o2.sameSite)
    switch ("string" == typeof o2.sameSite ? o2.sameSite.toLowerCase() : o2.sameSite) {
      case true:
        a2 += "; SameSite=Strict";
        break;
      case "lax":
        a2 += "; SameSite=Lax";
        break;
      case "strict":
        a2 += "; SameSite=Strict";
        break;
      case "none":
        a2 += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  return a2;
}
function defaultDecode(e2) {
  return -1 !== e2.indexOf("%") ? decodeURIComponent(e2) : e2;
}
function defaultEncode(e2) {
  return encodeURIComponent(e2);
}
function getTokenPayload(t2) {
  if (t2)
    try {
      var n2 = decodeURIComponent(e$2(t2.split(".")[1]).split("").map(function(e2) {
        return "%" + ("00" + e2.charCodeAt(0).toString(16)).slice(-2);
      }).join(""));
      return JSON.parse(n2) || {};
    } catch (e2) {
    }
  return {};
}
function isTokenExpired(e2, t2) {
  void 0 === t2 && (t2 = 0);
  var n2 = getTokenPayload(e2);
  return !(Object.keys(n2).length > 0 && (!n2.exp || n2.exp - t2 > Date.now() / 1e3));
}
e$2 = "function" == typeof atob ? atob : function(e2) {
  var t2 = String(e2).replace(/=+$/, "");
  if (t2.length % 4 == 1)
    throw new Error("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var n2, i2, o2 = 0, r2 = 0, s2 = ""; i2 = t2.charAt(r2++); ~i2 && (n2 = o2 % 4 ? 64 * n2 + i2 : i2, o2++ % 4) ? s2 += String.fromCharCode(255 & n2 >> (-2 * o2 & 6)) : 0)
    i2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(i2);
  return s2;
};
var i$2 = function() {
  function BaseModel(e2) {
    void 0 === e2 && (e2 = {}), this.$load(e2 || {});
  }
  return BaseModel.prototype.load = function(e2) {
    return this.$load(e2);
  }, BaseModel.prototype.$load = function(e2) {
    for (var t2 = 0, n2 = Object.entries(e2); t2 < n2.length; t2++) {
      var i2 = n2[t2], o2 = i2[0], r2 = i2[1];
      this[o2] = r2;
    }
    this.id = void 0 !== e2.id ? e2.id : "", this.created = void 0 !== e2.created ? e2.created : "", this.updated = void 0 !== e2.updated ? e2.updated : "";
  }, Object.defineProperty(BaseModel.prototype, "$isNew", { get: function() {
    return !this.id;
  }, enumerable: false, configurable: true }), BaseModel.prototype.clone = function() {
    return this.$clone();
  }, BaseModel.prototype.$clone = function() {
    var e2 = "function" == typeof structuredClone ? structuredClone(this) : JSON.parse(JSON.stringify(this));
    return new this.constructor(e2);
  }, BaseModel.prototype.export = function() {
    return this.$export();
  }, BaseModel.prototype.$export = function() {
    return "function" == typeof structuredClone ? structuredClone(this) : Object.assign({}, this);
  }, BaseModel;
}(), o$3 = function(e2) {
  function Record() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(Record, e2), Record.prototype.$load = function(t2) {
    e2.prototype.$load.call(this, t2), this.collectionId = "string" == typeof t2.collectionId ? t2.collectionId : "", this.collectionName = "string" == typeof t2.collectionName ? t2.collectionName : "", this._loadExpand(t2.expand);
  }, Record.prototype._loadExpand = function(e3) {
    for (var t2 in e3 = e3 || {}, this.expand = {}, e3)
      Array.isArray(e3[t2]) ? this.expand[t2] = e3[t2].map(function(e4) {
        return new Record(e4 || {});
      }) : this.expand[t2] = new Record(e3[t2] || {});
  }, Record;
}(i$2), r$2 = function(e2) {
  function Admin() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(Admin, e2), Admin.prototype.$load = function(t2) {
    e2.prototype.$load.call(this, t2), this.avatar = "number" == typeof t2.avatar ? t2.avatar : 0, this.email = "string" == typeof t2.email ? t2.email : "";
  }, Admin;
}(i$2), s$2 = "pb_auth", a$2 = function() {
  function BaseAuthStore() {
    this.baseToken = "", this.baseModel = null, this._onChangeCallbacks = [];
  }
  return Object.defineProperty(BaseAuthStore.prototype, "token", { get: function() {
    return this.baseToken;
  }, enumerable: false, configurable: true }), Object.defineProperty(BaseAuthStore.prototype, "model", { get: function() {
    return this.baseModel;
  }, enumerable: false, configurable: true }), Object.defineProperty(BaseAuthStore.prototype, "isValid", { get: function() {
    return !isTokenExpired(this.token);
  }, enumerable: false, configurable: true }), BaseAuthStore.prototype.save = function(e2, t2) {
    this.baseToken = e2 || "", this.baseModel = null !== t2 && "object" == typeof t2 ? void 0 !== t2.collectionId ? new o$3(t2) : new r$2(t2) : null, this.triggerChange();
  }, BaseAuthStore.prototype.clear = function() {
    this.baseToken = "", this.baseModel = null, this.triggerChange();
  }, BaseAuthStore.prototype.loadFromCookie = function(e2, t2) {
    void 0 === t2 && (t2 = s$2);
    var n2 = function cookieParse(e3, t3) {
      var n3 = {};
      if ("string" != typeof e3)
        return n3;
      for (var i3 = Object.assign({}, t3 || {}).decode || defaultDecode, o2 = 0; o2 < e3.length; ) {
        var r2 = e3.indexOf("=", o2);
        if (-1 === r2)
          break;
        var s2 = e3.indexOf(";", o2);
        if (-1 === s2)
          s2 = e3.length;
        else if (s2 < r2) {
          o2 = e3.lastIndexOf(";", r2 - 1) + 1;
          continue;
        }
        var a2 = e3.slice(o2, r2).trim();
        if (void 0 === n3[a2]) {
          var c2 = e3.slice(r2 + 1, s2).trim();
          34 === c2.charCodeAt(0) && (c2 = c2.slice(1, -1));
          try {
            n3[a2] = i3(c2);
          } catch (e4) {
            n3[a2] = c2;
          }
        }
        o2 = s2 + 1;
      }
      return n3;
    }(e2 || "")[t2] || "", i2 = {};
    try {
      (null === typeof (i2 = JSON.parse(n2)) || "object" != typeof i2 || Array.isArray(i2)) && (i2 = {});
    } catch (e3) {
    }
    this.save(i2.token || "", i2.model || null);
  }, BaseAuthStore.prototype.exportToCookie = function(e2, t2) {
    var n2, i2, r2;
    void 0 === t2 && (t2 = s$2);
    var a2 = { secure: true, sameSite: true, httpOnly: true, path: "/" }, c2 = getTokenPayload(this.token);
    (null == c2 ? void 0 : c2.exp) ? a2.expires = new Date(1e3 * c2.exp) : a2.expires = /* @__PURE__ */ new Date("1970-01-01"), e2 = Object.assign({}, a2, e2);
    var u3 = { token: this.token, model: (null === (n2 = this.model) || void 0 === n2 ? void 0 : n2.export()) || null }, l2 = cookieSerialize(t2, JSON.stringify(u3), e2), d3 = "undefined" != typeof Blob ? new Blob([l2]).size : l2.length;
    return u3.model && d3 > 4096 && (u3.model = { id: null === (i2 = null == u3 ? void 0 : u3.model) || void 0 === i2 ? void 0 : i2.id, email: null === (r2 = null == u3 ? void 0 : u3.model) || void 0 === r2 ? void 0 : r2.email }, this.model instanceof o$3 && (u3.model.username = this.model.username, u3.model.verified = this.model.verified, u3.model.collectionId = this.model.collectionId), l2 = cookieSerialize(t2, JSON.stringify(u3), e2)), l2;
  }, BaseAuthStore.prototype.onChange = function(e2, t2) {
    var n2 = this;
    return void 0 === t2 && (t2 = false), this._onChangeCallbacks.push(e2), t2 && e2(this.token, this.model), function() {
      for (var t3 = n2._onChangeCallbacks.length - 1; t3 >= 0; t3--)
        if (n2._onChangeCallbacks[t3] == e2)
          return delete n2._onChangeCallbacks[t3], void n2._onChangeCallbacks.splice(t3, 1);
    };
  }, BaseAuthStore.prototype.triggerChange = function() {
    for (var e2 = 0, t2 = this._onChangeCallbacks; e2 < t2.length; e2++) {
      var n2 = t2[e2];
      n2 && n2(this.token, this.model);
    }
  }, BaseAuthStore;
}(), c$1 = function(e2) {
  function LocalAuthStore(t2) {
    void 0 === t2 && (t2 = "pocketbase_auth");
    var n2 = e2.call(this) || this;
    return n2.storageFallback = {}, n2.storageKey = t2, n2;
  }
  return __extends(LocalAuthStore, e2), Object.defineProperty(LocalAuthStore.prototype, "token", { get: function() {
    return (this._storageGet(this.storageKey) || {}).token || "";
  }, enumerable: false, configurable: true }), Object.defineProperty(LocalAuthStore.prototype, "model", { get: function() {
    var e3, t2 = this._storageGet(this.storageKey) || {};
    return null === t2 || "object" != typeof t2 || null === t2.model || "object" != typeof t2.model ? null : void 0 === (null === (e3 = t2.model) || void 0 === e3 ? void 0 : e3.collectionId) ? new r$2(t2.model) : new o$3(t2.model);
  }, enumerable: false, configurable: true }), LocalAuthStore.prototype.save = function(t2, n2) {
    this._storageSet(this.storageKey, { token: t2, model: n2 }), e2.prototype.save.call(this, t2, n2);
  }, LocalAuthStore.prototype.clear = function() {
    this._storageRemove(this.storageKey), e2.prototype.clear.call(this);
  }, LocalAuthStore.prototype._storageGet = function(e3) {
    if ("undefined" != typeof window && (null === window || void 0 === window ? void 0 : window.localStorage)) {
      var t2 = window.localStorage.getItem(e3) || "";
      try {
        return JSON.parse(t2);
      } catch (e4) {
        return t2;
      }
    }
    return this.storageFallback[e3];
  }, LocalAuthStore.prototype._storageSet = function(e3, t2) {
    if ("undefined" != typeof window && (null === window || void 0 === window ? void 0 : window.localStorage)) {
      var n2 = t2;
      "string" != typeof t2 && (n2 = JSON.stringify(t2)), window.localStorage.setItem(e3, n2);
    } else
      this.storageFallback[e3] = t2;
  }, LocalAuthStore.prototype._storageRemove = function(e3) {
    var t2;
    "undefined" != typeof window && (null === window || void 0 === window ? void 0 : window.localStorage) && (null === (t2 = window.localStorage) || void 0 === t2 || t2.removeItem(e3)), delete this.storageFallback[e3];
  }, LocalAuthStore;
}(a$2), u$1 = function u(e2) {
  this.client = e2;
}, l$1 = function(e2) {
  function SettingsService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(SettingsService, e2), SettingsService.prototype.getAll = function(e3) {
    return void 0 === e3 && (e3 = {}), this.client.send("/api/settings", { method: "GET", params: e3 }).then(function(e4) {
      return e4 || {};
    });
  }, SettingsService.prototype.update = function(e3, t2) {
    return void 0 === e3 && (e3 = {}), void 0 === t2 && (t2 = {}), this.client.send("/api/settings", { method: "PATCH", params: t2, body: e3 }).then(function(e4) {
      return e4 || {};
    });
  }, SettingsService.prototype.testS3 = function(e3, t2) {
    void 0 === e3 && (e3 = "storage"), void 0 === t2 && (t2 = {});
    var n2 = { filesystem: e3 };
    return this.client.send("/api/settings/test/s3", { method: "POST", params: t2, body: n2 }).then(function() {
      return true;
    });
  }, SettingsService.prototype.testEmail = function(e3, t2, n2) {
    void 0 === n2 && (n2 = {});
    var i2 = { email: e3, template: t2 };
    return this.client.send("/api/settings/test/email", { method: "POST", params: n2, body: i2 }).then(function() {
      return true;
    });
  }, SettingsService.prototype.generateAppleClientSecret = function(e3, t2, n2, i2, o2, r2, s2) {
    return void 0 === r2 && (r2 = {}), void 0 === s2 && (s2 = {}), r2 = Object.assign({ clientId: e3, teamId: t2, keyId: n2, privateKey: i2, duration: o2 }, r2), this.client.send("/api/settings/apple/generate-client-secret", { method: "POST", params: s2, body: r2 });
  }, SettingsService;
}(u$1), d$3 = function d(e2, t2, n2, i2, o2) {
  this.page = e2 > 0 ? e2 : 1, this.perPage = t2 >= 0 ? t2 : 0, this.totalItems = n2 >= 0 ? n2 : 0, this.totalPages = i2 >= 0 ? i2 : 0, this.items = o2 || [];
}, h$1 = function(e2) {
  function CrudService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(CrudService, e2), CrudService.prototype.getFullList = function(e3, t2) {
    if ("number" == typeof e3)
      return this._getFullList(this.baseCrudPath, e3, t2);
    var n2 = Object.assign({}, e3, t2);
    return this._getFullList(this.baseCrudPath, n2.batch || 200, n2);
  }, CrudService.prototype.getList = function(e3, t2, n2) {
    return void 0 === e3 && (e3 = 1), void 0 === t2 && (t2 = 30), void 0 === n2 && (n2 = {}), this._getList(this.baseCrudPath, e3, t2, n2);
  }, CrudService.prototype.getFirstListItem = function(e3, t2) {
    return void 0 === t2 && (t2 = {}), this._getFirstListItem(this.baseCrudPath, e3, t2);
  }, CrudService.prototype.getOne = function(e3, t2) {
    return void 0 === t2 && (t2 = {}), this._getOne(this.baseCrudPath, e3, t2);
  }, CrudService.prototype.create = function(e3, t2) {
    return void 0 === e3 && (e3 = {}), void 0 === t2 && (t2 = {}), this._create(this.baseCrudPath, e3, t2);
  }, CrudService.prototype.update = function(e3, t2, n2) {
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), this._update(this.baseCrudPath, e3, t2, n2);
  }, CrudService.prototype.delete = function(e3, t2) {
    return void 0 === t2 && (t2 = {}), this._delete(this.baseCrudPath, e3, t2);
  }, CrudService;
}(function(e2) {
  function BaseCrudService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(BaseCrudService, e2), BaseCrudService.prototype._getFullList = function(e3, t2, n2) {
    var i2 = this;
    void 0 === t2 && (t2 = 200), void 0 === n2 && (n2 = {});
    var o2 = [], request = function(r2) {
      return __awaiter(i2, void 0, void 0, function() {
        return __generator(this, function(i3) {
          return [2, this._getList(e3, r2, t2 || 200, n2).then(function(e4) {
            var t3 = e4, n3 = t3.items, i4 = t3.totalItems;
            return o2 = o2.concat(n3), n3.length && i4 > o2.length ? request(r2 + 1) : o2;
          })];
        });
      });
    };
    return request(1);
  }, BaseCrudService.prototype._getList = function(e3, t2, n2, i2) {
    var o2 = this;
    return void 0 === t2 && (t2 = 1), void 0 === n2 && (n2 = 30), void 0 === i2 && (i2 = {}), i2 = Object.assign({ page: t2, perPage: n2 }, i2), this.client.send(e3, { method: "GET", params: i2 }).then(function(e4) {
      var t3 = [];
      if (null == e4 ? void 0 : e4.items) {
        e4.items = e4.items || [];
        for (var n3 = 0, i3 = e4.items; n3 < i3.length; n3++) {
          var r2 = i3[n3];
          t3.push(o2.decode(r2));
        }
      }
      return new d$3((null == e4 ? void 0 : e4.page) || 1, (null == e4 ? void 0 : e4.perPage) || 0, (null == e4 ? void 0 : e4.totalItems) || 0, (null == e4 ? void 0 : e4.totalPages) || 0, t3);
    });
  }, BaseCrudService.prototype._getOne = function(e3, t2, n2) {
    var i2 = this;
    return void 0 === n2 && (n2 = {}), this.client.send(e3 + "/" + encodeURIComponent(t2), { method: "GET", params: n2 }).then(function(e4) {
      return i2.decode(e4);
    });
  }, BaseCrudService.prototype._getFirstListItem = function(e3, n2, i2) {
    return void 0 === i2 && (i2 = {}), i2 = Object.assign({ filter: n2, $cancelKey: "one_by_filter_" + e3 + "_" + n2 }, i2), this._getList(e3, 1, 1, i2).then(function(e4) {
      var n3;
      if (!(null === (n3 = null == e4 ? void 0 : e4.items) || void 0 === n3 ? void 0 : n3.length))
        throw new t$2({ status: 404, data: { code: 404, message: "The requested resource wasn't found.", data: {} } });
      return e4.items[0];
    });
  }, BaseCrudService.prototype._create = function(e3, t2, n2) {
    var i2 = this;
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), this.client.send(e3, { method: "POST", params: n2, body: t2 }).then(function(e4) {
      return i2.decode(e4);
    });
  }, BaseCrudService.prototype._update = function(e3, t2, n2, i2) {
    var o2 = this;
    return void 0 === n2 && (n2 = {}), void 0 === i2 && (i2 = {}), this.client.send(e3 + "/" + encodeURIComponent(t2), { method: "PATCH", params: i2, body: n2 }).then(function(e4) {
      return o2.decode(e4);
    });
  }, BaseCrudService.prototype._delete = function(e3, t2, n2) {
    return void 0 === n2 && (n2 = {}), this.client.send(e3 + "/" + encodeURIComponent(t2), { method: "DELETE", params: n2 }).then(function() {
      return true;
    });
  }, BaseCrudService;
}(u$1)), p$1 = function(e2) {
  function AdminService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(AdminService, e2), AdminService.prototype.decode = function(e3) {
    return new r$2(e3);
  }, Object.defineProperty(AdminService.prototype, "baseCrudPath", { get: function() {
    return "/api/admins";
  }, enumerable: false, configurable: true }), AdminService.prototype.update = function(t2, n2, i2) {
    var o2 = this;
    return void 0 === n2 && (n2 = {}), void 0 === i2 && (i2 = {}), e2.prototype.update.call(this, t2, n2, i2).then(function(e3) {
      var t3, n3;
      return o2.client.authStore.model && void 0 === (null === (t3 = o2.client.authStore.model) || void 0 === t3 ? void 0 : t3.collectionId) && (null === (n3 = o2.client.authStore.model) || void 0 === n3 ? void 0 : n3.id) === (null == e3 ? void 0 : e3.id) && o2.client.authStore.save(o2.client.authStore.token, e3), e3;
    });
  }, AdminService.prototype.delete = function(t2, n2) {
    var i2 = this;
    return void 0 === n2 && (n2 = {}), e2.prototype.delete.call(this, t2, n2).then(function(e3) {
      var n3, o2;
      return e3 && i2.client.authStore.model && void 0 === (null === (n3 = i2.client.authStore.model) || void 0 === n3 ? void 0 : n3.collectionId) && (null === (o2 = i2.client.authStore.model) || void 0 === o2 ? void 0 : o2.id) === t2 && i2.client.authStore.clear(), e3;
    });
  }, AdminService.prototype.authResponse = function(e3) {
    var t2 = this.decode((null == e3 ? void 0 : e3.admin) || {});
    return (null == e3 ? void 0 : e3.token) && (null == e3 ? void 0 : e3.admin) && this.client.authStore.save(e3.token, t2), Object.assign({}, e3, { token: (null == e3 ? void 0 : e3.token) || "", admin: t2 });
  }, AdminService.prototype.authWithPassword = function(e3, t2, n2, i2) {
    return void 0 === n2 && (n2 = {}), void 0 === i2 && (i2 = {}), n2 = Object.assign({ identity: e3, password: t2 }, n2), this.client.send(this.baseCrudPath + "/auth-with-password", { method: "POST", params: i2, body: n2 }).then(this.authResponse.bind(this));
  }, AdminService.prototype.authRefresh = function(e3, t2) {
    return void 0 === e3 && (e3 = {}), void 0 === t2 && (t2 = {}), this.client.send(this.baseCrudPath + "/auth-refresh", { method: "POST", params: t2, body: e3 }).then(this.authResponse.bind(this));
  }, AdminService.prototype.requestPasswordReset = function(e3, t2, n2) {
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), t2 = Object.assign({ email: e3 }, t2), this.client.send(this.baseCrudPath + "/request-password-reset", { method: "POST", params: n2, body: t2 }).then(function() {
      return true;
    });
  }, AdminService.prototype.confirmPasswordReset = function(e3, t2, n2, i2, o2) {
    return void 0 === i2 && (i2 = {}), void 0 === o2 && (o2 = {}), i2 = Object.assign({ token: e3, password: t2, passwordConfirm: n2 }, i2), this.client.send(this.baseCrudPath + "/confirm-password-reset", { method: "POST", params: o2, body: i2 }).then(function() {
      return true;
    });
  }, AdminService;
}(h$1), v$1 = function(e2) {
  function ExternalAuth() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(ExternalAuth, e2), ExternalAuth.prototype.$load = function(t2) {
    e2.prototype.$load.call(this, t2), this.recordId = "string" == typeof t2.recordId ? t2.recordId : "", this.collectionId = "string" == typeof t2.collectionId ? t2.collectionId : "", this.provider = "string" == typeof t2.provider ? t2.provider : "", this.providerId = "string" == typeof t2.providerId ? t2.providerId : "";
  }, ExternalAuth;
}(i$2), f$1 = function(e2) {
  function RecordService(t2, n2) {
    var i2 = e2.call(this, t2) || this;
    return i2.collectionIdOrName = n2, i2;
  }
  return __extends(RecordService, e2), RecordService.prototype.decode = function(e3) {
    return new o$3(e3);
  }, Object.defineProperty(RecordService.prototype, "baseCrudPath", { get: function() {
    return this.baseCollectionPath + "/records";
  }, enumerable: false, configurable: true }), Object.defineProperty(RecordService.prototype, "baseCollectionPath", { get: function() {
    return "/api/collections/" + encodeURIComponent(this.collectionIdOrName);
  }, enumerable: false, configurable: true }), RecordService.prototype.subscribeOne = function(e3, t2) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(n2) {
        return console.warn("PocketBase: subscribeOne(recordId, callback) is deprecated. Please replace it with subscribe(recordId, callback)."), [2, this.client.realtime.subscribe(this.collectionIdOrName + "/" + e3, t2)];
      });
    });
  }, RecordService.prototype.subscribe = function(e3, t2) {
    return __awaiter(this, void 0, void 0, function() {
      var n2;
      return __generator(this, function(i2) {
        if ("function" == typeof e3)
          return console.warn("PocketBase: subscribe(callback) is deprecated. Please replace it with subscribe('*', callback)."), [2, this.client.realtime.subscribe(this.collectionIdOrName, e3)];
        if (!t2)
          throw new Error("Missing subscription callback.");
        if ("" === e3)
          throw new Error("Missing topic.");
        return n2 = this.collectionIdOrName, "*" !== e3 && (n2 += "/" + e3), [2, this.client.realtime.subscribe(n2, t2)];
      });
    });
  }, RecordService.prototype.unsubscribe = function(e3) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(t2) {
        return "*" === e3 ? [2, this.client.realtime.unsubscribe(this.collectionIdOrName)] : e3 ? [2, this.client.realtime.unsubscribe(this.collectionIdOrName + "/" + e3)] : [2, this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName)];
      });
    });
  }, RecordService.prototype.getFullList = function(t2, n2) {
    if ("number" == typeof t2)
      return e2.prototype.getFullList.call(this, t2, n2);
    var i2 = Object.assign({}, t2, n2);
    return e2.prototype.getFullList.call(this, i2);
  }, RecordService.prototype.getList = function(t2, n2, i2) {
    return void 0 === t2 && (t2 = 1), void 0 === n2 && (n2 = 30), void 0 === i2 && (i2 = {}), e2.prototype.getList.call(this, t2, n2, i2);
  }, RecordService.prototype.getFirstListItem = function(t2, n2) {
    return void 0 === n2 && (n2 = {}), e2.prototype.getFirstListItem.call(this, t2, n2);
  }, RecordService.prototype.getOne = function(t2, n2) {
    return void 0 === n2 && (n2 = {}), e2.prototype.getOne.call(this, t2, n2);
  }, RecordService.prototype.create = function(t2, n2) {
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), e2.prototype.create.call(this, t2, n2);
  }, RecordService.prototype.update = function(t2, n2, i2) {
    var o2 = this;
    return void 0 === n2 && (n2 = {}), void 0 === i2 && (i2 = {}), e2.prototype.update.call(this, t2, n2, i2).then(function(e3) {
      var t3, n3, i3;
      return (null === (t3 = o2.client.authStore.model) || void 0 === t3 ? void 0 : t3.id) !== (null == e3 ? void 0 : e3.id) || (null === (n3 = o2.client.authStore.model) || void 0 === n3 ? void 0 : n3.collectionId) !== o2.collectionIdOrName && (null === (i3 = o2.client.authStore.model) || void 0 === i3 ? void 0 : i3.collectionName) !== o2.collectionIdOrName || o2.client.authStore.save(o2.client.authStore.token, e3), e3;
    });
  }, RecordService.prototype.delete = function(t2, n2) {
    var i2 = this;
    return void 0 === n2 && (n2 = {}), e2.prototype.delete.call(this, t2, n2).then(function(e3) {
      var n3, o2, r2;
      return !e3 || (null === (n3 = i2.client.authStore.model) || void 0 === n3 ? void 0 : n3.id) !== t2 || (null === (o2 = i2.client.authStore.model) || void 0 === o2 ? void 0 : o2.collectionId) !== i2.collectionIdOrName && (null === (r2 = i2.client.authStore.model) || void 0 === r2 ? void 0 : r2.collectionName) !== i2.collectionIdOrName || i2.client.authStore.clear(), e3;
    });
  }, RecordService.prototype.authResponse = function(e3) {
    var t2 = this.decode((null == e3 ? void 0 : e3.record) || {});
    return this.client.authStore.save(null == e3 ? void 0 : e3.token, t2), Object.assign({}, e3, { token: (null == e3 ? void 0 : e3.token) || "", record: t2 });
  }, RecordService.prototype.listAuthMethods = function(e3) {
    return void 0 === e3 && (e3 = {}), this.client.send(this.baseCollectionPath + "/auth-methods", { method: "GET", params: e3 }).then(function(e4) {
      return Object.assign({}, e4, { usernamePassword: !!(null == e4 ? void 0 : e4.usernamePassword), emailPassword: !!(null == e4 ? void 0 : e4.emailPassword), authProviders: Array.isArray(null == e4 ? void 0 : e4.authProviders) ? null == e4 ? void 0 : e4.authProviders : [] });
    });
  }, RecordService.prototype.authWithPassword = function(e3, t2, n2, i2) {
    var o2 = this;
    return void 0 === n2 && (n2 = {}), void 0 === i2 && (i2 = {}), n2 = Object.assign({ identity: e3, password: t2 }, n2), this.client.send(this.baseCollectionPath + "/auth-with-password", { method: "POST", params: i2, body: n2 }).then(function(e4) {
      return o2.authResponse(e4);
    });
  }, RecordService.prototype.authWithOAuth2Code = function(e3, t2, n2, i2, o2, r2, s2) {
    var a2 = this;
    return void 0 === o2 && (o2 = {}), void 0 === r2 && (r2 = {}), void 0 === s2 && (s2 = {}), r2 = Object.assign({ provider: e3, code: t2, codeVerifier: n2, redirectUrl: i2, createData: o2 }, r2), this.client.send(this.baseCollectionPath + "/auth-with-oauth2", { method: "POST", params: s2, body: r2 }).then(function(e4) {
      return a2.authResponse(e4);
    });
  }, RecordService.prototype.authWithOAuth2 = function() {
    for (var e3 = [], n2 = 0; n2 < arguments.length; n2++)
      e3[n2] = arguments[n2];
    return __awaiter(this, void 0, void 0, function() {
      var n3, i2, o2, r2, s2 = this;
      return __generator(this, function(a2) {
        switch (a2.label) {
          case 0:
            return e3.length > 1 || "string" == typeof (null == e3 ? void 0 : e3[0]) ? (console.warn("PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration."), [2, this.authWithOAuth2Code((null == e3 ? void 0 : e3[0]) || "", (null == e3 ? void 0 : e3[1]) || "", (null == e3 ? void 0 : e3[2]) || "", (null == e3 ? void 0 : e3[3]) || "", (null == e3 ? void 0 : e3[4]) || {}, (null == e3 ? void 0 : e3[5]) || {}, (null == e3 ? void 0 : e3[6]) || {})]) : (n3 = (null == e3 ? void 0 : e3[0]) || {}, [4, this.listAuthMethods()]);
          case 1:
            if (i2 = a2.sent(), !(o2 = i2.authProviders.find(function(e4) {
              return e4.name === n3.provider;
            })))
              throw new t$2(new Error('Missing or invalid provider "'.concat(n3.provider, '".')));
            return r2 = this.client.buildUrl("/api/oauth2-redirect"), [2, new Promise(function(e4, i3) {
              return __awaiter(s2, void 0, void 0, function() {
                var s3, a3, c2, u3, l2, d3 = this;
                return __generator(this, function(h2) {
                  switch (h2.label) {
                    case 0:
                      return h2.trys.push([0, 3, , 4]), [4, this.client.realtime.subscribe("@oauth2", function(a4) {
                        return __awaiter(d3, void 0, void 0, function() {
                          var c3, u4, l3;
                          return __generator(this, function(d4) {
                            switch (d4.label) {
                              case 0:
                                c3 = this.client.realtime.clientId, d4.label = 1;
                              case 1:
                                if (d4.trys.push([1, 3, , 4]), s3(), !a4.state || c3 !== a4.state)
                                  throw new Error("State parameters don't match.");
                                return [4, this.authWithOAuth2Code(o2.name, a4.code, o2.codeVerifier, r2, n3.createData, n3.body, n3.query)];
                              case 2:
                                return u4 = d4.sent(), e4(u4), [3, 4];
                              case 3:
                                return l3 = d4.sent(), i3(new t$2(l3)), [3, 4];
                              case 4:
                                return [2];
                            }
                          });
                        });
                      })];
                    case 1:
                      return s3 = h2.sent(), a3 = { state: this.client.realtime.clientId }, (null === (l2 = n3.scopes) || void 0 === l2 ? void 0 : l2.length) && (a3.scope = n3.scopes.join(" ")), c2 = this._replaceQueryParams(o2.authUrl + r2, a3), [4, n3.urlCallback ? n3.urlCallback(c2) : this._defaultUrlCallback(c2)];
                    case 2:
                      return h2.sent(), [3, 4];
                    case 3:
                      return u3 = h2.sent(), i3(new t$2(u3)), [3, 4];
                    case 4:
                      return [2];
                  }
                });
              });
            })];
        }
      });
    });
  }, RecordService.prototype.authRefresh = function(e3, t2) {
    var n2 = this;
    return void 0 === e3 && (e3 = {}), void 0 === t2 && (t2 = {}), this.client.send(this.baseCollectionPath + "/auth-refresh", { method: "POST", params: t2, body: e3 }).then(function(e4) {
      return n2.authResponse(e4);
    });
  }, RecordService.prototype.requestPasswordReset = function(e3, t2, n2) {
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), t2 = Object.assign({ email: e3 }, t2), this.client.send(this.baseCollectionPath + "/request-password-reset", { method: "POST", params: n2, body: t2 }).then(function() {
      return true;
    });
  }, RecordService.prototype.confirmPasswordReset = function(e3, t2, n2, i2, o2) {
    return void 0 === i2 && (i2 = {}), void 0 === o2 && (o2 = {}), i2 = Object.assign({ token: e3, password: t2, passwordConfirm: n2 }, i2), this.client.send(this.baseCollectionPath + "/confirm-password-reset", { method: "POST", params: o2, body: i2 }).then(function() {
      return true;
    });
  }, RecordService.prototype.requestVerification = function(e3, t2, n2) {
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), t2 = Object.assign({ email: e3 }, t2), this.client.send(this.baseCollectionPath + "/request-verification", { method: "POST", params: n2, body: t2 }).then(function() {
      return true;
    });
  }, RecordService.prototype.confirmVerification = function(e3, t2, n2) {
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), t2 = Object.assign({ token: e3 }, t2), this.client.send(this.baseCollectionPath + "/confirm-verification", { method: "POST", params: n2, body: t2 }).then(function() {
      return true;
    });
  }, RecordService.prototype.requestEmailChange = function(e3, t2, n2) {
    return void 0 === t2 && (t2 = {}), void 0 === n2 && (n2 = {}), t2 = Object.assign({ newEmail: e3 }, t2), this.client.send(this.baseCollectionPath + "/request-email-change", { method: "POST", params: n2, body: t2 }).then(function() {
      return true;
    });
  }, RecordService.prototype.confirmEmailChange = function(e3, t2, n2, i2) {
    return void 0 === n2 && (n2 = {}), void 0 === i2 && (i2 = {}), n2 = Object.assign({ token: e3, password: t2 }, n2), this.client.send(this.baseCollectionPath + "/confirm-email-change", { method: "POST", params: i2, body: n2 }).then(function() {
      return true;
    });
  }, RecordService.prototype.listExternalAuths = function(e3, t2) {
    return void 0 === t2 && (t2 = {}), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e3) + "/external-auths", { method: "GET", params: t2 }).then(function(e4) {
      var t3 = [];
      if (Array.isArray(e4))
        for (var n2 = 0, i2 = e4; n2 < i2.length; n2++) {
          var o2 = i2[n2];
          t3.push(new v$1(o2));
        }
      return t3;
    });
  }, RecordService.prototype.unlinkExternalAuth = function(e3, t2, n2) {
    return void 0 === n2 && (n2 = {}), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e3) + "/external-auths/" + encodeURIComponent(t2), { method: "DELETE", params: n2 }).then(function() {
      return true;
    });
  }, RecordService.prototype._replaceQueryParams = function(e3, t2) {
    void 0 === t2 && (t2 = {});
    var n2 = e3, i2 = "";
    e3.indexOf("?") >= 0 && (n2 = e3.substring(0, e3.indexOf("?")), i2 = e3.substring(e3.indexOf("?") + 1));
    for (var o2 = {}, r2 = 0, s2 = i2.split("&"); r2 < s2.length; r2++) {
      var a2 = s2[r2];
      if ("" != a2) {
        var c2 = a2.split("=");
        o2[decodeURIComponent(c2[0].replace(/\+/g, " "))] = decodeURIComponent((c2[1] || "").replace(/\+/g, " "));
      }
    }
    for (var u3 in t2)
      t2.hasOwnProperty(u3) && (null == t2[u3] ? delete o2[u3] : o2[u3] = t2[u3]);
    for (var u3 in i2 = "", o2)
      o2.hasOwnProperty(u3) && ("" != i2 && (i2 += "&"), i2 += encodeURIComponent(u3.replace(/%20/g, "+")) + "=" + encodeURIComponent(o2[u3].replace(/%20/g, "+")));
    return "" != i2 ? n2 + "?" + i2 : n2;
  }, RecordService.prototype._defaultUrlCallback = function(e3) {
    if ("undefined" == typeof window || !(null === window || void 0 === window ? void 0 : window.open))
      throw new t$2(new Error("Not in a browser context - please pass a custom urlCallback function."));
    var n2 = 1024, i2 = 768, o2 = window.innerWidth, r2 = window.innerHeight, s2 = o2 / 2 - (n2 = n2 > o2 ? o2 : n2) / 2, a2 = r2 / 2 - (i2 = i2 > r2 ? r2 : i2) / 2;
    window.open(e3, "oauth2-popup", "width=" + n2 + ",height=" + i2 + ",top=" + a2 + ",left=" + s2 + ",resizable,menubar=no");
  }, RecordService;
}(h$1), m$1 = function m(e2) {
  void 0 === e2 && (e2 = {}), this.id = void 0 !== e2.id ? e2.id : "", this.name = void 0 !== e2.name ? e2.name : "", this.type = void 0 !== e2.type ? e2.type : "text", this.system = !!e2.system, this.required = !!e2.required, this.options = "object" == typeof e2.options && null !== e2.options ? e2.options : {};
}, b$1 = function(e2) {
  function Collection() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(Collection, e2), Collection.prototype.$load = function(t2) {
    e2.prototype.$load.call(this, t2), this.system = !!t2.system, this.name = "string" == typeof t2.name ? t2.name : "", this.type = "string" == typeof t2.type ? t2.type : "base", this.options = void 0 !== t2.options && null !== t2.options ? t2.options : {}, this.indexes = Array.isArray(t2.indexes) ? t2.indexes : [], this.listRule = "string" == typeof t2.listRule ? t2.listRule : null, this.viewRule = "string" == typeof t2.viewRule ? t2.viewRule : null, this.createRule = "string" == typeof t2.createRule ? t2.createRule : null, this.updateRule = "string" == typeof t2.updateRule ? t2.updateRule : null, this.deleteRule = "string" == typeof t2.deleteRule ? t2.deleteRule : null, t2.schema = Array.isArray(t2.schema) ? t2.schema : [], this.schema = [];
    for (var n2 = 0, i2 = t2.schema; n2 < i2.length; n2++) {
      var o2 = i2[n2];
      this.schema.push(new m$1(o2));
    }
  }, Object.defineProperty(Collection.prototype, "isBase", { get: function() {
    return this.$isBase;
  }, enumerable: false, configurable: true }), Object.defineProperty(Collection.prototype, "$isBase", { get: function() {
    return "base" === this.type;
  }, enumerable: false, configurable: true }), Object.defineProperty(Collection.prototype, "isAuth", { get: function() {
    return this.$isAuth;
  }, enumerable: false, configurable: true }), Object.defineProperty(Collection.prototype, "$isAuth", { get: function() {
    return "auth" === this.type;
  }, enumerable: false, configurable: true }), Object.defineProperty(Collection.prototype, "isView", { get: function() {
    return this.$isView;
  }, enumerable: false, configurable: true }), Object.defineProperty(Collection.prototype, "$isView", { get: function() {
    return "view" === this.type;
  }, enumerable: false, configurable: true }), Collection;
}(i$2), y$1 = function(e2) {
  function CollectionService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(CollectionService, e2), CollectionService.prototype.decode = function(e3) {
    return new b$1(e3);
  }, Object.defineProperty(CollectionService.prototype, "baseCrudPath", { get: function() {
    return "/api/collections";
  }, enumerable: false, configurable: true }), CollectionService.prototype.import = function(e3, t2, n2) {
    return void 0 === t2 && (t2 = false), void 0 === n2 && (n2 = {}), __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(i2) {
        return [2, this.client.send(this.baseCrudPath + "/import", { method: "PUT", params: n2, body: { collections: e3, deleteMissing: t2 } }).then(function() {
          return true;
        })];
      });
    });
  }, CollectionService;
}(h$1), g$1 = function(e2) {
  function LogRequest() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(LogRequest, e2), LogRequest.prototype.$load = function(t2) {
    e2.prototype.$load.call(this, t2), t2.remoteIp = t2.remoteIp || t2.ip, this.url = "string" == typeof t2.url ? t2.url : "", this.method = "string" == typeof t2.method ? t2.method : "GET", this.status = "number" == typeof t2.status ? t2.status : 200, this.auth = "string" == typeof t2.auth ? t2.auth : "guest", this.remoteIp = "string" == typeof t2.remoteIp ? t2.remoteIp : "", this.userIp = "string" == typeof t2.userIp ? t2.userIp : "", this.referer = "string" == typeof t2.referer ? t2.referer : "", this.userAgent = "string" == typeof t2.userAgent ? t2.userAgent : "", this.meta = "object" == typeof t2.meta && null !== t2.meta ? t2.meta : {};
  }, LogRequest;
}(i$2), S$1 = function(e2) {
  function LogService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(LogService, e2), LogService.prototype.getRequestsList = function(e3, t2, n2) {
    return void 0 === e3 && (e3 = 1), void 0 === t2 && (t2 = 30), void 0 === n2 && (n2 = {}), n2 = Object.assign({ page: e3, perPage: t2 }, n2), this.client.send("/api/logs/requests", { method: "GET", params: n2 }).then(function(e4) {
      var t3 = [];
      if (null == e4 ? void 0 : e4.items) {
        e4.items = (null == e4 ? void 0 : e4.items) || [];
        for (var n3 = 0, i2 = e4.items; n3 < i2.length; n3++) {
          var o2 = i2[n3];
          t3.push(new g$1(o2));
        }
      }
      return new d$3((null == e4 ? void 0 : e4.page) || 1, (null == e4 ? void 0 : e4.perPage) || 0, (null == e4 ? void 0 : e4.totalItems) || 0, (null == e4 ? void 0 : e4.totalPages) || 0, t3);
    });
  }, LogService.prototype.getRequest = function(e3, t2) {
    return void 0 === t2 && (t2 = {}), this.client.send("/api/logs/requests/" + encodeURIComponent(e3), { method: "GET", params: t2 }).then(function(e4) {
      return new g$1(e4);
    });
  }, LogService.prototype.getRequestsStats = function(e3) {
    return void 0 === e3 && (e3 = {}), this.client.send("/api/logs/requests/stats", { method: "GET", params: e3 }).then(function(e4) {
      return e4;
    });
  }, LogService;
}(u$1), w$1 = function(e2) {
  function RealtimeService() {
    var t2 = null !== e2 && e2.apply(this, arguments) || this;
    return t2.clientId = "", t2.eventSource = null, t2.subscriptions = {}, t2.lastSentTopics = [], t2.maxConnectTimeout = 15e3, t2.reconnectAttempts = 0, t2.maxReconnectAttempts = 1 / 0, t2.predefinedReconnectIntervals = [200, 300, 500, 1e3, 1200, 1500, 2e3], t2.pendingConnects = [], t2;
  }
  return __extends(RealtimeService, e2), Object.defineProperty(RealtimeService.prototype, "isConnected", { get: function() {
    return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;
  }, enumerable: false, configurable: true }), RealtimeService.prototype.subscribe = function(e3, t2) {
    var n2;
    return __awaiter(this, void 0, void 0, function() {
      var i2, o2 = this;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (!e3)
              throw new Error("topic must be set.");
            return i2 = function(e4) {
              var n3, i3 = e4;
              try {
                n3 = JSON.parse(null == i3 ? void 0 : i3.data);
              } catch (e5) {
              }
              t2(n3 || {});
            }, this.subscriptions[e3] || (this.subscriptions[e3] = []), this.subscriptions[e3].push(i2), this.isConnected ? [3, 2] : [4, this.connect()];
          case 1:
            return r2.sent(), [3, 5];
          case 2:
            return 1 !== this.subscriptions[e3].length ? [3, 4] : [4, this.submitSubscriptions()];
          case 3:
            return r2.sent(), [3, 5];
          case 4:
            null === (n2 = this.eventSource) || void 0 === n2 || n2.addEventListener(e3, i2), r2.label = 5;
          case 5:
            return [2, function() {
              return __awaiter(o2, void 0, void 0, function() {
                return __generator(this, function(t3) {
                  return [2, this.unsubscribeByTopicAndListener(e3, i2)];
                });
              });
            }];
        }
      });
    });
  }, RealtimeService.prototype.unsubscribe = function(e3) {
    var t2;
    return __awaiter(this, void 0, void 0, function() {
      var n2, i2, o2;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (!this.hasSubscriptionListeners(e3))
              return [2];
            if (e3) {
              for (n2 = 0, i2 = this.subscriptions[e3]; n2 < i2.length; n2++)
                o2 = i2[n2], null === (t2 = this.eventSource) || void 0 === t2 || t2.removeEventListener(e3, o2);
              delete this.subscriptions[e3];
            } else
              this.subscriptions = {};
            return this.hasSubscriptionListeners() ? [3, 1] : (this.disconnect(), [3, 3]);
          case 1:
            return this.hasSubscriptionListeners(e3) ? [3, 3] : [4, this.submitSubscriptions()];
          case 2:
            r2.sent(), r2.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, RealtimeService.prototype.unsubscribeByPrefix = function(e3) {
    var t2;
    return __awaiter(this, void 0, void 0, function() {
      var n2, i2, o2, r2, s2;
      return __generator(this, function(a2) {
        switch (a2.label) {
          case 0:
            for (i2 in n2 = false, this.subscriptions)
              if (i2.startsWith(e3)) {
                for (n2 = true, o2 = 0, r2 = this.subscriptions[i2]; o2 < r2.length; o2++)
                  s2 = r2[o2], null === (t2 = this.eventSource) || void 0 === t2 || t2.removeEventListener(i2, s2);
                delete this.subscriptions[i2];
              }
            return n2 ? this.hasSubscriptionListeners() ? [4, this.submitSubscriptions()] : [3, 2] : [2];
          case 1:
            return a2.sent(), [3, 3];
          case 2:
            this.disconnect(), a2.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, RealtimeService.prototype.unsubscribeByTopicAndListener = function(e3, t2) {
    var n2;
    return __awaiter(this, void 0, void 0, function() {
      var i2, o2;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (!Array.isArray(this.subscriptions[e3]) || !this.subscriptions[e3].length)
              return [2];
            for (i2 = false, o2 = this.subscriptions[e3].length - 1; o2 >= 0; o2--)
              this.subscriptions[e3][o2] === t2 && (i2 = true, delete this.subscriptions[e3][o2], this.subscriptions[e3].splice(o2, 1), null === (n2 = this.eventSource) || void 0 === n2 || n2.removeEventListener(e3, t2));
            return i2 ? (this.subscriptions[e3].length || delete this.subscriptions[e3], this.hasSubscriptionListeners() ? [3, 1] : (this.disconnect(), [3, 3])) : [2];
          case 1:
            return this.hasSubscriptionListeners(e3) ? [3, 3] : [4, this.submitSubscriptions()];
          case 2:
            r2.sent(), r2.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, RealtimeService.prototype.hasSubscriptionListeners = function(e3) {
    var t2, n2;
    if (this.subscriptions = this.subscriptions || {}, e3)
      return !!(null === (t2 = this.subscriptions[e3]) || void 0 === t2 ? void 0 : t2.length);
    for (var i2 in this.subscriptions)
      if (null === (n2 = this.subscriptions[i2]) || void 0 === n2 ? void 0 : n2.length)
        return true;
    return false;
  }, RealtimeService.prototype.submitSubscriptions = function() {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(e3) {
        return this.clientId ? (this.addAllSubscriptionListeners(), this.lastSentTopics = this.getNonEmptySubscriptionTopics(), [2, this.client.send("/api/realtime", { method: "POST", body: { clientId: this.clientId, subscriptions: this.lastSentTopics }, params: { $cancelKey: this.getSubscriptionsCancelKey() } }).catch(function(e4) {
          if (!(null == e4 ? void 0 : e4.isAbort))
            throw e4;
        })]) : [2];
      });
    });
  }, RealtimeService.prototype.getSubscriptionsCancelKey = function() {
    return "realtime_" + this.clientId;
  }, RealtimeService.prototype.getNonEmptySubscriptionTopics = function() {
    var e3 = [];
    for (var t2 in this.subscriptions)
      this.subscriptions[t2].length && e3.push(t2);
    return e3;
  }, RealtimeService.prototype.addAllSubscriptionListeners = function() {
    if (this.eventSource)
      for (var e3 in this.removeAllSubscriptionListeners(), this.subscriptions)
        for (var t2 = 0, n2 = this.subscriptions[e3]; t2 < n2.length; t2++) {
          var i2 = n2[t2];
          this.eventSource.addEventListener(e3, i2);
        }
  }, RealtimeService.prototype.removeAllSubscriptionListeners = function() {
    if (this.eventSource)
      for (var e3 in this.subscriptions)
        for (var t2 = 0, n2 = this.subscriptions[e3]; t2 < n2.length; t2++) {
          var i2 = n2[t2];
          this.eventSource.removeEventListener(e3, i2);
        }
  }, RealtimeService.prototype.connect = function() {
    return __awaiter(this, void 0, void 0, function() {
      var e3 = this;
      return __generator(this, function(t2) {
        return this.reconnectAttempts > 0 ? [2] : [2, new Promise(function(t3, n2) {
          e3.pendingConnects.push({ resolve: t3, reject: n2 }), e3.pendingConnects.length > 1 || e3.initConnect();
        })];
      });
    });
  }, RealtimeService.prototype.initConnect = function() {
    var e3 = this;
    this.disconnect(true), clearTimeout(this.connectTimeoutId), this.connectTimeoutId = setTimeout(function() {
      e3.connectErrorHandler(new Error("EventSource connect took too long."));
    }, this.maxConnectTimeout), this.eventSource = new EventSource(this.client.buildUrl("/api/realtime")), this.eventSource.onerror = function(t2) {
      e3.connectErrorHandler(new Error("Failed to establish realtime connection."));
    }, this.eventSource.addEventListener("PB_CONNECT", function(t2) {
      var n2 = t2;
      e3.clientId = null == n2 ? void 0 : n2.lastEventId, e3.submitSubscriptions().then(function() {
        return __awaiter(e3, void 0, void 0, function() {
          var e4;
          return __generator(this, function(t3) {
            switch (t3.label) {
              case 0:
                e4 = 3, t3.label = 1;
              case 1:
                return this.hasUnsentSubscriptions() && e4 > 0 ? (e4--, [4, this.submitSubscriptions()]) : [3, 3];
              case 2:
                return t3.sent(), [3, 1];
              case 3:
                return [2];
            }
          });
        });
      }).then(function() {
        for (var t3 = 0, n3 = e3.pendingConnects; t3 < n3.length; t3++) {
          n3[t3].resolve();
        }
        e3.pendingConnects = [], e3.reconnectAttempts = 0, clearTimeout(e3.reconnectTimeoutId), clearTimeout(e3.connectTimeoutId);
      }).catch(function(t3) {
        e3.clientId = "", e3.connectErrorHandler(t3);
      });
    });
  }, RealtimeService.prototype.hasUnsentSubscriptions = function() {
    var e3 = this.getNonEmptySubscriptionTopics();
    if (e3.length != this.lastSentTopics.length)
      return true;
    for (var t2 = 0, n2 = e3; t2 < n2.length; t2++) {
      var i2 = n2[t2];
      if (!this.lastSentTopics.includes(i2))
        return true;
    }
    return false;
  }, RealtimeService.prototype.connectErrorHandler = function(e3) {
    var n2 = this;
    if (clearTimeout(this.connectTimeoutId), clearTimeout(this.reconnectTimeoutId), !this.clientId && !this.reconnectAttempts || this.reconnectAttempts > this.maxReconnectAttempts) {
      for (var i2 = 0, o2 = this.pendingConnects; i2 < o2.length; i2++) {
        o2[i2].reject(new t$2(e3));
      }
      return this.pendingConnects = [], void this.disconnect();
    }
    this.disconnect(true);
    var r2 = this.predefinedReconnectIntervals[this.reconnectAttempts] || this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length - 1];
    this.reconnectAttempts++, this.reconnectTimeoutId = setTimeout(function() {
      n2.initConnect();
    }, r2);
  }, RealtimeService.prototype.disconnect = function(e3) {
    var t2;
    if (void 0 === e3 && (e3 = false), clearTimeout(this.connectTimeoutId), clearTimeout(this.reconnectTimeoutId), this.removeAllSubscriptionListeners(), this.client.cancelRequest(this.getSubscriptionsCancelKey()), null === (t2 = this.eventSource) || void 0 === t2 || t2.close(), this.eventSource = null, this.clientId = "", !e3) {
      this.reconnectAttempts = 0;
      for (var n2 = 0, i2 = this.pendingConnects; n2 < i2.length; n2++) {
        i2[n2].resolve();
      }
      this.pendingConnects = [];
    }
  }, RealtimeService;
}(u$1), C$1 = function(e2) {
  function HealthService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(HealthService, e2), HealthService.prototype.check = function(e3) {
    return void 0 === e3 && (e3 = {}), this.client.send("/api/health", { method: "GET", params: e3 });
  }, HealthService;
}(u$1), _$1 = function(e2) {
  function FileService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(FileService, e2), FileService.prototype.getUrl = function(e3, t2, n2) {
    void 0 === n2 && (n2 = {});
    var i2 = [];
    i2.push("api"), i2.push("files"), i2.push(encodeURIComponent(e3.collectionId || e3.collectionName)), i2.push(encodeURIComponent(e3.id)), i2.push(encodeURIComponent(t2));
    var o2 = this.client.buildUrl(i2.join("/"));
    if (Object.keys(n2).length) {
      var r2 = new URLSearchParams(n2);
      o2 += (o2.includes("?") ? "&" : "?") + r2;
    }
    return o2;
  }, FileService.prototype.getToken = function(e3) {
    return void 0 === e3 && (e3 = {}), this.client.send("/api/files/token", { method: "POST", params: e3 }).then(function(e4) {
      return (null == e4 ? void 0 : e4.token) || "";
    });
  }, FileService;
}(u$1), R$1 = function(e2) {
  function BackupService() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(BackupService, e2), BackupService.prototype.getFullList = function(e3) {
    return void 0 === e3 && (e3 = {}), this.client.send("/api/backups", { method: "GET", params: e3 });
  }, BackupService.prototype.create = function(e3, t2) {
    void 0 === t2 && (t2 = {});
    var n2 = { name: e3 };
    return this.client.send("/api/backups", { method: "POST", params: t2, body: n2 }).then(function() {
      return true;
    });
  }, BackupService.prototype.delete = function(e3, t2) {
    return void 0 === t2 && (t2 = {}), this.client.send("/api/backups/".concat(encodeURIComponent(e3)), { method: "DELETE", params: t2 }).then(function() {
      return true;
    });
  }, BackupService.prototype.restore = function(e3, t2) {
    return void 0 === t2 && (t2 = {}), this.client.send("/api/backups/".concat(encodeURIComponent(e3), "/restore"), { method: "POST", params: t2 }).then(function() {
      return true;
    });
  }, BackupService.prototype.getDownloadUrl = function(e3, t2) {
    return this.client.buildUrl("/api/backups/".concat(encodeURIComponent(t2), "?token=").concat(encodeURIComponent(e3)));
  }, BackupService;
}(u$1), O$1 = function() {
  function Client(e2, t2, n2) {
    void 0 === e2 && (e2 = "/"), void 0 === n2 && (n2 = "en-US"), this.cancelControllers = {}, this.recordServices = {}, this.enableAutoCancellation = true, this.baseUrl = e2, this.lang = n2, this.authStore = t2 || new c$1(), this.admins = new p$1(this), this.collections = new y$1(this), this.files = new _$1(this), this.logs = new S$1(this), this.settings = new l$1(this), this.realtime = new w$1(this), this.health = new C$1(this), this.backups = new R$1(this);
  }
  return Client.prototype.collection = function(e2) {
    return this.recordServices[e2] || (this.recordServices[e2] = new f$1(this, e2)), this.recordServices[e2];
  }, Client.prototype.autoCancellation = function(e2) {
    return this.enableAutoCancellation = !!e2, this;
  }, Client.prototype.cancelRequest = function(e2) {
    return this.cancelControllers[e2] && (this.cancelControllers[e2].abort(), delete this.cancelControllers[e2]), this;
  }, Client.prototype.cancelAllRequests = function() {
    for (var e2 in this.cancelControllers)
      this.cancelControllers[e2].abort();
    return this.cancelControllers = {}, this;
  }, Client.prototype.send = function(e2, n2) {
    var i2, o2, r2, s2, a2, c2, u3, l2;
    return __awaiter(this, void 0, void 0, function() {
      var d3, h2, p2, v2, f2, m3, b2, y2, g2, S2 = this;
      return __generator(this, function(w2) {
        switch (w2.label) {
          case 0:
            return d3 = Object.assign({ method: "GET" }, n2), this.isFormData(d3.body) || (d3.body && "string" != typeof d3.body && (d3.body = JSON.stringify(d3.body)), void 0 === (null === (i2 = null == d3 ? void 0 : d3.headers) || void 0 === i2 ? void 0 : i2["Content-Type"]) && (d3.headers = Object.assign({}, d3.headers, { "Content-Type": "application/json" }))), void 0 === (null === (o2 = null == d3 ? void 0 : d3.headers) || void 0 === o2 ? void 0 : o2["Accept-Language"]) && (d3.headers = Object.assign({}, d3.headers, { "Accept-Language": this.lang })), (null === (r2 = this.authStore) || void 0 === r2 ? void 0 : r2.token) && void 0 === (null === (s2 = null == d3 ? void 0 : d3.headers) || void 0 === s2 ? void 0 : s2.Authorization) && (d3.headers = Object.assign({}, d3.headers, { Authorization: this.authStore.token })), this.enableAutoCancellation && false !== (null === (a2 = d3.params) || void 0 === a2 ? void 0 : a2.$autoCancel) && (h2 = (null === (c2 = d3.params) || void 0 === c2 ? void 0 : c2.$cancelKey) || (d3.method || "GET") + e2, this.cancelRequest(h2), p2 = new AbortController(), this.cancelControllers[h2] = p2, d3.signal = p2.signal), null === (u3 = d3.params) || void 0 === u3 || delete u3.$autoCancel, null === (l2 = d3.params) || void 0 === l2 || delete l2.$cancelKey, v2 = this.buildUrl(e2), void 0 !== d3.params && ((f2 = this.serializeQueryParams(d3.params)) && (v2 += (v2.includes("?") ? "&" : "?") + f2), delete d3.params), this.beforeSend ? (y2 = (b2 = Object).assign, g2 = [{}], [4, this.beforeSend(v2, d3)]) : [3, 2];
          case 1:
            void 0 !== (m3 = y2.apply(b2, g2.concat([w2.sent()]))).url || void 0 !== m3.options ? (v2 = m3.url || v2, d3 = m3.options || d3) : Object.keys(m3).length && (d3 = m3, (null === console || void 0 === console ? void 0 : console.warn) && console.warn("Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`.")), w2.label = 2;
          case 2:
            return [2, fetch(v2, d3).then(function(e3) {
              return __awaiter(S2, void 0, void 0, function() {
                var n3;
                return __generator(this, function(i3) {
                  switch (i3.label) {
                    case 0:
                      n3 = {}, i3.label = 1;
                    case 1:
                      return i3.trys.push([1, 3, , 4]), [4, e3.json()];
                    case 2:
                      return n3 = i3.sent(), [3, 4];
                    case 3:
                      return i3.sent(), [3, 4];
                    case 4:
                      return this.afterSend ? [4, this.afterSend(e3, n3)] : [3, 6];
                    case 5:
                      n3 = i3.sent(), i3.label = 6;
                    case 6:
                      if (e3.status >= 400)
                        throw new t$2({ url: e3.url, status: e3.status, data: n3 });
                      return [2, n3];
                  }
                });
              });
            }).catch(function(e3) {
              throw new t$2(e3);
            })];
        }
      });
    });
  }, Client.prototype.getFileUrl = function(e2, t2, n2) {
    return void 0 === n2 && (n2 = {}), this.files.getUrl(e2, t2, n2);
  }, Client.prototype.buildUrl = function(e2) {
    var t2, n2 = this.baseUrl;
    return "undefined" == typeof window || !window.location || n2.startsWith("https://") || n2.startsWith("http://") || (n2 = (null === (t2 = window.location.origin) || void 0 === t2 ? void 0 : t2.endsWith("/")) ? window.location.origin.substring(0, window.location.origin.length - 1) : window.location.origin || "", this.baseUrl.startsWith("/") || (n2 += window.location.pathname || "/", n2 += n2.endsWith("/") ? "" : "/"), n2 += this.baseUrl), e2 && (n2 += n2.endsWith("/") ? "" : "/", n2 += e2.startsWith("/") ? e2.substring(1) : e2), n2;
  }, Client.prototype.isFormData = function(e2) {
    return e2 && ("FormData" === e2.constructor.name || "undefined" != typeof FormData && e2 instanceof FormData);
  }, Client.prototype.serializeQueryParams = function(e2) {
    var t2 = [];
    for (var n2 in e2)
      if (null !== e2[n2]) {
        var i2 = e2[n2], o2 = encodeURIComponent(n2);
        if (Array.isArray(i2))
          for (var r2 = 0, s2 = i2; r2 < s2.length; r2++) {
            var a2 = s2[r2];
            t2.push(o2 + "=" + encodeURIComponent(a2));
          }
        else
          i2 instanceof Date ? t2.push(o2 + "=" + encodeURIComponent(i2.toISOString())) : null !== typeof i2 && "object" == typeof i2 ? t2.push(o2 + "=" + encodeURIComponent(JSON.stringify(i2))) : t2.push(o2 + "=" + encodeURIComponent(i2));
      }
    return t2.join("&");
  }, Client;
}();
function getServer() {
  Log(
    "api/server.ts: getServer",
    "Getting current server (arcos-current-server)",
    LogLevel.info
  );
  const server = localStorage.getItem("arcos-current-server");
  if (!server) {
    Log(
      "api/server.ts: getServer",
      "arcos-current-server does not exist, falling back to remembered servers",
      LogLevel.warn
    );
    const all3 = getAllServers();
    if (!all3.length) {
      Log(
        "api/server.ts: getServer",
        "Fallback failed: no servers to select from",
        LogLevel.error
      );
      return null;
    }
    const server2 = all3[all3.length - 1];
    setServer(server2);
    return server2;
  }
  return localStorage.getItem("arcos-current-server");
}
function getAllServers() {
  Log(
    "api/server.ts: getAllServers",
    "Retrieving all servers from arcos-servers",
    LogLevel.info
  );
  if (!localStorage.getItem("arcos-servers"))
    return [];
  return JSON.parse(localStorage.getItem("arcos-servers"));
}
function addServer(server, makeDefault = true) {
  Log(
    "api/server.ts: addServer",
    `Adding server ${server} to arcos-servers`,
    LogLevel.info
  );
  const all3 = getAllServers();
  if (!all3.includes(server))
    all3.push(server);
  localStorage.setItem("arcos-servers", JSON.stringify(all3));
  localStorage.removeItem("arcos-remembered-token");
  if (makeDefault)
    setServer(server);
}
function removeServer(server) {
  Log(
    "api/server.ts: removeServer",
    `Removing ${server} from arcos-servers`,
    LogLevel.info
  );
  const all3 = getAllServers();
  if (!all3.includes(server))
    return false;
  all3.splice(all3.indexOf(server), 1);
  localStorage.setItem("arcos-servers", JSON.stringify(all3));
  return true;
}
function migrateToMulti() {
  Log(
    "api/server.ts: migrateToMulti",
    "Migrating single-API localStorage state to multi-API",
    LogLevel.info
  );
  const server = localStorage.getItem("arcos-server");
  if (!server)
    return;
  addServer(server);
  localStorage.removeItem("arcos-server");
}
function setServer(server) {
  localStorage.setItem("arcos-current-server", server);
  localStorage.removeItem("arcos-remembered-token");
}
const ActionCenterOpened = writable(false);
function toggleActionCenter() {
  const newValue = !get_store_value(ActionCenterOpened);
  ActionCenterOpened.set(newValue);
}
const UserData$2 = writable();
const UserName = writable();
const UserToken = writable();
const EXPERIMENTS_URL = "https://arcapi.nl/topsecret/experiments/experiments.json";
const Experiments = writable({});
async function getExperiments() {
  Log(
    "desktop/experiments/main.ts: getExperiments",
    "Getting experiments from CDN"
  );
  try {
    const req = await fetch(EXPERIMENTS_URL);
    if (!req.ok)
      return false;
    try {
      const json = JSON.parse(await req.text());
      Experiments.set(json);
      Log("desktop/experiments/main.ts: getExperiments", "Experiments updated");
      return json;
    } catch {
      Log(
        "desktop/experiments/main.ts: getExperiments",
        "Could not get experiments",
        LogLevel.error
      );
      return false;
    }
  } catch {
    return false;
  }
}
async function experimentsClasses() {
  let result = "";
  if (!get_store_value(Experiments)) {
    Log(
      "classes/experiments.ts: experimentsClasses",
      "No experiments! Initializing before generating classes.",
      LogLevel.warn
    );
    await getExperiments();
  }
  const experiments2 = get_store_value(Experiments);
  const udata = get_store_value(UserData$2);
  const loaded = udata.appdata.experiments;
  if (!loaded)
    return result;
  const entries = Object.entries(loaded);
  for (let i2 = 0; i2 < entries.length; i2++) {
    if (!experiments2[entries[i2][0]])
      continue;
    if (entries[i2][1])
      result += `exp-${entries[i2][0]} `;
  }
  return result;
}
function setDesktopClassNameListener() {
  UserData$2.subscribe(async (v2) => {
    if (v2) {
      const udata = v2;
      let classes = "";
      if (udata.sh.taskbar.docked)
        classes += `tbdocked `;
      if (!udata.sh.anim)
        classes += `noani `;
      if (udata.sh.noGlass || navigator.userAgent.toLowerCase().includes("firefox"))
        classes += `noglass `;
      if (udata.sh.window.bigtb)
        classes += `bigtitlebars `;
      if (udata.sh.desktop.sharp)
        classes += `sharp `;
      if (udata.sh.taskbar.isLauncher)
        classes += `is-launcher `;
      if (udata.sh.taskbar.docked)
        classes += `tb-docked `;
      classes += await experimentsClasses();
      desktopClassNames.set(classes);
    }
  });
}
const appShortcuts = [];
function registerAppShortcuts(id, app) {
  Log(
    "keyboard: registerAppShortcuts",
    `Registering app shortcuts for ${id}`,
    LogLevel.info
  );
  if (!app.events || !app.events.keyboardShortcuts)
    return false;
  if (isRegistered(id))
    return false;
  appShortcuts.push([id, app.events.keyboardShortcuts]);
}
function registerShortcuts(data, id) {
  appShortcuts.push([id || "", data]);
}
function isRegistered(id) {
  for (let i2 = 0; i2 < appShortcuts.length; i2++) {
    if (appShortcuts[i2][0] == id)
      return true;
  }
  return false;
}
const sleep = (ms) => new Promise((r2) => setTimeout(r2, ms));
const ArcOSVersion = "5.0.11";
const minArcAPI = 2;
const Busy = writable(false);
Busy.subscribe(async (v2) => {
  if (!v2)
    return;
  await sleep(1e4);
  Busy.set(false);
});
const TwentyIcon = "" + new URL("2048-158b8f3f.svg", import.meta.url).href;
const AppManIcon = "" + new URL("appmanager-60c1ea43.svg", import.meta.url).href;
const AppPokerIcon = "" + new URL("apppoker-d7ed29fe.svg", import.meta.url).href;
const ArcTermIcon = "" + new URL("arcterm-b608c3ab.svg", import.meta.url).href;
const BugRepIcon = "" + new URL("bugreports-744772f4.svg", import.meta.url).href;
const CalculatorIcon = "" + new URL("calculator-a55e0dfc.svg", import.meta.url).href;
const DefaultIcon = "" + new URL("default-fc91861d.svg", import.meta.url).href;
const DonutIcon = "" + new URL("donut-041054d9.png", import.meta.url).href;
const ErrorIcon = "" + new URL("error-3c4c2c86.svg", import.meta.url).href;
const ErrorDialogIcon = "" + new URL("bugreports-744772f4.svg", import.meta.url).href;
const FileManagerIcon = "" + new URL("filemanager-cb441701.svg", import.meta.url).href;
const HelpCenterIcon = "" + new URL("helpcenter-dc574bdf.svg", import.meta.url).href;
const IconLibraryIcon = "" + new URL("iconlibrary-03c98ce1.svg", import.meta.url).href;
const ImageViewerIcon = "" + new URL("imageviewer-5b7c750b.svg", import.meta.url).href;
const LightsOffIcon = "" + new URL("lightsoff-07cdd0f7.svg", import.meta.url).href;
const LoggerIcon = "" + new URL("logger-53b4bb5a.svg", import.meta.url).href;
const MarkDownViewerIcon = "" + new URL("markdownviewer-a03d6bb8.svg", import.meta.url).href;
const MediaPlayerIcon = "" + new URL("mediaplayer-8f0c4cdf.svg", import.meta.url).href;
const MessagingIcon = "" + new URL("messaging-9e309b2f.svg", import.meta.url).href;
const pfpselector = "" + new URL("pfpselector-a2bb868c.svg", import.meta.url).href;
const SettingsIcon = "" + new URL("settings-ade5abd9.svg", import.meta.url).href;
const TestAppIcon = "" + new URL("testapp-fd93573e.svg", import.meta.url).href;
const UnknownIcon = "" + new URL("unknown-41ebe866.svg", import.meta.url).href;
const apps$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AppManIcon,
  AppPokerIcon,
  ArcTermIcon,
  BugRepIcon,
  CalculatorIcon,
  DefaultIcon,
  DonutIcon,
  ErrorDialogIcon,
  ErrorIcon,
  FileManagerIcon,
  HelpCenterIcon,
  IconLibraryIcon,
  ImageViewerIcon,
  LightsOffIcon,
  LoggerIcon,
  MarkDownViewerIcon,
  MediaPlayerIcon,
  MessagingIcon,
  PfpSelectorIcon: pfpselector,
  SettingsIcon,
  TestAppIcon,
  TwentyIcon,
  UnknownIcon
}, Symbol.toStringTag, { value: "Module" }));
const ErrorMessages = writable(
  []
);
const ErrorWindowStore = writable([]);
function errorMessage(title, message, image, parentId, ...buttons) {
  Log(
    "errorlogic/main.ts: errorMessage",
    `Generating "${title}"`,
    LogLevel.info
  );
  const error2 = {
    title,
    message,
    opened: false,
    buttons,
    id: Math.floor(Math.random() * 1e10),
    image,
    parentId
  };
  const em = get_store_value(ErrorMessages);
  em.push(error2);
  ErrorMessages.set(em);
  createErrorAppData(error2);
}
function closeError(id) {
  Log("errorlogic/main.ts: closeError", `Closing error ${id}`);
  const ews = get_store_value(ErrorWindowStore);
  for (let i2 = 0; i2 < ews.length; i2++) {
    if (ews[i2].id == `error_${id}`) {
      ews[i2].opened = false;
      setTimeout(() => {
        ews.splice(i2, 1);
        ErrorWindowStore.set(ews);
      }, 500);
    }
  }
  ErrorWindowStore.set(ews);
}
function openError(id) {
  Log("errorlogic/main.ts: openError", `Opening error ${id}`);
  const ews = get_store_value(ErrorWindowStore);
  for (let i2 = 0; i2 < ews.length; i2++) {
    if (ews[i2].id == `error_${id}`)
      ews[i2].opened = true;
  }
  ErrorWindowStore.set(ews);
}
function createErrorAppData(data) {
  Log(
    "errorlogic/main.ts: createErrorAppData",
    `Generating error appData for ${data.title}`,
    LogLevel.info
  );
  const error2 = {
    info: {
      name: data.title,
      description: "ArcOS.Desktop.ErrorLogicwindow",
      builtin: true,
      version: ArcOSVersion,
      author: "Generated by ArcOS",
      icon: data.image || ErrorDialogIcon
    },
    size: { w: NaN, h: NaN },
    pos: { x: 60, y: 60 },
    minSize: { w: 200, h: NaN },
    maxSize: { w: 600, h: NaN },
    controls: { min: false, max: false, cls: true },
    state: {
      headless: false,
      resizable: false,
      windowState: { min: false, max: false, fll: false }
    },
    content: null,
    glass: false,
    id: `error_${data.id}`,
    opened: false,
    parentId: data.parentId
  };
  const ews = get_store_value(ErrorWindowStore);
  ews.push(error2);
  ErrorWindowStore.set(ews);
  setTimeout(() => {
    openError(data.id);
    const el = document.querySelector(`window#${error2.id}`);
    if (!el)
      return Log(
        "ErrorLogic: createErrorAppData",
        `Can't bring window ${error2.id} to front, no associated element could be found.`,
        LogLevel.error
      );
    maxZIndex.set(get_store_value(maxZIndex) + 1);
    el.style.zIndex = `${get_store_value(maxZIndex)}`;
  }, 5);
}
const CurrentNotification = writable(null);
const NotificationStore = writable({});
let globalNotifTimeout;
function makeNotification(data) {
  clearTimeout(globalNotifTimeout);
  const id = `${Math.floor(Math.random() * 1e9)}`;
  const ns = get_store_value(NotificationStore);
  ns[id] = data;
  NotificationStore.set(ns);
  setTimeout(() => {
    CurrentNotification.set(id);
  }, 100);
  if (data.timeout)
    globalNotifTimeout = setTimeout(() => {
      CurrentNotification.set(null);
    }, data.timeout);
  return id;
}
function closeNotification() {
  CurrentNotification.set(null);
}
function deleteNotification(id) {
  const ns = get_store_value(NotificationStore);
  delete ns[id];
  NotificationStore.set(ns);
  if (get_store_value(CurrentNotification) == "id")
    closeNotification();
}
function isArray$1(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
const INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString$1(value) {
  return value == null ? "" : baseToString(value);
}
function isString$1(value) {
  return typeof value === "string";
}
function isNumber$1(value) {
  return typeof value === "number";
}
function isBoolean$1(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject$1(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject$1(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key2) => `Invalid value for key ${key2}`;
const PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
const INVALID_KEY_WEIGHT_VALUE = (key2) => `Property 'weight' in key '${key2}' must be a positive integer`;
const hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key2) => {
      let obj = createKey(key2);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key2) => {
      key2.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(key2) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString$1(key2) || isArray$1(key2)) {
    src = key2;
    path = createKeyPath(key2);
    id = createKeyId(key2);
  } else {
    if (!hasOwn.call(key2, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key2.name;
    src = name;
    if (hasOwn.call(key2, "weight")) {
      weight = key2.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key2.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key2) {
  return isArray$1(key2) ? key2 : key2.split(".");
}
function createKeyId(key2) {
  return isArray$1(key2) ? key2.join(".") : key2;
}
function get(obj, path) {
  let list2 = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list2.push(obj2);
    } else {
      let key2 = path2[index];
      const value = obj2[key2];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString$1(value) || isNumber$1(value) || isBoolean$1(value))) {
        list2.push(toString$1(value));
      } else if (isArray$1(value)) {
        arr = true;
        for (let i2 = 0, len = value.length; i2 < len; i2 += 1) {
          deepGet(value[i2], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString$1(path) ? path.split(".") : path, 0);
  return arr ? list2 : list2[0];
}
const MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
const BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a2, b2) => a2.score === b2.score ? a2.idx < b2.idx ? -1 : 1 : a2.score < b2.score ? -1 : 1
};
const FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
const AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config$1 = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
const SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m3 = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n2 = parseFloat(Math.round(norm2 * m3) / m3);
      cache.set(numTokens, n2);
      return n2;
    },
    clear() {
      cache.clear();
    }
  };
}
class FuseIndex {
  constructor({
    getFn = Config$1.getFn,
    fieldNormWeight = Config$1.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key2, idx) => {
      this._keysMap[key2.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString$1(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString$1(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i2 = idx, len = this.size(); i2 < len; i2 += 1) {
      this.records[i2].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key2, keyIndex) => {
      let value = key2.getFn ? key2.getFn(doc) : this.getFn(doc, key2.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray$1(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString$1(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray$1(value2)) {
            value2.forEach((item, k2) => {
              stack.push({
                nestedArrIndex: k2,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString$1(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function createIndex(keys, docs, { getFn = Config$1.getFn, fieldNormWeight = Config$1.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config$1.getFn, fieldNormWeight = Config$1.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config$1.distance,
  ignoreLocation = Config$1.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config$1.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i2 = 0;
  for (let len = matchmask.length; i2 < len; i2 += 1) {
    let match = matchmask[i2];
    if (match && start === -1) {
      start = i2;
    } else if (!match && start !== -1) {
      end = i2 - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i2 - 1] && i2 - start >= minMatchCharLength) {
    indices.push([start, i2 - 1]);
  }
  return indices;
}
const MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location: location2 = Config$1.location,
  distance = Config$1.distance,
  threshold = Config$1.threshold,
  findAllMatches = Config$1.findAllMatches,
  minMatchCharLength = Config$1.minMatchCharLength,
  includeMatches = Config$1.includeMatches,
  ignoreLocation = Config$1.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location2, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i2 = 0;
      while (i2 < patternLen) {
        matchMask[index + i2] = 1;
        i2 += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i2 = 0; i2 < patternLen; i2 += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i2,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i2) - 1;
    for (let j2 = finish; j2 >= start; j2 -= 1) {
      let currentLocation = j2 - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j2] = (bitArr[j2 + 1] << 1 | 1) & charMatch;
      if (i2) {
        bitArr[j2] |= (lastBitArr[j2 + 1] | lastBitArr[j2]) << 1 | 1 | lastBitArr[j2 + 1];
      }
      if (bitArr[j2] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i2,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i2 + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i2 = 0, len = pattern.length; i2 < len; i2 += 1) {
    const char = pattern.charAt(i2);
    mask[char] = (mask[char] || 0) | 1 << len - i2 - 1;
  }
  return mask;
}
class BitapSearch {
  constructor(pattern, {
    location: location2 = Config$1.location,
    threshold = Config$1.threshold,
    distance = Config$1.distance,
    includeMatches = Config$1.includeMatches,
    findAllMatches = Config$1.findAllMatches,
    minMatchCharLength = Config$1.minMatchCharLength,
    isCaseSensitive = Config$1.isCaseSensitive,
    ignoreLocation = Config$1.ignoreLocation
  } = {}) {
    this.options = {
      location: location2,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i2 = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i2 < end) {
        addChunk(this.pattern.substr(i2, MAX_BITS), i2);
        i2 += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location: location2,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location2 + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}
class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
}
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index = text2.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class FuzzyMatch extends BaseMatch {
  constructor(pattern, {
    location: location2 = Config$1.location,
    threshold = Config$1.threshold,
    distance = Config$1.distance,
    includeMatches = Config$1.includeMatches,
    findAllMatches = Config$1.findAllMatches,
    minMatchCharLength = Config$1.minMatchCharLength,
    isCaseSensitive = Config$1.isCaseSensitive,
    ignoreLocation = Config$1.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location: location2,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
}
class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location2 = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text2.indexOf(this.pattern, location2)) > -1) {
      location2 = index + patternLen;
      indices.push([index, location2 - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
const searchersLen = searchers.length;
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i2 = 0, len = query.length; i2 < len; i2 += 1) {
      const queryItem = query[i2];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
  constructor(pattern, {
    isCaseSensitive = Config$1.isCaseSensitive,
    includeMatches = Config$1.includeMatches,
    minMatchCharLength = Config$1.minMatchCharLength,
    ignoreLocation = Config$1.ignoreLocation,
    findAllMatches = Config$1.findAllMatches,
    location: location2 = Config$1.location,
    threshold = Config$1.threshold,
    distance = Config$1.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location: location2,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_2, options) {
    return options.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i2 = 0, qLen = query.length; i2 < qLen; i2 += 1) {
      const searchers2 = query[i2];
      allIndices.length = 0;
      numMatches = 0;
      for (let j2 = 0, pLen = searchers2.length; j2 < pLen; j2 += 1) {
        const searcher = searchers2[j2];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
}
const registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i2 = 0, len = registeredSearchers.length; i2 < len; i2 += 1) {
    let searcherClass = registeredSearchers[i2];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
const LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
const KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
const isPath = (query) => !!query[KeyType.PATH];
const isLeaf = (query) => !isArray$1(query) && isObject$1(query) && !isExpression(query);
const convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key2) => ({
    [key2]: query[key2]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key2 = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key2];
      if (!isString$1(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key2));
      }
      const obj = {
        keyId: createKeyId(key2),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key2) => {
      const value = query2[key2];
      if (isArray$1(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config$1.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key: key2, norm: norm2, score }) => {
      const weight = key2 ? key2.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config$1.includeMatches,
  includeScore = Config$1.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
class Fuse {
  constructor(docs, options = {}, index) {
    this.options = { ...Config$1, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i2 = 0, len = this._docs.length; i2 < len; i2 += 1) {
      const doc = this._docs[i2];
      if (predicate(doc, i2)) {
        this.removeAt(i2);
        i2 -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString$1(query) ? isString$1(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber$1(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i2 = 0, len = node.children.length; i2 < len; i2 += 1) {
        const child = node.children[i2];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key2, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key: key2,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key: key2, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray$1(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key: key2,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key: key2, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
}
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config$1;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}
function generateParamStr(params) {
  let str = "?";
  const entries = Object.entries(params);
  for (let i2 = 0; i2 < entries.length; i2++) {
    str += `${entries[i2][0]}=${entries[i2][1]}&`;
  }
  return str;
}
const BugReportData = writable();
function InvalidStateBugrep(stateSource, stateKey) {
  Log(
    "ts/bugrep.ts: InvalidStateBugrep",
    `${stateSource}: ${stateKey}`,
    LogLevel.info
  );
  BugReportData.set([
    true,
    {
      icon: "broken_image",
      title: `Broken page`,
      message: "ArcOS tried to open a page or location that doesn't exist.<br>This session can't continue. You can choose to restart.",
      button: {
        action: () => applyState("boot"),
        caption: "Restart"
      },
      source: stateSource,
      details: `applyState for ${stateSource}: Can't apply a non-existent state '${stateKey}'.`
    }
  ]);
}
const arctermonly = "";
const main = "";
const Default$1 = {
  keyword: "default",
  async exec(cmd, argv, term) {
    if (!cmd || !term || !term.std || !term.std.verbose)
      return;
    if (!cmd.trim().replaceAll(" ", ""))
      return;
    const scriptPath = await term.scripts.detectScript(term.path, cmd);
    if (!scriptPath && term && term.std) {
      return term.std.Error(`${cmd}: command not found`);
    }
    await term.scripts.runScriptFile(scriptPath);
  },
  description: "Default command"
};
class ArcTermCommandHandler {
  constructor(term) {
    __publicField(this, "term");
    __publicField(this, "history", []);
    Log(
      `ArcTerm ${term.referenceId}`,
      `Creating new ArcTermCommandHandler`,
      LogLevel.info
    );
    this.term = term;
  }
  async evaluate(cmd, args, isScript = false, provider) {
    Log(`ArcTerm ${this.term.referenceId}`, `cmd.evaluate: ${cmd}`);
    if (cmd.startsWith("#"))
      return;
    if (!isScript)
      this.history.push(`${cmd} ${args.join(" ")}`.trim());
    const command = this.getCommand(cmd, provider);
    if (isScript && command.keyword == "default")
      return false;
    if (this.term.input && this.term.input.current)
      this.term.input.current.disabled = true;
    const result = await command.exec(cmd, args, this.term);
    if (result == false) {
      return false;
    }
    if (!this.term.std || !this.term.input)
      return true;
    if (this.term.std.verbose && !isScript)
      this.term.std.writeLine("\n");
    this.term.input.unlock();
    return command.keyword != "default";
  }
  getCommand(command, provider) {
    const c2 = command.toLowerCase();
    const commands = provider ? provider : this.term.commands;
    for (let i2 = 0; i2 < commands.length; i2++) {
      const k2 = commands[i2].keyword.toLowerCase();
      if (k2 == c2)
        return commands[i2];
    }
    return Default$1;
  }
}
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const { iterator, toStringTag } = Symbol;
const kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key2;
    for (i2 = 0; i2 < len; i2++) {
      key2 = keys[i2];
      fn.call(null, obj[key2], key2, obj);
    }
  }
}
function findKey(obj, key2) {
  key2 = key2.toLowerCase();
  const keys = Object.keys(obj);
  let i2 = keys.length;
  let _key;
  while (i2-- > 0) {
    _key = keys[i2];
    if (key2 === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key2) => {
    const targetKey = caseless && findKey(result, key2) || key2;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key2) => {
    if (thisArg && isFunction(val)) {
      a2[key2] = bind(val, thisArg);
    } else {
      a2[key2] = val;
    }
  }, { allOwnKeys });
  return a2;
};
const stripBOM = (content2) => {
  if (content2.charCodeAt(0) === 65279) {
    content2 = content2.slice(1);
  }
  return content2;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i2 = thing.length;
  if (!isNumber(i2))
    return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m3, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source2, i2) => {
    if (isObject(source2)) {
      if (stack.indexOf(source2) >= 0) {
        return;
      }
      if (!("toJSON" in source2)) {
        stack[i2] = source2;
        const target = isArray(source2) ? [] : {};
        forEach(source2, (value, key2) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key2] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source2;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source: source2, data }) => {
      if (source2 === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const isIterable = (thing) => thing != null && isFunction(thing[iterator]);
const utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error2, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error2, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error2.message, code, config, request, response);
  axiosError.cause = error2;
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key2) {
  return utils$1.endsWith(key2, "[]") ? key2.slice(0, -2) : key2;
}
function renderKey(path, key2, dots) {
  if (!path)
    return key2;
  return path.concat(key2).map(function each(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source2) {
    return !utils$1.isUndefined(source2[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key2, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils$1.endsWith(key2, "{}")) {
        key2 = metaTokens ? key2 : key2.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key2, "[]")) && (arr = utils$1.toArray(value))) {
        key2 = removeBrackets(key2);
        arr.forEach(function each(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key2], index, dots) : indexes === null ? key2 : key2 + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key2, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$1.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils$1.forEach(value, function each(el, key2) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1.isString(key2) ? key2.trim() : key2,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key2) : [key2]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append2(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  if (utils$1.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key2, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key2, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i2;
  const len = keys.length;
  let key2;
  for (i2 = 0; i2 < len; i2++) {
    key2 = keys[i2];
    obj[key2] = arr[key2];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data);
    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$1.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults$1.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults$1.headers[method] = {};
});
const defaults$2 = defaults$1;
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key2;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i2 = line.indexOf(":");
    key2 = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
      return;
    }
    if (key2 === "set-cookie") {
      if (parsed[key2]) {
        parsed[key2].push(val);
      } else {
        parsed[key2] = [val];
      }
    } else {
      parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header2) {
  return header2 && String(header2).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header2, filter2, isHeaderNameFilter) {
  if (utils$1.isFunction(filter2)) {
    return filter2.call(this, value, header2);
  }
  if (isHeaderNameFilter) {
    value = header2;
  }
  if (!utils$1.isString(value))
    return;
  if (utils$1.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$1.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header2) {
  return header2.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header2) {
  const accessorName = utils$1.toCamelCase(" " + header2);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header2, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header2, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key2 = utils$1.findKey(self2, lHeader);
      if (!key2 || self2[key2] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key2] !== false) {
        self2[key2 || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header2) || header2 instanceof this.constructor) {
      setHeaders(header2, valueOrRewrite);
    } else if (utils$1.isString(header2) && (header2 = header2.trim()) && !isValidHeaderName(header2)) {
      setHeaders(parseHeaders(header2), valueOrRewrite);
    } else if (utils$1.isObject(header2) && utils$1.isIterable(header2)) {
      let obj = {}, dest, key2;
      for (const entry of header2) {
        if (!utils$1.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key2 = entry[0]] = (dest = obj[key2]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header2 != null && setHeader(valueOrRewrite, header2, rewrite);
    }
    return this;
  }
  get(header2, parser) {
    header2 = normalizeHeader(header2);
    if (header2) {
      const key2 = utils$1.findKey(this, header2);
      if (key2) {
        const value = this[key2];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key2);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header2, matcher) {
    header2 = normalizeHeader(header2);
    if (header2) {
      const key2 = utils$1.findKey(this, header2);
      return !!(key2 && this[key2] !== void 0 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
    }
    return false;
  }
  delete(header2, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key2 = utils$1.findKey(self2, _header);
        if (key2 && (!matcher || matchHeaderValue(self2, self2[key2], key2, matcher))) {
          delete self2[key2];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header2)) {
      header2.forEach(deleteHeader);
    } else {
      deleteHeader(header2);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i2 = keys.length;
    let deleted = false;
    while (i2--) {
      const key2 = keys[i2];
      if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
        delete this[key2];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value, header2) => {
      const key2 = utils$1.findKey(headers, header2);
      if (key2) {
        self2[key2] = normalizeValue(value);
        delete self2[header2];
        return;
      }
      const normalized = format2 ? formatHeader(header2) : String(header2).trim();
      if (normalized !== header2) {
        delete self2[header2];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value, header2) => {
      value != null && value !== false && (obj[header2] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header2, value]) => header2 + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header2) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header2) ? header2.forEach(defineAccessor) : defineAccessor(header2);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key2) => {
  let mapped = key2[0].toUpperCase() + key2.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config = this || defaults$2;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$1.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now2 = Date.now()) => {
    timestamp = now2;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now2 = Date.now();
    const passed = now2 - timestamp;
    if (passed >= threshold) {
      invoke(args, now2);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush2 = () => lastArgs && invoke(lastArgs);
  return [throttled, flush2];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
const isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain2, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path) && cookie.push("path=" + path);
      utils$1.isString(domain2) && cookie.push("domain=" + domain2);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source2, prop, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source2)) {
      return utils$1.merge.call({ caseless }, target, source2);
    } else if (utils$1.isPlainObject(source2)) {
      return utils$1.merge({}, source2);
    } else if (utils$1.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(a2, b2, prop, caseless) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(a2, b2, prop, caseless);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2, prop, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2, prop) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), prop, true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const resolveConfig = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth: auth2 } = newConfig;
  newConfig.headers = headers = AxiosHeaders$1.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth2) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth2.username || "") + ":" + (auth2.password ? unescape(encodeURIComponent(auth2.password)) : ""))
    );
  }
  let contentType;
  if (utils$1.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err2) {
        reject(err2);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
        request.setRequestHeader(key2, val);
      });
    }
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol2 = parseProtocol(_config.url);
    if (protocol2 && platform.protocols.indexOf(protocol2) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol2 + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err2 = reason instanceof Error ? reason : this.reason;
        controller.abort(err2 instanceof AxiosError ? err2 : new CanceledError(err2 instanceof Error ? err2.message : err2));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$1.asap(unsubscribe);
    return signal;
  }
};
const composeSignals$1 = composeSignals;
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e2) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err2) {
        _onFinish(err2);
        throw err2;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e2) {
    return false;
  }
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config) => {
      throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$1.isBlob(body)) {
    return body.size;
  }
  if (utils$1.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$1.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush2] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush2);
      }
    }
    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush2] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush2 && flush2();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err2) {
    unsubscribe && unsubscribe();
    if (err2 && err2.name === "TypeError" && /Load failed|fetch/i.test(err2.message)) {
      throw Object.assign(
        new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
        {
          cause: err2.cause || err2
        }
      );
    }
    throw AxiosError.from(err2, err2 && err2.code, config, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i2 = 0; i2 < length; i2++) {
      nameOrAdapter = adapters2[i2];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i2] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$2.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const VERSION = "1.9.0";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i2 = keys.length;
  while (i2-- > 0) {
    const opt = keys[i2];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err2) {
      if (err2 instanceof Error) {
        let dummy2 = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy2) : dummy2 = new Error();
        const stack = dummy2.stack ? dummy2.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err2.stack) {
            err2.stack = stack;
          } else if (stack && !String(err2.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err2.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err2;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0)
      ;
    else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator.assertOptions(config, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise2;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise2 = Promise.resolve(config);
      while (i2 < len) {
        promise2 = promise2.then(chain[i2++], chain[i2++]);
      }
      return promise2;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise2 = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise2 = promise2.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise2;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise2 = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise2.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise2;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err2) => {
      controller.abort(err2);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key2, value]) => {
  HttpStatusCode[value] = key2;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance2 = bind(Axios$1.prototype.request, context);
  utils$1.extend(instance2, Axios$1.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance2, context, null, { allOwnKeys: true });
  instance2.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance2;
}
const axios = createInstance(defaults$2);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
function ttlFetch(url, init2, ms = 3e3) {
  Log("ts/ttlFetch.ts: default", `${url}`);
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      reject(new Error("TIMEOUT"));
    }, ms);
    fetch(url, init2).then((value) => {
      clearTimeout(timer);
      resolve(value);
    }).catch((reason) => {
      clearTimeout(timer);
      reject(reason);
    });
  });
}
const TEST_MODES = [
  [true, 443],
  [false, 3333],
  [true, 80],
  [false, 80],
  [true, 3333]
];
async function testConnection(server, authCode = "", set = true) {
  for (let i2 = 0; i2 < TEST_MODES.length; i2++) {
    const proto = `http${TEST_MODES[i2][0] ? "s" : ""}`;
    const port = TEST_MODES[i2][1];
    const url = `${proto}://${server}:${port}/users/get?ac=${authCode}`;
    Log(
      "api/test.ts: testConnection",
      `Testing ${server} on port ${port} and protocol ${proto}...`,
      LogLevel.info
    );
    try {
      const req = await (await ttlFetch(url, {})).json();
      Log(
        "api/test.ts: testConnection",
        `Got a response from URL ${url}`,
        LogLevel.warn
      );
      const connectReq = await (await ttlFetch(url.replace("users/get", "connect"), {})).json();
      const rev = connectReq.revision || 0;
      if (rev < minArcAPI)
        return false;
      if (set) {
        ConnectedServer.set(`${proto}://${server}:${port}`);
        ServerAuthCode.set(authCode);
      }
      return req && !!req.valid;
    } catch {
      Log(
        "api/test.ts: testConnection",
        `Did not get a valid response from ${url}`,
        LogLevel.error
      );
      continue;
    }
  }
  Log(
    "api/test.ts: testConnection",
    `Can't connect to server ${server}: none of the modes match`,
    CurrentState.key != "fts" ? LogLevel.critical : LogLevel.error
  );
  return false;
}
function setAuthcode(server, code) {
  Log(
    "api/authcode.ts: setAuthcode",
    `Adding authcode to ${server}`,
    LogLevel.info
  );
  let authCodes = localStorage.getItem("arcos-authcodes");
  if (!authCodes)
    authCodes = "{}";
  authCodes = JSON.parse(authCodes);
  authCodes[server] = code;
  localStorage.setItem("arcos-authcodes", JSON.stringify(authCodes));
}
function getAuthcode(server) {
  Log(
    "api/authcode.ts: getAuthcode",
    `Getting authcode for ${server}`,
    LogLevel.info
  );
  let authCodes = localStorage.getItem("arcos-authcodes");
  if (!authCodes)
    authCodes = "{}";
  authCodes = JSON.parse(authCodes);
  return authCodes[server];
}
function toBase64(input) {
  try {
    return btoa(input);
  } catch {
    Log(
      `ts/base64.ts: toBase64`,
      `Couldn't convert ${input.length} bytes to Base64.`,
      LogLevel.error
    );
    return input;
  }
}
function fromBase64(input) {
  try {
    return atob(input);
  } catch {
    Log(
      `ts/base64.ts: toBase64`,
      `Couldn't convert ${input.length} bytes to string.`,
      LogLevel.error
    );
    return input;
  }
}
async function partialFileToComplete(file) {
  Log(
    "fs/convert.ts: partialFileToComplete",
    `Converting ${file.scopedPath} to ArcFile`,
    LogLevel.info
  );
  const data = {
    name: file.filename,
    path: file.scopedPath,
    mime: file.mime,
    data: await readFile(file.scopedPath)
  };
  return data;
}
async function fileToArcFile(file, target, mime) {
  Log(
    "fs/convert.ts: fileToArcFile",
    `Converting ${file.name} to ArcFile`,
    LogLevel.info
  );
  const data = {
    name: file.name,
    path: target,
    data: await file.arrayBuffer(),
    mime: mime || "ArcOS Uploadable"
  };
  return data;
}
async function deleteItem(path) {
  Log(
    "fs/file.ts: deleteItem",
    `Deleting item "${path}" from ArcFS`,
    LogLevel.info
  );
  const server = get_store_value(ConnectedServer);
  if (!server)
    return false;
  const req = await apiCall(
    server,
    "fs/rm",
    { path: toBase64(path) },
    get_store_value(UserToken),
    null,
    null,
    true
  );
  return !(req.valid == false);
}
async function getDirectory(path = "./") {
  Log(
    "fs/directory.ts: getDirectory",
    `Requesting directory contents of "${path}" from ArcAPI`,
    LogLevel.info
  );
  const server = get_store_value(ConnectedServer);
  if (!server)
    return false;
  const req = await apiCall(
    server,
    "fs/dir/get",
    { path: path ? toBase64(path) : null },
    get_store_value(UserToken)
  );
  if (!req || !req.valid)
    return false;
  return req.data;
}
function sortDirectories(dir) {
  if (!dir)
    return [];
  return dir.sort(
    (a2, b2) => a2.name.toLowerCase() > b2.name.toLowerCase() ? 1 : -1
  );
}
async function createDirectory(path) {
  Log("fs/directory.ts: createDirectory", `Creating ${path}`);
  const server = get_store_value(ConnectedServer);
  if (!server)
    return false;
  const req = await apiCall(
    server,
    "fs/dir/create",
    { path: toBase64(path) },
    get_store_value(UserToken)
  );
  return req.valid;
}
const openwith = "";
const loadThemeIcon = "" + new URL("loadtheme-61b4520f.svg", import.meta.url).href;
const openInNewIcon = "" + new URL("openinnew-33fae09f.svg", import.meta.url).href;
const pdfOpenerIcon = "" + new URL("pdfopener-7ec41537.svg", import.meta.url).href;
const UpdateIcon = "" + new URL("update-e4e652e1.svg", import.meta.url).href;
const values = [
  "anim",
  "noGlass",
  "sharp",
  "theme",
  "wallpaper",
  "accent",
  "docked",
  "taskbarCentered",
  "taskbarLabels",
  "taskbarPosition",
  "taskbarColored",
  "smallStart",
  "titleButtons",
  "titlebarLarge",
  "titlebarLeft"
];
function loadTheme(context) {
  UserData$2.update((udata) => {
    udata.sh.anim = context.anim;
    udata.sh.noGlass = context.noGlass;
    udata.sh.desktop.sharp = context.sharp;
    udata.sh.desktop.theme = context.theme;
    udata.sh.desktop.wallpaper = context.wallpaper;
    udata.sh.desktop.accent = context.accent;
    udata.sh.taskbar.docked = context.docked;
    udata.sh.taskbar.centered = context.taskbarCentered;
    udata.sh.taskbar.labels = context.taskbarLabels;
    udata.sh.taskbar.pos = context.taskbarPosition;
    udata.sh.start.small = context.smallStart;
    udata.sh.window.buttons = context.titleButtons;
    udata.sh.window.bigtb = context.titlebarLarge;
    udata.sh.window.lefttb = context.titlebarLeft;
    udata.sh.taskbar.colored = context.taskbarColored;
    udata.sh.window.centertb = !!context.titlebarCentered;
    udata.sh.taskbar.isLauncher = !!context.isLauncher;
    if (context.loginBackground)
      udata.acc.loginBackground = context.loginBackground;
    return udata;
  });
}
function saveCurrentTheme(name) {
  const id = `${Math.floor(Math.random() * 1e6)}`;
  UserData$2.update((udata) => {
    const context = {
      version: "1.0.0",
      name,
      author: get_store_value(UserName),
      anim: udata.sh.anim,
      noGlass: udata.sh.noGlass,
      sharp: udata.sh.desktop.sharp,
      theme: udata.sh.desktop.theme,
      wallpaper: udata.sh.desktop.wallpaper,
      loginBackground: udata.acc.loginBackground || "img15",
      accent: udata.sh.desktop.accent,
      docked: udata.sh.taskbar.docked,
      taskbarCentered: udata.sh.taskbar.centered,
      taskbarLabels: udata.sh.taskbar.labels,
      taskbarPosition: udata.sh.taskbar.pos,
      smallStart: udata.sh.start.small,
      titleButtons: udata.sh.window.buttons,
      titlebarLarge: udata.sh.window.bigtb,
      titlebarLeft: udata.sh.window.lefttb,
      taskbarColored: udata.sh.taskbar.colored,
      titlebarCentered: udata.sh.taskbar.centered,
      isLauncher: udata.sh.taskbar.isLauncher
    };
    if (!udata.sh.userThemes)
      udata.sh.userThemes = {};
    udata.sh.userThemes[id] = context;
    return udata;
  });
}
function deleteCustomTheme(id) {
  UserData$2.update((udata) => {
    if (!udata.sh.userThemes || !udata.sh.userThemes[id])
      return udata;
    delete udata.sh.userThemes[id];
    return udata;
  });
  return true;
}
function verifyTheme(json) {
  const keys = Object.keys(json);
  for (let i2 = 0; i2 < values.length; i2++) {
    if (!keys.includes(values[i2]))
      return false;
  }
  return true;
}
function arrayToText(buffer) {
  return new TextDecoder().decode(new Uint8Array(buffer));
}
function arrayToBlob(buffer, type = "text/plain") {
  return new Blob([new Uint8Array(buffer)], {
    type
  });
}
const FileLoaders = {
  pdfOpener: {
    name: "Open In New Tab",
    description: "Open a PDF file in a new browser tab",
    icon: pdfOpenerIcon,
    loader: (file) => {
      const f2 = arrayToBlob(file.data, "application/pdf");
      window.open(URL.createObjectURL(f2), "_blank");
    },
    extensions: [".pdf"]
  },
  experiments: {
    name: "Experiments",
    description: "Spooky spooky experiments",
    extensions: [".experiments"],
    icon: UpdateIcon,
    loader: () => {
      openWindow("ExperimentsApp");
    }
  },
  loadTheme: {
    name: "Load theme file",
    description: "Apply theme file to ArcOS",
    loader: (file) => {
      const str = arrayToText(file.data);
      let json;
      try {
        json = JSON.parse(str);
      } catch {
        json = false;
      }
      if (!json || !verifyTheme(json))
        return errorMessage(
          "Unable to load theme",
          "The theme file is invalid, or it could not be parsed. Please make sure you are trying to load a theme, and then try again.",
          loadThemeIcon,
          null,
          { caption: "Okay", action() {
          }, suggested: true }
        );
      loadTheme(json);
    },
    icon: loadThemeIcon,
    extensions: [".arctheme"]
  },
  editFile: {
    name: "Edit config file",
    description: "Open file in Text Editor",
    icon: AppPokerIcon,
    loader(file) {
      openWith("TextEditor", file, true);
    },
    extensions: [".conf"]
  },
  openInNew: {
    name: "Download",
    description: "Open file in a new tab to download it",
    loader: (file) => {
      if (!file)
        return;
      const f2 = arrayToBlob(file.data, file.mime.split(";")[0]);
      window.open(URL.createObjectURL(f2), "_blank");
    },
    icon: openInNewIcon,
    extensions: []
  }
};
function create_fragment$5g(ctx) {
  let button;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let div3;
  let div1;
  let t1_value = (
    /*loader*/
    ctx[1].name + ""
  );
  let t1;
  let t2;
  let div2;
  let t3_value = (
    /*loader*/
    ctx[1].description + ""
  );
  let t3;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      t3 = text(t3_value);
      if (!src_url_equal(img.src, img_src_value = /*loader*/
      ctx[1].icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*loader*/
      ctx[1].name);
      attr(div0, "class", "icon");
      attr(div1, "class", "name");
      attr(div2, "class", "description");
      attr(button, "class", "option loader");
      toggle_class(
        button,
        "selected",
        /*selected*/
        ctx[0] == /*loader*/
        ctx[1].name
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div0);
      append(div0, img);
      append(button, t0);
      append(button, div3);
      append(div3, div1);
      append(div1, t1);
      append(div3, t2);
      append(div3, div2);
      append(div2, t3);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*select*/
            ctx[2]
          ),
          listen(
            button,
            "dblclick",
            /*openThis*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*loader*/
      2 && !src_url_equal(img.src, img_src_value = /*loader*/
      ctx2[1].icon)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*loader*/
      2 && img_alt_value !== (img_alt_value = /*loader*/
      ctx2[1].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*loader*/
      2 && t1_value !== (t1_value = /*loader*/
      ctx2[1].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*loader*/
      2 && t3_value !== (t3_value = /*loader*/
      ctx2[1].description + ""))
        set_data(t3, t3_value);
      if (dirty & /*selected, loader*/
      3) {
        toggle_class(
          button,
          "selected",
          /*selected*/
          ctx2[0] == /*loader*/
          ctx2[1].name
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4W($$self, $$props, $$invalidate) {
  let $OpenWithFile;
  component_subscribe($$self, OpenWithFile, ($$value) => $$invalidate(6, $OpenWithFile = $$value));
  let { loader } = $$props;
  let { selected = "" } = $$props;
  let { loaderOptions } = $$props;
  let { options } = $$props;
  function select() {
    $$invalidate(0, selected = loader.name);
  }
  async function openThis() {
    loader.loader($OpenWithFile);
    await sleep(100);
    closeWindow("OpenWithApp");
    $$invalidate(4, loaderOptions = []);
    $$invalidate(5, options = []);
  }
  $$self.$$set = ($$props2) => {
    if ("loader" in $$props2)
      $$invalidate(1, loader = $$props2.loader);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("loaderOptions" in $$props2)
      $$invalidate(4, loaderOptions = $$props2.loaderOptions);
    if ("options" in $$props2)
      $$invalidate(5, options = $$props2.options);
  };
  return [selected, loader, select, openThis, loaderOptions, options];
}
class LoaderOption extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4W, create_fragment$5g, safe_not_equal, {
      loader: 1,
      selected: 0,
      loaderOptions: 4,
      options: 5
    });
  }
}
function create_fragment$5f(ctx) {
  let button;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let div3;
  let div1;
  let t1_value = (
    /*app*/
    ctx[1].info.name + ""
  );
  let t1;
  let t2;
  let div2;
  let t3_value = (
    /*app*/
    ctx[1].info.description + ""
  );
  let t3;
  let t4;
  let div4;
  let t5_value = (
    /*app*/
    ctx[1].id + ""
  );
  let t5;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      t3 = text(t3_value);
      t4 = space();
      div4 = element("div");
      t5 = text(t5_value);
      if (!src_url_equal(img.src, img_src_value = /*app*/
      ctx[1].info.icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*app*/
      ctx[1].info.name);
      attr(div0, "class", "icon");
      attr(div1, "class", "name");
      attr(div2, "class", "description");
      attr(div4, "class", "id");
      attr(button, "class", "option");
      toggle_class(
        button,
        "selected",
        /*selected*/
        ctx[0] == /*app*/
        ctx[1].id
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div0);
      append(div0, img);
      append(button, t0);
      append(button, div3);
      append(div3, div1);
      append(div1, t1);
      append(div3, t2);
      append(div3, div2);
      append(div2, t3);
      append(button, t4);
      append(button, div4);
      append(div4, t5);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*select*/
            ctx[2]
          ),
          listen(
            button,
            "dblclick",
            /*openThis*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*app*/
      2 && !src_url_equal(img.src, img_src_value = /*app*/
      ctx2[1].info.icon)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*app*/
      2 && img_alt_value !== (img_alt_value = /*app*/
      ctx2[1].info.name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*app*/
      2 && t1_value !== (t1_value = /*app*/
      ctx2[1].info.name + ""))
        set_data(t1, t1_value);
      if (dirty & /*app*/
      2 && t3_value !== (t3_value = /*app*/
      ctx2[1].info.description + ""))
        set_data(t3, t3_value);
      if (dirty & /*app*/
      2 && t5_value !== (t5_value = /*app*/
      ctx2[1].id + ""))
        set_data(t5, t5_value);
      if (dirty & /*selected, app*/
      3) {
        toggle_class(
          button,
          "selected",
          /*selected*/
          ctx2[0] == /*app*/
          ctx2[1].id
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4V($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { file } = $$props;
  let { selected = "" } = $$props;
  let { loaderOptions } = $$props;
  let { options } = $$props;
  function select() {
    $$invalidate(0, selected = app.id);
  }
  function openThis() {
    openWith(app.id, file, file.anymime);
    setTimeout(
      () => {
        OpenWithFile.set(null);
      },
      1e3
    );
    closeWindow("OpenWithApp");
    $$invalidate(4, loaderOptions = []);
    $$invalidate(5, options = []);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
    if ("file" in $$props2)
      $$invalidate(6, file = $$props2.file);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("loaderOptions" in $$props2)
      $$invalidate(4, loaderOptions = $$props2.loaderOptions);
    if ("options" in $$props2)
      $$invalidate(5, options = $$props2.options);
  };
  return [selected, app, select, openThis, loaderOptions, options, file];
}
let Option$1 = class Option extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4V, create_fragment$5f, safe_not_equal, {
      app: 1,
      file: 6,
      selected: 0,
      loaderOptions: 4,
      options: 5
    });
  }
};
function get_each_context$10(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list2[i2];
  return child_ctx;
}
function get_each_context_1$h(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list2[i2];
  return child_ctx;
}
function create_if_block$1Y(ctx) {
  let div2;
  let p0;
  let t0;
  let t1;
  let t2;
  let div0;
  let p1;
  let t4;
  let t5;
  let t6;
  let p2;
  let t8;
  let t9;
  let t10;
  let div1;
  let button0;
  let t11;
  let button0_disabled_value;
  let t12;
  let button1;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like(
    /*options*/
    ctx[0]
  );
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1$h(get_each_context_1$h(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  let if_block0 = !/*options*/
  ctx[0].length && create_if_block_2$e();
  let each_value = ensure_array_like(
    /*loaderOptions*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$10(get_each_context$10(ctx, each_value, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block1 = !/*loaderOptions*/
  ctx[1].length && create_if_block_1$D();
  return {
    c() {
      div2 = element("div");
      p0 = element("p");
      t0 = text("Select an item to open ");
      t1 = text(
        /*filename*/
        ctx[3]
      );
      t2 = space();
      div0 = element("div");
      p1 = element("p");
      p1.textContent = "Apps";
      t4 = space();
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t5 = space();
      if (if_block0)
        if_block0.c();
      t6 = space();
      p2 = element("p");
      p2.textContent = "Handlers";
      t8 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t9 = space();
      if (if_block1)
        if_block1.c();
      t10 = space();
      div1 = element("div");
      button0 = element("button");
      t11 = text("Open");
      t12 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(p0, "class", "title");
      attr(p1, "class", "category");
      attr(p2, "class", "category");
      attr(div0, "class", "options");
      button0.disabled = button0_disabled_value = !/*selected*/
      ctx[2];
      attr(div1, "class", "actions");
      attr(div2, "class", "content");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, p0);
      append(p0, t0);
      append(p0, t1);
      append(div2, t2);
      append(div2, div0);
      append(div0, p1);
      append(div0, t4);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(div0, null);
        }
      }
      append(div0, t5);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t6);
      append(div0, p2);
      append(div0, t8);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div0, t9);
      if (if_block1)
        if_block1.m(div0, null);
      append(div2, t10);
      append(div2, div1);
      append(div1, button0);
      append(button0, t11);
      append(div1, t12);
      append(div1, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*openThis*/
            ctx[5]
          ),
          listen(
            button1,
            "click",
            /*closeThis*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*filename*/
      8)
        set_data(
          t1,
          /*filename*/
          ctx2[3]
        );
      if (dirty & /*$OpenWithFile, options, loaderOptions, selected*/
      23) {
        each_value_1 = ensure_array_like(
          /*options*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$h(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_1$h(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(div0, t5);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!/*options*/
      ctx2[0].length) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_2$e();
          if_block0.c();
          if_block0.m(div0, t6);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*loaderOptions, $OpenWithFile, options, selected*/
      23) {
        each_value = ensure_array_like(
          /*loaderOptions*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$10(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$10(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, t9);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
      if (!/*loaderOptions*/
      ctx2[1].length) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block_1$D();
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*selected*/
      4 && button0_disabled_value !== (button0_disabled_value = !/*selected*/
      ctx2[2])) {
        button0.disabled = button0_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks_1, detaching);
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block_1$h(ctx) {
  let option_1;
  let updating_loaderOptions;
  let updating_options;
  let updating_selected;
  let current;
  function option_1_loaderOptions_binding(value) {
    ctx[7](value);
  }
  function option_1_options_binding(value) {
    ctx[8](value);
  }
  function option_1_selected_binding(value) {
    ctx[9](value);
  }
  let option_1_props = {
    file: (
      /*$OpenWithFile*/
      ctx[4]
    ),
    app: (
      /*option*/
      ctx[16]
    )
  };
  if (
    /*loaderOptions*/
    ctx[1] !== void 0
  ) {
    option_1_props.loaderOptions = /*loaderOptions*/
    ctx[1];
  }
  if (
    /*options*/
    ctx[0] !== void 0
  ) {
    option_1_props.options = /*options*/
    ctx[0];
  }
  if (
    /*selected*/
    ctx[2] !== void 0
  ) {
    option_1_props.selected = /*selected*/
    ctx[2];
  }
  option_1 = new Option$1({ props: option_1_props });
  binding_callbacks.push(() => bind$1(option_1, "loaderOptions", option_1_loaderOptions_binding));
  binding_callbacks.push(() => bind$1(option_1, "options", option_1_options_binding));
  binding_callbacks.push(() => bind$1(option_1, "selected", option_1_selected_binding));
  return {
    c() {
      create_component(option_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(option_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const option_1_changes = {};
      if (dirty & /*$OpenWithFile*/
      16)
        option_1_changes.file = /*$OpenWithFile*/
        ctx2[4];
      if (dirty & /*options*/
      1)
        option_1_changes.app = /*option*/
        ctx2[16];
      if (!updating_loaderOptions && dirty & /*loaderOptions*/
      2) {
        updating_loaderOptions = true;
        option_1_changes.loaderOptions = /*loaderOptions*/
        ctx2[1];
        add_flush_callback(() => updating_loaderOptions = false);
      }
      if (!updating_options && dirty & /*options*/
      1) {
        updating_options = true;
        option_1_changes.options = /*options*/
        ctx2[0];
        add_flush_callback(() => updating_options = false);
      }
      if (!updating_selected && dirty & /*selected*/
      4) {
        updating_selected = true;
        option_1_changes.selected = /*selected*/
        ctx2[2];
        add_flush_callback(() => updating_selected = false);
      }
      option_1.$set(option_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(option_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(option_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(option_1, detaching);
    }
  };
}
function create_if_block_2$e(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "No apps found";
      attr(p2, "class", "noitems");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_each_block$10(ctx) {
  let loaderoption;
  let updating_loaderOptions;
  let updating_options;
  let updating_selected;
  let current;
  function loaderoption_loaderOptions_binding(value) {
    ctx[10](value);
  }
  function loaderoption_options_binding(value) {
    ctx[11](value);
  }
  function loaderoption_selected_binding(value) {
    ctx[12](value);
  }
  let loaderoption_props = {
    loader: (
      /*loader*/
      ctx[13]
    ),
    file: (
      /*$OpenWithFile*/
      ctx[4]
    )
  };
  if (
    /*loaderOptions*/
    ctx[1] !== void 0
  ) {
    loaderoption_props.loaderOptions = /*loaderOptions*/
    ctx[1];
  }
  if (
    /*options*/
    ctx[0] !== void 0
  ) {
    loaderoption_props.options = /*options*/
    ctx[0];
  }
  if (
    /*selected*/
    ctx[2] !== void 0
  ) {
    loaderoption_props.selected = /*selected*/
    ctx[2];
  }
  loaderoption = new LoaderOption({ props: loaderoption_props });
  binding_callbacks.push(() => bind$1(loaderoption, "loaderOptions", loaderoption_loaderOptions_binding));
  binding_callbacks.push(() => bind$1(loaderoption, "options", loaderoption_options_binding));
  binding_callbacks.push(() => bind$1(loaderoption, "selected", loaderoption_selected_binding));
  return {
    c() {
      create_component(loaderoption.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loaderoption, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const loaderoption_changes = {};
      if (dirty & /*loaderOptions*/
      2)
        loaderoption_changes.loader = /*loader*/
        ctx2[13];
      if (dirty & /*$OpenWithFile*/
      16)
        loaderoption_changes.file = /*$OpenWithFile*/
        ctx2[4];
      if (!updating_loaderOptions && dirty & /*loaderOptions*/
      2) {
        updating_loaderOptions = true;
        loaderoption_changes.loaderOptions = /*loaderOptions*/
        ctx2[1];
        add_flush_callback(() => updating_loaderOptions = false);
      }
      if (!updating_options && dirty & /*options*/
      1) {
        updating_options = true;
        loaderoption_changes.options = /*options*/
        ctx2[0];
        add_flush_callback(() => updating_options = false);
      }
      if (!updating_selected && dirty & /*selected*/
      4) {
        updating_selected = true;
        loaderoption_changes.selected = /*selected*/
        ctx2[2];
        add_flush_callback(() => updating_selected = false);
      }
      loaderoption.$set(loaderoption_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(loaderoption.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loaderoption.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loaderoption, detaching);
    }
  };
}
function create_if_block_1$D(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "No handlers found";
      attr(p2, "class", "noitems");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_fragment$5e(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$OpenWithFile*/
    ctx[4] && create_if_block$1Y(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$OpenWithFile*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$OpenWithFile*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1Y(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$4U($$self, $$props, $$invalidate) {
  let $OpenWithFile;
  component_subscribe($$self, OpenWithFile, ($$value) => $$invalidate(4, $OpenWithFile = $$value));
  let options = [];
  let loaderOptions = [];
  let selected = "";
  let filename = "";
  OpenWithFile.subscribe((v2) => {
    if (!v2)
      return $$invalidate(3, filename = "file");
    $$invalidate(3, filename = v2.name);
    $$invalidate(0, options = []);
    $$invalidate(1, loaderOptions = []);
    let apps2 = [];
    if (v2.anymime)
      apps2 = getAllFileHandlers();
    else
      apps2 = findAppToOpen(v2.mime);
    for (let i2 = 0; i2 < apps2.length; i2++) {
      options.push(getWindow(apps2[i2]));
    }
    $$invalidate(2, selected = "");
    const loaders = Object.entries(FileLoaders);
    for (let i2 = 0; i2 < loaders.length; i2++) {
      const loader = loaders[i2];
      const data = loader[1];
      for (let j2 = 0; j2 < data.extensions.length; j2++) {
        if (filename.endsWith(data.extensions[j2]))
          loaderOptions.push(data);
      }
      if (!data.extensions.length)
        loaderOptions.push(data);
    }
  });
  function openThis() {
    const window2 = getWindow(selected);
    if (window2) {
      openWith(window2.id, $OpenWithFile, $OpenWithFile.anymime);
    } else {
      for (let i2 = 0; i2 < loaderOptions.length; i2++) {
        if (loaderOptions[i2].name == selected)
          loaderOptions[i2].loader($OpenWithFile);
        set_store_value(OpenWithFile, $OpenWithFile = null, $OpenWithFile);
      }
    }
    setTimeout(
      () => {
        OpenWithFile.set(null);
      },
      1e3
    );
    closeThis();
  }
  function closeThis() {
    isFullscreenWindow.set(false);
    closeWindow("OpenWithApp");
  }
  function option_1_loaderOptions_binding(value) {
    loaderOptions = value;
    $$invalidate(1, loaderOptions);
  }
  function option_1_options_binding(value) {
    options = value;
    $$invalidate(0, options);
  }
  function option_1_selected_binding(value) {
    selected = value;
    $$invalidate(2, selected);
  }
  function loaderoption_loaderOptions_binding(value) {
    loaderOptions = value;
    $$invalidate(1, loaderOptions);
  }
  function loaderoption_options_binding(value) {
    options = value;
    $$invalidate(0, options);
  }
  function loaderoption_selected_binding(value) {
    selected = value;
    $$invalidate(2, selected);
  }
  return [
    options,
    loaderOptions,
    selected,
    filename,
    $OpenWithFile,
    openThis,
    closeThis,
    option_1_loaderOptions_binding,
    option_1_options_binding,
    option_1_selected_binding,
    loaderoption_loaderOptions_binding,
    loaderoption_options_binding,
    loaderoption_selected_binding
  ];
}
class OpenWith extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4U, create_fragment$5e, safe_not_equal, {});
  }
}
const AccountIcon = "" + new URL("account-a7a14557.svg", import.meta.url).href;
const AppsIcon = "" + new URL("apps-5c65dab6.svg", import.meta.url).href;
const searchIcon = "" + new URL("arcfind-d60c3db2.svg", import.meta.url).href;
const ConnectIcon = "" + new URL("connect-7fe4df73.svg", import.meta.url).href;
const DesktopIcon$1 = "" + new URL("desktop-2a5e3c36.svg", import.meta.url).href;
const FileIcon = "" + new URL("file-0d0c64f1.svg", import.meta.url).href;
const FireFoxIcon = "" + new URL("firefox-ac949acd.png", import.meta.url).href;
const FlagIcon = "" + new URL("flag-80e46659.svg", import.meta.url).href;
const FolderIcon = "" + new URL("folder-f520676e.svg", import.meta.url).href;
const HomeIcon = "" + new URL("home-39ab8c91.svg", import.meta.url).href;
const MemoryIcon = "" + new URL("memory-802c404d.svg", import.meta.url).href;
const mode = "" + new URL("mode-b35b0f1d.svg", import.meta.url).href;
const PasswordIcon = "" + new URL("password-d04179f1.svg", import.meta.url).href;
const PersonalizationIcon = "" + new URL("loadtheme-61b4520f.svg", import.meta.url).href;
const SaveIcon = "" + new URL("save-13107e70.svg", import.meta.url).href;
const SecureIcon = "" + new URL("secure-c775bee3.svg", import.meta.url).href;
const SpinnerIcon = "" + new URL("spinner-a610f1d3.svg", import.meta.url).href;
const startmenu = "" + new URL("startmenu-40eb1351.svg", import.meta.url).href;
const systemIcon = "" + new URL("systemIcon-393c5507.svg", import.meta.url).href;
const TaskBarIcon = "" + new URL("taskbar-24d42588.svg", import.meta.url).href;
const ThemesIcon = "" + new URL("themes-d865bc0e.svg", import.meta.url).href;
const TrashIcon = "" + new URL("trash-675017c3.svg", import.meta.url).href;
const UploadIcon = "" + new URL("upload-62f3bdf6.svg", import.meta.url).href;
const WaveIcon = "" + new URL("wave-1b0d0ba8.svg", import.meta.url).href;
const WindowSettingsIcon = "" + new URL("windowsettings-2ef194f6.svg", import.meta.url).href;
const generals = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AccountIcon,
  AppsIcon,
  ArcFindIcon: searchIcon,
  ConnectIcon,
  DesktopIcon: DesktopIcon$1,
  FileIcon,
  FireFoxIcon,
  FlagIcon,
  FolderIcon,
  HomeIcon,
  MemoryIcon,
  ModeIcon: mode,
  PasswordIcon,
  PersonalizationIcon,
  SaveIcon,
  SecureIcon,
  SpinnerIcon,
  StartMenuIcon: startmenu,
  SystemIcon: systemIcon,
  TaskBarIcon,
  ThemesIcon,
  TrashIcon,
  UpdateIcon,
  UploadIcon,
  WaveIcon,
  WindowSettingsIcon
}, Symbol.toStringTag, { value: "Module" }));
const OpenWithApp = {
  info: {
    name: "Open With",
    description: "Open a file with an app",
    builtin: true,
    version: "1.0.1",
    author: "Izaak Kuipers",
    hidden: true,
    icon: AppsIcon,
    appGroup: "coreApps"
  },
  size: { w: 450, h: 550 },
  pos: { x: 0, y: 0 },
  minSize: { w: 450, h: 550 },
  maxSize: { w: 450, h: 550 },
  controls: { min: false, max: false, cls: false },
  state: {
    headless: true,
    resizable: false,
    windowState: { min: false, max: false, fll: true }
  },
  content: OpenWith,
  glass: true,
  events: {
    close() {
      OpenWithFile.set(null);
    },
    async open(app) {
      await sleep(10);
      if (!get_store_value(OpenWithFile))
        closeWindow(app.id);
    }
  }
};
const OpenWithFile = writable(null);
function isLoaded(id) {
  const ws = get_store_value(WindowStore);
  return !!ws.filter((a2) => a2 && a2.id == id).length;
}
function isOpened(id) {
  const window2 = getWindow(id);
  if (!window2)
    return false;
  return window2.opened;
}
function isMinimized(id) {
  const ws = get_store_value(WindowStore);
  return !!ws.filter((a2) => a2 && a2.id == id && a2.state.windowState.min).length;
}
function isDisabled(id) {
  const ws = get_store_value(WindowStore);
  return !!ws.filter((a2) => a2 && a2.id == id && a2.disabled).length;
}
function isPopulatable(app) {
  if (get_store_value(UserData$2).sh.showHiddenApps && !app.disabled && !app.core && app.id != "ExperimentsApp")
    return true;
  return !app.disabled && !app.info.hidden && !app.info.custom;
}
async function checkFileRequirement(appId) {
  const app = getWindow(appId);
  if (!app.info.requiresFile)
    return;
  await sleep(100);
  if (app.openedFile)
    return;
  makeNotification({
    icon: "warning",
    title: "Could not open app",
    message: `${app.info.name} requires a file to be able to open, it cannot be opened this way.`,
    buttons: []
  });
  closeWindow(app.id);
}
const AppInfo$3 = "";
function hotSwapAppIcon(icon2, appId) {
  Log(
    "icon.ts: hotSwapAppIcon",
    `Changing app icon for ${appId} to ${icon2}`,
    LogLevel.info
  );
  WindowStore.update((ws) => {
    for (let i2 = 0; i2 < ws.length; i2++) {
      if (ws[i2].id == appId) {
        if (!Originals$1[appId])
          Originals$1[appId] = `${getAppIcon(ws[i2])}`;
        ws[i2].info.icon = icon2;
      }
    }
    return ws;
  });
}
function getOriginalIcon(appId) {
  return Originals$1[appId];
}
function getAppIcon(app) {
  if (!app.info.builtin)
    return UnknownIcon;
  return app.info.icon;
}
const Originals$1 = {};
function getAppPreference(id, key2) {
  const udata = get_store_value(UserData$2);
  if (!udata.appdata || !udata.appdata[id])
    return void 0;
  return udata.appdata[id][key2];
}
function setAppPreference(id, key2, value) {
  Log(
    "applogic/pref.ts: setAppPreference",
    `Setting ${key2} in ${id} to type ${typeof value}...`
  );
  UserData$2.update((udata) => {
    if (!udata.appdata)
      return udata;
    if (!udata.appdata[id])
      udata.appdata[id] = {};
    udata.appdata[id][key2] = value;
    return udata;
  });
  return true;
}
const dialogError = "" + new URL("Error-35b4aff9.wav", import.meta.url).href;
const dialogWarning = "" + new URL("Warning-ab00a839.wav", import.meta.url).href;
const dialogInfo = "" + new URL("Info-ccd624fe.wav", import.meta.url).href;
const notification = "" + new URL("Notification-2d6e0e95.wav", import.meta.url).href;
const systemLogon = "" + new URL("logon-aa2b9d46.wav", import.meta.url).href;
const systemLogoff = "" + new URL("logoff-62e8a4e4.wav", import.meta.url).href;
const click = "" + new URL("click-loud-74bfb009.wav", import.meta.url).href;
const mwomp = "" + new URL("mwomp-71d2eb2a.mp3", import.meta.url).href;
const ArcSounds = {
  "arcos.dialog.error": dialogError,
  "arcos.dialog.warning": dialogWarning,
  "arcos.dialog.info": dialogInfo,
  "arcos.notification": notification,
  "arcos.system.logon": systemLogon,
  "arcos.system.logoff": systemLogoff,
  "arcos.click": click,
  "arcos.mwomp": mwomp
};
class SoundBus {
  constructor(store) {
    __publicField(this, "store", {});
    __publicField(this, "_bus", {});
    if (!store) {
      Log(
        "SoundBus",
        `Can't create SoundBus without valid store.`,
        LogLevel.error
      );
      return;
    }
    this.store = store;
  }
  playSound(id) {
    if (!this.store[id])
      return false;
    Log("SoundBus.playSound", `Playing sound ${id} from store`);
    const element2 = document.createElement("audio");
    element2.muted = true;
    element2.src = this.store[id];
    element2.volume = 1;
    try {
      element2.play();
      setTimeout(() => {
        element2.muted = false;
      }, 10);
    } catch (e2) {
      Log(
        "SoundBus.playSound",
        `Can't play ${id}: User didn't interact with the page first`,
        LogLevel.error
      );
      return false;
    }
    if (!this._bus[id])
      this._bus[id] = [];
    this._bus[id].push(element2);
    setTimeout(() => {
      element2.onended = () => delete this._bus[id];
    }, 10);
    return true;
  }
  stopSound(id) {
    Log("SoundBus.stopSound", `Stopping ${id}`);
    if (!this._bus[id])
      return false;
    const bus = this._bus[id];
    for (let i2 = 0; i2 < bus.length; i2++) {
      bus[i2].src = null;
      bus[i2].currentTime = -1;
      bus[i2].pause();
    }
    return true;
  }
  getStore() {
    return Object.entries(this.store);
  }
  loadExternal(source2, play2 = false) {
    const uuid = `${Math.floor(Math.random() * 1e9)}`;
    this.store[uuid] = source2;
    if (play2)
      this.playSound(uuid);
  }
}
const ArcSoundBus = new SoundBus(ArcSounds);
function createOverlayableError(error2, targetId) {
  Log(
    "errorlogic/overlay.ts",
    `Creating error "${error2.title}" for parent ${targetId}`,
    LogLevel.info
  );
  const ws = get_store_value(WindowStore);
  for (let i2 = 0; i2 < ws.length; i2++) {
    const window2 = ws[i2];
    if (window2.id != targetId)
      continue;
    if (!window2.errorOverlays)
      window2.errorOverlays = [];
    window2.errorOverlays.push({
      ...error2,
      id: `${Math.floor(Math.random() * 1e9)}`
    });
    WindowStore.set(ws);
    ArcSoundBus.playSound("arcos.dialog.info");
    return true;
  }
  return false;
}
function destroyOverlayableError(errorId, ownerId) {
  const ws = get_store_value(WindowStore);
  for (let i2 = 0; i2 < ws.length; i2++) {
    const window2 = ws[i2];
    if (window2.id != ownerId || !window2.errorOverlays)
      continue;
    const errors = window2.errorOverlays;
    for (let j2 = 0; j2 < errors.length; j2++) {
      if (errors[j2].id != errorId)
        continue;
      errors.splice(j2, 1);
      WindowStore.set(ws);
      return true;
    }
  }
  return false;
}
function create_if_block$1X(ctx) {
  let div3;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let div1;
  let p0;
  let t1_value = (
    /*data*/
    ctx[0].info.name + ""
  );
  let t1;
  let t2;
  let p1;
  let t3_value = (
    /*data*/
    ctx[0].info.description + ""
  );
  let t3;
  let t4;
  let t5;
  let div2;
  let input;
  let input_disabled_value;
  let t6;
  let div26;
  let div6;
  let div4;
  let t8;
  let div5;
  let t9_value = (
    /*data*/
    (ctx[0].size.w || d$2) + ""
  );
  let t9;
  let t10;
  let t11_value = (
    /*data*/
    (ctx[0].size.h || d$2) + ""
  );
  let t11;
  let t12;
  let div9;
  let div7;
  let t14;
  let div8;
  let t15_value = (
    /*data*/
    (ctx[0].minSize.w || d$2) + ""
  );
  let t15;
  let t16;
  let t17_value = (
    /*data*/
    (ctx[0].minSize.h || d$2) + ""
  );
  let t17;
  let t18;
  let div12;
  let div10;
  let t20;
  let div11;
  let t21_value = (
    /*data*/
    (ctx[0].maxSize.w || d$2) + ""
  );
  let t21;
  let t22;
  let t23_value = (
    /*data*/
    (ctx[0].maxSize.h || d$2) + ""
  );
  let t23;
  let t24;
  let hr;
  let t25;
  let div15;
  let div13;
  let t27;
  let div14;
  let t28_value = (
    /*data*/
    (ctx[0].pos.x || d$2) + ""
  );
  let t28;
  let t29;
  let t30_value = (
    /*data*/
    (ctx[0].pos.y || d$2) + ""
  );
  let t30;
  let t31;
  let div18;
  let div16;
  let t33;
  let div17;
  let t34_value = (
    /*data*/
    (ctx[0].core || "false") + ""
  );
  let t34;
  let t35;
  let div22;
  let div19;
  let t37;
  let div21;
  let div20;
  let button0;
  let t38;
  let button0_disabled_value;
  let t39;
  let button1;
  let t40;
  let button1_disabled_value;
  let t41;
  let button2;
  let t42;
  let button2_disabled_value;
  let t43;
  let div25;
  let div23;
  let t45;
  let div24;
  let button3;
  let t46;
  let button3_disabled_value;
  let t47;
  let button4;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*data*/
      ctx2[0].parentId
    )
      return create_if_block_1$C;
    return create_else_block$H;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div1 = element("div");
      p0 = element("p");
      t1 = text(t1_value);
      t2 = space();
      p1 = element("p");
      t3 = text(t3_value);
      t4 = space();
      if_block.c();
      t5 = space();
      div2 = element("div");
      input = element("input");
      t6 = space();
      div26 = element("div");
      div6 = element("div");
      div4 = element("div");
      div4.textContent = "Size:";
      t8 = space();
      div5 = element("div");
      t9 = text(t9_value);
      t10 = text("x");
      t11 = text(t11_value);
      t12 = space();
      div9 = element("div");
      div7 = element("div");
      div7.textContent = "Minimal size:";
      t14 = space();
      div8 = element("div");
      t15 = text(t15_value);
      t16 = text("x");
      t17 = text(t17_value);
      t18 = space();
      div12 = element("div");
      div10 = element("div");
      div10.textContent = "Maximal size:";
      t20 = space();
      div11 = element("div");
      t21 = text(t21_value);
      t22 = text("x");
      t23 = text(t23_value);
      t24 = space();
      hr = element("hr");
      t25 = space();
      div15 = element("div");
      div13 = element("div");
      div13.textContent = "Start position:";
      t27 = space();
      div14 = element("div");
      t28 = text(t28_value);
      t29 = text("x");
      t30 = text(t30_value);
      t31 = space();
      div18 = element("div");
      div16 = element("div");
      div16.textContent = "Core Application:";
      t33 = space();
      div17 = element("div");
      t34 = text(t34_value);
      t35 = space();
      div22 = element("div");
      div19 = element("div");
      div19.textContent = "Window controls:";
      t37 = space();
      div21 = element("div");
      div20 = element("div");
      button0 = element("button");
      t38 = text("minimize");
      t39 = space();
      button1 = element("button");
      t40 = text("crop_square");
      t41 = space();
      button2 = element("button");
      t42 = text("close");
      t43 = space();
      div25 = element("div");
      div23 = element("div");
      div23.textContent = "Actions";
      t45 = space();
      div24 = element("div");
      button3 = element("button");
      t46 = text("Open");
      t47 = space();
      button4 = element("button");
      button4.textContent = "Reset Data";
      if (!src_url_equal(img.src, img_src_value = getAppIcon(
        /*data*/
        ctx[0]
      )))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*data*/
      ctx[0].info.name);
      attr(p0, "class", "appname");
      attr(p1, "class", "description");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
      input.disabled = input_disabled_value = SystemApps.includes(
        /*$id*/
        ctx[2]
      );
      attr(div2, "class", "actions");
      attr(div3, "class", "name");
      attr(div5, "class", "value");
      attr(div6, "class", "property");
      attr(div8, "class", "value");
      attr(div9, "class", "property");
      attr(div11, "class", "value");
      attr(div12, "class", "property");
      attr(div14, "class", "value");
      attr(div15, "class", "property");
      attr(div17, "class", "value");
      attr(div18, "class", "property");
      attr(button0, "class", "material-icons-round");
      button0.disabled = button0_disabled_value = !/*data*/
      ctx[0].controls.min;
      attr(button1, "class", "material-icons-round");
      button1.disabled = button1_disabled_value = !/*data*/
      ctx[0].controls.max;
      attr(button2, "class", "material-icons-round");
      button2.disabled = button2_disabled_value = !/*data*/
      ctx[0].controls.cls;
      attr(div20, "class", "controls");
      attr(div21, "class", "value");
      attr(div22, "class", "property");
      button3.disabled = button3_disabled_value = /*data*/
      ctx[0].opened || /*data*/
      ctx[0].disabled || /*data*/
      ctx[0].core;
      attr(div24, "class", "value");
      attr(div25, "class", "property");
      attr(div26, "class", "properties");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, img);
      append(div3, t0);
      append(div3, div1);
      append(div1, p0);
      append(p0, t1);
      append(div1, t2);
      append(div1, p1);
      append(p1, t3);
      append(p1, t4);
      if_block.m(p1, null);
      append(div3, t5);
      append(div3, div2);
      append(div2, input);
      input.checked = /*isEnabled*/
      ctx[1];
      insert(target, t6, anchor);
      insert(target, div26, anchor);
      append(div26, div6);
      append(div6, div4);
      append(div6, t8);
      append(div6, div5);
      append(div5, t9);
      append(div5, t10);
      append(div5, t11);
      append(div26, t12);
      append(div26, div9);
      append(div9, div7);
      append(div9, t14);
      append(div9, div8);
      append(div8, t15);
      append(div8, t16);
      append(div8, t17);
      append(div26, t18);
      append(div26, div12);
      append(div12, div10);
      append(div12, t20);
      append(div12, div11);
      append(div11, t21);
      append(div11, t22);
      append(div11, t23);
      append(div26, t24);
      append(div26, hr);
      append(div26, t25);
      append(div26, div15);
      append(div15, div13);
      append(div15, t27);
      append(div15, div14);
      append(div14, t28);
      append(div14, t29);
      append(div14, t30);
      append(div26, t31);
      append(div26, div18);
      append(div18, div16);
      append(div18, t33);
      append(div18, div17);
      append(div17, t34);
      append(div26, t35);
      append(div26, div22);
      append(div22, div19);
      append(div22, t37);
      append(div22, div21);
      append(div21, div20);
      append(div20, button0);
      append(button0, t38);
      append(div20, t39);
      append(div20, button1);
      append(button1, t40);
      append(div20, t41);
      append(div20, button2);
      append(button2, t42);
      append(div26, t43);
      append(div26, div25);
      append(div25, div23);
      append(div25, t45);
      append(div25, div24);
      append(div24, button3);
      append(button3, t46);
      append(div24, t47);
      append(div24, button4);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[5]
          ),
          listen(
            input,
            "change",
            /*updateState*/
            ctx[3]
          ),
          listen(
            button3,
            "click",
            /*click_handler*/
            ctx[6]
          ),
          listen(
            button4,
            "click",
            /*resetData*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && !src_url_equal(img.src, img_src_value = getAppIcon(
        /*data*/
        ctx2[0]
      ))) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*data*/
      1 && img_alt_value !== (img_alt_value = /*data*/
      ctx2[0].info.name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*data*/
      1 && t1_value !== (t1_value = /*data*/
      ctx2[0].info.name + ""))
        set_data(t1, t1_value);
      if (dirty & /*data*/
      1 && t3_value !== (t3_value = /*data*/
      ctx2[0].info.description + ""))
        set_data(t3, t3_value);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(p1, null);
        }
      }
      if (dirty & /*$id*/
      4 && input_disabled_value !== (input_disabled_value = SystemApps.includes(
        /*$id*/
        ctx2[2]
      ))) {
        input.disabled = input_disabled_value;
      }
      if (dirty & /*isEnabled*/
      2) {
        input.checked = /*isEnabled*/
        ctx2[1];
      }
      if (dirty & /*data*/
      1 && t9_value !== (t9_value = /*data*/
      (ctx2[0].size.w || d$2) + ""))
        set_data(t9, t9_value);
      if (dirty & /*data*/
      1 && t11_value !== (t11_value = /*data*/
      (ctx2[0].size.h || d$2) + ""))
        set_data(t11, t11_value);
      if (dirty & /*data*/
      1 && t15_value !== (t15_value = /*data*/
      (ctx2[0].minSize.w || d$2) + ""))
        set_data(t15, t15_value);
      if (dirty & /*data*/
      1 && t17_value !== (t17_value = /*data*/
      (ctx2[0].minSize.h || d$2) + ""))
        set_data(t17, t17_value);
      if (dirty & /*data*/
      1 && t21_value !== (t21_value = /*data*/
      (ctx2[0].maxSize.w || d$2) + ""))
        set_data(t21, t21_value);
      if (dirty & /*data*/
      1 && t23_value !== (t23_value = /*data*/
      (ctx2[0].maxSize.h || d$2) + ""))
        set_data(t23, t23_value);
      if (dirty & /*data*/
      1 && t28_value !== (t28_value = /*data*/
      (ctx2[0].pos.x || d$2) + ""))
        set_data(t28, t28_value);
      if (dirty & /*data*/
      1 && t30_value !== (t30_value = /*data*/
      (ctx2[0].pos.y || d$2) + ""))
        set_data(t30, t30_value);
      if (dirty & /*data*/
      1 && t34_value !== (t34_value = /*data*/
      (ctx2[0].core || "false") + ""))
        set_data(t34, t34_value);
      if (dirty & /*data*/
      1 && button0_disabled_value !== (button0_disabled_value = !/*data*/
      ctx2[0].controls.min)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*data*/
      1 && button1_disabled_value !== (button1_disabled_value = !/*data*/
      ctx2[0].controls.max)) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*data*/
      1 && button2_disabled_value !== (button2_disabled_value = !/*data*/
      ctx2[0].controls.cls)) {
        button2.disabled = button2_disabled_value;
      }
      if (dirty & /*data*/
      1 && button3_disabled_value !== (button3_disabled_value = /*data*/
      ctx2[0].opened || /*data*/
      ctx2[0].disabled || /*data*/
      ctx2[0].core)) {
        button3.disabled = button3_disabled_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
        detach(t6);
        detach(div26);
      }
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block$H(ctx) {
  let t0;
  let t1_value = (
    /*data*/
    ctx[0].id + ""
  );
  let t1;
  let t2;
  return {
    c() {
      t0 = text("(");
      t1 = text(t1_value);
      t2 = text(")");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && t1_value !== (t1_value = /*data*/
      ctx2[0].id + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_if_block_1$C(ctx) {
  let t0;
  let t1_value = (
    /*data*/
    ctx[0].parentId + ""
  );
  let t1;
  let t2;
  let t3_value = (
    /*data*/
    ctx[0].id + ""
  );
  let t3;
  let t4;
  return {
    c() {
      t0 = text("(");
      t1 = text(t1_value);
      t2 = text(".");
      t3 = text(t3_value);
      t4 = text(")");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, t4, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && t1_value !== (t1_value = /*data*/
      ctx2[0].parentId + ""))
        set_data(t1, t1_value);
      if (dirty & /*data*/
      1 && t3_value !== (t3_value = /*data*/
      ctx2[0].id + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
      }
    }
  };
}
function create_fragment$5d(ctx) {
  let if_block_anchor;
  let if_block = (
    /*data*/
    ctx[0] && create_if_block$1X(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*data*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1X(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
let d$2 = "(unset)";
function instance$4T($$self, $$props, $$invalidate) {
  let $id;
  let $UserData;
  component_subscribe($$self, AppInfoId, ($$value) => $$invalidate(2, $id = $$value));
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(7, $UserData = $$value));
  let data;
  let isEnabled = true;
  function updateState() {
    if (isEnabled)
      enableApp($id);
    else
      disableApp($id);
    $$invalidate(0, data = getWindow($id));
    if (!data)
      return;
    $$invalidate(1, isEnabled = !getWindow($id).disabled);
  }
  AppInfoId.subscribe(update2);
  WindowStore.subscribe(update2);
  function update2() {
    if (!$id)
      return;
    $$invalidate(0, data = getWindow($id));
    if (!data)
      return;
    $$invalidate(1, isEnabled = !getWindow($id).disabled);
  }
  function resetData() {
    createOverlayableError(
      {
        title: "Warning!",
        message: "Resetting the application data may result in a loss of personal information related to the app. Are you sure?",
        buttons: [
          {
            caption: "Yes",
            action() {
              delete $UserData.appdata[$id];
              UserData$2.set($UserData);
              closeWindow($id);
            }
          },
          {
            caption: "Cancel",
            action() {
            },
            suggested: true
          }
        ]
      },
      "AppInfo"
    );
  }
  function input_change_handler() {
    isEnabled = this.checked;
    $$invalidate(1, isEnabled);
  }
  const click_handler = () => openWindow($id);
  return [
    data,
    isEnabled,
    $id,
    updateState,
    resetData,
    input_change_handler,
    click_handler
  ];
}
let AppInfo$2 = class AppInfo extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4T, create_fragment$5d, safe_not_equal, {});
  }
};
const AppInfo$1 = {
  info: {
    name: "Application Info",
    description: "View information about an application",
    builtin: true,
    version: "1.0.0",
    author: "Izaak Kuipers",
    hidden: true,
    icon: TestAppIcon,
    appGroup: "coreApps"
  },
  size: { w: 500, h: 450 },
  pos: { x: 30, y: 40 },
  minSize: { w: 500, h: 450 },
  maxSize: { w: 500, h: 450 },
  controls: { min: true, max: false, cls: true },
  state: {
    headless: false,
    resizable: false,
    windowState: { min: false, max: false, fll: false }
  },
  content: AppInfo$2,
  glass: false,
  events: {
    close() {
      AppInfoId.set(null);
    },
    async open(app) {
      await sleep(10);
      if (!get_store_value(AppInfoId))
        closeWindow(app.id);
    }
  }
};
const AppInfoId = writable(null);
const AppManager$2 = "";
function showOverlay(id, parentId) {
  const ws = get_store_value(WindowStore);
  for (let i2 = 0; i2 < ws.length; i2++) {
    if (ws[i2].id == parentId) {
      if (!ws[i2].overlays || !ws[i2].overlays[id])
        return false;
      ws[i2].overlays[id].show = true;
    }
  }
  WindowStore.set(ws);
}
function hideOverlay(id, parentId) {
  const ws = get_store_value(WindowStore);
  for (let i2 = 0; i2 < ws.length; i2++) {
    if (ws[i2].id == parentId) {
      if (!ws[i2].overlays || !ws[i2].overlays[id])
        return false;
      ws[i2].overlays[id].show = false;
    }
  }
  WindowStore.set(ws);
}
const staticAppManActions = [
  {
    caption: "Run...",
    icon: "directions_run",
    action: () => {
      showOverlay("run", "AppMan");
    }
  }
];
const appManSelected = writable();
function create_if_block$1W(ctx) {
  let div3;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let div1;
  let t1_value = (
    /*app*/
    ctx[0].info.name + ""
  );
  let t1;
  let t2;
  let t3;
  let div2;
  let mounted;
  let dispose;
  let if_block0 = (
    /*error*/
    ctx[1] && create_if_block_2$d()
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*app*/
      ctx2[0].parentId
    )
      return create_if_block_1$B;
    return create_else_block$G;
  }
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      div2 = element("div");
      if_block1.c();
      if (!src_url_equal(img.src, img_src_value = getOriginalIcon(
        /*app*/
        ctx[0].id
      ) || getAppIcon(
        /*app*/
        ctx[0]
      )))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(div1, "class", "appname");
      attr(div2, "class", "id");
      attr(div3, "class", "appinstance");
      toggle_class(div3, "closed", !/*app*/
      ctx[0].opened);
      toggle_class(
        div3,
        "selected",
        /*$appManSelected*/
        ctx[2] == /*app*/
        ctx[0].id
      );
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, img);
      append(div3, t0);
      append(div3, div1);
      append(div1, t1);
      append(div1, t2);
      if (if_block0)
        if_block0.m(div1, null);
      append(div3, t3);
      append(div3, div2);
      if_block1.m(div2, null);
      if (!mounted) {
        dispose = listen(
          div3,
          "click",
          /*select*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*app*/
      1 && !src_url_equal(img.src, img_src_value = getOriginalIcon(
        /*app*/
        ctx2[0].id
      ) || getAppIcon(
        /*app*/
        ctx2[0]
      ))) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*app*/
      1 && t1_value !== (t1_value = /*app*/
      ctx2[0].info.name + ""))
        set_data(t1, t1_value);
      if (
        /*error*/
        ctx2[1]
      ) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_2$d();
          if_block0.c();
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div2, null);
        }
      }
      if (dirty & /*app*/
      1) {
        toggle_class(div3, "closed", !/*app*/
        ctx2[0].opened);
      }
      if (dirty & /*$appManSelected, app*/
      5) {
        toggle_class(
          div3,
          "selected",
          /*$appManSelected*/
          ctx2[2] == /*app*/
          ctx2[0].id
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block0)
        if_block0.d();
      if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$d(ctx) {
  let t2;
  return {
    c() {
      t2 = text("(Dialog)");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_else_block$G(ctx) {
  let t_value = (
    /*app*/
    ctx[0].id + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*app*/
      1 && t_value !== (t_value = /*app*/
      ctx2[0].id + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$B(ctx) {
  let t0_value = (
    /*app*/
    ctx[0].parentId + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*app*/
    ctx[0].id + ""
  );
  let t2;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(".");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*app*/
      1 && t0_value !== (t0_value = /*app*/
      ctx2[0].parentId + ""))
        set_data(t0, t0_value);
      if (dirty & /*app*/
      1 && t2_value !== (t2_value = /*app*/
      ctx2[0].id + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_fragment$5c(ctx) {
  let show_if = (
    /*app*/
    ctx[0] && (!isDisabled(
      /*app*/
      ctx[0].id
    ) && isOpened(
      /*app*/
      ctx[0].id
    ) || /*error*/
    ctx[1])
  );
  let if_block_anchor;
  let if_block = show_if && create_if_block$1W(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*app, error*/
      3)
        show_if = /*app*/
        ctx2[0] && (!isDisabled(
          /*app*/
          ctx2[0].id
        ) && isOpened(
          /*app*/
          ctx2[0].id
        ) || /*error*/
        ctx2[1]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1W(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$4S($$self, $$props, $$invalidate) {
  let $appManSelected;
  component_subscribe($$self, appManSelected, ($$value) => $$invalidate(2, $appManSelected = $$value));
  let { app } = $$props;
  let { error: error2 = false } = $$props;
  function select() {
    set_store_value(appManSelected, $appManSelected = app.id, $appManSelected);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("error" in $$props2)
      $$invalidate(1, error2 = $$props2.error);
  };
  return [app, error2, $appManSelected, select];
}
let App$1 = class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4S, create_fragment$5c, safe_not_equal, { app: 0, error: 1 });
  }
};
function create_if_block$1V(ctx) {
  let div3;
  let div0;
  let t0;
  let div1;
  let t1_value = (
    /*overlay*/
    ctx[1].info.name + ""
  );
  let t1;
  let t2;
  let div2;
  let t3_value = (
    /*parent*/
    ctx[2].id + ""
  );
  let t3;
  let t4;
  let t5;
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      div0.innerHTML = `<img src="${DefaultIcon}" alt=""/>`;
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      t3 = text(t3_value);
      t4 = text(".");
      t5 = text(
        /*id*/
        ctx[0]
      );
      attr(div1, "class", "appname");
      attr(div2, "class", "id");
      attr(div3, "class", "appinstance");
      toggle_class(div3, "closed", !/*overlay*/
      ctx[1].show);
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div3, t0);
      append(div3, div1);
      append(div1, t1);
      append(div3, t2);
      append(div3, div2);
      append(div2, t3);
      append(div2, t4);
      append(div2, t5);
    },
    p(ctx2, dirty) {
      if (dirty & /*overlay*/
      2 && t1_value !== (t1_value = /*overlay*/
      ctx2[1].info.name + ""))
        set_data(t1, t1_value);
      if (dirty & /*parent*/
      4 && t3_value !== (t3_value = /*parent*/
      ctx2[2].id + ""))
        set_data(t3, t3_value);
      if (dirty & /*id*/
      1)
        set_data(
          t5,
          /*id*/
          ctx2[0]
        );
      if (dirty & /*overlay*/
      2) {
        toggle_class(div3, "closed", !/*overlay*/
        ctx2[1].show);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
    }
  };
}
function create_fragment$5b(ctx) {
  let div;
  let show_if = (
    /*overlay*/
    ctx[1] && isOpened(
      /*parent*/
      ctx[2].id
    )
  );
  let if_block = show_if && create_if_block$1V(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "indent");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*overlay, parent*/
      6)
        show_if = /*overlay*/
        ctx2[1] && isOpened(
          /*parent*/
          ctx2[2].id
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1V(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$4R($$self, $$props, $$invalidate) {
  let { id } = $$props;
  let { overlay } = $$props;
  let { parent } = $$props;
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("overlay" in $$props2)
      $$invalidate(1, overlay = $$props2.overlay);
    if ("parent" in $$props2)
      $$invalidate(2, parent = $$props2.parent);
  };
  return [id, overlay, parent];
}
class OverlayApp extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4R, create_fragment$5b, safe_not_equal, { id: 0, overlay: 1, parent: 2 });
  }
}
function get_each_context$$(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function get_each_context_1$g(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list2[i2];
  return child_ctx;
}
function create_if_block$1U(ctx) {
  let div;
  let appsvelte;
  let t0;
  let t1;
  let current;
  appsvelte = new App$1({
    props: {
      app: (
        /*window*/
        ctx[0]
      ),
      error: (
        /*error*/
        ctx[2]
      )
    }
  });
  let if_block0 = (
    /*window*/
    ctx[0].children && create_if_block_2$c(ctx)
  );
  let if_block1 = (
    /*window*/
    ctx[0].overlays && create_if_block_1$A(ctx)
  );
  return {
    c() {
      div = element("div");
      create_component(appsvelte.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      toggle_class(div, "indent", !/*top*/
      ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(appsvelte, div, null);
      append(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const appsvelte_changes = {};
      if (dirty & /*window*/
      1)
        appsvelte_changes.app = /*window*/
        ctx2[0];
      if (dirty & /*error*/
      4)
        appsvelte_changes.error = /*error*/
        ctx2[2];
      appsvelte.$set(appsvelte_changes);
      if (
        /*window*/
        ctx2[0].children
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*window*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$c(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*window*/
        ctx2[0].overlays
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*window*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$A(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*top*/
      2) {
        toggle_class(div, "indent", !/*top*/
        ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(appsvelte.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(appsvelte.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(appsvelte);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_2$c(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(Object.keys(
    /*window*/
    ctx[0].children
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$g(get_each_context_1$g(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, window*/
      1) {
        each_value_1 = ensure_array_like(Object.keys(
          /*window*/
          ctx2[0].children
        ));
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$g(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$g(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1$g(ctx) {
  let branch;
  let current;
  branch = new Branch_1$1({
    props: { window: getWindow(
      /*child*/
      ctx[6]
    ) }
  });
  return {
    c() {
      create_component(branch.$$.fragment);
    },
    m(target, anchor) {
      mount_component(branch, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const branch_changes = {};
      if (dirty & /*window*/
      1)
        branch_changes.window = getWindow(
          /*child*/
          ctx2[6]
        );
      branch.$set(branch_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(branch.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(branch.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(branch, detaching);
    }
  };
}
function create_if_block_1$A(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(Object.entries(
    /*window*/
    ctx[0].overlays
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$$(get_each_context$$(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, window*/
      1) {
        each_value = ensure_array_like(Object.entries(
          /*window*/
          ctx2[0].overlays
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$$(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$$(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$$(ctx) {
  let overlayapp;
  let current;
  overlayapp = new OverlayApp({
    props: {
      overlay: (
        /*overlay*/
        ctx[3][1]
      ),
      parent: (
        /*window*/
        ctx[0]
      ),
      id: (
        /*overlay*/
        ctx[3][0]
      )
    }
  });
  return {
    c() {
      create_component(overlayapp.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overlayapp, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const overlayapp_changes = {};
      if (dirty & /*window*/
      1)
        overlayapp_changes.overlay = /*overlay*/
        ctx2[3][1];
      if (dirty & /*window*/
      1)
        overlayapp_changes.parent = /*window*/
        ctx2[0];
      if (dirty & /*window*/
      1)
        overlayapp_changes.id = /*overlay*/
        ctx2[3][0];
      overlayapp.$set(overlayapp_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(overlayapp.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overlayapp.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overlayapp, detaching);
    }
  };
}
function create_fragment$5a(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*window*/
    ctx[0] && create_if_block$1U(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*window*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*window*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1U(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$4Q($$self, $$props, $$invalidate) {
  let { window: window2 } = $$props;
  let { top = false } = $$props;
  let { error: error2 = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("window" in $$props2)
      $$invalidate(0, window2 = $$props2.window);
    if ("top" in $$props2)
      $$invalidate(1, top = $$props2.top);
    if ("error" in $$props2)
      $$invalidate(2, error2 = $$props2.error);
  };
  return [window2, top, error2];
}
let Branch_1$1 = class Branch_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4Q, create_fragment$5a, safe_not_equal, { window: 0, top: 1, error: 2 });
  }
};
function get_each_context$_(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2];
  return child_ctx;
}
function get_each_context_1$f(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2];
  return child_ctx;
}
function create_if_block$1T(ctx) {
  let branch;
  let current;
  branch = new Branch_1$1({
    props: { window: (
      /*window*/
      ctx[5]
    ), top: true }
  });
  return {
    c() {
      create_component(branch.$$.fragment);
    },
    m(target, anchor) {
      mount_component(branch, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const branch_changes = {};
      if (dirty & /*$WindowStore*/
      2)
        branch_changes.window = /*window*/
        ctx2[5];
      branch.$set(branch_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(branch.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(branch.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(branch, detaching);
    }
  };
}
function create_each_block_1$f(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*window*/
  ctx[5].parentId && create_if_block$1T(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*window*/
      ctx2[5].parentId) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$WindowStore*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1T(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_each_block$_(ctx) {
  let branch;
  let current;
  branch = new Branch_1$1({
    props: {
      window: (
        /*error*/
        ctx[2]
      ),
      top: true,
      error: true
    }
  });
  return {
    c() {
      create_component(branch.$$.fragment);
    },
    m(target, anchor) {
      mount_component(branch, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const branch_changes = {};
      if (dirty & /*es*/
      1)
        branch_changes.window = /*error*/
        ctx2[2];
      branch.$set(branch_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(branch.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(branch.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(branch, detaching);
    }
  };
}
function create_fragment$59(ctx) {
  let div;
  let t2;
  let current;
  let each_value_1 = ensure_array_like(
    /*$WindowStore*/
    ctx[1]
  );
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1$f(get_each_context_1$f(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  let each_value = ensure_array_like(
    /*es*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$_(get_each_context$_(ctx, each_value, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "apps");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(div, null);
        }
      }
      append(div, t2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$WindowStore*/
      2) {
        each_value_1 = ensure_array_like(
          /*$WindowStore*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$f(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_1$f(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(div, t2);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (dirty & /*es*/
      1) {
        each_value = ensure_array_like(
          /*es*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$_(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$_(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$4P($$self, $$props, $$invalidate) {
  let $WindowStore;
  component_subscribe($$self, WindowStore, ($$value) => $$invalidate(1, $WindowStore = $$value));
  let es = [];
  ErrorWindowStore.subscribe((v2) => {
    $$invalidate(0, es = v2);
  });
  return [es, $WindowStore];
}
let AppList$1 = class AppList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4P, create_fragment$59, safe_not_equal, {});
  }
};
function create_if_block$1S(ctx) {
  let div;
  let t0;
  let t1_value = getWindow(
    /*$appManSelected*/
    ctx[0]
  ).snapped ? "yes" : "no";
  let t1;
  return {
    c() {
      div = element("div");
      t0 = text("Snapped: ");
      t1 = text(t1_value);
      attr(div, "class", "section");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$appManSelected*/
      1 && t1_value !== (t1_value = getWindow(
        /*$appManSelected*/
        ctx2[0]
      ).snapped ? "yes" : "no"))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$58(ctx) {
  let div4;
  let div3;
  let show_if = (
    /*$appManSelected*/
    ctx[0] && !/*$appManSelected*/
    ctx[0].startsWith("error_")
  );
  let t0;
  let div0;
  let t1;
  let t2_value = (
    /*$OpenedStore*/
    ctx[1].length + ""
  );
  let t2;
  let t3;
  let div1;
  let t4;
  let t5_value = (
    /*$WindowStore*/
    ctx[2].length + ""
  );
  let t5;
  let t6;
  let div2;
  let t7;
  let t8_value = (
    /*$ErrorWindowStore*/
    ctx[3].length + ""
  );
  let t8;
  let if_block = show_if && create_if_block$1S(ctx);
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div0 = element("div");
      t1 = text("Running: ");
      t2 = text(t2_value);
      t3 = space();
      div1 = element("div");
      t4 = text("Loaded: ");
      t5 = text(t5_value);
      t6 = space();
      div2 = element("div");
      t7 = text("Dialogs: ");
      t8 = text(t8_value);
      attr(div0, "class", "section");
      attr(div1, "class", "section");
      attr(div2, "class", "section");
      attr(div3, "class", "right");
      attr(div4, "class", "bottombar");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      if (if_block)
        if_block.m(div3, null);
      append(div3, t0);
      append(div3, div0);
      append(div0, t1);
      append(div0, t2);
      append(div3, t3);
      append(div3, div1);
      append(div1, t4);
      append(div1, t5);
      append(div3, t6);
      append(div3, div2);
      append(div2, t7);
      append(div2, t8);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$appManSelected*/
      1)
        show_if = /*$appManSelected*/
        ctx2[0] && !/*$appManSelected*/
        ctx2[0].startsWith("error_");
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1S(ctx2);
          if_block.c();
          if_block.m(div3, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*$OpenedStore*/
      2 && t2_value !== (t2_value = /*$OpenedStore*/
      ctx2[1].length + ""))
        set_data(t2, t2_value);
      if (dirty & /*$WindowStore*/
      4 && t5_value !== (t5_value = /*$WindowStore*/
      ctx2[2].length + ""))
        set_data(t5, t5_value);
      if (dirty & /*$ErrorWindowStore*/
      8 && t8_value !== (t8_value = /*$ErrorWindowStore*/
      ctx2[3].length + ""))
        set_data(t8, t8_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$4O($$self, $$props, $$invalidate) {
  let $appManSelected;
  let $OpenedStore;
  let $WindowStore;
  let $ErrorWindowStore;
  component_subscribe($$self, appManSelected, ($$value) => $$invalidate(0, $appManSelected = $$value));
  component_subscribe($$self, OpenedStore, ($$value) => $$invalidate(1, $OpenedStore = $$value));
  component_subscribe($$self, WindowStore, ($$value) => $$invalidate(2, $WindowStore = $$value));
  component_subscribe($$self, ErrorWindowStore, ($$value) => $$invalidate(3, $ErrorWindowStore = $$value));
  return [$appManSelected, $OpenedStore, $WindowStore, $ErrorWindowStore];
}
class BottomBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4O, create_fragment$58, safe_not_equal, {});
  }
}
function create_fragment$57(ctx) {
  let button;
  let span;
  let t0_value = (
    /*action*/
    ctx[0].icon + ""
  );
  let t0;
  let t1;
  let p2;
  let t2_value = (
    /*action*/
    ctx[0].caption + ""
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      p2 = element("p");
      t2 = text(t2_value);
      attr(span, "class", "material-icons-round");
      attr(p2, "class", "caption");
      attr(button, "class", "action");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      append(span, t0);
      append(button, t1);
      append(button, p2);
      append(p2, t2);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*action*/
            ctx[0].action
          ))
            ctx[0].action.apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*action*/
      1 && t0_value !== (t0_value = /*action*/
      ctx[0].icon + ""))
        set_data(t0, t0_value);
      if (dirty & /*action*/
      1 && t2_value !== (t2_value = /*action*/
      ctx[0].caption + ""))
        set_data(t2, t2_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4N($$self, $$props, $$invalidate) {
  let { action } = $$props;
  $$self.$$set = ($$props2) => {
    if ("action" in $$props2)
      $$invalidate(0, action = $$props2.action);
  };
  return [action];
}
let Action$1 = class Action extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4N, create_fragment$57, safe_not_equal, { action: 0 });
  }
};
function create_fragment$56(ctx) {
  let button;
  let span;
  let t1;
  let p2;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      span = element("span");
      span.textContent = "settings";
      t1 = space();
      p2 = element("p");
      p2.textContent = "App info";
      attr(span, "class", "material-icons-round");
      attr(p2, "class", "caption");
      attr(button, "class", "action");
      button.disabled = button_disabled_value = !/*$appManSelected*/
      ctx[0] || /*$appManSelected*/
      ctx[0].startsWith("error_");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      append(button, t1);
      append(button, p2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*info*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$appManSelected*/
      1 && button_disabled_value !== (button_disabled_value = !/*$appManSelected*/
      ctx2[0] || /*$appManSelected*/
      ctx2[0].startsWith("error_"))) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4M($$self, $$props, $$invalidate) {
  let $appManSelected;
  component_subscribe($$self, appManSelected, ($$value) => $$invalidate(0, $appManSelected = $$value));
  function info() {
    AppInfoId.set($appManSelected);
    openWindow("AppInfo");
  }
  return [$appManSelected, info];
}
class AppInfo2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4M, create_fragment$56, safe_not_equal, {});
  }
}
function create_fragment$55(ctx) {
  let button;
  let span;
  let t1;
  let p2;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      span = element("span");
      span.textContent = "close";
      t1 = space();
      p2 = element("p");
      p2.textContent = "Close";
      attr(span, "class", "material-icons-round");
      attr(p2, "class", "caption");
      attr(button, "class", "action");
      button.disabled = button_disabled_value = !/*$appManSelected*/
      ctx[0] || /*$appManSelected*/
      ctx[0].startsWith("error_");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      append(button, t1);
      append(button, p2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*terminate*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$appManSelected*/
      1 && button_disabled_value !== (button_disabled_value = !/*$appManSelected*/
      ctx2[0] || /*$appManSelected*/
      ctx2[0].startsWith("error_"))) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4L($$self, $$props, $$invalidate) {
  let $appManSelected;
  component_subscribe($$self, appManSelected, ($$value) => $$invalidate(0, $appManSelected = $$value));
  function terminate() {
    closeWindow($appManSelected);
    set_store_value(appManSelected, $appManSelected = null, $appManSelected);
  }
  return [$appManSelected, terminate];
}
class Close extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4L, create_fragment$55, safe_not_equal, {});
  }
}
function create_fragment$54(ctx) {
  let button;
  let span;
  let t1;
  let p2;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      span = element("span");
      span.textContent = "block";
      t1 = space();
      p2 = element("p");
      p2.textContent = "Disable";
      attr(span, "class", "material-icons-round");
      attr(p2, "class", "caption");
      attr(button, "class", "action");
      button.disabled = button_disabled_value = !/*$appManSelected*/
      ctx[0] || /*$appManSelected*/
      ctx[0].startsWith("error_");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      append(button, t1);
      append(button, p2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*disable*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$appManSelected*/
      1 && button_disabled_value !== (button_disabled_value = !/*$appManSelected*/
      ctx2[0] || /*$appManSelected*/
      ctx2[0].startsWith("error_"))) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4K($$self, $$props, $$invalidate) {
  let $appManSelected;
  component_subscribe($$self, appManSelected, ($$value) => $$invalidate(0, $appManSelected = $$value));
  function disable() {
    disableApp($appManSelected);
  }
  return [$appManSelected, disable];
}
class DisableApp extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4K, create_fragment$54, safe_not_equal, {});
  }
}
function get_each_context$Z(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list2[i2];
  return child_ctx;
}
function create_each_block$Z(ctx) {
  let action_1;
  let current;
  action_1 = new Action$1({ props: { action: (
    /*action*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(action_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(action_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(action_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(action_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(action_1, detaching);
    }
  };
}
function create_fragment$53(ctx) {
  let div3;
  let div2;
  let appinfo;
  let t0;
  let div0;
  let t1;
  let disableapp;
  let t2;
  let close;
  let t3;
  let div1;
  let t4;
  let current;
  appinfo = new AppInfo2({});
  disableapp = new DisableApp({});
  close = new Close({});
  let each_value = ensure_array_like(staticAppManActions);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$Z(get_each_context$Z(ctx, each_value, i2));
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      create_component(appinfo.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = space();
      create_component(disableapp.$$.fragment);
      t2 = space();
      create_component(close.$$.fragment);
      t3 = space();
      div1 = element("div");
      t4 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div0, "class", "sep");
      attr(div1, "class", "sep");
      attr(div2, "class", "actions");
      attr(div3, "class", "topbar");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      mount_component(appinfo, div2, null);
      append(div2, t0);
      append(div2, div0);
      append(div2, t1);
      mount_component(disableapp, div2, null);
      append(div2, t2);
      mount_component(close, div2, null);
      append(div2, t3);
      append(div2, div1);
      append(div2, t4);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div2, null);
        }
      }
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(appinfo.$$.fragment, local);
      transition_in(disableapp.$$.fragment, local);
      transition_in(close.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(appinfo.$$.fragment, local);
      transition_out(disableapp.$$.fragment, local);
      transition_out(close.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(appinfo);
      destroy_component(disableapp);
      destroy_component(close);
      destroy_each(each_blocks, detaching);
    }
  };
}
let TopBar$3 = class TopBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$53, safe_not_equal, {});
  }
};
function create_fragment$52(ctx) {
  let topbar;
  let t0;
  let applist;
  let t1;
  let bottombar;
  let current;
  topbar = new TopBar$3({});
  applist = new AppList$1({});
  bottombar = new BottomBar({});
  return {
    c() {
      create_component(topbar.$$.fragment);
      t0 = space();
      create_component(applist.$$.fragment);
      t1 = space();
      create_component(bottombar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      insert(target, t0, anchor);
      mount_component(applist, target, anchor);
      insert(target, t1, anchor);
      mount_component(bottombar, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      transition_in(applist.$$.fragment, local);
      transition_in(bottombar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      transition_out(applist.$$.fragment, local);
      transition_out(bottombar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(topbar, detaching);
      destroy_component(applist, detaching);
      destroy_component(bottombar, detaching);
    }
  };
}
let AppManager$1 = class AppManager extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$52, safe_not_equal, {});
  }
};
const RunDialog_svelte_svelte_type_style_lang = "";
function get_each_context$Y(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2];
  return child_ctx;
}
function create_if_block$1R(ctx) {
  let option;
  let t_value = (
    /*window*/
    ctx[5].id + ""
  );
  let t2;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t2 = text(t_value);
      option.__value = option_value_value = /*window*/
      ctx[5].id;
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$WindowStore*/
      2 && t_value !== (t_value = /*window*/
      ctx2[5].id + ""))
        set_data(t2, t_value);
      if (dirty & /*$WindowStore*/
      2 && option_value_value !== (option_value_value = /*window*/
      ctx2[5].id)) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block$Y(ctx) {
  let show_if = !isOpened(
    /*window*/
    ctx[5].id
  ) && !/*window*/
  ctx[5].info.custom && !isDisabled(
    /*window*/
    ctx[5].id
  );
  let if_block_anchor;
  let if_block = show_if && create_if_block$1R(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$WindowStore*/
      2)
        show_if = !isOpened(
          /*window*/
          ctx2[5].id
        ) && !/*window*/
        ctx2[5].info.custom && !isDisabled(
          /*window*/
          ctx2[5].id
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1R(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$51(ctx) {
  let div1;
  let img;
  let img_src_value;
  let t0;
  let div0;
  let p2;
  let t2;
  let select;
  let t3;
  let div3;
  let div2;
  let button0;
  let t4;
  let button0_disabled_value;
  let t5;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*$WindowStore*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$Y(get_each_context$Y(ctx, each_value, i2));
  }
  return {
    c() {
      div1 = element("div");
      img = element("img");
      t0 = space();
      div0 = element("div");
      p2 = element("p");
      p2.textContent = "Select the ID of the app you want to run from the following list:";
      t2 = space();
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      div3 = element("div");
      div2 = element("div");
      button0 = element("button");
      t4 = text("Run");
      t5 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      if (!src_url_equal(img.src, img_src_value = AppsIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "Run");
      attr(img, "class", "svelte-1pwxzgl");
      attr(p2, "class", "caption svelte-1pwxzgl");
      attr(select, "class", "svelte-1pwxzgl");
      if (
        /*value*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[4].call(select)
        ));
      attr(div0, "class", "inner");
      attr(div1, "class", "wrapper svelte-1pwxzgl");
      button0.disabled = button0_disabled_value = !/*value*/
      ctx[0];
      attr(div2, "class", "inner svelte-1pwxzgl");
      attr(div3, "class", "actions svelte-1pwxzgl");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, img);
      append(div1, t0);
      append(div1, div0);
      append(div0, p2);
      append(div0, t2);
      append(div0, select);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(
        select,
        /*value*/
        ctx[0],
        true
      );
      insert(target, t3, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, button0);
      append(button0, t4);
      append(div2, t5);
      append(div2, button1);
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[4]
          ),
          listen(
            button0,
            "click",
            /*run*/
            ctx[2]
          ),
          listen(
            button1,
            "click",
            /*closeThis*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$WindowStore*/
      2) {
        each_value = ensure_array_like(
          /*$WindowStore*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$Y(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$Y(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*value, $WindowStore*/
      3) {
        select_option(
          select,
          /*value*/
          ctx2[0]
        );
      }
      if (dirty & /*value, $WindowStore*/
      3 && button0_disabled_value !== (button0_disabled_value = !/*value*/
      ctx2[0])) {
        button0.disabled = button0_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t3);
        detach(div3);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4J($$self, $$props, $$invalidate) {
  let $WindowStore;
  component_subscribe($$self, WindowStore, ($$value) => $$invalidate(1, $WindowStore = $$value));
  let value;
  function run2() {
    openWindow(value, true);
    closeThis();
  }
  function closeThis() {
    hideOverlay("run", "AppMan");
  }
  function select_change_handler() {
    value = select_value(this);
    $$invalidate(0, value);
  }
  return [value, $WindowStore, run2, closeThis, select_change_handler];
}
class RunDialog extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4J, create_fragment$51, safe_not_equal, {});
  }
}
const trayIcons = writable([]);
function createTrayIcon(data) {
  if (trayExists(data.identifier))
    return false;
  const icons = get_store_value(trayIcons);
  icons.push(data);
  trayIcons.set(icons);
}
function disposeTrayIcon(identifier) {
  const icons = get_store_value(trayIcons);
  for (let i2 = 0; i2 < icons.length; i2++) {
    if (icons[i2].identifier == identifier)
      icons.splice(i2, 1);
  }
  trayIcons.set(icons);
}
function trayExists(identifier) {
  const icons = get_store_value(trayIcons);
  for (let i2 = 0; i2 < icons.length; i2++) {
    if (icons[i2].identifier == identifier)
      return true;
  }
  return false;
}
const AppManager2 = {
  info: {
    name: "Application Manager",
    description: "Manage Open Apps",
    builtin: true,
    version: "1.5.0",
    author: "Izaak Kuipers",
    icon: AppManIcon,
    appGroup: "systemTools"
  },
  size: { w: 600, h: 500 },
  pos: { x: 30, y: 40 },
  minSize: { w: 600, h: 500 },
  maxSize: { w: 600, h: 500 },
  controls: { min: false, max: true, cls: true },
  state: {
    headless: false,
    resizable: false,
    windowState: { min: false, max: false, fll: false }
  },
  content: AppManager$1,
  glass: true,
  events: {
    open() {
      createTrayIcon({
        image: AppManager2.info.icon,
        identifier: "Application Manager",
        onOpen() {
        }
      });
    },
    close() {
      disposeTrayIcon("Application Manager");
    }
  },
  overlays: {
    run: {
      info: {
        name: "Run",
        author: "ArcOS Team",
        version: "1.0.0"
      },
      size: { w: NaN, h: NaN },
      show: false,
      content: RunDialog
    }
  }
};
const arcterm = "";
function getSwitches(argv) {
  let switches = {};
  let currentArg = "";
  const prefix = "--";
  for (let i2 = 0; i2 < argv.length; i2++) {
    if (argv[i2].startsWith(prefix)) {
      const arg = argv[i2].replace(prefix, "");
      currentArg = arg == currentArg ? currentArg : arg;
      if (!switches[currentArg])
        switches[currentArg] = "";
    } else if (currentArg) {
      switches[currentArg] += `${argv[i2]} `;
    }
  }
  for (const key2 in switches) {
    switches[key2] = switches[key2].trim();
  }
  return switches;
}
function switchExists(argv, key2) {
  const switches = getSwitches(argv);
  for (const sw in switches) {
    if (sw == key2)
      return true;
  }
  return false;
}
const AppList2 = {
  keyword: "applist",
  exec(cmd, argv, term) {
    const store = switchExists(argv, "open") ? getOpenedStore() : get_store_value(WindowStore);
    const showHidden = switchExists(argv, "all");
    header(term);
    for (let i2 = 0; i2 < store.length; i2++) {
      if (isPopulatable(store[i2]) || showHidden)
        output(term, store[i2]);
    }
  },
  help(term) {
    term.std.writeColor("Example: [applist] --open", "blue");
  },
  description: "List all- or opened ArcOS apps.",
  syntax: "([opened?])"
};
function output(term, app) {
  const id = app.id.padEnd(30, " ");
  const name = app.info.name.padEnd(30, " ");
  const version = app.info.version;
  term.std.writeColor(`${name}[${id}]${version}`, "gray");
}
function header(term) {
  const hName = `Name`.padEnd(30, " ");
  const hId = `ID`.padEnd(30, " ");
  const hVer = `Version`;
  const head = `${hName}${hId}${hVer}`;
  term.std.writeColor(`[${head}]`, "yellow");
  term.std.writeSeparator(head.length);
}
const sizeUnits = [
  "bytes",
  "KB",
  "MB",
  "GB",
  "TB",
  "PB",
  "EB",
  "ZB",
  "YB"
];
function formatBytes(bytes) {
  let l2 = 0, n2 = bytes;
  while (n2 >= 1024 && ++l2) {
    n2 = n2 / 1024;
  }
  return n2.toFixed(n2 < 10 && l2 > 0 ? 1 : 0) + " " + sizeUnits[l2];
}
let DESKTOP_MODE;
async function getDesktopMode() {
  try {
    const req = await (await fetch("./desktop")).text();
    DESKTOP_MODE = req.startsWith("desktop") ? "desktop" : "browser";
  } catch {
    DESKTOP_MODE = "browser";
  }
}
function checkDesktopFile() {
  if (!isDesktop())
    createTrayIcon({
      title: "You're in the web version",
      image: WindowSettingsIcon,
      identifier: "webversion-notice",
      onOpen(tray) {
        errorMessage(
          "You're running ArcOS Web",
          "Thank you for using ArcOS! It is recommended you use the ArcOS Desktop app instead of the web instance for better compatibility and security. Click Download to download it.",
          tray.image,
          null,
          {
            caption: "Download",
            action() {
              window.open(
                "https://github.com/IzK-ArcOS/ArcOS-Frontend/releases",
                "_blank"
              );
            },
            suggested: true
          },
          {
            caption: "OK",
            action() {
            }
          }
        );
      }
    });
}
const isDesktop = () => DESKTOP_MODE == "desktop";
function getCPU() {
  const cpu = {
    cores: navigator.hardwareConcurrency || 4
  };
  return cpu;
}
const GPU_VENDOR_REGEX = /(intel|nvidia|sis|amd|apple|powervr)\W? (.+)/i;
const GPU_RENDERER_REGEX = /(((?:radeon|adreno|geforce|mali).+))/i;
const GPU_CLEANUP_REGEX = / ?(\(.+?\)| direct3d.+| opengl.+|\/.+$| gpu$)/gi;
function getGPU() {
  const gpu = {
    supported: "WebGLRenderingContext" in globalThis,
    active: false,
    vendor: void 0,
    model: void 0
  };
  const canvas = document.createElement("canvas");
  const gl = canvas.getContext("webgl2") || canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
  if (!gl)
    return gpu;
  gpu.active = true;
  const info = gl.getExtension("WEBGL_debug_renderer_info");
  gpu.vendor = gl.getParameter(info.UNMASKED_VENDOR_WEBGL);
  const renderer = gl.getParameter(info.UNMASKED_RENDERER_WEBGL) ?? "";
  const vendorMathes = renderer.match(GPU_VENDOR_REGEX);
  const modelMathes = renderer.match(GPU_RENDERER_REGEX);
  if (vendorMathes)
    gpu.vendor = vendorMathes[1];
  gpu.model = modelMathes ? modelMathes[1] : renderer;
  gpu.model = gpu.model.replace(GPU_CLEANUP_REGEX, "");
  return gpu;
}
function getMEM() {
  const nav = navigator;
  return { kb: (nav.deviceMemory || 1) * 1024 ** 3 };
}
const defaultNetwork = {
  downlink: 0,
  effectiveType: "0G",
  rtt: 0,
  saveData: false,
  online: false
};
function getNET() {
  const connection = navigator.connection;
  if (!connection)
    return defaultNetwork;
  return connection;
}
function getDeviceInfo() {
  return {
    gpu: getGPU(),
    cpu: getCPU(),
    mem: getMEM(),
    net: getNET()
  };
}
const colors = "red,orange,yellow,green,aqua,blue,purple".split(",");
const ArcFetch = {
  keyword: "arcfetch",
  async exec(cmd, argv, term) {
    term.std.writeLine("\n");
    await graphic(term);
    term.std.writeLine("");
    colorBar(term);
  },
  description: "Show system information"
};
async function getItems(a2) {
  const info = getDeviceInfo();
  const desktop2 = isDesktop();
  return Object.entries({
    Server: `${getServer()} @ rev ${minArcAPI}`,
    Username: get_store_value(UserName),
    Processor: `${info.cpu.cores} cores`,
    GPU: `${info.gpu.vendor} ${info.gpu.model}`,
    Memory: `~ ${formatBytes(info.mem.kb)}`,
    Mode: (desktop2 ? `Desktop` : `Browser`) + ` (state ${CurrentState.key})`,
    Reference: a2.referenceId
  });
}
function colorBar(term) {
  term.std.write("\n                            ");
  for (let i2 = 0; i2 < colors.length; i2++) {
    term.std.writeColor("[██ ]", colors[i2], "white", true);
  }
}
async function graphic(term) {
  const items = await getItems(term);
  const graphicParts = [
    "        ",
    "    _   ",
    "   /_\\  ",
    "  / _ \\ ",
    " /_/ \\_\\",
    "        ",
    "        "
  ];
  for (let i2 = 0; i2 < graphicParts.length; i2++) {
    term.std.writeColor(`  [${graphicParts[i2]}]    `, "blue", "white", true);
    if (items[i2]) {
      term.std.writeColor(
        `[${items[i2][0].padEnd(12, " ")}]: ${items[i2][1]}`,
        "purple",
        "white",
        true
      );
    }
    term.std.writeLine("");
  }
}
const ATConf = {
  keyword: "atconf",
  async exec(cmd, argv, term) {
    const data = {
      name: "arcterm.conf",
      path: term.env.config.configPath,
      data: await readFile(term.env.config.configPath),
      mime: "application/json"
    };
    FileLoaders.editFile.loader(data);
  },
  description: "Edit ArcTerm configuration"
};
const img0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABIAAAAKICAIAAACHSRZaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAiSSURBVHhe7cEBDQAAAMKg909tDjcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALhTAzCGAAGNmWH9AAAAAElFTkSuQmCC";
const img01 = "" + new URL("img01-a6458b53.jpeg", import.meta.url).href;
const img02 = "" + new URL("img02-b03be002.png", import.meta.url).href;
const img03 = "" + new URL("img03-87b2d378.png", import.meta.url).href;
const img04 = "" + new URL("img04-9d473c5a.png", import.meta.url).href;
const img05 = "" + new URL("img05-3c6c1958.png", import.meta.url).href;
const img06 = "" + new URL("img06-e2fa3f96.jpg", import.meta.url).href;
const img07 = "" + new URL("img07-788d74d9.jpg", import.meta.url).href;
const img08 = "" + new URL("img08-feb75f17.jpg", import.meta.url).href;
const img12 = "" + new URL("img12-c9a4396e.png", import.meta.url).href;
const img13 = "" + new URL("img13-0a31c489.png", import.meta.url).href;
const img14 = "" + new URL("img14-54c8328b.jpg", import.meta.url).href;
const img15 = "" + new URL("img15-ddfd765d.jpg", import.meta.url).href;
const img16 = "" + new URL("img16-f0145d13.jpg", import.meta.url).href;
const img17 = "" + new URL("img17-ebfd7073.jpg", import.meta.url).href;
const img18 = "" + new URL("img18-b02e721d.jpg", import.meta.url).href;
const img19 = "" + new URL("img19-ed01403f.png", import.meta.url).href;
const img20 = "" + new URL("img20-bfa396d5.jpg", import.meta.url).href;
const img21 = "" + new URL("img21-28e5e7c5.jpg", import.meta.url).href;
const img22 = "" + new URL("img22-6a722732.png", import.meta.url).href;
const img23 = "" + new URL("img23-88193330.png", import.meta.url).href;
const img24 = "" + new URL("img24-9bad1e4d.jpg", import.meta.url).href;
const img25 = "" + new URL("img25-46cff1cd.jpg", import.meta.url).href;
const img26 = "" + new URL("img26-59eb83ad.jpg", import.meta.url).href;
const img27 = "" + new URL("img27-9359e713.jpg", import.meta.url).href;
const img28 = "" + new URL("img28-4e3146f5.jpg", import.meta.url).href;
const Wallpapers = {
  /**ArcOS Team */
  img04: { url: img04, author: "Izaak Kuipers", name: "ArcOS Dark" },
  img05: { url: img05, author: "Izaak Kuipers", name: "ArcOS Light" },
  img03: { url: img03, author: "Izaak Kuipers", name: "Stealth Gradient" },
  img12: { url: img12, author: "Izaak Kuipers", name: "Gradiented Waves" },
  /**SWHFotografie */
  img08: {
    url: img08,
    author: "SWHFotografie",
    name: "Wandelbos",
    source: "Wandelbos, The Netherlands"
  },
  /** Eversiege */
  img21: {
    url: img21,
    author: "Eversiege",
    name: "Flippin' Trees"
  },
  /**Nik Nikovsky */
  img24: {
    url: img24,
    author: "Nik Nikovsky",
    name: "Camp Forest",
    source: "Radków, Poland"
  },
  img25: {
    url: img25,
    author: "Nik Nikovsky",
    name: "Horses",
    source: "Radków, Poland"
  },
  img26: {
    url: img26,
    author: "Nik Nikovsky",
    name: "Glorified Duck",
    source: "Radków, Poland"
  },
  /**SWHFotografie */
  img13: { url: img13, author: "SWHFotografie", name: "Agga" },
  img18: {
    url: img18,
    author: "SWHFotografie",
    name: "Wilhelmina Sunset",
    source: "Wilheminakanaal, Tilburg, The Netherlands"
  },
  img20: {
    url: img20,
    author: "SWHFotografie",
    name: "Stars and Milkyway"
  },
  /**Matteo Scaringi */
  img15: {
    url: img15,
    author: "Matteo Scaringi",
    name: "Corfu",
    source: "Corfu, Greece"
  },
  img19: {
    url: img19,
    author: "Matteo Scaringi",
    name: "Long Exposure",
    source: "Slijpe, West-Flanders, Belgium"
  },
  img27: {
    url: img27,
    author: "Matteo Scaringi",
    name: "Evening Neighborhood"
  },
  /**Kees van Voorthuizen */
  img14: { url: img14, author: "Kees van Voorthuizen", name: "Scheveningen" },
  img01: {
    url: img01,
    author: "Kees van Voorthuizen",
    name: "Mykonos Seaside",
    source: "Mykonos, Greece"
  },
  img02: {
    url: img02,
    author: "Kees van Voorthuizen",
    name: "Sunset in Mykonos",
    source: "Mykonos, Greece"
  },
  /**Saw Ramsson */
  img22: {
    url: img22,
    author: "Saw Ramsson",
    name: "Evening Lakeside"
  },
  img23: {
    url: img23,
    author: "Saw Ramsson",
    name: "Sunny Lake"
  },
  /**Blocky (Cy) */
  img17: {
    url: img17,
    author: "Blocky (Cy)",
    name: "Sunset Sky",
    source: "Fairfield Bay, US"
  },
  img28: {
    url: img28,
    author: "Blocky (Cy)",
    name: "Florida Beach",
    source: "Florida"
  },
  /**Matteo Scaringi */
  img16: {
    url: img16,
    author: "Matteo Scaringi, Izaak Kuipers",
    name: "Login Background - Blurred",
    source: "Corfu, Greece"
  },
  /**Izaak Kuipers */
  img06: { url: img06, author: "Izaak Kuipers", name: "ArcOS Beta Dark" },
  img07: { url: img07, author: "Izaak Kuipers", name: "ArcOS Beta Light" },
  /* img09: { url: img09, author: "Unknown", name: "Login Background" }, */
  img0: { url: img0, author: "Izaak Kuipers", name: "Blank" }
};
const BgCommand = {
  keyword: "bgs",
  exec(cmd, argv, term) {
    const backgrounds = Wallpapers;
    const entries = Object.keys(backgrounds).sort((a2, b2) => a2 < b2 ? -1 : 1);
    for (let i2 = 0; i2 < entries.length; i2++) {
      const [key2, value] = [entries[i2], backgrounds[entries[i2]]];
      const keyStr = key2.padStart(6, " ");
      const nameStr = value.name.padEnd(30, " ");
      term.std.writeColor(
        `${keyStr}: [${nameStr}] by ${value.author}`,
        "purple"
      );
    }
  },
  description: "List ArcOS Backgrounds"
};
const BugRep = {
  keyword: "bugrep",
  async exec(cmd, argv, term) {
    const Regx = argv.join(" ").match(/"(.*?)"/);
    const includeUserData = !switchExists(argv, "no-ud");
    const includeApi = !switchExists(argv, "no-api");
    if (Regx && Regx.length > 1) {
      const text2 = term.vars.replace(Regx[1]);
      term.std.writeColor(
        "[BugRep]: Creating bug report...\n\n[ReportOptions]\n",
        "yellow"
      );
      const opt = {
        includeApi,
        includeUserData,
        title: text2
      };
      term.std.writeLine(JSON.stringify(opt, null, 2) + "\n");
      const id = await sendReport(opt);
      term.std.Info(`Created with id [${id}]. Thank you!`);
      return;
    }
    term.std.Error("Unable to submit report: syntax invalid!");
  },
  description: "Create a bug report.",
  syntax: `"<[body]>" (--[no-ud]) (--[no-api])`,
  hidden: true
};
const Cd = {
  keyword: "cd",
  async exec(cmd, argv, term) {
    const path = `${term.path}/${argv.join(" ")}`;
    const req = await getDirectory(path);
    if (req == false) {
      return err(term, path);
    }
    const dir = req;
    if (dir.scopedPath.includes(".."))
      return err(term, path);
    term.path = dir.scopedPath;
  },
  help(term) {
    term.std.writeColor("[NOTE]: Capitalization matters.", "yellow");
    term.std.writeColor("Example: [cd] ../Documents", "blue");
  },
  description: "Change directory",
  syntax: "[<path>]"
};
function err(t2, p2) {
  return t2.std.Error(`Can't change to "${p2}": Path not found`);
}
const Clear = {
  keyword: "clear",
  exec(cmd, argv, term) {
    term.input.current = null;
    setTimeout(() => {
      term.std.clear();
      term.input.unlock();
    });
  },
  description: "Clears the screen"
};
const Colors = {
  keyword: "colors",
  exec(cmd, argv, term) {
    const str = argv.join(" ").trim() || "The quick brown fox jumps over the lazy dog.";
    const colors2 = [
      "gray",
      "white",
      "red",
      "orange",
      "yellow",
      "green",
      "aqua",
      "blue",
      "purple"
    ];
    for (let i2 = 0; i2 < colors2.length; i2++) {
      term.std.writeColor(`${colors2[i2].padEnd(10, " ")}: [${str}]`, colors2[i2]);
    }
  },
  description: "Print out all ArcTerm colors",
  syntax: "([sample?])",
  hidden: true
};
const Config = {
  keyword: "config",
  exec(cmd, argv, term) {
    const e2 = Object.entries(term.env.config.getConfig());
    for (let i2 = 0; i2 < e2.length; i2++) {
      const str = e2[i2][1].toString().replaceAll("\n", "\\n");
      const key2 = e2[i2][0].padEnd(20, " ");
      if (e2[i2][0] === "gooseBumps")
        continue;
      term.std.writeColor(`# [${key2}]: `, "blue", "white", true);
      term.std.write(`${str}`);
      term.std.writeLine("");
    }
  },
  description: "List configuration options"
};
const Desktop$2 = {
  keyword: "desktop",
  exec(cmd, argv, term) {
    if (term.app)
      return term.std.Error("You already are in the ArcOS desktop!");
    if (get_store_value(previouslyLoaded) && !getSwitches(argv)["force"])
      return term.std.Error(
        "The desktop may not be initialized twice in one instance. Please use [RESTART]."
      );
    applyState("desktop");
  },
  description: "Switch to Desktop"
};
const Dir$4 = {
  keyword: "dir",
  async exec(cmd, argv, term) {
    const path = term.path;
    const dir = await getDirectory(path);
    if (argv[0])
      return specific$2(argv[0], path, term);
    all$2(dir, term);
  },
  description: "List the contents of the current directory",
  syntax: `<[path]>`
};
function all$2(dir, term) {
  const subdirs = sortDirectories(dir.directories);
  const files = sortFiles(dir.files);
  for (let i2 = 0; i2 < subdirs.length; i2++) {
    const subdir = subdirs[i2];
    term.std.writeColor(
      `-- --- ----, --:-- <directory> [${subdir.name}]/`,
      "blue"
    );
  }
  for (let i2 = 0; i2 < files.length; i2++) {
    const file = files[i2];
    const date = dayjs(file.dateModified || 0).format("DD MMM YYYY, HH:mm").padEnd(19, " ");
    const size = formatBytes(file.size || 0).padEnd(12, " ");
    term.std.writeColor(`${date}${size}[${file.filename}]`, "blue");
  }
  if (subdirs.length == 0 && files.length == 0) {
    term.std.writeLine("This folder is empty.");
  }
}
async function specific$2(path, currentPath, term) {
  if (currentPath != ".") {
    path = currentPath + "/" + path;
  }
  const dir = await getDirectory(path);
  const subdirs = sortDirectories(dir.directories);
  const files = sortFiles(dir.files);
  if (dir.scopedPath == void 0) {
    term.std.Error(`The directory doesn't exist in this path.`);
    return;
  }
  for (let i2 = 0; i2 < subdirs.length; i2++) {
    const subdir = subdirs[i2];
    term.std.writeColor(
      `-- --- ----, --:-- <directory> [${subdir.name}]/`,
      "blue"
    );
  }
  for (let i2 = 0; i2 < files.length; i2++) {
    const file = files[i2];
    const date = dayjs(file.dateModified || 0).format("DD MMM YYYY, HH:mm").padEnd(19, " ");
    const size = formatBytes(file.size || 0).padEnd(12, " ");
    term.std.writeColor(`${date}${size}[${file.filename}]`, "blue");
  }
  if (subdirs.length == 0 && files.length == 0) {
    term.std.writeLine("This folder is empty.");
  }
}
const Echo = {
  keyword: "echo",
  exec(cmd, argv, term) {
    const Regx = argv.join(" ").match(/"(.*?)"/);
    if (Regx && Regx.length > 1) {
      const text2 = term.vars.replace(Regx[1]);
      term.std.writeLine(text2);
      return;
    }
    term.std.Error("Unable to echo: syntax invalid!");
  },
  help(term) {
    term.std.writeColor("Example: [echo] I <3 ArcOS!", "blue");
  },
  description: "Echo a string.",
  syntax: `"<[string]>"`
};
const End = {
  keyword: "end",
  exec(cmd, argv, term) {
    const reason = argv.join(" ").trim();
    if (reason)
      term.std.writeLine(reason);
    return false;
  },
  description: "Quit ArcTerm"
};
const Err = {
  keyword: "err",
  async exec(cmd, argv, term) {
    term.std.writeLine("\n");
    const input = await term.std.read(
      "Are you sure you want to proceed? This WILL hang ArcOS. Y/N [",
      "]",
      1
    );
    term.std.writeLine("\n");
    if (input != "y")
      return term.std.Error("Aborted.");
    term.std.Warning("Goodbye.");
    window["document"] = fromBase64("!#");
  },
  description: "Simulate an error to be picked up by svelte:head",
  hidden: true
};
const Exec = {
  keyword: "exec",
  async exec(cmd, argv, term) {
    const path = term.path;
    const fn = argv.join(" ").trim();
    const dir = await getDirectory(path);
    for (let i2 = 0; i2 < dir.files.length; i2++) {
      const file = dir.files[i2];
      if (file.filename != fn)
        continue;
      await term.scripts.runScriptFile(file.scopedPath);
    }
  },
  help(term) {
    term.std.writeColor("[NOTE]: Capitalization matters.", "yellow");
    term.std.writeColor("Example: [exec] mwomp.txt", "blue");
  },
  description: "Execute ArcTerm commands from a file",
  syntax: "<[filename]>"
};
const Exit$2 = {
  keyword: "exit",
  exec(cmd, argv, term) {
    if (!term.app)
      return term.std.Error(
        "can't close ArcTerm: no associated app in constructor"
      );
    closeWindow(term.app.id);
  },
  description: "Quit ArcTerm"
};
const Goose = {
  keyword: "goose",
  async exec(c2, argv, term) {
    if (argv[0] != "bumps") {
      await Default$1.exec(c2, argv, term);
      return;
    }
    if (!term.env.gooseBumps) {
      return dummy(term);
    }
    return await gooses(term);
  },
  description: "GooseBumps 👀"
};
function dummy(term) {
  const parts = [
    "                                   ___",
    '                               ,-""   `.',
    "                             ,'  _   e )`-._",
    "                            /  ,' `-._<.===-'",
    "                           /  /",
    "                          /  ;",
    "              _          /   ;",
    ' (`._    _.-"" ""--..__,\'    |',
    ' <_  `-""                     \\',
    "  <`-                          :",
    "   (__   <__.                  ;",
    "     `-.   '-.__.      _.'    /",
    "        \\      `-.__,-'    _,'",
    "         `._    ,    /__,-'",
    `            ""._\\__,'< <____`,
    "                 | |  `----.`.",
    "                 | |        \\ `.",
    "                 ; |___      \\-``",
    "                 \\   --<",
    "                  `.`.<",
    "                    `-'"
  ];
  parts.forEach((part) => {
    term.std.writeLine(part);
  });
}
async function gooses(term) {
  term.std.Warning(
    "Super duper secret thingy approaching! Welcome to the GooseBumps."
  );
  term.std.writeLine("\n");
  const options = {
    "(Cancel)": "$cancel",
    "Change State": "state",
    "Print Colors": "colors",
    "Dump UserData": "udd",
    "Dump Logs": "logdump",
    "Submit Test Bug Report": "bugrep",
    "View base report info": "repinfo",
    "Crash ArcOS": "err"
  };
  const cmd = Object.values(options)[await term.std.select(Object.keys(options), "orange")];
  if (cmd == "$cancel")
    return;
  term.std.writeLine("\n");
  const arg = (await term.std.read("Arguments: [", "]", 128)).split(" ");
  const result = await term.commandHandler.evaluate(cmd, arg, false, gooseBumpsCommands);
  return result;
}
const Goto = {
  keyword: "goto",
  async exec(cmd, argv, term) {
    const sectName = argv[0];
    const sect = term.sect.get(sectName);
    if (!sect) {
      term.std.Error(`Can't find section ${sectName}`);
      return false;
    }
    await term.input.processCommands(sect || [], `<Sect ${sectName}>`);
    return false;
  },
  description: "Goto a section"
};
const Help = {
  keyword: "help",
  exec(cmd, argv, term) {
    if (switchExists(argv, "count"))
      return term.std.writeColor(
        `ArcTerm has [${term.commands.length}] commands.`,
        "aqua"
      );
    if (argv[0] && !argv[0].startsWith("--"))
      return specific$1(argv[0], term);
    all$1(term, !switchExists(argv, "list"));
  },
  help(term) {
    term.std.writeColor("Example: [help] help", "blue");
  },
  description: "Display a list of built-in commands",
  syntax: "([command?])"
};
function all$1(term, short) {
  const cmd = term.commands.sort((a2, b2) => {
    return b2.keyword < a2.keyword ? 1 : -1;
  });
  if (short)
    return term.std.writeColor(
      `[${cmd.map((c2) => c2.keyword).join("  ")}]`,
      "aqua"
    );
  for (let i2 = 0; i2 < cmd.length; i2++) {
    const a2 = cmd[i2].keyword.toUpperCase().padEnd(15, " ");
    const b2 = cmd[i2].description;
    term.std.writeColor(`[${a2}]${b2}`, cmd[i2].hidden ? "purple" : "orange");
  }
}
function specific$1(command, term) {
  const c2 = term.commandHandler.getCommand(command);
  if (!c2 || c2.keyword == Default$1.keyword)
    return term.std.Error(`${command}: command not found.`);
  if (!c2.help) {
    term.std.writeColor(
      `[${c2.keyword.toUpperCase()}]: ${c2.description}`,
      "blue"
    );
    term.std.writeLine("\n");
  }
  term.std.writeColor(`Usage: [${c2.keyword}] ${c2.syntax || ""}`, "blue");
  term.std.writeLine("\n");
  if (c2.help)
    return c2.help(term);
}
const History = {
  keyword: "history",
  exec(cmd, argv, term) {
    if (argv.includes("clear"))
      return clear(term);
    const hist = term.commandHandler.history;
    for (let i2 = 0; i2 < hist.length; i2++) {
      const index = `${i2}`.padStart(3, "0");
      term.std.writeColor(`[${index}]: ${hist[i2]}`, "yellow");
    }
  },
  help(term) {
    term.std.writeColor("Example: [history] <clear>", "blue");
  },
  description: "Show the command history",
  syntax: "([clear?])"
};
function clear(term) {
  const len = term.commandHandler.history.length;
  term.commandHandler.history = [];
  term.std.writeColor(
    `[SUCCESS]: History cleared, ${len} items removed.`,
    "green"
  );
}
const If = {
  keyword: "if",
  async exec(cmd, argv, term) {
    const regex = /\[(?: |)\"(?<e1>.*?)\"(?: |)(?<mode>!=|==)(?: |)\"(?<e2>.*?)\"(?: |)\](?: |)(?<cmd>.+)/gm;
    const str = argv.join(" ");
    const r2 = regex.exec(str);
    if (!r2 || !r2.groups) {
      term.std.Error("Invalid statement!");
      return false;
    }
    const result = r2.groups;
    const split = result.cmd.split(" ");
    const command = split[0];
    split.shift();
    async function doIt() {
      return await term.commandHandler.evaluate(command, split, true);
    }
    if (result.mode == "!=" && result.e1 !== result.e2) {
      return await doIt();
    }
    if (result.mode == "==" && result.e1 === result.e2) {
      return await doIt();
    }
  },
  description: "Test a condition to execute some code"
};
const InDesktop = {
  keyword: "indesktop",
  async exec(cmd, argv, term) {
    const is = isDesktop();
    term.std.writeColor(
      `[STATUS]: You are ${is ? "in the Desktop app" : "in the Web version"}`,
      "aqua"
    );
  },
  description: "Check if you are in the desktop app or not"
};
const Kill = {
  keyword: "kill",
  exec(cmd, argv, term) {
    const appId = argv[0];
    if (!appId)
      return term.std.Error("Missing application ID.");
    const window2 = getWindow(appId);
    if (!window2)
      return term.std.Error(`${appId}: app not found.`);
    closeWindow(appId);
    if (term && term.std)
      term.std.writeLine(`Closed ${window2.info.name}`);
  },
  help(term) {
    term.std.writeColor("[NOTE]: Capitalization matters.", "yellow");
    term.std.writeColor("Example: [kill] SettingsApp", "blue");
  },
  description: "Terminate a program",
  syntax: `"<[appId]>"`
};
function collectLogsBySource() {
  const logs = get_store_value(LogStore);
  let sources = [];
  let items = {};
  for (let i2 = 0; i2 < logs.length; i2++) {
    const logItem = logs[i2];
    if (!sources.includes(logItem.source)) {
      sources.push(logItem.source);
    }
    items[logItem.source] = Array.prototype.concat(
      items[logItem.source] || [],
      [logItem]
    );
  }
  return items;
}
function compileStringLog() {
  const result = [];
  const logs = get_store_value(LogStore);
  for (let i2 = 0; i2 < logs.length; i2++) {
    const item = logs[i2];
    const caption = LogLevelData[LogLevel[item.level]].capt;
    const time = dayjs(item.timestamp || 0).format("HH:mm:ss.mmm");
    result.push(`${time} [${caption}] ${item.source}: ${item.msg}`);
  }
  return result;
}
const LogDump = {
  keyword: "logdump",
  async exec(cmd, argv, term) {
    const filename = `LogDump-${Math.floor(Math.random() * 1e9)}.txt`;
    term.std.writeColor(`Writing log to [${filename}]...
`, "purple");
    get_store_value(LogStore);
    let str = "-- [START OF LOG] --\n";
    str += compileStringLog().join("\n");
    const b2 = new Blob([str], { type: "text/plain" });
    await writeFile(`${term.path}/${filename}`, b2);
    term.vars.set("ldout", filename);
    term.std.writeColor(`
Wrote [${str.length}] bytes.`, "purple");
    fbClass.refresh();
  },
  description: "Dump the log to a file",
  hidden: true
};
const Logout = {
  keyword: "logout",
  exec(cmd, argv, term) {
    if (term.app)
      return term.std.Error("This command requires ArcTerm Mode");
    localStorage.removeItem("arcos-remembered-token");
    UserName.set(void 0);
    term.dispose();
    setTimeout(() => {
      term.initialize();
    });
  },
  description: "Logout ArcTerm Mode"
};
const Ls = {
  keyword: "ls",
  async exec(cmd, argv, term) {
    const path = term.path;
    const dir = await getDirectory(path);
    if (argv[0])
      return specific(argv[0], path, term);
    all2(dir, term);
  },
  description: "List the contents of the current directory",
  syntax: `<[path]>`
};
function all2(dir, term) {
  const subdirs = sortDirectories(dir.directories);
  const files = sortFiles(dir.files);
  for (let i2 = 0; i2 < subdirs.length; i2++) {
    const subdir = subdirs[i2];
    term.std.writeColor(`[${subdir.name}  ]`, "blue");
  }
  for (let i2 = 0; i2 < files.length; i2++) {
    const file = files[i2];
    term.std.writeColor(`[${file.filename}  ]`, "aqua");
  }
  if (subdirs.length == 0 && files.length == 0) {
    term.std.writeLine("This folder is empty.");
  }
}
async function specific(path, currentPath, term) {
  if (currentPath != ".") {
    path = currentPath + "/" + path;
  }
  const dir = await getDirectory(path);
  const subdirs = sortDirectories(dir.directories);
  const files = sortFiles(dir.files);
  if (dir.scopedPath == void 0) {
    term.std.Error(`The directory doesn't exist in this path.`);
    return;
  }
  for (let i2 = 0; i2 < subdirs.length; i2++) {
    const subdir = subdirs[i2];
    term.std.writeColor(`[${subdir.name}]`, "blue");
  }
  for (let i2 = 0; i2 < files.length; i2++) {
    const file = files[i2];
    term.std.writeColor(`[${file.filename}]`, "aqua");
    return;
  }
  if (subdirs.length == 0 && files.length == 0) {
    term.std.writeLine("This folder is empty.");
  }
}
const Mkdir = {
  keyword: "mkdir",
  async exec(cmd, argv, term) {
    const p2 = term.path;
    const dir = argv.join(" ");
    const name = `${p2}/${dir}`.replaceAll("//", "/");
    await createDirectory(name);
    term.std.writeLine(`Directory '${dir}' created.`);
  },
  help(term) {
    term.std.writeColor("Example: [mkdir] Private Photos", "blue");
  },
  description: "Create a directory",
  syntax: `"<[name]>"`
};
const oa = {
  keyword: "oa",
  exec(cmd, argv, term) {
    const ws = get_store_value(WindowStore);
    for (let i2 = 0; i2 < ws.length; i2++) {
      if (ws[i2].info.custom)
        continue;
      term.std.writeColor(`Opening [${ws[i2].id}]`, "orange");
      openWindow(ws[i2].id, true);
    }
  },
  description: "Open all apps"
};
const Open = {
  keyword: "open",
  exec(cmd, argv, term) {
    const appId = argv[0];
    const window2 = getWindow(appId);
    if (isDisabled(appId))
      return term.std.Warning(`Not opening disabled app [${appId}]`);
    if (!window2)
      return term.std.Error(`${appId}: app not found.`);
    openWindow(appId, true);
    term.std.writeColor(`Opened [${window2.info.name}]`, "purple");
  },
  help(term) {
    term.std.writeColor("[NOTE]: Capitalization matters.", "yellow");
    term.std.writeColor("Example: [open] ArcTerm", "blue");
  },
  description: "Open a window",
  syntax: `"<[appId]>"`
};
function getJsonHierarchy(object, hierarchy) {
  const parts = hierarchy.split(".");
  let currentObj = object;
  for (let i2 = 0; i2 < parts.length; i2++) {
    if (!currentObj[parts[i2]])
      return null;
    currentObj = currentObj[parts[i2]];
  }
  return currentObj;
}
function setJsonHierarchy(object, hierarchy, value) {
  const parts = hierarchy.split(".");
  let currentObj = object;
  for (let i2 = 0; i2 < parts.length - 1; i2++) {
    const key2 = parts[i2];
    if (currentObj[key2] === void 0) {
      currentObj[key2] = {};
    }
    currentObj = currentObj[key2];
  }
  currentObj[parts[parts.length - 1]] = value;
  return getJsonHierarchy(object, hierarchy);
}
const BANNED$1 = [
  "content",
  "disabled",
  "opened",
  "parentId",
  "snapped",
  "fileMimes",
  "fileExts",
  "id",
  "overlays",
  "errorOverlays",
  "disabledWarning",
  "events"
];
const Poke = {
  keyword: "poke",
  exec(cmd, argv, term) {
    if (!argv.length || argv.length < 3)
      return term.std.Error("Missing arguments");
    const appId = argv[0];
    const hierarchy = argv[1];
    if (!isLoaded(appId))
      return term.std.Error(
        `Can't change property of [${appId}]: App not loaded!`
      );
    if (!hierarchy)
      return term.std.Error("Missing hierarchy");
    if (BANNED$1.join("|").includes(hierarchy))
      return term.std.Error(
        `Not permitted to change property [${hierarchy}] of [${appId}]`
      );
    const ws = get_store_value(WindowStore);
    const window2 = ws.filter((a2) => a2.id == appId)[0];
    const currentValue = getJsonHierarchy(window2, hierarchy);
    if (!currentValue && typeof currentValue === "undefined")
      return term.std.Error(`Can't find [UserData.${hierarchy}]!`);
    argv.shift();
    argv.shift();
    let newValue = argv.join(" ").trim();
    try {
      newValue = JSON.parse(newValue);
    } catch {
    }
    setJsonHierarchy(window2, hierarchy, newValue);
    for (let i2 = 0; i2 < ws.length; i2++) {
      if (ws[i2].id == appId)
        ws[i2] = window2;
    }
    WindowStore.set(ws);
    term.std.writeColor(`Updated [WindowStore.${appId}.${hierarchy}]`, "blue");
  },
  description: "Poke app properties"
};
const Read = {
  keyword: "read",
  async exec(cmd, argv, term) {
    const switches = getSwitches(argv);
    const prompt = switches["prompt"] || "?";
    const key2 = switches["var"];
    let max = switches["max"];
    const mask = switchExists(argv, "mask");
    try {
      if (!!max)
        max = parseInt(max);
    } catch {
      return term.std.Error("--max must be a number.");
    }
    if (!key2)
      return term.std.Error("Missing variable: use --var <variable>");
    const value = await term.std.read(`${prompt} `, "", max || 100, mask);
    const setter = term.vars.set(key2, value);
    if (!setter)
      term.std.Error("Unable to set variable: it is read-only!");
  },
  help(term) {
    term.std.writeLine("Command parameters:");
    term.std.writeColor(
      "--[var] <[variable]>      The variable to write to",
      "blue"
    );
    term.std.writeColor(
      "--[mask]?               Masks the input (like a password)",
      "blue"
    );
    term.std.writeColor(
      "--[prompt]? <[string]>    The prompt to display to the user",
      "blue"
    );
    term.std.writeColor(
      "--[max]? <[number]>       The maximum input length",
      "blue"
    );
    term.std.writeColor("", "blue");
  },
  description: "Read user input to a variable",
  syntax: "--[var] <[variable]> --[mask]? --[prompt]? <[string]> --[max]? <[number]>"
};
const Reload = {
  keyword: "reload",
  async exec(cmd, argv, term) {
    term.reload();
  },
  description: "Reload the ArcTerm configuration"
};
const RepInfo = {
  keyword: "repinfo",
  async exec(cmd, argv, term) {
    const data = {
      ...createReport({
        body: "This is what a report sent to the Reports server may look like",
        title: "Example report",
        includeApi: true,
        includeUserData: true
      })
    };
    if (switchExists(argv, "json")) {
      const json = JSON.stringify(data, null, 2);
      term.std.writeLine(json);
      if (switchExists(argv, "file")) {
        const filename = `${term.path}/repinfo_${(/* @__PURE__ */ new Date()).getTime()}.json`;
        const blob = new Blob([json], { type: "application/json" });
        await writeFile(filename, blob);
        term.std.Info(`Written RepInfo to [${filename}]`);
      }
      return;
    }
    data.userdata = "UserData {...}";
    data.log = `LogStore {${get_store_value(LogStore).length}}`;
    const entries = Object.entries(data);
    for (let i2 = 0; i2 < entries.length; i2++) {
      const entry = entries[i2];
      const key2 = entry[0].padEnd(23, " ");
      const value = entry[1];
      if (value && typeof value === "object") {
        term.std.writeColor(`[${key2}]:`, "yellow");
        const subEntries = Object.entries(JSON.parse(JSON.stringify(value)));
        for (let j2 = 0; j2 < subEntries.length; j2++) {
          const key22 = subEntries[j2][0].padEnd(18, " ");
          const value2 = subEntries[j2][1];
          term.std.writeColor(` --> [${key22}]: ${value2}`, "yellow");
        }
        continue;
      }
      term.std.writeColor(`[${key2}]: ${value}`, "yellow");
    }
  },
  description: "Display information in a bug report",
  hidden: true
};
const Reset = {
  keyword: "reset",
  async exec(cmd, argv, term) {
    term.std.writeLine(
      "Are you sure you want to reset ArcOS?\nThis will not affect any ArcAPI data.\n\n"
    );
    const confirmed = await term.std.select(["Yes, reset it", "No, abort"], "red") == 0;
    if (!confirmed)
      return term.std.Error("Reset aborted.");
    localStorage.clear();
    location.reload();
    await sleep(3e3);
  },
  description: "Reset local ArcOS instance"
};
const Restart$1 = {
  keyword: "restart",
  exec(cmd, argv, term) {
    if (CurrentState.key == "desktop")
      return restart(false);
    term.std.writeColor("[RESTART]: Terminating NOW.", "green");
    setTimeout(() => {
      location.reload();
    }, 1e3);
  },
  description: "Restart ArcOS"
};
const Rf = {
  keyword: "rf",
  async exec(cmd, argv, term) {
    const path = term.path;
    const fn = argv.join(" ").trim();
    const dir = await getDirectory(path);
    for (let i2 = 0; i2 < dir.files.length; i2++) {
      const file = dir.files[i2];
      if (file.filename == fn) {
        const contents = await readFile(file.scopedPath);
        if (!contents)
          return term.std.Error("Could not read the file.");
        if (!file.mime.includes("text/"))
          return term.std.Error("Not attempting to read non-text file.");
        const d3 = arrayToText(contents);
        term.std.writeLine(d3);
        return;
      }
    }
    term.std.Error(`The file doesn't exist on ArcFS.`);
  },
  help(term) {
    term.std.writeColor("Example: [rf] mwomp.txt", "blue");
  },
  description: "Read a file from ArcFS",
  syntax: "<[filename]>"
};
const DEFSIZE = 20;
const Ri = {
  keyword: "ri",
  async exec(cmd, argv, term) {
    const args = getSwitches(argv);
    const file = args["file"];
    const url = args["url"];
    let size;
    try {
      size = parseInt(args["height"]);
    } catch {
      size = DEFSIZE;
    }
    term.std.writeLine("\n");
    if (file)
      return await displayFile(term, file, size || DEFSIZE);
    if (url)
      return displayUrl(term, url, size || DEFSIZE);
    term.std.Error("Missing parameters.");
  },
  help(term) {
    term.std.writeColor(
      "Example: [ri] --url https://tinyurl.com/arcoslogo",
      "blue"
    );
  },
  description: "Display image from ArcFS or URL",
  syntax: "(--[file]) <[path]> (--[url]) <[url]> (--[height]) <[height]>"
};
async function displayFile(term, fn, height) {
  const path = term.path;
  const dir = await getDirectory(path);
  for (let i2 = 0; i2 < dir.files.length; i2++) {
    const file = dir.files[i2];
    if (file.filename == fn) {
      const contents = await readFile(file.scopedPath);
      if (!contents)
        return term.std.Error("Could not read the file.");
      const blob = arrayToBlob(contents, file.mime);
      const url = URL.createObjectURL(blob);
      term.std.writeImage(url, height);
      return;
    }
  }
}
function displayUrl(term, url, height) {
  term.std.writeImage(url, height || DEFSIZE);
}
const Rm = {
  keyword: "rm",
  async exec(cmd, argv, term) {
    const p2 = term.path;
    const dir = argv.join(" ");
    const name = `${p2}/${dir}`.replaceAll("//", "/");
    if (!dir.trim().length)
      return term.std.Error("Missing filename");
    try {
      await deleteItem(name);
    } catch {
      term.std.Error(`Unable to delete "${dir}"`);
    }
  },
  help(term) {
    term.std.writeColor("[NOTE]: Capitalization matters.", "yellow");
    term.std.writeColor("Example: [rm] mwomp.txt", "blue");
  },
  description: "Delete a file or folder",
  syntax: `"<[name]>"`
};
const Run = {
  keyword: "run",
  async exec(cmd, argv, term) {
    const path = term.path;
    const fn = argv.join(" ").trim();
    const dir = await getDirectory(path);
    for (let i2 = 0; i2 < dir.files.length; i2++) {
      const file = dir.files[i2];
      if (file.filename == fn) {
        term.std.writeLine(`Opening ${fn} (${file.size} Bytes)`);
        o$2(file);
        return;
      }
    }
    term.std.Error(`The file doesn't exist on ArcFS.`);
  },
  help(term) {
    term.std.writeColor("[NOTE]: Capitalization matters.", "yellow");
    term.std.writeColor("Example: [run] arcterm.conf", "blue");
  },
  description: "Run a file from your ArcFS account.",
  syntax: `"<[filename]>"`
};
async function o$2(f2) {
  f2.scopedPath;
  const file = await openUserFile(f2);
  WindowStore.set(get_store_value(WindowStore));
  if (file == true)
    return;
  openWithDialog({ ...file, anymime: true });
}
const Servers = {
  keyword: "servers",
  exec(cmd, argv, term) {
    const servers = getAllServers();
    term.std.writeLine("\n# | Server");
    term.std.writeSeparator(20);
    for (let i2 = 0; i2 < servers.length; i2++) {
      const server = servers[i2];
      const ac = getAuthcode(server);
      term.std.writeColor(`${ac ? "[#]" : " "} | ${server}`, "orange");
    }
    term.std.writeLine("\n");
    term.std.Info("Servers marked with a '[#]' indicates a protected server.");
  },
  description: "List saved servers"
};
const Set$1 = {
  keyword: "set",
  async exec(cmd, argv, term) {
    const key2 = argv[0];
    const Regx = argv.join(" ").match(/"(.*?)"/);
    if (!Regx || Regx.length < 2) {
      const deleter = await term.vars.delete(key2);
      if (!deleter)
        term.std.Error(
          "Can't delete variable: deletion isn't allowed or the variable is read-only."
        );
      return;
    }
    const value = Regx[1];
    const setter = await term.vars.set(key2, value);
    if (!setter)
      term.std.Error("Can't update variable: the variable is readonly.");
  },
  help(term) {
    term.std.writeColor('Example: [set] color "green"', "blue");
  },
  description: "Set a variable",
  syntax: `<[key]> "<[value]>"`
};
const Shutdown$1 = {
  keyword: "shutdown",
  exec(cmd, argv, term) {
    if (CurrentState.key == "desktop")
      return shutdown();
    term.std.writeColor("[SHUTDOWN]: Terminating NOW.", "green");
    setTimeout(() => {
      applyState("turnedoff");
    }, 1e3);
  },
  description: "Turn off ArcOS"
};
const SleepCommand = {
  keyword: "sleep",
  async exec(cmd, argv, term) {
    try {
      const duration = JSON.parse(argv[0]);
      if (typeof duration !== "number")
        return term.std.Error("Invalid duration.");
      await sleep(duration);
    } catch {
      term.std.Error("Failed to parse duration.");
    }
  },
  description: "wait for a given amount of milliseconds."
};
const SoundBusCommand = {
  keyword: "soundbus",
  description: "SoundBus CLI",
  exec(cmd, argv, term) {
    switch (argv[0]) {
      case "play":
        play(cmd, argv, term);
        break;
      case "stop":
        stop(cmd, argv, term);
        break;
      case "list":
        list(term);
        break;
      default:
        term.std.Error("Missing or invalid subcommand.");
    }
  },
  help(term) {
    term.std.writeColor("[play] - Plays the specified sound.", "aqua");
    term.std.writeColor("[stop] - Stops the current playing sound.", "aqua");
    term.std.writeColor("[list] - Lists playable sounds.\n\n", "aqua");
    term.std.writeColor("Example: [soundbus] play ...", "blue");
  },
  syntax: "SOUNDBUS <[subcommand]> <...[arguments]>"
};
function play(cmd, argv, term) {
  const sound = argv[1];
  const valid = ArcSoundBus.playSound(sound);
  if (!valid)
    term.std.Error(
      `Can't play sound [${sound}]: the sound could not be found.`
    );
  else
    term.std.writeColor(`Playing sound [${sound}]`, "blue");
}
function stop(cmd, argv, term) {
  const sound = argv[1];
  const valid = ArcSoundBus.stopSound(sound);
  if (!valid)
    term.std.Error(
      `Can't stop sound [${sound}]: the requested sound is not playing.`
    );
  else
    term.std.writeColor(`Stopping sound [${sound}]`, "blue");
}
function list(term) {
  const sounds = ArcSoundBus.getStore();
  for (let i2 = 0; i2 < sounds.length; i2++) {
    const sound = sounds[i2];
    const id = sound[0].padEnd(32, " ");
    const source2 = sound[1];
    term.std.writeColor(`[${id}]${source2}`, "blue");
  }
}
const StateCommand = {
  keyword: "state",
  exec(cmd, argv, term) {
    const state = argv.join(" ");
    if (!state) {
      const s2 = CurrentState;
      return term.std.writeColor(
        `Current state: [${s2.name}] (ArcOS.state.[${s2.key}])`,
        "purple"
      );
    }
    applyState(state, false);
  },
  syntax: "<[stateId]>",
  description: "for debugging -- forcefully change the state",
  hidden: true
};
const BANNED = ["acc.enabled", "acc.admin", "devmode", "valid", "statusCode"];
const SUD = {
  keyword: "sud",
  exec(cmd, argv, term) {
    if (!argv.length || argv.length < 2)
      return term.std.Error("Missing arguments");
    const hierarchy = argv[0];
    if (!hierarchy)
      return term.std.Error("Missing hierarchy");
    if (BANNED.join("|").includes(hierarchy))
      return term.std.Error(`Not permitted to change data of [${hierarchy}]`);
    const udata = get_store_value(UserData$2);
    const currentValue = getJsonHierarchy(udata, hierarchy);
    if (!currentValue && typeof currentValue === "undefined")
      return term.std.Error(`Can't find [UserData.${hierarchy}]!`);
    argv.shift();
    let newValue = argv.join(" ").trim();
    try {
      newValue = JSON.parse(newValue);
    } catch {
    }
    setJsonHierarchy(udata, hierarchy, newValue);
    UserData$2.set(udata);
    term.std.writeColor(
      `Wrote ["${newValue}"] to [UserData.${hierarchy}]`,
      "blue"
    );
  },
  description: "Set UserData parameters"
};
const UDD = {
  keyword: "udd",
  async exec(cmd, argv, term) {
    const filename = `./UserDump-${Math.floor(Math.random() * 1e9)}.txt`;
    term.std.writeColor(`Writing UserData to [${filename}]...
`, "purple");
    const b2 = new Blob([JSON.stringify(get_store_value(UserData$2), null, 2)], {
      type: "text/plain"
    });
    await writeFile(filename, b2);
    term.vars.set("uddout", filename);
  },
  description: "Dump the userdata to a file",
  hidden: true
};
const source = "UserLogic: UserData watch";
let commitTimeout;
function commitUserdata(v2) {
  if (!v2)
    return;
  clearTimeout(commitTimeout);
  committingUserData.set(true);
  if (get_store_value(UserName)) {
    const changed = setUserdata(v2);
    unsetStatus();
    if (!changed) {
      Log(source, "Commit failed, setter returned false", LogLevel.error);
      if (!get_store_value(BugReportData))
        commitFailed();
    }
    return;
  }
  unsetStatus();
  Log(source, "Not committing, no username", LogLevel.warn);
}
function unsetStatus() {
  commitTimeout = setTimeout(() => {
    committingUserData.set(false);
  }, 1500);
}
function commitFailed() {
  BugReportData.set([
    true,
    {
      icon: "person_off",
      title: "User data commit failed",
      message: "The user data could not be saved. This happens if the<br>user data is altered while ArcOS is running.",
      details: "UserLogic: UserData watch: setter returned false",
      button: {
        action: () => {
          applyState("fts");
        },
        caption: "Reset"
      }
    }
  ]);
}
class Cache {
  constructor(id, initial) {
    __publicField(this, "_data");
    __publicField(this, "id");
    this.id = id;
    if (initial)
      this.set(initial);
  }
  set(data) {
    this._data = data;
  }
  get() {
    return this._data;
  }
  clear() {
    this.set(null);
  }
}
const UserCache = new Cache("UserCache", {});
const committingUserData = writable(false);
async function getUsers() {
  const cache = UserCache.get();
  if (cache && Object.entries(cache).length)
    return cache;
  const server = get_store_value(ConnectedServer);
  if (!server)
    return {};
  const users = await apiCall(server, "users/get", {}, null, null);
  let obj = {};
  const arr = users.data;
  for (let i2 = 0; i2 < arr.length; i2++) {
    obj[arr[i2].username] = arr[i2];
  }
  UserCache.set(obj);
  return obj;
}
async function deleteUser() {
  Log("userlogic/main.ts: deleteUsers", `Delete users`);
  const server = get_store_value(ConnectedServer);
  const token = get_store_value(UserToken);
  if (!server)
    return;
  apiCall(server, "user/delete", {}, token);
  if (CurrentState.name == "Desktop")
    restart();
}
async function setUserdata(data) {
  const server = get_store_value(ConnectedServer);
  if (!server)
    return false;
  const req = await apiCall(
    server,
    "user/properties/update",
    {},
    get_store_value(UserToken),
    null,
    JSON.stringify(data)
  );
  if (req.valid) {
    Log(
      "userlogic/main.ts: setUserdata",
      `Userdata committed to API`,
      LogLevel.info
    );
  }
  return;
}
UserData$2.subscribe(commitUserdata);
const pfp1 = "" + new URL("1-ce0ed19a.png", import.meta.url).href;
const pfp10 = "" + new URL("10-a17f4986.png", import.meta.url).href;
const pfp11 = "" + new URL("11-0772df5b.png", import.meta.url).href;
const pfp12 = "" + new URL("12-e9d77a32.png", import.meta.url).href;
const pfp13 = "" + new URL("13-0dcda114.png", import.meta.url).href;
const pfp14 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAALdElEQVR42uzRMREAIAwEsAcZ+LfCgg8GXKCi1yWxkLHPu0lWWjBTAgECECAAAQIQIAABAhAgAAECECAAAQIQIIDP3llHt5F8Wfh7Vd0tNMiWZcbQMC0zMzMz47/LzMzMvDvMzMw8GQyzKZYtVne99bF0frYTZeJkd8jWPecmZnjfg6o6Ktnjg5YIp0m1XQHvddDVGFDFVCrYxSW8hTx2qYCpVEG18X6RNoD3ItuD49P03P0gI3/+D0z+8u+y7Wd/jW0/t+xf+g0mfvcPGf7nfyPz2OMEs7MAYEy7Bf1/BN8WimTueZDsrXcT33tgJdtFHRgBz4AnYAUNLC6dpDI+ysInfSILn/wpVIaGQARU2xVwPsH38osM/e2/MPJnf0dq95vYahVrBLEWXbFp/m9BZKU1pd55m6Frr2bqT/+A3N234y3mQUwbwLkGX+oRfdfcTPbGOxo93hiKIrxglD2iOAAF0BZzwpE4dJDhq/+T8X/6G9Jv7QbVd58PbQCCilmxCSv07H6UvjvvQOohIkIF+APf8TVBxLcGjkeMYgAQWPc/QAOERCFdLz3PxD//NX0P34uplM8EoQ3Aq+TpPP4qg6/dxI4Hf5+pZ/6SQOdBBAGmBW6wylGBF41yp3FEcnaoGCGYm2b45v9h+Jar8RfmW0FoAwhKc2T3PMjIi1fTu/dh/GgBkwUABTqAnQ4M0AnsVMGwQYnBVCv0PX4/Y9f/K/HjR06F0AZQ6pnk4Cd8D2997k9z7OKvptqZQ7IKnqJARuHX6obfWfaf1yxfHwkogG58OescXa89z9gN/0zq0J5TIbSHcOQnyQ9eyv5P/sEVEPNXfSakfVBFgV0q/GRo+OZI6ERQAIQNSwAgve8tRm/6t+X/3wCkDWBViqhDjWVx4BL2fdGPMfdZnw0iALimI0A5F+n6ShAheXQ/o7f9Bx37dgPSBnCqxDnqHd2c+KZvoLx9EpzjvCSAyOksxJCYPsLIXf9Nx4E3QKQNoBWEysQos1/+RWgQsGGJQs3BUh3ma3CyBqUIIj1tLsRnjjB839WkDr/TGkL7LAjyn/nJK1Ugzp21zUhCMX01WCjDiWUfX/bREhwpNV5eqn8MhNKshBOHGHngmuX/D54GoQ3AKbVcH/lP+QT0bAdsRrGjdaS7Dk7BrWETOShHcLLaqIhatK4Sksf2MfzwdcROnlgHoQ0AUGsoXHUZYWfHmQ/WVJCUIt0RCmBpLQWqESzWkYoD9GMQOg6/xdDjN+MX8mshtAGIUyojQ9T7+5AzAWi2H7UKFiR2lr4WKZRDqLrVtwFd+15i4Lk7sNUyiNAG0FSUTlHry8K7AfAUADwgdTaqgCpSc1B36wZ/z5tPkd39MBKFANAGoKjnEaWTZw2qGMAA3QqWs0sVCRWiJgQRTFgj98oDdO97AQDaAARUkXp4ljIRxDZBZIAEoGf/2qq6ZnenIIJXKTD44p2kp/eCSLsF2XIZf3YekDPucrUmiAhigBRIDpANAgZQXf2SIsTy08sQ7iBYmgORrQtARQhOzBA7dgKVFsFqSquAA/EBAzKikAKUDUpAZBWaCOkTexjYfS+2XgFkawJgBcA0tlKEhIWUB2kfkhYCA0ZAFKqClgUTAwToBJlQ8DYCQQFAAE+AplEy+5+nZ9/ToG6LAlDFKxaQuEAmBtkYDCRgOAVjaRhNQi6BxnzcosV4YAIAkBGQMQXDRpZFgICRJgQAMGGV3FsP0TGzB0S25gyQMETWHq4ZwBOIW+gKYCiBTnUQJTtRNdgEiAd4INsUGXNgAd3ALBAB36xCEENQPMnAm/eu/I/I1gOgnoe2mr+6JnYxg4slcS6OeGBTIBbwQSYcMhlCUgEFlTVdR4GmBQAwTbhmFUp6di+5vY9gojqIbK0ZEKWSYC3r1BKIIQo7ULWYAGy6CcGC5CLMZBXpq0EsAgEARaDpNVqtMKEppefwc/S+8yS2WETFgMjWmAH1TDcuFmxomEYuQaQdACsQvE5WB3PcIX1VTH8BySw7VkJMFagDEahbX1YJ27AIINh6maFXbmf8un+g+9UXMLUqKmZzAxCg3ttL2NkJ6IY+I9RuItIAiAdeR8MmAAzgOSReRZJLmOAkVmYx9ROY2iwSFoAQUBBZXXE1ZRKO7uKbjP/X3zJ6w7+TPvQO4hyIbOIK6O6iMjyE6EYAKIqlbvuIbCcgIGBijWrwO8GmwcRBfBDPISZEtIZEFcSVEa0gJgIDWIGUB3ELACLoWBqvK6T32YeZvPqvGXzk5sZRNoDI5gPgEgmKu3ahxgLKRqT41IN+6okcamMAIIr4YBPgpRswvK6mO8EmIqzUMK7SAGIVfK/hlAe+ARQCg27vgrRPsDBL/5N3MnnbP5Dd/Ri2UkBFNtkqyBgKl15C2N0Fyoal4hHGe6llxql3DxIlOlHPBxUQAQNiBLEG8Q1m2VZCvGoRm5/Hzs1i5heQQhXqCiIAoEC3j06kUWtBlcTMQYYfv47xx/6TzuNvIi4Ckc1xQUNUKU1MULjwQjLPPolybkcMzovjkknwcphaDdkzjxSrqBUwFsQ0Amksag2IBWegatBIoFIDzzQtAIDAUAIWa7AUgggmqtN16FWShaPMb/9EZic/mVqiB9CPNgBUiZJJ5j7zs+h48zVsvQRyHg9NsR4u7UNWYG4RhDWbLgMiQPNlBESacHyE6JT1r0LMwmga3VtA1AEKIviVRfr3PkS6eJATU5/FYs9OVCygH907YqLK0qWXsvDxnwgAel4gG87GoNMDtGlavAyoUuoZ4fhFX0AYS4Pq6V8vE1D4+CuYu+TTqHYPNGGxAiS9sI+xt24kd+gRbFgG5KMLAFVcPMH0l34ZpYmp1Yw7HwUGemMterSsAe6opXs4dukXcWLnZzM7+SmoOfVkT0AUm64z/SlfyJ4v+WEOfso3MTv1SZQ6hwj9FF69yODBB8gdeRzR6CMMAEAd5ZExjn7NN1Lt6z//E0oBugLw5EywV4J/9MovZ3HoQtR6zGz7NPKDF7f8YsnCcTKzr1DtzDK37RM5dNXXsfeTvpt9l30rh7d/GdPDn0I1ngF0E9ySVGXx0ss57L6N4duuIX7yOKqGc1bcgm+gthaigkIlM8zRT/hy8mOXAAKqKy3o2M7Px6/lSS0dBOy6xMhMv8xC9iJK6SHUWGqJDNVED0tsB9XNdk9YWLj84znwLd9H/oLLUGuRc6kGBaw0vOZxqc4GLExdyYHP/nby45eCyDrwlY6BZQhfRDWZXR9UEWKVeXqWIRgXAYA2viaqm/eidmFqFwe+8fs58oVfT3FwArUeotqEoatuNbWdIs41Au8FLA3v4PBnfSMHP/tbKPWNnZHcUu82jm3/QsJYB+DWAeqa202sPPOe7oY/fE9fLwKqBPk50ofeouPomyTyx/DDAtbUER8ITMOx5uU+Y3EVQ/2wUMqOsjR1EYXRndTTXRu6+C3q6D32HIP778ELS2sCLhyd+HxOjH7mFgKwFgSChDX88hJ+aYGgkl/ZM1hC1EC6O05oA/K1gNBLU7OdhMkOnOcj6Dm0C0E0JHvsWQYOPoBfaxw/iDqWuibZd9G3EPppQLcQgFNgKAKAAKCoQi4bJ3IwN18F4RyD3gpCRGbmZQYO3E+sPI8AoZ9kz8XfRmEZhKjbHEcR5yxVBG2xGW4GXB3C/1WKimE+dwW1WIbckcdI5/fjjMW48P28Kd9WoWuCcqqfRPE4oo5Sx3Cr7G8DUAWU90BK5CVY6p4COFPw2wBQBXkv77hp+wmbWsnzDNneGAO55LIT9GXjxAKLCO+12gASccvwQIKh/iS+J8R8s/xygtHhFD3dMax9Tym0W1C97jg+U+H4dKXF/q3hj5Laf8it3YL+tz06FgAAAAAY5G89in2lkAAECECAAAQIQIAABAhAgAAEDAQgQAACBCBAAAHVjZKnIJJ7jgAAAABJRU5ErkJggg==";
const pfp15 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAO9UlEQVR42u3cBXAcy3YG4P8/3TMLlgwyM+g+vMz4mJn5FYeZizlUGIaiYFGYmZmTy2BfEDMvDXT3iXekzZPKtsC5Wj3YX2MxfnvO6d7RyPyDH1X0cuMIeukB9YB6QD2gryygXnpAPaAeUA+oB9QD6gH1gHqx2NOQiiKq7AFtCAkN6hw1AICNQVFoIdUDIjWEttA97/8HEiNPv3Zh4njaNMbCRCC/jKTsXuloCPd96G9P3faCejlz6+Xa7MDUixcmrlxcnj7sc5oIxirahnvM1Dnl2n2dD//NqTde1mYFUBKIHKzTNF6cPDZx+dLUS+frC32qsDHE7GVB2S7rqG7QoQQU0dwiiyhh4OzEwIWx1zeqcyOnxl+4NDt8plUrkd0fUl2voEIHPue9H/7rM7e/oI1C55qoEkoajygHkCzvn3753MTli/PjJ7JW94dUAdRNnXs+8Hdn73y2UzubZXX60BZSwWwcUujWkCqAuqpz17M3qh2QAAGFFgdZOFGVpO7VkLJfJjqqQZ3XoBSRKII1cL74eCV174ZUUUF7qxNU1WXqs5CnvpXkjcxlWj54sHrqGLzfYkgRydKuDqkCaA91VMHYQ3JXy1vLmWulxrUkrTemV6IjpwbufC2cA7ndIXWlGFIzA6/iTsrusU4Zk8P4z3/E6MtSX4q8k3IUHRuIbh8Mh1deap04UjkxgPz6RhQtKtBqYgntP7zQf2L2lgee6Aypc/WFflXYCJQvMyASHZ2/PXvXc9fXCW2dZ/8r/PovuqSlRkhQPZczGR0qP/HEyffe3XjsoeRG5xtUV6d5UHVCIoqgJW0EmqtDanzgwujrG31zo+fGL79mdui4SwzILxsgopgqvOu9/1jUTvUGUxm0uPJsWFrEseP0ToOHelhBHOnMqJtxp+Mzh0Pq5LrlEwEm0KfaaDWXEp/6yqFD0aGD8EZdFXmwpnbi/N+eOPVLK0PxP/7FT3pfJhXgXgMR6OhcuO+pG+i0QwESvOODptHQF55sF1Fwql7VqQD3v7XygW8+hWAIxfWyOKvLKz5paDWSowcA35p9fK7/7NH+c31ojGo6rulMyBrG1EUvqhp2ocV2rrPZbpAEPPr6+flvjCaHzcjLfmU+eB/69vPcoD37mogK5EpeZz/AMv/tH/BXf2RKJaWGo0fitz+8fFKenPuHxepjVZocStDSRIxK+cpACIYEwJsD6r5OJ4Q6wOHkeTk5aIBOPDRRBTo62j7aMZCIYpD7936sdqBv9k9+U0Ub45fTX31OP/7m5tmDNe/3RXFFg3YGlXOupEFoFXrzQN3XKdIh0LQtgo4GCYp2aASMQAMofEuTaSTjmoxLmLn7Uvb38T21WlSphEa9/M+Pv+GLH/x3WxYNAWsRUL3bFxTFx99M7B7qrGfaWCwEbYFChAz5nKaTbZd0Cm4ZmgPiEJUrevpM64nHq3E1McbX6nHldJ8Y+Hz9khWc6ytsdBdarCs6gELXygaMAWkTuJpm00jG2jT5AkIKALTFEQFKBeAefWTs8gsHarU4beLN71nsO2t8snFBp7q8T9fou19BBKF5yjve888X7nuys2ZtJ1ocWOsgsUCAa2g+jmQc6bhmc/BNQEHTRpHKuo/S1aLzqbl4cfnbvv3xoVf6q5X8jbcthsyQig1pA0H3YKPY0Ul4+7v+9dL9T2xDZ/1Yse0DQEiQTrXLJB3TdAa+BvWAtMmkBLAjEq7bmD6XY0ebx07VoQwtc90eyl0/0H2gdTqDD/6PNss30lk3VkyBItAMbqk9UJKx9uN8EZp11KKiy3TdceN0jDQzAEQU1wld1tdloGt1irlzXRQIJAIM4IuxMlPM2gnk8/AtAGtqrK6rL935gFfcKMrclcEuAt1Y50YL81RnrMzCNYBQoJiNYyVsa2oRqlQFqeQ2x79xeZUAwK4AXdtZ9NcszCmyOc0miw6aRmdhLmZtvHGs7CC01ABjMsRQZ0PGLY24CuT2daeC1um8818GH/zvonYIKa1bmKc6HbR47cK87thxKEzms9ZU/YUXjy4mB+9508qJs4lPZQsjIrQraB/RHSBFlvCOq7XzyNPaHKD1cHVNZ5FMtF3yzRfmmw+F6YrL5pb/9YnBP/unWxH0X/8n/ZbvevbEyabPNzcK6mPvq2QXWowaHG99+5ODD/23LjaQPaPp+E4W5puPKkKW5VHf/7w0WO335bJbWiz/8z+d/PjnrmhmbjyhSQbfBmq3mO5qBZEhz+TY6X957eu+LbxSRZ5Ckx0uzDcfDRpXuVSv5N5GMQJsqYKVegmBW7VYCCH2rhjSusvXB5HwOXXpebqJtTVISqDpFIti10ICNho4mvfvd65tpLmzJ060IKq6iSsI9a7sQwnc9QuoSEGWnlI9StGNw6UrEVver+9+11AUa71eunBp5ZFHxpEaUjfzYXC+osHs+gxSBYk8G8jzvlJ5CV2PiIYsuv2u2WMnWvPzlQsXlquVfKsJDVCdKwVvunHSnoTLK0l6qFSdUQcS3Q7hU3v8WOP4yXrIzJY6nXMd+4LSUlW5yy1G9d6k6REw/38uSXqzrUmqz8W1rAZsQ6dosbxPFYB2YR8Ugpo0OVEAKcAdf1UFDcVQQSiCCxpUBDd/z2vrqHP7VLv1u3lVZK1ToL+5G0RiyWoumc9sSG3FxEdjVK1vGopil9KuuD50q4KUQKt1srOuy053w/PP1Jav1Hwanho6Nzp3tO+gPvaBpdfd2/AtS+6WUZ73A12qIIJIkiNQQ3hs/yy4gpYLz9eWXmrEffLnT9/39CvnIuv8Ap/48TNf/PqXHnjznG/a3akjdXm/dutCcnIVKMSg29HcyZbz5nw+cE6enbr0zMi5A/uTcsX178/L/fyD3764NFsyUdBd8ZHcVdk1ICGy9ERwFTIHuG1XZPW8tF9Yjl4YO10uexiBMSqmVNF6q/TsMwMo+d25/ElcXgG70mKqgCDPDru8P45zDdsjIjQAwlK/5D5qZGVbAg1NwUEDibC4WMauRKGSd86WdaGCIMRVnSw/CMl0J1/SlsVUTLyPUQyKiBEa0rL92IiNFPqq4xAqIcTF2bJutRio3tk0OQxmALd/O9qyYWT7D/rjx5tejbFo0wjFUAxOn20g8NVhUVE1qkKTm9IibdP7KrvSYp12CUyS45B8R5VuImMVtPrIwxPPvHDcB2OiNkm9Fp+/sPL61y2E1MjNr2JUFQCkN7YJkyKUkubJhfk7ZqYebdQuGWnDdQMIUFVkyUkgx45CRLHJPQdft/Sxj17+0z8bTFoWwLnztc985nlrg88NqTstFoCAiuQSJaAP2YGlxVvnZx6Ynbl/aeHOpNWviiju1HqXgICkdRpUQHdqZKz4XB58eGLwlqWx8f2l2F8aXCpFfic6VG0fIt5ELUiKYNPW8cWp22enH5yfva+2MuhyocAYRHEAVNUA3QMiiVbrSIETsPOQ8Gl0ZCA5crwJZUjNdnQKFCFVxEmcQHxIq/Nzt6wsXkV5YH7urlbzoAaIabvEJd9xFBTpNlDa3itGhAdk+5tphQBKtg/vRPO134WSukWxMBibIsoQJKkfnhq5e2zkntHRuxfmLwqPHOg3/X0olVQ1hMDio8xeXkheAB3XUKI41dLWQKqgpQkiNYTY+zIQVpk2KxZATC5xCnGaVxYWzo6P3T4yfO/ExBtrKydCiK3NoyhVTC/X2ExL/dVKtVI2hqpQxZ4BqZJEnh31+T5rc9Xy1qAmhl9MVuJG+lilMrbv4FBwFfWWDNcsz6vFkuHqAWSNg1Njt40O3z08ctfc7KWkdYCEjdIobgmbgBSHJZnnfmG5Xm8k1Wp5X6VkjABQ3bsKyvNDWX7ARrXCawue5uxLS9MHnnvlFydn70iz6Yu3/O2jb/7Zctz0PuqsRDDGSdSEydWVlhZPjY/fOjx0z/jYrctLJ50vGeMim1Yqy2AxVgKDCEES2ml7IUMItUazlaSVclwtl6w1HaauzyDv4iQ9VN03D3CzYjN2ZWIkmZt+fuRnXx6/O/hx1fjx//7UwuLZj378+w2V4hglgOatAzOTrxsduWt4+O6ZqcFm86ACkc1slMalRNf2xAY3vjlUlXI1hGorybLMleKoXI6tMSRUu1pBwQVJk6OQ53DDKI3JmvXW/ESuR0an7gh+gYwB9O+fHnrpocf/5+P3v/nnV6ZeNzn1+pGhe8bGbltcOJPnZUoe2bRcWekUF0MQ7GDPrhCRgjHNcud9ZO1VKWs7TF0AAlQDstZJbHKHXkFKWlsh4MOh3B0QWfv+vI/KlZWnn/jQxPitE2O3NRoHg4o1qbGpjRJVaqAG0+kd7Di61vdtJ9J730rUWhNH5mq6BQQkrVOAxw2ikBAsfG4NJiY/6EPVsBlAXW0F42q1o1dLxkStUrleiFOVQc3aR+88JNdESa63EoIaQshyNUGtkavZbSASSJJj1/7WcHVYkEFswlLDlPgfl3/oysQPGFlW5boLPmmMMyYLgRqk+MBtlz83MKy3AICggQSFAhaFtPqCMVKEXbrKlUTSOgo1QFh3X1GNSRG12ivRwi0jw2966cW3zc7cGtnlENZk1t+0CrOOeP1bCSg7ngS18yZtB4SCIFikABAaEWvaENashrIattPNVayzmU6PBVcGoGrEpGJbUFNfvjA2+sjwK2+bmb6t1eqnSeJoyQdRYJVyPcE6EoJKLQhWFdYefenLCSmy+vOLFWOtMda0H1kxIqb9iEU2SHd5mV8HJMjTo6AzpXlolDROTk0+NDL0junJexrNA4pgTKNSWfQBwVswUKFY27V0HKCqof0vaKdBWMS0w8KiDRFZa420OURkFULAjQTrH+ue/82q6uq9jZOTYx80Eo0OfWhq8sF6fSAEGJOVyyuFC4OaoEGhGgqIVYrVB1AIMfJ/RWEKC1NUx+q8IEGuQSg6tFo8CtDO6/ll+3fzqgihfTgHkQAm7ec9Q/BB0cbQtTohSaEhCw+x0mmJ9gPXKVxTDvjSgCL2MvZmUAlrtRjMzrelrAhjAjQsIlyNyGpH8Nqm6BxYy0aFjR/1lQbUWdRBkVjkBps6haJDoDe2RvfTFaBrvPAVkd5/0dUD6gH1gHpAPaAeUC89oB5QD6gH1APqAfWAekC9/C8SKX7bqPpkgQAAAABJRU5ErkJggg==";
const pfp16 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAANoklEQVR42uzRQQ2AQBAEwdkLHgDvaEIGTywcqwJ4VCetoOq6jzPJ1s/o9ZZ+7fd8kkYEAIAAABAAAAIAQAAACAAA/RVAAKqS0c+nvbOAbmNJFuitnhmRSWbHYXzMzJ+ZmZmZmZmZmZlxH3OWHmM48QuaZFmsga7/t4/XXp9EcdZe1lyfFh/qq+rqqtMaKw5JBbzvMEI8t0Dt/v3w2KtkXj2HzNdTAe8TBFqvHGHmF/+E+D/eQu+JFj2vNujZf5rgZBk0FfDeQQBV6vtfYOZX/hR7+Axj+64hO7iTzOSnkw9upvBCmWBq4YNOgs8HA1apPfEM83/4T8SzJTbfdCeFoVFsVEdtC3/4NljMw0tvpQFE2wdBUgHvMWpPP8/8H/4j0bkSPWPjDO3cB8ag0QLR9Jtg5F78gatAQ3jpGRqeIdo6kC5BG0aE5guvU/rjfyaeLmF84yY/09MHqoCgUYVo9jGS2hH8wSsJMnvJvziNP10DSQWsHyOEx08x/8f/QnRqGhXI9RcpbtoG1oIqDgSNa0RzT2FbM/jD1xEko+RfOItXbq1LQipAhKRUofQX/0H74HEwIALF8S1kMzkII4gTsHZFQrhANPdWIMEfvQ6/Ysi9dA5pxh/QErzv/N5P+U6gjw8UBDRKKP/T/VTf9CRYBYEgm2PTnqvJ5XvAKqK6ShgiaFQF4+EP7AQbwvQpBEjGekAkjYBLQ2g88wqV/3ocjRMQUIWeviHy2R60HUIYQRQhYQhuRBDHYGOShQPYxjRecRcmUyRzeI7g5GK6BF1ylTs9R/kf3kSyUAHBYYwwMDCCnyi0W9BuOwFYEBMgmTyS70d6hiCfJYmnkZ5+vPHLMARkX5/HW1wzH6TbUI0SKv/7JK3Xj4JhmSDI0VccRwbHkNFJZHwzMjyBFIfcRJMtIEEGPAMIiAd+AS/ejixeQ9CoIn6NKmdQolTABTGG9iuHqT6wHxILgkMt9F55Cz1f9UP42/YgfUXIZMF4rIXQgzc4DEBBQ6LGfprhEUBSAasQwTaaVP77cVfpIiwjnqH/7k8kuOle1kQV4IIJVyRDT+4qwniaxFYBSQWsLrgOUH/by6xCwe8v0nflLSwThWijBpUSuriA1hahWUOjNiQxCOAHkM1hBkYxoztQXyAw+Pke8sFuauHLoDYVsPztrzXc0mMrdTCrv9DZ8W3kBkbQV5/DHn0NfeMIOnsGrZVxk24TMIAxqGfA83DD95G+YTJXfDhKm2j2oFu+gtEi/q6IuN8DBSAV0HrlMM0XD4CwGoF8o4H8wS8Qz5zBffNR8DzU98H3cMNzjxHrgQVVQBWtzGPnT2GGNyGVCnZ6Cj0RELQniW/eAka6vBAT3L6+/Pf/S/u1Y2DOc8Ow5OirNSBsgyosISii4FBdGe51RQCsRYyHN7wFbVex1RKiYJoh8eQA2pPt8jpADOGJ067hhnAeRgz5IO8mEZGVyU4SiOKlYsyNpeJs9b1EEVqeRhtVTL4Iibr3TKlO5sgcWNvlAqyl8fZXiOfKFxTgG5+sn+m844mdiOXJluXJXx4uSWt5BskUEBMsvx4cmVkqzqRLBYiQlKs0nn0VrLIaUCDjBfhegKIXlYiLiAii1dHg5LRa2FoJKfRisj0Qhu49b7aCPzUP0L0CwmMnCadOg3BBMl4GTwxrogqJPT8awhCMj9xyL9z1kZhte5Glz9BsExyeQVoRSDcKsJbmy4ew1QYI5yFLAowYLpHV+cHlhhAxPmbrbhgaRfZeCxjESYrxT5XwZquAdJkAEWy9Qev1Y6B0JOMH65ZLHDsRlObRqcMAyOR2JNcDrSa025hyDX9qDlS7T0A8UyI6dQ6k00cMgQkQhHVjPFDQE4chSZDBUcwVN2H2XofZcTlYwT8+i4QxSJctQeHUWZeEO2FE3C5oXXg+5t6Pw//GH8H/zp/BfMSngAjkCvif87UE3/yT+F/7Q5h91+KdmscsNgDpokrYWsI3zqBh5wRoEHzj8W6jCn39eJ/weci+qzmPXB6iCOIY2iGmVMWbrpCMD4B2QwQIaBQTnZ4GS0dEDEbWIUAE6jXs/gexzz6NfeoB7P3/jE4dAUBPTxH/zk8R/+L3oi++FdNo451dAO2aJUiwrTbx7AIIF0QBIwZjDLqemYlCkv/6O+Jf/j7i3/xR4j/8eexzTy1Hn77yDHrgRWg0oB3hnStDnADdEgGNJrZSozNOwMYSsE2g2YAwhDhCZ6fBWqRvAAaGQAyoQhxj5ipIlIB0SwQ0WthmC+RiAsSNDSHiBgoszjsRZPNIb//qxl61ibQjQLojCdtm2yXgiyNsGOOBAIiLBpIYfB96+8HzQASwrhqWKOmOXZAIaByjSbLG5wRB1r8NveujMVffDAKowuAIBBknxXz8Z2NuvBMtz2Pf9M9IVIc4AQG0CyIABfS99P1Xhb4BvE/8XGTv1VwIJ+YdIwrRN47Dy4+D1S6qAwQQ2aCjDghQr2L3P4Sp10AABfI9yK7LwffRU8ehNIMuzKPHXkeNASPdIUAVTCZAfG+Nz61XgeC2of/5tyQP/CsIYC1m95X43/PzUOgj+d9/wD7232AttFowOYgGHmiXRIDkckgm4GIoiqpubBvaqC0/VhuD8dxjKmUXJXgeAJrPQOB3RwSgiunJYQp5UEA6fcyi6MYzvkOQQh/4PiRL9YEIIIDF9ubQrA9odzTjTD6HN9AH2nkZt2o3FgGqK/dqXWLGDyBsoZXyyvsIdrgPDfwu6QWpIrks/tggCB2xqk7Curainoe5/SPwvvRb8T7nqzGf+PmYm+4Cz0ejCBkYRIbHQAQ8cY04PAN0Sw4IfIItE2AuJsCSaLI+wb0DeJ/+Jci+awBWnX6Q4jDeN/4wTJ8h+fNfIznxGsmmQRC6JAIAjJDZPolks6CdBcR2HQIEtFnHPvMUevhVt+XUxRLLiDgJsnMfjExgBwrYiWI3dUMBhWDrJvyhftDOu6AoiViXgbBN8m9/TvTT30b8E9/kvuk062At9pH/cN3R+Pd/Fn3hLcTbRrHFAqh2kwDFHxkk2L75onVAmETr3wnFMSyW0Okz7kgK+QLUKySP/Cf2v/7WidBmlfiySTQTAHSXAFPIkb9yN3jSsRIOk9CJ2BCFXuTaW8F46KkT6Jk3wPNBDLbYQ7x3AqRLzwXlrt6L1995O9pOQqxaNoLkC8jIBAD2lWegWgYRUIh2T5CMF0G1CwWoktmxmezebR0FhHFIbOMNSdbaoms9JP/+lyvtBwXNBkTX70BzASjdKcD0Fijceg0SeBcsxmIbuzwgCOsmjrGP/hfJX/wmbvkRAVWSLUNEl02CAnTt6WjI33gV/qZRsJxHogmtuMV7BLUggsM3hDfvxg72gGoXC7BKMDlG4dZrQS68E2pEDdTGsI7uaKeji8lEkfCGnSACdPkvZCTw6b33ZuqPv91dCQtZPV/NwMfuuRJvYR6tliEKV/VxEOhgDxwKCPgB9PQh45sI79tJMtYPqqkA1JLds43C7ddR+a/HzssDLV+IP++ryQ5NuLM9evIYeu4UujAHtUVoNdE4Aqsrla7vQzaHm/DiMO53xVt2Ilt3E43laHvPA3U+EHjHP/E5DUzy/sQYWq8dYfqnfp94Zh6EZcTPsOf7fpfxT/mKZWGEIbRbaKsBzbp7jLXLAshkXeEluR7I5SGTAeOhJFQab6HRPoAjFbCCJgmlP/s3yv/4JlBdlTsnPvUr2P19v4MJsmyEVjTFYv1JrLYAgfRaEatzQf/H3k1251awrKL67OO03/SP6IGX0Nmz0Kgt5QJ78YQbR7gImZshPnuIeuOlTpOfRoBDcNeKmP+dv8O22iArp+R2je5heGQrDAy6Y+YMjiD9RbfOk80jmQwgaBRC2IJ6DZe0F+ZcN7Rx704ad+8EoTPpNePE7YhaLx6k+vBbVrWmF+slBv0epFxaPmgLAvLOYUAAq4CCWlAFq4Q37qJ17TgYAdVUwMWr4x6Kn/1xtI+dIvz/gcFRbVdpJSGFII+iFy60lBXELFW8gzQ/5RZc0WWVtUgv2GQtmd1bGfz8T8Ab6AXF0Y5DKu0Kil6yTO3N0fykm4h3jnWY/FRAR3ruupH+T/0Il5xRsCilZpnIxqyJAoFH86OuIbxlNwjvFqkAVSQTUPy0j6T3I24DI4hCPaxTbVXXbs4ZoX3HZbQ/6lrUCUwFrC8fDPQy9CWfSs/t1wNCYi1zzdKaLer2dVupffINxD0+1saoJqhaQAFNBVwyVvHHhxn+6s+icPNVCLgIWGxVOkiD+r4iZz9xC4v5BeqN0zRa52i2Z2lH87SjMlFcI0maWI2cGND0spUXRXGHuHKX73Q/a2qfOkuUxBRz/XjG412p7Rtg+lN3EY7nUbVugAWxgAIWRUGWXudd+kdIGgEdUSXYOsHIN34+/R93D3UJma3OoqqIAgKVK4uc+bQdtCYKoCCACMjyH4DAEoqCrtQLoKmAS1uOPpuhr/gMFrf0UsklNEeynLtzhJOfso3WaA5UAVBAFRRlZXq1wzF5N9JWxCUhAtYSz5dhsUaSSaj3JiQmAbVLhbHBvHMYDyO+uxfxlx77y49FPEDSXtD6f4CnqCpoglULKKoWlhAEWfqsYICl50jajHvvIuDQ9B84vH9QziMtxFJSAamAlFRAKiAlFZAKSEkFpAJS/g9M6LHIZJg5/AAAAABJRU5ErkJggg==";
const pfp17 = "" + new URL("17-662a7167.png", import.meta.url).href;
const pfp18 = "" + new URL("18-240e69f8.png", import.meta.url).href;
const pfp19 = "" + new URL("19-42714701.png", import.meta.url).href;
const pfp2 = "" + new URL("2-73afb162.png", import.meta.url).href;
const pfp20 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAOI0lEQVR42uychZPcSJaHv5eiwgYzz5hxGJeZmXkDjinwmIPv/oNjZr5bZmYettfUbWpjQ3FJyne9itqtCnVry/b2gOz6RWQolI31vkeZAtFfeaHydGmkWcPTqpFGAEYAniKNAIw0AjACMNIIwAjASCMAIwAjjQCMAIw0AjACMJJL3qQMkQUEREYRsOLygfHsoVVDZ+tewjWb+wBURxGwUtIDgj1oMkMjim9hdvz9BEcP4zQX8C6dITj1BBJ1kbDTgyIjANclAR0TmFw+DSke9eBFyMWI0uFv0Ljt+ajr09z/IMH0YxROPopZhGI6TRAzAnBdimM0UkRZRhGl1ucJp3cTrt3K+Bf/E6ylcfsiCMfjyqt+htKjXyI4cwR34TLSbV01iBEABVQh6kInREmnEgXAX/gOtruWxu4X4p87hn9hmrGv/B+2UE48X72AK6/+Wca++gH8mRM49TnQGJARgGWNjoJj0JKLTgbE6x206qLGA+Ni44i4VQMsgsUUY9zWI1QO15l/3luofPczFA9/HdOqU37o88TVSUyrQXfdNmp3v5TJT/wd7twFxMYjAIOGR0DHfeyWCvbWKnZjOTnXggNGAAEBG7YJQ0AtAFRB7rOorWErM7TCbSAxhemHkVaUeHzpsS/R3bgzgVK/5+UJgOo3PgKqT0vr+vTflpIyfOLp+1ctjkns2gJ4BhBA08U3AdCtXQK1LJVDJ3gNROOUpj9AcOQs3lQD01RAUdejdt+r0KCId+EUhZMPY5o1ELkJb0tRkjQT3buO7lt3Eb5oM3ZTGVzTz//KNSrG734GR75Nffe7qb3oXhovnSDcHqCuQaKIsa99EP/sUWr3v4pwzRYw5iZciCnYjSXCV99C+NIt2A0lkJVZQInO48RTuOHDxP5mmjtfT+PFa2jfX8RWDFhLMPUY45/9F+q3vYDmvgdB9SYCIBDvnSB8/XbiA5PgmhU2gEG0jhd+HmPnsDJJt3IHzbt20XxBlXiNh2m38GdO4rRqxJWJxTF5kwAQiA+uJnzlNuz6EihPogQ3+hZ+92NE7r1E3u10t08uQhgj2uRj2g3GvvK/dDdsX6wLr0RF8g9guPFXEb5kCzoePEVhbzF2lqDzP0BEx38b4cZVNJ9bJl7nYTotSr2WNVq18QYGoBDvGCd80RZ0zB9u/BWHcDapC0YvEzmHCDdsofnsMnYMghOPJi1q49BzQeQGBKBg1xWJXrgZnQiepp1KgxMfxQ2/SuTeRWz2EG2u0rq3gjhdyg99Fqc+jy1WQPUGAqCgBYfo2RuSrgdVnj5JLx39J2om6PivobuzQnePi2nVaB54Nt0NO4AbCYBAfGAV8b5JEFZAwk+mGGPPYeIzQJeweBet2zdBaY7ikW/izF8C5AbZilDQ1QWie9eCb0BXwKgiIAYRQVW4emmqO/o2orN0gjfCJNgHW3SD+3EXLuFdOgVI/gFgILp9Fbqu0E89CkgKUnsGbZ2/SucXbBgS12ugynBDKYiDlNcjbpG+BCc+Q6H9r0TuHbTX76H80KeTCzlI7iOgX3jj/RO9E7vUGUVAFTv3BPbKQz86B/2xgWEjsA2LKsOJCSAuzsZ7kUoJsPTVxdgzuJHFsSdxvIcx4SyogOQdgIF43zg64YK1y6cClR6cGNQCAequAXGAbKkoGijosOLThOgKYMFaUAvokig08VmIzxBtFMJNPv7xbs4jQEEnfOzuCmBBs/K99odabPEg3fV/CKYK6LDrNEPkILVvIif/AGwTVEFtdioE1BfCHT7eqRCJNN8RYLeV0Mme96MZxVZ6gDQZasaxwV5whvfiyHAAhFcAD1SXAgBIF3FRog0O8aSDeyECySsA3xDvKIMD0gv7bMspYhVREFWEGO3/zPXfJyTSN7iCaB909i8RbBGizQ7uxSinEaBgJz10gw82ThU0TQWD9OZ688qKSwZBLwGbykYKKkK0yUEfF6Sj+YwA3RSgRQFr0442YPQlXvrkSOkNXaYeaQoSCEI8KcTjBvd8DJI3AK5gFwHgaA+ApG0/MKeg9qoiwBjTv37bO6oqIoK19uoAZNejvlRRH+K1sgggbylIQcsOdk2v+KYLqcogiN65BbIjQETodLscmz5DsRDQbLUpFQu02h0qpSK1RpNdt2yh4PtYVbIhaH8ASDYIBOI1BnVB4rwBmHChbLJ7f9JRkF0DVJVavcGluXn++UMfZ+uGdUydneHWTRs5NXN+0fBbOXxiip9+2xuYHKtSrZQxIlkR0B+pxL+c4gnQgiB1BckLAAFd5aCegsbZvX86J9kBANr3/G4Y8g8f+CjVcpn3vO6VlAoBi56fREK706FULPLgHQf53hPf5+jUKX7+XW+mUiqhfSOnAKSKsGZ9CLBFxVbA1PMUAQ7YVQ7IYPoRYMhCTH84ABEU5RsPPc7lRc/ft+PWxLv377yl/7MDtUCMEMWWcrHAV7/7SJKeHrj9EMYBILUGSKdFAdHlF2Uu2DFgJk8APEHHDagFqymbZ8HQ3qB/VJg+O8PMpctJeikEfmJkAUT6EFQVtXBg13b2bN/GP/zvR/A8l/tvP7jUy1WXB7DcskBIRlwlR12QggYCJUAtoiwxKiJLG0BdvgYsGj3xaiApvB/4zBfYvmXzonEP0Ot+ktTz0OGjvP4lz08K8mJqwnPdIV0QaYsv/f8sYMCWFXVA4pxEgBYM+IrYuB/WOuhl9kfzMgBA7A8GiPaLo6KoKgBWlXqzRbfbZVDdMEzm1dqBbKNIyviSDAUd0usqDEaGFgFHIBcAFCiAOgP9tsrSNlQULAAgqQhg0LgR7cTgJN79/je+GiMCA2nonoP7uWv/XlzXIY5tAkjVHfxVfahWkQEAw5fzoJ4kQzqAPNMBCBAAYkGFVGXLWAtoVgpK0k+1XGKuViPo+Fhrk/TSDcPkGEZRcoziGNdx6HTDpCvyfRdZNgVZ0PgadvQUHEFdASQnKcgbBABgsz+wDkbA0pS8UG9w7uJl/vmDHyfwPWbna+y5dStHTp5i68b1TJ09x7aNGzg9cyE5P3fhUlI3Vo2PocMWYsJVgVCj4Dp5akMV1C7T5WT320AqBSkIHNi5nU3r1mCMwXWcpP9fPTnOutWrGK9WEuOPV8vcunljcr59y6YkFRWDACOyfKelNqP/z/4f1Wh+ImDwQw5fhGXvhgrCoT07kcFgGXoc5KnLpCCArAhIw0qlytxEgCponDJ8JowMAAZEltRlHXoclPTHYA1I784KqXNN702Dao4AxIBVMAqaYXzJSA0KxA2kew7isWHdynC7iAPtC2CjjK0IAc24MGDpHQWx5AeAdBVsyicF0BQEBSS1EMPg1B6m8PjPgfF/LAAbQ9SGoQzCeQhrgx1XZsyALJmWGIhyBICOIrHtG5fBay+pVlOlZ39FevMSt3AajwGgQyJNmoAyXCKA6UdA5m8Xlih0kFByFAEtoGvBTXlSpkUFUTDlCcSYq73km0C2fohqRlFPSwzG85FUg6BD/qLpGCSSHG1Ht0HaihYtaPZOaCo0kOIYUhhLtS0ABmTpz0sUEXtNUJuFaPkptf3oG2pXxTQMkpsUJCAdQRYUnbCgw4wiy1RTBfEg2AAIdGfAhiAp7152axnwxsEpQTgHcQtIX4HTflqywxfCpmbA5igFEYHMCmyx13eHs3jI2jcujjcDBr38QfT8v4DtDBhTlgdQ2YPZ8BrwJtDGcXTmA9C9ktHtKED2DWMCEgnOggNKjlKQglwyEAKuki1dfq6wDVn7NihsBUDWvgWd/wokhdkB6EcAtr+4Mj6y+tlQ3glqkYm7oHkCvfhZEGH4qnwpCGm5mAU3f7elyKyDLBh0dQx6jYs4HBB3gKaL4KCqIAoMbqyl210vlQ8dQEGzoGdwEQUFZ9bFtA1Inh7QEJCWYGYcUK5NItA5jV75CIRXkjyuVz6Otk+AGBiUKSDi9RcUtguzX4f2DNg21I+gC49eJfil5xIJ7oUAYsnhEzIWzGk3AYFcIz3bRs/9DXr01xbHr6Nn/hTixkD+d5BVL0O2/w6y9X1Q2t632/z3sCf/Aj3x59jpvyeBgVyXE5kFD/eKn+N3RTgQ3dvG7g5Buf4NPTGA9PN+5QBm5x9hTZXwBwZfHDr9NxDVBveVfrI3ZFmh8NgY/lQ5x++KiMA55iH168mhAuIkI71uEG89eKtAY0CRYA04xdTPmus3voA76+PNFEHz/JCegFx2MEc9iFkZiaCtY9A8CiKoxmj9KIQLK7iOMfjHy0hSfPMMAMCSADBn3BX6MCYp0nbqj9Ezf4me/Q905oNg2yvTqMeCf7KMeykAAcg1gH5H5DwUIBedlftQzSfQc/8AFz8F4Swr9Yu9s8UEAPZGelJeQGYN7rcC5NJKQZBkKLJyxj9XJDhcRboZZsn5g9pJBLhfDzDnHJ4xEsAK/nSJ4LExTMsBIecAhhRl52sFzPc9CAXkaTV+YvDC4SrBE9nGzz+ANISawf12gPv1AnLBAQvIU/w/RJKknOJ3JvFPVJDQgNws744WIBLMCRf3i8VFGD0QkYA8STCkd+ga3JkChYcmKHxvHOeyD3qzvrhVQBqCHPaQKRddG2M3ReiaGC0reJqGkf2gZdacJfFu03CTbQX3YoCZ95K5DNg38WsrARzQoqJjMTpp0TELFYsWEiCoCwhgwEYxYaMFqqCAFSSWxLjScTCNxVF3cRa8BIB0DSggPFM0+8wBkOXlDuAq6in49CAoGEAVG8egQNw3PpEgkUnOsQCA8P/t3QEGACAMQNFF9z9mAHWEAiDIION9doIHDNsdgCTKSy0qNCudr8/ng4YAABAAAAIAQAAACAAAAQCgfmaEfu131wYAeAuzlsd+jwAAAABJRU5ErkJggg==";
const pfp21 = "" + new URL("21-6ad724fd.png", import.meta.url).href;
const pfp22 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAK60lEQVR42u2c9Vsbe9rG++v7rrsbrvVUca2gdcEtuFuBc07d3V3gCO6aAPGECe6QhHq7S/+KvadTo8bMwByydK7rwXU+1/3oVxaIYjt4+4zxgHhAPCAeEA+IB8QD4gHxgHjjAfGAeEDsjAfEAxJSxgOaQoQQxRCieE1rsrI1VdGaJm9NUYoT1K8+L/xSAVFoQER+qIG4+21P/eUB+akh4tgQcXRQebK36aL223uK47VtGbKX30x8YYCEBJ5cc60YLMYn8g3/zpqYzDTA/kMa3pkg38/SPcwb0h4l7hW257YD6JcBSNghjtcoT1UPao7rn+aABUAA0McNXwKv59nDvYc0V0rESSqQndeAhAQCjfa7u+MTBXhyIKBp+Gb9oz09NVfbMqUko/kJSNjRmqLorroG4TCj80ZNz7P6W8+1Z0vAaB4CEiequ0pvgQ7lU6ytT3QBmQ6M5hsg9ZUS3cM9lHZmYvpn2Z3FtxHI5hEgISEpEI8MHJg5HSoejRsKUAGQIpongOI0XRU3GCCgwahfcgb15P8iIEI81Sj5jI7spSEfBgFb9yBPebKGLLWNHxAJIk7bGqdtEarro6U1keLKiOaK8Ca8rooQ1UZK1LcKUcswQUBLRMj60KYxAyK54J3qSPGtnfcO+exPd4uNXLNlh8AzcImD3+LV/ovXbFnqGukU0Fyden8ya9YBjfQeosoiYwQENI0x8ts7i/K80ncKvL3tFjlbmTlY/AvmSJoJZQ7m//JdYyPTCCcmZ11BWbr7+fKDDcYGiEKjuLb9ZrxT8Hr7JY6WJiCC106Wph+ag7lJkM+y3tHkCbL2mWXTP8lRXywTxRgRIDLofhdcnuoaA8l8kstUQLG7Vg8aUrkAhLjWcfu7FiMBBDRNMcrTgac3L3UGl2nRvAGUFLZ2+H4aF4BgaPSNQkGgUxfVnu+d6WlrD+HQQUOZg5lJhtBp5GG6gRtAmBnNPSBxHIE8BbdytbKghEPf1pqZ7M/z0j/nhA5GJd1V1+c4zUM7NVFtKa5RzlbmTgzpwFxszG5d33L/RTZHgDBvI+tp4ZwBIpCwcjxTXKwsWNBBmg9wtJeqGOR4ppl+XP+VbH8TMv2cKeio32EPGxvKsxgDMjcpyHAfe5yBh+HOuspvop6eA0Cod+7u+g4FMaIyOzqBTvai9qj7zOXDqJ4eG/tGdrBx5iJawDhtRUuEjrtY0rEw9VhocfViIPPwzIbRgOz0zHuOBUzlcybwtLuNDavQY+pqa35k73pkd/blD8OKEatGWEECI+4BUZkrsjVklR87+cDy09wG9KiemToXe8MkF/NcTHU5B0TJ59zm8yzlY24Ss32Vtj+BfeZi3bs+2oOFth8DEFJ7vFMI+nIWed3fwa6hKZyTwEwjGI0O72Od9RfQr5u/D6n0XbSSRWp3sTY7c9xX/5z25JADRlgXokpHrgBhMHgy4LirlSVTOuhLwzcJOgcSqdAzV6Z/nKu+VAoRcQUIY9MM9zjG/mVh6mZnfufWVgahhzMRDXUcI7c8CDkARHXtyF8AxFg+gYKe4WRO5cNgkHaZFBEngMrDGgIWr0W4ZQQI89YLp/05rnoYNLED0tPYBMABoDhtUVDJOjtykMo0eUmUMVwnLwZNrKGAUf/BANCNHXe8bO0BiNFULDnCYfgBNTY0FtMW3Zt9QEhhV7Zd97SxY5rjz53y414+zLwMS6/YTzT3gNB5eS2xrKoJYTwV475obM9ph4i4cLGFTACRYw1VZxz3CZ7x2rT8SP3sAyoKKqVWu+gn+LCA5X1jKUYVgKj2Fckei0KznebDGwOWOEAX9CN0UrgD+4UdLk1bWDj7gOqiJKGr/VEo0geUk+hCzlWNDBDCUFfJrVl2MVhLrCbTPYERoPx09/Gn3DeoLBaFKm5w0qyeCjzpam3JAFAaAGUYIaAuAOJi3FEcWu23eBXCEE1A2Qkuo0bpYp0lt2ffxWBYg090Dse8lWYWSwxdOzTzII0uF4XCi5yXr8n3YTOETtwrQpDmZOR6ccslDxtbjFzpAArxndEGF4DQP8kY644ZrNrSe92754J77zWvgfJNo9oo/aN0EhPrnv5SKTeAYonaqLbw1YEI1TQ7VQURy6ZQhGqeZgy37tbmCxR+f5Y6/lKy8mcSwU8kK34qdfilfOMfiawlQ4079I/T8Z1stlcdauDExSgRnd98HiJCxThtq+G5yLK8PAitBlM6On1yzxlXuffvJct/IhHAfgo0r0wA+wk+L3P/TdehteOjCcwYodUY3N+eJeEIEIxoiJYlOIUAEB0RnTriw2xUBjq6JAhHsvrnlGQ+YSQmyIpIWzQ+FM+A0SQ5nBYnsm9W6c6GAsmq+l/ThqG4oDWDBrpxGvqH13QdcZCs+hmlGjoGmrr7qXTD9vNsnEFjPu5gbicDTnjaTtPcw8t8VtmI2iLpTjwmswert8hcf01ph5YJyKjUX+QDQLS24uu+ku1r5h7Qy213Bd5ZqBun9bWThzbSDZ+GFE2cjWQ5SYe+4ftVQaZ0ghH8qw/+RQ2DuFYQ1Z2h+XD57PYyeNmu9UuJPhoLqpPZw6JdMrffvJEPIxENVmyeNvFj5Ud1vgJb8zgGNCXrt2d5JLpZW4HRZzaTXT4fiDA0LaCei+5vQg9TEXUdXmt4Po1/kdvOyPNSP+4mzvpo2d4N+evsFn8qZmNVfue6JZicTROJnmaQyWvZ/7MD1JFkr3+Y9qlIRB1zVZ2t5GDhkAajZqHqwpaL25d7AsenpHSwwHv8ScZnHkD/KI1IXYRHZQdIHWmhMyR/5vf3Nl6iog8HgOhhKgmtyfZI2mC/DOXPVExkOlsvsC4t3Y1I9GlA6UTGYtYK0kRb6SZSPg4Ipzf6D0q/EkE+c3sUgZQSTmmkukb7LFxBRuh3ttzD0YI2LpOphZ9xtK4Da9gBwk8RWUtRQ32UDnoLxGbQMZbDLE1CJSrJvevzQlf5bbBfiv0OIEWa+b8Sw9ZoB5DRPgboRU5/oQ8KaBaAYD0XPZDmP1Z55mqLCqlzmlwCYo6JWs4v3F18IuB4rmdqnFNQ8EpfnIg6lRs8osv5SFKbzEabrvD9E/M0/xOZ5+9GJCFUmp9CB9vLym6SoUdo3AfqqM1XqAmqI8Q1USLV5eJx3dcQ/4eJjPQyAeNCkcheihgPIu96FrSDzXdYiafocACIA16UieI6lGeqRvrJs7wfiki59e94Zvp0FD5/GpFS8plyupe4WwTtcLQNmHsTEuiJBqRn9M9y3sUEFQxWbqYGHXToyFx/01/k++6P4/VwzyHVmUrsIuf+KALHjFDXEoWFWAsmH+wNpueZAyWBCt8/k4wEn4o7JB1w7LuzUf+ULK9Ig3Am8nFgVZLXSgpnXpybJ19Lv2nprr42Nv415R2vVNAe3JFsL3X+FYmJJPXKqA8xY9QIrYeadoCmYfJlLn+Q3992TnGihrpgaJ7d3UEgDcPjOktuwTuwaxcPPPEiS38/Zah2a+felaogE/mGP8i9fidf/wfVzn9q85cPVmzSGRLxPchTEGBP3RXcJyAm4zExj6/HIfAaJweUp6uRmweUJ0dH9ukeFuge5oyPpYz1xo4SUWM9sePDKeOG3DHd3iHiOLxJfamsfU8b+OLHv5QLlqhxBLbs4vIkTNdRBGuuFxN3vod13CxWXyxXHK2T5LcifiEM45spNF/oHWYUr5Z3jCICm8d3mPHXBPKAeEC88YB4QDwgHhAPiAfEA+IB8fZfZ/srY3Y0xdYAAAAASUVORK5CYII=";
const pfp23 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAC31BMVEXu7u7v7+/w8PDy8vL09PT19fX39/f4+Pjx8fH7+/v9/f3+/v7////29vb8/Pz6+vr5+fnz8/P//v7/+Pb/7+r/4Nf/0cP/xrT/vqv/u6b//Pv/7un/0sT/spv/mHj/glv/eE7/c0j/b0P/bUD/bD//9vP/1sn/qpD/hmD/bD7/az3/9fL/y7v/lnb/dUv/az7/+vn/08b/lnX/ckf/6uP/d03/bT///fz/1Mf/i2f/+ff/wKz/elH/9/T/s5z/r5b/cUX/+fj//f3/+/n/ckb/imb/pIj/kG3/noH/iGT/xbT/x7X/fVX/8u7/+vj/7Ob/wK3/hWD/bkH/m3z/5t//v6z/cET/uaT/49r/l3j/bUH/nH3/knD/jmr/mHn/jGn/6OH/wa3/b0L/vKf/5t7/59//gFn/flb/5Nz/zr//dkz/0sP/pYr/ooX/n4H/oob/eVD/3NH/5d7/2Mz/ybj/3tT/2c7/eE//8e3/sJj/f1j/dkv/glz/t6H/9PD/7+n/iGP/7ej/van/h2L/g13/tqD/+PX/mXr/cEP/xLH/p4z/qI3/uaP/rZP/rJL/9/X/wa7/fFP/xLL/r5f/6uT/6eL/dEj/yLf/4dj/elL/jmv/8Oz/vqr/xbP/w7H/dEn/j2z/8+//oYX/+/r/yrr///7/qo//zb7/oIL//v3/rZT/0MH/o4f/sJf/rpX/9PH/tJ3/e1L/zLz/f1f/tZ//3NL/qY//hV//qI7//Pz/eU//u6f/k3L/z8D/8Ov/3tP/0ML/3dP/lHT/kW//uKL/sZn/p4v/dEr/fFT/dUr/iWX/pYn/lXX/lHP/q5H/6+X/gVv/xrX/08X/jWr/noD/oIP/jGj/c0n/nX//nH7/0sX/l3f/2s7/4Nb/4df/2c3/5+D/6OL/v6v/rJP/flf/49v/t6D/5Nv/uqX/fVT/jmz/0cL/z8H/8u//m33/tp//8ez/yrn/18v/39b/iWSUsVjxAAAG0UlEQVR42uzR1QECQQwEUNYtl3Oj/z5x+MHWcF4BkZnFx/gjlHEhpdqQUnBGSc7hWihjnYMT56xRQpMs05k0Di5yRrLUHVocp1/bUeiU8RLhLpQ6erwFLzZqBREI3lAEd8FKCFKysPMLC4FsEfAErRwEcxX1jsdAFOMZU40QCWuf+dxCNMvj5zdt1w/jNM/TOPRd28RuqC/OX64pqwol12EYOMfMzJezwmldZmbuY2Zm/v95EzhwIhd2OBVU2tX66Pjk9OxcuCAA5EI4Pzs9OT46RDtsDOEX278oyYqgaioAsQCgaqqgyJKI8TCQ6UlEP7rh81MViAugUr/P0BEtDVDrxLonPBAMhSkQFEDDoWDAk7LOv7gVz31F5CiNES5iNCpHPBe3wiXATXA8kSRABgJIMhF3E82hYcLtb6l0hpKhoJl0yu18+JJmXGHZnKCSEaAKuawrdQZ9X1Zd9fMFICMBCnlXh1XsBZplY4o5vD7eIVdks2eRAViGS2kByMgAIV1ieZ4fNkAio5IxoGYS/BEwBiJJSsYCTUZwFnAJlWUyNuTyICFNsCYUjAIZExANspY0wR4xYxJ6iDpWoFJKYZBVaJpKbNCQzhjG1ACKjXDMpq5SrckhP/DFU681lIJqNwsbKM3IhkSfM0CztX1Y0tsdnptm0t3DXv/W7Zg9gk/k7mie2ZBk/+c7d+/ZJ3G/ghvqg4eH1mP66PETq59fYnY0z9NQXLYHeHrkfOg+o6j2n287Af0X9ghynKejuZs/HCmqmf7y1dWX1xcEwZu3VwHvqlaKcnSzzhyPgmMBTNXtXn95/wFhAT5+uo74/MXMEb5ySJhkfOhENdO/9W7c3XdkR/THjYjUTzBHOGH8aBK/gq3HGiHw67dV+c/fVyaRhpfmWOGfydd/RqwBSLIkiJ7CL9Rab+PnIn/HTJ369/mGwR2tbdu2bdu2bdvG2bcO66pX09c11VMdGBReV2Vl5nsvr8fnryLdsxdZll3HXXQmfBQP4PGzZYl6sS7Vu0/ffv0HDAQGZStH4MFDgApDhwWGj5ATMHKUnMF+TzzAR0U/Im9AfpfRYyCXj23KxDXHDYRrfNVEgKojXAhPyBJywsRJACbLh0ABr/KM1Dz2yRjTlNoApmZRLBo1p7kxfVjCEbjyDOS+7kk0cxaA2XNIRtmn5LIKUEJ+FTF3IDCvkXhTEOZHseD//Yc+W4iMyYvodbgX5wBLYrNDJRQANQ1KyiX20mVAmzcVSUZ8+Qr3yqpxCE7VcZOwag69GV/kAz5ebctfS6qJoACUIgnQB1izlt/dR6t16L0+9A6BmnaYh7J9343TBhewUQJQKUMAqgVMkjW7EGF56U2btzCT4xDzlu8GRrdu48KUKO8GBpACoL8iayjQezDH3Xlge050x86CyGefRXbt7rInZ8DeuFHOzgH2OcoV6YNMpYAhfo6Pamj/gXD04KHD644cjFZYd7RmfMx5eBmgFumDrDxT8V0CgPzwomPHKzb2eBpXHF9/kRxKBDgh9M9USTT7ZDR2RYls3Tp12u8/fcZK7KJ8Ngelz9n6RFNKhTg/Cd8eVSscETORWvdS5PQLQl8qlGLH/fMQ3WlMjcTFDFy6zPpip5RrWvQFsCBkClDzCnB1EanlWt9wqJwLrauYsutWXeE6QWrDSdIyxbUcpF83vCNxIxe9bwqlZSZr+hRcB7S5ZXQEWiTnHgiSpulraAvfdiOcYnQEUT6MkXdYQ1t0xIvafiIDZ0JRKfAFcLctaYiXljryvSXI3Fi1eICq3y/DkhTWUEc9+XXS5rtQZn+xMoQveOAamqYlv3r6Tq3uAw8SW6Xa+x8Cj1qRnr7rBQgvniHX7kp6Bq58H2i8mJMLEK2EqncQ6HKTHK08oEZdAE81J7mE0ovAqjc8QIvraZpDcFrHHwDP6qrFi0CNjHWq1vsR2DTfT0VxU6f/T2GgcbWqZjJWI8TnPsrAmtY/t7IEJfSGXya0XoNot7mORogbWglcpVQOUPrX3+ZGLFswyQ8L24rMHfB7aSDnjz9ZYyUYmyFU86hvEuBa0rNUp7/8Uzp3nuJf3KnZ/SUuYNLfF2qS1gwxt3M4td4/sf2wbNOQ5l5v8yGblgFw/XvgcSob2DkGhhRxcO6T+0+XFQ4se9rzydwgk4EhZWapyZhGznY6/uz5g4cPXzx/drzDy4iMuomlZm4KEtuUlhro1SuQmkY201tTMNfAFDS3Nem/gQHhYU36D8wSHlrORh9azsY1tEzXwXH6D+9TPkFB/ykW+k8SUT7NRf+JOvpPNVI+WTrw070IK3gJT1jTdcqd/osG6L/sgf5gFAAAwljXMphbLwMAAAAASUVORK5CYII=";
const pfp24 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAHDklEQVR42u3chXMbSRbH8WNmpoJjZiZ7mUGKzMwOMzOzMcyMZmYWS2NFG9X9O9/zW+iKXVqN7yxX7Yy66hdOJjWfeq1+3e6ZD2G8lSA6GkgDaSANpIE0kAbSQBpI54MNNP14bjQQysVvMO6hb4j2bkn/MBNeAoaSSjEgRRN6RO8gZ86xdTsVlRQUkpcvKSykqpodOzl/kYERwlHFlEJAUi+Hj1JSypIlOBw4nXMiv+lyUVbOiRoGR8UoFYDkPgPTXL1BZdU7EAKUIO/8haXLuH1PKk6YbAmkdHxh6hrIyZlLY8qUn8/ZC4IrRnYFCkaobyQrK76OmZGwnrsodWRboGu3yM0110lgVFDAvYdSRDYDklsaGJG5yVzHzGjlKkanlJFNgGRcHDu5IBoVl4vGMzaqIFU+ZeWqfBZYRDKpjUkR2QUoEuPiZVyuhdKoZGVx865c1iZAwWl278HhSBaQXOrwYcJROwDJQJjysXyFGl/JGWWrihjvkovbAWhonJLSpAItoeQN2rYSNmwB1DdEYWGSgQrf5OZruO9jxKwP1D9MYVGSgQocXH2a3pWEAhiPLQ40MklZWbIryMG1Z2h5nomr1gdyB1i9ZlGAmtLoKifoFiNLAqk2+uBhHI7kAzU/RfOzjJ6yOFAkxo07ZGYtClBTOh15+EfFyMJLjTG3aoWSDTSTpxk+hhG1+HbH2fNkZCwOUDptLnx9GDErb3dMeFm3PilFJEDFb3JDAYkRA7sJR6wJpIxaOyhNQkstQKtf497TQqOAWl/H0ypFZO1N+xu3F9hVi062k5oXVPkoI/o2EA5jPLYyUDjKzbv/996Q6OQ42fcy96V85gK1vMTkHSkiqwKpdHSzeQuZmTgd/4OUS0YWjc/zQETiJY2eZYT8UkTWBpL22s+V6/KxnZs7X6AsJw3P06I44qX5ecYvWRxIGQlTgOZ2du2Z135j1hvU/Jnm9ARAUkSdJQQmxcgmhxei/5nXhqzTRfFT1HyZu3+i6emERs8wWm+j4y+RGBeuJAJyOch+jZJ09nyDug9x6Xs0JS6idDpy8A9LEdkBaDpGSwd5eTid8Qun8m/s/zLHPzmjI2n8BHd+n7iIJEOHMKL2AHqMNyQnYByOOJN61mvs+hb1QqPChW/yMM2kiNqceLsxYhYHUkbd/axYOfv4i5PsTDb+npqPCMqTafgYt35tVkTpDOwgPG0LILUze+iInKTKL6CoiPUbuH6DvgZu/IOGT1I72+jcV3nwLxOg1tdwN0sRWR5IGQUjjE7S3S9YniDSCsQITNGznyu/of5jion6j3DjZ+ZF1LuWUAjjsfWBVOKc4xQmvEN0rOfCD6h7b8Sd+SL3/2EC1PIikzdtAWQeGSm4O2ku5+y3EKMPc+1HApEoaXRXEfSKkc2BVE8QfsT4Pe67OP0lTn2Ge38xGWjNzzF2PmWAFFMozPBFbj3H9Z/z8N9mi48iAhNilCpA6oMp6GP4NF1VND8vEO9r9DQjNbatIHOmkF9W8F2lsgqLvwpJpz0L36D8/ZQCUkySwBSjDXTkikhcpsH9GI9SE0gxvYV/hKHDtC0RI8mTi4838XZixFIWSDFF8fbIOqP1tdlM6fRvIWykMpBKjHBE1hm966RXbEp7r298hakHGDEN9B5TKMTkLbqrpRsSpjR6VhEKSqFpIPX5Ld3A+HnphpqeloZg4poGijvNTUg31J5JV4U6MaOB5k5z+AZlmpu8rSvo/ZnCEWT5GtVAZtWkgeYdDaSBNJAGmrsVrYEUSiRGOIovJGc9xz34wu98STolXyygRKRnC8tzcW1dXL7G0eNs3Ex5BRWVbN7K8ZPy6HhHD+Nu/IaJl1WAzEX8YcbdcttXrgvBDERlJXl5cvrV4VCvF3jn5/Kb+flUVbN1GydruXaTzl4mPCZeFgBSLiJiMOGlq1du70St3GpVldz2bJFEz4Upr8xM8guoXsq2HdTUyVnH7n4mfQSmlZR1gEKPeNhKTZ3cTHW1iMhpO6eJiGmUl9MpFywokIdXd+yitoHWTsJRiwDJ6xVCbNrCm2/OU2SBXvIf7d4rpWQZIG+IjZvUcZZFj8PBrt0aSANpoPlHA2mgDZtkclFT2OLNYk4Hb7xhJSBJMMKtexw4xNp1lJSQkyP3k4wpf9bbu3JyKS1l3QZ53vN+kzX6oLnvcPMEGRrjQTNnzrP/oDzaW1xC9vy9lIiMVoEuKRX0GfpzF2lqZXgCb1BoLNFJJ1iISWa83AEGRrnXxOmz7N3PqtUUF5OdPcvrCRGhnAFdvVZwZ4gftAi3JyiXisTmLMcsBmTuFYzg9sthzbsPaDwjrfCKlRQWUVQscDN8p88J5cCosJqIWBzI3Oud861T4sXAiIgEI/KbcUX0jqJE7yjqPWkNpIF0NJAG0kAaSANpIEvnvy7V3Oc1ANVFAAAAAElFTkSuQmCC";
const pfp25 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAILUlEQVR42u2cA9TkyhLHP1yba9u2bdu2bWUPnnmsZ+uzbc185tq2N5mk379vL8eTZDMzu33O/97VZLby2+rqqupKAo5UEyfi4oA4IA6IA+KAOCAOiAPigN5dcUAcEAfEAQlW4oAYhaM19Of7K8nuCrKjnGwrg+hPdlWQfZX4I3zAy7wCvIVmTyVZXUwm5ZK+6aRNImkQR76NJl9EQvQn9ePob/ZJpx9YVYwPew1TgMFoDlaRtSVkRBZplkA+iyTBYSQghFCF2iiEKiiMfBpJmsaT4VlkTTG9XHgrATE0y4pI91TyZRQJDGVQ3FYIvQTO1S2VLC1kmN4WQOxO1pWQXmlwGdytVn0aQXqmwQ3Zl/s5INwAYu3EXPJ9NO5NT30XTSbk0i8X/BcQTN9cRhfF+2E602HC13ZJIZtKieCPgGD0iiLSOF5/LlZqFEeWFxHB7wAtMJPvY3Rm4WS5zTf5FaB5JvJ1FEw3Tl9FkTkmfwAEV19kJt9E29mn3wsj74ezDd5K+jDCPwncVvBlQDAOWW9tm5X1YTgZlyP/+LjllyctB6st60vleSZ5TI7cO01plajUi1Vwb8gGP6D4NLGrFUNWFhPBNwHBrK3lyI+tjcY9LzDLZffFC0/E80/o/889EU8+EqseiKX3xII7YupNKeyK9Ifz0q9+wLcB+Mzy2By5VxplF+yhHyHn3lpGBB8EtL+K5m+BNhZjuUVclYDmzOPXdPa5wAs6/1znHj/Hd19MvCHNN8ueZgk9Umn1K/gUIFgzJQ9rxE7oaZ6gwE3OAoonYuzAq/Cu2C9d8WitwYxJub7kQaCzvgTr334N1SNNKbnHAKkRnGtjqcXTYITEHcWN4COADmJxpTosMkdly1gvWgAhKnkKiC20A1XeBsTcZ6GZfBLhENAck3zikUo6EOLRfLMaQB9HsF3f24BQLrZLctamWFcqq3YfXAjvw46mLldqm6RDNRug0X3mm8lH4c6s3F9lQaxVDQipANIldYCQf80zeRUQFnmnZGcmInX+xUlNgEx3xZaJKgFBHZJhpJcAsbzZeQ8M+fHvzyMJUh+h029KtWMU1fXHZxFkJWp9b3nQkEzX9RGy5HMaAOFyjXXv4ExveJBQjZMZ9GJcNJJRK6TeVA8Irvf7cxLcUAughnHUVMFgQEeryZJC8lGEC0CtElkarR4QQhgCmZa6H3vI4kIYbLgHjchyfRSBDahUQxqNyhabIL6qQZwyPleekCs3jFMCPWc0PMtwD0JpStOfEBeAkMJoSaNx4doSuU+6gkhU81CEUPcOzPAwZocgIYLBRgFi7rOtHPWOa8uQBJ/UkEYjBf/tKUv8dboPvihfEdQGZyqe9mRhsGAkoBVFyOVdA9pYKqve46HTj8Xjj8DFemtLuykN9YQRTF1eZCAgDBTMyEcL1bVl+6osFyggncUYDctyNx7B1On5MNtAQKOz3Vr8K4plFkreBKN0TxiNyjYQEHx1YIYbm24IzsWUf16keRDrt56jAi8mHRhl3JJGuMMohAzIMG6JQdi/GSB3msQKItFvTln+fF6KvCql35JQXqGdWv1APPVIfMGO4VPHaGS2HOgKECYDDhsG6FAVhjTcBcQGM9AGRdWG/nT9WKVtktI3neY1aOZvKpMPV1uA70/npairUtUDNYwyKSOnfhQCg2G2zwByzstKL/DNKpDRgT6raq1l3ZJGwY80ADJsiakQZTQiW8Hqe0FHHSOctQU6zOmxxLwUpLXTGZWt4PZwkxpjdvZtxsjbQRr75Zgc3dxnSKYVHU2Mcm5j77fNIZGXGJoHIV7oM/WDqbq/XHDSUVPTAPj7RenLKOtJopkFxuZBGFD9NEIzoBA0a7S7j60Tici/Xo0AMHVVsbG12M4KNMP0Gcn472WdPSj0imQ1XlI3luzUVKxq3+k1aFKeXHRP1CsGFd8Tp+bLVn7aje3xRgLCep6aR4L1CEOoJGebdGDE6GAyxKqKhpFT8mCw4R1FTE9+q9PsKu6BZYla2vtAPNdkTQeCkTDV6I4iW2W90mCBnozMqhjhEsCdY02HCUbCVC+di6Fv/0mEnoxmeM6I0cEitbveYR6MFLx5spoCO/RkND1fNlFGHtCB6zmKhp1TYKRXz+bx5MTnkTozmkYZITlyTQfuNtMxHRi2rMirZ/MsEqEuo+WPfgoKI9iqC+6AkQs6cDdHdGASDDvkC/NBW8v1n6gPCiWT8+R8ysg+HSzDaY7pQDCJnmT4yAgeji6/jDKGEaUD54KLBTmmA2NgkuBTU66T8nDIqz+jia8zYnSm5MlBTg55wkHW98aAMak4Mpt88AYY4cQZh4Wsz4+TjElO6cCAUdkwxicHybGh4sD+Qz0YYQOqH6ewEINw2z5ZWVYkLy+SOyQrTujAhUdmwwwDBsk1PHc5Pkfzk4UheBBMweJ6EdfceTgBf+n4XGqA4ONP+6D1O9dE6mhrhgBNk3jF/WIYDQ2MIx72l8eh6Gh5KbxATUhSManZNYVsQDnqd08c7q9E3UAHvJw7gpacu1EcpgTYkxl++1Dv9nJMCWECCn0ffRps7NEzcEew24FU0P8fC2eYUGFh5op26YPUkQrBhbgcOxock6GB3qIXC6Cnt5++dgF7DS2ya8egFwFfYDfvQLTfiI/hw4hoSIhwOXZxfJUvv1hAOymaDVAXWFlMfQGpU5903D/1r1aJEP0Jftk3nYzMoiFmVTFtuR9kXN7Bt79ALBFHrN1HBUdjqTD+yKfe/sLFAXFAHBAHxAFxQBwQB8TFAXFAHBAHxAFxQBwQB8TFAXFA2vR/9QcEJHdEdqEAAAAASUVORK5CYII=";
const pfp26 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAACfFBMVEUAiXsAiHsAiHoAinwBjH0Cjn8CkIADkoEDk4EBjX4DlIMHn4oKqZEMsZcOuJsQvp8RwaESw6MSxKMCj38GnIgLrJMPup0SxaQTyaYUy6gUzKkUzKgBi3wEl4QKq5IQvZ8TyKYFmocMspcSxKQTy6gSy6gRy6gRy6cQy6cAinsEl4UNspcSxqUVy6giy6syy61Jy7JgzLZxzLh8zLqBzLwKqpIdy6o7y69rzLiazMDCzMfgzc3uzc/2zdD7zdH+zdL/zdIFm4cPu50UyqhwzLmzzMTkzc35zdH/ztP/z9T/ytD/yc8Jp48Wy6g/y7CPzL7Zzcv6zdH/z9P+x839usT7pbT4j6P2fpb1cYz0aYbzZIMMsJYTyac1y67hzc3+xMv7qbf3gpnzXn7wQmnuNF7tLVntKFXtJlTtJ1QMsZYOtpofy6puzLjUzcr9zdL4jKHyWXrvN2DtKVYDk4IPuZw4y6+ozML1zdD3g5rwSG3tLFhWy7TPzcn+xcz4kaXxTHDtK1ftJ1UYy6ltzLjlzc3/zdP8sr70ZoTuMFvvKVcZy6l6zLr/zNH6m6zpKVXHJ0zwzdD+yc/4iZ7vOGHuKValJkM5ICb+yM72f5fuMlzqKVVyIzUeHx+KJDwiHyDCJ0s4ICbuMVynzMKoJkToKVW/J0ptIzR+IzjXKFDSKE96IzdwIzTFJ0uOzL7lKVRmIjJ9IzjnKVR0IzYhHx9vIzRwIzUgHx87ICbLJ03vKVbDJ0s1ICU+y7DOJ05uIzQzICQ0ICW3JkjwKVeuJkUxICTYzcvmKVTAJ0qvJkXgKFLdKFLgzcygJUKNJDzGJ0vrKVWLJDw8ICewJkagJUEqughNAAAFa0lEQVR42uzUU7zrWBQG8LVSJtlpjs+5tse2bdu2nsfzPLZt2zPXtm2zaXaS4nSv2Wmv2kkPrp7u93ROsf4L/QVhN2cvILMX2Au0/+O0WwBEUtAPkB+BRLsQUISKWwK0JZ4idgmAVLulNoLwOaAtygaknQWUjiiTQQqAY76xUuwMgJ0iiG6xuo4yIPwBZJzi6jSi3AraUQD7I+ImUSgeipTdIJcvIEo1Ec2mHQIwsv8C1S/PsAoDjkxJ4j7h9ZqSox0ABjQhzpb1WVyp33xi8DQJuCpsPvM6keZS6E+0elZ7AQydMS7sl++PMh6q/5vAI5X89fhE86G/5aldAEYuxX8F6HBkylyiasbW8hLYStiu181KjAIHlBONt3PUDgCjN3/rL/80RJybruuEiK4ABlvCQdGksGJ9vC8R/eGf4sK3s9RmAB/Cj/36FyBOAdYbcaNgUB6u1BDN57A/0Xe+cDU9Q20EMHqvrK+r5+HwmkEoY0FwTJKZsfEY+sFzpPBiltoEYOQWuR/9OkQcdhxipqR8I6wpIWJEQ4+VzAdSuPCtHLUFCF/+j6x/G37PTsH1G6BkOZ0RaHnJoqC2jv7i59MbUrjgzeY2AAN6Vf0t+1cjv50pl1+6nZ4oAVpYuid5il/PyHlyhpOTC2a1CuAJM8MC6i77nZ2POKHstv0LwOyyax9M9D0//Yv1oDQPHEytABg5Zo4Adpk6/MxYciGD0vRUJeAthDKhZ1Xm12O8Lzgo/YbnqGVgAEvMBHZBTI1FY+X9yxM3SGDtGigXjrayGS8jf60DU3xWiwAOWK0K/fTD34mfGp1WqN9zYcmOVPBKNlR8m++b/TN905jfHcVrmkUtAZ3NpAD9jCn1h9hxq1Cgys1uT/SEkv+iWrLwv5k2xq/b/zcHlCpreQuA0k3fAOyIqnmHaouK/Vcj4vqFEJye9Yi4ujhDD3dcn+RoDrXOElEZ6BzNCDjkhhfUw7TCgXt2xA1KzcLlFep3QVzTlCzMwHu6Y7373hsPSiy7vCKAnaMusAEbDDZIsYolwgiI+Hsg0Hgg5vJesngTU8zg9hN3ctCyy6niBF1zAHU9LTgintrc5ACUGb0mELgA0fO8dZsXmEiPBnPheoDI0ooT1LIcMe2Vp1if4oV94SBEHBd8hJ6HZTxv2Zb3zPQ8/shdLlfCfEMFQKlhGWDdDOyip7dVcY6cWvHI+43St70Xd5aRvYRDjG8UwQDUh0GvMUON1WkN2h83vmlN3troQPM6CAZUI0ysADhsBwCuFwCOzbYXCKBqKGBWmbpZDTuWTZZjJS0QtkdBgKIaCHVMAlENdiRuVgJ8PZDtiSAAdQN0jSWYGWI7BPC8xVPcdcB2AicIaQYx7a1HmansICAs/uQtLkfbzQcBYY2RoTHDMA3YsdiWbXPXRu42BwERjYmExljCZDsIcCvFuZtSuJsLAqKaLkyNKU2mXnwUd5u8BtqSRj1afKQ71mrBXUtx3GwAgFEtDqZuaGbCB47vNOkgxA+h9fTv3jAum1nuAynLtR0L0m6WAoCYFgMjwXQzocmuOnearxyMv7Y+w+lr80JkM1n5STdlOTxlQ8bN7FkgeEU9R7d1RREf+K89uzZYIAiDMPwrnl05dIOkSCNoIzRBDZRAjjtEuMuT3RawvvvNvHN3i/wh+2vKH5r7KsBn579rVXDW3esFx5dMX/S9bAlSixUQXkA6MvEbdHbiF8t3b0C8hfIm0NtYb8Tvo4R4+yGUkB4/gRIgDNm1v3yL4hwPpDhS81CQYs3dOWT7EsweouViU6BlA8fv4P16ebeCavEDeN8HFLuI5WcFIhYQEqmYywd1Pmr0YWkYWIcDhAPgtgHMWJmdVvJ1GgAAAABJRU5ErkJggg==";
const pfp27 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAFHUlEQVR42u3cA5zrShvH8a7x8tq2bdu2bdu2bdu2bSOdam3v1sr8bp9r34NumvTM//McrIpvMMlgffhN/V0ZAgNkgAyQATJABsgAGSBTBsgAGSADZIAMkAEyQKbcClRJcCpUPf4KVA0GSCD8VahGeg6g50DaNyfxDv2n0bUzIzfRvDSB/0hNoUCWj9Y1Gb6G3qPJ9WDHyIQB8kPkegGijxN7htF7CE495QFF5qN1dUbvBtBJsPljdP5Hr4FzGDiXyLxTBpDlI/B/Ys/JO88P8s+x0Vl0jt5Dfzw9lTlQ06J070vaz0RF50l+KAddywplDRT4D9En0Bl0lkmIzsm53CpXIFVF0yLEnmWSo9Py4z2HoOrLEah1DTJKWqvJTCZMaLZyBOrYAnuUyU/qEzo2J/Cv8gLq2JrYC8UB0hnyA3Rsg1U+QNUMX08Rkx+hcwdUTVkAqWraNmDsQXSOYkWnyQTpPQp/lfeBQrOQ9jMeGbkNVedxIFUt95zJDyh+8iRelyY/0OhZIMtH2/pkQthxxinZFrlH8+4eJKdSO8b4JfWltI+B/3gRqEJ04i9hRxm/SJM/ROcuWJ4DUrWM3IEDsWN07Y6q8RSQqqF9Y6KPQZ7xjs5Ik993IqraO0DhueXc7GTG7kc1eARI1UivTepTnItN4i16DyfwHy8AtW9GJiJNu8PJdUhvnOV+oK490SmcT9qic3sC/3UzUCVduxJ/WXYf56OzchPbvQ+Wa4FUg9yUljA6SfcBqFpXAqlaOfvEnga7dEBZafL7T0eM3AYUWUjujNyQ6OME/u0yIFVD66qkv6b00STfldHawP9cA2T56NhWdh87gUuS66V5GSzX7EFyatRZ3JNMkM6dCfzfBUCqiu69iL+CTuKe6Cx2lJ6DsUoP9G9puVwYnZGbD1VbUiBVT8eWxJ4HjdsiTX6YgfNQ9aUDal6SbAdoXJv4i3LzUSKgSlqWJ23h5iTfRzr2/1MKoLZ1RcdO8k954dOPjrvjxhPuvKmIVXjAwsNOeJPvNNCP1z72GBOQ4++40bfByr6NVytiFR6w8LBMSJLvEpnPcSBVJz3BE3ZvUdjg8pY2W7OIVXjAwsMyIbGjjD1McBpngZoWk9MzeAAIZOQyNJOzQMHpiD4KtgeAdJbBiwj821mg8BxEn/AEkCQ/QPtGWI4BWT7aN8GOeuQQs0m8S9PiDh9iUzN4CTrlkUPsUlSDw61YAyO3gvbGIZb2E57VWaDAv2WsTidBux0o/a3MzFZ1jgJJhWdn9F4vAFkluFCUCvxfxjPB1UB2XMZ4I/OXAkjVSFdZ7Dl00rVAch6ILIC/snQdZt17ozOuBLIRoAd+bL9KBtS6mqyCy4TAdheQDJCdIh0ype60r5QBlv4zXLQH6Qzk5f4rOC2WS4Z9Wlcn+pQsENTJ0gMl3pTu+rZ1ijKLungzEgONMi0oEybbTLYdSR70eALd/MsyKTQ6TfwFGbzsO0FoLDdOXqihZUWZGD1wDrk+WW6abUUnTrjlBN/GqxcbaPUTbj5OOsNA+hWiT8r/m5eUw0o1uH4KXnAqYQpOLXN0ew844YolfZsUU0dqk7VOuGJRmhen9whpyIP/JzQj/kpPLmY5/tK5fRutXXhLRazCAxYeFuXD8vxiFt8td860xhFLrn3UEkWswgPefOdMqLJYDpX6unL08+qiV+Fhy2hBnSp6uW5JpvnlJqYMkAEyQAbIABkgA2SATBkgA2SADJABMkAGyACZ+g5eG3xTXD3mYQAAAABJRU5ErkJggg==";
const pfp28 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAALQklEQVR42uzWA3crQRQA4Pfrn2qbR81xbLM2Ytt2ptPYdu56x/db/iL/QwMutOWM7fYO+YhJC1N0HCD+QbdX9oyDhjzk4uIjKVlK0p9Slb+IuZH0f4pxeljDZ2/FSX9/0vEWH8cMHOQlleviJWVjyC49pL811QNKES6WsjIkZz6cohe9Il9VLS/J/SKnr6UHj25GgC4AqC2Q9MILQAA0VKCgUghAbYFUAARAAARAfQOtA1AdELseyPcp6RbICndQR6BzAAIgAOoLSMtnb9cARfXcjkCszcSsAgmPg+MBCqkFswxEAKC2QHcEGwB1D9T2PwiAmgIx1lO+DwAaCpAXgLoAkpz7AAiAAAiAhg8UM3J4++EyED6Om9gAVALyknIuyhdTRV3O4lzqckbJUuKUSkUAwrkpO92sePykqy2Kh7SdjlMWEUjF+WoOVIqnsl1coL+1QO+S5iJNgc4ACIC6AvJSkI+Kt4WDuQMyM4VH3+SbBXAbyRKGj/keM8MxY1gyhJmZ4djMzBhmZjPLgjAzM4NZHDmcGLffv5rKbWmtbPIotuSqv1yj0Ux25nNPT3ev818AApSSDCoMoNlDacEo2hpPugJ0it5qoLFpXg0CKEcGlPvvAwKdU0vIrw25P08dn+LV41WaNYQqczmz5rSqRACUTPvXmoGmNQECHRhLdBeeS6enSPYU5/Jsfa9fcl1fpiwPqlahtn8g3bRuRgMiJjzCdPIAO32tBhDczdF51P8XoNPY7XXO/QVyeaah1y9I9jR5fwEjAouayk2GY4e0h4/eKdmGKc4G6OqOs8IU9hdQF3bZANqWQN1f4Vyfuz/hk7oBf2B2xBvUuH9QSbrVbfPbZnI6QBYlwsLN8+/BfcCO8PNghhF7w1e2FvRLwYJAB+rw1AMLss0/nAwQxJnV2kNHERBvXXgX3+Lvw1j/w3wQxDdAKsuT0XFuQEJ1Gck6/5UFH4Vti28xGA5I9Xyd3WKtCBBZIDSUZMolUw4aIkZwNw/ioNEsDmJ0WgkgJjUZ0qhqDlXNJf1ye5H0OrgkJtbZ+gBp55Mxm8wFpJ1LZoU0hVYJyLCKtPNIu4B0Sx6TRaNZVWdQtBJAkJKMmWRMJ3Px49Dhrqk2KqbNmRl4t6qQLGJAu5HHOhsg5mugx6FjVm0qni7v3u3TjvId62ZRtc2sBuO6k4ryLQvuGU8cJIsTAGJFDKOCtPn4ifYjMeFkhYV9+8+P2/zzkzapyT5NByAFQemj0cQ8essGhLVKAQILBDXFwRTfgwLaUWw3KvCj8iz0S1nZdc3yReFvfdbuHx+3CQ7+WuSJbCq2DgFox9JbDBCMX7zbK2kU05W6vMjiQP4nAuVQOZ1f2ZRRg0mpv5B5t7LAcDHzB8/xb3zSFhaUkuTDSZqbIwPCgZo5mOTPCJkEhDaU2JP0BSK/A688cPiAb78fO3zMkPfadHjj07afdXLZrmE+yPkAwdccX0CDfgPDYeloff/fk/xpxoj6/pz2z8CYH21t14Y58m5dcaaY64H5vP15+6io7+8Jt5gacjhAylrtRkQliiTCzWLjNREcK0Oo8wuNnV+u7/e7hp4/q+/zKwaIl+uzlO1J19f9COj47sUTpoyEybz7RYf323TEFTY1xffalWx2EvnYUr+aDKvRcChAFiVSdtT6UBvD/3azWS42jwzL7bm6/n+4823Hhp4/tzloLs9Q+vcCICuj6yW5ezbOyV4bp8hOOn9oea1BIfgp3VLSLbZqiYMBYiuDKbG2zRHbN516/5Rzex51QlTFUFEl2YMj1v1V5KUYYycguM5L7HcQhSPRhdC4pnQkQFJhYVUehbkwHwRMtcPf4NxfYjVD8v1SfNlLi+W6kGGtA1qQBCPUDL9+z3pzPdPY7TWSWW+0CW/AQ0vTsZrSOkgILJHomvPRcCJAjNHppXytZ+KbNPDXNP6fNG0Abjf0S03RF9KBmZTjRRnf4yQ+sDVI5XSA2IZNxVSaQRdXU0kG2o+gc3EVJfWmvj/DTQdfjqo++XxBe6eTxRkBiR0wL7VUnlGeTRGu8OU2VWr2nuPYfLJonBSQRcVZ1LfL8yvOpJWfXnuzLI9jOJr6naJA6vwio2MjMErth9DcAQAprdLMaMD7vMc8Yve0hUXZSYgD5d26deraddS4oRmrYm6W54sZmRSU0AP5GgICJChiQDCiK2lsijQgtsLmAaRObdySZNwZf2XL1Gs6AKp+NKBavWLurKCPO8hYDgGh8X7bjnGxHncqUJ8XOJIun4I6ci7P3R/7Qd3AP9kAgk0hazm3/JGAtk03YXmbk0yqVO5JAwKdE1Hrb/lNqPXufz3I4/bm1Wx7UqpWI9v8Qu6K3ArlizYubm3d3JFkIRH9sF2nwsxEmw3Dfyf2sg8IFjT+DbqaLglIdX/rshtB32F5N/0mHYveAkZPDhCMdkdCyV3fEeQpI08X8pBT9ADaO1saUL2hGKWvv334Jaxm3KQRx3YtPntgmYfXBPBC59ffjUFxQ6AMH6QKpa4vczhfkIw/a5zbC8QsaMYgEHwYGjIrafdMiuyHhWF5WORt37HbEiuVTxLQoZi9DV49rI935eXhQuF9aHMyfOfDXhMjF09K9B4xdsj4ySN2rp/N0ogTe5ZM/nr0iLFDQ0K/uVGah7k21bX47qDD4m9kcLVD/kadnqYp79Cpxfafgk4sYGMihfYmD7Y2yKXeq9f+uKPK5rAgOVYgMArsTnkhVGH/XShnVt6pLMC1das8r95YzDobTcpb5fnovF2R32hWind7NY1/uTro16gEcF1e4vr/ikJkdGTuQ+mU51B2EAV0E+jwkgsW9GR9kKbGe4CYkbc7zZ9MJ5eR3cvbYq9cz3okLOL4Qr5aUuhPe6chp7MzkvWcWEJzJ5GXm4hOjc/gY9GbnqAPEhg1wPnd8xlmw4hhiupPqhj8PoWd/zfiQ0qbXEwMtyybiqPgdGzRQHKY+ZGYHarUxuYKFLmDsQdu+U0UM2KmNHMc7ZpB2oL/EpNUSb8qn3ZOp+lj8LimdG76TTkQexiLbOZIelfCJWNgMOfpBncoxuTfleZNBiY4pv8Wk+iQwjx3TKO5E8mvaxM0LpynuyEwbGfCFWVLSDWwiE1J166ELa7z7stMSYwJe5g2mj8Fp1ewP9iwn4VJQ2FTMP30clJE0NRR5NelCRpIXuvd73LYsk3J1YxO8wNijDQptYdjdlX7fyc2JaYfXMjLlcJ607xJpIikQ/OpJJPfrVkJz8LEEDAWQg8GYNjVTDo4n4rCac5EXOGMe1M0eHS1vwdCEHVKHaPTQgAJmLYkGS6Fr7B6bhfIjjWBFBq4iaMH8gckzZe3rK0pfJx5eAEdXcQLDXzckkLFkZTmAygIRDGFgbaHxgWCP74YvhqJhYCmpQFijHC77Y6/UBYys8ZnENYtOnQCKR4WZP3WpzPvrQK6U2APXmjgo4+7lYjcCgVic0XCdJf7PkNKQ2fDFeLRjE6LBCQ+cXV74s+WhM676zsKLhM7ERnUw6gxSY9k3PHP3vEdczVswe7488KZaumAxNZUvz2x4kxkvikwEFGl1T3JpGFJQ8F0/CM13gNxb56OLER8LFiNowESMEHrk+/sjj93NjJXFxSNwL/eu7fVrGSMF0MmEutnYzC4zrv3bd9x2qCYM5F5OMLrU+4KtR6HBiQitS6lBo4cqSN+/1dD5+uConDv3PEdCz9S4zMQVgahgY/gaPH3ANCroQtORyowBeUnTUqNmIuzABKRYpvkwGtD8q1NSZatSfrtiWUI7SA08BGd+AoDMEyYwvSvduigBAAACAFY/9Z3CXyLDJZg20Gh7OWLuiAECRIkSJAgQYLGCBIkSJAgQYI4CBD5MYF/GSMAAAAASUVORK5CYII=";
const pfp29 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAKBklEQVR42u3bBVQbWRcH8Ky7L7Lui9XdWxLqtsbZeonggXq7UleCQ93d3d0V9yRIHHciZGLzvsukX85mXXlTzpzzrzf2y30yd2ZYftGIye+EAWKAGCAGiAFigBggBogBYsIAMUAMEAPEADFADFCrRESFAfpVmiGJdWP2nB++vtgvmmSAnGgGxxpH77o88d44ftGHU7MGfHV0y9CkGj8RA9RCYB2xKffbKzN5Eg+B3EUgc4Wf+cXvTrr/DVTT4LhmXEwsOugMW1P6zem4gNzuD2lkbvZQTG/ypJ+NuxY5cnOWX4yVYmqjQBwRYouQb5RT/BIaxh7cPzl9qKDkLUrH7dcCZC5T8zp9dWblkDVyXxFpfyw8G0fUFoCoTxKNvkiyBW83LTlmSL6g3XKtaeMVbfT5yvkpsdNKOgXCaJL9ug5f5goRyj9epO61tmz8dunmLTfL117UrTqpj9xN+K+xDo5BbGcmDuRRAbJ/w1M2WjZeacosrqqrLyX0atKoQiYVIlQWo1xnzCrRnj5VPX+xum+g7C2w+BnNXGWHPZXhuY376g1pJmMhaZIjk5IkVGaDuqlRI1VV7L/TELbDNDSWBCbIsFjzqDjDyDjDkBgr9cXQGAh0xiTaoF4UZeVWOwrl4hw1IjTwgWv0905Ufz9T4QWlZNcJk3+wrYKv1F2wEnJElML/hDg91tQSeGx1bene241Bm6tj9m+5cJF759qXt699deKccP7O0yNiDRx6AoHOhPWWC5m1hEFNufxhNACR07h3kboPT/bmLKX3tbo4wiiFv//jx5qgGDXV5TdNxT2QhOWILufVfad+GBWn49ANCHTGr7feFVeTf+zy82oq1p5KKB37oH6jjVA6lcwfM6mR9gySdUJilj1gZMx7Pmb/NnoBgc7YRBvUDqXzlwOP0jbnQDXZdf5iNKjxMCr+4KdGqTeHjYlv4tCqglZf0JoM1Mf7e6Fo/n6qlyPJMw4gTdrn45I1HBE9gNgiFLDZoigvp+YdLFGj5hykHOQAKnnQyT+pkkYVBHscmxGXjj2lqDYJSZ61A50+HwJrPy3mICjjr5JtefJKZMILpEH6FCTzBB35A5/QjelQ1/iB7OMrYhcB+zfcQJASg5x/68yQqUtv9l1I0mUf5BuFYs82Wppx60DMqtPXpb3C6j24qH0IGrAYO5AIDY43jN578mDhAUTQAujM7dqOQaQnD3nxUEch8l2BCwiGd4xl5Na0cTdCeYUfn6tdjAgNHYBupFd3DSU9uQDUkh5z8ACRw9fJ/c8t5+Z3FFBH5GdrltATqF0wGrisdYEGx5q/OLR/SqavQOZub+XAMdSRqjk0GWLHb9T7CNBnAchh1HNe6wJBa31K+pBAxRv/7064hUpcb94LQboS+1YYZ0yq2/cv/Ri/ZabogN8MeQsQF3USInZUKwINTaqdkuHnaAPy5W7rzn5WL5pIVmYhE14gNTJKbYrhlrzHTXnPZF3pPXZeDixn7YJglGECAp0Zee/kRvU2zBxhSTmMzBrMG0XteVTk/vBoQ8pau3UhDDRvAeq3EJYUHEA8ueuGsx4NMzg6Ice4cQ7ZKMVaRApULkTixxxAm3fMs6/3vX/ABBRa6H5rTXdDxGBdJEc3e6T5zj58QKWo8TgqegdJWmjgZ8Udj4kLbntQU3Wv73EAwfiam/WecsEAfYSfLtJPF8ExLJ9sK7qGTDhmH/0DpPSFwlHd+3T/vtDYDSL/H1K9+TYvjBUE4yv6+ic1s9l60LFHyDHtDEd6casvZ0pUMR2qpiHjDd6Sy148EpZ5e+1AYA7quwALkMJ102nPxukc3U+AiLXjUFNOaw80owxpvoXyacx8PXDZeR++FYAgn1O7IR9cqxgA7TrqTdE4gNjN8XyyoQAPUAELjMoefHD4oGDNlsUJG1fMEB3qG17VIRyxV9EEKILdHBtE1uMEsk/S9nmayH3u5pkR46LEVOMV3xCjF5BzgOnK5Qmj4vScaGyTtK+e3kB1We7BG7LYIpzLPH2BIPrcV2ZvuwZA+DaKwsF0rqCK9I8C1kkBCOehBj2BQMda8OT+U98NizHjPVjtA0cbNAGyiB8j8p8y5LxgyHmpKuP9g6fnfJ1YzYnG2+4451E7i62PwAs0DoCsYtb9oqdXXhwbtvK4MO48d614WCwBOpgbZmGFb13Y3JnaKGIGggqqK2StOMb35Js6RiLfh30yDC3XfVMyB4GOY6DNznk3JaGnXsjBDgTzTmXqO7wllzpNs1/HhbNpv6ylaS9z5VNG32W89yC+uyE2CNWLcQJRRjfPDB84r4HqtOI87WOG0z7B9/wjZC68lhXNbVb221cvfGNtLMAOpM16RZhwadAqfECOc6rxh5PTpM9FF78WLHMLkLmsVHP0zbmIwApEZcP+lb74gURozaFkUvxYk+TxS4XP/1jy2goNR0cHIAnryMlIPxFJA6DDSSTVBibFrFLJ47eVfYz0ADp4YiZHhGgEZA8p64wM2diBbAWPJ+xKHLSKfkCIDkASVk2aW0BUim8UDYDW0hLoyEF+71lGDh2AVu7dC/0EJMELJEea8Y6NYv71rqPn5GPcKDoFbgBYuvtwzu2BloKnsQERclQ6Hmhs4sczL/cZP/+uBxd1mU4PIA51CZ5/UsWGI3Hq1M9JAGrGUEHN8kDpDZ91Wxf6zZB7chGEFkDOd6+QvHV5526stRionbRJg4i/EOohKvj5rzxEhcwtsRHKTUdz+wtLvfnWh6fD6Abk2FgLthIZRVVyjdJYfwVpj6OmU38iJ+F/6mpuSGWKour7Cv0Zhe6cQnv+96I7K9dekKgludLKvMKKbElleGLzZ1OBBkJjIMjQ2JZLgr9dQ6w6cDb/7giLxAUVvYoKX//NFL1iFrulXPlqWvS1/tOJIasypl4OjyzuMEP52XSFx69E+Tn8U2gO+5s96wfMq+kTYesT2ZJOwSS40B3IMdwg7Cg0cqEqYeNy9b2PYB/wq91i+HvZbc9Va+P6Ccs9qInDIwC1C6sfmLx73F0OvwTaKW9St4/Z4yKQvxEg/mTMifDu89O9+Bb4/45QLvQHcmbqMgPeq/XLedkH9wc3ZL6BJE46NWnuO3fPGDlbAqfSnT4hF0J2mqkaujNqclYXgRxcXAOpO339r37dT3TOJ7j5V0QeRaCuM6mi4KKOgUY4ZX7jzEg41YmkLGgYXzzxzZRFN9oLTB7c3/yE3nxLj/mZY45HBOR7THgwgL1+c4eIGgdNGwHyoj6PJ6+FqWdY3cLEjReO+8+N3d0tpImi+YMAh0+wodeSO13mFEOhUc/WFoHsob58W+cggyfXaUz9GSYnmrYKZI8n/NwKeUSBnMMAzUCemIA8AWgavYEg/RainvNwhbr0l95AVGLw5Z/fN8+kDQExQAwQA8QAMUBMGCAGiAFigBggBogBYoCY/A/WHbioOxyUEwAAAABJRU5ErkJggg==";
const pfp3 = "" + new URL("3-f0871c58.png", import.meta.url).href;
const pfp4 = "" + new URL("4-61f6a6d6.png", import.meta.url).href;
const pfp5 = "" + new URL("5-17c42ca6.png", import.meta.url).href;
const pfp6 = "" + new URL("6-ae5f3eff.png", import.meta.url).href;
const pfp7 = "" + new URL("7-8a53975d.png", import.meta.url).href;
const pfp8 = "" + new URL("8-0ff7188c.png", import.meta.url).href;
const pfp9 = "" + new URL("9-fdbbb4a2.png", import.meta.url).href;
const def = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIAAgMAAACJFjxpAAAADFBMVEXFxcX////p6enW1tbAmiBwAAAFiElEQVR4AezAgQAAAACAoP2pF6kAAAAAAAAAAAAAAIDbu2MkvY0jiuMWWQoUmI50BB+BgRTpCAz4G6C8CJDrC3AEXGKPoMTlYA/gAJfwETawI8cuBs5Nk2KtvfiLW+gLfK9m+r3X82G653+JP/zjF8afP1S//y+An4/i51//AsB4aH+/QPD6EQAY/zwZwN8BAP50bh786KP4+VT+3fs4/noigEc+jnHeJrzxX+NWMDDh4g8+EXcnLcC9T8U5S/CdT8bcUeBEIrwBOiI8ki7Ba5+NrePgWUy89/nYyxQ8Iw3f+pWY4h1gb3eAW7sDTPEOsLc7wK1TIeDuDB+I/OA1QOUHv/dFsZQkhKkh4QlEfOULYz2nGj2/Nn1LmwR/86VxlCoAW6kCsHRGANx1RgCMo5Qh2EsZgrXNQZZShp5Liv7Il8eIc5C91EHY2hxk6bwYmNscZIReDBwtCdhbErC1JGBpScBcOgFMLQsZMQs5Whayd+UQsLYsZGlZyNyykKllISNmIUfAwifw8NXvTojAjGFrdYi11SGWVoeYWx1i6lmQCiEjFkKOVgjZ+xxIhZCtFULWHkCqxCw9gNQKmP9vNHzipdEPrRcxtVbAeDkAvve0iM2QozVD9hfjhp4YP/UrkJYDbD2AtBxgfSkAvvHEeNcDSAsilgtAWxIy91J8AXgZAJ5e33+4tuACcAG4AFwALgBXRXQB6AFcB5MXAuA6nl9/0Vx/011/1V5/1/dfTPJvRtdnu/zL6beeFO/7r+fXBYbrEkt/j+i6ytXfpuvvE/ZXOnsA/a3a/l5xf7O6v1t+Xe/vOyz6HpO8yyboM8o7rfJes77bru83THk48p7TvOs27zvOO6/73vO++z7l4cgnMPQzKPopHC0N9noSSz6LJp/Gk88jyicy5TOp6qlc+VyyfDJbPpuuns6XzyfMJzTmMyrrKZ35nNJ8Ums+q7af1tvPK+4nNodEnPKp3fnc8npyez67/qVP7+/fL8hfcMjfsOhf8cjfMclfcnn9+BkOnLECP8Q58OYeyJ40eoyF6Ee/En/JHlP6mIlRVXprF4BxtAvArV0AxtEuALd2ARhHuwDc2gVgHPX/hFv9fMBddjIGeKg/WCxlCsI46u+Ga5mCcJd+sIG9UkGAW32ZbApFAHhod4Bb3eo04h3god0BbiUHYApVCNjbHeBW+QDAXT4a7qg7r7e214057vg0QhkEHkoSwq0kIdydXw4/Q3H8hjYJ3vL0WConBJhCHQaOToeBrU0BljYFmEoVgHGUKgAPnREAt84IgLuqFgAYSUEOAHszDwuAtSkHAZhLGYIpdCLgKGUIHtocZG1zkLmUIRhxDnJU1RDA1uYga5uDzKUOwhTnIEfnxcDe5iBrcyQAYGlzkKkUYhhxDrKXQgxbSwLWUohhbknA1JKAEZOAvSUBW0sC1pYEzC0JmFoSMMJyCDhaFrK3JGDtyiFgaVnI3LKQqWUhI2YhR8tC9paFrC0LWVoWMrcsZGpZyIhZyNGykL2rSIGtlQHWVgZYWhlgbmWAqZUBRiwDHK0MsLcywNbKAGsOoNUhllaHmFsdYmp1iBHrEEerQ+w5gFYI2VodYm11iKXVIeYcQCuETK0QMmIh5MgBtELI3gohWyuErDmAVolZWiFkzgG0SszUKjGjfj6gVmKOVonZcwCtFbB9HQC+ozWDbz1bvGu9iKW1AuYcQOtFTLEX1GbIaFegN0OOHEBrhuw5gNYM2XIArRuz5gDacoB3bTnAEktxXQ4wfw0AvveM8b4tiJjSJOwLIsbXsAKeNeKCiOO3D+AVbUl0AfjGs8ZPbUnIdgFoa1LWC0BblfMuB9AeC1j6gqQE0J9LmC8AOYD2ZMb7i4bt2ZTpWoHfPoB7Tj2fXzT8N1X41vkq/QHOAAAAAElFTkSuQmCC";
const ProfilePictures = {
  pfp1,
  pfp2,
  pfp3,
  pfp4,
  pfp5,
  pfp6,
  pfp7,
  pfp8,
  pfp9,
  pfp10,
  pfp11,
  pfp12,
  pfp13,
  pfp14,
  pfp15,
  pfp16,
  pfp17,
  pfp18,
  pfp19,
  pfp20,
  pfp21,
  pfp22,
  pfp23,
  pfp24,
  pfp25,
  pfp26,
  pfp27,
  pfp28,
  pfp29,
  def
};
function getProfilePicture(id) {
  if (typeof id == "number")
    return ProfilePictures[`pfp${id}`] || def;
  return id.toString();
}
async function applyCustomPfp(url) {
  UserData$2.update((udata) => {
    udata.acc.profilePicture = url;
    return udata;
  });
}
const pfpCache = {};
async function getUserPfp(username) {
  const server = get_store_value(ConnectedServer);
  if (!server)
    return ProfilePictures.def;
  if (pfpCache[username])
    return getProfilePicture(pfpCache[username]);
  const users = await getUsers();
  const user = users[username];
  if (!user)
    return ProfilePictures.def;
  pfpCache[username] = getProfilePicture(users[username].acc.profilePicture);
  return pfpCache[username];
}
const ProfilePicture_svelte_svelte_type_style_lang = "";
function create_fragment$50(ctx) {
  let div;
  let div_class_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = "pfprenderer " + /*className*/
      ctx[2] + " pfp svelte-11jeot8");
      set_style(div, "background-image", "url('" + /*src*/
      ctx[0] + "')");
      set_style(
        div,
        "height",
        /*height*/
        ctx[1] + "px"
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*className*/
      4 && div_class_value !== (div_class_value = "pfprenderer " + /*className*/
      ctx2[2] + " pfp svelte-11jeot8")) {
        attr(div, "class", div_class_value);
      }
      if (dirty & /*src*/
      1) {
        set_style(div, "background-image", "url('" + /*src*/
        ctx2[0] + "')");
      }
      if (dirty & /*height*/
      2) {
        set_style(
          div,
          "height",
          /*height*/
          ctx2[1] + "px"
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$4I($$self, $$props, $$invalidate) {
  let { src } = $$props;
  let { height } = $$props;
  let { className = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("src" in $$props2)
      $$invalidate(0, src = $$props2.src);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
  };
  return [src, height, className];
}
class ProfilePicture extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4I, create_fragment$50, safe_not_equal, { src: 0, height: 1, className: 2 });
  }
}
const spinner = "";
function create_fragment$4$(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = SpinnerIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "spinner");
      set_style(
        img,
        "height",
        /*height*/
        ctx[0] + "px"
      );
      attr(img, "class", "spinner-svg");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*height*/
      1) {
        set_style(
          img,
          "height",
          /*height*/
          ctx2[0] + "px"
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function instance$4H($$self, $$props, $$invalidate) {
  let { height } = $$props;
  $$self.$$set = ($$props2) => {
    if ("height" in $$props2)
      $$invalidate(0, height = $$props2.height);
  };
  return [height];
}
class Spinner extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4H, create_fragment$4$, safe_not_equal, { height: 0 });
  }
}
const release = "" + new URL("systemIcon-393c5507.svg", import.meta.url).href;
const icon = "" + new URL("devIcon-567f5f60.svg", import.meta.url).href;
const unstable = "" + new URL("unstIcon-118758aa.png", import.meta.url).href;
const admin = "" + new URL("adminIcon-11dc6ee1.png", import.meta.url).href;
const siege = "" + new URL("siegeIcon-bce24d4a.png", import.meta.url).href;
const rc = "" + new URL("rc-d6342559.png", import.meta.url).href;
const uwu = "" + new URL("uwuIcon-3878edfd.png", import.meta.url).href;
const esr = "" + new URL("esr-9b05be30.png", import.meta.url).href;
const MODES = { release, development: icon, unstable, admin, siege, rc, uwu, esr };
let ARCOS_MODE = "release";
async function getMode() {
  Log(
    "ts/branding.ts: getMode",
    "Attempting to retrieve mode from /mode",
    LogLevel.info
  );
  try {
    const mode2 = await (await fetch("./mode")).text();
    ARCOS_MODE = mode2.trim();
  } catch {
    ARCOS_MODE = "release";
  }
}
const Logo = (m3) => MODES[m3 || ARCOS_MODE] || release;
function create_if_block$1Q(ctx) {
  let div;
  let profilepicture;
  let t0;
  let h1;
  let t1;
  let t2;
  let h3;
  let spinner2;
  let t3;
  let span;
  let t4;
  let current;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*pfp*/
      ctx[2]
    ), height: 151 }
  });
  spinner2 = new Spinner({ props: { height: 23 } });
  return {
    c() {
      div = element("div");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      h1 = element("h1");
      t1 = text(
        /*name*/
        ctx[1]
      );
      t2 = space();
      h3 = element("h3");
      create_component(spinner2.$$.fragment);
      t3 = text(" ");
      span = element("span");
      t4 = text(
        /*caption*/
        ctx[0]
      );
      attr(div, "class", "userlogin show");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(profilepicture, div, null);
      append(div, t0);
      append(div, h1);
      append(h1, t1);
      append(div, t2);
      append(div, h3);
      mount_component(spinner2, h3, null);
      append(h3, t3);
      append(h3, span);
      append(span, t4);
      current = true;
    },
    p(ctx2, dirty) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      4)
        profilepicture_changes.src = /*pfp*/
        ctx2[2];
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*name*/
      2)
        set_data(
          t1,
          /*name*/
          ctx2[1]
        );
      if (!current || dirty & /*caption*/
      1)
        set_data(
          t4,
          /*caption*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      transition_in(spinner2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      transition_out(spinner2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(profilepicture);
      destroy_component(spinner2);
    }
  };
}
function create_fragment$4_(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*pfp*/
    ctx[2] && create_if_block$1Q(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*pfp*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*pfp*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1Q(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$4G($$self, $$props, $$invalidate) {
  let $UserName;
  let $loginUsername;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(4, $UserName = $$value));
  component_subscribe($$self, loginUsername, ($$value) => $$invalidate(5, $loginUsername = $$value));
  let { caption } = $$props;
  let { username = "" } = $$props;
  let name = "";
  let pfp = "";
  onMount(async () => {
    $$invalidate(1, name = $loginUsername || $UserName || username);
    $$invalidate(2, pfp = await getUserPfp(name));
    if (pfp == ProfilePictures.def)
      $$invalidate(2, pfp = Logo());
  });
  $$self.$$set = ($$props2) => {
    if ("caption" in $$props2)
      $$invalidate(0, caption = $$props2.caption);
    if ("username" in $$props2)
      $$invalidate(3, username = $$props2.username);
  };
  return [caption, name, pfp, username];
}
let Loading$2 = class Loading extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4G, create_fragment$4_, safe_not_equal, { caption: 0, username: 3 });
  }
};
function create_fragment$4Z(ctx) {
  let loading;
  let current;
  loading = new Loading$2({ props: { caption: "Welcome" } });
  return {
    c() {
      create_component(loading.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading, detaching);
    }
  };
}
let AutoLogin$1 = class AutoLogin extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$4Z, safe_not_equal, {});
  }
};
const userlogin = "";
function flush() {
  UserName.set(void 0);
  loginUsername.set(void 0);
  NotificationStore.set({});
  ErrorMessages.set([]);
}
function create_fragment$4Y(ctx) {
  let loading;
  let current;
  loading = new Loading$2({
    props: {
      caption: "Goodbye!",
      username: (
        /*$UserName*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(loading.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const loading_changes = {};
      if (dirty & /*$UserName*/
      1)
        loading_changes.username = /*$UserName*/
        ctx2[0];
      loading.$set(loading_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading, detaching);
    }
  };
}
function instance$4F($$self, $$props, $$invalidate) {
  let $UserName;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(0, $UserName = $$value));
  onMount(() => {
    setTimeout(
      () => {
        flush();
        location.reload();
      },
      2e3
    );
  });
  return [$UserName];
}
class Logoff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4F, create_fragment$4Y, safe_not_equal, {});
  }
}
function create_fragment$4X(ctx) {
  let loading;
  let current;
  loading = new Loading$2({ props: { caption: "Restarting" } });
  return {
    c() {
      create_component(loading.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading, detaching);
    }
  };
}
function instance$4E($$self) {
  setTimeout(
    () => {
      location.reload();
    },
    2e3
  );
  return [];
}
class Restart extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4E, create_fragment$4X, safe_not_equal, {});
  }
}
function create_if_block$1P(ctx) {
  let button;
  let profilepicture;
  let t0;
  let p2;
  let t1;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*pfp*/
      ctx[2]
    ), height: 76 }
  });
  return {
    c() {
      button = element("button");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      p2 = element("p");
      t1 = text(
        /*name*/
        ctx[1]
      );
      attr(p2, "class", "username");
      attr(button, "class", "user");
      toggle_class(
        button,
        "drop",
        /*name*/
        ctx[1] == "space"
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(profilepicture, button, null);
      append(button, t0);
      append(button, p2);
      append(p2, t1);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*go*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      4)
        profilepicture_changes.src = /*pfp*/
        ctx2[2];
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*name*/
      2)
        set_data(
          t1,
          /*name*/
          ctx2[1]
        );
      if (!current || dirty & /*name*/
      2) {
        toggle_class(
          button,
          "drop",
          /*name*/
          ctx2[1] == "space"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(profilepicture);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4W(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*data*/
    ctx[0].acc.enabled && create_if_block$1P(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*data*/
        ctx2[0].acc.enabled
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*data*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1P(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$4D($$self, $$props, $$invalidate) {
  let pfp = "";
  let { data } = $$props;
  let { name } = $$props;
  function go() {
    loginUsername.set(name);
    applyLoginState("todesktop");
  }
  onMount(() => {
    $$invalidate(2, pfp = getProfilePicture(data.acc.profilePicture));
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("name" in $$props2)
      $$invalidate(1, name = $$props2.name);
  };
  return [data, name, pfp, go];
}
let User$1 = class User extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4D, create_fragment$4W, safe_not_equal, { data: 0, name: 1 });
  }
};
function get_each_context$X(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2];
  return child_ctx;
}
function create_if_block$1O(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(Object.keys(
    /*users*/
    ctx[0]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$X(get_each_context$X(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*users, Object*/
      1) {
        each_value = ensure_array_like(Object.keys(
          /*users*/
          ctx2[0]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$X(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$X(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$X(ctx) {
  let user;
  let current;
  user = new User$1({
    props: {
      data: (
        /*users*/
        ctx[0][
          /*username*/
          ctx[1]
        ]
      ),
      name: (
        /*username*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(user.$$.fragment);
    },
    m(target, anchor) {
      mount_component(user, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const user_changes = {};
      if (dirty & /*users*/
      1)
        user_changes.data = /*users*/
        ctx2[0][
          /*username*/
          ctx2[1]
        ];
      if (dirty & /*users*/
      1)
        user_changes.name = /*username*/
        ctx2[1];
      user.$set(user_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(user.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(user.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(user, detaching);
    }
  };
}
function create_fragment$4V(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*users*/
    ctx[0] && create_if_block$1O(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*users*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*users*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1O(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$4C($$self, $$props, $$invalidate) {
  let users;
  onMount(async () => {
    $$invalidate(0, users = await getUsers());
  });
  return [users];
}
class Populator extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4C, create_fragment$4V, safe_not_equal, {});
  }
}
function create_fragment$4U(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Create Account";
      attr(button, "class", "createacc");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4B($$self) {
  const click_handler = () => applyLoginState("newapiuser");
  return [click_handler];
}
let CreateButton$1 = class CreateButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4B, create_fragment$4U, safe_not_equal, {});
  }
};
function create_fragment$4T(ctx) {
  let div;
  let populator;
  let t2;
  let createbutton;
  let current;
  populator = new Populator({});
  createbutton = new CreateButton$1({});
  return {
    c() {
      div = element("div");
      create_component(populator.$$.fragment);
      t2 = space();
      create_component(createbutton.$$.fragment);
      attr(div, "class", "user-selector");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(populator, div, null);
      append(div, t2);
      mount_component(createbutton, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(populator.$$.fragment, local);
      transition_in(createbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(populator.$$.fragment, local);
      transition_out(createbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(populator);
      destroy_component(createbutton);
    }
  };
}
let Selector$2 = class Selector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$4T, safe_not_equal, {});
  }
};
function create_fragment$4S(ctx) {
  let loading;
  let current;
  loading = new Loading$2({ props: { caption: "Shutting down" } });
  return {
    c() {
      create_component(loading.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading, detaching);
    }
  };
}
function instance$4A($$self) {
  onMount(() => {
    setTimeout(
      () => {
        flush();
        applyState("turnedoff");
      },
      2e3
    );
  });
  return [];
}
class Shutdown extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4A, create_fragment$4S, safe_not_equal, {});
  }
}
function create_fragment$4R(ctx) {
  let form;
  let input;
  let t0;
  let button;
  let t1;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      form = element("form");
      input = element("input");
      t0 = space();
      button = element("button");
      t1 = text("arrow_forward_ios");
      input.autofocus = true;
      attr(input, "type", "password");
      attr(input, "placeholder", "Password");
      toggle_class(
        input,
        "wrongpswd",
        /*wrongpswd*/
        ctx[0]
      );
      attr(button, "class", "material-icons-round");
      button.disabled = button_disabled_value = !/*password*/
      ctx[1];
    },
    m(target, anchor) {
      insert(target, form, anchor);
      append(form, input);
      set_input_value(
        input,
        /*password*/
        ctx[1]
      );
      insert(target, t0, anchor);
      insert(target, button, anchor);
      append(button, t1);
      input.focus();
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[6]
          ),
          listen(
            input,
            "input",
            /*input_handler*/
            ctx[7]
          ),
          listen(
            form,
            "submit",
            /*submit*/
            ctx[2]
          ),
          listen(
            button,
            "click",
            /*serverLogin*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*password*/
      2 && input.value !== /*password*/
      ctx2[1]) {
        set_input_value(
          input,
          /*password*/
          ctx2[1]
        );
      }
      if (dirty & /*wrongpswd*/
      1) {
        toggle_class(
          input,
          "wrongpswd",
          /*wrongpswd*/
          ctx2[0]
        );
      }
      if (dirty & /*password*/
      2 && button_disabled_value !== (button_disabled_value = !/*password*/
      ctx2[1])) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(form);
        detach(t0);
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4z($$self, $$props, $$invalidate) {
  let $loginUsername;
  component_subscribe($$self, loginUsername, ($$value) => $$invalidate(8, $loginUsername = $$value));
  let { authenticating } = $$props;
  let password;
  let { wrongpswd = false } = $$props;
  let { pfp = "" } = $$props;
  onMount(async () => {
    $$invalidate(5, pfp = await getUserPfp($loginUsername));
  });
  function submit2(e2) {
    e2.preventDefault();
    serverLogin();
    return false;
  }
  async function serverLogin() {
    $$invalidate(4, authenticating = true);
    const userdata = await loginUsingCreds(generateCredToken({ username: $loginUsername, password }));
    if (!userdata) {
      $$invalidate(4, authenticating = false);
      $$invalidate(0, wrongpswd = true);
      return;
    }
    localStorage.setItem("arcos-remembered-token", toBase64(`${$loginUsername}:${password}`));
    UserData$2.set(userdata);
    UserName.set($loginUsername);
    applyState("desktop");
  }
  function input_input_handler() {
    password = this.value;
    $$invalidate(1, password);
  }
  const input_handler = () => $$invalidate(0, wrongpswd = false);
  $$self.$$set = ($$props2) => {
    if ("authenticating" in $$props2)
      $$invalidate(4, authenticating = $$props2.authenticating);
    if ("wrongpswd" in $$props2)
      $$invalidate(0, wrongpswd = $$props2.wrongpswd);
    if ("pfp" in $$props2)
      $$invalidate(5, pfp = $$props2.pfp);
  };
  return [
    wrongpswd,
    password,
    submit2,
    serverLogin,
    authenticating,
    pfp,
    input_input_handler,
    input_handler
  ];
}
class Input extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4z, create_fragment$4R, safe_not_equal, { authenticating: 4, wrongpswd: 0, pfp: 5 });
  }
}
function create_if_block_2$b(ctx) {
  let profilepicture;
  let t0;
  let h1;
  let t1_value = (
    /*$loginUsername*/
    (ctx[3] || "Login") + ""
  );
  let t1;
  let t2;
  let if_block_anchor;
  let current;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*pfp*/
      ctx[1]
    ), height: 151 }
  });
  let if_block = !/*wrongpswd*/
  ctx[2] && create_if_block_3$5(ctx);
  return {
    c() {
      create_component(profilepicture.$$.fragment);
      t0 = space();
      h1 = element("h1");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(profilepicture, target, anchor);
      insert(target, t0, anchor);
      insert(target, h1, anchor);
      append(h1, t1);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      2)
        profilepicture_changes.src = /*pfp*/
        ctx2[1];
      profilepicture.$set(profilepicture_changes);
      if ((!current || dirty & /*$loginUsername*/
      8) && t1_value !== (t1_value = /*$loginUsername*/
      (ctx2[3] || "Login") + ""))
        set_data(t1, t1_value);
      if (!/*wrongpswd*/
      ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$5(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(h1);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(profilepicture, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_3$5(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "class", "block username");
      attr(input, "placeholder", "Username");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*$loginUsername*/
        ctx[3]
      );
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$loginUsername*/
      8 && input.value !== /*$loginUsername*/
      ctx2[3]) {
        set_input_value(
          input,
          /*$loginUsername*/
          ctx2[3]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_1$7(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "The password is incorrect. Try again.";
      attr(p2, "class", "error");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_if_block_1$z(ctx) {
  let div;
  let input;
  let updating_authenticating;
  let updating_pfp;
  let updating_wrongpswd;
  let current;
  function input_authenticating_binding(value) {
    ctx[6](value);
  }
  function input_pfp_binding(value) {
    ctx[7](value);
  }
  function input_wrongpswd_binding(value) {
    ctx[8](value);
  }
  let input_props = {};
  if (
    /*authenticating*/
    ctx[0] !== void 0
  ) {
    input_props.authenticating = /*authenticating*/
    ctx[0];
  }
  if (
    /*pfp*/
    ctx[1] !== void 0
  ) {
    input_props.pfp = /*pfp*/
    ctx[1];
  }
  if (
    /*wrongpswd*/
    ctx[2] !== void 0
  ) {
    input_props.wrongpswd = /*wrongpswd*/
    ctx[2];
  }
  input = new Input({ props: input_props });
  binding_callbacks.push(() => bind$1(input, "authenticating", input_authenticating_binding));
  binding_callbacks.push(() => bind$1(input, "pfp", input_pfp_binding));
  binding_callbacks.push(() => bind$1(input, "wrongpswd", input_wrongpswd_binding));
  return {
    c() {
      div = element("div");
      create_component(input.$$.fragment);
      attr(div, "class", "field");
      toggle_class(
        div,
        "hidden",
        /*authenticating*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(input, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const input_changes = {};
      if (!updating_authenticating && dirty & /*authenticating*/
      1) {
        updating_authenticating = true;
        input_changes.authenticating = /*authenticating*/
        ctx2[0];
        add_flush_callback(() => updating_authenticating = false);
      }
      if (!updating_pfp && dirty & /*pfp*/
      2) {
        updating_pfp = true;
        input_changes.pfp = /*pfp*/
        ctx2[1];
        add_flush_callback(() => updating_pfp = false);
      }
      if (!updating_wrongpswd && dirty & /*wrongpswd*/
      4) {
        updating_wrongpswd = true;
        input_changes.wrongpswd = /*wrongpswd*/
        ctx2[2];
        add_flush_callback(() => updating_wrongpswd = false);
      }
      input.$set(input_changes);
      if (!current || dirty & /*authenticating*/
      1) {
        toggle_class(
          div,
          "hidden",
          /*authenticating*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(input);
    }
  };
}
function create_else_block$F(ctx) {
  let loading;
  let current;
  loading = new Loading$2({ props: { caption: "Welcome" } });
  return {
    c() {
      create_component(loading.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading, detaching);
    }
  };
}
function create_if_block$1N(ctx) {
  let button;
  let t_value = (
    /*wrongpswd*/
    ctx[2] ? "Okay" : "Show Picker"
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "class", "switchuser");
      attr(button, "type", "button");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*cancel*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*wrongpswd*/
      4 && t_value !== (t_value = /*wrongpswd*/
      ctx2[2] ? "Okay" : "Show Picker"))
        set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4Q(ctx) {
  let t0;
  let div;
  let current_block_type_index;
  let if_block1;
  let t1;
  let current_block_type_index_1;
  let if_block2;
  let current;
  let if_block0 = !/*authenticating*/
  ctx[0] && create_if_block_2$b(ctx);
  const if_block_creators = [create_if_block_1$z, create_else_block_1$7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*wrongpswd*/
    ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const if_block_creators_1 = [create_if_block$1N, create_else_block$F];
  const if_blocks_1 = [];
  function select_block_type_1(ctx2, dirty) {
    if (!/*authenticating*/
    ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index_1 = select_block_type_1(ctx);
  if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if_block1.c();
      t1 = space();
      if_block2.c();
      attr(div, "class", "cloudlogin");
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t1);
      if_blocks_1[current_block_type_index_1].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*authenticating*/
      ctx2[0]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*authenticating*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$b(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, t1);
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx2);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block2 = if_blocks_1[current_block_type_index_1];
        if (!if_block2) {
          if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
      }
      if (if_block0)
        if_block0.d(detaching);
      if_blocks[current_block_type_index].d();
      if_blocks_1[current_block_type_index_1].d();
    }
  };
}
function instance$4y($$self, $$props, $$invalidate) {
  let $loginUsername;
  component_subscribe($$self, loginUsername, ($$value) => $$invalidate(3, $loginUsername = $$value));
  let { authenticating = false } = $$props;
  let pfp;
  let wrongpswd = false;
  async function cancel() {
    if (wrongpswd)
      return $$invalidate(2, wrongpswd = false);
    loginUsername.set(void 0);
    applyLoginState("selector");
  }
  loginUsername.subscribe(async (v2) => $$invalidate(1, pfp = await getUserPfp(v2)));
  function input_input_handler() {
    $loginUsername = this.value;
    loginUsername.set($loginUsername);
  }
  function input_authenticating_binding(value) {
    authenticating = value;
    $$invalidate(0, authenticating);
  }
  function input_pfp_binding(value) {
    pfp = value;
    $$invalidate(1, pfp);
  }
  function input_wrongpswd_binding(value) {
    wrongpswd = value;
    $$invalidate(2, wrongpswd);
  }
  $$self.$$set = ($$props2) => {
    if ("authenticating" in $$props2)
      $$invalidate(0, authenticating = $$props2.authenticating);
  };
  return [
    authenticating,
    pfp,
    wrongpswd,
    $loginUsername,
    cancel,
    input_input_handler,
    input_authenticating_binding,
    input_pfp_binding,
    input_wrongpswd_binding
  ];
}
class AuthForm extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4y, create_fragment$4Q, safe_not_equal, { authenticating: 0 });
  }
}
function create_fragment$4P(ctx) {
  let div;
  let authform;
  let updating_authenticating;
  let current;
  function authform_authenticating_binding(value) {
    ctx[2](value);
  }
  let authform_props = {};
  if (
    /*authenticating*/
    ctx[0] !== void 0
  ) {
    authform_props.authenticating = /*authenticating*/
    ctx[0];
  }
  authform = new AuthForm({ props: authform_props });
  binding_callbacks.push(() => bind$1(authform, "authenticating", authform_authenticating_binding));
  return {
    c() {
      div = element("div");
      create_component(authform.$$.fragment);
      attr(div, "class", "userlogin");
      toggle_class(
        div,
        "show",
        /*show*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(authform, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const authform_changes = {};
      if (!updating_authenticating && dirty & /*authenticating*/
      1) {
        updating_authenticating = true;
        authform_changes.authenticating = /*authenticating*/
        ctx2[0];
        add_flush_callback(() => updating_authenticating = false);
      }
      authform.$set(authform_changes);
      if (!current || dirty & /*show*/
      2) {
        toggle_class(
          div,
          "show",
          /*show*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(authform.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(authform.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(authform);
    }
  };
}
function instance$4x($$self, $$props, $$invalidate) {
  let authenticating = false;
  let show = false;
  onMount(async () => {
    setTimeout(
      () => {
        $$invalidate(1, show = true);
      },
      10
    );
  });
  function authform_authenticating_binding(value) {
    authenticating = value;
    $$invalidate(0, authenticating);
  }
  return [authenticating, show, authform_authenticating_binding];
}
class UserLogin extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4x, create_fragment$4P, safe_not_equal, {});
  }
}
function create_fragment$4O(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Cancel";
      attr(button, "class", "switchuser");
      toggle_class(
        button,
        "show",
        /*show*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*show*/
      1) {
        toggle_class(
          button,
          "show",
          /*show*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4w($$self, $$props, $$invalidate) {
  let { show } = $$props;
  const click_handler = () => applyLoginState("selector");
  $$self.$$set = ($$props2) => {
    if ("show" in $$props2)
      $$invalidate(0, show = $$props2.show);
  };
  return [show, click_handler];
}
let Cancel$1 = class Cancel extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4w, create_fragment$4O, safe_not_equal, { show: 0 });
  }
};
function create_fragment$4N(ctx) {
  let profilepicture;
  let t0;
  let h1;
  let t2;
  let form0;
  let input0;
  let t3;
  let input1;
  let input1_disabled_value;
  let t4;
  let div;
  let form1;
  let input2;
  let input2_disabled_value;
  let t5;
  let button;
  let t6;
  let button_disabled_value;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: { src: ProfilePictures.def, height: 151 }
  });
  return {
    c() {
      create_component(profilepicture.$$.fragment);
      t0 = space();
      h1 = element("h1");
      h1.textContent = "New user";
      t2 = space();
      form0 = element("form");
      input0 = element("input");
      t3 = space();
      input1 = element("input");
      t4 = space();
      div = element("div");
      form1 = element("form");
      input2 = element("input");
      t5 = space();
      button = element("button");
      t6 = text("arrow_forward_ios");
      attr(input0, "type", "text");
      attr(input0, "placeholder", "Username");
      attr(input0, "class", "block");
      input0.disabled = /*loading*/
      ctx[0];
      attr(input1, "type", "password");
      attr(input1, "placeholder", "Password");
      attr(input1, "class", "block");
      input1.disabled = input1_disabled_value = /*loading*/
      ctx[0] || !/*username*/
      ctx[1];
      attr(input2, "type", "password");
      attr(input2, "placeholder", "Confirm Password");
      input2.disabled = input2_disabled_value = /*loading*/
      ctx[0] || !/*username*/
      ctx[1];
      button.disabled = button_disabled_value = /*loading*/
      ctx[0] || !/*username*/
      ctx[1] || !/*password*/
      ctx[2] || /*password*/
      ctx[2] != /*confirm*/
      ctx[3];
      attr(button, "class", "createbutton material-icons-round");
      attr(button, "type", "button");
      attr(div, "class", "input-wrapper");
    },
    m(target, anchor) {
      mount_component(profilepicture, target, anchor);
      insert(target, t0, anchor);
      insert(target, h1, anchor);
      insert(target, t2, anchor);
      insert(target, form0, anchor);
      append(form0, input0);
      set_input_value(
        input0,
        /*username*/
        ctx[1]
      );
      insert(target, t3, anchor);
      insert(target, input1, anchor);
      set_input_value(
        input1,
        /*password*/
        ctx[2]
      );
      insert(target, t4, anchor);
      insert(target, div, anchor);
      append(div, form1);
      append(form1, input2);
      set_input_value(
        input2,
        /*confirm*/
        ctx[3]
      );
      append(div, t5);
      append(div, button);
      append(button, t6);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[6]
          ),
          listen(
            form0,
            "submit",
            /*createAccount*/
            ctx[4]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[7]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[8]
          ),
          listen(
            form1,
            "submit",
            /*createAccount*/
            ctx[4]
          ),
          listen(
            button,
            "click",
            /*createAccount*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*loading*/
      1) {
        input0.disabled = /*loading*/
        ctx2[0];
      }
      if (dirty & /*username*/
      2 && input0.value !== /*username*/
      ctx2[1]) {
        set_input_value(
          input0,
          /*username*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*loading, username*/
      3 && input1_disabled_value !== (input1_disabled_value = /*loading*/
      ctx2[0] || !/*username*/
      ctx2[1])) {
        input1.disabled = input1_disabled_value;
      }
      if (dirty & /*password*/
      4 && input1.value !== /*password*/
      ctx2[2]) {
        set_input_value(
          input1,
          /*password*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*loading, username*/
      3 && input2_disabled_value !== (input2_disabled_value = /*loading*/
      ctx2[0] || !/*username*/
      ctx2[1])) {
        input2.disabled = input2_disabled_value;
      }
      if (dirty & /*confirm*/
      8 && input2.value !== /*confirm*/
      ctx2[3]) {
        set_input_value(
          input2,
          /*confirm*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*loading, username, password, confirm*/
      15 && button_disabled_value !== (button_disabled_value = /*loading*/
      ctx2[0] || !/*username*/
      ctx2[1] || !/*password*/
      ctx2[2] || /*password*/
      ctx2[2] != /*confirm*/
      ctx2[3])) {
        button.disabled = button_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(h1);
        detach(t2);
        detach(form0);
        detach(t3);
        detach(input1);
        detach(t4);
        detach(div);
      }
      destroy_component(profilepicture, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4v($$self, $$props, $$invalidate) {
  let { loading } = $$props;
  let { username } = $$props;
  let { password } = $$props;
  let confirm;
  let { errored = false } = $$props;
  async function createAccount(e2) {
    if (e2)
      e2.preventDefault();
    if (password != confirm)
      return false;
    if (!username || !password || loading)
      return false;
    loginUsername.set(username);
    Busy.set(false);
    $$invalidate(0, loading = true);
    const userdata = await createUser(username, password);
    if (!userdata) {
      $$invalidate(5, errored = true);
      return false;
    }
    UserData$2.set(userdata);
    UserName.set(username);
    applyState("desktop");
    return false;
  }
  function input0_input_handler() {
    username = this.value;
    $$invalidate(1, username);
  }
  function input1_input_handler() {
    password = this.value;
    $$invalidate(2, password);
  }
  function input2_input_handler() {
    confirm = this.value;
    $$invalidate(3, confirm);
  }
  $$self.$$set = ($$props2) => {
    if ("loading" in $$props2)
      $$invalidate(0, loading = $$props2.loading);
    if ("username" in $$props2)
      $$invalidate(1, username = $$props2.username);
    if ("password" in $$props2)
      $$invalidate(2, password = $$props2.password);
    if ("errored" in $$props2)
      $$invalidate(5, errored = $$props2.errored);
  };
  return [
    loading,
    username,
    password,
    confirm,
    createAccount,
    errored,
    input0_input_handler,
    input1_input_handler,
    input2_input_handler
  ];
}
class Form extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4v, create_fragment$4N, safe_not_equal, {
      loading: 0,
      username: 1,
      password: 2,
      errored: 5
    });
  }
}
function create_else_block_1$6(ctx) {
  let loading_1;
  let current;
  loading_1 = new Loading$2({ props: { caption: "Welcome" } });
  return {
    c() {
      create_component(loading_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loading_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading_1, detaching);
    }
  };
}
function create_if_block_1$y(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2$a, create_else_block$E];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*errored*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$E(ctx) {
  let form;
  let updating_loading;
  let updating_username;
  let updating_password;
  let updating_errored;
  let current;
  function form_loading_binding(value) {
    ctx[5](value);
  }
  function form_username_binding(value) {
    ctx[6](value);
  }
  function form_password_binding(value) {
    ctx[7](value);
  }
  function form_errored_binding(value) {
    ctx[8](value);
  }
  let form_props = {};
  if (
    /*loading*/
    ctx[2] !== void 0
  ) {
    form_props.loading = /*loading*/
    ctx[2];
  }
  if (
    /*username*/
    ctx[0] !== void 0
  ) {
    form_props.username = /*username*/
    ctx[0];
  }
  if (
    /*password*/
    ctx[1] !== void 0
  ) {
    form_props.password = /*password*/
    ctx[1];
  }
  if (
    /*errored*/
    ctx[4] !== void 0
  ) {
    form_props.errored = /*errored*/
    ctx[4];
  }
  form = new Form({ props: form_props });
  binding_callbacks.push(() => bind$1(form, "loading", form_loading_binding));
  binding_callbacks.push(() => bind$1(form, "username", form_username_binding));
  binding_callbacks.push(() => bind$1(form, "password", form_password_binding));
  binding_callbacks.push(() => bind$1(form, "errored", form_errored_binding));
  return {
    c() {
      create_component(form.$$.fragment);
    },
    m(target, anchor) {
      mount_component(form, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const form_changes = {};
      if (!updating_loading && dirty & /*loading*/
      4) {
        updating_loading = true;
        form_changes.loading = /*loading*/
        ctx2[2];
        add_flush_callback(() => updating_loading = false);
      }
      if (!updating_username && dirty & /*username*/
      1) {
        updating_username = true;
        form_changes.username = /*username*/
        ctx2[0];
        add_flush_callback(() => updating_username = false);
      }
      if (!updating_password && dirty & /*password*/
      2) {
        updating_password = true;
        form_changes.password = /*password*/
        ctx2[1];
        add_flush_callback(() => updating_password = false);
      }
      if (!updating_errored && dirty & /*errored*/
      16) {
        updating_errored = true;
        form_changes.errored = /*errored*/
        ctx2[4];
        add_flush_callback(() => updating_errored = false);
      }
      form.$set(form_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(form.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(form.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(form, detaching);
    }
  };
}
function create_if_block_2$a(ctx) {
  let h1;
  let t1;
  let p2;
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Oh no";
      t1 = space();
      p2 = element("p");
      p2.textContent = "Sorry! Couldn't create your account... It may already exist. Please try\n        again or contact your server administrator.";
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      insert(target, t1, anchor);
      insert(target, p2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(h1);
        detach(t1);
        detach(p2);
      }
    }
  };
}
function create_if_block$1M(ctx) {
  let cancel;
  let current;
  cancel = new Cancel$1({ props: { show: (
    /*show*/
    ctx[3]
  ) } });
  return {
    c() {
      create_component(cancel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cancel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const cancel_changes = {};
      if (dirty & /*show*/
      8)
        cancel_changes.show = /*show*/
        ctx2[3];
      cancel.$set(cancel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cancel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cancel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cancel, detaching);
    }
  };
}
function create_fragment$4M(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t2;
  let current;
  const if_block_creators = [create_if_block_1$y, create_else_block_1$6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*loading*/
    ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = !/*loading*/
  ctx[2] && create_if_block$1M(ctx);
  return {
    c() {
      div = element("div");
      if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      attr(div, "class", "userlogin newuser");
      toggle_class(
        div,
        "errored",
        /*errored*/
        ctx[4]
      );
      toggle_class(
        div,
        "show",
        /*show*/
        ctx[3]
      );
      toggle_class(
        div,
        "loading",
        /*loading*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t2);
      }
      if (!/*loading*/
      ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*loading*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1M(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*errored*/
      16) {
        toggle_class(
          div,
          "errored",
          /*errored*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*show*/
      8) {
        toggle_class(
          div,
          "show",
          /*show*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*loading*/
      4) {
        toggle_class(
          div,
          "loading",
          /*loading*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance$4u($$self, $$props, $$invalidate) {
  let username = "";
  let password = "";
  let loading = false;
  let show = false;
  let errored = false;
  onMount(() => {
    setTimeout(() => {
      $$invalidate(3, show = true);
    });
  });
  function form_loading_binding(value) {
    loading = value;
    $$invalidate(2, loading);
  }
  function form_username_binding(value) {
    username = value;
    $$invalidate(0, username);
  }
  function form_password_binding(value) {
    password = value;
    $$invalidate(1, password);
  }
  function form_errored_binding(value) {
    errored = value;
    $$invalidate(4, errored);
  }
  return [
    username,
    password,
    loading,
    show,
    errored,
    form_loading_binding,
    form_username_binding,
    form_password_binding,
    form_errored_binding
  ];
}
class NewApiUser extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4u, create_fragment$4M, safe_not_equal, {});
  }
}
const LoginStates = /* @__PURE__ */ new Map([
  [
    "selector",
    {
      name: "User Selector",
      content: Selector$2,
      attribs: {
        topbar: true,
        darken: false
      },
      key: "selector"
    }
  ],
  [
    "todesktop",
    {
      name: "Login Redirector -> Desktop",
      content: UserLogin,
      attribs: {
        topbar: false,
        darken: true
      },
      key: "todesktop"
    }
  ],
  [
    "logoff",
    {
      name: "Desktop -> Logoff -> User Selector",
      content: Logoff,
      attribs: {
        topbar: false,
        darken: true
      },
      key: "logoff"
    }
  ],
  [
    "shutdown",
    {
      name: "Desktop -> Logoff -> End",
      content: Shutdown,
      attribs: {
        topbar: false,
        darken: true
      },
      key: "shutdown"
    }
  ],
  [
    "restart",
    {
      name: "Desktop -> Logoff -> Boot",
      content: Restart,
      attribs: {
        topbar: false,
        darken: true
      },
      key: "restart"
    }
  ],
  [
    "newapiuser",
    {
      name: "New User",
      content: NewApiUser,
      attribs: {
        topbar: false,
        darken: true
      },
      key: "newapiuser"
    }
  ],
  [
    "autologin",
    {
      name: "Auto Login",
      content: AutoLogin$1,
      attribs: {
        topbar: false,
        darken: true
      },
      key: "autologin"
    }
  ]
]);
const CurrentLoginState = writable();
const loginUsername = writable();
function applyLoginState(stateKey) {
  if (LoginStates.has(stateKey)) {
    Log(
      "login/main.ts: applyLoginState",
      `Applying state ${stateKey}`,
      LogLevel.info
    );
    const state = LoginStates.get(stateKey);
    CurrentLoginState.set(state);
    return;
  }
  InvalidStateBugrep("Login", stateKey);
}
async function loginOnMount() {
  const users = await getUsers();
  const remembered = localStorage.getItem("arcos-remembered-token");
  const state = get_store_value(CurrentLoginState);
  const server = get_store_value(ConnectedServer);
  setTimeout(() => {
    if (!state)
      applyLoginState("todesktop");
    if (!Object.keys(users).length && !remembered) {
      if (!server) {
        applyState("fts");
      } else {
        applyLoginState("newapiuser");
      }
      return;
    }
  }, 100);
}
async function loginUsingCreds(token) {
  Log(
    "ts/api/getter.ts: loginUsingCreds",
    `Authenticating using <token>`,
    LogLevel.info
  );
  let [name, password] = fromBase64(token).split(":");
  const server = get_store_value(ConnectedServer);
  loginUsername.set(name);
  let req = await apiCall(get_store_value(ConnectedServer), "auth", {}, null, {
    username: name,
    password
  });
  if (!req.valid)
    return false;
  UserToken.set(req.data.token);
  UserName.set(name);
  req = await apiCall(server, `user/properties`, {}, get_store_value(UserToken), null);
  if (!req.valid)
    return false;
  return req;
}
async function rememberedLogin() {
  Log(
    "ts/api/getter.ts: rememberedLogin",
    `Attempting login using arcos-remembered-token`,
    LogLevel.warn
  );
  const token = localStorage.getItem("arcos-remembered-token");
  if (!token) {
    localStorage.removeItem("arcos-remembered-token");
    return false;
  }
  const [username, password] = fromBase64(token).split(":");
  const userdata = await loginUsingCreds(
    generateCredToken({ username, password })
  );
  if (!userdata) {
    localStorage.removeItem("arcos-remembered-token");
    UserName.set(null);
    UserData$2.set(null);
    return false;
  }
  UserData$2.set(userdata);
  UserName.set(username);
  return true;
}
async function createUser(username, password) {
  const server = get_store_value(ConnectedServer);
  if (!server)
    return false;
  const req = await apiCall(server, "user/create", {}, null, {
    username: username.trim(),
    password
  });
  if (!req.valid) {
    return false;
  }
  const token = generateCredToken({ username, password });
  const userdata = await loginUsingCreds(token);
  if (!userdata)
    return false;
  userdata.acc.profilePicture = Math.floor(Math.random() * 29);
  await apiCall(
    server,
    "user/properties/update",
    {},
    token,
    null,
    JSON.stringify(userdata)
  );
  return userdata;
}
const UserAdd = {
  keyword: "useradd",
  async exec(cmd, argv, term) {
    const username = await term.std.read("Username: ", "", 25);
    const password = await term.std.read("Password: ", "", 128, true);
    const confirm = await term.std.read("Confirm Password: ", "", 128, true);
    if (!username)
      return term.std.Error(`Invalid username!`);
    if (password !== confirm)
      return term.std.Error(`Can't create ${username}: passwords don't match`);
    term.std.writeLine(`
Continue creating ${username}?
`);
    const confirmCreate = await term.std.select(["Confirm creation", "Stop!"]) == 0;
    if (!confirmCreate)
      return term.std.Warning("Aborted.");
    const userdata = await createUser(username, password);
    if (!userdata)
      return term.std.Error(`Creating user ${username} failed.`);
    term.std.writeColor(`User [${username}] created successfully!`, "aqua");
  },
  description: "Create a new user"
};
const Users = {
  keyword: "users",
  async exec(cmd, argv, term) {
    term.std.Warning("Clearing [UserCache]!");
    term.std.writeLine("\n");
    UserCache.clear();
    const users = await getUsers();
    const entries = Object.entries(users);
    const names = Object.keys(users);
    for (let i2 = 0; i2 < entries.length; i2++) {
      const role = entries[i2][1].acc.admin ? "Administrator" : "Regular user";
      const name = entries[i2][0].padEnd(getMaxLength(names), " ");
      term.std.writeColor(`[${name}]: ${role}`, "blue");
    }
  },
  description: "Display ArcAPI users"
};
function getMaxLength(users) {
  let length = 0;
  for (let i2 = 0; i2 < users.length; i2++) {
    if (users[i2].length > length)
      length = users[i2].length;
  }
  return length + 2;
}
const Vars = {
  keyword: "vars",
  async exec(cmd, argv, term) {
    const v2 = Object.entries(await term.vars.getAll());
    for (let i2 = 0; i2 < v2.length; i2++) {
      if (!v2[i2][1].value)
        continue;
      const str = v2[i2][1].value;
      const key2 = v2[i2][0].padEnd(20, " ");
      const prefix = v2[i2][1].readOnly ? "#" : " ";
      term.std.writeColor(`${prefix} [${key2}]: `, "aqua", "white", true);
      term.std.write(`${str}`);
      term.std.writeLine("");
    }
  },
  description: "List the variables"
};
const Ver = {
  keyword: "ver",
  exec(cmd, argv, term) {
    term.std.writeColor(`ArcOS & ArcTerm [v${ArcOSVersion}]`, "blue");
  },
  description: "Display the version number"
};
const Verbose = {
  keyword: "verbose",
  exec(cmd, argv, term) {
    const off = switchExists(argv, "off");
    const on = switchExists(argv, "on");
    if (off && on)
      return term.std.Error("Can't accept both --on and --off.");
    if (!off && !on)
      return term.std.Error("Missing --on or --off.");
    if (on)
      term.std.verbose = true;
    if (off)
      term.std.verbose = false;
  },
  description: "Set verbose mode on or off.",
  syntax: "--[on]? --[off]?"
};
const arcCommands = [
  ArcFetch,
  Cd,
  Clear,
  Dir$4,
  Echo,
  Vars,
  Exit$2,
  Help,
  History,
  Logout,
  Ls,
  Mkdir,
  Rm,
  Reload,
  Restart$1,
  Shutdown$1,
  InDesktop,
  Ver,
  Reset,
  Rf,
  Ri,
  Users,
  Read,
  Set$1,
  SoundBusCommand,
  Config,
  Exec,
  Verbose,
  Desktop$2,
  Servers,
  If,
  Goto,
  End,
  Goose,
  UserAdd,
  SUD,
  SleepCommand,
  BgCommand
];
const gooseBumpsCommands = [
  StateCommand,
  Colors,
  UDD,
  LogDump,
  BugRep,
  RepInfo,
  Err
];
const desktopSpecific = [
  AppList2,
  ATConf,
  Kill,
  oa,
  Open,
  Run,
  Poke
];
function create_fragment$4L(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "terminal-renderer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[3](div);
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*focus*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[3](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$4t($$self, $$props, $$invalidate) {
  let $focusedWindowId;
  component_subscribe($$self, focusedWindowId, ($$value) => $$invalidate(5, $focusedWindowId = $$value));
  let { app } = $$props;
  let arcTerm;
  let target;
  onMount(() => {
    $$invalidate(
      2,
      app.events.close = () => {
        if (!arcTerm)
          return;
        arcTerm.dispose();
        arcTerm = null;
      },
      app
    );
    $$invalidate(
      2,
      app.events.open = () => {
        if (!arcTerm) {
          arcTerm = new ArcTerm(
            target,
            [...arcCommands, ...desktopSpecific],
            app,
            (a2) => {
              a2.std.clear();
            }
          );
        }
        if (app.state.windowState.fll)
          fullscreenToggle(app.id);
      },
      app
    );
    $$invalidate(
      2,
      app.events.blur = () => {
        if (arcTerm && arcTerm.input && arcTerm.input.current)
          arcTerm.input.current.disabled = true;
      },
      app
    );
    $$invalidate(
      2,
      app.events.focus = () => {
        if (arcTerm && arcTerm.input && arcTerm.input.current)
          arcTerm.input.current.disabled = false;
      },
      app
    );
  });
  function focus() {
    if (!arcTerm || !arcTerm.input || !arcTerm.input.current || $focusedWindowId != "ArcTerm")
      return;
    arcTerm.input.current.focus();
    if (!target)
      return;
    target.scrollTo(0, target.scrollHeight);
  }
  setInterval(focus, 10);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      target = $$value;
      $$invalidate(0, target);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(2, app = $$props2.app);
  };
  return [target, focus, app, div_binding];
}
let ArcTerm_1$1 = class ArcTerm_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4t, create_fragment$4L, safe_not_equal, { app: 2 });
  }
};
const ArcTerm$1 = {
  info: {
    name: "ArcTerm",
    description: "ArcOS Terminal",
    builtin: true,
    version: "2.0.0",
    author: "ArcOS Team",
    icon: ArcTermIcon,
    preloaded: true,
    appGroup: "systemTools"
  },
  size: { w: 640, h: 480 },
  pos: { x: 60, y: 60 },
  minSize: { w: 350, h: 250 },
  maxSize: { w: NaN, h: NaN },
  controls: { min: true, max: true, cls: true },
  state: {
    headless: false,
    resizable: true,
    windowState: { min: false, max: false, fll: false }
  },
  content: ArcTerm_1$1,
  glass: true,
  events: {
    keyboardShortcuts: [
      {
        alt: true,
        shift: true,
        key: "f",
        action(app) {
          fullscreenToggle(app.id);
        }
      }
    ]
  }
};
const bugreports = "";
function create_fragment$4K(ctx) {
  let div1;
  let img;
  let img_src_value;
  let t0;
  let div0;
  let h1;
  let t1_value = (
    /*report*/
    (ctx[0].title || `Report from ${/*report*/
    ctx[0].author}`) + ""
  );
  let t1;
  let t2;
  let p2;
  let span;
  let t3_value = (
    /*report*/
    ctx[0].author + ""
  );
  let t3;
  let t4;
  let t5_value = (
    /*report*/
    (ctx[0].api || "No API") + ""
  );
  let t5;
  let t6;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      img = element("img");
      t0 = space();
      div0 = element("div");
      h1 = element("h1");
      t1 = text(t1_value);
      t2 = space();
      p2 = element("p");
      span = element("span");
      t3 = text(t3_value);
      t4 = text(" - ");
      t5 = text(t5_value);
      t6 = space();
      button = element("button");
      button.textContent = "chat";
      if (!src_url_equal(img.src, img_src_value = FileIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(h1, "data-contextmenu", "report-export");
      attr(
        h1,
        "data-id",
        /*id*/
        ctx[1]
      );
      attr(span, "class", "author");
      attr(button, "class", "material-icons-round show-body");
      attr(button, "title", "View report body");
      attr(div1, "class", "header");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, img);
      append(div1, t0);
      append(div1, div0);
      append(div0, h1);
      append(h1, t1);
      append(div0, t2);
      append(div0, p2);
      append(p2, span);
      append(span, t3);
      append(p2, t4);
      append(p2, t5);
      append(div1, t6);
      append(div1, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*showBody*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*report*/
      1 && t1_value !== (t1_value = /*report*/
      (ctx2[0].title || `Report from ${/*report*/
      ctx2[0].author}`) + ""))
        set_data(t1, t1_value);
      if (dirty & /*id*/
      2) {
        attr(
          h1,
          "data-id",
          /*id*/
          ctx2[1]
        );
      }
      if (dirty & /*report*/
      1 && t3_value !== (t3_value = /*report*/
      ctx2[0].author + ""))
        set_data(t3, t3_value);
      if (dirty & /*report*/
      1 && t5_value !== (t5_value = /*report*/
      (ctx2[0].api || "No API") + ""))
        set_data(t5, t5_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4s($$self, $$props, $$invalidate) {
  let { report } = $$props;
  let { id } = $$props;
  function showBody() {
    showOverlay("bodyView", "BugReports");
  }
  $$self.$$set = ($$props2) => {
    if ("report" in $$props2)
      $$invalidate(0, report = $$props2.report);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
  };
  return [report, id, showBody];
}
let Header$3 = class Header extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4s, create_fragment$4K, safe_not_equal, { report: 0, id: 1 });
  }
};
function create_fragment$4J(ctx) {
  let div1;
  return {
    c() {
      div1 = element("div");
      div1.innerHTML = `<div class="not-found"><img src="${BugRepIcon}" alt="Bug Reports"/> <p class="header">No Report Selected</p> <p>There is no report selected or the selected report no longer exists.</p></div>`;
      attr(div1, "class", "not-found-wrapper");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
    }
  };
}
let NotFound$1 = class NotFound extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$4J, safe_not_equal, {});
  }
};
function create_fragment$4I(ctx) {
  let div1;
  let div0;
  let t3;
  let button;
  let t4_value = (
    /*report*/
    ctx[0].userdata ? "Show Data" : "Not Provided"
  );
  let t4;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h1>User Data</h1> <p>Your ArcOS Settings</p>`;
      t3 = space();
      button = element("button");
      t4 = text(t4_value);
      attr(div0, "class", "left");
      button.disabled = button_disabled_value = !/*report*/
      ctx[0].userdata;
      attr(div1, "class", "detail");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t3);
      append(div1, button);
      append(button, t4);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*show*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*report*/
      1 && t4_value !== (t4_value = /*report*/
      ctx2[0].userdata ? "Show Data" : "Not Provided"))
        set_data(t4, t4_value);
      if (dirty & /*report*/
      1 && button_disabled_value !== (button_disabled_value = !/*report*/
      ctx2[0].userdata)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4r($$self, $$props, $$invalidate) {
  let { report } = $$props;
  function show() {
    showOverlay("udataExplorer", "BugReports");
  }
  $$self.$$set = ($$props2) => {
    if ("report" in $$props2)
      $$invalidate(0, report = $$props2.report);
  };
  return [report, show];
}
let UserData$1 = class UserData extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4r, create_fragment$4I, safe_not_equal, { report: 0 });
  }
};
function create_fragment$4H(ctx) {
  let div1;
  let div0;
  let t3;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h1>System Log</h1> <p>The Log from when it happened</p>`;
      t3 = space();
      button = element("button");
      button.textContent = "Show Data";
      attr(div0, "class", "left");
      attr(div1, "class", "detail");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t3);
      append(div1, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*show*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4q($$self) {
  function show() {
    showOverlay("systemLogView", "BugReports");
  }
  return [show];
}
let SystemLog$1 = class SystemLog extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4q, create_fragment$4H, safe_not_equal, {});
  }
};
let ISSUE_CACHE = [];
async function getReportIssue(id) {
  const report = await getReport(id);
  if (!report)
    return null;
  let issues = [];
  if (ISSUE_CACHE.length)
    issues = [...ISSUE_CACHE];
  else {
    issues = await (await fetch(
      "https://api.github.com/repos/IzK-ArcOS/ArcOS-Reports/issues?per_page=100"
    )).json();
    if (!issues.length)
      return null;
    ISSUE_CACHE = [...issues];
  }
  if (!issues.length)
    return null;
  for (let i2 = 0; i2 < issues.length; i2++) {
    if (issues[i2].body.includes(`br$${report.issueid}`))
      return issues[i2];
  }
  return null;
}
function create_else_block$D(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "No GitHub issue has referenced your report yet.";
      attr(p2, "class", "context none");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_if_block_1$x(ctx) {
  let p0;
  let t0;
  let t1_value = (
    /*issue*/
    ctx[1].user.login + ""
  );
  let t1;
  let t2;
  let br;
  let t3;
  let t4;
  let p1;
  let a2;
  let t5;
  let t6_value = (
    /*issue*/
    ctx[1].number + ""
  );
  let t6;
  let t7;
  let b2;
  let t8_value = (
    /*report*/
    ctx[0].issueid + ""
  );
  let t8;
  let t9;
  let mounted;
  let dispose;
  return {
    c() {
      p0 = element("p");
      t0 = text("Good news! Team member ");
      t1 = text(t1_value);
      t2 = text(" created a");
      br = element("br");
      t3 = text("\n      GitHub issue referencing your report.");
      t4 = space();
      p1 = element("p");
      a2 = element("a");
      t5 = text("Issue #");
      t6 = text(t6_value);
      t7 = text(" (References\n      ");
      b2 = element("b");
      t8 = text(t8_value);
      t9 = text(")");
      attr(p0, "class", "context");
      attr(p1, "class", "ref");
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      append(p0, t0);
      append(p0, t1);
      append(p0, t2);
      append(p0, br);
      append(p0, t3);
      insert(target, t4, anchor);
      insert(target, p1, anchor);
      append(p1, a2);
      append(a2, t5);
      append(a2, t6);
      append(p1, t7);
      append(p1, b2);
      append(b2, t8);
      append(p1, t9);
      if (!mounted) {
        dispose = listen(
          a2,
          "click",
          /*openIssue*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*issue*/
      2 && t1_value !== (t1_value = /*issue*/
      ctx2[1].user.login + ""))
        set_data(t1, t1_value);
      if (dirty & /*issue*/
      2 && t6_value !== (t6_value = /*issue*/
      ctx2[1].number + ""))
        set_data(t6, t6_value);
      if (dirty & /*report*/
      1 && t8_value !== (t8_value = /*report*/
      ctx2[0].issueid + ""))
        set_data(t8, t8_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p0);
        detach(t4);
        detach(p1);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1L(ctx) {
  let div;
  let spinner2;
  let t0;
  let p2;
  let current;
  spinner2 = new Spinner({ props: { height: 30 } });
  return {
    c() {
      div = element("div");
      create_component(spinner2.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.textContent = "Searching...";
      attr(div, "class", "loading");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(spinner2, div, null);
      append(div, t0);
      append(div, p2);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(spinner2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(spinner2);
    }
  };
}
function create_fragment$4G(ctx) {
  let div;
  let h1;
  let t1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$1L, create_if_block_1$x, create_else_block$D];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*loading*/
      ctx2[2]
    )
      return 0;
    if (
      /*issue*/
      ctx2[1]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      h1 = element("h1");
      h1.textContent = "GitHub Issue";
      t1 = space();
      if_block.c();
      attr(div, "class", "issue-detail");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h1);
      append(div, t1);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$4p($$self, $$props, $$invalidate) {
  let { id } = $$props;
  let { report } = $$props;
  let issue;
  let loading = false;
  onMount(update2);
  async function update2() {
    $$invalidate(2, loading = true);
    const i2 = await getReportIssue(id);
    $$invalidate(1, issue = i2);
    $$invalidate(2, loading = false);
  }
  function openIssue() {
    window.open(issue.html_url, "_blank");
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(4, id = $$props2.id);
    if ("report" in $$props2)
      $$invalidate(0, report = $$props2.report);
  };
  return [report, issue, loading, openIssue, id];
}
class Issue extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4p, create_fragment$4G, safe_not_equal, { id: 4, report: 0 });
  }
}
const MODE_CAPTIONS = {
  release: "Stable",
  development: "Development",
  unstable: "Unstable Build",
  admin: "Administrator",
  siege: "ArcSiege",
  rc: "Release Candidate",
  uwu: "UwU",
  esr: "Extended Support Release"
};
const More_svelte_svelte_type_style_lang = "";
function create_fragment$4F(ctx) {
  let div4;
  let h1;
  let t1;
  let p0;
  let t3;
  let div0;
  let p1;
  let t5;
  let p2;
  let t6;
  let t7_value = (
    /*report*/
    ctx[0].version + ""
  );
  let t7;
  let t8;
  let t9_value = (
    /*report*/
    ctx[0].mode_file + ""
  );
  let t9;
  let t10;
  let div1;
  let p3;
  let t12;
  let p4;
  let t13_value = (MODE_CAPTIONS[
    /*report*/
    ctx[0].mode_file || "release"
  ] || /*report*/
  ctx[0].mode_file) + "";
  let t13;
  let p4_title_value;
  let t14;
  let div2;
  let p5;
  let t16;
  let p6;
  let t17_value = (
    /*report*/
    ctx[0].desktop ? "Yes" : "No"
  );
  let t17;
  let t18;
  let div3;
  let p7;
  let t20;
  let p8;
  let t21_value = (
    /*report*/
    (ctx[0].useragent || "Not provided") + ""
  );
  let t21;
  return {
    c() {
      div4 = element("div");
      h1 = element("h1");
      h1.textContent = "More Information";
      t1 = space();
      p0 = element("p");
      p0.textContent = "Below follows more information about this bug report.";
      t3 = space();
      div0 = element("div");
      p1 = element("p");
      p1.textContent = "ArcOS Version";
      t5 = space();
      p2 = element("p");
      t6 = text("v");
      t7 = text(t7_value);
      t8 = text("-");
      t9 = text(t9_value);
      t10 = space();
      div1 = element("div");
      p3 = element("p");
      p3.textContent = "Mode";
      t12 = space();
      p4 = element("p");
      t13 = text(t13_value);
      t14 = space();
      div2 = element("div");
      p5 = element("p");
      p5.textContent = "Desktop app";
      t16 = space();
      p6 = element("p");
      t17 = text(t17_value);
      t18 = space();
      div3 = element("div");
      p7 = element("p");
      p7.textContent = "User Agent";
      t20 = space();
      p8 = element("p");
      t21 = text(t21_value);
      attr(p0, "class", "subtitle");
      attr(p1, "class", "name");
      attr(p2, "class", "value");
      attr(div0, "class", "info");
      attr(p3, "class", "name");
      attr(p4, "class", "value");
      attr(p4, "title", p4_title_value = /*report*/
      ctx[0].mode_file);
      attr(div1, "class", "info");
      attr(p5, "class", "name");
      attr(p6, "class", "value");
      attr(div2, "class", "info");
      attr(p7, "class", "name");
      attr(p8, "class", "value useragent svelte-s63uxe");
      attr(div3, "class", "info");
      attr(div4, "class", "more-info");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, h1);
      append(div4, t1);
      append(div4, p0);
      append(div4, t3);
      append(div4, div0);
      append(div0, p1);
      append(div0, t5);
      append(div0, p2);
      append(p2, t6);
      append(p2, t7);
      append(p2, t8);
      append(p2, t9);
      append(div4, t10);
      append(div4, div1);
      append(div1, p3);
      append(div1, t12);
      append(div1, p4);
      append(p4, t13);
      append(div4, t14);
      append(div4, div2);
      append(div2, p5);
      append(div2, t16);
      append(div2, p6);
      append(p6, t17);
      append(div4, t18);
      append(div4, div3);
      append(div3, p7);
      append(div3, t20);
      append(div3, p8);
      append(p8, t21);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*report*/
      1 && t7_value !== (t7_value = /*report*/
      ctx2[0].version + ""))
        set_data(t7, t7_value);
      if (dirty & /*report*/
      1 && t9_value !== (t9_value = /*report*/
      ctx2[0].mode_file + ""))
        set_data(t9, t9_value);
      if (dirty & /*report*/
      1 && t13_value !== (t13_value = (MODE_CAPTIONS[
        /*report*/
        ctx2[0].mode_file || "release"
      ] || /*report*/
      ctx2[0].mode_file) + ""))
        set_data(t13, t13_value);
      if (dirty & /*report*/
      1 && p4_title_value !== (p4_title_value = /*report*/
      ctx2[0].mode_file)) {
        attr(p4, "title", p4_title_value);
      }
      if (dirty & /*report*/
      1 && t17_value !== (t17_value = /*report*/
      ctx2[0].desktop ? "Yes" : "No"))
        set_data(t17, t17_value);
      if (dirty & /*report*/
      1 && t21_value !== (t21_value = /*report*/
      (ctx2[0].useragent || "Not provided") + ""))
        set_data(t21, t21_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
    }
  };
}
function instance$4o($$self, $$props, $$invalidate) {
  let { report } = $$props;
  $$self.$$set = ($$props2) => {
    if ("report" in $$props2)
      $$invalidate(0, report = $$props2.report);
  };
  return [report];
}
class More extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4o, create_fragment$4F, safe_not_equal, { report: 0 });
  }
}
function create_else_block$C(ctx) {
  let notfound;
  let current;
  notfound = new NotFound$1({});
  return {
    c() {
      create_component(notfound.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notfound, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(notfound.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notfound.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notfound, detaching);
    }
  };
}
function create_if_block$1K(ctx) {
  let header2;
  let t0;
  let userdata;
  let t1;
  let systemlog;
  let t2;
  let issue;
  let t3;
  let more;
  let current;
  header2 = new Header$3({
    props: {
      report: (
        /*data*/
        ctx[0]
      ),
      id: (
        /*id*/
        ctx[1]
      )
    }
  });
  userdata = new UserData$1({ props: { report: (
    /*data*/
    ctx[0]
  ) } });
  systemlog = new SystemLog$1({});
  issue = new Issue({
    props: {
      report: (
        /*data*/
        ctx[0]
      ),
      id: (
        /*id*/
        ctx[1]
      )
    }
  });
  more = new More({ props: { report: (
    /*data*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(header2.$$.fragment);
      t0 = space();
      create_component(userdata.$$.fragment);
      t1 = space();
      create_component(systemlog.$$.fragment);
      t2 = space();
      create_component(issue.$$.fragment);
      t3 = space();
      create_component(more.$$.fragment);
    },
    m(target, anchor) {
      mount_component(header2, target, anchor);
      insert(target, t0, anchor);
      mount_component(userdata, target, anchor);
      insert(target, t1, anchor);
      mount_component(systemlog, target, anchor);
      insert(target, t2, anchor);
      mount_component(issue, target, anchor);
      insert(target, t3, anchor);
      mount_component(more, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty & /*data*/
      1)
        header_changes.report = /*data*/
        ctx2[0];
      if (dirty & /*id*/
      2)
        header_changes.id = /*id*/
        ctx2[1];
      header2.$set(header_changes);
      const userdata_changes = {};
      if (dirty & /*data*/
      1)
        userdata_changes.report = /*data*/
        ctx2[0];
      userdata.$set(userdata_changes);
      const issue_changes = {};
      if (dirty & /*data*/
      1)
        issue_changes.report = /*data*/
        ctx2[0];
      if (dirty & /*id*/
      2)
        issue_changes.id = /*id*/
        ctx2[1];
      issue.$set(issue_changes);
      const more_changes = {};
      if (dirty & /*data*/
      1)
        more_changes.report = /*data*/
        ctx2[0];
      more.$set(more_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(userdata.$$.fragment, local);
      transition_in(systemlog.$$.fragment, local);
      transition_in(issue.$$.fragment, local);
      transition_in(more.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(userdata.$$.fragment, local);
      transition_out(systemlog.$$.fragment, local);
      transition_out(issue.$$.fragment, local);
      transition_out(more.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
      }
      destroy_component(header2, detaching);
      destroy_component(userdata, detaching);
      destroy_component(systemlog, detaching);
      destroy_component(issue, detaching);
      destroy_component(more, detaching);
    }
  };
}
function create_fragment$4E(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$1K, create_else_block$C];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*data*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$4n($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let data;
  let id;
  onMount(() => {
    runtime.Selected.subscribe(async (v2) => {
      $$invalidate(0, data = null);
      if (!v2)
        return;
      await sleep(0);
      $$invalidate(0, data = await runtime.getReport(v2));
      $$invalidate(1, id = v2);
    });
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [data, id, runtime];
}
let Content$4 = class Content extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4n, create_fragment$4E, safe_not_equal, { runtime: 2 });
  }
};
function create_fragment$4D(ctx) {
  let div;
  let button0;
  let t3;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.innerHTML = `<span class="material-icons-round">add</span> <span>New Bug Report</span>`;
      t3 = space();
      button1 = element("button");
      button1.textContent = "autorenew";
      attr(button0, "class", "new");
      attr(button1, "class", "refresh material-icons-round");
      attr(div, "class", "bottom");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, t3);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*add*/
            ctx[1]
          ),
          listen(
            button1,
            "click",
            /*refresh*/
            ctx[0]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4m($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  function refresh() {
    runtime.refreshStore();
  }
  function add() {
    showOverlay("createReport", "BugReports");
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [refresh, add, runtime];
}
let Bottom$3 = class Bottom extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4m, create_fragment$4D, safe_not_equal, { runtime: 2 });
  }
};
function create_if_block$1J(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "close";
      attr(button, "class", "delete material-icons-round");
      attr(button, "title", "Remove Report");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*remove*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4C(ctx) {
  let button;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1_value = dayjs(
    /*report*/
    ctx[0].timestamp
  ).format("D MMM YYYY, HH:mm:ss") + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  let if_block = (
    /*selected*/
    ctx[2] && create_if_block$1J(ctx)
  );
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      if (!src_url_equal(img.src, img_src_value = /*statuses*/
      ctx[3][
        /*status*/
        ctx[1]
      ]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(img, "class", "icon");
      toggle_class(
        button,
        "selected",
        /*selected*/
        ctx[2]
      );
      toggle_class(
        button,
        "deleted",
        /*status*/
        ctx[1] == "deleted"
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, span);
      append(span, t1);
      append(button, t2);
      if (if_block)
        if_block.m(button, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*select*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*status*/
      2 && !src_url_equal(img.src, img_src_value = /*statuses*/
      ctx2[3][
        /*status*/
        ctx2[1]
      ])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*report*/
      1 && t1_value !== (t1_value = dayjs(
        /*report*/
        ctx2[0].timestamp
      ).format("D MMM YYYY, HH:mm:ss") + ""))
        set_data(t1, t1_value);
      if (
        /*selected*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1J(ctx2);
          if_block.c();
          if_block.m(button, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*selected*/
      4) {
        toggle_class(
          button,
          "selected",
          /*selected*/
          ctx2[2]
        );
      }
      if (dirty & /*status*/
      2) {
        toggle_class(
          button,
          "deleted",
          /*status*/
          ctx2[1] == "deleted"
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$4l($$self, $$props, $$invalidate) {
  const statuses = {
    deleted: BugRepIcon,
    issue: HelpCenterIcon,
    report: FileIcon
  };
  let status = "report";
  let { runtime } = $$props;
  let { report } = $$props;
  let selected = false;
  onMount(async () => {
    runtime.Selected.subscribe((v2) => $$invalidate(2, selected = v2 == report.id));
    if (!await reportExists(report.id))
      return $$invalidate(1, status = "deleted");
    if (await getReportIssue(report.id))
      $$invalidate(1, status = "issue");
  });
  function select() {
    runtime.Selected.set(report.id);
  }
  function remove() {
    createOverlayableError(
      {
        title: "Remove Report",
        message: `Are you sure you want to remove this report from your account? It will not be deleted from the Reports server, though nobody outside of the ArcOS Team will have access to the report.`,
        buttons: [
          {
            caption: "Keep",
            action() {
            }
          },
          {
            caption: "Remove Report",
            action: () => {
              runtime.deleteReport(report.id);
            },
            suggested: true
          }
        ],
        image: BugRepIcon
      },
      "BugReports"
    );
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(6, runtime = $$props2.runtime);
    if ("report" in $$props2)
      $$invalidate(0, report = $$props2.report);
  };
  return [report, status, selected, statuses, select, remove, runtime];
}
class Report extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4l, create_fragment$4C, safe_not_equal, { runtime: 6, report: 0 });
  }
}
function get_each_context$W(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2];
  return child_ctx;
}
function create_each_block$W(ctx) {
  let report_1;
  let current;
  report_1 = new Report({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      report: (
        /*report*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(report_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(report_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const report_1_changes = {};
      if (dirty & /*runtime*/
      1)
        report_1_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*store*/
      2)
        report_1_changes.report = /*report*/
        ctx2[2];
      report_1.$set(report_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(report_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(report_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(report_1, detaching);
    }
  };
}
function create_fragment$4B(ctx) {
  let div1;
  let div0;
  let t2;
  let bottom;
  let current;
  let each_value = ensure_array_like(
    /*store*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$W(get_each_context$W(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  bottom = new Bottom$3({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      create_component(bottom.$$.fragment);
      attr(div0, "class", "list");
      attr(div1, "class", "sidebar");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div1, t2);
      mount_component(bottom, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*runtime, store*/
      3) {
        each_value = ensure_array_like(
          /*store*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$W(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$W(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const bottom_changes = {};
      if (dirty & /*runtime*/
      1)
        bottom_changes.runtime = /*runtime*/
        ctx2[0];
      bottom.$set(bottom_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(bottom.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(bottom.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      destroy_component(bottom);
    }
  };
}
function instance$4k($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let store = [];
  onMount(() => {
    runtime.Store.subscribe((v2) => $$invalidate(1, store = v2));
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, store];
}
let SideBar$3 = class SideBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4k, create_fragment$4B, safe_not_equal, { runtime: 0 });
  }
};
function create_fragment$4A(ctx) {
  let sidebar;
  let t2;
  let content2;
  let current;
  sidebar = new SideBar$3({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  content2 = new Content$4({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(sidebar.$$.fragment);
      t2 = space();
      create_component(content2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sidebar, target, anchor);
      insert(target, t2, anchor);
      mount_component(content2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const sidebar_changes = {};
      if (dirty & /*runtime*/
      1)
        sidebar_changes.runtime = /*runtime*/
        ctx2[0];
      sidebar.$set(sidebar_changes);
      const content_changes = {};
      if (dirty & /*runtime*/
      1)
        content_changes.runtime = /*runtime*/
        ctx2[0];
      content2.$set(content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      transition_in(content2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      transition_out(content2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(sidebar, detaching);
      destroy_component(content2, detaching);
    }
  };
}
function instance$4j($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime];
}
let BugReports$1 = class BugReports extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4j, create_fragment$4A, safe_not_equal, { runtime: 0 });
  }
};
function create_fragment$4z(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "close";
      attr(button, "class", "overlay-close material-icons-round");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*closeThis*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4i($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { id } = $$props;
  function closeThis() {
    hideOverlay(id, app.id);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
    if ("id" in $$props2)
      $$invalidate(2, id = $$props2.id);
  };
  return [closeThis, app, id];
}
class CloseButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4i, create_fragment$4z, safe_not_equal, { app: 1, id: 2 });
  }
}
const BodyView_svelte_svelte_type_style_lang = "";
function create_if_block$1I(ctx) {
  let textarea;
  return {
    c() {
      textarea = element("textarea");
      textarea.value = /*value*/
      ctx[2];
      textarea.readOnly = true;
      attr(textarea, "class", "svelte-1ov8mi7");
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*value*/
      4) {
        textarea.value = /*value*/
        ctx2[2];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(textarea);
      }
    }
  };
}
function create_fragment$4y(ctx) {
  let t2;
  let closebutton;
  let current;
  let if_block = (
    /*value*/
    ctx[2] && create_if_block$1I(ctx)
  );
  closebutton = new CloseButton({
    props: { app: (
      /*app*/
      ctx[0]
    ), id: (
      /*id*/
      ctx[1]
    ) }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t2 = space();
      create_component(closebutton.$$.fragment);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t2, anchor);
      mount_component(closebutton, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*value*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1I(ctx2);
          if_block.c();
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const closebutton_changes = {};
      if (dirty & /*app*/
      1)
        closebutton_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*id*/
      2)
        closebutton_changes.id = /*id*/
        ctx2[1];
      closebutton.$set(closebutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(closebutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(closebutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_component(closebutton, detaching);
    }
  };
}
function instance$4h($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { app } = $$props;
  let { id } = $$props;
  let value = "";
  runtime.OpenedReport.subscribe((v2) => {
    if (!v2)
      return;
    $$invalidate(2, value = `${v2.title}
${v2.author} - ${v2.issueid}

${v2.body}`);
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
  };
  return [app, id, value, runtime];
}
class BodyView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4h, create_fragment$4y, safe_not_equal, { runtime: 3, app: 0, id: 1 });
  }
}
const createreport = "";
function create_fragment$4x(ctx) {
  let p0;
  let t1;
  let h4;
  let t3;
  let ul;
  let li0;
  let t5;
  let li1;
  let t9;
  let li2;
  let t11;
  let li3;
  let t13;
  let li4;
  let t15;
  let p1;
  return {
    c() {
      p0 = element("p");
      p0.textContent = "In order to make bug reports useful for the ArcOS developers, we collect some\n  required data that we use to resolve the problem.";
      t1 = space();
      h4 = element("h4");
      h4.textContent = "This data includes:";
      t3 = space();
      ul = element("ul");
      li0 = element("li");
      li0.textContent = "The ArcOS Log (without API and AuthCode);";
      t5 = space();
      li1 = element("li");
      li1.textContent = `The version of ArcOS and its mode (${ARCOS_MODE.toUpperCase()} in this case);`;
      t9 = space();
      li2 = element("li");
      li2.textContent = "Your User Agent string;";
      t11 = space();
      li3 = element("li");
      li3.textContent = "The frontend URL;";
      t13 = space();
      li4 = element("li");
      li4.textContent = "and the development metadata.";
      t15 = space();
      p1 = element("p");
      p1.innerHTML = `By clicking <b>I agree</b> you acknowledge that Bug Reports may include the
  aforementioned
  <b>required</b> data in the report, optionally including the
  <i>ArcAPI hostname</i> and your ArcOS Account preferences.`;
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      insert(target, t1, anchor);
      insert(target, h4, anchor);
      insert(target, t3, anchor);
      insert(target, ul, anchor);
      append(ul, li0);
      append(ul, t5);
      append(ul, li1);
      append(ul, t9);
      append(ul, li2);
      append(ul, t11);
      append(ul, li3);
      append(ul, t13);
      append(ul, li4);
      insert(target, t15, anchor);
      insert(target, p1, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p0);
        detach(t1);
        detach(h4);
        detach(t3);
        detach(ul);
        detach(t15);
        detach(p1);
      }
    }
  };
}
class DataPrivacy extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$4x, safe_not_equal, {});
  }
}
function create_fragment$4w(ctx) {
  let div0;
  let h2;
  let t1;
  let p0;
  let t5;
  let div1;
  let input0;
  let t6;
  let textarea;
  let t7;
  let div4;
  let div2;
  let p1;
  let t9;
  let input1;
  let t10;
  let div3;
  let p2;
  let t12;
  let input2;
  let t13;
  let div6;
  let div5;
  let t20;
  let button0;
  let t22;
  let button1;
  let t23;
  let t24;
  let button2;
  let t25;
  let button2_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div0 = element("div");
      h2 = element("h2");
      h2.textContent = "Create Bug Report";
      t1 = space();
      p0 = element("p");
      p0.textContent = `You're submitting a bug report for ArcOS ${ArcOSVersion}.`;
      t5 = space();
      div1 = element("div");
      input0 = element("input");
      t6 = space();
      textarea = element("textarea");
      t7 = space();
      div4 = element("div");
      div2 = element("div");
      p1 = element("p");
      p1.textContent = "Include preferences";
      t9 = space();
      input1 = element("input");
      t10 = space();
      div3 = element("div");
      p2 = element("p");
      p2.textContent = "Include ArcAPI";
      t12 = space();
      input2 = element("input");
      t13 = space();
      div6 = element("div");
      div5 = element("div");
      div5.textContent = `ArcOS ${ArcOSVersion}-${ARCOS_MODE} - ${DESKTOP_MODE}`;
      t20 = space();
      button0 = element("button");
      button0.textContent = "Data Privacy";
      t22 = space();
      button1 = element("button");
      t23 = text("Cancel");
      t24 = space();
      button2 = element("button");
      t25 = text("Send Report");
      attr(h2, "class", "header");
      attr(p0, "class", "subheader");
      attr(div0, "class", "overlay-head");
      attr(input0, "type", "text");
      attr(input0, "class", "title");
      attr(input0, "placeholder", "Report Title");
      attr(textarea, "class", "body");
      attr(textarea, "placeholder", "Report Body: Provide any particular information about the bug here.");
      attr(div1, "class", "form");
      attr(p1, "class", "caption");
      attr(input1, "type", "checkbox");
      input1.disabled = /*locked*/
      ctx[0];
      attr(div2, "class", "choice");
      attr(p2, "class", "caption");
      attr(input2, "type", "checkbox");
      input2.disabled = /*locked*/
      ctx[0];
      attr(div3, "class", "choice");
      attr(div4, "class", "choices");
      attr(div5, "class", "left");
      button1.disabled = /*locked*/
      ctx[0];
      button2.disabled = button2_disabled_value = !/*Options*/
      ctx[1].title || /*locked*/
      ctx[0];
      attr(div6, "class", "bottom");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, h2);
      append(div0, t1);
      append(div0, p0);
      insert(target, t5, anchor);
      insert(target, div1, anchor);
      append(div1, input0);
      set_input_value(
        input0,
        /*Options*/
        ctx[1].title
      );
      append(div1, t6);
      append(div1, textarea);
      set_input_value(
        textarea,
        /*Options*/
        ctx[1].body
      );
      insert(target, t7, anchor);
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, p1);
      append(div2, t9);
      append(div2, input1);
      input1.checked = /*Options*/
      ctx[1].includeUserData;
      append(div4, t10);
      append(div4, div3);
      append(div3, p2);
      append(div3, t12);
      append(div3, input2);
      input2.checked = /*Options*/
      ctx[1].includeApi;
      insert(target, t13, anchor);
      insert(target, div6, anchor);
      append(div6, div5);
      append(div6, t20);
      append(div6, button0);
      append(div6, t22);
      append(div6, button1);
      append(button1, t23);
      append(div6, t24);
      append(div6, button2);
      append(button2, t25);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[6]
          ),
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[7]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[8]
          ),
          listen(
            input2,
            "change",
            /*input2_change_handler*/
            ctx[9]
          ),
          listen(
            button0,
            "click",
            /*info*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*hide*/
            ctx[3]
          ),
          listen(
            button2,
            "click",
            /*create*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Options*/
      2 && input0.value !== /*Options*/
      ctx2[1].title) {
        set_input_value(
          input0,
          /*Options*/
          ctx2[1].title
        );
      }
      if (dirty & /*Options*/
      2) {
        set_input_value(
          textarea,
          /*Options*/
          ctx2[1].body
        );
      }
      if (dirty & /*locked*/
      1) {
        input1.disabled = /*locked*/
        ctx2[0];
      }
      if (dirty & /*Options*/
      2) {
        input1.checked = /*Options*/
        ctx2[1].includeUserData;
      }
      if (dirty & /*locked*/
      1) {
        input2.disabled = /*locked*/
        ctx2[0];
      }
      if (dirty & /*Options*/
      2) {
        input2.checked = /*Options*/
        ctx2[1].includeApi;
      }
      if (dirty & /*locked*/
      1) {
        button1.disabled = /*locked*/
        ctx2[0];
      }
      if (dirty & /*Options, locked*/
      3 && button2_disabled_value !== (button2_disabled_value = !/*Options*/
      ctx2[1].title || /*locked*/
      ctx2[0])) {
        button2.disabled = button2_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t5);
        detach(div1);
        detach(t7);
        detach(div4);
        detach(t13);
        detach(div6);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4g($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  const defaultOptions2 = {
    title: "",
    body: "",
    includeApi: true,
    includeUserData: false
  };
  let locked = false;
  let Options = { ...defaultOptions2 };
  async function create() {
    $$invalidate(0, locked = true);
    const id = await sendReport(Options);
    runtime.refreshStore();
    createOverlayableError(
      {
        title: "Report Sent",
        message: `Thank you! Report ${id} has been sent to the Reports server. Keep in mind that an issue may be created on GitHub referencing your report by an ArcOS team member.`,
        buttons: [
          {
            caption: "Understood",
            action() {
            },
            suggested: true
          }
        ]
      },
      "BugReports"
    );
    hide();
  }
  function hide() {
    $$invalidate(1, Options = { ...defaultOptions2 });
    $$invalidate(0, locked = false);
    hideOverlay("createReport", "BugReports");
  }
  function info() {
    $$invalidate(0, locked = true);
    createOverlayableError(
      {
        title: "Please keep in mind",
        component: DataPrivacy,
        buttons: [
          {
            caption: "I agree",
            action() {
              $$invalidate(0, locked = false);
            },
            suggested: true
          },
          { caption: "Decline", action: hide }
        ]
      },
      "BugReports"
    );
  }
  function input0_input_handler() {
    Options.title = this.value;
    $$invalidate(1, Options);
  }
  function textarea_input_handler() {
    Options.body = this.value;
    $$invalidate(1, Options);
  }
  function input1_change_handler() {
    Options.includeUserData = this.checked;
    $$invalidate(1, Options);
  }
  function input2_change_handler() {
    Options.includeApi = this.checked;
    $$invalidate(1, Options);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(5, runtime = $$props2.runtime);
  };
  return [
    locked,
    Options,
    create,
    hide,
    info,
    runtime,
    input0_input_handler,
    textarea_input_handler,
    input1_change_handler,
    input2_change_handler
  ];
}
class CreateReport extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4g, create_fragment$4w, safe_not_equal, { runtime: 5 });
  }
}
const SystemLog_svelte_svelte_type_style_lang = "";
function create_if_block$1H(ctx) {
  let textarea;
  let textarea_value_value;
  return {
    c() {
      textarea = element("textarea");
      textarea.readOnly = true;
      textarea.value = textarea_value_value = /*data*/
      ctx[2].log;
      attr(textarea, "class", "svelte-1ov8mi7");
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      4 && textarea_value_value !== (textarea_value_value = /*data*/
      ctx2[2].log)) {
        textarea.value = textarea_value_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(textarea);
      }
    }
  };
}
function create_fragment$4v(ctx) {
  let t2;
  let closebutton;
  let current;
  let if_block = (
    /*data*/
    ctx[2] && /*data*/
    ctx[2].log && create_if_block$1H(ctx)
  );
  closebutton = new CloseButton({
    props: { app: (
      /*app*/
      ctx[0]
    ), id: (
      /*id*/
      ctx[1]
    ) }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t2 = space();
      create_component(closebutton.$$.fragment);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t2, anchor);
      mount_component(closebutton, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*data*/
        ctx2[2] && /*data*/
        ctx2[2].log
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1H(ctx2);
          if_block.c();
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const closebutton_changes = {};
      if (dirty & /*app*/
      1)
        closebutton_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*id*/
      2)
        closebutton_changes.id = /*id*/
        ctx2[1];
      closebutton.$set(closebutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(closebutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(closebutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_component(closebutton, detaching);
    }
  };
}
function instance$4f($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { app } = $$props;
  let { id } = $$props;
  let data;
  onMount(() => {
    if (!runtime)
      return;
    runtime.OpenedReport.subscribe((v2) => $$invalidate(2, data = v2));
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
  };
  return [app, id, data, runtime];
}
class SystemLog2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4f, create_fragment$4v, safe_not_equal, { runtime: 3, app: 0, id: 1 });
  }
}
const ude = "";
function create_if_block$1G(ctx) {
  let div;
  let t2;
  let div_data_type_value;
  return {
    c() {
      div = element("div");
      t2 = text(
        /*value*/
        ctx[1]
      );
      attr(div, "class", "value");
      attr(div, "data-type", div_data_type_value = typeof /*value*/
      ctx[1]);
      attr(
        div,
        "data-value",
        /*value*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*value*/
      2)
        set_data(
          t2,
          /*value*/
          ctx2[1]
        );
      if (dirty & /*value*/
      2 && div_data_type_value !== (div_data_type_value = typeof /*value*/
      ctx2[1])) {
        attr(div, "data-type", div_data_type_value);
      }
      if (dirty & /*value*/
      2) {
        attr(
          div,
          "data-value",
          /*value*/
          ctx2[1]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$4u(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let if_block = typeof /*value*/
  ctx[1] != "object" && create_if_block$1G(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(
        /*key*/
        ctx[0]
      );
      t1 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "key");
      attr(div1, "class", "nodeinstance");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div1, t1);
      if (if_block)
        if_block.m(div1, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*key*/
      1)
        set_data(
          t0,
          /*key*/
          ctx2[0]
        );
      if (typeof /*value*/
      ctx2[1] != "object") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1G(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$4e($$self, $$props, $$invalidate) {
  let { key: key2 } = $$props;
  let { value } = $$props;
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(0, key2 = $$props2.key);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
  };
  return [key2, value];
}
class Node extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4e, create_fragment$4u, safe_not_equal, { key: 0, value: 1 });
  }
}
function get_each_context$V(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function create_if_block$1F(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(Object.entries(
    /*value*/
    ctx[1]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$V(get_each_context$V(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, value*/
      2) {
        each_value = ensure_array_like(Object.entries(
          /*value*/
          ctx2[1]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$V(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$V(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$V(ctx) {
  let branch;
  let current;
  branch = new Branch_12({
    props: {
      key: (
        /*child*/
        ctx[3][0]
      ),
      value: (
        /*child*/
        ctx[3][1]
      )
    }
  });
  return {
    c() {
      create_component(branch.$$.fragment);
    },
    m(target, anchor) {
      mount_component(branch, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const branch_changes = {};
      if (dirty & /*value*/
      2)
        branch_changes.key = /*child*/
        ctx2[3][0];
      if (dirty & /*value*/
      2)
        branch_changes.value = /*child*/
        ctx2[3][1];
      branch.$set(branch_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(branch.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(branch.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(branch, detaching);
    }
  };
}
function create_fragment$4t(ctx) {
  let div;
  let node;
  let t2;
  let current;
  node = new Node({
    props: {
      key: (
        /*key*/
        ctx[0]
      ),
      value: (
        /*value*/
        ctx[1]
      )
    }
  });
  let if_block = typeof /*value*/
  ctx[1] == "object" && /*value*/
  ctx[1] && create_if_block$1F(ctx);
  return {
    c() {
      div = element("div");
      create_component(node.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      toggle_class(div, "indent", !/*top*/
      ctx[2]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(node, div, null);
      append(div, t2);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const node_changes = {};
      if (dirty & /*key*/
      1)
        node_changes.key = /*key*/
        ctx2[0];
      if (dirty & /*value*/
      2)
        node_changes.value = /*value*/
        ctx2[1];
      node.$set(node_changes);
      if (typeof /*value*/
      ctx2[1] == "object" && /*value*/
      ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*value*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1F(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*top*/
      4) {
        toggle_class(div, "indent", !/*top*/
        ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(node.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(node.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(node);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$4d($$self, $$props, $$invalidate) {
  let { key: key2 } = $$props;
  let { value } = $$props;
  let { top = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(0, key2 = $$props2.key);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("top" in $$props2)
      $$invalidate(2, top = $$props2.top);
  };
  return [key2, value, top];
}
class Branch_12 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4d, create_fragment$4t, safe_not_equal, { key: 0, value: 1, top: 2 });
  }
}
function get_each_context$U(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2];
  return child_ctx;
}
function create_if_block$1E(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(Object.entries(
    /*$UserData*/
    ctx[0]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$U(get_each_context$U(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "userdata-explorer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, $UserData*/
      1) {
        each_value = ensure_array_like(Object.entries(
          /*$UserData*/
          ctx2[0]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$U(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$U(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block$B(ctx) {
  let node_1;
  let current;
  node_1 = new Node({
    props: {
      key: (
        /*node*/
        ctx[1][0]
      ),
      value: (
        /*node*/
        ctx[1][1]
      )
    }
  });
  return {
    c() {
      create_component(node_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const node_1_changes = {};
      if (dirty & /*$UserData*/
      1)
        node_1_changes.key = /*node*/
        ctx2[1][0];
      if (dirty & /*$UserData*/
      1)
        node_1_changes.value = /*node*/
        ctx2[1][1];
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
    }
  };
}
function create_if_block_1$w(ctx) {
  let branch;
  let current;
  branch = new Branch_12({
    props: {
      key: (
        /*node*/
        ctx[1][0]
      ),
      value: (
        /*node*/
        ctx[1][1]
      ),
      top: true
    }
  });
  return {
    c() {
      create_component(branch.$$.fragment);
    },
    m(target, anchor) {
      mount_component(branch, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const branch_changes = {};
      if (dirty & /*$UserData*/
      1)
        branch_changes.key = /*node*/
        ctx2[1][0];
      if (dirty & /*$UserData*/
      1)
        branch_changes.value = /*node*/
        ctx2[1][1];
      branch.$set(branch_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(branch.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(branch.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(branch, detaching);
    }
  };
}
function create_each_block$U(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t2;
  let current;
  const if_block_creators = [create_if_block_1$w, create_else_block$B];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof /*node*/
    ctx2[1][1] == "object")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      t2 = space();
      attr(div, "class", "toplevel-item");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t2);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t2);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_fragment$4s(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$UserData*/
    ctx[0] && create_if_block$1E(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$UserData*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$UserData*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1E(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$4c($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(0, $UserData = $$value));
  return [$UserData];
}
class UserDataExplorer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4c, create_fragment$4s, safe_not_equal, {});
  }
}
function create_if_block$1D(ctx) {
  let userdataexplorer;
  let current;
  userdataexplorer = new UserDataExplorer({
    props: { data: (
      /*data*/
      ctx[2].userdata
    ) }
  });
  return {
    c() {
      create_component(userdataexplorer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(userdataexplorer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const userdataexplorer_changes = {};
      if (dirty & /*data*/
      4)
        userdataexplorer_changes.data = /*data*/
        ctx2[2].userdata;
      userdataexplorer.$set(userdataexplorer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(userdataexplorer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(userdataexplorer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(userdataexplorer, detaching);
    }
  };
}
function create_fragment$4r(ctx) {
  let t2;
  let closebutton;
  let current;
  let if_block = (
    /*data*/
    ctx[2] && create_if_block$1D(ctx)
  );
  closebutton = new CloseButton({
    props: { app: (
      /*app*/
      ctx[0]
    ), id: (
      /*id*/
      ctx[1]
    ) }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t2 = space();
      create_component(closebutton.$$.fragment);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t2, anchor);
      mount_component(closebutton, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*data*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*data*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1D(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const closebutton_changes = {};
      if (dirty & /*app*/
      1)
        closebutton_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*id*/
      2)
        closebutton_changes.id = /*id*/
        ctx2[1];
      closebutton.$set(closebutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(closebutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(closebutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_component(closebutton, detaching);
    }
  };
}
function instance$4b($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { app } = $$props;
  let { id } = $$props;
  let data;
  onMount(() => {
    if (!runtime)
      return;
    runtime.OpenedReport.subscribe((v2) => $$invalidate(2, data = v2));
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
  };
  return [app, id, data, runtime];
}
class UserData2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4b, create_fragment$4r, safe_not_equal, { runtime: 3, app: 0, id: 1 });
  }
}
class AppRuntime {
  constructor(appData) {
    __publicField(this, "app");
    if (!appData.id) {
      Log(
        `applogic/runtime/main.ts`,
        `Can't create AppRuntime without valid app ID`,
        LogLevel.error
      );
      return;
    }
    this.app = appData;
  }
  Log(message, fn = "<anonymous>", level = LogLevel.info) {
    Log(`${this.app.id}Runtime: ${fn}`, message, level);
  }
}
class BugReportsRuntime extends AppRuntime {
  constructor(appData) {
    super(appData);
    __publicField(this, "Selected", writable());
    __publicField(this, "Store", writable([]));
    __publicField(this, "OpenedReport", writable(null));
    this.refreshStore();
    this.Selected.subscribe(async (v2) => {
      this.OpenedReport.set(await getReport(v2));
    });
  }
  getReports() {
    this.Log("Getting reports", "getReports");
    return getAppPreference("Reporting", "reports") || [];
  }
  async getReport(id) {
    if (!id)
      return;
    this.Log(`Getting report ${id}`, `getReport`);
    const deleted = !await reportExists(id);
    if (deleted) {
      createOverlayableError(
        {
          title: "Report Deleted!",
          message: `Report ${id} has been deleted from the reports server and it cannot be accessed. Do you want to delete it from your account?`,
          buttons: [
            { caption: "Keep", action() {
            } },
            {
              caption: "Remove Report",
              action: () => {
                this.deleteReport(id);
              },
              suggested: true
            }
          ],
          image: BugRepIcon
        },
        "BugReports"
      );
      return null;
    }
    return await getReport(id);
  }
  deleteReport(id) {
    this.Log(`Deleting local report ${id}...`, "deleteReport", LogLevel.warn);
    const reports = this.getReports();
    const result = reports.filter((report) => report.id != id);
    setAppPreference("Reporting", "reports", result);
    this.refreshStore();
    const selected = get_store_value(this.Selected);
    if (selected == id) {
      this.Selected.set(null);
      this.OpenedReport.set(null);
    }
  }
  async refreshStore() {
    this.Log(`Refreshing store`, "refreshStore");
    this.Store.set([]);
    await sleep(0);
    this.Store.set(this.getReports() || []);
  }
}
const BugReports2 = {
  info: {
    name: "Bug Reports",
    description: "View and manage your bug reports",
    builtin: true,
    version: "1.0.0",
    author: "ArcOS Team",
    icon: BugRepIcon,
    appGroup: "support"
  },
  size: { w: 750, h: 500 },
  pos: { x: 30, y: 40 },
  minSize: { w: 750, h: 500 },
  maxSize: { w: 900, h: 700 },
  controls: { min: true, max: false, cls: true },
  state: {
    headless: false,
    resizable: false,
    windowState: { min: false, max: false, fll: false }
  },
  content: BugReports$1,
  glass: true,
  runtime: BugReportsRuntime,
  overlays: {
    udataExplorer: {
      info: {
        name: "User Data",
        version: "1.0.0",
        author: "ArcOS Team"
      },
      content: UserData2,
      size: { w: 550, h: 400 },
      show: false
    },
    systemLogView: {
      info: {
        name: "View System Log",
        version: "1.0.0",
        author: "ArcOS Team"
      },
      content: SystemLog2,
      size: { w: 700, h: 450 },
      show: false
    },
    createReport: {
      info: {
        name: "Create Report",
        version: "1.0.0",
        author: "ArcOS Team"
      },
      content: CreateReport,
      size: { w: 550, h: 400 },
      show: false
    },
    bodyView: {
      info: {
        name: "View Body",
        version: "1.0.0",
        author: "ArcOS Team"
      },
      content: BodyView,
      size: { w: 550, h: 400 },
      show: false
    }
  }
};
const calculator = "";
class CS {
  constructor() {
    __publicField(this, "Source", "Calculator/main.ts:");
    __publicField(this, "AllowedKeys", [
      "+",
      "-",
      "/",
      "*",
      "7",
      "8",
      "9",
      "**",
      "4",
      "5",
      "6",
      "%",
      "1",
      "2",
      "3",
      "%%C",
      ".",
      "0",
      "00",
      "%%E"
    ]);
    __publicField(this, "Shortcuts", [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "/",
      "+",
      "-",
      "*"
    ]);
    __publicField(this, "Overrides", {
      "*": "x",
      "**": "^",
      "%": "mod"
    });
    __publicField(this, "altClasses", ["+", "-", "/", "*", "**", "%", "."]);
  }
}
const CalculatorStore = new CS();
const CalculatorValue = writable("");
class CL {
  constructor() {
    __publicField(this, "keys", []);
    __publicField(this, "Functions", {
      "%%C": ["C", () => CalculatorValue.set(""), "clear"],
      "%%E": ["=", () => this.evaluate(), "process"]
    });
    this.keys = this.compileKeys(CalculatorStore.AllowedKeys, CalculatorStore.Overrides);
  }
  eval(expr) {
    try {
      return Function(`'use strict'; return (${expr})`)();
    } catch {
      return expr;
    }
  }
  // Compile keypad keys by merging allowed keys and their overrides for the Calculator UI
  compileKeys(keys, overrides) {
    const value = [];
    for (let i2 = 0; i2 < keys.length; i2++) {
      let v2 = [null, null];
      v2[0] = overrides[keys[i2]] || keys[i2];
      v2[1] = keys[i2];
      value.push(v2);
    }
    return value;
  }
  // Calculate the calculator value and set it to itself
  evaluate() {
    Log(
      `${CalculatorStore.Source} evaluate`,
      `Evaluating sum ("${get_store_value(CalculatorValue)}")`,
      LogLevel.info
    );
    if (!CalculatorClass.isValid(get_store_value(CalculatorValue)))
      return false;
    const value = this.eval(get_store_value(CalculatorValue));
    CalculatorValue.set(value);
    return value;
  }
  // Tests the current value plus the new input to evaluate if it's valid.
  isValid(input) {
    if (!input || typeof input !== "string")
      return;
    Log(
      `${CalculatorStore.Source} isValid`,
      `Verifying input "${input}"...`,
      LogLevel.info
    );
    if (input.startsWith("%%"))
      return false;
    for (let i2 = 0; i2 < input.length; i2++) {
      if (CalculatorStore.AllowedKeys.includes(input[i2]))
        continue;
      Log(
        `${CalculatorStore.Source} isValid`,
        `Input "${input}" not valid.`,
        LogLevel.warn
      );
      return false;
    }
    return true;
  }
  // Generate a list of keyboard shortcuts from keys to pass to the Calculator AppData.
  generateKeyboardShortcuts() {
    let shortCuts = [];
    for (let i2 = 0; i2 < CalculatorStore.Shortcuts.length; i2++) {
      shortCuts.push({
        key: CalculatorStore.Shortcuts[i2],
        action: () => this.processKey(CalculatorStore.Shortcuts[i2])
      });
    }
    return shortCuts;
  }
  // Processes incoming key inputs from either the window
  // or the AppShortcuts (Calculator Events)
  processKey(key2) {
    Log(`${CalculatorStore.Source} processKey`, `Processing key "${key2}"`);
    if (!this.isValid(key2))
      return false;
    const newValue = `${get_store_value(CalculatorValue)}${key2}0`;
    if (!this.validate(newValue)) {
      Log(
        `${CalculatorStore.Source} Calculator/main.ts: processKey`,
        `Test sum "${newValue}" is not valid. Aborting.`,
        LogLevel.error
      );
      return false;
    }
    CalculatorValue.set(get_store_value(CalculatorValue) + key2);
  }
  validate(expr) {
    const re = /(?:(?:^|[-+_*%\/])(?:\s*-?\d+(\.\d+)?(?:[eE][+-]?\d+)?\s*))+$/;
    return re.test(expr);
  }
}
const CalculatorClass = new CL();
function get_each_context$T(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  return child_ctx;
}
function create_else_block$A(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${CalculatorClass.Functions[
        /*key*/
        ctx[4][1]
      ][0]} `;
      attr(button, "class", CalculatorClass.Functions[
        /*key*/
        ctx[4][1]
      ][2]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", CalculatorClass.Functions[
          /*key*/
          ctx[4][0]
        ][1]);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1C(ctx) {
  let button;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[1](
        /*key*/
        ctx[4]
      )
    );
  }
  return {
    c() {
      button = element("button");
      button.textContent = `${/*key*/
      ctx[4][0]} `;
      toggle_class(button, "empty", !/*key*/
      ctx[4][0]);
      toggle_class(button, "alt", CalculatorStore.altClasses.includes(
        /*key*/
        ctx[4][1]
      ));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$T(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (!/*key*/
    ctx2[4][0].startsWith("%%"))
      return create_if_block$1C;
    return create_else_block$A;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_fragment$4q(ctx) {
  let input;
  let t2;
  let div;
  let each_value = ensure_array_like(CalculatorClass.keys);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$T(get_each_context$T(ctx, each_value, i2));
  }
  return {
    c() {
      input = element("input");
      t2 = space();
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(input, "type", "text");
      attr(input, "class", "display");
      input.readOnly = true;
      input.value = /*value*/
      ctx[0];
      attr(div, "class", "keys");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        input.value = /*value*/
        ctx2[0];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(input);
        detach(t2);
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$4a($$self, $$props, $$invalidate) {
  let $CalculatorValue;
  component_subscribe($$self, CalculatorValue, ($$value) => $$invalidate(2, $CalculatorValue = $$value));
  let value = "";
  onMount(() => {
    CalculatorValue.subscribe((v2) => {
      Log("Calculator: CalculatorValue.subscribe", `Value of CalculatorValue<string> changed to "${$CalculatorValue}"`, LogLevel.info);
      $$invalidate(0, value = v2 || "0");
    });
  });
  const click_handler = (key2) => CalculatorClass.processKey(key2[1]);
  return [value, click_handler];
}
class Calculator extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4a, create_fragment$4q, safe_not_equal, {});
  }
}
const CalculatorApp = {
  info: {
    name: "Calculator",
    description: "ArcOS Calculator",
    builtin: true,
    version: "2.0.0",
    author: "Izaak Kuipers",
    icon: CalculatorIcon,
    appGroup: "utilities"
  },
  size: { w: 340, h: NaN },
  pos: { x: 60, y: 60 },
  minSize: { w: 340, h: 412 },
  maxSize: { w: 340, h: 422 },
  controls: { min: true, max: false, cls: true },
  state: {
    headless: false,
    resizable: false,
    windowState: { min: false, max: false, fll: false }
  },
  content: Calculator,
  glass: true,
  events: {
    close() {
      CalculatorValue.set("");
    },
    open() {
      CalculatorValue.set("");
    },
    keyboardShortcuts: [
      ...CalculatorClass.generateKeyboardShortcuts(),
      { key: "enter", action: () => CalculatorClass.evaluate() },
      { key: "escape", action: () => CalculatorValue.set("") }
    ]
  }
};
let A$1 = 1;
let B$1 = 1;
function tick$1() {
  const b2 = [];
  const z2 = [];
  A$1 += 0.07;
  B$1 += 0.03;
  let cA = Math.cos(A$1), sA = Math.sin(A$1), cB = Math.cos(B$1), sB = Math.sin(B$1);
  for (let k2 = 0; k2 < 1760; k2++) {
    b2[k2] = k2 % 80 == 79 ? "\n" : " ";
    z2[k2] = 0;
  }
  for (let j2 = 0; j2 < 6.28; j2 += 0.07) {
    let ct2 = Math.cos(j2), st2 = Math.sin(j2);
    for (let i2 = 0; i2 < 6.28; i2 += 0.02) {
      let sp = Math.sin(i2), cp = Math.cos(i2), h2 = ct2 + 2, D2 = 1 / (sp * h2 * sA + st2 * cA + 5), t2 = sp * h2 * cA - st2 * sA;
      let x2 = 0 | 40 + 30 * D2 * (cp * h2 * cB - t2 * sB), y2 = 0 | 12 + 15 * D2 * (cp * h2 * sB + t2 * cB), o2 = x2 + 80 * y2, N2 = 0 | 8 * ((st2 * sA - sp * ct2 * cA) * cB - sp * ct2 * sA - st2 * cA - cp * ct2 * sB);
      if (y2 < 22 && y2 >= 0 && x2 >= 0 && x2 < 79 && D2 > z2[o2]) {
        z2[o2] = D2;
        b2[o2] = ".,-~:;=!*#$@"[N2 > 0 ? N2 : 0];
      }
      const debug = {
        o: o2,
        A: A$1,
        B: B$1,
        N: N2,
        st: st2,
        sA,
        sp,
        ct: ct2,
        cA,
        cB,
        cp,
        sB,
        D: D2,
        t: t2,
        h: h2,
        i: i2,
        j: j2,
        x: x2,
        y: y2,
        cycles: (A$1 / 0.07 / 89.71428571428571).toFixed(2)
      };
      donutDebugInformation.set(debug);
    }
  }
  return b2.join("");
}
const donutDebugInformation = writable();
const Donut_svelte_svelte_type_style_lang = "";
function get_each_context$S(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function create_if_block$1B(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(Object.entries(
    /*$donutDebugInformation*/
    ctx[1]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$S(get_each_context$S(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, $donutDebugInformation*/
      2) {
        each_value = ensure_array_like(Object.entries(
          /*$donutDebugInformation*/
          ctx2[1]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$S(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$S(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block$z(ctx) {
  let t_value = (
    /*entry*/
    ctx[3][1] + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$donutDebugInformation*/
      2 && t_value !== (t_value = /*entry*/
      ctx2[3][1] + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$v(ctx) {
  let t_value = (
    /*entry*/
    ctx[3][1].toFixed(8) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$donutDebugInformation*/
      2 && t_value !== (t_value = /*entry*/
      ctx2[3][1].toFixed(8) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_each_block$S(ctx) {
  let tr;
  let td0;
  let t0_value = (
    /*entry*/
    ctx[3][0] + ""
  );
  let t0;
  let t1;
  let td1;
  let t2;
  function select_block_type(ctx2, dirty) {
    if (typeof /*entry*/
    ctx2[3][1] == "number")
      return create_if_block_1$v;
    return create_else_block$z;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      if_block.c();
      t2 = space();
      attr(td0, "class", "svelte-u78920");
      attr(td1, "class", "svelte-u78920");
      attr(tr, "class", "svelte-u78920");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      if_block.m(td1, null);
      append(tr, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$donutDebugInformation*/
      2 && t0_value !== (t0_value = /*entry*/
      ctx2[3][0] + ""))
        set_data(t0, t0_value);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(td1, null);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      if_block.d();
    }
  };
}
function create_fragment$4p(ctx) {
  let div;
  let pre;
  let t0;
  let t1;
  let table;
  let if_block = (
    /*$donutDebugInformation*/
    ctx[1] && create_if_block$1B(ctx)
  );
  return {
    c() {
      div = element("div");
      pre = element("pre");
      t0 = text(
        /*value*/
        ctx[0]
      );
      t1 = space();
      table = element("table");
      if (if_block)
        if_block.c();
      attr(pre, "class", "svelte-u78920");
      attr(table, "class", "svelte-u78920");
      attr(div, "data-contextmenu", "donut-target");
      attr(div, "class", "svelte-u78920");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, pre);
      append(pre, t0);
      append(div, t1);
      append(div, table);
      if (if_block)
        if_block.m(table, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*value*/
      1)
        set_data(
          t0,
          /*value*/
          ctx2[0]
        );
      if (
        /*$donutDebugInformation*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1B(ctx2);
          if_block.c();
          if_block.m(table, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
let fps = 30;
function instance$49($$self, $$props, $$invalidate) {
  let $donutSpinning;
  let $donutDebugInformation;
  component_subscribe($$self, donutSpinning, ($$value) => $$invalidate(2, $donutSpinning = $$value));
  component_subscribe($$self, donutDebugInformation, ($$value) => $$invalidate(1, $donutDebugInformation = $$value));
  let value = "";
  setInterval(
    () => {
      if ($donutSpinning)
        $$invalidate(0, value = tick$1());
    },
    1e3 / fps
  );
  return [value, $donutDebugInformation];
}
class Donut extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$49, create_fragment$4p, safe_not_equal, {});
  }
}
const DonutApp = {
  info: {
    name: "Donut",
    description: "A spinning ASCII donut",
    builtin: true,
    version: ArcOSVersion,
    author: "Andy Sloane (ArcOS port by IzK)",
    icon: DonutIcon,
    appGroup: "entertainment"
  },
  size: { w: 850, h: 520 },
  pos: { x: 30, y: 40 },
  minSize: { w: 850, h: 520 },
  maxSize: { w: 850, h: NaN },
  controls: { min: true, max: true, cls: true },
  state: {
    headless: false,
    resizable: true,
    windowState: { min: false, max: false, fll: false }
  },
  content: Donut,
  glass: true,
  events: {
    open() {
      donutSpinning.set(true);
    },
    close() {
      donutSpinning.set(false);
    },
    blur() {
      donutSpinning.set(false);
    },
    focus() {
      donutSpinning.set(true);
    }
  }
};
const donutSpinning = writable(false);
function create_fragment$4o(ctx) {
  let p2;
  let t1;
  let br;
  let t2;
  let input0;
  let t3;
  let input1;
  let t4;
  let input2;
  let t5;
  let input3;
  let t6;
  let button;
  let t7;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "Specify the title and message to create an error message:";
      t1 = space();
      br = element("br");
      t2 = space();
      input0 = element("input");
      t3 = space();
      input1 = element("input");
      t4 = space();
      input2 = element("input");
      t5 = space();
      input3 = element("input");
      t6 = space();
      button = element("button");
      t7 = text("Create");
      attr(input0, "placeholder", "title");
      attr(input0, "class", "fullwidth");
      attr(input1, "placeholder", "message");
      attr(input1, "class", "fullwidth");
      attr(input2, "placeholder", "button caption 1");
      attr(input2, "class", "fullwidth");
      attr(input3, "placeholder", "button caption 2");
      attr(input3, "class", "fullwidth");
      button.disabled = button_disabled_value = !/*t*/
      ctx[0] || !/*m*/
      ctx[1];
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      insert(target, t1, anchor);
      insert(target, br, anchor);
      insert(target, t2, anchor);
      insert(target, input0, anchor);
      set_input_value(
        input0,
        /*t*/
        ctx[0]
      );
      insert(target, t3, anchor);
      insert(target, input1, anchor);
      set_input_value(
        input1,
        /*m*/
        ctx[1]
      );
      insert(target, t4, anchor);
      insert(target, input2, anchor);
      set_input_value(
        input2,
        /*C1*/
        ctx[2]
      );
      insert(target, t5, anchor);
      insert(target, input3, anchor);
      set_input_value(
        input3,
        /*C2*/
        ctx[3]
      );
      insert(target, t6, anchor);
      insert(target, button, anchor);
      append(button, t7);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[5]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[6]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[7]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler*/
            ctx[8]
          ),
          listen(
            button,
            "click",
            /*c*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*t*/
      1 && input0.value !== /*t*/
      ctx2[0]) {
        set_input_value(
          input0,
          /*t*/
          ctx2[0]
        );
      }
      if (dirty & /*m*/
      2 && input1.value !== /*m*/
      ctx2[1]) {
        set_input_value(
          input1,
          /*m*/
          ctx2[1]
        );
      }
      if (dirty & /*C1*/
      4 && input2.value !== /*C1*/
      ctx2[2]) {
        set_input_value(
          input2,
          /*C1*/
          ctx2[2]
        );
      }
      if (dirty & /*C2*/
      8 && input3.value !== /*C2*/
      ctx2[3]) {
        set_input_value(
          input3,
          /*C2*/
          ctx2[3]
        );
      }
      if (dirty & /*t, m*/
      3 && button_disabled_value !== (button_disabled_value = !/*t*/
      ctx2[0] || !/*m*/
      ctx2[1])) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
        detach(t1);
        detach(br);
        detach(t2);
        detach(input0);
        detach(t3);
        detach(input1);
        detach(t4);
        detach(input2);
        detach(t5);
        detach(input3);
        detach(t6);
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$48($$self, $$props, $$invalidate) {
  let t2;
  let m3;
  let C1;
  let C2;
  function c2() {
    errorMessage(
      t2,
      m3,
      null,
      "ErrCre",
      {
        caption: C1,
        action: () => {
        }
      },
      {
        caption: C2,
        action: () => {
        }
      }
    );
  }
  function input0_input_handler() {
    t2 = this.value;
    $$invalidate(0, t2);
  }
  function input1_input_handler() {
    m3 = this.value;
    $$invalidate(1, m3);
  }
  function input2_input_handler() {
    C1 = this.value;
    $$invalidate(2, C1);
  }
  function input3_input_handler() {
    C2 = this.value;
    $$invalidate(3, C2);
  }
  return [
    t2,
    m3,
    C1,
    C2,
    c2,
    input0_input_handler,
    input1_input_handler,
    input2_input_handler,
    input3_input_handler
  ];
}
let ErrorCreator$1 = class ErrorCreator extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$48, create_fragment$4o, safe_not_equal, {});
  }
};
const ErrorCreator2 = {
  info: {
    name: "Error Message Summoner",
    description: "Use for testing only -- error message creator",
    builtin: true,
    version: ArcOSVersion,
    author: "Izaak Kuipers",
    icon: ErrorIcon,
    hidden: true
  },
  size: { w: 300, h: 267 },
  pos: { x: 30, y: 40 },
  minSize: { w: 300, h: 253 },
  maxSize: { w: 300, h: 253 },
  controls: { min: true, max: false, cls: true },
  state: {
    headless: false,
    resizable: false,
    windowState: { min: false, max: false, fll: false }
  },
  content: ErrorCreator$1,
  glass: true
};
const exit = "";
function create_fragment$4n(ctx) {
  let div1;
  let div0;
  let h3;
  let t1;
  let button0;
  let t5;
  let button1;
  let t9;
  let button2;
  let t13;
  let button3;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      h3 = element("h3");
      h3.textContent = "ArcOS";
      t1 = space();
      button0 = element("button");
      button0.innerHTML = `<span class="material-icons-round">power_settings_new</span> <p class="caption">Shutdown</p>`;
      t5 = space();
      button1 = element("button");
      button1.innerHTML = `<span class="material-icons-round">logout</span> <p class="caption">Logoff</p>`;
      t9 = space();
      button2 = element("button");
      button2.innerHTML = `<span class="material-icons-round">refresh</span> <p class="caption">Restart</p>`;
      t13 = space();
      button3 = element("button");
      button3.textContent = "Cancel";
      attr(h3, "class", "header");
      attr(button0, "class", "option");
      attr(button1, "class", "option");
      attr(button2, "class", "option");
      attr(button3, "class", "cancel");
      attr(div0, "class", "flex-stop");
      attr(div1, "class", "center-flex");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, h3);
      append(div0, t1);
      append(div0, button0);
      append(div0, t5);
      append(div0, button1);
      append(div0, t9);
      append(div0, button2);
      append(div0, t13);
      append(div0, button3);
      if (!mounted) {
        dispose = [
          listen(button0, "click", shutdown),
          listen(
            button1,
            "click",
            /*click_handler*/
            ctx[2]
          ),
          listen(
            button2,
            "click",
            /*click_handler_1*/
            ctx[3]
          ),
          listen(
            button3,
            "click",
            /*cancel*/
            ctx[0]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$47($$self, $$props, $$invalidate) {
  let { app } = $$props;
  function cancel() {
    isFullscreenWindow.set(false);
    closeWindow(app.id);
  }
  const click_handler = () => restart(true);
  const click_handler_1 = () => restart(false);
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
  };
  return [cancel, app, click_handler, click_handler_1];
}
let Exit$1 = class Exit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$47, create_fragment$4n, safe_not_equal, { app: 1 });
  }
};
const LogoutIcon = "" + new URL("logout-623be534.svg", import.meta.url).href;
const LockIcon = "" + new URL("lock-f6dca1ce.svg", import.meta.url).href;
const ShutdownIcon = "" + new URL("exit-ccaa87b5.svg", import.meta.url).href;
const RestartIcon = "" + new URL("restart-098d532d.svg", import.meta.url).href;
const power = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LockIcon,
  LogoutIcon,
  RestartIcon,
  ShutdownIcon
}, Symbol.toStringTag, { value: "Module" }));
const Exit2 = {
  info: {
    name: "Exit",
    description: "ArcOS Exit Menu",
    builtin: true,
    version: "2.0.0",
    author: "Izaak Kuipers",
    icon: ShutdownIcon,
    hidden: true,
    appGroup: "coreApps"
  },
  size: { w: 280, h: 50 },
  pos: { x: 0, y: 0 },
  minSize: { w: 280, h: 50 },
  maxSize: { w: 280, h: 50 },
  controls: { min: false, max: false, cls: true },
  state: {
    headless: true,
    resizable: false,
    windowState: { min: false, max: false, fll: true }
  },
  content: Exit$1,
  glass: true
};
const filebrowser = "";
const defaultDirectory = {
  files: [],
  directories: [],
  name: "",
  scopedPath: ""
};
function create_if_block$1A(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (!/*$fbState*/
    ctx2[0].home)
      return create_if_block_1$u;
    return create_else_block$y;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "bottom");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_block.d();
    }
  };
}
function create_else_block$y(ctx) {
  let div0;
  let t1;
  let div2;
  let div1;
  let t2;
  return {
    c() {
      div0 = element("div");
      div0.textContent = "Home";
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      t2 = text(
        /*$UserName*/
        ctx[1]
      );
      attr(div0, "class", "section");
      attr(div1, "class", "section");
      attr(div2, "class", "right");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserName*/
      2)
        set_data(
          t2,
          /*$UserName*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t1);
        detach(div2);
      }
    }
  };
}
function create_if_block_1$u(ctx) {
  let div0;
  let t0_value = (
    /*$fbState*/
    (ctx[0].currentDir || "./") + ""
  );
  let t0;
  let t1;
  let div1;
  let t2_value = (
    /*$fbState*/
    ctx[0].dirContents.name + ""
  );
  let t2;
  let t3;
  let div4;
  let div2;
  let t4_value = (
    /*$fbState*/
    ctx[0].dirContents.files.length + ""
  );
  let t4;
  let t5;
  let t6;
  let div3;
  let t7_value = (
    /*$fbState*/
    ctx[0].dirContents.directories.length + ""
  );
  let t7;
  let t8;
  return {
    c() {
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div4 = element("div");
      div2 = element("div");
      t4 = text(t4_value);
      t5 = text(" Files");
      t6 = space();
      div3 = element("div");
      t7 = text(t7_value);
      t8 = text(" Folders");
      attr(div0, "class", "section");
      attr(div1, "class", "section");
      attr(div2, "class", "section");
      attr(div3, "class", "section");
      attr(div4, "class", "right");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, t0);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      append(div1, t2);
      insert(target, t3, anchor);
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, t4);
      append(div2, t5);
      append(div4, t6);
      append(div4, div3);
      append(div3, t7);
      append(div3, t8);
    },
    p(ctx2, dirty) {
      if (dirty & /*$fbState*/
      1 && t0_value !== (t0_value = /*$fbState*/
      (ctx2[0].currentDir || "./") + ""))
        set_data(t0, t0_value);
      if (dirty & /*$fbState*/
      1 && t2_value !== (t2_value = /*$fbState*/
      ctx2[0].dirContents.name + ""))
        set_data(t2, t2_value);
      if (dirty & /*$fbState*/
      1 && t4_value !== (t4_value = /*$fbState*/
      ctx2[0].dirContents.files.length + ""))
        set_data(t4, t4_value);
      if (dirty & /*$fbState*/
      1 && t7_value !== (t7_value = /*$fbState*/
      ctx2[0].dirContents.directories.length + ""))
        set_data(t7, t7_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t1);
        detach(div1);
        detach(t3);
        detach(div4);
      }
    }
  };
}
function create_fragment$4m(ctx) {
  let if_block_anchor;
  let if_block = (
    /*$fbState*/
    ctx[0].dirContents && create_if_block$1A(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*$fbState*/
        ctx2[0].dirContents
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1A(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$46($$self, $$props, $$invalidate) {
  let $fbState;
  let $UserName;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(0, $fbState = $$value));
  component_subscribe($$self, UserName, ($$value) => $$invalidate(1, $UserName = $$value));
  return [$fbState, $UserName];
}
let Bottom$2 = class Bottom2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$46, create_fragment$4m, safe_not_equal, {});
  }
};
function getParentDirectory(p2) {
  Log(
    "fs/main.ts: getParentDirectory",
    `Getting parent of ${p2}`,
    LogLevel.info
  );
  const split = p2.split("/");
  if (p2 == "./")
    return p2;
  if (!split.length)
    return p2;
  if (split.length == 1)
    return "./";
  split.splice(-1);
  const newPath = split.join("/");
  return newPath;
}
function pinFile(path) {
  checkFilePins();
  const udata = get_store_value(UserData$2);
  if (udata.sh.desktop.pinnedFiles.includes(path))
    return false;
  udata.sh.desktop.pinnedFiles.push(path);
  UserData$2.set(udata);
  return true;
}
function unpinFile(path) {
  checkFilePins();
  const udata = get_store_value(UserData$2);
  const pins = udata.sh.desktop.pinnedFiles;
  if (!pins.includes(path))
    return false;
  pins.splice(pins.indexOf(path), 1);
  udata.sh.desktop.pinnedFiles = pins;
  UserData$2.set(udata);
  return true;
}
function isFilePinned(path) {
  const udata = get_store_value(UserData$2);
  const pins = udata.sh.desktop.pinnedFiles;
  return pins && pins.includes(path);
}
function checkFilePins() {
  const udata = get_store_value(UserData$2);
  if (udata.sh.desktop.pinnedFiles && Array.isArray(udata.sh.desktop.pinnedFiles))
    return true;
  udata.sh.desktop.pinnedFiles = [];
  UserData$2.set(udata);
  return false;
}
function create_fragment$4l(ctx) {
  let button;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let div1;
  let t1;
  let t2;
  let div2;
  let t3;
  let t4;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div1 = element("div");
      t1 = text(
        /*name*/
        ctx[1]
      );
      t2 = space();
      div2 = element("div");
      t3 = text("In ");
      t4 = text(
        /*parent*/
        ctx[2]
      );
      if (!src_url_equal(img.src, img_src_value = FileIcon))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*path*/
        ctx[0]
      );
      attr(div0, "class", "image");
      attr(div1, "class", "name");
      attr(div2, "class", "parent");
      attr(button, "data-contextmenu", "homepage-file");
      attr(
        button,
        "data-path",
        /*path*/
        ctx[0]
      );
      button.disabled = button_disabled_value = /*$fbState*/
      ctx[3].refreshing;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div0);
      append(div0, img);
      append(button, t0);
      append(button, div1);
      append(div1, t1);
      append(button, t2);
      append(button, div2);
      append(div2, t3);
      append(div2, t4);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*openFile*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*path*/
      1) {
        attr(
          img,
          "alt",
          /*path*/
          ctx2[0]
        );
      }
      if (dirty & /*name*/
      2)
        set_data(
          t1,
          /*name*/
          ctx2[1]
        );
      if (dirty & /*parent*/
      4)
        set_data(
          t4,
          /*parent*/
          ctx2[2]
        );
      if (dirty & /*path*/
      1) {
        attr(
          button,
          "data-path",
          /*path*/
          ctx2[0]
        );
      }
      if (dirty & /*$fbState*/
      8 && button_disabled_value !== (button_disabled_value = /*$fbState*/
      ctx2[3].refreshing)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$45($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(3, $fbState = $$value));
  let { path } = $$props;
  let name = "Unknown";
  let parent = "";
  onMount(() => {
    const split = path.split("/").filter((p2) => !!p2);
    $$invalidate(2, parent = split.length > 1 ? split[split.length - 2] : "ArcFS");
    $$invalidate(1, name = path.replace(getParentDirectory(path), "").replaceAll("/", "").trim());
  });
  async function openFile() {
    const partial = await getPartialFile(path);
    if (!partial) {
      notFound();
      return;
    }
    fbClass.openFile(partial);
  }
  function notFound() {
    createOverlayableError(
      {
        title: "File not found",
        message: `ArcOS was unable to open <code>${path}</code>: the file could not be found. Please check the path and try again.`,
        image: ErrorIcon,
        buttons: [
          {
            caption: "Unpin file",
            action() {
              unpinFile(path);
            }
          },
          {
            caption: "Okay",
            action() {
            },
            suggested: true
          }
        ]
      },
      "FileManager"
    );
  }
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(0, path = $$props2.path);
  };
  return [path, name, parent, $fbState, openFile];
}
let File$5 = class File extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$45, create_fragment$4l, safe_not_equal, { path: 0 });
  }
};
function get_each_context$R(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2];
  return child_ctx;
}
function create_if_block$1z(ctx) {
  let t2;
  let div;
  let current;
  let if_block = !/*files*/
  ctx[0].length && create_if_block_1$t();
  let each_value = ensure_array_like(
    /*files*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$R(get_each_context$R(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t2 = space();
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "files");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*files*/
      ctx2[0].length) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_1$t();
          if_block.c();
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*files*/
      1) {
        each_value = ensure_array_like(
          /*files*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$R(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$R(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(div);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_1$t(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "Files you pin will appear here.";
      attr(p2, "class", "no-files");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_each_block$R(ctx) {
  let file_1;
  let current;
  file_1 = new File$5({ props: { path: (
    /*file*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(file_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(file_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const file_1_changes = {};
      if (dirty & /*files*/
      1)
        file_1_changes.path = /*file*/
        ctx2[1];
      file_1.$set(file_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(file_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(file_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(file_1, detaching);
    }
  };
}
function create_fragment$4k(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*files*/
    ctx[0] && create_if_block$1z(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*files*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*files*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1z(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$44($$self, $$props, $$invalidate) {
  let files = [];
  UserData$2.subscribe(async (v2) => {
    const newFiles = v2.sh.desktop.pinnedFiles;
    $$invalidate(0, files = []);
    await sleep(0);
    $$invalidate(0, files = newFiles);
  });
  return [files];
}
class Files extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$44, create_fragment$4k, safe_not_equal, {});
  }
}
function create_fragment$4j(ctx) {
  let button;
  let img;
  let img_src_value;
  let t0;
  let div;
  let p2;
  let t1;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      div = element("div");
      p2 = element("p");
      t1 = text(
        /*name*/
        ctx[1]
      );
      if (!src_url_equal(img.src, img_src_value = FolderIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(p2, "class", "title");
      attr(button, "class", "folder");
      attr(button, "data-contextmenu", "homepage-folder");
      attr(
        button,
        "data-path",
        /*path*/
        ctx[0]
      );
      button.disabled = button_disabled_value = /*$fbState*/
      ctx[2].refreshing;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, div);
      append(div, p2);
      append(p2, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*open*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*name*/
      2)
        set_data(
          t1,
          /*name*/
          ctx2[1]
        );
      if (dirty & /*path*/
      1) {
        attr(
          button,
          "data-path",
          /*path*/
          ctx2[0]
        );
      }
      if (dirty & /*$fbState*/
      4 && button_disabled_value !== (button_disabled_value = /*$fbState*/
      ctx2[2].refreshing)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$43($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(2, $fbState = $$value));
  let { path } = $$props;
  let name = "";
  onMount(() => {
    $$invalidate(1, name = path.replace(getParentDirectory(path), "").replaceAll("/", "").trim());
  });
  function open() {
    fbClass.goToDirectory(path);
  }
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(0, path = $$props2.path);
  };
  return [path, name, $fbState, open];
}
let Folder$1 = class Folder extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$43, create_fragment$4j, safe_not_equal, { path: 0 });
  }
};
function get_each_context$Q(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2];
  return child_ctx;
}
function create_if_block_1$s(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "Folders you pin will appear here.";
      attr(p2, "class", "no-folders");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_if_block$1y(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*folders*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$Q(get_each_context$Q(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "dirs");
      toggle_class(div, "collapsed", !/*folders*/
      ctx[0].length);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*folders*/
      1) {
        each_value = ensure_array_like(
          /*folders*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$Q(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$Q(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*folders*/
      1) {
        toggle_class(div, "collapsed", !/*folders*/
        ctx2[0].length);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$Q(ctx) {
  let folder_1;
  let current;
  folder_1 = new Folder$1({ props: { path: (
    /*folder*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(folder_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(folder_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const folder_1_changes = {};
      if (dirty & /*folders*/
      1)
        folder_1_changes.path = /*folder*/
        ctx2[1];
      folder_1.$set(folder_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(folder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(folder_1, detaching);
    }
  };
}
function create_fragment$4i(ctx) {
  let t2;
  let if_block1_anchor;
  let current;
  let if_block0 = (!/*folders*/
  ctx[0] || !/*folders*/
  ctx[0].length) && create_if_block_1$s();
  let if_block1 = (
    /*folders*/
    ctx[0] && create_if_block$1y(ctx)
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*folders*/
      ctx2[0] || !/*folders*/
      ctx2[0].length) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_1$s();
          if_block0.c();
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*folders*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*folders*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1y(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function instance$42($$self, $$props, $$invalidate) {
  let folders = [];
  UserData$2.subscribe(async (v2) => {
    const newFolders = v2.sh.desktop.pinnedFolders;
    $$invalidate(0, folders = null);
    await sleep(0);
    $$invalidate(0, folders = newFolders);
  });
  return [folders];
}
let Folders$1 = class Folders extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$42, create_fragment$4i, safe_not_equal, {});
  }
};
function create_fragment$4h(ctx) {
  let div;
  let folders;
  let t2;
  let files;
  let current;
  folders = new Folders$1({});
  files = new Files({});
  return {
    c() {
      div = element("div");
      create_component(folders.$$.fragment);
      t2 = space();
      create_component(files.$$.fragment);
      attr(div, "class", "filebrowser-home");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(folders, div, null);
      append(div, t2);
      mount_component(files, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(folders.$$.fragment, local);
      transition_in(files.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folders.$$.fragment, local);
      transition_out(files.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(folders);
      destroy_component(files);
    }
  };
}
let Home$1 = class Home extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$4h, safe_not_equal, {});
  }
};
function create_fragment$4g(ctx) {
  let button;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let div1;
  let t1_value = (
    /*dir*/
    ctx[0].name + ""
  );
  let t1;
  let t2;
  let div2;
  let t4;
  let div3;
  let t6;
  let div4;
  let button_data_path_value;
  let button_data_name_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      div2.textContent = "Folder";
      t4 = space();
      div3 = element("div");
      div3.textContent = "-";
      t6 = space();
      div4 = element("div");
      div4.textContent = "-";
      if (!src_url_equal(img.src, img_src_value = FolderIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*dir*/
      ctx[0].name);
      attr(div0, "class", "image");
      attr(div1, "class", "name");
      attr(div2, "class", "mime");
      attr(div3, "class", "modified");
      attr(div4, "class", "size");
      attr(button, "class", "item dir");
      attr(button, "data-path", button_data_path_value = /*dir*/
      ctx[0].scopedPath);
      attr(button, "data-type", "dir");
      attr(button, "data-name", button_data_name_value = /*dir*/
      ctx[0].name);
      attr(button, "data-contextmenu", "listitem-dir");
      toggle_class(
        button,
        "selected",
        /*$fbState*/
        ctx[1].selectedFilename == /*dir*/
        ctx[0].name
      );
      toggle_class(
        button,
        "cutting",
        /*$fbState*/
        ctx[1].cuttingFilename && /*$fbState*/
        ctx[1].cuttingFilename.name == /*dir*/
        ctx[0].name
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div0);
      append(div0, img);
      append(button, t0);
      append(button, div1);
      append(div1, t1);
      append(button, t2);
      append(button, div2);
      append(button, t4);
      append(button, div3);
      append(button, t6);
      append(button, div4);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*select*/
            ctx[2]
          ),
          listen(
            button,
            "dblclick",
            /*open*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*dir*/
      1 && img_alt_value !== (img_alt_value = /*dir*/
      ctx2[0].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*dir*/
      1 && t1_value !== (t1_value = /*dir*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*dir*/
      1 && button_data_path_value !== (button_data_path_value = /*dir*/
      ctx2[0].scopedPath)) {
        attr(button, "data-path", button_data_path_value);
      }
      if (dirty & /*dir*/
      1 && button_data_name_value !== (button_data_name_value = /*dir*/
      ctx2[0].name)) {
        attr(button, "data-name", button_data_name_value);
      }
      if (dirty & /*$fbState, dir*/
      3) {
        toggle_class(
          button,
          "selected",
          /*$fbState*/
          ctx2[1].selectedFilename == /*dir*/
          ctx2[0].name
        );
      }
      if (dirty & /*$fbState, dir*/
      3) {
        toggle_class(
          button,
          "cutting",
          /*$fbState*/
          ctx2[1].cuttingFilename && /*$fbState*/
          ctx2[1].cuttingFilename.name == /*dir*/
          ctx2[0].name
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$41($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(1, $fbState = $$value));
  let { dir } = $$props;
  function select() {
    set_store_value(fbState, $fbState.selectedFilename = dir.name, $fbState);
  }
  function open() {
    fbClass.goToDirectory(dir.scopedPath);
  }
  $$self.$$set = ($$props2) => {
    if ("dir" in $$props2)
      $$invalidate(0, dir = $$props2.dir);
  };
  return [dir, $fbState, select, open];
}
let Dir$3 = class Dir extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$41, create_fragment$4g, safe_not_equal, { dir: 0 });
  }
};
const ArcAppMimeIcon = "" + new URL("application-arcapp-2a8df358.svg", import.meta.url).href;
const DefaultMimeIcon = "" + new URL("application-default-dbaaa566.svg", import.meta.url).href;
const JsonMimeIcon = "" + new URL("application-json-e04d619a.svg", import.meta.url).href;
const PdfMimeIcon = "" + new URL("application-pdf-7a1f0afa.svg", import.meta.url).href;
const SvgMimeIcon = "" + new URL("application-svg-944fd245.svg", import.meta.url).href;
const CompressMimeIcon = "" + new URL("application-x-compress-98d85b80.svg", import.meta.url).href;
const AudioMimeIcon = "" + new URL("audio-x-generic-73f31c65.svg", import.meta.url).href;
const ImageMimeIcon = "" + new URL("image-x-generic-0c29fb59.svg", import.meta.url).href;
const fileIcon = "" + new URL("text-plain-19145840.svg", import.meta.url).href;
const mimes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArcAppMimeIcon,
  AudioMimeIcon,
  CompressMimeIcon,
  DefaultMimeIcon,
  ImageMimeIcon,
  JsonMimeIcon,
  PdfMimeIcon,
  PlainMimeIcon: fileIcon,
  SvgMimeIcon
}, Symbol.toStringTag, { value: "Module" }));
const extensionIcons = [
  {
    extensions: [".png", ".jpg", ".bmp", ".gif", ".ico", ".webp"],
    image: ImageMimeIcon
  },
  {
    extensions: [".svg"],
    image: SvgMimeIcon
  },
  {
    extensions: [".md"],
    image: MarkDownViewerIcon
  },
  {
    extensions: [".app", ".ealc", ".app.json"],
    image: ArcAppMimeIcon
  },
  {
    extensions: [".pdf"],
    image: PdfMimeIcon
  },
  {
    extensions: [".txt"],
    image: fileIcon
  },
  {
    extensions: [".json"],
    image: JsonMimeIcon
  },
  {
    extensions: [".zip", ".tar", ".tar.gz", ".7z", ".rar"],
    image: CompressMimeIcon
  },
  {
    extensions: [".flac", ".mp3", ".wav"],
    image: AudioMimeIcon
  },
  {
    extensions: [".arctheme"],
    image: ThemesIcon
  },
  {
    extensions: ["arcterm.conf"],
    image: ArcTermIcon
  }
];
function getMimeIcon(filename) {
  for (let i2 = 0; i2 < extensionIcons.length; i2++) {
    const exts = extensionIcons[i2].extensions;
    for (let j2 = 0; j2 < exts.length; j2++) {
      if (filename.endsWith(exts[j2]))
        return extensionIcons[i2].image;
    }
  }
  return DefaultMimeIcon;
}
var relativeTime$1 = { exports: {} };
(function(module, exports) {
  !function(r2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    return function(r2, e2, t2) {
      r2 = r2 || {};
      var n2 = e2.prototype, o2 = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function i2(r3, e3, t3, o3) {
        return n2.fromToBase(r3, e3, t3, o3);
      }
      t2.en.relativeTime = o2, n2.fromToBase = function(e3, n3, i3, d4, u3) {
        for (var f2, a2, s2, l2 = i3.$locale().relativeTime || o2, h2 = r2.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], m3 = h2.length, c2 = 0; c2 < m3; c2 += 1) {
          var y2 = h2[c2];
          y2.d && (f2 = d4 ? t2(e3).diff(i3, y2.d, true) : i3.diff(e3, y2.d, true));
          var p2 = (r2.rounding || Math.round)(Math.abs(f2));
          if (s2 = f2 > 0, p2 <= y2.r || !y2.r) {
            p2 <= 1 && c2 > 0 && (y2 = h2[c2 - 1]);
            var v2 = l2[y2.l];
            u3 && (p2 = u3("" + p2)), a2 = "string" == typeof v2 ? v2.replace("%d", p2) : v2(p2, n3, y2.l, s2);
            break;
          }
        }
        if (n3)
          return a2;
        var M2 = s2 ? l2.future : l2.past;
        return "function" == typeof M2 ? M2(a2) : M2.replace("%s", a2);
      }, n2.to = function(r3, e3) {
        return i2(r3, e3, this, true);
      }, n2.from = function(r3, e3) {
        return i2(r3, e3, this);
      };
      var d3 = function(r3) {
        return r3.$u ? t2.utc() : t2();
      };
      n2.toNow = function(r3) {
        return this.to(d3(this), r3);
      }, n2.fromNow = function(r3) {
        return this.from(d3(this), r3);
      };
    };
  });
})(relativeTime$1);
var relativeTimeExports = relativeTime$1.exports;
const relativeTime = /* @__PURE__ */ getDefaultExportFromCjs(relativeTimeExports);
function create_fragment$4f(ctx) {
  let button1;
  let div0;
  let img_1;
  let img_1_src_value;
  let img_1_alt_value;
  let t0;
  let div1;
  let t1_value = (
    /*file*/
    ctx[0].filename + ""
  );
  let t1;
  let t2;
  let div2;
  let t3_value = (
    /*file*/
    ctx[0].mime.split("; ")[0].split("/").join(" - ") + ""
  );
  let t3;
  let t4;
  let div3;
  let t5_value = dayjs(
    /*file*/
    ctx[0].dateModified || null
  ).fromNow() + "";
  let t5;
  let t6;
  let div4;
  let t7_value = formatBytes(
    /*file*/
    ctx[0].size
  ) + "";
  let t7;
  let t8;
  let div5;
  let button0;
  let button1_title_value;
  let button1_data_path_value;
  let button1_data_name_value;
  let mounted;
  let dispose;
  return {
    c() {
      button1 = element("button");
      div0 = element("div");
      img_1 = element("img");
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      t3 = text(t3_value);
      t4 = space();
      div3 = element("div");
      t5 = text(t5_value);
      t6 = space();
      div4 = element("div");
      t7 = text(t7_value);
      t8 = space();
      div5 = element("div");
      button0 = element("button");
      button0.textContent = "launch";
      if (!src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx[1]))
        attr(img_1, "src", img_1_src_value);
      attr(img_1, "alt", img_1_alt_value = /*file*/
      ctx[0].filename);
      attr(div0, "class", "image");
      attr(div1, "class", "name");
      attr(div2, "class", "mime");
      attr(div3, "class", "modified");
      attr(div4, "class", "size");
      attr(button0, "class", "material-icons-round");
      attr(div5, "class", "options");
      attr(button1, "class", "item file");
      attr(button1, "title", button1_title_value = /*file*/
      ctx[0].scopedPath);
      attr(button1, "data-path", button1_data_path_value = /*file*/
      ctx[0].scopedPath);
      attr(button1, "data-type", "file");
      attr(button1, "data-name", button1_data_name_value = /*file*/
      ctx[0].filename);
      attr(button1, "data-contextmenu", "listitem-file");
      toggle_class(
        button1,
        "selected",
        /*$fbState*/
        ctx[2].selectedFilename == /*file*/
        ctx[0].filename
      );
      toggle_class(
        button1,
        "cutting",
        /*$fbState*/
        ctx[2].cuttingFilename && /*$fbState*/
        ctx[2].cuttingFilename.name == /*file*/
        ctx[0].filename
      );
    },
    m(target, anchor) {
      insert(target, button1, anchor);
      append(button1, div0);
      append(div0, img_1);
      append(button1, t0);
      append(button1, div1);
      append(div1, t1);
      append(button1, t2);
      append(button1, div2);
      append(div2, t3);
      append(button1, t4);
      append(button1, div3);
      append(div3, t5);
      append(button1, t6);
      append(button1, div4);
      append(div4, t7);
      append(button1, t8);
      append(button1, div5);
      append(div5, button0);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*select*/
            ctx[3]
          ),
          listen(
            button1,
            "contextmenu",
            /*select*/
            ctx[3]
          ),
          listen(
            button1,
            "dblclick",
            /*dblclick_handler*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*img*/
      2 && !src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx2[1])) {
        attr(img_1, "src", img_1_src_value);
      }
      if (dirty & /*file*/
      1 && img_1_alt_value !== (img_1_alt_value = /*file*/
      ctx2[0].filename)) {
        attr(img_1, "alt", img_1_alt_value);
      }
      if (dirty & /*file*/
      1 && t1_value !== (t1_value = /*file*/
      ctx2[0].filename + ""))
        set_data(t1, t1_value);
      if (dirty & /*file*/
      1 && t3_value !== (t3_value = /*file*/
      ctx2[0].mime.split("; ")[0].split("/").join(" - ") + ""))
        set_data(t3, t3_value);
      if (dirty & /*file*/
      1 && t5_value !== (t5_value = dayjs(
        /*file*/
        ctx2[0].dateModified || null
      ).fromNow() + ""))
        set_data(t5, t5_value);
      if (dirty & /*file*/
      1 && t7_value !== (t7_value = formatBytes(
        /*file*/
        ctx2[0].size
      ) + ""))
        set_data(t7, t7_value);
      if (dirty & /*file*/
      1 && button1_title_value !== (button1_title_value = /*file*/
      ctx2[0].scopedPath)) {
        attr(button1, "title", button1_title_value);
      }
      if (dirty & /*file*/
      1 && button1_data_path_value !== (button1_data_path_value = /*file*/
      ctx2[0].scopedPath)) {
        attr(button1, "data-path", button1_data_path_value);
      }
      if (dirty & /*file*/
      1 && button1_data_name_value !== (button1_data_name_value = /*file*/
      ctx2[0].filename)) {
        attr(button1, "data-name", button1_data_name_value);
      }
      if (dirty & /*$fbState, file*/
      5) {
        toggle_class(
          button1,
          "selected",
          /*$fbState*/
          ctx2[2].selectedFilename == /*file*/
          ctx2[0].filename
        );
      }
      if (dirty & /*$fbState, file*/
      5) {
        toggle_class(
          button1,
          "cutting",
          /*$fbState*/
          ctx2[2].cuttingFilename && /*$fbState*/
          ctx2[2].cuttingFilename.name == /*file*/
          ctx2[0].filename
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$40($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(2, $fbState = $$value));
  dayjs.extend(relativeTime);
  let { file } = $$props;
  let img = FileIcon;
  function select() {
    set_store_value(fbState, $fbState.selectedFilename = file.filename, $fbState);
  }
  onMount(() => {
    $$invalidate(1, img = getMimeIcon(file.filename));
  });
  fbState.subscribe(() => {
    $$invalidate(1, img = getMimeIcon(file.filename));
  });
  const click_handler = () => fbClass.openWith(file);
  const dblclick_handler = () => fbClass.openFile(file);
  $$self.$$set = ($$props2) => {
    if ("file" in $$props2)
      $$invalidate(0, file = $$props2.file);
  };
  return [file, img, $fbState, select, click_handler, dblclick_handler];
}
let File$4 = class File2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$40, create_fragment$4f, safe_not_equal, { file: 0 });
  }
};
function create_fragment$4e(ctx) {
  let button;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<div class="image"></div> <div class="name">Name</div> <div class="mime">Type</div> <div class="modified">Modified</div> <div class="size">Size</div>`;
      attr(button, "class", "item head");
    },
    m(target, anchor) {
      insert(target, button, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
    }
  };
}
class TopRow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$4e, safe_not_equal, {});
  }
}
function get_each_context$P(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function get_each_context_1$e(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list2[i2];
  return child_ctx;
}
function create_else_block_1$5(ctx) {
  let div1;
  let toprow;
  let t0;
  let div0;
  let t1;
  let current;
  toprow = new TopRow({});
  let each_value_1 = ensure_array_like(
    /*dirs*/
    ctx[1]
  );
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1$e(get_each_context_1$e(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  let each_value = ensure_array_like(
    /*files*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$P(get_each_context$P(ctx, each_value, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div1 = element("div");
      create_component(toprow.$$.fragment);
      t0 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div0, "class", "items");
      attr(div1, "class", "listview");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(toprow, div1, null);
      append(div1, t0);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(div0, null);
        }
      }
      append(div0, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*dirs*/
      2) {
        each_value_1 = ensure_array_like(
          /*dirs*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$e(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_1$e(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(div0, t1);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (dirty & /*files*/
      1) {
        each_value = ensure_array_like(
          /*files*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$P(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$P(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(toprow.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(toprow.$$.fragment, local);
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(toprow);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block$1x(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$r, create_else_block$x];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$fbState*/
      ctx2[2].refreshing
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_each_block_1$e(ctx) {
  let dir_1;
  let current;
  dir_1 = new Dir$3({ props: { dir: (
    /*dir*/
    ctx[6]
  ) } });
  return {
    c() {
      create_component(dir_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dir_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dir_1_changes = {};
      if (dirty & /*dirs*/
      2)
        dir_1_changes.dir = /*dir*/
        ctx2[6];
      dir_1.$set(dir_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dir_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dir_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dir_1, detaching);
    }
  };
}
function create_each_block$P(ctx) {
  let file_1;
  let current;
  file_1 = new File$4({ props: { file: (
    /*file*/
    ctx[3]
  ) } });
  return {
    c() {
      create_component(file_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(file_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const file_1_changes = {};
      if (dirty & /*files*/
      1)
        file_1_changes.file = /*file*/
        ctx2[3];
      file_1.$set(file_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(file_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(file_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(file_1, detaching);
    }
  };
}
function create_else_block$x(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "This folder is empty.";
      attr(div, "class", "nofiles");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_1$r(ctx) {
  let div1;
  let div0;
  let spinner2;
  let t0;
  let p2;
  let current;
  spinner2 = new Spinner({ props: { height: 32 } });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(spinner2.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.textContent = "Reading items...";
      attr(p2, "class", "caption");
      attr(div0, "class", "loading-inner");
      attr(div1, "class", "loading");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(spinner2, div0, null);
      append(div0, t0);
      append(div0, p2);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(spinner2);
    }
  };
}
function create_fragment$4d(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1x, create_else_block_1$5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*dirs*/
    ctx2[1].length && !/*files*/
    ctx2[0].length)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$3$($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(2, $fbState = $$value));
  let { files = [] } = $$props;
  let { dirs = [] } = $$props;
  $$self.$$set = ($$props2) => {
    if ("files" in $$props2)
      $$invalidate(0, files = $$props2.files);
    if ("dirs" in $$props2)
      $$invalidate(1, dirs = $$props2.dirs);
  };
  return [files, dirs, $fbState];
}
class ListView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3$, create_fragment$4d, safe_not_equal, { files: 0, dirs: 1 });
  }
}
function create_fragment$4c(ctx) {
  let button;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let p2;
  let t1_value = (
    /*folder*/
    ctx[0].name + ""
  );
  let t1;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      p2 = element("p");
      t1 = text(t1_value);
      if (!src_url_equal(img.src, img_src_value = FolderIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*folder*/
      ctx[0].name);
      attr(p2, "class", "name");
      attr(button, "class", "folder");
      button.disabled = button_disabled_value = /*$fbState*/
      ctx[2].refreshing;
      toggle_class(
        button,
        "selected",
        /*selected*/
        ctx[1] && !/*$fbState*/
        ctx[2].home
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, p2);
      append(p2, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*switchTo*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*folder*/
      1 && img_alt_value !== (img_alt_value = /*folder*/
      ctx2[0].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*folder*/
      1 && t1_value !== (t1_value = /*folder*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*$fbState*/
      4 && button_disabled_value !== (button_disabled_value = /*$fbState*/
      ctx2[2].refreshing)) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*selected, $fbState*/
      6) {
        toggle_class(
          button,
          "selected",
          /*selected*/
          ctx2[1] && !/*$fbState*/
          ctx2[2].home
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3_($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(2, $fbState = $$value));
  let { folder } = $$props;
  let selected = false;
  async function switchTo() {
    fbClass.goToDirectory(folder.scopedPath);
  }
  fbState.subscribe((v2) => {
    const path = v2.currentDir.replace("./", "");
    $$invalidate(1, selected = path.startsWith(folder.name));
  });
  $$self.$$set = ($$props2) => {
    if ("folder" in $$props2)
      $$invalidate(0, folder = $$props2.folder);
  };
  return [folder, selected, $fbState, switchTo];
}
class Folder2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3_, create_fragment$4c, safe_not_equal, { folder: 0 });
  }
}
function get_each_context$O(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function create_else_block$w(ctx) {
  let div;
  let spinner2;
  let current;
  spinner2 = new Spinner({ props: { height: 24 } });
  return {
    c() {
      div = element("div");
      create_component(spinner2.$$.fragment);
      attr(div, "class", "loading");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(spinner2, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(spinner2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(spinner2);
    }
  };
}
function create_if_block$1w(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*folders*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$O(get_each_context$O(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*folders*/
      1) {
        each_value = ensure_array_like(
          /*folders*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$O(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$O(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$O(ctx) {
  let folder_1;
  let current;
  folder_1 = new Folder2({ props: { folder: (
    /*folder*/
    ctx[3]
  ) } });
  return {
    c() {
      create_component(folder_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(folder_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const folder_1_changes = {};
      if (dirty & /*folders*/
      1)
        folder_1_changes.folder = /*folder*/
        ctx2[3];
      folder_1.$set(folder_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(folder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(folder_1, detaching);
    }
  };
}
function create_fragment$4b(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$1w, create_else_block$w];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*loading*/
    ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "dirs");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$3Z($$self, $$props, $$invalidate) {
  let folders = [];
  let loading = false;
  let currentJoin = "";
  fbState.subscribe(async () => {
    if (!currentJoin)
      $$invalidate(1, loading = true);
    const unsorted = (await getDirectory("./")).directories;
    if (!unsorted)
      return $$invalidate(1, loading = false);
    const join = unsorted.map((v2) => v2.name.toLowerCase()).join("|");
    if (currentJoin == join)
      return $$invalidate(1, loading = false);
    currentJoin = join;
    $$invalidate(1, loading = true);
    $$invalidate(0, folders = sortDirectories(unsorted));
    $$invalidate(1, loading = false);
  });
  return [folders, loading];
}
class Folders2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3Z, create_fragment$4b, safe_not_equal, {});
  }
}
function create_fragment$4a(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      button.innerHTML = `<img src="${HomeIcon}" alt=""/> <p class="name">Home</p>`;
      attr(button, "class", "folder");
      toggle_class(
        button,
        "selected",
        /*$fbState*/
        ctx[0].home
      );
      attr(div, "class", "home");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$fbState*/
      1) {
        toggle_class(
          button,
          "selected",
          /*$fbState*/
          ctx2[0].home
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3Y($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(0, $fbState = $$value));
  const click_handler = () => set_store_value(fbState, $fbState.home = true, $fbState);
  return [$fbState, click_handler];
}
class Home2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3Y, create_fragment$4a, safe_not_equal, {});
  }
}
const defaultQuota = {
  used: 0,
  max: 0,
  free: 0,
  username: "ArcOS"
};
async function getFSQuota() {
  const username = get_store_value(UserName);
  const server = get_store_value(ConnectedServer);
  Log(
    `fs/quota.ts: getFSQuota`,
    `Getting FSQuota for ${username}`,
    LogLevel.info
  );
  if (!server || !username)
    return defaultQuota;
  const req = await apiCall(server, "fs/quota", {}, get_store_value(UserToken));
  if (!req.valid)
    return defaultQuota;
  return req.data;
}
function create_fragment$49(ctx) {
  let div4;
  let div1;
  let div0;
  let t0;
  let div3;
  let span;
  let t1_value = formatBytes(
    /*quota*/
    ctx[0].used
  ) + "";
  let t1;
  let span_title_value;
  let t2;
  let div2;
  let t3_value = formatBytes(
    /*quota*/
    ctx[0].max
  ) + "";
  let t3;
  return {
    c() {
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      div3 = element("div");
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      t3 = text(t3_value);
      attr(div0, "class", "inner");
      set_style(
        div0,
        "width",
        /*width*/
        ctx[1] + "%"
      );
      attr(div1, "class", "bar");
      attr(span, "title", span_title_value = /*quota*/
      ctx[0].used + "B");
      toggle_class(
        span,
        "invalid",
        /*quota*/
        ctx[0].used > /*quota*/
        ctx[0].max
      );
      attr(div2, "class", "right");
      attr(div3, "class", "stat");
      attr(div4, "class", "quota-renderer");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div1);
      append(div1, div0);
      append(div4, t0);
      append(div4, div3);
      append(div3, span);
      append(span, t1);
      append(div3, t2);
      append(div3, div2);
      append(div2, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*width*/
      2) {
        set_style(
          div0,
          "width",
          /*width*/
          ctx2[1] + "%"
        );
      }
      if (dirty & /*quota*/
      1 && t1_value !== (t1_value = formatBytes(
        /*quota*/
        ctx2[0].used
      ) + ""))
        set_data(t1, t1_value);
      if (dirty & /*quota*/
      1 && span_title_value !== (span_title_value = /*quota*/
      ctx2[0].used + "B")) {
        attr(span, "title", span_title_value);
      }
      if (dirty & /*quota*/
      1) {
        toggle_class(
          span,
          "invalid",
          /*quota*/
          ctx2[0].used > /*quota*/
          ctx2[0].max
        );
      }
      if (dirty & /*quota*/
      1 && t3_value !== (t3_value = formatBytes(
        /*quota*/
        ctx2[0].max
      ) + ""))
        set_data(t3, t3_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
    }
  };
}
function instance$3X($$self, $$props, $$invalidate) {
  let quota = defaultQuota;
  let width = 0;
  fbState.subscribe(refresh);
  async function refresh() {
    $$invalidate(0, quota = await getFSQuota());
    $$invalidate(1, width = Math.round(100 / quota.max * quota.used));
  }
  return [quota, width];
}
class QuotaRenderer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3X, create_fragment$49, safe_not_equal, {});
  }
}
function create_fragment$48(ctx) {
  let div;
  let home;
  let t0;
  let folders;
  let t1;
  let quotarenderer;
  let current;
  home = new Home2({});
  folders = new Folders2({});
  quotarenderer = new QuotaRenderer({});
  return {
    c() {
      div = element("div");
      create_component(home.$$.fragment);
      t0 = space();
      create_component(folders.$$.fragment);
      t1 = space();
      create_component(quotarenderer.$$.fragment);
      attr(div, "class", "sidebar");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(home, div, null);
      append(div, t0);
      mount_component(folders, div, null);
      append(div, t1);
      mount_component(quotarenderer, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(home.$$.fragment, local);
      transition_in(folders.$$.fragment, local);
      transition_in(quotarenderer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(home.$$.fragment, local);
      transition_out(folders.$$.fragment, local);
      transition_out(quotarenderer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(home);
      destroy_component(folders);
      destroy_component(quotarenderer);
    }
  };
}
let SideBar$2 = class SideBar2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$48, safe_not_equal, {});
  }
};
const tile = "";
function create_fragment$47(ctx) {
  let button;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let p2;
  let t1_value = (
    /*dir*/
    ctx[0].name + ""
  );
  let t1;
  let button_data_path_value;
  let button_data_name_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      p2 = element("p");
      t1 = text(t1_value);
      if (!src_url_equal(img.src, img_src_value = FolderIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*dir*/
      ctx[0].name);
      attr(p2, "class", "name");
      attr(button, "class", "tile dir");
      attr(button, "data-path", button_data_path_value = /*dir*/
      ctx[0].scopedPath);
      attr(button, "data-type", "dir");
      attr(button, "data-name", button_data_name_value = /*dir*/
      ctx[0].name);
      attr(button, "data-contextmenu", "listitem-dir");
      toggle_class(
        button,
        "selected",
        /*$fbState*/
        ctx[1].selectedFilename == /*dir*/
        ctx[0].name
      );
      toggle_class(
        button,
        "cutting",
        /*$fbState*/
        ctx[1].cuttingFilename && /*$fbState*/
        ctx[1].cuttingFilename.name == /*dir*/
        ctx[0].name
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, p2);
      append(p2, t1);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*select*/
            ctx[2]
          ),
          listen(
            button,
            "dblclick",
            /*open*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*dir*/
      1 && img_alt_value !== (img_alt_value = /*dir*/
      ctx2[0].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*dir*/
      1 && t1_value !== (t1_value = /*dir*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*dir*/
      1 && button_data_path_value !== (button_data_path_value = /*dir*/
      ctx2[0].scopedPath)) {
        attr(button, "data-path", button_data_path_value);
      }
      if (dirty & /*dir*/
      1 && button_data_name_value !== (button_data_name_value = /*dir*/
      ctx2[0].name)) {
        attr(button, "data-name", button_data_name_value);
      }
      if (dirty & /*$fbState, dir*/
      3) {
        toggle_class(
          button,
          "selected",
          /*$fbState*/
          ctx2[1].selectedFilename == /*dir*/
          ctx2[0].name
        );
      }
      if (dirty & /*$fbState, dir*/
      3) {
        toggle_class(
          button,
          "cutting",
          /*$fbState*/
          ctx2[1].cuttingFilename && /*$fbState*/
          ctx2[1].cuttingFilename.name == /*dir*/
          ctx2[0].name
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3W($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(1, $fbState = $$value));
  let { dir } = $$props;
  function select() {
    set_store_value(fbState, $fbState.selectedFilename = dir.name, $fbState);
  }
  function open() {
    fbClass.goToDirectory(dir.scopedPath);
  }
  $$self.$$set = ($$props2) => {
    if ("dir" in $$props2)
      $$invalidate(0, dir = $$props2.dir);
  };
  return [dir, $fbState, select, open];
}
let Dir$2 = class Dir2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3W, create_fragment$47, safe_not_equal, { dir: 0 });
  }
};
function create_fragment$46(ctx) {
  let button;
  let img_1;
  let img_1_src_value;
  let img_1_alt_value;
  let t0;
  let p2;
  let t1_value = (
    /*file*/
    ctx[0].filename + ""
  );
  let t1;
  let button_title_value;
  let button_data_path_value;
  let button_data_name_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img_1 = element("img");
      t0 = space();
      p2 = element("p");
      t1 = text(t1_value);
      if (!src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx[1]))
        attr(img_1, "src", img_1_src_value);
      attr(img_1, "alt", img_1_alt_value = /*file*/
      ctx[0].filename);
      attr(p2, "class", "name");
      attr(button, "class", "tile file");
      attr(button, "title", button_title_value = /*file*/
      ctx[0].scopedPath);
      attr(button, "data-path", button_data_path_value = /*file*/
      ctx[0].scopedPath);
      attr(button, "data-type", "file");
      attr(button, "data-name", button_data_name_value = /*file*/
      ctx[0].filename);
      attr(button, "data-contextmenu", "listitem-file");
      toggle_class(
        button,
        "selected",
        /*$fbState*/
        ctx[2].selectedFilename == /*file*/
        ctx[0].filename
      );
      toggle_class(
        button,
        "cutting",
        /*$fbState*/
        ctx[2].cuttingFilename && /*$fbState*/
        ctx[2].cuttingFilename.name == /*file*/
        ctx[0].filename
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img_1);
      append(button, t0);
      append(button, p2);
      append(p2, t1);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*select*/
            ctx[3]
          ),
          listen(
            button,
            "dblclick",
            /*dblclick_handler*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*img*/
      2 && !src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx2[1])) {
        attr(img_1, "src", img_1_src_value);
      }
      if (dirty & /*file*/
      1 && img_1_alt_value !== (img_1_alt_value = /*file*/
      ctx2[0].filename)) {
        attr(img_1, "alt", img_1_alt_value);
      }
      if (dirty & /*file*/
      1 && t1_value !== (t1_value = /*file*/
      ctx2[0].filename + ""))
        set_data(t1, t1_value);
      if (dirty & /*file*/
      1 && button_title_value !== (button_title_value = /*file*/
      ctx2[0].scopedPath)) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*file*/
      1 && button_data_path_value !== (button_data_path_value = /*file*/
      ctx2[0].scopedPath)) {
        attr(button, "data-path", button_data_path_value);
      }
      if (dirty & /*file*/
      1 && button_data_name_value !== (button_data_name_value = /*file*/
      ctx2[0].filename)) {
        attr(button, "data-name", button_data_name_value);
      }
      if (dirty & /*$fbState, file*/
      5) {
        toggle_class(
          button,
          "selected",
          /*$fbState*/
          ctx2[2].selectedFilename == /*file*/
          ctx2[0].filename
        );
      }
      if (dirty & /*$fbState, file*/
      5) {
        toggle_class(
          button,
          "cutting",
          /*$fbState*/
          ctx2[2].cuttingFilename && /*$fbState*/
          ctx2[2].cuttingFilename.name == /*file*/
          ctx2[0].filename
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3V($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(2, $fbState = $$value));
  let { file } = $$props;
  let img = FileIcon;
  function select() {
    set_store_value(fbState, $fbState.selectedFilename = file.filename, $fbState);
  }
  onMount(() => {
    $$invalidate(1, img = getMimeIcon(file.filename));
  });
  fbState.subscribe(() => {
    $$invalidate(1, img = getMimeIcon(file.filename));
  });
  const dblclick_handler = () => fbClass.openFile(file);
  $$self.$$set = ($$props2) => {
    if ("file" in $$props2)
      $$invalidate(0, file = $$props2.file);
  };
  return [file, img, $fbState, select, dblclick_handler];
}
let File$3 = class File3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3V, create_fragment$46, safe_not_equal, { file: 0 });
  }
};
function get_each_context$N(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function get_each_context_1$d(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list2[i2];
  return child_ctx;
}
function create_else_block_1$4(ctx) {
  let div;
  let t2;
  let current;
  let if_block0 = (
    /*dirs*/
    ctx[1].length && create_if_block_3$4(ctx)
  );
  let if_block1 = (
    /*files*/
    ctx[0].length && create_if_block_2$9(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      attr(div, "class", "tileview");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*dirs*/
        ctx2[1].length
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*dirs*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$4(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*files*/
        ctx2[0].length
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*files*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block$1v(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$q, create_else_block$v];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$fbState*/
      ctx2[2].refreshing
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_3$4(ctx) {
  let div;
  let current;
  let each_value_1 = ensure_array_like(
    /*dirs*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$d(get_each_context_1$d(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "folders");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*dirs*/
      2) {
        each_value_1 = ensure_array_like(
          /*dirs*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$d(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$d(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1$d(ctx) {
  let dir_1;
  let current;
  dir_1 = new Dir$2({ props: { dir: (
    /*dir*/
    ctx[6]
  ) } });
  return {
    c() {
      create_component(dir_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dir_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dir_1_changes = {};
      if (dirty & /*dirs*/
      2)
        dir_1_changes.dir = /*dir*/
        ctx2[6];
      dir_1.$set(dir_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dir_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dir_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dir_1, detaching);
    }
  };
}
function create_if_block_2$9(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*files*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$N(get_each_context$N(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "files");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*files*/
      1) {
        each_value = ensure_array_like(
          /*files*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$N(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$N(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$N(ctx) {
  let file_1;
  let current;
  file_1 = new File$3({ props: { file: (
    /*file*/
    ctx[3]
  ) } });
  return {
    c() {
      create_component(file_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(file_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const file_1_changes = {};
      if (dirty & /*files*/
      1)
        file_1_changes.file = /*file*/
        ctx2[3];
      file_1.$set(file_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(file_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(file_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(file_1, detaching);
    }
  };
}
function create_else_block$v(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "This folder is empty.";
      attr(div, "class", "nofiles");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_1$q(ctx) {
  let div1;
  let div0;
  let spinner2;
  let t0;
  let p2;
  let current;
  spinner2 = new Spinner({ props: { height: 32 } });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(spinner2.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.textContent = "Reading items...";
      attr(p2, "class", "caption");
      attr(div0, "class", "loading-inner");
      attr(div1, "class", "loading");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(spinner2, div0, null);
      append(div0, t0);
      append(div0, p2);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(spinner2);
    }
  };
}
function create_fragment$45(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1v, create_else_block_1$4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*dirs*/
    ctx2[1].length && !/*files*/
    ctx2[0].length)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$3U($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(2, $fbState = $$value));
  let { files = [] } = $$props;
  let { dirs = [] } = $$props;
  $$self.$$set = ($$props2) => {
    if ("files" in $$props2)
      $$invalidate(0, files = $$props2.files);
    if ("dirs" in $$props2)
      $$invalidate(1, dirs = $$props2.dirs);
  };
  return [files, dirs, $fbState];
}
class TileView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3U, create_fragment$45, safe_not_equal, { files: 0, dirs: 1 });
  }
}
function create_if_block$1u(ctx) {
  let button;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(
        /*crumb*/
        ctx[0]
      );
      attr(button, "class", "crumb");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*openThis*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*crumb*/
      1)
        set_data(
          t2,
          /*crumb*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$44(ctx) {
  let if_block_anchor;
  let if_block = (
    /*crumb*/
    ctx[0] && /*crumb*/
    ctx[0] != "." && create_if_block$1u(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*crumb*/
        ctx2[0] && /*crumb*/
        ctx2[0] != "."
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1u(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$3T($$self, $$props, $$invalidate) {
  let { crumb } = $$props;
  let { path } = $$props;
  function openThis() {
    fbClass.goToDirectory(path);
  }
  $$self.$$set = ($$props2) => {
    if ("crumb" in $$props2)
      $$invalidate(0, crumb = $$props2.crumb);
    if ("path" in $$props2)
      $$invalidate(2, path = $$props2.path);
  };
  return [crumb, openThis, path];
}
let Crumb$1 = class Crumb extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3T, create_fragment$44, safe_not_equal, { crumb: 0, path: 2 });
  }
};
function get_each_context$M(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2];
  child_ctx[7] = i2;
  return child_ctx;
}
function create_else_block$u(ctx) {
  let button;
  return {
    c() {
      button = element("button");
      button.textContent = "Home";
      attr(button, "class", "crumb");
    },
    m(target, anchor) {
      insert(target, button, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
    }
  };
}
function create_if_block$1t(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*crumbs*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$M(get_each_context$M(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*crumbs, generatePath*/
      9) {
        each_value = ensure_array_like(
          /*crumbs*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$M(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$M(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$M(ctx) {
  let crumb_1;
  let current;
  crumb_1 = new Crumb$1({
    props: {
      crumb: (
        /*crumb*/
        ctx[5]
      ),
      path: (
        /*generatePath*/
        ctx[3](
          /*crumb*/
          ctx[5],
          /*i*/
          ctx[7]
        )
      )
    }
  });
  return {
    c() {
      create_component(crumb_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(crumb_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const crumb_1_changes = {};
      if (dirty & /*crumbs*/
      1)
        crumb_1_changes.crumb = /*crumb*/
        ctx2[5];
      if (dirty & /*crumbs*/
      1)
        crumb_1_changes.path = /*generatePath*/
        ctx2[3](
          /*crumb*/
          ctx2[5],
          /*i*/
          ctx2[7]
        );
      crumb_1.$set(crumb_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(crumb_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(crumb_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(crumb_1, detaching);
    }
  };
}
function create_fragment$43(ctx) {
  let button0;
  let t0;
  let button0_disabled_value;
  let t1;
  let div;
  let current_block_type_index;
  let if_block;
  let t2;
  let button1;
  let t3;
  let button1_disabled_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$1t, create_else_block$u];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*$fbState*/
    ctx2[1].home)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      button0 = element("button");
      t0 = text("first_page");
      t1 = space();
      div = element("div");
      if_block.c();
      t2 = space();
      button1 = element("button");
      t3 = text("refresh");
      attr(button0, "class", "home material-icons-round");
      button0.disabled = button0_disabled_value = /*$fbState*/
      ctx[1].refreshing || /*$fbState*/
      ctx[1].currentDir == "./" && !/*$fbState*/
      ctx[1].home;
      attr(div, "class", "addressbar");
      attr(button1, "class", "refresh material-icons-round");
      button1.disabled = button1_disabled_value = /*$fbState*/
      ctx[1].home || /*$fbState*/
      ctx[1].refreshing;
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      append(button0, t0);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      insert(target, t2, anchor);
      insert(target, button1, anchor);
      append(button1, t3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*home*/
            ctx[2]
          ),
          listen(
            button1,
            "click",
            /*click_handler*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$fbState*/
      2 && button0_disabled_value !== (button0_disabled_value = /*$fbState*/
      ctx2[1].refreshing || /*$fbState*/
      ctx2[1].currentDir == "./" && !/*$fbState*/
      ctx2[1].home)) {
        button0.disabled = button0_disabled_value;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*$fbState*/
      2 && button1_disabled_value !== (button1_disabled_value = /*$fbState*/
      ctx2[1].home || /*$fbState*/
      ctx2[1].refreshing)) {
        button1.disabled = button1_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t1);
        detach(div);
        detach(t2);
        detach(button1);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3S($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(1, $fbState = $$value));
  let crumbs = [];
  fbState.subscribe((v2) => {
    $$invalidate(0, crumbs = v2.currentDir.split("/"));
  });
  function home() {
    fbClass.goToDirectory("./");
  }
  function generatePath(crumb, I2) {
    let str = "";
    for (let i2 = 0; i2 < I2; i2++) {
      str += `${crumbs[i2]}/`;
    }
    return `${str}${crumb}`;
  }
  const click_handler = () => fbClass.refresh();
  return [crumbs, $fbState, home, generatePath, click_handler];
}
class PathCrumbs extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3S, create_fragment$43, safe_not_equal, {});
  }
}
function create_fragment$42(ctx) {
  let button;
  let t2;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text("content_copy");
      attr(button, "class", "material-icons-round copy");
      button.disabled = button_disabled_value = !/*$fbState*/
      ctx[0].selectedFilename || /*$fbState*/
      ctx[0].home;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*copy*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$fbState*/
      1 && button_disabled_value !== (button_disabled_value = !/*$fbState*/
      ctx2[0].selectedFilename || /*$fbState*/
      ctx2[0].home)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3R($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(0, $fbState = $$value));
  function copy() {
    set_store_value(
      fbState,
      $fbState.copyingFilename = {
        name: $fbState.selectedFilename,
        scopedPath: `${$fbState.currentDir}/${$fbState.selectedFilename}`
      },
      $fbState
    );
  }
  return [$fbState, copy];
}
class CopyButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3R, create_fragment$42, safe_not_equal, {});
  }
}
function create_fragment$41(ctx) {
  let button;
  let t2;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text("add");
      attr(button, "class", "material-icons-round create");
      button.disabled = button_disabled_value = /*$fbState*/
      ctx[0].home;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*show*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$fbState*/
      1 && button_disabled_value !== (button_disabled_value = /*$fbState*/
      ctx2[0].home)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3Q($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(0, $fbState = $$value));
  function show() {
    showOverlay("createFile", "FileManager");
  }
  return [$fbState, show];
}
class CreateButton2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3Q, create_fragment$41, safe_not_equal, {});
  }
}
function create_fragment$40(ctx) {
  let button;
  let t2;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text("content_cut");
      attr(button, "class", "material-icons-round cut");
      button.disabled = button_disabled_value = !/*$fbState*/
      ctx[0].selectedFilename || /*$fbState*/
      ctx[0].home;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*cut*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$fbState*/
      1 && button_disabled_value !== (button_disabled_value = !/*$fbState*/
      ctx2[0].selectedFilename || /*$fbState*/
      ctx2[0].home)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3P($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(0, $fbState = $$value));
  function cut() {
    set_store_value(
      fbState,
      $fbState.cuttingFilename = {
        name: $fbState.selectedFilename,
        scopedPath: `${$fbState.currentDir}/${$fbState.selectedFilename}`
      },
      $fbState
    );
  }
  return [$fbState, cut];
}
class CutButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3P, create_fragment$40, safe_not_equal, {});
  }
}
function create_fragment$3$(ctx) {
  let button;
  let t2;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text("delete");
      attr(button, "class", "material-icons-round");
      button.disabled = button_disabled_value = !/*$fbState*/
      ctx[0].selectedFilename || /*$fbState*/
      ctx[0].home;
      attr(button, "title", "Delete item");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*deleteSelected*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$fbState*/
      1 && button_disabled_value !== (button_disabled_value = !/*$fbState*/
      ctx2[0].selectedFilename || /*$fbState*/
      ctx2[0].home)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3O($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(0, $fbState = $$value));
  function deleteSelected() {
    createOverlayableError(
      {
        title: "Delete item?",
        message: `Are you sure you want to permanently delete ${$fbState.selectedFilename}?`,
        buttons: [
          {
            caption: "Delete",
            action: confirmDelete,
            suggested: true
          },
          {
            caption: "Cancel",
            action() {
            }
          }
        ],
        image: TrashIcon
      },
      "FileManager"
    );
  }
  async function confirmDelete() {
    const path = `${$fbState.currentDir}/${$fbState.selectedFilename}`;
    set_store_value(fbState, $fbState.deletingFilename = $fbState.selectedFilename, $fbState);
    showOverlay("deletingItem", "FileManager");
    const valid = await deleteItem(path);
    if (!valid)
      createOverlayableError(
        {
          title: "Unable to delete item",
          message: "ArcAPI was not able to delete the item from the file system. A permission error may have occured. Please try again later.",
          buttons: [
            {
              caption: "OK",
              action() {
              },
              suggested: true
            }
          ],
          image: ErrorIcon
        },
        "FileManager"
      );
    set_store_value(fbState, $fbState.selectedFilename = null, $fbState);
    fbClass.refresh();
    setTimeout(
      () => {
        hideOverlay("deletingItem", "FileManager");
      },
      100
    );
  }
  return [$fbState, deleteSelected];
}
class DeleteButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3O, create_fragment$3$, safe_not_equal, {});
  }
}
function create_fragment$3_(ctx) {
  let button;
  let t2;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text("create_new_folder");
      attr(button, "class", "material-icons-round");
      attr(button, "title", "New folder");
      button.disabled = button_disabled_value = /*$fbState*/
      ctx[0].home;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*trigger*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$fbState*/
      1 && button_disabled_value !== (button_disabled_value = /*$fbState*/
      ctx2[0].home)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3N($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(0, $fbState = $$value));
  function trigger() {
    showOverlay("createFolder", "FileManager");
  }
  return [$fbState, trigger];
}
class NewFolderButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3N, create_fragment$3_, safe_not_equal, {});
  }
}
function create_fragment$3Z(ctx) {
  let button;
  let t2;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text("arrow_upward");
      attr(button, "class", "material-icons-round parentdir");
      button.disabled = button_disabled_value = /*$fbState*/
      ctx[0].currentDir == "./" || /*$fbState*/
      ctx[0].home;
      attr(button, "title", "Parent folder");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*parentdir*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$fbState*/
      1 && button_disabled_value !== (button_disabled_value = /*$fbState*/
      ctx2[0].currentDir == "./" || /*$fbState*/
      ctx2[0].home)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3M($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(0, $fbState = $$value));
  function parentdir() {
    fbClass.goToDirectory(getParentDirectory($fbState.currentDir));
  }
  return [$fbState, parentdir];
}
class ParentDir extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3M, create_fragment$3Z, safe_not_equal, {});
  }
}
async function copyItem(sourcePath, targetPath) {
  Log(
    `fs/mutate.ts: copyItem`,
    `Copying ${sourcePath} to ${targetPath}`,
    LogLevel.info
  );
  const server = get_store_value(ConnectedServer);
  if (!server)
    return false;
  await apiCall(
    server,
    "fs/cp",
    { path: toBase64(sourcePath), target: toBase64(targetPath) },
    get_store_value(UserToken)
  );
  return true;
}
async function renameItem(oldPath, newPath) {
  Log(
    `fs/rename.ts: renameItem`,
    `Renaming ${oldPath} to ${newPath}`,
    LogLevel.info
  );
  const server = get_store_value(ConnectedServer);
  if (!server)
    return false;
  const req = await apiCall(
    server,
    "fs/rename",
    { oldpath: toBase64(oldPath), newpath: toBase64(newPath) },
    get_store_value(UserToken)
  );
  return req.valid;
}
function create_fragment$3Y(ctx) {
  let button;
  let t2;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text("content_paste");
      attr(button, "class", "material-icons-round paste");
      button.disabled = button_disabled_value = !/*$fbState*/
      ctx[0].copyingFilename && !/*$fbState*/
      ctx[0].cuttingFilename || /*$fbState*/
      ctx[0].home;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*paste*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$fbState*/
      1 && button_disabled_value !== (button_disabled_value = !/*$fbState*/
      ctx2[0].copyingFilename && !/*$fbState*/
      ctx2[0].cuttingFilename || /*$fbState*/
      ctx2[0].home)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3L($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(0, $fbState = $$value));
  async function paste() {
    if ($fbState.copyingFilename) {
      const name = $fbState.copyingFilename.name;
      const path = $fbState.copyingFilename.scopedPath;
      await copyItem(path, `${$fbState.currentDir}/${name}`);
      set_store_value(fbState, $fbState.copyingFilename = null, $fbState);
    }
    if ($fbState.cuttingFilename) {
      const name = $fbState.cuttingFilename.name;
      const path = $fbState.cuttingFilename.scopedPath;
      await renameItem(path, `${$fbState.currentDir}/${name}`);
      set_store_value(fbState, $fbState.cuttingFilename = null, $fbState);
    }
    fbClass.refresh();
  }
  return [$fbState, paste];
}
class PasteButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3L, create_fragment$3Y, safe_not_equal, {});
  }
}
function create_fragment$3X(ctx) {
  let button;
  let t2;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text("drive_file_rename_outline");
      attr(button, "class", "material-icons-round");
      button.disabled = button_disabled_value = !/*$fbState*/
      ctx[0].selectedFilename || /*$fbState*/
      ctx[0].home;
      attr(button, "title", "Rename item");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$fbState*/
      1 && button_disabled_value !== (button_disabled_value = !/*$fbState*/
      ctx2[0].selectedFilename || /*$fbState*/
      ctx2[0].home)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3K($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(0, $fbState = $$value));
  function click2() {
    showOverlay("renameItem", "FileManager");
  }
  return [$fbState, click2];
}
class RenameButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3K, create_fragment$3X, safe_not_equal, {});
  }
}
const UploadFileButton_svelte_svelte_type_style_lang = "";
function create_fragment$3W(ctx) {
  let input;
  let t0;
  let button;
  let t1;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      t0 = space();
      button = element("button");
      t1 = text("upload");
      attr(input, "type", "file");
      attr(input, "name", "file");
      input.multiple = true;
      attr(input, "class", "svelte-nn3gqf");
      attr(button, "class", "material-icons-round");
      attr(button, "title", "Upload file");
      button.disabled = button_disabled_value = /*$fbState*/
      ctx[1].home;
    },
    m(target, anchor) {
      insert(target, input, anchor);
      ctx[3](input);
      insert(target, t0, anchor);
      insert(target, button, anchor);
      append(button, t1);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*doUpload*/
            ctx[2]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$fbState*/
      2 && button_disabled_value !== (button_disabled_value = /*$fbState*/
      ctx2[1].home)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(input);
        detach(t0);
        detach(button);
      }
      ctx[3](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3J($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(1, $fbState = $$value));
  let uploader;
  async function doUpload() {
    const files = uploader.files;
    if (files.length > 80) {
      return createOverlayableError(
        {
          title: "Too many files",
          message: "You are only allowed to upload 80 files at a time to prevent overloading.",
          buttons: [
            {
              caption: "Understood",
              action() {
              },
              suggested: true
            }
          ],
          image: UploadIcon
        },
        "FileManager"
      );
    }
    showOverlay("uploadingFile", "FileManager");
    let maxTimeout = 50;
    for (let i2 = 0; i2 < files.length; i2++) {
      maxTimeout += 25;
      if (!files[i2])
        continue;
      await fileUpload2(files[i2]);
    }
    setTimeout(
      () => {
        hideOverlay("uploadingFile", "FileManager");
        fbClass.refresh();
      },
      maxTimeout + 500
    );
  }
  async function fileUpload2(file) {
    const content2 = arrayToBlob(await file.arrayBuffer());
    const path = `${$fbState.currentDir}/${file.name}`.split("//").join("/");
    const data = await fileToArcFile(file, path);
    set_store_value(fbState, $fbState.uploadFile = data, $fbState);
    const valid = await writeFile(path, content2);
    if (!valid)
      makeNotification({
        title: "File upload failed",
        message: "The server could not parse the file or it could not be written to the ArcFS",
        buttons: [],
        image: UploadIcon
      });
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      uploader = $$value;
      $$invalidate(0, uploader);
    });
  }
  const click_handler = () => uploader.click();
  return [uploader, $fbState, doUpload, input_binding, click_handler];
}
class UploadFileButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3J, create_fragment$3W, safe_not_equal, {});
  }
}
function create_fragment$3V(ctx) {
  let div;
  let button0;
  let t0;
  let button0_disabled_value;
  let t1;
  let button1;
  let t2;
  let button1_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text("format_list_bulleted");
      t1 = space();
      button1 = element("button");
      t2 = text("grid_view");
      attr(button0, "class", "material-icons-round");
      attr(button0, "title", "List view");
      button0.disabled = button0_disabled_value = /*$fbState*/
      ctx[1].home;
      toggle_class(button0, "selected", !/*appdata*/
      ctx[0].tiled);
      attr(button1, "class", "material-icons-round");
      attr(button1, "title", "Tile view");
      button1.disabled = button1_disabled_value = /*$fbState*/
      ctx[1].home;
      toggle_class(
        button1,
        "selected",
        /*appdata*/
        ctx[0].tiled
      );
      attr(div, "class", "group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*changeView*/
            ctx[2](false)
          ),
          listen(
            button1,
            "click",
            /*changeView*/
            ctx[2](true)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$fbState*/
      2 && button0_disabled_value !== (button0_disabled_value = /*$fbState*/
      ctx2[1].home)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*appdata*/
      1) {
        toggle_class(button0, "selected", !/*appdata*/
        ctx2[0].tiled);
      }
      if (dirty & /*$fbState*/
      2 && button1_disabled_value !== (button1_disabled_value = /*$fbState*/
      ctx2[1].home)) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*appdata*/
      1) {
        toggle_class(
          button1,
          "selected",
          /*appdata*/
          ctx2[0].tiled
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3I($$self, $$props, $$invalidate) {
  let $UserData;
  let $fbState;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(4, $UserData = $$value));
  component_subscribe($$self, fbState, ($$value) => $$invalidate(1, $fbState = $$value));
  let { appdata } = $$props;
  let { app } = $$props;
  function changeView(newState) {
    return () => {
      $$invalidate(0, appdata.tiled = newState, appdata);
      set_store_value(UserData$2, $UserData.appdata[app.id] = appdata, $UserData);
    };
  }
  $$self.$$set = ($$props2) => {
    if ("appdata" in $$props2)
      $$invalidate(0, appdata = $$props2.appdata);
    if ("app" in $$props2)
      $$invalidate(3, app = $$props2.app);
  };
  return [appdata, $fbState, changeView, app];
}
class Views extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3I, create_fragment$3V, safe_not_equal, { appdata: 0, app: 3 });
  }
}
function create_fragment$3U(ctx) {
  let div4;
  let parentdir;
  let t0;
  let adressbar;
  let t1;
  let div3;
  let div1;
  let cutbutton;
  let t2;
  let copybutton;
  let t3;
  let pastebutton;
  let t4;
  let div0;
  let t5;
  let deletebutton;
  let t6;
  let renamebutton;
  let t7;
  let div2;
  let newfolderbutton;
  let t8;
  let createbutton;
  let t9;
  let uploadfilebutton;
  let t10;
  let views;
  let updating_appdata;
  let updating_app;
  let current;
  parentdir = new ParentDir({});
  adressbar = new PathCrumbs({});
  cutbutton = new CutButton({});
  copybutton = new CopyButton({});
  pastebutton = new PasteButton({});
  deletebutton = new DeleteButton({});
  renamebutton = new RenameButton({});
  newfolderbutton = new NewFolderButton({});
  createbutton = new CreateButton2({});
  uploadfilebutton = new UploadFileButton({});
  function views_appdata_binding(value) {
    ctx[2](value);
  }
  function views_app_binding(value) {
    ctx[3](value);
  }
  let views_props = {};
  if (
    /*appdata*/
    ctx[0] !== void 0
  ) {
    views_props.appdata = /*appdata*/
    ctx[0];
  }
  if (
    /*app*/
    ctx[1] !== void 0
  ) {
    views_props.app = /*app*/
    ctx[1];
  }
  views = new Views({ props: views_props });
  binding_callbacks.push(() => bind$1(views, "appdata", views_appdata_binding));
  binding_callbacks.push(() => bind$1(views, "app", views_app_binding));
  return {
    c() {
      div4 = element("div");
      create_component(parentdir.$$.fragment);
      t0 = space();
      create_component(adressbar.$$.fragment);
      t1 = space();
      div3 = element("div");
      div1 = element("div");
      create_component(cutbutton.$$.fragment);
      t2 = space();
      create_component(copybutton.$$.fragment);
      t3 = space();
      create_component(pastebutton.$$.fragment);
      t4 = space();
      div0 = element("div");
      t5 = space();
      create_component(deletebutton.$$.fragment);
      t6 = space();
      create_component(renamebutton.$$.fragment);
      t7 = space();
      div2 = element("div");
      create_component(newfolderbutton.$$.fragment);
      t8 = space();
      create_component(createbutton.$$.fragment);
      t9 = space();
      create_component(uploadfilebutton.$$.fragment);
      t10 = space();
      create_component(views.$$.fragment);
      attr(div0, "class", "sep");
      attr(div1, "class", "group");
      attr(div2, "class", "group");
      attr(div3, "class", "right");
      attr(div4, "class", "topbar");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      mount_component(parentdir, div4, null);
      append(div4, t0);
      mount_component(adressbar, div4, null);
      append(div4, t1);
      append(div4, div3);
      append(div3, div1);
      mount_component(cutbutton, div1, null);
      append(div1, t2);
      mount_component(copybutton, div1, null);
      append(div1, t3);
      mount_component(pastebutton, div1, null);
      append(div1, t4);
      append(div1, div0);
      append(div1, t5);
      mount_component(deletebutton, div1, null);
      append(div1, t6);
      mount_component(renamebutton, div1, null);
      append(div3, t7);
      append(div3, div2);
      mount_component(newfolderbutton, div2, null);
      append(div2, t8);
      mount_component(createbutton, div2, null);
      append(div2, t9);
      mount_component(uploadfilebutton, div2, null);
      append(div3, t10);
      mount_component(views, div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const views_changes = {};
      if (!updating_appdata && dirty & /*appdata*/
      1) {
        updating_appdata = true;
        views_changes.appdata = /*appdata*/
        ctx2[0];
        add_flush_callback(() => updating_appdata = false);
      }
      if (!updating_app && dirty & /*app*/
      2) {
        updating_app = true;
        views_changes.app = /*app*/
        ctx2[1];
        add_flush_callback(() => updating_app = false);
      }
      views.$set(views_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(parentdir.$$.fragment, local);
      transition_in(adressbar.$$.fragment, local);
      transition_in(cutbutton.$$.fragment, local);
      transition_in(copybutton.$$.fragment, local);
      transition_in(pastebutton.$$.fragment, local);
      transition_in(deletebutton.$$.fragment, local);
      transition_in(renamebutton.$$.fragment, local);
      transition_in(newfolderbutton.$$.fragment, local);
      transition_in(createbutton.$$.fragment, local);
      transition_in(uploadfilebutton.$$.fragment, local);
      transition_in(views.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(parentdir.$$.fragment, local);
      transition_out(adressbar.$$.fragment, local);
      transition_out(cutbutton.$$.fragment, local);
      transition_out(copybutton.$$.fragment, local);
      transition_out(pastebutton.$$.fragment, local);
      transition_out(deletebutton.$$.fragment, local);
      transition_out(renamebutton.$$.fragment, local);
      transition_out(newfolderbutton.$$.fragment, local);
      transition_out(createbutton.$$.fragment, local);
      transition_out(uploadfilebutton.$$.fragment, local);
      transition_out(views.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      destroy_component(parentdir);
      destroy_component(adressbar);
      destroy_component(cutbutton);
      destroy_component(copybutton);
      destroy_component(pastebutton);
      destroy_component(deletebutton);
      destroy_component(renamebutton);
      destroy_component(newfolderbutton);
      destroy_component(createbutton);
      destroy_component(uploadfilebutton);
      destroy_component(views);
    }
  };
}
function instance$3H($$self, $$props, $$invalidate) {
  let { appdata } = $$props;
  let { app } = $$props;
  function views_appdata_binding(value) {
    appdata = value;
    $$invalidate(0, appdata);
  }
  function views_app_binding(value) {
    app = value;
    $$invalidate(1, app);
  }
  $$self.$$set = ($$props2) => {
    if ("appdata" in $$props2)
      $$invalidate(0, appdata = $$props2.appdata);
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
  };
  return [appdata, app, views_appdata_binding, views_app_binding];
}
let TopBar$2 = class TopBar2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3H, create_fragment$3U, safe_not_equal, { appdata: 0, app: 1 });
  }
};
function create_else_block$t(ctx) {
  let listview;
  let current;
  listview = new ListView({
    props: {
      files: (
        /*files*/
        ctx[2]
      ),
      dirs: (
        /*dirs*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(listview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(listview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const listview_changes = {};
      if (dirty & /*files*/
      4)
        listview_changes.files = /*files*/
        ctx2[2];
      if (dirty & /*dirs*/
      8)
        listview_changes.dirs = /*dirs*/
        ctx2[3];
      listview.$set(listview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(listview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(listview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(listview, detaching);
    }
  };
}
function create_if_block_1$p(ctx) {
  let tileview;
  let current;
  tileview = new TileView({
    props: {
      files: (
        /*files*/
        ctx[2]
      ),
      dirs: (
        /*dirs*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(tileview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tileview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tileview_changes = {};
      if (dirty & /*files*/
      4)
        tileview_changes.files = /*files*/
        ctx2[2];
      if (dirty & /*dirs*/
      8)
        tileview_changes.dirs = /*dirs*/
        ctx2[3];
      tileview.$set(tileview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tileview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tileview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tileview, detaching);
    }
  };
}
function create_if_block$1s(ctx) {
  let home;
  let current;
  home = new Home$1({});
  return {
    c() {
      create_component(home.$$.fragment);
    },
    m(target, anchor) {
      mount_component(home, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(home.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(home.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(home, detaching);
    }
  };
}
function create_fragment$3T(ctx) {
  let topbar;
  let updating_appdata;
  let t0;
  let sidebar;
  let t1;
  let div;
  let current_block_type_index;
  let if_block;
  let t2;
  let bottom;
  let current;
  function topbar_appdata_binding(value) {
    ctx[6](value);
  }
  let topbar_props = { app: (
    /*app*/
    ctx[1]
  ) };
  if (
    /*appdata*/
    ctx[0] !== void 0
  ) {
    topbar_props.appdata = /*appdata*/
    ctx[0];
  }
  topbar = new TopBar$2({ props: topbar_props });
  binding_callbacks.push(() => bind$1(topbar, "appdata", topbar_appdata_binding));
  sidebar = new SideBar$2({});
  const if_block_creators = [create_if_block$1s, create_if_block_1$p, create_else_block$t];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$fbState*/
      ctx2[5].home
    )
      return 0;
    if (
      /*tiledMode*/
      ctx2[4]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  bottom = new Bottom$2({});
  return {
    c() {
      create_component(topbar.$$.fragment);
      t0 = space();
      create_component(sidebar.$$.fragment);
      t1 = space();
      div = element("div");
      if_block.c();
      t2 = space();
      create_component(bottom.$$.fragment);
      attr(div, "class", "content");
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      insert(target, t0, anchor);
      mount_component(sidebar, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      insert(target, t2, anchor);
      mount_component(bottom, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const topbar_changes = {};
      if (dirty & /*app*/
      2)
        topbar_changes.app = /*app*/
        ctx2[1];
      if (!updating_appdata && dirty & /*appdata*/
      1) {
        updating_appdata = true;
        topbar_changes.appdata = /*appdata*/
        ctx2[0];
        add_flush_callback(() => updating_appdata = false);
      }
      topbar.$set(topbar_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      transition_in(sidebar.$$.fragment, local);
      transition_in(if_block);
      transition_in(bottom.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      transition_out(sidebar.$$.fragment, local);
      transition_out(if_block);
      transition_out(bottom.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(div);
        detach(t2);
      }
      destroy_component(topbar, detaching);
      destroy_component(sidebar, detaching);
      if_blocks[current_block_type_index].d();
      destroy_component(bottom, detaching);
    }
  };
}
function instance$3G($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(5, $fbState = $$value));
  let files = [];
  let dirs = [];
  let tiledMode = false;
  let { app } = $$props;
  let { appdata } = $$props;
  UserData$2.subscribe(() => {
    $$invalidate(4, tiledMode = appdata.tiled);
  });
  onMount(async () => {
    await fbClass.refresh();
    const currentDir = $fbState.dirContents || defaultDirectory;
    $$invalidate(2, files = currentDir.files);
    $$invalidate(3, dirs = currentDir.directories);
  });
  fbState.subscribe((v2) => {
    $$invalidate(3, dirs = sortDirectories(v2.dirContents.directories));
    $$invalidate(2, files = sortFiles(v2.dirContents.files));
  });
  function topbar_appdata_binding(value) {
    appdata = value;
    $$invalidate(0, appdata);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
    if ("appdata" in $$props2)
      $$invalidate(0, appdata = $$props2.appdata);
  };
  return [appdata, app, files, dirs, tiledMode, $fbState, topbar_appdata_binding];
}
class FileBrowser extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3G, create_fragment$3T, safe_not_equal, { app: 1, appdata: 0 });
  }
}
function pinDirectory(path) {
  checkDirectoryPins();
  const udata = get_store_value(UserData$2);
  if (udata.sh.desktop.pinnedFolders.includes(path))
    return false;
  udata.sh.desktop.pinnedFolders.push(path);
  UserData$2.set(udata);
  return true;
}
function unpinDirectory(path) {
  checkDirectoryPins();
  const udata = get_store_value(UserData$2);
  const pins = udata.sh.desktop.pinnedFolders;
  if (!pins.includes(path))
    return false;
  pins.splice(pins.indexOf(path), 1);
  udata.sh.desktop.pinnedFolders = pins;
  UserData$2.set(udata);
  return true;
}
function isDirPinned(path) {
  const udata = get_store_value(UserData$2);
  const pins = udata.sh.desktop.pinnedFolders;
  return pins && pins.includes(path);
}
function checkDirectoryPins() {
  const udata = get_store_value(UserData$2);
  if (udata.sh.desktop.pinnedFolders && Array.isArray(udata.sh.desktop.pinnedFolders))
    return true;
  udata.sh.desktop.pinnedFolders = [];
  UserData$2.set(udata);
  return false;
}
const SEP_ITEM = { sep: true };
const validContexMenuTags = [
  "button",
  "div",
  "span",
  "p",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "img"
];
function composePosition(e2, mW, mH) {
  const desktop2 = document.querySelectorAll(
    "div.app > div.desktop"
  )[0];
  if (!desktop2)
    return;
  const dW = desktop2.offsetWidth;
  const dH = desktop2.offsetHeight;
  let x2 = e2.clientX;
  let y2 = e2.clientY;
  if (x2 + mW > dW)
    x2 = dW - mW - 10;
  if (y2 + mH > dH)
    y2 = dH - mH - 10;
  if (x2 < 0)
    x2 = 10;
  if (y2 < 0)
    y2 = 10;
  return [x2, y2];
}
function getContexMenuScope(e2) {
  const p2 = e2.composedPath();
  for (let i2 = 0; i2 < p2.length; i2++) {
    const tag = p2[i2].tagName;
    if (!tag)
      continue;
    const contextmenu2 = p2[i2].dataset.contextmenu;
    if (validContexMenuTags.includes(tag.toLowerCase()) && contextmenu2) {
      return p2[i2];
    }
  }
  return null;
}
function getContextEntry(windowId, scope) {
  const window2 = getWindow(windowId);
  if (!window2 || !window2.contextMenu)
    return false;
  const menu = Object.entries(window2.contextMenu);
  for (let i2 = 0; i2 < menu.length; i2++) {
    if (scope.includes(menu[i2][0]))
      return menu[i2][1];
  }
  return false;
}
const FileManagerContextMenu = {
  "listitem-dir": [
    {
      icon: "launch",
      caption: "Open",
      action: (_2, data) => {
        const path = data.path;
        if (!path)
          return;
        fbClass.goToDirectory(path);
      }
    },
    {
      icon: "push_pin",
      caption: "Pin Folder",
      action: (_2, data) => {
        if (isDirPinned(data.path))
          unpinDirectory(data.path);
        else
          pinDirectory(data.path);
      },
      isActive: (_2, data) => isDirPinned(data.path)
    },
    SEP_ITEM,
    {
      icon: "drive_file_rename_outline",
      caption: "Rename",
      action: (_2, data) => {
        fbState.update((v2) => {
          v2.selectedFilename = data.name;
          return v2;
        });
        showOverlay("renameItem", "FileManager");
      }
    },
    {
      icon: "content_copy",
      caption: "Copy",
      action: (_2, data) => {
        fbState.update((v2) => {
          v2.selectedFilename = data.name;
          return v2;
        });
        fbState.update((v2) => {
          v2.copyingFilename = {
            name: data.name,
            scopedPath: `${data.path}`
          };
          return v2;
        });
      }
    },
    {
      icon: "content_cut",
      caption: "Cut",
      action: (_2, data) => {
        fbState.update((v2) => {
          v2.selectedFilename = data.name;
          return v2;
        });
        fbState.update((v2) => {
          v2.cuttingFilename = {
            name: data.name,
            scopedPath: `${data.path}`
          };
          return v2;
        });
      }
    },
    SEP_ITEM,
    {
      image: TrashIcon,
      caption: "Delete",
      action: async (_2, data) => {
        await deleteItem(data.path);
        fbClass.refresh();
      }
    }
  ],
  "listitem-file": [
    {
      icon: "launch",
      caption: "Open File",
      action: async (_2, data) => {
        if (!data || !data.path)
          return;
        const partial = await getPartialFile(data.path);
        if (!partial)
          return;
        fbClass.openFile(partial);
      }
    },
    SEP_ITEM,
    {
      icon: "push_pin",
      caption: "Pin File",
      action: (_2, data) => {
        if (isFilePinned(data.path))
          unpinFile(data.path);
        else
          pinFile(data.path);
      },
      isActive: (_2, data) => isFilePinned(data.path)
    },
    SEP_ITEM,
    {
      icon: "drive_file_rename_outline",
      caption: "Rename",
      action: (_2, data) => {
        fbState.update((v2) => {
          v2.selectedFilename = data.name;
          return v2;
        });
        showOverlay("renameItem", "FileManager");
      }
    },
    {
      icon: "content_copy",
      caption: "Copy",
      action: (_2, data) => {
        fbState.update((v2) => {
          v2.selectedFilename = data.name;
          return v2;
        });
        fbState.update((v2) => {
          v2.copyingFilename = {
            name: data.name,
            scopedPath: `${data.path}`
          };
          return v2;
        });
      }
    },
    {
      icon: "content_cut",
      caption: "Cut",
      action: (_2, data) => {
        fbState.update((v2) => {
          v2.selectedFilename = data.name;
          return v2;
        });
        fbState.update((v2) => {
          v2.cuttingFilename = {
            name: data.name,
            scopedPath: `${data.path}`
          };
          return v2;
        });
      }
    },
    SEP_ITEM,
    {
      image: TrashIcon,
      caption: "Delete",
      action: (_2, data) => {
        createOverlayableError(
          {
            title: "Delete item?",
            message: `Are you sure you want to permanently delete ${data.name}?`,
            buttons: [
              {
                caption: "Delete",
                action: async () => {
                  fbClass.deleteItem(data["name"], data["path"]);
                },
                suggested: true
              },
              { caption: "Cancel", action() {
              } }
            ],
            image: TrashIcon
          },
          "FileManager"
        );
      }
    }
  ],
  "homepage-folder": [
    {
      caption: "Open Folder",
      icon: "launch",
      action(_2, data) {
        const path = data.path;
        if (!path)
          return;
        fbClass.goToDirectory(path);
      }
    },
    {
      caption: "Find Parent",
      action(_2, data) {
        const path = data.path;
        if (!path)
          return;
        const parent = getParentDirectory(path);
        fbClass.goToDirectory(parent || path);
      }
    },
    SEP_ITEM,
    {
      caption: "Unpin Folder",
      icon: "block",
      action(_2, data) {
        unpinDirectory(data.path);
      }
    }
  ],
  "homepage-file": [
    {
      caption: "Open File",
      icon: "launch",
      async action(_2, data) {
        const path = data.path;
        if (!path)
          return;
        const partial = await getPartialFile(path);
        if (!partial)
          return;
        fbClass.openFile(partial);
      }
    },
    {
      caption: "Find Parent",
      action(_2, data) {
        const path = data.path;
        if (!path)
          return;
        const parent = getParentDirectory(path);
        fbClass.goToDirectory(parent || path);
      }
    },
    SEP_ITEM,
    {
      caption: "Unpin File",
      icon: "block",
      action(_2, data) {
        unpinFile(data.path);
      }
    }
  ]
};
const mutator = "";
function create_fragment$3S(ctx) {
  let div4;
  let div0;
  let img_1;
  let img_1_src_value;
  let t0;
  let div3;
  let p2;
  let t2;
  let input;
  let t3;
  let div2;
  let div1;
  let button0;
  let t4;
  let t5;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      img_1 = element("img");
      t0 = space();
      div3 = element("div");
      p2 = element("p");
      p2.textContent = "Enter a name for the new file:";
      t2 = space();
      input = element("input");
      t3 = space();
      div2 = element("div");
      div1 = element("div");
      button0 = element("button");
      t4 = text("Create");
      t5 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      if (!src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx[1] || fileIcon))
        attr(img_1, "src", img_1_src_value);
      attr(img_1, "alt", "");
      attr(div0, "class", "image");
      attr(input, "type", "text");
      button0.disabled = /*exists*/
      ctx[2];
      attr(div1, "class", "inner");
      attr(div2, "class", "actions");
      attr(div4, "class", "fb-overlay-mutator-wrapper");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div0, img_1);
      append(div4, t0);
      append(div4, div3);
      append(div3, p2);
      append(div3, t2);
      append(div3, input);
      set_input_value(
        input,
        /*filename*/
        ctx[0]
      );
      append(div3, t3);
      append(div3, div2);
      append(div2, div1);
      append(div1, button0);
      append(button0, t4);
      append(div1, t5);
      append(div1, button1);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[6]
          ),
          listen(
            input,
            "input",
            /*updateExists*/
            ctx[3]
          ),
          listen(
            button0,
            "click",
            /*create*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*cancel*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*img*/
      2 && !src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx2[1] || fileIcon)) {
        attr(img_1, "src", img_1_src_value);
      }
      if (dirty & /*filename*/
      1 && input.value !== /*filename*/
      ctx2[0]) {
        set_input_value(
          input,
          /*filename*/
          ctx2[0]
        );
      }
      if (dirty & /*exists*/
      4) {
        button0.disabled = /*exists*/
        ctx2[2];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3F($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(7, $fbState = $$value));
  let filename = "";
  let img = "";
  let exists = false;
  function updateExists() {
    const directories = $fbState.dirContents.directories;
    const files = $fbState.dirContents.files;
    for (let i2 = 0; i2 < directories.length; i2++) {
      if (directories[i2].name == filename)
        return $$invalidate(2, exists = true);
    }
    for (let j2 = 0; j2 < files.length; j2++) {
      if (files[j2].filename == filename)
        return $$invalidate(2, exists = true);
    }
    $$invalidate(2, exists = false);
    $$invalidate(1, img = getMimeIcon(filename) || fileIcon);
  }
  async function create() {
    await writeFile(`${$fbState.currentDir}/${filename}`, new Blob([]));
    set_store_value(fbState, $fbState.selectedFilename = filename, $fbState);
    cancel();
    fbClass.refresh();
  }
  function cancel() {
    hideOverlay("createFile", "FileManager");
    $$invalidate(0, filename = "");
  }
  function input_input_handler() {
    filename = this.value;
    $$invalidate(0, filename);
  }
  return [filename, img, exists, updateExists, create, cancel, input_input_handler];
}
class CreateFile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3F, create_fragment$3S, safe_not_equal, {});
  }
}
function create_fragment$3R(ctx) {
  let div4;
  let div0;
  let t0;
  let div3;
  let p2;
  let t2;
  let input;
  let t3;
  let div2;
  let div1;
  let button0;
  let t4;
  let t5;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      div0.innerHTML = `<img src="${FolderIcon}" alt=""/>`;
      t0 = space();
      div3 = element("div");
      p2 = element("p");
      p2.textContent = "Enter a name for the new folder:";
      t2 = space();
      input = element("input");
      t3 = space();
      div2 = element("div");
      div1 = element("div");
      button0 = element("button");
      t4 = text("Create");
      t5 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(div0, "class", "image");
      attr(input, "type", "text");
      button0.disabled = /*exists*/
      ctx[1];
      attr(div1, "class", "inner");
      attr(div2, "class", "actions");
      attr(div4, "class", "fb-overlay-mutator-wrapper");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div4, t0);
      append(div4, div3);
      append(div3, p2);
      append(div3, t2);
      append(div3, input);
      set_input_value(
        input,
        /*folderName*/
        ctx[0]
      );
      append(div3, t3);
      append(div3, div2);
      append(div2, div1);
      append(div1, button0);
      append(button0, t4);
      append(div1, t5);
      append(div1, button1);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[5]
          ),
          listen(
            input,
            "input",
            /*updateExists*/
            ctx[2]
          ),
          listen(
            button0,
            "click",
            /*create*/
            ctx[3]
          ),
          listen(
            button1,
            "click",
            /*cancel*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*folderName*/
      1 && input.value !== /*folderName*/
      ctx2[0]) {
        set_input_value(
          input,
          /*folderName*/
          ctx2[0]
        );
      }
      if (dirty & /*exists*/
      2) {
        button0.disabled = /*exists*/
        ctx2[1];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3E($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(6, $fbState = $$value));
  let folderName = "";
  let exists = false;
  function updateExists() {
    const directories = $fbState.dirContents.directories;
    const files = $fbState.dirContents.files;
    for (let i2 = 0; i2 < directories.length; i2++) {
      if (directories[i2].name == folderName)
        return $$invalidate(1, exists = true);
    }
    for (let j2 = 0; j2 < files.length; j2++) {
      if (files[j2].filename == folderName)
        return $$invalidate(1, exists = true);
    }
    $$invalidate(1, exists = false);
  }
  async function create() {
    await createDirectory(`${$fbState.currentDir}/${folderName}`);
    set_store_value(fbState, $fbState.selectedFilename = folderName, $fbState);
    cancel();
    fbClass.refresh();
  }
  function cancel() {
    hideOverlay("createFolder", "FileManager");
    $$invalidate(0, folderName = "");
  }
  function input_input_handler() {
    folderName = this.value;
    $$invalidate(0, folderName);
  }
  return [folderName, exists, updateExists, create, cancel, input_input_handler];
}
class CreateFolder extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3E, create_fragment$3R, safe_not_equal, {});
  }
}
const deletingfile = "";
function create_fragment$3Q(ctx) {
  let div3;
  let div0;
  let t0;
  let div1;
  let t1;
  let t2_value = (
    /*$fbState*/
    ctx[0].deletingFilename + ""
  );
  let t2;
  let t3;
  let t4;
  let div2;
  let spinner2;
  let current;
  spinner2 = new Spinner({ props: { height: 30 } });
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      div0.innerHTML = `<img src="${TrashIcon}" alt=""/>`;
      t0 = space();
      div1 = element("div");
      t1 = text("Deleting ");
      t2 = text(t2_value);
      t3 = text("...");
      t4 = space();
      div2 = element("div");
      create_component(spinner2.$$.fragment);
      attr(div0, "class", "icon");
      attr(div1, "class", "caption");
      attr(div2, "class", "spin");
      attr(div3, "class", "deletingfile-wrapper");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div3, t0);
      append(div3, div1);
      append(div1, t1);
      append(div1, t2);
      append(div1, t3);
      append(div3, t4);
      append(div3, div2);
      mount_component(spinner2, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*$fbState*/
      1) && t2_value !== (t2_value = /*$fbState*/
      ctx2[0].deletingFilename + ""))
        set_data(t2, t2_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(spinner2);
    }
  };
}
function instance$3D($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(0, $fbState = $$value));
  return [$fbState];
}
class DeletingItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3D, create_fragment$3Q, safe_not_equal, {});
  }
}
const openingfile = "";
function create_if_block$1r(ctx) {
  let div3;
  let div0;
  let t0;
  let div1;
  let t1;
  let t2_value = (
    /*$fbState*/
    ctx[0].openingFile.filename + ""
  );
  let t2;
  let t3;
  let t4;
  let div2;
  let spinner2;
  let t5;
  let table;
  let tr0;
  let td0;
  let t7;
  let td1;
  let t8_value = (
    /*$fbState*/
    ctx[0].openingFile.filename + ""
  );
  let t8;
  let t9;
  let tr1;
  let td2;
  let t11;
  let td3;
  let t12_value = (
    /*$fbState*/
    ctx[0].openingFile.filename + ""
  );
  let t12;
  let t13;
  let tr2;
  let td4;
  let t15;
  let td5;
  let t16_value = (
    /*$fbState*/
    ctx[0].openingFile.mime + ""
  );
  let t16;
  let t17;
  let tr3;
  let td6;
  let t19;
  let td7;
  let t20_value = formatBytes(
    /*$fbState*/
    ctx[0].openingFile.size
  ) + "";
  let t20;
  let current;
  spinner2 = new Spinner({ props: { height: 30 } });
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      div0.innerHTML = `<img src="${MemoryIcon}" alt=""/>`;
      t0 = space();
      div1 = element("div");
      t1 = text("Downloading ");
      t2 = text(t2_value);
      t3 = text(" to RAM...");
      t4 = space();
      div2 = element("div");
      create_component(spinner2.$$.fragment);
      t5 = space();
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      td0.textContent = "Name";
      t7 = space();
      td1 = element("td");
      t8 = text(t8_value);
      t9 = space();
      tr1 = element("tr");
      td2 = element("td");
      td2.textContent = "Path";
      t11 = space();
      td3 = element("td");
      t12 = text(t12_value);
      t13 = space();
      tr2 = element("tr");
      td4 = element("td");
      td4.textContent = "Mimetype";
      t15 = space();
      td5 = element("td");
      t16 = text(t16_value);
      t17 = space();
      tr3 = element("tr");
      td6 = element("td");
      td6.textContent = "Size";
      t19 = space();
      td7 = element("td");
      t20 = text(t20_value);
      attr(div0, "class", "icon");
      attr(div1, "class", "caption");
      attr(div2, "class", "spin");
      attr(div3, "class", "openingfile-wrapper");
      attr(td0, "class", "key");
      attr(td2, "class", "key");
      attr(td4, "class", "key");
      attr(td6, "class", "key");
      attr(table, "class", "openfile-details");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div3, t0);
      append(div3, div1);
      append(div1, t1);
      append(div1, t2);
      append(div1, t3);
      append(div3, t4);
      append(div3, div2);
      mount_component(spinner2, div2, null);
      insert(target, t5, anchor);
      insert(target, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      append(tr0, t7);
      append(tr0, td1);
      append(td1, t8);
      append(table, t9);
      append(table, tr1);
      append(tr1, td2);
      append(tr1, t11);
      append(tr1, td3);
      append(td3, t12);
      append(table, t13);
      append(table, tr2);
      append(tr2, td4);
      append(tr2, t15);
      append(tr2, td5);
      append(td5, t16);
      append(table, t17);
      append(table, tr3);
      append(tr3, td6);
      append(tr3, t19);
      append(tr3, td7);
      append(td7, t20);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*$fbState*/
      1) && t2_value !== (t2_value = /*$fbState*/
      ctx2[0].openingFile.filename + ""))
        set_data(t2, t2_value);
      if ((!current || dirty & /*$fbState*/
      1) && t8_value !== (t8_value = /*$fbState*/
      ctx2[0].openingFile.filename + ""))
        set_data(t8, t8_value);
      if ((!current || dirty & /*$fbState*/
      1) && t12_value !== (t12_value = /*$fbState*/
      ctx2[0].openingFile.filename + ""))
        set_data(t12, t12_value);
      if ((!current || dirty & /*$fbState*/
      1) && t16_value !== (t16_value = /*$fbState*/
      ctx2[0].openingFile.mime + ""))
        set_data(t16, t16_value);
      if ((!current || dirty & /*$fbState*/
      1) && t20_value !== (t20_value = formatBytes(
        /*$fbState*/
        ctx2[0].openingFile.size
      ) + ""))
        set_data(t20, t20_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
        detach(t5);
        detach(table);
      }
      destroy_component(spinner2);
    }
  };
}
function create_fragment$3P(ctx) {
  let t0;
  let button;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$fbState*/
    ctx[0].openingFile && create_if_block$1r(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      button = element("button");
      button.textContent = "Cancel";
      attr(button, "class", "cancel");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, button, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*abort*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*$fbState*/
        ctx2[0].openingFile
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$fbState*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1r(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(button);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$3C($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(0, $fbState = $$value));
  function abort() {
    abortFileReader.set(true);
    hideOverlay("openingFile", "FileManager");
  }
  return [$fbState, abort];
}
class OpeningFile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3C, create_fragment$3P, safe_not_equal, {});
  }
}
function create_fragment$3O(ctx) {
  let div4;
  let div0;
  let img_1;
  let img_1_src_value;
  let t0;
  let div3;
  let p2;
  let t1;
  let t2_value = (
    /*$fbState*/
    ctx[4].selectedFilename + ""
  );
  let t2;
  let t3;
  let t4;
  let input;
  let input_placeholder_value;
  let t5;
  let div2;
  let div1;
  let button0;
  let t6;
  let button0_disabled_value;
  let t7;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      img_1 = element("img");
      t0 = space();
      div3 = element("div");
      p2 = element("p");
      t1 = text("Enter a new name for ");
      t2 = text(t2_value);
      t3 = text(":");
      t4 = space();
      input = element("input");
      t5 = space();
      div2 = element("div");
      div1 = element("div");
      button0 = element("button");
      t6 = text("Rename");
      t7 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      if (!src_url_equal(img_1.src, img_1_src_value = /*isDir*/
      ctx[2] ? FolderIcon : (
        /*img*/
        ctx[1]
      )))
        attr(img_1, "src", img_1_src_value);
      attr(img_1, "alt", "");
      attr(div0, "class", "image");
      attr(input, "type", "text");
      attr(input, "placeholder", input_placeholder_value = /*$fbState*/
      ctx[4].selectedFilename);
      button0.disabled = button0_disabled_value = /*exists*/
      ctx[3] || !/*newName*/
      ctx[0];
      attr(div1, "class", "inner");
      attr(div2, "class", "actions");
      attr(div4, "class", "fb-overlay-mutator-wrapper");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div0, img_1);
      append(div4, t0);
      append(div4, div3);
      append(div3, p2);
      append(p2, t1);
      append(p2, t2);
      append(p2, t3);
      append(div3, t4);
      append(div3, input);
      set_input_value(
        input,
        /*newName*/
        ctx[0]
      );
      append(div3, t5);
      append(div3, div2);
      append(div2, div1);
      append(div1, button0);
      append(button0, t6);
      append(div1, t7);
      append(div1, button1);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[8]
          ),
          listen(
            input,
            "input",
            /*updateExists*/
            ctx[5]
          ),
          listen(
            button0,
            "click",
            /*rename*/
            ctx[6]
          ),
          listen(
            button1,
            "click",
            /*cancel*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*isDir, img*/
      6 && !src_url_equal(img_1.src, img_1_src_value = /*isDir*/
      ctx2[2] ? FolderIcon : (
        /*img*/
        ctx2[1]
      ))) {
        attr(img_1, "src", img_1_src_value);
      }
      if (dirty & /*$fbState*/
      16 && t2_value !== (t2_value = /*$fbState*/
      ctx2[4].selectedFilename + ""))
        set_data(t2, t2_value);
      if (dirty & /*$fbState*/
      16 && input_placeholder_value !== (input_placeholder_value = /*$fbState*/
      ctx2[4].selectedFilename)) {
        attr(input, "placeholder", input_placeholder_value);
      }
      if (dirty & /*newName*/
      1 && input.value !== /*newName*/
      ctx2[0]) {
        set_input_value(
          input,
          /*newName*/
          ctx2[0]
        );
      }
      if (dirty & /*exists, newName*/
      9 && button0_disabled_value !== (button0_disabled_value = /*exists*/
      ctx2[3] || !/*newName*/
      ctx2[0])) {
        button0.disabled = button0_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3B($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(4, $fbState = $$value));
  let newName = "";
  let img = "";
  let isDir = false;
  let exists = false;
  function updateExists() {
    const directories = $fbState.dirContents.directories;
    const files = $fbState.dirContents.files;
    $$invalidate(2, isDir = checkIsDir());
    for (let i2 = 0; i2 < directories.length; i2++) {
      if (directories[i2].name == $fbState.currentDir)
        $$invalidate(2, isDir = true);
    }
    for (let j2 = 0; j2 < files.length; j2++) {
      if (files[j2].filename == newName)
        return $$invalidate(3, exists = true);
    }
    $$invalidate(3, exists = false);
  }
  fbState.subscribe((v2) => {
    if (!v2 || !v2.selectedFilename)
      return;
    $$invalidate(2, isDir = checkIsDir());
    $$invalidate(1, img = getMimeIcon(v2.selectedFilename));
  });
  function checkIsDir() {
    const directories = $fbState.dirContents.directories;
    for (let i2 = 0; i2 < directories.length; i2++) {
      if (directories[i2].name == $fbState.selectedFilename)
        return true;
    }
    return false;
  }
  async function rename() {
    await renameItem(`${$fbState.currentDir}/${$fbState.selectedFilename}`, `${$fbState.currentDir}/${newName}`);
    set_store_value(fbState, $fbState.selectedFilename = newName, $fbState);
    cancel();
    $$invalidate(0, newName = "");
    fbClass.refresh();
  }
  function cancel() {
    hideOverlay("renameItem", "FileManager");
  }
  function input_input_handler() {
    newName = this.value;
    $$invalidate(0, newName);
  }
  return [
    newName,
    img,
    isDir,
    exists,
    $fbState,
    updateExists,
    rename,
    cancel,
    input_input_handler
  ];
}
class RenameItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3B, create_fragment$3O, safe_not_equal, {});
  }
}
const uploadingfile = "";
const APIReveal_svelte_svelte_type_style_lang = "";
function create_fragment$3N(ctx) {
  let span2;
  let span0;
  let t0_value = (
    /*api*/
    (ctx[0] || getServer() || location.hostname) + ""
  );
  let t0;
  let t1;
  let span1;
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      attr(span0, "class", "api svelte-1lv4tmj");
      attr(span1, "class", "placeholder svelte-1lv4tmj");
      attr(span2, "class", "reveal svelte-1lv4tmj");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      append(span0, t0);
      append(span2, t1);
      append(span2, span1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*api*/
      1 && t0_value !== (t0_value = /*api*/
      (ctx2[0] || getServer() || location.hostname) + ""))
        set_data(t0, t0_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span2);
      }
    }
  };
}
function instance$3A($$self, $$props, $$invalidate) {
  let { api: api2 = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("api" in $$props2)
      $$invalidate(0, api2 = $$props2.api);
  };
  return [api2];
}
class APIReveal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3A, create_fragment$3N, safe_not_equal, { api: 0 });
  }
}
function create_if_block$1q(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let t1;
  let t2_value = (
    /*$fbState*/
    ctx[0].uploadFile.name + ""
  );
  let t2;
  let t3;
  let t4;
  let div6;
  let div4;
  let div3;
  let t5;
  let div5;
  let t6_value = (
    /*$fbState*/
    ctx[0].uploadProgress.toFixed(0) + ""
  );
  let t6;
  let t7;
  let t8;
  let table;
  let tr0;
  let td0;
  let t10;
  let td1;
  let t11_value = (
    /*$fbState*/
    ctx[0].uploadFile.path + ""
  );
  let t11;
  let t12;
  let tr1;
  let td2;
  let t14;
  let td3;
  let t15_value = (
    /*$fbState*/
    ctx[0].uploadFile.mime + ""
  );
  let t15;
  let t16;
  let tr2;
  let td4;
  let t18;
  let td5;
  let apireveal;
  let current;
  apireveal = new APIReveal({});
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<img src="${UploadIcon}" alt=""/>`;
      t0 = space();
      div1 = element("div");
      t1 = text("Uploading ");
      t2 = text(t2_value);
      t3 = text("...");
      t4 = space();
      div6 = element("div");
      div4 = element("div");
      div3 = element("div");
      t5 = space();
      div5 = element("div");
      t6 = text(t6_value);
      t7 = text("%");
      t8 = space();
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      td0.textContent = "Path";
      t10 = space();
      td1 = element("td");
      t11 = text(t11_value);
      t12 = space();
      tr1 = element("tr");
      td2 = element("td");
      td2.textContent = "Type";
      t14 = space();
      td3 = element("td");
      t15 = text(t15_value);
      t16 = space();
      tr2 = element("tr");
      td4 = element("td");
      td4.textContent = "Target";
      t18 = space();
      td5 = element("td");
      create_component(apireveal.$$.fragment);
      attr(div0, "class", "icon");
      attr(div1, "class", "caption");
      attr(div2, "class", "uploadingfile-wrapper");
      attr(div3, "class", "inner");
      set_style(div3, "width", Math.floor(
        /*$fbState*/
        ctx[0].uploadProgress
      ) + "%");
      attr(div4, "class", "progress");
      attr(div5, "class", "percentage");
      attr(div6, "class", "progress-wrapper");
      attr(td0, "class", "key");
      attr(td2, "class", "key");
      attr(td4, "class", "key");
      attr(table, "class", "openfile-details");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t0);
      append(div2, div1);
      append(div1, t1);
      append(div1, t2);
      append(div1, t3);
      insert(target, t4, anchor);
      insert(target, div6, anchor);
      append(div6, div4);
      append(div4, div3);
      append(div6, t5);
      append(div6, div5);
      append(div5, t6);
      append(div5, t7);
      insert(target, t8, anchor);
      insert(target, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      append(tr0, t10);
      append(tr0, td1);
      append(td1, t11);
      append(table, t12);
      append(table, tr1);
      append(tr1, td2);
      append(tr1, t14);
      append(tr1, td3);
      append(td3, t15);
      append(table, t16);
      append(table, tr2);
      append(tr2, td4);
      append(tr2, t18);
      append(tr2, td5);
      mount_component(apireveal, td5, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*$fbState*/
      1) && t2_value !== (t2_value = /*$fbState*/
      ctx2[0].uploadFile.name + ""))
        set_data(t2, t2_value);
      if (!current || dirty & /*$fbState*/
      1) {
        set_style(div3, "width", Math.floor(
          /*$fbState*/
          ctx2[0].uploadProgress
        ) + "%");
      }
      if ((!current || dirty & /*$fbState*/
      1) && t6_value !== (t6_value = /*$fbState*/
      ctx2[0].uploadProgress.toFixed(0) + ""))
        set_data(t6, t6_value);
      if ((!current || dirty & /*$fbState*/
      1) && t11_value !== (t11_value = /*$fbState*/
      ctx2[0].uploadFile.path + ""))
        set_data(t11, t11_value);
      if ((!current || dirty & /*$fbState*/
      1) && t15_value !== (t15_value = /*$fbState*/
      ctx2[0].uploadFile.mime + ""))
        set_data(t15, t15_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(apireveal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(apireveal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t4);
        detach(div6);
        detach(t8);
        detach(table);
      }
      destroy_component(apireveal);
    }
  };
}
function create_fragment$3M(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$fbState*/
    ctx[0].uploadFile && create_if_block$1q(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$fbState*/
        ctx2[0].uploadFile
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$fbState*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1q(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$3z($$self, $$props, $$invalidate) {
  let $fbState;
  component_subscribe($$self, fbState, ($$value) => $$invalidate(0, $fbState = $$value));
  return [$fbState];
}
class UploadingFile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3z, create_fragment$3M, safe_not_equal, {});
  }
}
const fbOverlays = {
  openingFile: {
    info: {
      name: "Opening File",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: OpeningFile,
    size: { w: 430, h: 165 },
    show: false
  },
  deletingItem: {
    info: {
      name: "Deleting Item",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: DeletingItem,
    size: { w: 430, h: 75 },
    show: false
  },
  createFolder: {
    info: {
      name: "Create Folder",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: CreateFolder,
    size: { w: 350, h: 120 },
    show: false
  },
  createFile: {
    info: {
      name: "Create File",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: CreateFile,
    size: { w: 350, h: 120 },
    show: false
  },
  uploadingFile: {
    info: {
      name: "Uploading File",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: UploadingFile,
    size: { w: 430, h: 175 },
    show: false
  },
  renameItem: {
    info: {
      name: "Rename Item",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: RenameItem,
    size: { w: 350, h: 120 },
    show: false
  }
};
const FileBrowserApp = {
  info: {
    name: "File Manager",
    description: "Browse your files",
    builtin: true,
    version: "2.5.1",
    author: "ArcOS Team",
    icon: FileManagerIcon,
    appGroup: "utilities"
  },
  size: { w: 700, h: 450 },
  pos: { x: 30, y: 40 },
  minSize: { w: 700, h: 450 },
  maxSize: { w: 1e3, h: 600 },
  controls: { min: true, max: true, cls: true },
  state: {
    headless: false,
    resizable: true,
    windowState: { min: false, max: false, fll: false }
  },
  content: FileBrowser,
  glass: true,
  overlays: fbOverlays,
  contextMenu: FileManagerContextMenu,
  events: {
    async open() {
      fbState.update((v2) => {
        v2.home = true;
        return v2;
      });
      await fbClass.goToDirectory("./", false);
    }
  }
};
const iconlibrary = "";
const apploader = "" + new URL("apploader-cf8168a8.svg", import.meta.url).href;
const handlers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AppLoaderIcon: apploader,
  LoadThemeIcon: loadThemeIcon,
  OpenInNewIcon: openInNewIcon,
  PdfOpenerIcon: pdfOpenerIcon
}, Symbol.toStringTag, { value: "Module" }));
const ICON_GROUP_CAPTIONS = {
  generals: "General Icons",
  apps: "Apps",
  handlers: "File Handlers",
  mimes: "Mimetypes",
  power: "Power Icons"
};
function getGroupedIcons() {
  return { generals, apps: apps$1, handlers, mimes, power };
}
function get_each_context$L(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2][0];
  child_ctx[2] = list2[i2][1];
  return child_ctx;
}
function get_each_context_1$c(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2][0];
  child_ctx[6] = list2[i2][1];
  return child_ctx;
}
function create_if_block$1p(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(Object.entries(
    /*groups*/
    ctx[0]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$L(get_each_context$L(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, groups*/
      1) {
        each_value = ensure_array_like(Object.entries(
          /*groups*/
          ctx2[0]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$L(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$L(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1$c(ctx) {
  let img;
  let img_src_value;
  let img_title_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*url*/
      ctx[6]))
        attr(img, "src", img_src_value);
      attr(img, "title", img_title_value = /*icon*/
      ctx[5]);
      attr(img, "alt", img_alt_value = /*icon*/
      ctx[5]);
      attr(img, "class", "icon");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups*/
      1 && !src_url_equal(img.src, img_src_value = /*url*/
      ctx2[6])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*groups*/
      1 && img_title_value !== (img_title_value = /*icon*/
      ctx2[5])) {
        attr(img, "title", img_title_value);
      }
      if (dirty & /*groups*/
      1 && img_alt_value !== (img_alt_value = /*icon*/
      ctx2[5])) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_each_block$L(ctx) {
  let div1;
  let h2;
  let t0_value = (ICON_GROUP_CAPTIONS[
    /*id*/
    ctx[1]
  ] || /*id*/
  ctx[1]) + "";
  let t0;
  let t1;
  let div0;
  let t2;
  let div1_class_value;
  let each_value_1 = ensure_array_like(Object.entries(
    /*items*/
    ctx[2]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$c(get_each_context_1$c(ctx, each_value_1, i2));
  }
  return {
    c() {
      div1 = element("div");
      h2 = element("h2");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      attr(h2, "class", "header");
      attr(div0, "class", "icons");
      attr(div1, "class", div1_class_value = "group group-" + /*id*/
      ctx[1]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, h2);
      append(h2, t0);
      append(div1, t1);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups*/
      1 && t0_value !== (t0_value = (ICON_GROUP_CAPTIONS[
        /*id*/
        ctx2[1]
      ] || /*id*/
      ctx2[1]) + ""))
        set_data(t0, t0_value);
      if (dirty & /*Object, groups*/
      1) {
        each_value_1 = ensure_array_like(Object.entries(
          /*items*/
          ctx2[2]
        ));
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$c(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$c(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div0, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*groups*/
      1 && div1_class_value !== (div1_class_value = "group group-" + /*id*/
      ctx2[1])) {
        attr(div1, "class", div1_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$3L(ctx) {
  let if_block_anchor;
  let if_block = (
    /*groups*/
    ctx[0] && create_if_block$1p(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*groups*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1p(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$3y($$self, $$props, $$invalidate) {
  let groups;
  onMount(() => {
    $$invalidate(0, groups = getGroupedIcons());
  });
  return [groups];
}
let IconLibrary$1 = class IconLibrary extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3y, create_fragment$3L, safe_not_equal, {});
  }
};
const IconLibrary2 = {
  info: {
    name: "Icon Library",
    description: "View the icons in ArcOS",
    builtin: true,
    version: "0.0.1",
    author: "Izaak Kuipers",
    hidden: true,
    icon: IconLibraryIcon,
    appGroup: "utilities"
  },
  size: { w: 595, h: NaN },
  pos: { x: 30, y: 40 },
  minSize: { w: 500, h: 470 },
  maxSize: (
    /* { w: 500, h: 480 } */
    { w: NaN, h: NaN }
  ),
  controls: { min: true, max: true, cls: true },
  state: {
    headless: false,
    resizable: true,
    windowState: { min: false, max: false, fll: false }
  },
  content: IconLibrary$1,
  glass: false
};
const imageviewer = "";
function create_if_block$1o(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  let img_data_path_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*url*/
      ctx[1]))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*app*/
      ctx[0].openedFile.name);
      attr(img, "data-contextmenu", "output");
      attr(img, "data-path", img_data_path_value = /*app*/
      ctx[0].openedFile.path);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*url*/
      2 && !src_url_equal(img.src, img_src_value = /*url*/
      ctx2[1])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*app*/
      1 && img_alt_value !== (img_alt_value = /*app*/
      ctx2[0].openedFile.name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*app*/
      1 && img_data_path_value !== (img_data_path_value = /*app*/
      ctx2[0].openedFile.path)) {
        attr(img, "data-path", img_data_path_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_fragment$3K(ctx) {
  let if_block_anchor;
  let if_block = (
    /*app*/
    ctx[0].openedFile && /*url*/
    ctx[1] && create_if_block$1o(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*app*/
        ctx2[0].openedFile && /*url*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1o(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$3x($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let url = "";
  WindowStore.subscribe(() => {
    if (!app.openedFile)
      return $$invalidate(1, url = "");
    const blob = arrayToBlob(app.openedFile.data, app.openedFile.mime);
    $$invalidate(1, url = URL.createObjectURL(blob));
  });
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [app, url];
}
class ImageView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3x, create_fragment$3K, safe_not_equal, { app: 0 });
  }
}
function setTitleSuffix(content2, appId) {
  WindowStore.update((ws) => {
    for (let i2 = 0; i2 < ws.length; i2++) {
      if (ws[i2].id == appId) {
        if (!Originals[appId])
          Originals[appId] = `${ws[i2].info.titleSuffix}`;
        ws[i2].info.titleSuffix = content2;
      }
    }
    return ws;
  });
}
const Originals = {};
const ImageViewer = {
  info: {
    name: "Image Viewer",
    description: "Display images from the ArcAPI",
    builtin: true,
    version: "2.0.1",
    author: "Izaak Kuipers",
    hidden: true,
    icon: ImageViewerIcon,
    appGroup: "entertainment"
  },
  size: { w: 500, h: 400 },
  pos: { x: 30, y: 40 },
  minSize: { w: 500, h: 400 },
  maxSize: { w: 1e3, h: 700 },
  controls: { min: true, max: true, cls: true },
  state: {
    headless: false,
    resizable: true,
    windowState: { min: false, max: false, fll: false }
  },
  content: ImageView,
  glass: true,
  fileMimes: [
    "image/png",
    "image/jpeg",
    "image/svg+xml",
    "image/vnd.microsoft.icon",
    "image/bmp",
    "image/jpeg",
    "image/webp",
    "image/gif"
  ],
  events: {
    openFile(app) {
      if (!app.openedFile)
        return;
      setTitleSuffix(` - ${app.openedFile.name}`, app.id);
    }
  },
  contextMenu: {
    output: [
      {
        caption: "Set as wallpaper",
        icon: "image",
        action(window2, data, scope) {
          UserData$2.update((udata) => {
            udata.sh.desktop.wallpaper = `@local:${toBase64(data["path"])}`;
            return udata;
          });
        }
      }
    ]
  }
};
const Stats_svelte_svelte_type_style_lang = "";
function create_fragment$3J(ctx) {
  let div3;
  let button;
  let t1;
  let div2;
  let div0;
  let t2;
  let t3_value = (
    /*level*/
    ctx[0] + 1 + ""
  );
  let t3;
  let t4;
  let div1;
  let t5;
  let t6;
  let t7_value = (
    /*clicks*/
    ctx[1] == 1 ? "" : "s"
  );
  let t7;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      button = element("button");
      button.textContent = "Reset";
      t1 = space();
      div2 = element("div");
      div0 = element("div");
      t2 = text("Level ");
      t3 = text(t3_value);
      t4 = space();
      div1 = element("div");
      t5 = text(
        /*clicks*/
        ctx[1]
      );
      t6 = text(" Click");
      t7 = text(t7_value);
      attr(button, "class", "reset-game");
      attr(div0, "class", "stat svelte-1gm5381");
      attr(div1, "class", "stat svelte-1gm5381");
      attr(div2, "class", "right svelte-1gm5381");
      attr(div3, "class", "statistics svelte-1gm5381");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, button);
      append(div3, t1);
      append(div3, div2);
      append(div2, div0);
      append(div0, t2);
      append(div0, t3);
      append(div2, t4);
      append(div2, div1);
      append(div1, t5);
      append(div1, t6);
      append(div1, t7);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*reset*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*level*/
      1 && t3_value !== (t3_value = /*level*/
      ctx2[0] + 1 + ""))
        set_data(t3, t3_value);
      if (dirty & /*clicks*/
      2)
        set_data(
          t5,
          /*clicks*/
          ctx2[1]
        );
      if (dirty & /*clicks*/
      2 && t7_value !== (t7_value = /*clicks*/
      ctx2[1] == 1 ? "" : "s"))
        set_data(t7, t7_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3w($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(5, $UserData = $$value));
  let { app } = $$props;
  let { runtime } = $$props;
  let level = 0;
  let clicks = 0;
  onMount(() => {
    runtime.LEVEL.subscribe((v2) => $$invalidate(0, level = v2));
    runtime.Clicks.subscribe((v2) => $$invalidate(1, clicks = v2));
  });
  function reset() {
    set_store_value(UserData$2, $UserData.appdata[app.id] = null, $UserData);
    runtime.loadData();
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(3, app = $$props2.app);
    if ("runtime" in $$props2)
      $$invalidate(4, runtime = $$props2.runtime);
  };
  return [level, clicks, reset, app, runtime];
}
class Stats extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3w, create_fragment$3J, safe_not_equal, { app: 3, runtime: 4 });
  }
}
const Light_svelte_svelte_type_style_lang = "";
function create_fragment$3I(ctx) {
  let button;
  let button_id_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      attr(button, "id", button_id_value = "pos-" + /*x*/
      ctx[1] + "x" + /*y*/
      ctx[2]);
      attr(button, "class", "light svelte-11uaj66");
      toggle_class(
        button,
        "lit",
        /*light*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggle*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*x, y*/
      6 && button_id_value !== (button_id_value = "pos-" + /*x*/
      ctx2[1] + "x" + /*y*/
      ctx2[2])) {
        attr(button, "id", button_id_value);
      }
      if (dirty & /*light*/
      1) {
        toggle_class(
          button,
          "lit",
          /*light*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3v($$self, $$props, $$invalidate) {
  let { light = false } = $$props;
  let { x: x2 } = $$props;
  let { y: y2 } = $$props;
  let { runtime } = $$props;
  function toggle() {
    runtime.ToggleLight(x2, y2);
  }
  $$self.$$set = ($$props2) => {
    if ("light" in $$props2)
      $$invalidate(0, light = $$props2.light);
    if ("x" in $$props2)
      $$invalidate(1, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y2 = $$props2.y);
    if ("runtime" in $$props2)
      $$invalidate(4, runtime = $$props2.runtime);
  };
  return [light, x2, y2, toggle, runtime];
}
class Light extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3v, create_fragment$3I, safe_not_equal, { light: 0, x: 1, y: 2, runtime: 4 });
  }
}
const LightsOff_svelte_svelte_type_style_lang = "";
function get_each_context$K(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  child_ctx[5] = i2;
  return child_ctx;
}
function get_each_context_1$b(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list2[i2];
  child_ctx[8] = i2;
  return child_ctx;
}
function create_each_block_1$b(ctx) {
  let light_1;
  let current;
  light_1 = new Light({
    props: {
      light: (
        /*light*/
        ctx[6]
      ),
      x: (
        /*x*/
        ctx[8]
      ),
      y: (
        /*y*/
        ctx[5]
      ),
      runtime: (
        /*runtime*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(light_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(light_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const light_1_changes = {};
      if (dirty & /*grid*/
      4)
        light_1_changes.light = /*light*/
        ctx2[6];
      if (dirty & /*runtime*/
      2)
        light_1_changes.runtime = /*runtime*/
        ctx2[1];
      light_1.$set(light_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(light_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(light_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(light_1, detaching);
    }
  };
}
function create_each_block$K(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*row*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$b(get_each_context_1$b(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*grid, runtime*/
      6) {
        each_value_1 = ensure_array_like(
          /*row*/
          ctx2[3]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$b(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$b(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$3H(ctx) {
  let stats;
  let t2;
  let div;
  let current;
  stats = new Stats({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      runtime: (
        /*runtime*/
        ctx[1]
      )
    }
  });
  let each_value = ensure_array_like(
    /*grid*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$K(get_each_context$K(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      create_component(stats.$$.fragment);
      t2 = space();
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "grid svelte-svdnfe");
    },
    m(target, anchor) {
      mount_component(stats, target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const stats_changes = {};
      if (dirty & /*app*/
      1)
        stats_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*runtime*/
      2)
        stats_changes.runtime = /*runtime*/
        ctx2[1];
      stats.$set(stats_changes);
      if (dirty & /*grid, runtime*/
      6) {
        each_value = ensure_array_like(
          /*grid*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$K(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$K(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(stats.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(stats.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(div);
      }
      destroy_component(stats, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$3u($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { runtime } = $$props;
  let grid = [];
  onMount(() => {
    runtime.Grid.subscribe((v2) => $$invalidate(2, grid = v2));
  });
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [app, runtime, grid];
}
let LightsOff$1 = class LightsOff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3u, create_fragment$3H, safe_not_equal, { app: 0, runtime: 1 });
  }
};
class LightsOffLevels {
  constructor(runtime) {
    __publicField(this, "runtime");
    __publicField(this, "_store", [
      [
        [false, false, false, false, true],
        [false, false, false, true, true],
        [false, false, false, false, true],
        [false, false, false, false, false],
        [false, false, false, false, false]
      ],
      [
        [false, false, false, false, false],
        [false, false, false, false, false],
        [false, false, false, false, false],
        [true, false, false, false, true],
        [true, true, false, true, true]
      ],
      [
        [true, true, false, true, true],
        [false, true, true, true, false],
        [false, true, true, true, false],
        [false, false, true, false, false],
        [false, false, false, false, false]
      ],
      [
        [false, true, false, false, false],
        [true, true, false, false, false],
        [false, true, true, true, false],
        [true, true, false, false, false],
        [false, true, false, false, false]
      ],
      [
        [true, false, false, false, true],
        [false, true, false, true, false],
        [false, true, false, true, false],
        [false, false, false, false, false],
        [false, false, false, false, false]
      ],
      [
        [true, true, true, false, false],
        [true, true, true, false, false],
        [true, false, true, true, false],
        [true, true, true, false, false],
        [true, true, true, false, false]
      ],
      [
        [true, true, false, false, false],
        [false, false, true, true, false],
        [false, false, true, false, false],
        [false, true, false, true, false],
        [true, true, false, true, true]
      ],
      [
        [true, false, false, false, true],
        [true, false, false, false, true],
        [false, true, true, true, false],
        [false, false, true, false, false],
        [false, false, true, false, false]
      ]
    ]);
    this.runtime = runtime;
  }
  loadLevel(level) {
    if (level >= this._store.length)
      return this.runtime.finish();
    if (!this._store[level])
      return;
    this.runtime.Grid.set(JSON.parse(JSON.stringify(this._store[level])));
    this.runtime.LEVEL.set(level);
    this.runtime.Clicks.set(0);
  }
  checkNextLevel() {
    if (this.runtime.containsLights() || get_store_value(this.runtime.Clicks) == 0)
      return false;
    this.runtime.LEVEL.set(get_store_value(this.runtime.LEVEL) + 1);
    if (get_store_value(this.runtime.LEVEL) > this._store.length)
      return this.runtime.finish();
    this.loadLevel(get_store_value(this.runtime.LEVEL));
    return true;
  }
}
class LightsOffRuntime extends AppRuntime {
  constructor(app) {
    super(app);
    __publicField(this, "xModifiers", [-1, 0, 1]);
    __publicField(this, "yModifiers", [-1, 1]);
    __publicField(this, "Grid", writable([
      [false, false, false, false, false],
      [false, false, false, false, false],
      [false, false, false, false, false],
      [false, false, false, false, false],
      [false, false, false, false, false]
    ]));
    __publicField(this, "Clicks", writable(0));
    __publicField(this, "LEVEL", writable(0));
    __publicField(this, "Levels");
    this.Levels = new LightsOffLevels(this);
    this.Grid.subscribe((v2) => {
      if (!v2)
        return;
      this.Levels.checkNextLevel();
      this.saveData();
    });
    this.LEVEL.subscribe(() => this.saveData());
    this.Clicks.subscribe(() => this.saveData());
    this.loadData();
  }
  containsLights() {
    this.Log("Checking lights", "containsLights");
    return JSON.stringify(get_store_value(this.Grid)).includes("true");
  }
  finish() {
    this.Log("User has won! Finishing...", "finish");
    this.LEVEL.set(0);
    this.Clicks.set(0);
    this.Levels.loadLevel(get_store_value(this.LEVEL));
    createOverlayableError(
      {
        title: "You Win!",
        message: "You've managed to complete all 8 levels of Lights Off. The game will be reset so you can play it again in the future.",
        buttons: [{ caption: "Play again", action() {
        }, suggested: true }],
        image: LightsOffIcon
      },
      "LightsOff"
    );
  }
  ToggleLight(x2, y2) {
    this.Log(`Toggling ${x2}x${y2}`, "ToggleLight");
    const grid = get_store_value(this.Grid);
    if (!grid[y2])
      throw new Error(`y doesn't exist ${y2}`);
    if (typeof grid[y2][x2] !== "boolean")
      throw new Error(`x doesn't exist ${y2} ${x2}`);
    this.Clicks.set(get_store_value(this.Clicks) + 1);
    for (let i2 = 0; i2 < this.xModifiers.length; i2++) {
      const value = grid[y2][x2 + this.xModifiers[i2]];
      if (typeof value !== "boolean")
        continue;
      grid[y2][x2 + this.xModifiers[i2]] = !value;
    }
    for (let i2 = 0; i2 < this.yModifiers.length; i2++) {
      const rowExists = Array.isArray(grid[y2 + this.yModifiers[i2]]);
      if (!rowExists)
        continue;
      const value = grid[y2 + this.yModifiers[i2]][x2];
      if (typeof value !== "boolean")
        continue;
      grid[y2 + this.yModifiers[i2]][x2] = !value;
    }
    this.Grid.set(grid);
  }
  loadData() {
    this.Log("Loading Data from UserData", "loadData");
    const data = get_store_value(UserData$2).appdata[this.app.id];
    if (data) {
      this.Levels.loadLevel(data.level);
      this.Grid.set(data.grid);
      this.Clicks.set(data.clicks);
      return;
    }
    this.Levels.loadLevel(0);
  }
  saveData() {
    if (get_store_value(this.LEVEL) == 0 && !this.containsLights())
      return this.Log("Not saving default state!", "saveData", LogLevel.warn);
    UserData$2.update((udata) => {
      udata.appdata[this.app.id] = {
        clicks: get_store_value(this.Clicks),
        level: get_store_value(this.LEVEL),
        grid: get_store_value(this.Grid)
      };
      return udata;
    });
  }
}
const LightsOff2 = {
  info: {
    name: "Lights Off",
    description: "Turn off all the lights!",
    builtin: true,
    version: "1.0.0",
    author: "Tim Horton, ported to ArcOS by IzKuipers",
    hidden: false,
    icon: LightsOffIcon,
    appGroup: "entertainment"
  },
  size: { w: 442, h: NaN },
  pos: { x: 80, y: 80 },
  minSize: { w: 442, h: 525 },
  maxSize: { w: 442, h: 535 },
  controls: { min: true, max: false, cls: true },
  state: {
    headless: false,
    resizable: false,
    windowState: { min: false, max: false, fll: false }
  },
  content: LightsOff$1,
  glass: true,
  events: {},
  runtime: LightsOffRuntime
};
const logger = "";
function create_fragment$3G(ctx) {
  let button;
  let span;
  let t_value = (
    /*data*/
    ctx[0][1] + ""
  );
  let t2;
  let button_class_value;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "material-icons-round");
      attr(button, "class", button_class_value = "filter " + LogLevel[
        /*data*/
        ctx[0][0]
      ]);
      button.disabled = button_disabled_value = !/*currentSource*/
      ctx[1] || /*disable*/
      ctx[4];
      toggle_class(
        button,
        "selected",
        /*data*/
        ctx[0][0] == /*currentFilter*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      append(span, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*data*/
      1 && t_value !== (t_value = /*data*/
      ctx2[0][1] + ""))
        set_data(t2, t_value);
      if (dirty & /*data*/
      1 && button_class_value !== (button_class_value = "filter " + LogLevel[
        /*data*/
        ctx2[0][0]
      ])) {
        attr(button, "class", button_class_value);
      }
      if (dirty & /*currentSource, disable*/
      18 && button_disabled_value !== (button_disabled_value = !/*currentSource*/
      ctx2[1] || /*disable*/
      ctx2[4])) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*data, data, currentFilter*/
      5) {
        toggle_class(
          button,
          "selected",
          /*data*/
          ctx2[0][0] == /*currentFilter*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3t($$self, $$props, $$invalidate) {
  let $LogStore;
  component_subscribe($$self, LogStore, ($$value) => $$invalidate(6, $LogStore = $$value));
  let { data } = $$props;
  let { currentSource } = $$props;
  let { currentFilter } = $$props;
  let { filter: filter2 } = $$props;
  let disable = false;
  LogStore.subscribe(() => {
    setTimeout(() => {
      let count = 0;
      for (let i2 = 0; i2 < $LogStore.length; i2++) {
        if ($LogStore[i2].level == data[0] && $LogStore[i2].source == currentSource)
          count++;
      }
      $$invalidate(4, disable = !count);
    });
    $$invalidate(4, disable = false);
  });
  const click_handler = () => filter2(data[0]);
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("currentSource" in $$props2)
      $$invalidate(1, currentSource = $$props2.currentSource);
    if ("currentFilter" in $$props2)
      $$invalidate(2, currentFilter = $$props2.currentFilter);
    if ("filter" in $$props2)
      $$invalidate(3, filter2 = $$props2.filter);
  };
  return [data, currentSource, currentFilter, filter2, disable, click_handler];
}
class Filter extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3t, create_fragment$3G, safe_not_equal, {
      data: 0,
      currentSource: 1,
      currentFilter: 2,
      filter: 3
    });
  }
}
function get_each_context$J(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  return child_ctx;
}
function create_each_block$J(ctx) {
  let filter_1;
  let current;
  filter_1 = new Filter({
    props: {
      data: (
        /*data*/
        ctx[4]
      ),
      currentSource: (
        /*currentSource*/
        ctx[2]
      ),
      currentFilter: (
        /*currentFilter*/
        ctx[0]
      ),
      filter: (
        /*filter*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(filter_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filter_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const filter_1_changes = {};
      if (dirty & /*currentSource*/
      4)
        filter_1_changes.currentSource = /*currentSource*/
        ctx2[2];
      if (dirty & /*currentFilter*/
      1)
        filter_1_changes.currentFilter = /*currentFilter*/
        ctx2[0];
      if (dirty & /*filter*/
      2)
        filter_1_changes.filter = /*filter*/
        ctx2[1];
      filter_1.$set(filter_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(filter_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filter_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filter_1, detaching);
    }
  };
}
function create_fragment$3F(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*filters*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$J(get_each_context$J(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "filters");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*filters, currentSource, currentFilter, filter*/
      15) {
        each_value = ensure_array_like(
          /*filters*/
          ctx2[3]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$J(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$J(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$3s($$self, $$props, $$invalidate) {
  let { filter: filter2 } = $$props;
  let { currentFilter } = $$props;
  let { currentSource } = $$props;
  const filters = [
    [LogLevel.error, "error"],
    [LogLevel.warn, "warning"],
    [LogLevel.info, "info"],
    [LogLevel.critical, "cancel"]
  ];
  LogStore.subscribe(() => {
    $$invalidate(0, currentFilter = null);
  });
  $$self.$$set = ($$props2) => {
    if ("filter" in $$props2)
      $$invalidate(1, filter2 = $$props2.filter);
    if ("currentFilter" in $$props2)
      $$invalidate(0, currentFilter = $$props2.currentFilter);
    if ("currentSource" in $$props2)
      $$invalidate(2, currentSource = $$props2.currentSource);
  };
  return [currentFilter, filter2, currentSource, filters];
}
class Filters extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3s, create_fragment$3F, safe_not_equal, {
      filter: 1,
      currentFilter: 0,
      currentSource: 2
    });
  }
}
function create_fragment$3E(ctx) {
  let div1;
  let button0;
  let img;
  let img_src_value;
  let t0;
  let button0_disabled_value;
  let t1;
  let div0;
  let t2;
  let button1;
  let span0;
  let t4;
  let button1_disabled_value;
  let t5;
  let button2;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      button0 = element("button");
      img = element("img");
      t0 = text("\n    Clear");
      t1 = space();
      div0 = element("div");
      t2 = space();
      button1 = element("button");
      span0 = element("span");
      span0.textContent = "refresh";
      t4 = text("\n    Refresh");
      t5 = space();
      button2 = element("button");
      button2.innerHTML = `<span class="material-icons-round">title</span>
    monospace`;
      if (!src_url_equal(img.src, img_src_value = TrashIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "Clear");
      attr(button0, "class", "action");
      button0.disabled = button0_disabled_value = !/*currentSource*/
      ctx[0];
      attr(div0, "class", "sep");
      attr(span0, "class", "material-icons-round");
      attr(button1, "class", "action");
      button1.disabled = button1_disabled_value = !/*currentSource*/
      ctx[0];
      attr(button2, "class", "action");
      attr(div1, "class", "static");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, button0);
      append(button0, img);
      append(button0, t0);
      append(div1, t1);
      append(div1, div0);
      append(div1, t2);
      append(div1, button1);
      append(button1, span0);
      append(button1, t4);
      append(div1, t5);
      append(div1, button2);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[10]
          ),
          listen(
            button1,
            "click",
            /*refresh*/
            ctx[2]
          ),
          listen(
            button2,
            "click",
            /*changeMonospace*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*currentSource*/
      1 && button0_disabled_value !== (button0_disabled_value = !/*currentSource*/
      ctx2[0])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*currentSource*/
      1 && button1_disabled_value !== (button1_disabled_value = !/*currentSource*/
      ctx2[0])) {
        button1.disabled = button1_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3r($$self, $$props, $$invalidate) {
  let $UserData;
  let $LogStore;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(11, $UserData = $$value));
  component_subscribe($$self, LogStore, ($$value) => $$invalidate(12, $LogStore = $$value));
  let { currentSource } = $$props;
  let { currentFilter } = $$props;
  let { logItems } = $$props;
  let { setView } = $$props;
  let { filter: filter2 } = $$props;
  let { appdata } = $$props;
  let { app } = $$props;
  function clearCategory(source2) {
    for (let i2 = 0; i2 < $LogStore.length; i2++) {
      if ($LogStore[i2].source == source2) {
        $LogStore.splice(i2, 1);
      }
    }
    $$invalidate(0, currentSource = "");
    $$invalidate(4, logItems = []);
    LogStore.set($LogStore);
  }
  function refresh() {
    Log("Logger: refresh", "Refreshing current view", LogLevel.warn);
    setView(currentSource);
    if (!currentFilter)
      return;
    filter2(currentFilter);
  }
  function changeMonospace() {
    $$invalidate(5, appdata.monospace = !appdata.monospace, appdata);
    set_store_value(UserData$2, $UserData.appdata[app.id] = appdata, $UserData);
  }
  const click_handler = () => clearCategory(currentSource);
  $$self.$$set = ($$props2) => {
    if ("currentSource" in $$props2)
      $$invalidate(0, currentSource = $$props2.currentSource);
    if ("currentFilter" in $$props2)
      $$invalidate(6, currentFilter = $$props2.currentFilter);
    if ("logItems" in $$props2)
      $$invalidate(4, logItems = $$props2.logItems);
    if ("setView" in $$props2)
      $$invalidate(7, setView = $$props2.setView);
    if ("filter" in $$props2)
      $$invalidate(8, filter2 = $$props2.filter);
    if ("appdata" in $$props2)
      $$invalidate(5, appdata = $$props2.appdata);
    if ("app" in $$props2)
      $$invalidate(9, app = $$props2.app);
  };
  return [
    currentSource,
    clearCategory,
    refresh,
    changeMonospace,
    logItems,
    appdata,
    currentFilter,
    setView,
    filter2,
    app,
    click_handler
  ];
}
class Static extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3r, create_fragment$3E, safe_not_equal, {
      currentSource: 0,
      currentFilter: 6,
      logItems: 4,
      setView: 7,
      filter: 8,
      appdata: 5,
      app: 9
    });
  }
}
function create_fragment$3D(ctx) {
  let div;
  let static_1;
  let updating_currentSource;
  let updating_logItems;
  let updating_appdata;
  let t2;
  let filters;
  let current;
  function static_1_currentSource_binding(value) {
    ctx[8](value);
  }
  function static_1_logItems_binding(value) {
    ctx[9](value);
  }
  function static_1_appdata_binding(value) {
    ctx[10](value);
  }
  let static_1_props = {
    currentFilter: (
      /*currentFilter*/
      ctx[5]
    ),
    filter: (
      /*filter*/
      ctx[6]
    ),
    setView: (
      /*setView*/
      ctx[4]
    ),
    app: (
      /*app*/
      ctx[3]
    )
  };
  if (
    /*currentSource*/
    ctx[0] !== void 0
  ) {
    static_1_props.currentSource = /*currentSource*/
    ctx[0];
  }
  if (
    /*logItems*/
    ctx[1] !== void 0
  ) {
    static_1_props.logItems = /*logItems*/
    ctx[1];
  }
  if (
    /*appdata*/
    ctx[2] !== void 0
  ) {
    static_1_props.appdata = /*appdata*/
    ctx[2];
  }
  static_1 = new Static({ props: static_1_props });
  binding_callbacks.push(() => bind$1(static_1, "currentSource", static_1_currentSource_binding));
  binding_callbacks.push(() => bind$1(static_1, "logItems", static_1_logItems_binding));
  binding_callbacks.push(() => bind$1(static_1, "appdata", static_1_appdata_binding));
  filters = new Filters({
    props: {
      currentFilter: (
        /*currentFilter*/
        ctx[5]
      ),
      currentSource: (
        /*currentSource*/
        ctx[0]
      ),
      filter: (
        /*filter*/
        ctx[6]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(static_1.$$.fragment);
      t2 = space();
      create_component(filters.$$.fragment);
      attr(div, "class", "actions");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(static_1, div, null);
      append(div, t2);
      mount_component(filters, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const static_1_changes = {};
      if (dirty & /*currentFilter*/
      32)
        static_1_changes.currentFilter = /*currentFilter*/
        ctx2[5];
      if (dirty & /*setView*/
      16)
        static_1_changes.setView = /*setView*/
        ctx2[4];
      if (dirty & /*app*/
      8)
        static_1_changes.app = /*app*/
        ctx2[3];
      if (!updating_currentSource && dirty & /*currentSource*/
      1) {
        updating_currentSource = true;
        static_1_changes.currentSource = /*currentSource*/
        ctx2[0];
        add_flush_callback(() => updating_currentSource = false);
      }
      if (!updating_logItems && dirty & /*logItems*/
      2) {
        updating_logItems = true;
        static_1_changes.logItems = /*logItems*/
        ctx2[1];
        add_flush_callback(() => updating_logItems = false);
      }
      if (!updating_appdata && dirty & /*appdata*/
      4) {
        updating_appdata = true;
        static_1_changes.appdata = /*appdata*/
        ctx2[2];
        add_flush_callback(() => updating_appdata = false);
      }
      static_1.$set(static_1_changes);
      const filters_changes = {};
      if (dirty & /*currentFilter*/
      32)
        filters_changes.currentFilter = /*currentFilter*/
        ctx2[5];
      if (dirty & /*currentSource*/
      1)
        filters_changes.currentSource = /*currentSource*/
        ctx2[0];
      filters.$set(filters_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(static_1.$$.fragment, local);
      transition_in(filters.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(static_1.$$.fragment, local);
      transition_out(filters.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(static_1);
      destroy_component(filters);
    }
  };
}
function instance$3q($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { currentSource } = $$props;
  let { logItems } = $$props;
  let { setView } = $$props;
  let { updating } = $$props;
  let { appdata } = $$props;
  let original = [];
  let currentFilter;
  LogStore.subscribe((v2) => {
    $$invalidate(7, updating = true);
    original = [];
    $$invalidate(5, currentFilter = null);
    const logs = Object.entries(v2);
    for (let i2 = 0; i2 < logs.length; i2++) {
      if (logs[i2][0] == currentSource)
        original.push(logs[i2][1]);
    }
    setTimeout(() => {
      $$invalidate(7, updating = false);
    });
  });
  function filter2(level) {
    if (currentFilter == level) {
      const source2 = `${currentSource}`;
      setView(null);
      setTimeout(() => {
        setView(source2);
      });
      return;
    }
    if (!original.length)
      original = logItems;
    const items = [];
    for (let i2 = 0; i2 < original.length; i2++) {
      if (level == original[i2].level)
        items.push(original[i2]);
    }
    $$invalidate(1, logItems = items);
    $$invalidate(5, currentFilter = level);
  }
  function static_1_currentSource_binding(value) {
    currentSource = value;
    $$invalidate(0, currentSource);
  }
  function static_1_logItems_binding(value) {
    logItems = value;
    $$invalidate(1, logItems);
  }
  function static_1_appdata_binding(value) {
    appdata = value;
    $$invalidate(2, appdata);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(3, app = $$props2.app);
    if ("currentSource" in $$props2)
      $$invalidate(0, currentSource = $$props2.currentSource);
    if ("logItems" in $$props2)
      $$invalidate(1, logItems = $$props2.logItems);
    if ("setView" in $$props2)
      $$invalidate(4, setView = $$props2.setView);
    if ("updating" in $$props2)
      $$invalidate(7, updating = $$props2.updating);
    if ("appdata" in $$props2)
      $$invalidate(2, appdata = $$props2.appdata);
  };
  return [
    currentSource,
    logItems,
    appdata,
    app,
    setView,
    currentFilter,
    filter2,
    updating,
    static_1_currentSource_binding,
    static_1_logItems_binding,
    static_1_appdata_binding
  ];
}
let Actions$4 = class Actions extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3q, create_fragment$3D, safe_not_equal, {
      app: 3,
      currentSource: 0,
      logItems: 1,
      setView: 4,
      updating: 7,
      appdata: 2
    });
  }
};
function create_fragment$3C(ctx) {
  let div3;
  let div0;
  let t0_value = (
    /*icons*/
    ctx[1][
      /*logItem*/
      ctx[0].level
    ] + ""
  );
  let t0;
  let div0_class_value;
  let t1;
  let div1;
  let t2_value = dayjs(
    /*logItem*/
    ctx[0].timestamp
  ).format("HH:mm:ss.SSS") + "";
  let t2;
  let t3;
  let div2;
  let t4_value = (
    /*logItem*/
    ctx[0].msg + ""
  );
  let t4;
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      t4 = text(t4_value);
      attr(div0, "class", div0_class_value = "level material-icons-round " + LogLevel[
        /*logItem*/
        ctx[0].level
      ]);
      attr(div1, "class", "timestamp");
      attr(div2, "class", "msg");
      attr(div3, "class", "logitem");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, t0);
      append(div3, t1);
      append(div3, div1);
      append(div1, t2);
      append(div3, t3);
      append(div3, div2);
      append(div2, t4);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*logItem*/
      1 && t0_value !== (t0_value = /*icons*/
      ctx2[1][
        /*logItem*/
        ctx2[0].level
      ] + ""))
        set_data(t0, t0_value);
      if (dirty & /*logItem*/
      1 && div0_class_value !== (div0_class_value = "level material-icons-round " + LogLevel[
        /*logItem*/
        ctx2[0].level
      ])) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty & /*logItem*/
      1 && t2_value !== (t2_value = dayjs(
        /*logItem*/
        ctx2[0].timestamp
      ).format("HH:mm:ss.SSS") + ""))
        set_data(t2, t2_value);
      if (dirty & /*logItem*/
      1 && t4_value !== (t4_value = /*logItem*/
      ctx2[0].msg + ""))
        set_data(t4, t4_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
    }
  };
}
function instance$3p($$self, $$props, $$invalidate) {
  let { logItem } = $$props;
  const icons = {
    0: "info",
    1: "warning",
    2: "error",
    3: "cancel"
  };
  $$self.$$set = ($$props2) => {
    if ("logItem" in $$props2)
      $$invalidate(0, logItem = $$props2.logItem);
  };
  return [logItem, icons];
}
class LogItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3p, create_fragment$3C, safe_not_equal, { logItem: 0 });
  }
}
function get_each_context$I(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  return child_ctx;
}
function create_if_block_1$o(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*logItems*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$I(get_each_context$I(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*logItems*/
      2) {
        each_value = ensure_array_like(
          /*logItems*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$I(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$I(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$I(ctx) {
  let logitemsvelte;
  let current;
  logitemsvelte = new LogItem({ props: { logItem: (
    /*logItem*/
    ctx[4]
  ) } });
  return {
    c() {
      create_component(logitemsvelte.$$.fragment);
    },
    m(target, anchor) {
      mount_component(logitemsvelte, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const logitemsvelte_changes = {};
      if (dirty & /*logItems*/
      2)
        logitemsvelte_changes.logItem = /*logItem*/
        ctx2[4];
      logitemsvelte.$set(logitemsvelte_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(logitemsvelte.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(logitemsvelte.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(logitemsvelte, detaching);
    }
  };
}
function create_if_block$1n(ctx) {
  let div;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let p2;
  return {
    c() {
      div = element("div");
      img = element("img");
      t0 = space();
      p2 = element("p");
      p2.textContent = "No items found.";
      if (!src_url_equal(img.src, img_src_value = getAppIcon(
        /*app*/
        ctx[0]
      )))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*app*/
      ctx[0].info.name);
      attr(div, "class", "noitems");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
      append(div, t0);
      append(div, p2);
    },
    p(ctx2, dirty) {
      if (dirty & /*app*/
      1 && !src_url_equal(img.src, img_src_value = getAppIcon(
        /*app*/
        ctx2[0]
      ))) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*app*/
      1 && img_alt_value !== (img_alt_value = /*app*/
      ctx2[0].info.name)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$3B(ctx) {
  let div;
  let t2;
  let current;
  let if_block0 = !/*updating*/
  ctx[2] && create_if_block_1$o(ctx);
  let if_block1 = !/*logItems*/
  ctx[1].length && create_if_block$1n(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      attr(div, "class", "items");
      toggle_class(div, "cflex", !/*logItems*/
      ctx[1].length);
      toggle_class(div, "monospace", !!/*appdata*/
      ctx[3].monospace);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*updating*/
      ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*updating*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$o(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*logItems*/
      ctx2[1].length) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$1n(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*logItems*/
      2) {
        toggle_class(div, "cflex", !/*logItems*/
        ctx2[1].length);
      }
      if (!current || dirty & /*appdata*/
      8) {
        toggle_class(div, "monospace", !!/*appdata*/
        ctx2[3].monospace);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance$3o($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { logItems } = $$props;
  let { updating } = $$props;
  let { appdata } = $$props;
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("logItems" in $$props2)
      $$invalidate(1, logItems = $$props2.logItems);
    if ("updating" in $$props2)
      $$invalidate(2, updating = $$props2.updating);
    if ("appdata" in $$props2)
      $$invalidate(3, appdata = $$props2.appdata);
  };
  return [app, logItems, updating, appdata];
}
class Items extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3o, create_fragment$3B, safe_not_equal, {
      app: 0,
      logItems: 1,
      updating: 2,
      appdata: 3
    });
  }
}
function create_fragment$3A(ctx) {
  let div;
  let actions;
  let updating_currentSource;
  let updating_logItems;
  let updating_setView;
  let updating_updating;
  let updating_appdata;
  let updating_app;
  let t2;
  let items;
  let updating_logItems_1;
  let updating_updating_1;
  let current;
  function actions_currentSource_binding(value) {
    ctx[6](value);
  }
  function actions_logItems_binding(value) {
    ctx[7](value);
  }
  function actions_setView_binding(value) {
    ctx[8](value);
  }
  function actions_updating_binding(value) {
    ctx[9](value);
  }
  function actions_appdata_binding(value) {
    ctx[10](value);
  }
  function actions_app_binding(value) {
    ctx[11](value);
  }
  let actions_props = {};
  if (
    /*currentSource*/
    ctx[1] !== void 0
  ) {
    actions_props.currentSource = /*currentSource*/
    ctx[1];
  }
  if (
    /*logItems*/
    ctx[2] !== void 0
  ) {
    actions_props.logItems = /*logItems*/
    ctx[2];
  }
  if (
    /*setView*/
    ctx[3] !== void 0
  ) {
    actions_props.setView = /*setView*/
    ctx[3];
  }
  if (
    /*updating*/
    ctx[5] !== void 0
  ) {
    actions_props.updating = /*updating*/
    ctx[5];
  }
  if (
    /*appdata*/
    ctx[4] !== void 0
  ) {
    actions_props.appdata = /*appdata*/
    ctx[4];
  }
  if (
    /*app*/
    ctx[0] !== void 0
  ) {
    actions_props.app = /*app*/
    ctx[0];
  }
  actions = new Actions$4({ props: actions_props });
  binding_callbacks.push(() => bind$1(actions, "currentSource", actions_currentSource_binding));
  binding_callbacks.push(() => bind$1(actions, "logItems", actions_logItems_binding));
  binding_callbacks.push(() => bind$1(actions, "setView", actions_setView_binding));
  binding_callbacks.push(() => bind$1(actions, "updating", actions_updating_binding));
  binding_callbacks.push(() => bind$1(actions, "appdata", actions_appdata_binding));
  binding_callbacks.push(() => bind$1(actions, "app", actions_app_binding));
  function items_logItems_binding(value) {
    ctx[12](value);
  }
  function items_updating_binding(value) {
    ctx[13](value);
  }
  let items_props = {
    app: (
      /*app*/
      ctx[0]
    ),
    appdata: (
      /*appdata*/
      ctx[4]
    )
  };
  if (
    /*logItems*/
    ctx[2] !== void 0
  ) {
    items_props.logItems = /*logItems*/
    ctx[2];
  }
  if (
    /*updating*/
    ctx[5] !== void 0
  ) {
    items_props.updating = /*updating*/
    ctx[5];
  }
  items = new Items({ props: items_props });
  binding_callbacks.push(() => bind$1(items, "logItems", items_logItems_binding));
  binding_callbacks.push(() => bind$1(items, "updating", items_updating_binding));
  return {
    c() {
      div = element("div");
      create_component(actions.$$.fragment);
      t2 = space();
      create_component(items.$$.fragment);
      attr(div, "class", "content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(actions, div, null);
      append(div, t2);
      mount_component(items, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const actions_changes = {};
      if (!updating_currentSource && dirty & /*currentSource*/
      2) {
        updating_currentSource = true;
        actions_changes.currentSource = /*currentSource*/
        ctx2[1];
        add_flush_callback(() => updating_currentSource = false);
      }
      if (!updating_logItems && dirty & /*logItems*/
      4) {
        updating_logItems = true;
        actions_changes.logItems = /*logItems*/
        ctx2[2];
        add_flush_callback(() => updating_logItems = false);
      }
      if (!updating_setView && dirty & /*setView*/
      8) {
        updating_setView = true;
        actions_changes.setView = /*setView*/
        ctx2[3];
        add_flush_callback(() => updating_setView = false);
      }
      if (!updating_updating && dirty & /*updating*/
      32) {
        updating_updating = true;
        actions_changes.updating = /*updating*/
        ctx2[5];
        add_flush_callback(() => updating_updating = false);
      }
      if (!updating_appdata && dirty & /*appdata*/
      16) {
        updating_appdata = true;
        actions_changes.appdata = /*appdata*/
        ctx2[4];
        add_flush_callback(() => updating_appdata = false);
      }
      if (!updating_app && dirty & /*app*/
      1) {
        updating_app = true;
        actions_changes.app = /*app*/
        ctx2[0];
        add_flush_callback(() => updating_app = false);
      }
      actions.$set(actions_changes);
      const items_changes = {};
      if (dirty & /*app*/
      1)
        items_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*appdata*/
      16)
        items_changes.appdata = /*appdata*/
        ctx2[4];
      if (!updating_logItems_1 && dirty & /*logItems*/
      4) {
        updating_logItems_1 = true;
        items_changes.logItems = /*logItems*/
        ctx2[2];
        add_flush_callback(() => updating_logItems_1 = false);
      }
      if (!updating_updating_1 && dirty & /*updating*/
      32) {
        updating_updating_1 = true;
        items_changes.updating = /*updating*/
        ctx2[5];
        add_flush_callback(() => updating_updating_1 = false);
      }
      items.$set(items_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actions.$$.fragment, local);
      transition_in(items.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actions.$$.fragment, local);
      transition_out(items.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(actions);
      destroy_component(items);
    }
  };
}
function instance$3n($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { currentSource } = $$props;
  let { logItems } = $$props;
  let { setView } = $$props;
  let { appdata } = $$props;
  let updating = false;
  function actions_currentSource_binding(value) {
    currentSource = value;
    $$invalidate(1, currentSource);
  }
  function actions_logItems_binding(value) {
    logItems = value;
    $$invalidate(2, logItems);
  }
  function actions_setView_binding(value) {
    setView = value;
    $$invalidate(3, setView);
  }
  function actions_updating_binding(value) {
    updating = value;
    $$invalidate(5, updating);
  }
  function actions_appdata_binding(value) {
    appdata = value;
    $$invalidate(4, appdata);
  }
  function actions_app_binding(value) {
    app = value;
    $$invalidate(0, app);
  }
  function items_logItems_binding(value) {
    logItems = value;
    $$invalidate(2, logItems);
  }
  function items_updating_binding(value) {
    updating = value;
    $$invalidate(5, updating);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("currentSource" in $$props2)
      $$invalidate(1, currentSource = $$props2.currentSource);
    if ("logItems" in $$props2)
      $$invalidate(2, logItems = $$props2.logItems);
    if ("setView" in $$props2)
      $$invalidate(3, setView = $$props2.setView);
    if ("appdata" in $$props2)
      $$invalidate(4, appdata = $$props2.appdata);
  };
  return [
    app,
    currentSource,
    logItems,
    setView,
    appdata,
    updating,
    actions_currentSource_binding,
    actions_logItems_binding,
    actions_setView_binding,
    actions_updating_binding,
    actions_appdata_binding,
    actions_app_binding,
    items_logItems_binding,
    items_updating_binding
  ];
}
let Content$3 = class Content2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3n, create_fragment$3A, safe_not_equal, {
      app: 0,
      currentSource: 1,
      logItems: 2,
      setView: 3,
      appdata: 4
    });
  }
};
function create_fragment$3z(ctx) {
  let button;
  let div0;
  let t0_value = (
    /*category*/
    ctx[0][0] + ""
  );
  let t0;
  let t1;
  let div1;
  let t2_value = (
    /*category*/
    ctx[0][1].length + ""
  );
  let t2;
  let t3;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = text(" items");
      attr(div0, "class", "name");
      attr(div1, "class", "items");
      toggle_class(
        button,
        "active",
        /*category*/
        ctx[0][0] == /*currentSource*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div0);
      append(div0, t0);
      append(button, t1);
      append(button, div1);
      append(div1, t2);
      append(div1, t3);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*apply*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*category*/
      1 && t0_value !== (t0_value = /*category*/
      ctx2[0][0] + ""))
        set_data(t0, t0_value);
      if (dirty & /*category*/
      1 && t2_value !== (t2_value = /*category*/
      ctx2[0][1].length + ""))
        set_data(t2, t2_value);
      if (dirty & /*category, currentSource*/
      3) {
        toggle_class(
          button,
          "active",
          /*category*/
          ctx2[0][0] == /*currentSource*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3m($$self, $$props, $$invalidate) {
  let { category } = $$props;
  let { setView } = $$props;
  let { currentSource } = $$props;
  function apply() {
    if (!setView)
      return;
    setView(category[0]);
  }
  $$self.$$set = ($$props2) => {
    if ("category" in $$props2)
      $$invalidate(0, category = $$props2.category);
    if ("setView" in $$props2)
      $$invalidate(3, setView = $$props2.setView);
    if ("currentSource" in $$props2)
      $$invalidate(1, currentSource = $$props2.currentSource);
  };
  return [category, currentSource, apply, setView];
}
class Category extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3m, create_fragment$3z, safe_not_equal, {
      category: 0,
      setView: 3,
      currentSource: 1
    });
  }
}
function get_each_context$H(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list2[i2];
  child_ctx[7] = list2;
  child_ctx[8] = i2;
  return child_ctx;
}
function create_each_block$H(ctx) {
  let category_1;
  let updating_setView;
  let updating_category;
  let updating_currentSource;
  let current;
  function category_1_setView_binding(value) {
    ctx[3](value);
  }
  function category_1_category_binding(value) {
    ctx[4](
      value,
      /*category*/
      ctx[6],
      /*each_value*/
      ctx[7],
      /*category_index*/
      ctx[8]
    );
  }
  function category_1_currentSource_binding(value) {
    ctx[5](value);
  }
  let category_1_props = {};
  if (
    /*setView*/
    ctx[1] !== void 0
  ) {
    category_1_props.setView = /*setView*/
    ctx[1];
  }
  if (
    /*category*/
    ctx[6] !== void 0
  ) {
    category_1_props.category = /*category*/
    ctx[6];
  }
  if (
    /*currentSource*/
    ctx[2] !== void 0
  ) {
    category_1_props.currentSource = /*currentSource*/
    ctx[2];
  }
  category_1 = new Category({ props: category_1_props });
  binding_callbacks.push(() => bind$1(category_1, "setView", category_1_setView_binding));
  binding_callbacks.push(() => bind$1(category_1, "category", category_1_category_binding));
  binding_callbacks.push(() => bind$1(category_1, "currentSource", category_1_currentSource_binding));
  return {
    c() {
      create_component(category_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(category_1, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const category_1_changes = {};
      if (!updating_setView && dirty & /*setView*/
      2) {
        updating_setView = true;
        category_1_changes.setView = /*setView*/
        ctx[1];
        add_flush_callback(() => updating_setView = false);
      }
      if (!updating_category && dirty & /*logs*/
      1) {
        updating_category = true;
        category_1_changes.category = /*category*/
        ctx[6];
        add_flush_callback(() => updating_category = false);
      }
      if (!updating_currentSource && dirty & /*currentSource*/
      4) {
        updating_currentSource = true;
        category_1_changes.currentSource = /*currentSource*/
        ctx[2];
        add_flush_callback(() => updating_currentSource = false);
      }
      category_1.$set(category_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(category_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(category_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(category_1, detaching);
    }
  };
}
function create_fragment$3y(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*logs*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$H(get_each_context$H(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "sidebar");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*setView, logs, currentSource*/
      7) {
        each_value = ensure_array_like(
          /*logs*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$H(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$H(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$3l($$self, $$props, $$invalidate) {
  let { logs } = $$props;
  let { setView } = $$props;
  let { currentSource } = $$props;
  function category_1_setView_binding(value) {
    setView = value;
    $$invalidate(1, setView);
  }
  function category_1_category_binding(value, category, each_value, category_index) {
    each_value[category_index] = value;
    $$invalidate(0, logs);
  }
  function category_1_currentSource_binding(value) {
    currentSource = value;
    $$invalidate(2, currentSource);
  }
  $$self.$$set = ($$props2) => {
    if ("logs" in $$props2)
      $$invalidate(0, logs = $$props2.logs);
    if ("setView" in $$props2)
      $$invalidate(1, setView = $$props2.setView);
    if ("currentSource" in $$props2)
      $$invalidate(2, currentSource = $$props2.currentSource);
  };
  return [
    logs,
    setView,
    currentSource,
    category_1_setView_binding,
    category_1_category_binding,
    category_1_currentSource_binding
  ];
}
let Sidebar$1 = class Sidebar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3l, create_fragment$3y, safe_not_equal, { logs: 0, setView: 1, currentSource: 2 });
  }
};
function create_if_block$1m(ctx) {
  let sidebar;
  let updating_currentSource;
  let updating_logs;
  let t2;
  let content2;
  let updating_currentSource_1;
  let updating_logItems;
  let updating_appdata;
  let current;
  function sidebar_currentSource_binding(value) {
    ctx[6](value);
  }
  function sidebar_logs_binding(value) {
    ctx[7](value);
  }
  let sidebar_props = { setView: (
    /*setView*/
    ctx[5]
  ) };
  if (
    /*currentSource*/
    ctx[4] !== void 0
  ) {
    sidebar_props.currentSource = /*currentSource*/
    ctx[4];
  }
  if (
    /*logs*/
    ctx[2] !== void 0
  ) {
    sidebar_props.logs = /*logs*/
    ctx[2];
  }
  sidebar = new Sidebar$1({ props: sidebar_props });
  binding_callbacks.push(() => bind$1(sidebar, "currentSource", sidebar_currentSource_binding));
  binding_callbacks.push(() => bind$1(sidebar, "logs", sidebar_logs_binding));
  function content_currentSource_binding(value) {
    ctx[8](value);
  }
  function content_logItems_binding(value) {
    ctx[9](value);
  }
  function content_appdata_binding(value) {
    ctx[10](value);
  }
  let content_props = {
    setView: (
      /*setView*/
      ctx[5]
    ),
    app: (
      /*app*/
      ctx[1]
    )
  };
  if (
    /*currentSource*/
    ctx[4] !== void 0
  ) {
    content_props.currentSource = /*currentSource*/
    ctx[4];
  }
  if (
    /*logItems*/
    ctx[3] !== void 0
  ) {
    content_props.logItems = /*logItems*/
    ctx[3];
  }
  if (
    /*appdata*/
    ctx[0] !== void 0
  ) {
    content_props.appdata = /*appdata*/
    ctx[0];
  }
  content2 = new Content$3({ props: content_props });
  binding_callbacks.push(() => bind$1(content2, "currentSource", content_currentSource_binding));
  binding_callbacks.push(() => bind$1(content2, "logItems", content_logItems_binding));
  binding_callbacks.push(() => bind$1(content2, "appdata", content_appdata_binding));
  return {
    c() {
      create_component(sidebar.$$.fragment);
      t2 = space();
      create_component(content2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sidebar, target, anchor);
      insert(target, t2, anchor);
      mount_component(content2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sidebar_changes = {};
      if (!updating_currentSource && dirty & /*currentSource*/
      16) {
        updating_currentSource = true;
        sidebar_changes.currentSource = /*currentSource*/
        ctx2[4];
        add_flush_callback(() => updating_currentSource = false);
      }
      if (!updating_logs && dirty & /*logs*/
      4) {
        updating_logs = true;
        sidebar_changes.logs = /*logs*/
        ctx2[2];
        add_flush_callback(() => updating_logs = false);
      }
      sidebar.$set(sidebar_changes);
      const content_changes = {};
      if (dirty & /*app*/
      2)
        content_changes.app = /*app*/
        ctx2[1];
      if (!updating_currentSource_1 && dirty & /*currentSource*/
      16) {
        updating_currentSource_1 = true;
        content_changes.currentSource = /*currentSource*/
        ctx2[4];
        add_flush_callback(() => updating_currentSource_1 = false);
      }
      if (!updating_logItems && dirty & /*logItems*/
      8) {
        updating_logItems = true;
        content_changes.logItems = /*logItems*/
        ctx2[3];
        add_flush_callback(() => updating_logItems = false);
      }
      if (!updating_appdata && dirty & /*appdata*/
      1) {
        updating_appdata = true;
        content_changes.appdata = /*appdata*/
        ctx2[0];
        add_flush_callback(() => updating_appdata = false);
      }
      content2.$set(content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      transition_in(content2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      transition_out(content2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(sidebar, detaching);
      destroy_component(content2, detaching);
    }
  };
}
function create_fragment$3x(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*app*/
    ctx[1] && create_if_block$1m(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*app*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*app*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1m(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$3k($$self, $$props, $$invalidate) {
  let $LogStore;
  component_subscribe($$self, LogStore, ($$value) => $$invalidate(11, $LogStore = $$value));
  let logs = [];
  let logItems = [];
  let currentSource = "";
  let { app } = $$props;
  let { appdata } = $$props;
  function setView(source2) {
    Log("apps/Logger: setView", `Setting source to "${source2}"`);
    for (let i2 = 0; i2 < logs.length; i2++) {
      if (logs[i2][0] == source2)
        $$invalidate(3, logItems = logs[i2][1]);
    }
    if (!logItems.length) {
      Log("apps/Logger: setView", `Source "${source2}" contains no items or could not be found.`, LogLevel.info);
    }
    $$invalidate(4, currentSource = source2);
  }
  LogStore.subscribe(() => {
    $$invalidate(2, logs = Object.entries(collectLogsBySource()));
    setTitleSuffix(` - ${$LogStore.length} items`, app.id);
  });
  function sidebar_currentSource_binding(value) {
    currentSource = value;
    $$invalidate(4, currentSource);
  }
  function sidebar_logs_binding(value) {
    logs = value;
    $$invalidate(2, logs);
  }
  function content_currentSource_binding(value) {
    currentSource = value;
    $$invalidate(4, currentSource);
  }
  function content_logItems_binding(value) {
    logItems = value;
    $$invalidate(3, logItems);
  }
  function content_appdata_binding(value) {
    appdata = value;
    $$invalidate(0, appdata);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
    if ("appdata" in $$props2)
      $$invalidate(0, appdata = $$props2.appdata);
  };
  return [
    appdata,
    app,
    logs,
    logItems,
    currentSource,
    setView,
    sidebar_currentSource_binding,
    sidebar_logs_binding,
    content_currentSource_binding,
    content_logItems_binding,
    content_appdata_binding
  ];
}
class Logger extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3k, create_fragment$3x, safe_not_equal, { app: 1, appdata: 0 });
  }
}
const LoggerApp = {
  info: {
    name: "System Logger",
    description: "All the ArcOS logs in one place",
    builtin: true,
    version: "1.0.0",
    author: "ArcOS Team",
    icon: LoggerIcon,
    appGroup: "systemTools"
  },
  size: { w: 900, h: 600 },
  pos: { x: 30, y: 40 },
  minSize: { w: 900, h: 600 },
  maxSize: { w: 901, h: 601 },
  controls: { min: true, max: true, cls: true },
  state: {
    headless: false,
    resizable: false,
    windowState: { min: false, max: false, fll: false }
  },
  content: Logger,
  glass: true
};
function supressWarnings() {
  const origWarn = console.warn;
  console.warn = (message) => {
    if (message.includes("unknown prop"))
      return;
    if (message.includes("unexpected slot"))
      return;
    origWarn(message);
  };
  onMount(() => {
    console.warn = origWarn;
  });
}
function get_each_context_5(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list2[i2];
  return child_ctx;
}
function get_each_context_4(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list2[i2];
  return child_ctx;
}
function get_each_context_1$a(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list2[i2];
  return child_ctx;
}
function get_each_context_2$1(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list2[i2];
  child_ctx[15] = i2;
  return child_ctx;
}
function get_each_context_3(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list2[i2];
  child_ctx[15] = i2;
  return child_ctx;
}
function get_each_context$G(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list2[i2];
  return child_ctx;
}
function create_if_block_1$n(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2$8, create_if_block_3$3, create_else_block_1$3];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*type*/
      ctx2[0] === "table"
    )
      return 0;
    if (
      /*type*/
      ctx2[0] === "list"
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block$1l(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*tokens*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$G(get_each_context$G(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*tokens, renderers*/
      34) {
        each_value = ensure_array_like(
          /*tokens*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$G(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$G(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block_1$3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*$$restProps*/
    ctx[6]
  ];
  var switch_value = (
    /*renderers*/
    ctx[5][
      /*type*/
      ctx[0]
    ]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx: ctx2 }
    };
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty & /*$$restProps*/
    64) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[6]
      )]));
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers, type*/
      33 && switch_value !== (switch_value = /*renderers*/
      ctx2[5][
        /*type*/
        ctx2[0]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*$$restProps*/
        64 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )]) : {};
        if (dirty & /*$$scope, tokens, renderers, $$restProps*/
        8388706) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_3$3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4$2, create_else_block$s];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*ordered*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_2$8(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].table
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot$a] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].table)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$scope, renderers, rows, $$restProps, header*/
        8388716) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_else_block_2(ctx) {
  let t_value = (
    /*$$restProps*/
    ctx[6].raw + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$$restProps*/
      64 && t_value !== (t_value = /*$$restProps*/
      ctx2[6].raw + ""))
        set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_5$2(ctx) {
  let parser;
  let current;
  parser = new Parser$1({
    props: {
      tokens: (
        /*tokens*/
        ctx[1]
      ),
      renderers: (
        /*renderers*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      create_component(parser.$$.fragment);
    },
    m(target, anchor) {
      mount_component(parser, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const parser_changes = {};
      if (dirty & /*tokens*/
      2)
        parser_changes.tokens = /*tokens*/
        ctx2[1];
      if (dirty & /*renderers*/
      32)
        parser_changes.renderers = /*renderers*/
        ctx2[5];
      parser.$set(parser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(parser, detaching);
    }
  };
}
function create_default_slot_11(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_5$2, create_else_block_2];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*tokens*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_3(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$s(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { ordered: (
      /*ordered*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  var switch_value = (
    /*renderers*/
    ctx[5].list
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_9$1] },
      $$scope: { ctx: ctx2 }
    };
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty & /*ordered, $$restProps*/
    80) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty & /*ordered*/
        16 && { ordered: (
          /*ordered*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].list)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*ordered, $$restProps*/
        80 ? get_spread_update(switch_instance_spread_levels, [
          dirty & /*ordered*/
          16 && { ordered: (
            /*ordered*/
            ctx2[4]
          ) },
          dirty & /*$$restProps*/
          64 && get_spread_object(
            /*$$restProps*/
            ctx2[6]
          )
        ]) : {};
        if (dirty & /*$$scope, $$restProps, renderers*/
        8388704) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_4$2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { ordered: (
      /*ordered*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  var switch_value = (
    /*renderers*/
    ctx[5].list
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_7$1] },
      $$scope: { ctx: ctx2 }
    };
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty & /*ordered, $$restProps*/
    80) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty & /*ordered*/
        16 && { ordered: (
          /*ordered*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].list)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*ordered, $$restProps*/
        80 ? get_spread_update(switch_instance_spread_levels, [
          dirty & /*ordered*/
          16 && { ordered: (
            /*ordered*/
            ctx2[4]
          ) },
          dirty & /*$$restProps*/
          64 && get_spread_object(
            /*$$restProps*/
            ctx2[6]
          )
        ]) : {};
        if (dirty & /*$$scope, $$restProps, renderers*/
        8388704) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_10(ctx) {
  let parser;
  let t2;
  let current;
  parser = new Parser$1({
    props: {
      tokens: (
        /*item*/
        ctx[18].tokens
      ),
      renderers: (
        /*renderers*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      create_component(parser.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(parser, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const parser_changes = {};
      if (dirty & /*$$restProps*/
      64)
        parser_changes.tokens = /*item*/
        ctx2[18].tokens;
      if (dirty & /*renderers*/
      32)
        parser_changes.renderers = /*renderers*/
        ctx2[5];
      parser.$set(parser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(parser, detaching);
    }
  };
}
function create_each_block_5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*item*/
    ctx[18]
  ];
  var switch_value = (
    /*renderers*/
    ctx[5].unorderedlistitem || /*renderers*/
    ctx[5].listitem
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx: ctx2 }
    };
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty & /*$$restProps*/
    64) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*item*/
        ctx2[18]
      )]));
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].unorderedlistitem || /*renderers*/
      ctx2[5].listitem)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*$$restProps*/
        64 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*item*/
          ctx2[18]
        )]) : {};
        if (dirty & /*$$scope, $$restProps, renderers*/
        8388704) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_9$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_5 = ensure_array_like(
    /*$$restProps*/
    ctx[6].items
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_5.length; i2 += 1) {
    each_blocks[i2] = create_each_block_5(get_each_context_5(ctx, each_value_5, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers, $$restProps*/
      96) {
        each_value_5 = ensure_array_like(
          /*$$restProps*/
          ctx2[6].items
        );
        let i2;
        for (i2 = 0; i2 < each_value_5.length; i2 += 1) {
          const child_ctx = get_each_context_5(ctx2, each_value_5, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_5.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_5.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_8$1(ctx) {
  let parser;
  let t2;
  let current;
  parser = new Parser$1({
    props: {
      tokens: (
        /*item*/
        ctx[18].tokens
      ),
      renderers: (
        /*renderers*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      create_component(parser.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(parser, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const parser_changes = {};
      if (dirty & /*$$restProps*/
      64)
        parser_changes.tokens = /*item*/
        ctx2[18].tokens;
      if (dirty & /*renderers*/
      32)
        parser_changes.renderers = /*renderers*/
        ctx2[5];
      parser.$set(parser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(parser, detaching);
    }
  };
}
function create_each_block_4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*item*/
    ctx[18]
  ];
  var switch_value = (
    /*renderers*/
    ctx[5].orderedlistitem || /*renderers*/
    ctx[5].listitem
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_8$1] },
      $$scope: { ctx: ctx2 }
    };
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty & /*$$restProps*/
    64) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*item*/
        ctx2[18]
      )]));
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].orderedlistitem || /*renderers*/
      ctx2[5].listitem)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*$$restProps*/
        64 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*item*/
          ctx2[18]
        )]) : {};
        if (dirty & /*$$scope, $$restProps, renderers*/
        8388704) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_7$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_4 = ensure_array_like(
    /*$$restProps*/
    ctx[6].items
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
    each_blocks[i2] = create_each_block_4(get_each_context_4(ctx, each_value_4, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers, $$restProps*/
      96) {
        each_value_4 = ensure_array_like(
          /*$$restProps*/
          ctx2[6].items
        );
        let i2;
        for (i2 = 0; i2 < each_value_4.length; i2 += 1) {
          const child_ctx = get_each_context_4(ctx2, each_value_4, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_4(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_4.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_6$1(ctx) {
  let parser;
  let t2;
  let current;
  parser = new Parser$1({
    props: {
      tokens: (
        /*headerItem*/
        ctx[16].tokens
      ),
      renderers: (
        /*renderers*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      create_component(parser.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(parser, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const parser_changes = {};
      if (dirty & /*header*/
      4)
        parser_changes.tokens = /*headerItem*/
        ctx2[16].tokens;
      if (dirty & /*renderers*/
      32)
        parser_changes.renderers = /*renderers*/
        ctx2[5];
      parser.$set(parser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(parser, detaching);
    }
  };
}
function create_each_block_3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].tablecell
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        header: true,
        align: (
          /*$$restProps*/
          ctx2[6].align[
            /*i*/
            ctx2[15]
          ] || "center"
        ),
        $$slots: { default: [create_default_slot_6$1] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].tablecell)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$restProps*/
        64)
          switch_instance_changes.align = /*$$restProps*/
          ctx2[6].align[
            /*i*/
            ctx2[15]
          ] || "center";
        if (dirty & /*$$scope, header, renderers*/
        8388644) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_5$2(ctx) {
  let each_1_anchor;
  let current;
  let each_value_3 = ensure_array_like(
    /*header*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    each_blocks[i2] = create_each_block_3(get_each_context_3(ctx, each_value_3, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers, $$restProps, header*/
      100) {
        each_value_3 = ensure_array_like(
          /*header*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value_3.length; i2 += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_3.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_4$3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].tablerow
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot_5$2] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].tablerow)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$scope, header, renderers, $$restProps*/
        8388708) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_3$3(ctx) {
  let parser;
  let current;
  parser = new Parser$1({
    props: {
      tokens: (
        /*cells*/
        ctx[13].tokens
      ),
      renderers: (
        /*renderers*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      create_component(parser.$$.fragment);
    },
    m(target, anchor) {
      mount_component(parser, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const parser_changes = {};
      if (dirty & /*rows*/
      8)
        parser_changes.tokens = /*cells*/
        ctx2[13].tokens;
      if (dirty & /*renderers*/
      32)
        parser_changes.renderers = /*renderers*/
        ctx2[5];
      parser.$set(parser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(parser, detaching);
    }
  };
}
function create_each_block_2$1(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].tablecell
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        header: false,
        align: (
          /*$$restProps*/
          ctx2[6].align[
            /*i*/
            ctx2[15]
          ] || "center"
        ),
        $$slots: { default: [create_default_slot_3$3] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].tablecell)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$restProps*/
        64)
          switch_instance_changes.align = /*$$restProps*/
          ctx2[6].align[
            /*i*/
            ctx2[15]
          ] || "center";
        if (dirty & /*$$scope, rows, renderers*/
        8388648) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_2$5(ctx) {
  let t2;
  let current;
  let each_value_2 = ensure_array_like(
    /*row*/
    ctx[10]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers, $$restProps, rows*/
      104) {
        each_value_2 = ensure_array_like(
          /*row*/
          ctx2[10]
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$1(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2$1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t2.parentNode, t2);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1$a(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].tablerow
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot_2$5] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].tablerow)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$scope, rows, renderers, $$restProps*/
        8388712) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_1$6(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*rows*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$a(get_each_context_1$a(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers, rows, $$restProps*/
      104) {
        each_value_1 = ensure_array_like(
          /*rows*/
          ctx2[3]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$a(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$a(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot$a(ctx) {
  let switch_instance0;
  let t2;
  let switch_instance1;
  let switch_instance1_anchor;
  let current;
  var switch_value = (
    /*renderers*/
    ctx[5].tablehead
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot_4$3] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx));
  }
  var switch_value_1 = (
    /*renderers*/
    ctx[5].tablebody
  );
  function switch_props_1(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot_1$6] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx));
  }
  return {
    c() {
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t2 = space();
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      switch_instance1_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance0)
        mount_component(switch_instance0, target, anchor);
      insert(target, t2, anchor);
      if (switch_instance1)
        mount_component(switch_instance1, target, anchor);
      insert(target, switch_instance1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*renderers*/
      32 && switch_value !== (switch_value = /*renderers*/
      ctx2[5].tablehead)) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, t2.parentNode, t2);
        } else {
          switch_instance0 = null;
        }
      } else if (switch_value) {
        const switch_instance0_changes = {};
        if (dirty & /*$$scope, renderers, header, $$restProps*/
        8388708) {
          switch_instance0_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance0.$set(switch_instance0_changes);
      }
      if (dirty & /*renderers*/
      32 && switch_value_1 !== (switch_value_1 = /*renderers*/
      ctx2[5].tablebody)) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx2));
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, switch_instance1_anchor.parentNode, switch_instance1_anchor);
        } else {
          switch_instance1 = null;
        }
      } else if (switch_value_1) {
        const switch_instance1_changes = {};
        if (dirty & /*$$scope, rows, renderers, $$restProps*/
        8388712) {
          switch_instance1_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance1.$set(switch_instance1_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(switch_instance1_anchor);
      }
      if (switch_instance0)
        destroy_component(switch_instance0, detaching);
      if (switch_instance1)
        destroy_component(switch_instance1, detaching);
    }
  };
}
function create_each_block$G(ctx) {
  let parser;
  let current;
  const parser_spread_levels = [
    /*token*/
    ctx[7],
    { renderers: (
      /*renderers*/
      ctx[5]
    ) }
  ];
  let parser_props = {};
  for (let i2 = 0; i2 < parser_spread_levels.length; i2 += 1) {
    parser_props = assign(parser_props, parser_spread_levels[i2]);
  }
  parser = new Parser$1({ props: parser_props });
  return {
    c() {
      create_component(parser.$$.fragment);
    },
    m(target, anchor) {
      mount_component(parser, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const parser_changes = dirty & /*tokens, renderers*/
      34 ? get_spread_update(parser_spread_levels, [
        dirty & /*tokens*/
        2 && get_spread_object(
          /*token*/
          ctx2[7]
        ),
        dirty & /*renderers*/
        32 && { renderers: (
          /*renderers*/
          ctx2[5]
        ) }
      ]) : {};
      parser.$set(parser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(parser, detaching);
    }
  };
}
function create_fragment$3w(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1l, create_if_block_1$n];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*type*/
    ctx2[0])
      return 0;
    if (
      /*renderers*/
      ctx2[5][
        /*type*/
        ctx2[0]
      ]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function instance$3j($$self, $$props, $$invalidate) {
  const omit_props_names = ["type", "tokens", "header", "rows", "ordered", "renderers"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { type = void 0 } = $$props;
  let { tokens = void 0 } = $$props;
  let { header: header2 = void 0 } = $$props;
  let { rows = void 0 } = $$props;
  let { ordered = false } = $$props;
  let { renderers } = $$props;
  supressWarnings();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props)
      $$invalidate(0, type = $$new_props.type);
    if ("tokens" in $$new_props)
      $$invalidate(1, tokens = $$new_props.tokens);
    if ("header" in $$new_props)
      $$invalidate(2, header2 = $$new_props.header);
    if ("rows" in $$new_props)
      $$invalidate(3, rows = $$new_props.rows);
    if ("ordered" in $$new_props)
      $$invalidate(4, ordered = $$new_props.ordered);
    if ("renderers" in $$new_props)
      $$invalidate(5, renderers = $$new_props.renderers);
  };
  return [type, tokens, header2, rows, ordered, renderers, $$restProps];
}
let Parser$1 = class Parser extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3j, create_fragment$3w, safe_not_equal, {
      type: 0,
      tokens: 1,
      header: 2,
      rows: 3,
      ordered: 4,
      renderers: 5
    });
  }
};
function getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    hooks: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
let defaults = getDefaults();
function changeDefaults(newDefaults) {
  defaults = newDefaults;
}
const escapeTest = /[&<>"']/;
const escapeReplace = new RegExp(escapeTest.source, "g");
const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
const escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html, encode2) {
  if (encode2) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape$1(html) {
  return html.replace(unescapeTest, (_2, n2) => {
    n2 = n2.toLowerCase();
    if (n2 === "colon")
      return ":";
    if (n2.charAt(0) === "#") {
      return n2.charAt(1) === "x" ? String.fromCharCode(parseInt(n2.substring(2), 16)) : String.fromCharCode(+n2.substring(1));
    }
    return "";
  });
}
const caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
const nonWordAndColonTest = /[^\w:]/g;
const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape$1(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e2) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e2) {
    return null;
  }
  return href;
}
const baseUrls = {};
const justDomain = /^[^:]+:\/*[^/]*$/;
const protocol = /^([^:]+:)[\s\S]*$/;
const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, "$1") + href;
  } else {
    return base + href;
  }
}
const noopTest = { exec: function noopTest2() {
} };
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false, curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i2 = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count)
      cells.push("");
  }
  for (; i2 < cells.length; i2++) {
    cells[i2] = cells[i2].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c2, invert) {
  const l2 = str.length;
  if (l2 === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l2) {
    const currChar = str.charAt(l2 - suffLen - 1);
    if (currChar === c2 && !invert) {
      suffLen++;
    } else if (currChar !== c2 && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l2 - suffLen);
}
function findClosingBracket(str, b2) {
  if (str.indexOf(b2[1]) === -1) {
    return -1;
  }
  const l2 = str.length;
  let level = 0, i2 = 0;
  for (; i2 < l2; i2++) {
    if (str[i2] === "\\") {
      i2++;
    } else if (str[i2] === b2[0]) {
      level++;
    } else if (str[i2] === b2[1]) {
      level--;
      if (level < 0) {
        return i2;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
}
function repeatString(pattern, count) {
  if (count < 1) {
    return "";
  }
  let result = "";
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer) {
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text2 = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text: text2,
      tokens: lexer.inlineTokens(text2)
    };
    lexer.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape(text2)
  };
}
function indentCodeCompensation(raw, text2) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text2;
  }
  const indentToCode = matchIndentToCode[1];
  return text2.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
class Tokenizer {
  constructor(options) {
    this.options = options || defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text2 = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text2, "\n") : text2
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text2 = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
        text: text2
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text2 = cap[2].trim();
      if (/#$/.test(text2)) {
        const trimmed = rtrim(text2, "#");
        if (this.options.pedantic) {
          text2 = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text2 = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text2 = cap[0].replace(/^ *>[ \t]?/gm, "");
      const top = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text2);
      this.lexer.state.top = top;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text: text2
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw, istask, ischecked, indent, i2, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list2 = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t2) => " ".repeat(3 * t2.length));
        nextLine = src.split("\n", 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list2.loose) {
          if (endsWithBlankLine) {
            list2.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list2.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list2.raw += raw;
      }
      list2.items[list2.items.length - 1].raw = raw.trimRight();
      list2.items[list2.items.length - 1].text = itemContents.trimRight();
      list2.raw = list2.raw.trimRight();
      const l2 = list2.items.length;
      for (i2 = 0; i2 < l2; i2++) {
        this.lexer.state.top = false;
        list2.items[i2].tokens = this.lexer.blockTokens(list2.items[i2].text, []);
        if (!list2.loose) {
          const spacers = list2.items[i2].tokens.filter((t2) => t2.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t2) => /\n.*\n/.test(t2.raw));
          list2.loose = hasMultipleLineBreaks;
        }
      }
      if (list2.loose) {
        for (i2 = 0; i2 < l2; i2++) {
          list2.items[i2].loose = true;
        }
      }
      return list2;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      };
      if (this.options.sanitize) {
        const text2 = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        token.type = "paragraph";
        token.text = text2;
        token.tokens = this.lexer.inline(text2);
      }
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
      return {
        type: "def",
        tag,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: "table",
        header: splitCells(cap[1]).map((c2) => {
          return { text: c2 };
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        let l2 = item.align.length;
        let i2, j2, k2, row;
        for (i2 = 0; i2 < l2; i2++) {
          if (/^ *-+: *$/.test(item.align[i2])) {
            item.align[i2] = "right";
          } else if (/^ *:-+: *$/.test(item.align[i2])) {
            item.align[i2] = "center";
          } else if (/^ *:-+ *$/.test(item.align[i2])) {
            item.align[i2] = "left";
          } else {
            item.align[i2] = null;
          }
        }
        l2 = item.rows.length;
        for (i2 = 0; i2 < l2; i2++) {
          item.rows[i2] = splitCells(item.rows[i2], item.header.length).map((c2) => {
            return { text: c2 };
          });
        }
        l2 = item.header.length;
        for (j2 = 0; j2 < l2; j2++) {
          item.header[j2].tokens = this.lexer.inline(item.header[j2].text);
        }
        l2 = item.rows.length;
        for (j2 = 0; j2 < l2; j2++) {
          row = item.rows[j2];
          for (k2 = 0; k2 < row.length; k2++) {
            row[k2].tokens = this.lexer.inline(row[k2].text);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text2 = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links[link.toLowerCase()];
      if (!link) {
        const text2 = cap[0].charAt(0);
        return {
          type: "text",
          raw: text2,
          text: text2
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = rDelim.length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text3 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text3,
            tokens: this.lexer.inlineTokens(text3)
          };
        }
        const text2 = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text: text2,
          tokens: this.lexer.inlineTokens(text2)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text2 = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text2);
      const hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text2 = text2.substring(1, text2.length - 1);
      }
      text2 = escape(text2, true);
      return {
        type: "codespan",
        raw: cap[0],
        text: text2
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
        href = "mailto:" + text2;
      } else {
        text2 = escape(cap[1]);
        href = text2;
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [
          {
            type: "text",
            raw: text2,
            text: text2
          }
        ]
      };
    }
  }
  url(src, mangle2) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
        href = "mailto:" + text2;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text2 = escape(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [
          {
            type: "text",
            raw: text2,
            text: text2
          }
        ]
      };
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text2;
      if (this.lexer.state.inRawBlock) {
        text2 = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
      } else {
        text2 = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text: text2
      };
    }
  }
}
const block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = { ...block };
block.gfm = {
  ...block.normal,
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
};
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = {
  ...block.normal,
  html: edit(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
};
const inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = { ...inline };
inline.pedantic = {
  ...inline.normal,
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
};
inline.gfm = {
  ...inline.normal,
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = {
  ...inline.gfm,
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
function smartypants(text2) {
  return text2.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…");
}
function mangle(text2) {
  let out = "", i2, ch;
  const l2 = text2.length;
  for (i2 = 0; i2 < l2; i2++) {
    ch = text2.charCodeAt(i2);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
class Lexer {
  constructor(options) {
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options || defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options) {
    const lexer = new Lexer(options);
    return lexer.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options) {
    const lexer = new Lexer(options);
    return lexer.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  /**
   * Lexing
   */
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_2, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
}
class Renderer {
  constructor(options) {
    this.options = options || defaults;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  /**
   * @param {string} quote
   */
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`;
  }
  html(html) {
    return html;
  }
  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */
  heading(text2, level, raw, slugger) {
    if (this.options.headerIds) {
      const id = this.options.headerPrefix + slugger.slug(raw);
      return `<h${level} id="${id}">${text2}</h${level}>
`;
    }
    return `<h${level}>${text2}</h${level}>
`;
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  }
  list(body, ordered, start) {
    const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  /**
   * @param {string} text
   */
  listitem(text2) {
    return `<li>${text2}</li>
`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  /**
   * @param {string} text
   */
  paragraph(text2) {
    return `<p>${text2}</p>
`;
  }
  /**
   * @param {string} header
   * @param {string} body
   */
  table(header2, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header2 + "</thead>\n" + body + "</table>\n";
  }
  /**
   * @param {string} content
   */
  tablerow(content2) {
    return `<tr>
${content2}</tr>
`;
  }
  tablecell(content2, flags) {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag + content2 + `</${type}>
`;
  }
  /**
   * span level renderer
   * @param {string} text
   */
  strong(text2) {
    return `<strong>${text2}</strong>`;
  }
  /**
   * @param {string} text
   */
  em(text2) {
    return `<em>${text2}</em>`;
  }
  /**
   * @param {string} text
   */
  codespan(text2) {
    return `<code>${text2}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  /**
   * @param {string} text
   */
  del(text2) {
    return `<del>${text2}</del>`;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  link(href, title, text2) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text2;
    }
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text2 + "</a>";
    return out;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  image(href, title, text2) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text2;
    }
    let out = `<img src="${href}" alt="${text2}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  }
  text(text2) {
    return text2;
  }
}
class TextRenderer {
  // no need for block level renderers
  strong(text2) {
    return text2;
  }
  em(text2) {
    return text2;
  }
  codespan(text2) {
    return text2;
  }
  del(text2) {
    return text2;
  }
  html(text2) {
    return text2;
  }
  text(text2) {
    return text2;
  }
  link(href, title, text2) {
    return "" + text2;
  }
  image(href, title, text2) {
    return "" + text2;
  }
  br() {
    return "";
  }
}
class Slugger {
  constructor() {
    this.seen = {};
  }
  /**
   * @param {string} value
   */
  serialize(value) {
    return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + "-" + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }
  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(value, options = {}) {
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options.dryrun);
  }
}
class Parser2 {
  constructor(options) {
    this.options = options || defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options) {
    const parser = new Parser2(options);
    return parser.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options) {
    const parser = new Parser2(options);
    return parser.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out = "", i2, j2, k2, l2, l3, row, cell, header2, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
    const l4 = tokens.length;
    for (i2 = 0; i2 < l4; i2++) {
      token = tokens[i2];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          out += this.renderer.heading(
            this.parseInline(token.tokens),
            token.depth,
            unescape$1(this.parseInline(token.tokens, this.textRenderer)),
            this.slugger
          );
          continue;
        }
        case "code": {
          out += this.renderer.code(
            token.text,
            token.lang,
            token.escaped
          );
          continue;
        }
        case "table": {
          header2 = "";
          cell = "";
          l2 = token.header.length;
          for (j2 = 0; j2 < l2; j2++) {
            cell += this.renderer.tablecell(
              this.parseInline(token.header[j2].tokens),
              { header: true, align: token.align[j2] }
            );
          }
          header2 += this.renderer.tablerow(cell);
          body = "";
          l2 = token.rows.length;
          for (j2 = 0; j2 < l2; j2++) {
            row = token.rows[j2];
            cell = "";
            l3 = row.length;
            for (k2 = 0; k2 < l3; k2++) {
              cell += this.renderer.tablecell(
                this.parseInline(row[k2].tokens),
                { header: false, align: token.align[k2] }
              );
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header2, body);
          continue;
        }
        case "blockquote": {
          body = this.parse(token.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          ordered = token.ordered;
          start = token.start;
          loose = token.loose;
          l2 = token.items.length;
          body = "";
          for (j2 = 0; j2 < l2; j2++) {
            item = token.items[j2];
            checked = item.checked;
            task = item.task;
            itemBody = "";
            if (item.task) {
              checkbox = this.renderer.checkbox(checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          out += this.renderer.html(token.text);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
        }
        case "text": {
          body = token.tokens ? this.parseInline(token.tokens) : token.text;
          while (i2 + 1 < l4 && tokens[i2 + 1].type === "text") {
            token = tokens[++i2];
            body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "", i2, token, ret;
    const l2 = tokens.length;
    for (i2 = 0; i2 < l2; i2++) {
      token = tokens[i2];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          out += renderer.text(token.text);
          break;
        }
        case "html": {
          out += renderer.html(token.text);
          break;
        }
        case "link": {
          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
          break;
        }
        case "image": {
          out += renderer.image(token.href, token.title, token.text);
          break;
        }
        case "strong": {
          out += renderer.strong(this.parseInline(token.tokens, renderer));
          break;
        }
        case "em": {
          out += renderer.em(this.parseInline(token.tokens, renderer));
          break;
        }
        case "codespan": {
          out += renderer.codespan(token.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          out += renderer.del(this.parseInline(token.tokens, renderer));
          break;
        }
        case "text": {
          out += renderer.text(token.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
}
class Hooks {
  constructor(options) {
    this.options = options || defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html) {
    return html;
  }
}
__publicField(Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess"
]));
function onError(silent, async, callback) {
  return (e2) => {
    e2.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (silent) {
      const msg = "<p>An error occurred:</p><pre>" + escape(e2.message + "", true) + "</pre>";
      if (async) {
        return Promise.resolve(msg);
      }
      if (callback) {
        callback(null, msg);
        return;
      }
      return msg;
    }
    if (async) {
      return Promise.reject(e2);
    }
    if (callback) {
      callback(e2);
      return;
    }
    throw e2;
  };
}
function parseMarkdown(lexer, parser) {
  return (src, opt, callback) => {
    if (typeof opt === "function") {
      callback = opt;
      opt = null;
    }
    const origOpt = { ...opt };
    opt = { ...marked.defaults, ...origOpt };
    const throwError = onError(opt.silent, opt.async, callback);
    if (typeof src === "undefined" || src === null) {
      return throwError(new Error("marked(): input parameter is undefined or null"));
    }
    if (typeof src !== "string") {
      return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
    }
    checkSanitizeDeprecation(opt);
    if (opt.hooks) {
      opt.hooks.options = opt;
    }
    if (callback) {
      const highlight = opt.highlight;
      let tokens;
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        tokens = lexer(src, opt);
      } catch (e2) {
        return throwError(e2);
      }
      const done = function(err2) {
        let out;
        if (!err2) {
          try {
            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens);
            }
            out = parser(tokens, opt);
            if (opt.hooks) {
              out = opt.hooks.postprocess(out);
            }
          } catch (e2) {
            err2 = e2;
          }
        }
        opt.highlight = highlight;
        return err2 ? throwError(err2) : callback(null, out);
      };
      if (!highlight || highlight.length < 3) {
        return done();
      }
      delete opt.highlight;
      if (!tokens.length)
        return done();
      let pending = 0;
      marked.walkTokens(tokens, function(token) {
        if (token.type === "code") {
          pending++;
          setTimeout(() => {
            highlight(token.text, token.lang, function(err2, code) {
              if (err2) {
                return done(err2);
              }
              if (code != null && code !== token.text) {
                token.text = code;
                token.escaped = true;
              }
              pending--;
              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });
      if (pending === 0) {
        done();
      }
      return;
    }
    if (opt.async) {
      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser(tokens, opt)).then((html) => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);
    }
    try {
      if (opt.hooks) {
        src = opt.hooks.preprocess(src);
      }
      const tokens = lexer(src, opt);
      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens);
      }
      let html = parser(tokens, opt);
      if (opt.hooks) {
        html = opt.hooks.postprocess(html);
      }
      return html;
    } catch (e2) {
      return throwError(e2);
    }
  };
}
function marked(src, opt, callback) {
  return parseMarkdown(Lexer.lex, Parser2.parse)(src, opt, callback);
}
marked.options = marked.setOptions = function(opt) {
  marked.defaults = { ...marked.defaults, ...opt };
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults;
marked.use = function(...args) {
  const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
  args.forEach((pack) => {
    const opts = { ...pack };
    opts.async = marked.defaults.async || opts.async || false;
    if (pack.extensions) {
      pack.extensions.forEach((ext) => {
        if (!ext.name) {
          throw new Error("extension name required");
        }
        if (ext.renderer) {
          const prevRenderer = extensions.renderers[ext.name];
          if (prevRenderer) {
            extensions.renderers[ext.name] = function(...args2) {
              let ret = ext.renderer.apply(this, args2);
              if (ret === false) {
                ret = prevRenderer.apply(this, args2);
              }
              return ret;
            };
          } else {
            extensions.renderers[ext.name] = ext.renderer;
          }
        }
        if (ext.tokenizer) {
          if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions[ext.level]) {
            extensions[ext.level].unshift(ext.tokenizer);
          } else {
            extensions[ext.level] = [ext.tokenizer];
          }
          if (ext.start) {
            if (ext.level === "block") {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext.start);
              } else {
                extensions.startBlock = [ext.start];
              }
            } else if (ext.level === "inline") {
              if (extensions.startInline) {
                extensions.startInline.push(ext.start);
              } else {
                extensions.startInline = [ext.start];
              }
            }
          }
        }
        if (ext.childTokens) {
          extensions.childTokens[ext.name] = ext.childTokens;
        }
      });
      opts.extensions = extensions;
    }
    if (pack.renderer) {
      const renderer = marked.defaults.renderer || new Renderer();
      for (const prop in pack.renderer) {
        const prevRenderer = renderer[prop];
        renderer[prop] = (...args2) => {
          let ret = pack.renderer[prop].apply(renderer, args2);
          if (ret === false) {
            ret = prevRenderer.apply(renderer, args2);
          }
          return ret;
        };
      }
      opts.renderer = renderer;
    }
    if (pack.tokenizer) {
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) {
        const prevTokenizer = tokenizer[prop];
        tokenizer[prop] = (...args2) => {
          let ret = pack.tokenizer[prop].apply(tokenizer, args2);
          if (ret === false) {
            ret = prevTokenizer.apply(tokenizer, args2);
          }
          return ret;
        };
      }
      opts.tokenizer = tokenizer;
    }
    if (pack.hooks) {
      const hooks = marked.defaults.hooks || new Hooks();
      for (const prop in pack.hooks) {
        const prevHook = hooks[prop];
        if (Hooks.passThroughHooks.has(prop)) {
          hooks[prop] = (arg) => {
            if (marked.defaults.async) {
              return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then((ret2) => {
                return prevHook.call(hooks, ret2);
              });
            }
            const ret = pack.hooks[prop].call(hooks, arg);
            return prevHook.call(hooks, ret);
          };
        } else {
          hooks[prop] = (...args2) => {
            let ret = pack.hooks[prop].apply(hooks, args2);
            if (ret === false) {
              ret = prevHook.apply(hooks, args2);
            }
            return ret;
          };
        }
      }
      opts.hooks = hooks;
    }
    if (pack.walkTokens) {
      const walkTokens = marked.defaults.walkTokens;
      opts.walkTokens = function(token) {
        let values2 = [];
        values2.push(pack.walkTokens.call(this, token));
        if (walkTokens) {
          values2 = values2.concat(walkTokens.call(this, token));
        }
        return values2;
      };
    }
    marked.setOptions(opts);
  });
};
marked.walkTokens = function(tokens, callback) {
  let values2 = [];
  for (const token of tokens) {
    values2 = values2.concat(callback.call(marked, token));
    switch (token.type) {
      case "table": {
        for (const cell of token.header) {
          values2 = values2.concat(marked.walkTokens(cell.tokens, callback));
        }
        for (const row of token.rows) {
          for (const cell of row) {
            values2 = values2.concat(marked.walkTokens(cell.tokens, callback));
          }
        }
        break;
      }
      case "list": {
        values2 = values2.concat(marked.walkTokens(token.items, callback));
        break;
      }
      default: {
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
            values2 = values2.concat(marked.walkTokens(token[childTokens], callback));
          });
        } else if (token.tokens) {
          values2 = values2.concat(marked.walkTokens(token.tokens, callback));
        }
      }
    }
  }
  return values2;
};
marked.parseInline = parseMarkdown(Lexer.lexInline, Parser2.parseInline);
marked.Parser = Parser2;
marked.parser = Parser2.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.Hooks = Hooks;
marked.parse = marked;
marked.options;
marked.setOptions;
marked.use;
marked.walkTokens;
marked.parseInline;
Parser2.parse;
Lexer.lex;
const key = {};
function create_else_block$r(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*raw*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*raw*/
      2)
        set_data(
          t2,
          /*raw*/
          ctx2[1]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_5$1(ctx) {
  let h6;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      h6 = element("h6");
      if (default_slot)
        default_slot.c();
      attr(
        h6,
        "id",
        /*id*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, h6, anchor);
      if (default_slot) {
        default_slot.m(h6, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr(
          h6,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h6);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block_4$1(ctx) {
  let h5;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      h5 = element("h5");
      if (default_slot)
        default_slot.c();
      attr(
        h5,
        "id",
        /*id*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, h5, anchor);
      if (default_slot) {
        default_slot.m(h5, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr(
          h5,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h5);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block_3$2(ctx) {
  let h4;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      h4 = element("h4");
      if (default_slot)
        default_slot.c();
      attr(
        h4,
        "id",
        /*id*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, h4, anchor);
      if (default_slot) {
        default_slot.m(h4, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr(
          h4,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h4);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block_2$7(ctx) {
  let h3;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      h3 = element("h3");
      if (default_slot)
        default_slot.c();
      attr(
        h3,
        "id",
        /*id*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      if (default_slot) {
        default_slot.m(h3, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr(
          h3,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block_1$m(ctx) {
  let h2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      h2 = element("h2");
      if (default_slot)
        default_slot.c();
      attr(
        h2,
        "id",
        /*id*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      if (default_slot) {
        default_slot.m(h2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr(
          h2,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block$1k(ctx) {
  let h1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      h1 = element("h1");
      if (default_slot)
        default_slot.c();
      attr(
        h1,
        "id",
        /*id*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      if (default_slot) {
        default_slot.m(h1, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr(
          h1,
          "id",
          /*id*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h1);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$3v(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block$1k,
    create_if_block_1$m,
    create_if_block_2$7,
    create_if_block_3$2,
    create_if_block_4$1,
    create_if_block_5$1,
    create_else_block$r
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*depth*/
      ctx2[0] === 1
    )
      return 0;
    if (
      /*depth*/
      ctx2[0] === 2
    )
      return 1;
    if (
      /*depth*/
      ctx2[0] === 3
    )
      return 2;
    if (
      /*depth*/
      ctx2[0] === 4
    )
      return 3;
    if (
      /*depth*/
      ctx2[0] === 5
    )
      return 4;
    if (
      /*depth*/
      ctx2[0] === 6
    )
      return 5;
    return 6;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$3i($$self, $$props, $$invalidate) {
  let id;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { depth } = $$props;
  let { raw } = $$props;
  let { text: text2 } = $$props;
  const { slug, getOptions } = getContext(key);
  const options = getOptions();
  $$self.$$set = ($$props2) => {
    if ("depth" in $$props2)
      $$invalidate(0, depth = $$props2.depth);
    if ("raw" in $$props2)
      $$invalidate(1, raw = $$props2.raw);
    if ("text" in $$props2)
      $$invalidate(3, text2 = $$props2.text);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*text*/
    8) {
      $$invalidate(2, id = options.headerIds ? options.headerPrefix + slug(text2) : void 0);
    }
  };
  return [depth, raw, id, text2, $$scope, slots];
}
class Heading extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3i, create_fragment$3v, safe_not_equal, { depth: 0, raw: 1, text: 3 });
  }
}
function create_fragment$3u(ctx) {
  let p2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      p2 = element("p");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      if (default_slot) {
        default_slot.m(p2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$3h($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Paragraph extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3h, create_fragment$3u, safe_not_equal, {});
  }
}
function create_fragment$3t(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$3g($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { text: text2 } = $$props;
  let { raw } = $$props;
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("raw" in $$props2)
      $$invalidate(1, raw = $$props2.raw);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [text2, raw, $$scope, slots];
}
class Text extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3g, create_fragment$3t, safe_not_equal, { text: 0, raw: 1 });
  }
}
function create_fragment$3s(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*href*/
      ctx[0]))
        attr(img, "src", img_src_value);
      attr(
        img,
        "title",
        /*title*/
        ctx[1]
      );
      attr(
        img,
        "alt",
        /*text*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*href*/
      1 && !src_url_equal(img.src, img_src_value = /*href*/
      ctx2[0])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*title*/
      2) {
        attr(
          img,
          "title",
          /*title*/
          ctx2[1]
        );
      }
      if (dirty & /*text*/
      4) {
        attr(
          img,
          "alt",
          /*text*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function instance$3f($$self, $$props, $$invalidate) {
  let { href = "" } = $$props;
  let { title = void 0 } = $$props;
  let { text: text2 = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("href" in $$props2)
      $$invalidate(0, href = $$props2.href);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("text" in $$props2)
      $$invalidate(2, text2 = $$props2.text);
  };
  return [href, title, text2];
}
let Image$1 = class Image2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3f, create_fragment$3s, safe_not_equal, { href: 0, title: 1, text: 2 });
  }
};
function create_fragment$3r(ctx) {
  let a2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      a2 = element("a");
      if (default_slot)
        default_slot.c();
      attr(
        a2,
        "href",
        /*href*/
        ctx[0]
      );
      attr(
        a2,
        "title",
        /*title*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, a2, anchor);
      if (default_slot) {
        default_slot.m(a2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*href*/
      1) {
        attr(
          a2,
          "href",
          /*href*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*title*/
      2) {
        attr(
          a2,
          "title",
          /*title*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(a2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$3e($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { href = "" } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("href" in $$props2)
      $$invalidate(0, href = $$props2.href);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [href, title, $$scope, slots];
}
let Link$1 = class Link extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3e, create_fragment$3r, safe_not_equal, { href: 0, title: 1 });
  }
};
function create_fragment$3q(ctx) {
  let em;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      em = element("em");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, em, anchor);
      if (default_slot) {
        default_slot.m(em, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(em);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$3d($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Em extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3d, create_fragment$3q, safe_not_equal, {});
  }
}
function create_fragment$3p(ctx) {
  let del;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      del = element("del");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, del, anchor);
      if (default_slot) {
        default_slot.m(del, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(del);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$3c($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Del extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3c, create_fragment$3p, safe_not_equal, {});
  }
}
function create_fragment$3o(ctx) {
  let code;
  let t_value = (
    /*raw*/
    ctx[0].replace(/`/g, "") + ""
  );
  let t2;
  return {
    c() {
      code = element("code");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, code, anchor);
      append(code, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*raw*/
      1 && t_value !== (t_value = /*raw*/
      ctx2[0].replace(/`/g, "") + ""))
        set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(code);
      }
    }
  };
}
function instance$3b($$self, $$props, $$invalidate) {
  let { raw } = $$props;
  $$self.$$set = ($$props2) => {
    if ("raw" in $$props2)
      $$invalidate(0, raw = $$props2.raw);
  };
  return [raw];
}
class Codespan extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3b, create_fragment$3o, safe_not_equal, { raw: 0 });
  }
}
function create_fragment$3n(ctx) {
  let strong;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      strong = element("strong");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, strong, anchor);
      if (default_slot) {
        default_slot.m(strong, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(strong);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$3a($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Strong extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3a, create_fragment$3n, safe_not_equal, {});
  }
}
function create_fragment$3m(ctx) {
  let table;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      table = element("table");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, table, anchor);
      if (default_slot) {
        default_slot.m(table, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(table);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$39($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Table extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$39, create_fragment$3m, safe_not_equal, {});
  }
}
function create_fragment$3l(ctx) {
  let thead;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      thead = element("thead");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, thead, anchor);
      if (default_slot) {
        default_slot.m(thead, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(thead);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$38($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class TableHead extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$38, create_fragment$3l, safe_not_equal, {});
  }
}
function create_fragment$3k(ctx) {
  let tbody;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      tbody = element("tbody");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, tbody, anchor);
      if (default_slot) {
        default_slot.m(tbody, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(tbody);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$37($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class TableBody extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$37, create_fragment$3k, safe_not_equal, {});
  }
}
function create_fragment$3j(ctx) {
  let tr;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      tr = element("tr");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$36($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class TableRow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$36, create_fragment$3j, safe_not_equal, {});
  }
}
function create_else_block$q(ctx) {
  let td;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      td = element("td");
      if (default_slot)
        default_slot.c();
      attr(
        td,
        "align",
        /*align*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, td, anchor);
      if (default_slot) {
        default_slot.m(td, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*align*/
      2) {
        attr(
          td,
          "align",
          /*align*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block$1j(ctx) {
  let th;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      th = element("th");
      if (default_slot)
        default_slot.c();
      attr(
        th,
        "align",
        /*align*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, th, anchor);
      if (default_slot) {
        default_slot.m(th, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*align*/
      2) {
        attr(
          th,
          "align",
          /*align*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(th);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$3i(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1j, create_else_block$q];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*header*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$35($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { header: header2 } = $$props;
  let { align } = $$props;
  $$self.$$set = ($$props2) => {
    if ("header" in $$props2)
      $$invalidate(0, header2 = $$props2.header);
    if ("align" in $$props2)
      $$invalidate(1, align = $$props2.align);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [header2, align, $$scope, slots];
}
class TableCell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$35, create_fragment$3i, safe_not_equal, { header: 0, align: 1 });
  }
}
function create_else_block$p(ctx) {
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block$1i(ctx) {
  let ol;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      ol = element("ol");
      if (default_slot)
        default_slot.c();
      attr(
        ol,
        "start",
        /*start*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*start*/
      2) {
        attr(
          ol,
          "start",
          /*start*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ol);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$3h(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1i, create_else_block$p];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*ordered*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$34($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { ordered } = $$props;
  let { start } = $$props;
  $$self.$$set = ($$props2) => {
    if ("ordered" in $$props2)
      $$invalidate(0, ordered = $$props2.ordered);
    if ("start" in $$props2)
      $$invalidate(1, start = $$props2.start);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [ordered, start, $$scope, slots];
}
class List extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$34, create_fragment$3h, safe_not_equal, { ordered: 0, start: 1 });
  }
}
function create_fragment$3g(ctx) {
  let li;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      li = element("li");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$33($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class ListItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$33, create_fragment$3g, safe_not_equal, {});
  }
}
function create_fragment$3f(ctx) {
  let hr;
  return {
    c() {
      hr = element("hr");
    },
    m(target, anchor) {
      insert(target, hr, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(hr);
      }
    }
  };
}
class Hr extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$3f, safe_not_equal, {});
  }
}
function create_fragment$3e(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(
        /*text*/
        ctx[0],
        target,
        anchor
      );
      insert(target, html_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*text*/
      1)
        html_tag.p(
          /*text*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function instance$32($$self, $$props, $$invalidate) {
  let { text: text2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
  };
  return [text2];
}
class Html extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$32, create_fragment$3e, safe_not_equal, { text: 0 });
  }
}
function create_fragment$3d(ctx) {
  let blockquote;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      blockquote = element("blockquote");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, blockquote, anchor);
      if (default_slot) {
        default_slot.m(blockquote, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(blockquote);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$31($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Blockquote extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$31, create_fragment$3d, safe_not_equal, {});
  }
}
function create_fragment$3c(ctx) {
  let pre;
  let code;
  let t2;
  return {
    c() {
      pre = element("pre");
      code = element("code");
      t2 = text(
        /*text*/
        ctx[1]
      );
      attr(
        pre,
        "class",
        /*lang*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append(pre, code);
      append(code, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*text*/
      2)
        set_data(
          t2,
          /*text*/
          ctx2[1]
        );
      if (dirty & /*lang*/
      1) {
        attr(
          pre,
          "class",
          /*lang*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(pre);
      }
    }
  };
}
function instance$30($$self, $$props, $$invalidate) {
  let { lang } = $$props;
  let { text: text2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("lang" in $$props2)
      $$invalidate(0, lang = $$props2.lang);
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
  };
  return [lang, text2];
}
class Code extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$30, create_fragment$3c, safe_not_equal, { lang: 0, text: 1 });
  }
}
function create_fragment$3b(ctx) {
  let br;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      br = element("br");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, br, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(br);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$2$($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Br extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2$, create_fragment$3b, safe_not_equal, {});
  }
}
const defaultRenderers = {
  heading: Heading,
  paragraph: Paragraph,
  text: Text,
  image: Image$1,
  link: Link$1,
  em: Em,
  strong: Strong,
  codespan: Codespan,
  del: Del,
  table: Table,
  tablehead: TableHead,
  tablebody: TableBody,
  tablerow: TableRow,
  tablecell: TableCell,
  list: List,
  orderedlistitem: null,
  unorderedlistitem: null,
  listitem: ListItem,
  hr: Hr,
  html: Html,
  blockquote: Blockquote,
  code: Code,
  br: Br
};
const defaultOptions = {
  baseUrl: null,
  breaks: false,
  gfm: true,
  headerIds: true,
  headerPrefix: "",
  highlight: null,
  langPrefix: "language-",
  mangle: true,
  pedantic: false,
  renderer: null,
  sanitize: false,
  sanitizer: null,
  silent: false,
  smartLists: false,
  smartypants: false,
  tokenizer: null,
  xhtml: false
};
function create_fragment$3a(ctx) {
  let parser;
  let current;
  parser = new Parser$1({
    props: {
      tokens: (
        /*tokens*/
        ctx[0]
      ),
      renderers: (
        /*combinedRenderers*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(parser.$$.fragment);
    },
    m(target, anchor) {
      mount_component(parser, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const parser_changes = {};
      if (dirty & /*tokens*/
      1)
        parser_changes.tokens = /*tokens*/
        ctx2[0];
      if (dirty & /*combinedRenderers*/
      2)
        parser_changes.renderers = /*combinedRenderers*/
        ctx2[1];
      parser.$set(parser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(parser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(parser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(parser, detaching);
    }
  };
}
function instance$2_($$self, $$props, $$invalidate) {
  let preprocessed;
  let slugger;
  let combinedOptions;
  let combinedRenderers;
  let { source: source2 = [] } = $$props;
  let { renderers = {} } = $$props;
  let { options = {} } = $$props;
  let { isInline = false } = $$props;
  const dispatch2 = createEventDispatcher();
  let tokens;
  let lexer;
  let mounted;
  setContext(key, {
    slug: (val) => slugger ? slugger.slug(val) : "",
    getOptions: () => combinedOptions
  });
  onMount(() => {
    $$invalidate(7, mounted = true);
  });
  $$self.$$set = ($$props2) => {
    if ("source" in $$props2)
      $$invalidate(2, source2 = $$props2.source);
    if ("renderers" in $$props2)
      $$invalidate(3, renderers = $$props2.renderers);
    if ("options" in $$props2)
      $$invalidate(4, options = $$props2.options);
    if ("isInline" in $$props2)
      $$invalidate(5, isInline = $$props2.isInline);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*source*/
    4) {
      $$invalidate(8, preprocessed = Array.isArray(source2));
    }
    if ($$self.$$.dirty & /*source*/
    4) {
      slugger = source2 ? new Slugger() : void 0;
    }
    if ($$self.$$.dirty & /*options*/
    16) {
      $$invalidate(9, combinedOptions = { ...defaultOptions, ...options });
    }
    if ($$self.$$.dirty & /*preprocessed, source, combinedOptions, isInline, lexer, tokens*/
    869) {
      if (preprocessed) {
        $$invalidate(0, tokens = source2);
      } else {
        $$invalidate(6, lexer = new Lexer(combinedOptions));
        $$invalidate(0, tokens = isInline ? lexer.inlineTokens(source2) : lexer.lex(source2));
        dispatch2("parsed", { tokens });
      }
    }
    if ($$self.$$.dirty & /*renderers*/
    8) {
      $$invalidate(1, combinedRenderers = { ...defaultRenderers, ...renderers });
    }
    if ($$self.$$.dirty & /*mounted, preprocessed, tokens*/
    385) {
      mounted && !preprocessed && dispatch2("parsed", { tokens });
    }
  };
  return [
    tokens,
    combinedRenderers,
    source2,
    renderers,
    options,
    isInline,
    lexer,
    mounted,
    preprocessed,
    combinedOptions
  ];
}
class SvelteMarkdown extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2_, create_fragment$3a, safe_not_equal, {
      source: 2,
      renderers: 3,
      options: 4,
      isInline: 5
    });
  }
}
const markdownviewer = "";
function create_fragment$39(ctx) {
  let div1;
  return {
    c() {
      div1 = element("div");
      div1.innerHTML = `<div class="content"><img src="${ErrorIcon}" alt="Error"/> <h3>Render failed</h3> <p>The markdown content could not be parsed. The opened file may be empty.</p></div>`;
      attr(div1, "class", "unreadable");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
    }
  };
}
class Unreadable extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$39, safe_not_equal, {});
  }
}
function create_if_block$1h(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$l, create_else_block$o];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*content*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$o(ctx) {
  let unreadable;
  let current;
  unreadable = new Unreadable({});
  return {
    c() {
      create_component(unreadable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(unreadable, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(unreadable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(unreadable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(unreadable, detaching);
    }
  };
}
function create_if_block_1$l(ctx) {
  let div;
  let sveltemarkdown;
  let current;
  sveltemarkdown = new SvelteMarkdown({ props: { source: (
    /*content*/
    ctx[1]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(sveltemarkdown.$$.fragment);
      attr(div, "class", "markdownrenderer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(sveltemarkdown, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const sveltemarkdown_changes = {};
      if (dirty & /*content*/
      2)
        sveltemarkdown_changes.source = /*content*/
        ctx2[1];
      sveltemarkdown.$set(sveltemarkdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sveltemarkdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sveltemarkdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(sveltemarkdown);
    }
  };
}
function create_fragment$38(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*app*/
    ctx[0] && create_if_block$1h(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*app*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*app*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1h(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$2Z($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let md = "";
  let content2 = "";
  WindowStore.subscribe(() => {
    if (!app)
      return;
    const file = app.openedFile;
    if (!file || !file.mime.startsWith("text/"))
      return;
    md = new TextDecoder().decode(file.data);
    $$invalidate(1, content2 = md);
  });
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [app, content2];
}
let MarkDownViewer$1 = class MarkDownViewer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2Z, create_fragment$38, safe_not_equal, { app: 0 });
  }
};
const MarkDownViewer2 = {
  info: {
    name: "Markdown Viewer",
    description: "View .MD files",
    author: "ArcOS Team",
    version: "1.0.0",
    icon: MarkDownViewerIcon,
    builtin: true,
    hidden: true,
    requiresFile: true,
    appGroup: "utilities"
  },
  size: { w: 700, h: 550 },
  pos: { x: 30, y: 40 },
  minSize: { w: 400, h: 300 },
  maxSize: { w: 1e3, h: 800 },
  controls: { min: true, max: true, cls: true },
  state: {
    headless: false,
    resizable: true,
    windowState: { min: false, max: false, fll: false }
  },
  content: MarkDownViewer$1,
  glass: false,
  fileMimes: ["text/plain", "text/markdown", "text/html"],
  fileExts: [".md"],
  events: {
    openFile(app) {
      if (!app.openedFile)
        return;
      setTitleSuffix(` - ${app.openedFile.path}`, app.id);
    }
  }
};
const mediaplayer = "";
function create_fragment$37(ctx) {
  let audio;
  let audio_src_value;
  let audio_updating = false;
  let audio_animationframe;
  let mounted;
  let dispose;
  function audio_timeupdate_handler() {
    cancelAnimationFrame(audio_animationframe);
    if (!audio.paused) {
      audio_animationframe = raf(audio_timeupdate_handler);
      audio_updating = true;
    }
    ctx[7].call(audio);
  }
  return {
    c() {
      audio = element("audio");
      if (!src_url_equal(audio.src, audio_src_value = /*url*/
      ctx[3]))
        attr(audio, "src", audio_src_value);
      audio.controls = true;
      audio.autoplay = true;
      if (
        /*duration*/
        ctx[1] === void 0
      )
        add_render_callback(() => (
          /*audio_durationchange_handler*/
          ctx[6].call(audio)
        ));
    },
    m(target, anchor) {
      insert(target, audio, anchor);
      ctx[5](audio);
      if (!mounted) {
        dispose = [
          listen(
            audio,
            "durationchange",
            /*audio_durationchange_handler*/
            ctx[6]
          ),
          listen(audio, "timeupdate", audio_timeupdate_handler),
          listen(audio, "timeupdate", function() {
            if (is_function(
              /*updateWidth*/
              ctx[4]
            ))
              ctx[4].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*url*/
      8 && !src_url_equal(audio.src, audio_src_value = /*url*/
      ctx[3])) {
        attr(audio, "src", audio_src_value);
      }
      if (!audio_updating && dirty & /*current*/
      4 && !isNaN(
        /*current*/
        ctx[2]
      )) {
        audio.currentTime = /*current*/
        ctx[2];
      }
      audio_updating = false;
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(audio);
      }
      ctx[5](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2Y($$self, $$props, $$invalidate) {
  let { url } = $$props;
  let { audioObject } = $$props;
  let { duration } = $$props;
  let { current } = $$props;
  let { updateWidth } = $$props;
  function audio_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      audioObject = $$value;
      $$invalidate(0, audioObject);
    });
  }
  function audio_durationchange_handler() {
    duration = this.duration;
    $$invalidate(1, duration);
  }
  function audio_timeupdate_handler() {
    current = this.currentTime;
    $$invalidate(2, current);
  }
  $$self.$$set = ($$props2) => {
    if ("url" in $$props2)
      $$invalidate(3, url = $$props2.url);
    if ("audioObject" in $$props2)
      $$invalidate(0, audioObject = $$props2.audioObject);
    if ("duration" in $$props2)
      $$invalidate(1, duration = $$props2.duration);
    if ("current" in $$props2)
      $$invalidate(2, current = $$props2.current);
    if ("updateWidth" in $$props2)
      $$invalidate(4, updateWidth = $$props2.updateWidth);
  };
  return [
    audioObject,
    duration,
    current,
    url,
    updateWidth,
    audio_binding,
    audio_durationchange_handler,
    audio_timeupdate_handler
  ];
}
class Audio extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2Y, create_fragment$37, safe_not_equal, {
      url: 3,
      audioObject: 0,
      duration: 1,
      current: 2,
      updateWidth: 4
    });
  }
}
function create_fragment$36(ctx) {
  let div;
  let img;
  let img_src_value;
  let img_alt_value;
  let span;
  let t_value = (
    /*file*/
    ctx[0].path + ""
  );
  let t2;
  let div_title_value;
  return {
    c() {
      div = element("div");
      img = element("img");
      span = element("span");
      t2 = text(t_value);
      if (!src_url_equal(img.src, img_src_value = getMimeIcon(
        /*file*/
        ctx[0].name
      )))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*file*/
      ctx[0].name);
      attr(div, "class", "filename");
      attr(div, "title", div_title_value = /*file*/
      ctx[0].path);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*file*/
      1 && !src_url_equal(img.src, img_src_value = getMimeIcon(
        /*file*/
        ctx2[0].name
      ))) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*file*/
      1 && img_alt_value !== (img_alt_value = /*file*/
      ctx2[0].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*file*/
      1 && t_value !== (t_value = /*file*/
      ctx2[0].path + ""))
        set_data(t2, t_value);
      if (dirty & /*file*/
      1 && div_title_value !== (div_title_value = /*file*/
      ctx2[0].path)) {
        attr(div, "title", div_title_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$2X($$self, $$props, $$invalidate) {
  let { file } = $$props;
  $$self.$$set = ($$props2) => {
    if ("file" in $$props2)
      $$invalidate(0, file = $$props2.file);
  };
  return [file];
}
let File$2 = class File4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2X, create_fragment$36, safe_not_equal, { file: 0 });
  }
};
function create_fragment$35(ctx) {
  let div;
  let button0;
  let t0;
  let button0_disabled_value;
  let t1;
  let button1;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text("play_arrow");
      t1 = space();
      button1 = element("button");
      t2 = text("pause");
      attr(button0, "class", "material-icons-round");
      button0.disabled = button0_disabled_value = !/*paused*/
      ctx[2] && /*barWidth*/
      ctx[1] < 100;
      attr(button1, "class", "material-icons-round");
      button1.disabled = /*paused*/
      ctx[2];
      attr(div, "class", "group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[3]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*paused, barWidth*/
      6 && button0_disabled_value !== (button0_disabled_value = !/*paused*/
      ctx2[2] && /*barWidth*/
      ctx2[1] < 100)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*paused*/
      4) {
        button1.disabled = /*paused*/
        ctx2[2];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2W($$self, $$props, $$invalidate) {
  let { audioObject } = $$props;
  let { barWidth } = $$props;
  let { paused } = $$props;
  const click_handler = () => audioObject.play();
  const click_handler_1 = () => audioObject.pause();
  $$self.$$set = ($$props2) => {
    if ("audioObject" in $$props2)
      $$invalidate(0, audioObject = $$props2.audioObject);
    if ("barWidth" in $$props2)
      $$invalidate(1, barWidth = $$props2.barWidth);
    if ("paused" in $$props2)
      $$invalidate(2, paused = $$props2.paused);
  };
  return [audioObject, barWidth, paused, click_handler, click_handler_1];
}
class PlayPause extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2W, create_fragment$35, safe_not_equal, { audioObject: 0, barWidth: 1, paused: 2 });
  }
}
function create_fragment$34(ctx) {
  let div;
  let button0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.textContent = "fast_rewind";
      t1 = space();
      button1 = element("button");
      button1.textContent = "fast_forward";
      attr(button0, "class", "material-icons-round");
      attr(button1, "class", "material-icons-round");
      attr(div, "class", "group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, t1);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*rewind*/
            ctx[0]
          ),
          listen(
            button1,
            "click",
            /*forward*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2V($$self, $$props, $$invalidate) {
  let { audioObject } = $$props;
  function rewind() {
    $$invalidate(2, audioObject.currentTime -= 10, audioObject);
  }
  function forward() {
    $$invalidate(2, audioObject.currentTime += 10, audioObject);
  }
  $$self.$$set = ($$props2) => {
    if ("audioObject" in $$props2)
      $$invalidate(2, audioObject = $$props2.audioObject);
  };
  return [rewind, forward, audioObject];
}
class Scrub extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2V, create_fragment$34, safe_not_equal, { audioObject: 2 });
  }
}
function create_fragment$33(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "stop";
      attr(button, "class", "material-icons-round");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*stop*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2U($$self, $$props, $$invalidate) {
  let { stop: stop2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("stop" in $$props2)
      $$invalidate(0, stop2 = $$props2.stop);
  };
  return [stop2];
}
class Stop extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2U, create_fragment$33, safe_not_equal, { stop: 0 });
  }
}
function create_fragment$32(ctx) {
  let div;
  let t0_value = formatTime(
    /*current*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let t2_value = formatTime(
    /*duration*/
    ctx[1]
  ) + "";
  let t2;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = text(" / ");
      t2 = text(t2_value);
      attr(div, "class", "right");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*current*/
      1 && t0_value !== (t0_value = formatTime(
        /*current*/
        ctx2[0]
      ) + ""))
        set_data(t0, t0_value);
      if (dirty & /*duration*/
      2 && t2_value !== (t2_value = formatTime(
        /*duration*/
        ctx2[1]
      ) + ""))
        set_data(t2, t2_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function formatTime(seconds) {
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = Math.floor(seconds % 60);
  return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
}
function instance$2T($$self, $$props, $$invalidate) {
  let { current } = $$props;
  let { duration } = $$props;
  $$self.$$set = ($$props2) => {
    if ("current" in $$props2)
      $$invalidate(0, current = $$props2.current);
    if ("duration" in $$props2)
      $$invalidate(1, duration = $$props2.duration);
  };
  return [current, duration];
}
class Time extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2T, create_fragment$32, safe_not_equal, { current: 0, duration: 1 });
  }
}
function create_else_block$n(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<h3>Error playing file</h3> <p>Media Player did not receive a file to play...</p>`;
      attr(div, "class", "markdownrenderer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block$1g(ctx) {
  let audio;
  let updating_audioObject;
  let updating_duration;
  let updating_current;
  let t2;
  let if_block_anchor;
  let current;
  function audio_audioObject_binding(value) {
    ctx[10](value);
  }
  function audio_duration_binding(value) {
    ctx[11](value);
  }
  function audio_current_binding(value) {
    ctx[12](value);
  }
  let audio_props = {
    url: (
      /*url*/
      ctx[5]
    ),
    updateWidth: (
      /*updateWidth*/
      ctx[7]
    )
  };
  if (
    /*audioObject*/
    ctx[0] !== void 0
  ) {
    audio_props.audioObject = /*audioObject*/
    ctx[0];
  }
  if (
    /*duration*/
    ctx[3] !== void 0
  ) {
    audio_props.duration = /*duration*/
    ctx[3];
  }
  if (
    /*current*/
    ctx[4] !== void 0
  ) {
    audio_props.current = /*current*/
    ctx[4];
  }
  audio = new Audio({ props: audio_props });
  binding_callbacks.push(() => bind$1(audio, "audioObject", audio_audioObject_binding));
  binding_callbacks.push(() => bind$1(audio, "duration", audio_duration_binding));
  binding_callbacks.push(() => bind$1(audio, "current", audio_current_binding));
  let if_block = (
    /*audioObject*/
    ctx[0] && create_if_block_1$k(ctx)
  );
  return {
    c() {
      create_component(audio.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(audio, target, anchor);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const audio_changes = {};
      if (dirty & /*url*/
      32)
        audio_changes.url = /*url*/
        ctx2[5];
      if (!updating_audioObject && dirty & /*audioObject*/
      1) {
        updating_audioObject = true;
        audio_changes.audioObject = /*audioObject*/
        ctx2[0];
        add_flush_callback(() => updating_audioObject = false);
      }
      if (!updating_duration && dirty & /*duration*/
      8) {
        updating_duration = true;
        audio_changes.duration = /*duration*/
        ctx2[3];
        add_flush_callback(() => updating_duration = false);
      }
      if (!updating_current && dirty & /*current*/
      16) {
        updating_current = true;
        audio_changes.current = /*current*/
        ctx2[4];
        add_flush_callback(() => updating_current = false);
      }
      audio.$set(audio_changes);
      if (
        /*audioObject*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*audioObject*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$k(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(audio.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(audio.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(audio, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_1$k(ctx) {
  let div3;
  let div0;
  let playpause;
  let t0;
  let scrub;
  let t1;
  let stop_1;
  let t2;
  let time;
  let t3;
  let div2;
  let div1;
  let t4;
  let file_1;
  let current;
  playpause = new PlayPause({
    props: {
      audioObject: (
        /*audioObject*/
        ctx[0]
      ),
      paused: (
        /*paused*/
        ctx[6]
      ),
      barWidth: (
        /*barWidth*/
        ctx[2]
      )
    }
  });
  scrub = new Scrub({
    props: { audioObject: (
      /*audioObject*/
      ctx[0]
    ) }
  });
  stop_1 = new Stop({ props: { stop: (
    /*stop*/
    ctx[8]
  ) } });
  time = new Time({
    props: {
      duration: (
        /*duration*/
        ctx[3]
      ),
      current: (
        /*current*/
        ctx[4]
      )
    }
  });
  file_1 = new File$2({ props: { file: (
    /*file*/
    ctx[1]
  ) } });
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      create_component(playpause.$$.fragment);
      t0 = space();
      create_component(scrub.$$.fragment);
      t1 = space();
      create_component(stop_1.$$.fragment);
      t2 = space();
      create_component(time.$$.fragment);
      t3 = space();
      div2 = element("div");
      div1 = element("div");
      t4 = space();
      create_component(file_1.$$.fragment);
      attr(div0, "class", "controls");
      attr(div1, "class", "inner");
      set_style(
        div1,
        "width",
        /*barWidth*/
        ctx[2] + "%"
      );
      attr(div2, "class", "bar");
      attr(div3, "class", "media-player");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      mount_component(playpause, div0, null);
      append(div0, t0);
      mount_component(scrub, div0, null);
      append(div0, t1);
      mount_component(stop_1, div0, null);
      append(div0, t2);
      mount_component(time, div0, null);
      append(div3, t3);
      append(div3, div2);
      append(div2, div1);
      append(div3, t4);
      mount_component(file_1, div3, null);
      current = true;
    },
    p(ctx2, dirty) {
      const playpause_changes = {};
      if (dirty & /*audioObject*/
      1)
        playpause_changes.audioObject = /*audioObject*/
        ctx2[0];
      if (dirty & /*paused*/
      64)
        playpause_changes.paused = /*paused*/
        ctx2[6];
      if (dirty & /*barWidth*/
      4)
        playpause_changes.barWidth = /*barWidth*/
        ctx2[2];
      playpause.$set(playpause_changes);
      const scrub_changes = {};
      if (dirty & /*audioObject*/
      1)
        scrub_changes.audioObject = /*audioObject*/
        ctx2[0];
      scrub.$set(scrub_changes);
      const time_changes = {};
      if (dirty & /*duration*/
      8)
        time_changes.duration = /*duration*/
        ctx2[3];
      if (dirty & /*current*/
      16)
        time_changes.current = /*current*/
        ctx2[4];
      time.$set(time_changes);
      if (!current || dirty & /*barWidth*/
      4) {
        set_style(
          div1,
          "width",
          /*barWidth*/
          ctx2[2] + "%"
        );
      }
      const file_1_changes = {};
      if (dirty & /*file*/
      2)
        file_1_changes.file = /*file*/
        ctx2[1];
      file_1.$set(file_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(playpause.$$.fragment, local);
      transition_in(scrub.$$.fragment, local);
      transition_in(stop_1.$$.fragment, local);
      transition_in(time.$$.fragment, local);
      transition_in(file_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(playpause.$$.fragment, local);
      transition_out(scrub.$$.fragment, local);
      transition_out(stop_1.$$.fragment, local);
      transition_out(time.$$.fragment, local);
      transition_out(file_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(playpause);
      destroy_component(scrub);
      destroy_component(stop_1);
      destroy_component(time);
      destroy_component(file_1);
    }
  };
}
function create_fragment$31(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1g, create_else_block$n];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*file*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$2S($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let audioObject;
  let file;
  let barWidth = 0;
  let duration = 0;
  let current = 0;
  let url = "";
  let filename = "";
  let paused = true;
  WindowStore.subscribe(() => {
    if (!app.openedFile || !audioObject || filename == app.openedFile.name)
      return;
    $$invalidate(1, file = app.openedFile);
    filename = file.name;
    $$invalidate(5, url = URL.createObjectURL(arrayToBlob(file.data, file.mime)));
    if (!isOpened(app.id))
      return;
    setTimeout(() => {
      audioObject.play();
    });
  });
  function updateWidth() {
    $$invalidate(2, barWidth = audioObject.currentTime / audioObject.duration * 100);
    $$invalidate(6, paused = audioObject.paused);
  }
  function stop2() {
    if (!audioObject)
      return;
    $$invalidate(0, audioObject.currentTime = 0, audioObject);
    audioObject.pause();
  }
  onMount(() => {
    if (!app.events)
      $$invalidate(9, app.events = {}, app);
    $$invalidate(
      9,
      app.events.close = () => {
        stop2();
      },
      app
    );
    $$invalidate(
      9,
      app.events.openFile = () => {
        if (!isOpened(app.id))
          return;
        if (!file)
          $$invalidate(1, file = app.openedFile);
        filename = file.name;
        $$invalidate(5, url = URL.createObjectURL(arrayToBlob(file.data, file.mime)));
        setTimeout(() => {
          audioObject.play();
        });
      },
      app
    );
    registerShortcuts([
      {
        key: "space",
        action: () => {
          if (!audioObject)
            return;
          audioObject.pause();
        }
      }
    ]);
  });
  function audio_audioObject_binding(value) {
    audioObject = value;
    $$invalidate(0, audioObject);
  }
  function audio_duration_binding(value) {
    duration = value;
    $$invalidate(3, duration);
  }
  function audio_current_binding(value) {
    current = value;
    $$invalidate(4, current);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(9, app = $$props2.app);
  };
  return [
    audioObject,
    file,
    barWidth,
    duration,
    current,
    url,
    paused,
    updateWidth,
    stop2,
    app,
    audio_audioObject_binding,
    audio_duration_binding,
    audio_current_binding
  ];
}
class MediaPlayer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2S, create_fragment$31, safe_not_equal, { app: 9 });
  }
}
const MediaPlayerApp = {
  info: {
    name: "Media Player",
    description: "Play audio files",
    builtin: true,
    version: "2.0.0",
    author: "Izaak Kuipers",
    icon: MediaPlayerIcon,
    hidden: true,
    appGroup: "entertainment",
    requiresFile: true
  },
  size: { w: 442, h: NaN },
  pos: { x: 100, y: 100 },
  minSize: { w: 442, h: 121 },
  maxSize: { w: 442, h: 131 },
  controls: { min: true, max: false, cls: true },
  state: {
    headless: false,
    resizable: false,
    windowState: { min: false, max: false, fll: false }
  },
  content: MediaPlayer,
  glass: true,
  fileMimes: [
    "audio/x-flac",
    "audio/wave",
    "audio/mpeg",
    "audio/x-wav",
    "audio/"
  ],
  events: {
    open: (app) => {
      createTrayIcon({
        onOpen() {
          openWindow("MediaPlayerApp");
        },
        image: MediaPlayerIcon,
        identifier: "MediaPlayerApp"
      });
    },
    close() {
      disposeTrayIcon("MediaPlayerApp");
    }
  }
};
const selectedMessageId = writable(null);
const replyMessageId = writable(null);
const threadMessageId = writable(null);
const creatingMessage = writable(false);
async function getMessages() {
  const server = get_store_value(ConnectedServer);
  if (!server)
    return [];
  const req = await apiCall(server, "messages/list", {}, get_store_value(UserToken));
  if (!req.valid)
    return [];
  return req.data;
}
async function getMessage(id) {
  const server = get_store_value(ConnectedServer);
  if (!server)
    return false;
  const req = await apiCall(
    server,
    "messages/get",
    {
      id: toBase64(id)
    },
    get_store_value(UserToken)
  );
  if (!req.valid)
    return false;
  return req.data;
}
async function deleteMessage(id) {
  const server = get_store_value(ConnectedServer);
  if (!server)
    return false;
  const req = await apiCall(
    server,
    "messages/delete",
    { id: toBase64(id) },
    get_store_value(UserToken)
  );
  return !req;
}
const MessagingUpdaters = writable([]);
function messageSubscribe(cb) {
  const updaters = get_store_value(MessagingUpdaters);
  updaters.push(cb);
  MessagingUpdaters.set(updaters);
}
function messageUpdateTrigger() {
  const updaters = get_store_value(MessagingUpdaters);
  for (let i2 = 0; i2 < updaters.length; i2++) {
    updaters[i2]();
  }
}
const messageSidebarActions = [
  {
    icon: "add",
    name: "New Message",
    action() {
      replyMessageId.set(null);
      creatingMessage.set(true);
    }
  }
];
const messageItemActions = [
  {
    icon: "reply",
    name: "Reply",
    async action(message) {
      replyMessageId.set(message.id);
      creatingMessage.set(true);
    }
  },
  {
    icon: "save",
    name: "Save to ArcFS",
    async action(message) {
      const blob = new Blob([message.body], { type: "text/markdown" });
      await createDirectory("./Messages");
      const filename = `Message from ${message.sender} - ${message.id}.md`;
      const path = `./Messages/${filename}`;
      await writeFile(path, blob);
      openWindow("FileManager");
      await fbClass.goToDirectory("./Messages");
      setTimeout(() => {
        fbState.update((v2) => {
          v2.selectedFilename = filename;
          return v2;
        });
      });
    }
  },
  {
    icon: "delete",
    name: "Delete message for everyone",
    async action(message) {
      if (message.sender != get_store_value(UserName)) {
        createOverlayableError(
          {
            title: "Well that's not good",
            message: `Unfortunately you have to be the owner of a message in order to delete it. Please ask <b>${message.sender}</b> to delete the message for you.`,
            image: ErrorIcon,
            buttons: [{ caption: "Okay", action() {
            }, suggested: true }]
          },
          "MessagingApp"
        );
        return;
      }
      createOverlayableError(
        {
          title: "Delete message?",
          message: `Are you sure you want to delete this message from ${message.sender}? This cannot be undone.`,
          image: ErrorIcon,
          buttons: [
            {
              caption: "Delete",
              action: async () => {
                await deleteMessage(message.id);
                messageUpdateTrigger();
                selectedMessageId.set(null);
              },
              suggested: true
            },
            { caption: "Cancel", action: () => {
            } }
          ]
        },
        "MessagingApp"
      );
    }
  }
];
async function getSentMessages() {
  const messages = await getMessages();
  let returnValue = [];
  for (let i2 = 0; i2 < messages.length; i2++) {
    if (messages[i2].sender == get_store_value(UserName))
      returnValue.push(messages[i2]);
  }
  return returnValue;
}
async function getReceivedMessages() {
  const messages = await getMessages();
  let returnValue = [];
  for (let i2 = 0; i2 < messages.length; i2++) {
    if (messages[i2].receiver == get_store_value(UserName) && messages[i2].sender != get_store_value(UserName))
      returnValue.push(messages[i2]);
  }
  return returnValue;
}
async function getUnreadMessages() {
  const messages = await getReceivedMessages();
  let returnValue = [];
  for (let i2 = 0; i2 < messages.length; i2++) {
    if (!messages[i2].read)
      returnValue.push(messages[i2]);
  }
  return returnValue;
}
const messagingPage = writable(null);
messagingPage.subscribe(() => {
  setTimeout(messageUpdateTrigger, 100);
});
selectedMessageId.subscribe(() => {
  messageUpdateTrigger();
  creatingMessage.set(false);
});
const MessagingPages = {
  unread: {
    name: "Unread",
    icon: "mark_email_unread",
    msgGetter: getUnreadMessages
  },
  inbox: {
    name: "Inbox",
    icon: "inbox",
    msgGetter: getReceivedMessages
  },
  sent: {
    name: "Sent",
    icon: "send",
    msgGetter: getSentMessages
  }
};
function create_fragment$30(ctx) {
  let button;
  let t_value = (
    /*action*/
    ctx[0].icon + ""
  );
  let t2;
  let button_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "class", "material-icons-round");
      attr(button, "title", button_title_value = /*action*/
      ctx[0].name);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*action*/
            ctx[0].action
          ))
            ctx[0].action.apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*action*/
      1 && t_value !== (t_value = /*action*/
      ctx[0].icon + ""))
        set_data(t2, t_value);
      if (dirty & /*action*/
      1 && button_title_value !== (button_title_value = /*action*/
      ctx[0].name)) {
        attr(button, "title", button_title_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2R($$self, $$props, $$invalidate) {
  let { action } = $$props;
  $$self.$$set = ($$props2) => {
    if ("action" in $$props2)
      $$invalidate(0, action = $$props2.action);
  };
  return [action];
}
class Action2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2R, create_fragment$30, safe_not_equal, { action: 0 });
  }
}
function create_fragment$2$(ctx) {
  let button;
  let t_value = (
    /*data*/
    ctx[0].icon + ""
  );
  let t2;
  let button_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "class", "material-icons-round");
      attr(button, "title", button_title_value = /*data*/
      ctx[0].name);
      toggle_class(
        button,
        "active",
        /*$messagingPage*/
        ctx[1] && /*data*/
        ctx[0].name == /*$messagingPage*/
        ctx[1].name
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*switchTo*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*data*/
      1 && t_value !== (t_value = /*data*/
      ctx2[0].icon + ""))
        set_data(t2, t_value);
      if (dirty & /*data*/
      1 && button_title_value !== (button_title_value = /*data*/
      ctx2[0].name)) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*$messagingPage, data*/
      3) {
        toggle_class(
          button,
          "active",
          /*$messagingPage*/
          ctx2[1] && /*data*/
          ctx2[0].name == /*$messagingPage*/
          ctx2[1].name
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2Q($$self, $$props, $$invalidate) {
  let $messagingPage;
  component_subscribe($$self, messagingPage, ($$value) => $$invalidate(1, $messagingPage = $$value));
  let { data } = $$props;
  function switchTo() {
    set_store_value(messagingPage, $messagingPage = data, $messagingPage);
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
  };
  return [data, $messagingPage, switchTo];
}
let Page$1 = class Page extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2Q, create_fragment$2$, safe_not_equal, { data: 0 });
  }
};
function get_each_context$F(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2];
  return child_ctx;
}
function get_each_context_1$9(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2];
  return child_ctx;
}
function create_each_block_1$9(ctx) {
  let page_1;
  let current;
  page_1 = new Page$1({ props: { data: (
    /*page*/
    ctx[5][1]
  ) } });
  return {
    c() {
      create_component(page_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(page_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(page_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(page_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(page_1, detaching);
    }
  };
}
function create_each_block$F(ctx) {
  let action_1;
  let current;
  action_1 = new Action2({ props: { action: (
    /*action*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(action_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(action_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(action_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(action_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(action_1, detaching);
    }
  };
}
function create_fragment$2_(ctx) {
  let div2;
  let div0;
  let t0;
  let hr;
  let t1;
  let div1;
  let t2;
  let profilepicture;
  let current;
  let each_value_1 = ensure_array_like(Object.entries(MessagingPages));
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1$9(get_each_context_1$9(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  let each_value = ensure_array_like(messageSidebarActions);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$F(get_each_context$F(ctx, each_value, i2));
  }
  profilepicture = new ProfilePicture({
    props: { src: (
      /*pfp*/
      ctx[0]
    ), height: 20 }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t0 = space();
      hr = element("hr");
      t1 = space();
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      create_component(profilepicture.$$.fragment);
      attr(div0, "class", "pages");
      attr(div1, "class", "actions");
      attr(div2, "class", "sidebar");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(div0, null);
        }
      }
      append(div2, t0);
      append(div2, hr);
      append(div2, t1);
      append(div2, div1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      append(div2, t2);
      mount_component(profilepicture, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Object*/
      0) {
        each_value_1 = ensure_array_like(Object.entries(MessagingPages));
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$9(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_1$9(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      1)
        profilepicture_changes.src = /*pfp*/
        ctx2[0];
      profilepicture.$set(profilepicture_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      destroy_component(profilepicture);
    }
  };
}
function instance$2P($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(1, $UserData = $$value));
  let pfp;
  UserData$2.subscribe(() => {
    $$invalidate(0, pfp = getProfilePicture($UserData.acc.profilePicture));
  });
  return [pfp];
}
let SideBar$1 = class SideBar3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2P, create_fragment$2_, safe_not_equal, {});
  }
};
const messaging = "";
const partialFilters = ["#", "](", "![", "!", ">", "|", "(", ")"];
function filterPartial(partial) {
  let str = partial;
  for (let i2 = 0; i2 < partialFilters.length; i2++) {
    str = str.split(partialFilters[i2]).join("");
  }
  return str;
}
function create_if_block$1f(ctx) {
  let span;
  let t2;
  let span_title_value;
  return {
    c() {
      span = element("span");
      t2 = text("reply");
      attr(span, "class", "material-icons-round");
      attr(span, "title", span_title_value = /*item*/
      ctx[0].replyingTo);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*item*/
      1 && span_title_value !== (span_title_value = /*item*/
      ctx2[0].replyingTo)) {
        attr(span, "title", span_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$2Z(ctx) {
  let button;
  let profilepicture;
  let t0;
  let div0;
  let p0;
  let t1_value = (
    /*invert*/
    (ctx[1] ? (
      /*item*/
      ctx[0].receiver
    ) : (
      /*item*/
      ctx[0].sender
    )) + ""
  );
  let t1;
  let t2;
  let t3;
  let p1;
  let t4_value = (filterPartial(
    /*item*/
    ctx[0].partialBody
  ) || "(no content)") + "";
  let t4;
  let t5;
  let div1;
  let t6_value = dayjs(
    /*item*/
    ctx[0].timestamp
  ).format("DD-MM HH:mm") + "";
  let t6;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*userProfile*/
      ctx[2]
    ), height: 26 }
  });
  let if_block = (
    /*item*/
    ctx[0].replyingTo && create_if_block$1f(ctx)
  );
  return {
    c() {
      button = element("button");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      div0 = element("div");
      p0 = element("p");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      p1 = element("p");
      t4 = text(t4_value);
      t5 = space();
      div1 = element("div");
      t6 = text(t6_value);
      attr(p0, "class", "username");
      attr(p1, "class", "partial");
      attr(div0, "class", "content");
      attr(div1, "class", "timestamp");
      attr(button, "class", "message");
      toggle_class(
        button,
        "selected",
        /*$selectedMessageId*/
        ctx[3] == /*item*/
        ctx[0].id
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(profilepicture, button, null);
      append(button, t0);
      append(button, div0);
      append(div0, p0);
      append(p0, t1);
      append(p0, t2);
      if (if_block)
        if_block.m(p0, null);
      append(div0, t3);
      append(div0, p1);
      append(p1, t4);
      append(button, t5);
      append(button, div1);
      append(div1, t6);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*select*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*userProfile*/
      4)
        profilepicture_changes.src = /*userProfile*/
        ctx2[2];
      profilepicture.$set(profilepicture_changes);
      if ((!current || dirty & /*invert, item*/
      3) && t1_value !== (t1_value = /*invert*/
      (ctx2[1] ? (
        /*item*/
        ctx2[0].receiver
      ) : (
        /*item*/
        ctx2[0].sender
      )) + ""))
        set_data(t1, t1_value);
      if (
        /*item*/
        ctx2[0].replyingTo
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1f(ctx2);
          if_block.c();
          if_block.m(p0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if ((!current || dirty & /*item*/
      1) && t4_value !== (t4_value = (filterPartial(
        /*item*/
        ctx2[0].partialBody
      ) || "(no content)") + ""))
        set_data(t4, t4_value);
      if ((!current || dirty & /*item*/
      1) && t6_value !== (t6_value = dayjs(
        /*item*/
        ctx2[0].timestamp
      ).format("DD-MM HH:mm") + ""))
        set_data(t6, t6_value);
      if (!current || dirty & /*$selectedMessageId, item*/
      9) {
        toggle_class(
          button,
          "selected",
          /*$selectedMessageId*/
          ctx2[3] == /*item*/
          ctx2[0].id
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(profilepicture);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$2O($$self, $$props, $$invalidate) {
  let $selectedMessageId;
  component_subscribe($$self, selectedMessageId, ($$value) => $$invalidate(3, $selectedMessageId = $$value));
  let { item } = $$props;
  let invert = false;
  let userProfile = "";
  onMount(update2);
  messageSubscribe(update2);
  function select() {
    set_store_value(selectedMessageId, $selectedMessageId = item.id, $selectedMessageId);
  }
  async function update2() {
    $$invalidate(2, userProfile = await getUserPfp(invert ? item.receiver : item.sender));
  }
  messagingPage.subscribe((v2) => {
    $$invalidate(1, invert = v2.name == "Sent");
  });
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  return [item, invert, userProfile, $selectedMessageId, select];
}
class MessageItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2O, create_fragment$2Z, safe_not_equal, { item: 0 });
  }
}
function get_each_context$E(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2];
  return child_ctx;
}
function create_if_block$1e(ctx) {
  let div0;
  let p2;
  let span0;
  let t0_value = (
    /*$messagingPage*/
    ctx[2].icon + ""
  );
  let t0;
  let t1;
  let span1;
  let t2_value = (
    /*$messagingPage*/
    ctx[2].name + ""
  );
  let t2;
  let t3;
  let button;
  let t4;
  let t5;
  let div1;
  let t6;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*items*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$E(get_each_context$E(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = !/*items*/
  ctx[0].length && create_if_block_1$j(ctx);
  return {
    c() {
      div0 = element("div");
      p2 = element("p");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      t3 = space();
      button = element("button");
      t4 = text("sync");
      t5 = space();
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t6 = space();
      if (if_block)
        if_block.c();
      attr(span0, "class", "material-icons-round");
      attr(p2, "class", "title");
      attr(button, "class", "material-icons-round refresh");
      button.disabled = /*loading*/
      ctx[1];
      attr(div0, "class", "header");
      attr(div1, "class", "list");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, p2);
      append(p2, span0);
      append(span0, t0);
      append(p2, t1);
      append(p2, span1);
      append(span1, t2);
      append(div0, t3);
      append(div0, button);
      append(button, t4);
      insert(target, t5, anchor);
      insert(target, div1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      append(div1, t6);
      if (if_block)
        if_block.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*refresh*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*$messagingPage*/
      4) && t0_value !== (t0_value = /*$messagingPage*/
      ctx2[2].icon + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & /*$messagingPage*/
      4) && t2_value !== (t2_value = /*$messagingPage*/
      ctx2[2].name + ""))
        set_data(t2, t2_value);
      if (!current || dirty & /*loading*/
      2) {
        button.disabled = /*loading*/
        ctx2[1];
      }
      if (dirty & /*items*/
      1) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$E(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$E(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, t6);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!/*items*/
      ctx2[0].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$j(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t5);
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$E(ctx) {
  let messageitem;
  let current;
  messageitem = new MessageItem({ props: { item: (
    /*item*/
    ctx[5]
  ) } });
  return {
    c() {
      create_component(messageitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(messageitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const messageitem_changes = {};
      if (dirty & /*items*/
      1)
        messageitem_changes.item = /*item*/
        ctx2[5];
      messageitem.$set(messageitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(messageitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(messageitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(messageitem, detaching);
    }
  };
}
function create_if_block_1$j(ctx) {
  let div;
  let t_value = !/*loading*/
  ctx[1] ? "No messages!" : "Loading...";
  let t2;
  return {
    c() {
      div = element("div");
      t2 = text(t_value);
      attr(div, "class", "noitems");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*loading*/
      2 && t_value !== (t_value = !/*loading*/
      ctx2[1] ? "No messages!" : "Loading..."))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$2Y(ctx) {
  let div;
  let current;
  let if_block = (
    /*$messagingPage*/
    ctx[2] && create_if_block$1e(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "listbar");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$messagingPage*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$messagingPage*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1e(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function sort(content2) {
  return content2.sort(function(a2, b2) {
    return new Date(b2.timestamp).getTime() - new Date(a2.timestamp).getTime();
  });
}
function isSame(a2, b2) {
  if (a2.length != b2.length)
    return false;
  for (let i2 = 0; i2 < b2.length; i2++) {
    let exists = false;
    for (let j2 = 0; j2 < a2.length; j2++) {
      if (a2[j2].id == b2[i2].id)
        exists = true;
    }
    if (!exists)
      return false;
  }
  return true;
}
function instance$2N($$self, $$props, $$invalidate) {
  let $messagingPage;
  component_subscribe($$self, messagingPage, ($$value) => $$invalidate(2, $messagingPage = $$value));
  let items = [];
  let loading = false;
  onMount(() => {
    messageUpdateTrigger();
  });
  messagingPage.subscribe(refresh);
  messageSubscribe(refresh);
  async function refresh() {
    $$invalidate(1, loading = true);
    Busy.set(true);
    if (!$messagingPage)
      return;
    const messages = await $messagingPage.msgGetter();
    if (!isSame(items, messages)) {
      set([]);
      await sleep(100);
      set(sort(messages));
    }
    $$invalidate(1, loading = false);
    Busy.set(false);
  }
  function set(messages) {
    $$invalidate(0, items = []);
    setTimeout(() => {
      $$invalidate(0, items = messages);
    });
  }
  return [items, loading, $messagingPage, refresh];
}
class ListBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2N, create_fragment$2Y, safe_not_equal, {});
  }
}
async function sendMessage(receiver, body) {
  const server = get_store_value(ConnectedServer);
  if (!server)
    return false;
  const req = await apiCall(
    server,
    "messages/send",
    { target: toBase64(receiver) },
    get_store_value(UserToken),
    null,
    body
  );
  return req.data.id;
}
async function sendMultipleMessages(receivers, body) {
  for (let i2 = 0; i2 < receivers.length; i2++) {
    try {
      if (!await sendMessage(receivers[i2], body))
        return false;
    } catch {
      return false;
    }
  }
  return true;
}
async function replyToMessage(id, receiver, body) {
  const server = get_store_value(ConnectedServer);
  if (!server)
    return false;
  const req = await apiCall(
    server,
    "messages/reply",
    { target: toBase64(receiver), id },
    get_store_value(UserToken),
    null,
    body
  );
  return !req;
}
function create_fragment$2X(ctx) {
  let button;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text("Delete");
      button.disabled = /*loading*/
      ctx[0];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*cancel*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*loading*/
      1) {
        button.disabled = /*loading*/
        ctx2[0];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2M($$self, $$props, $$invalidate) {
  let { loading } = $$props;
  function cancel() {
    $$invalidate(0, loading = true);
    createOverlayableError(
      {
        title: "Delete message?",
        message: "Are you sure you want to delete this draft? This cannot be undone.",
        image: ErrorIcon,
        buttons: [
          {
            caption: "Delete",
            action: () => {
              creatingMessage.set(false);
              messageUpdateTrigger();
              $$invalidate(0, loading = false);
            },
            suggested: true
          },
          {
            caption: "Cancel",
            action: () => {
              $$invalidate(0, loading = false);
            }
          }
        ]
      },
      "MessagingApp"
    );
  }
  $$self.$$set = ($$props2) => {
    if ("loading" in $$props2)
      $$invalidate(0, loading = $$props2.loading);
  };
  return [loading, cancel];
}
class Cancel2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2M, create_fragment$2X, safe_not_equal, { loading: 0 });
  }
}
function create_if_block$1d(ctx) {
  let div;
  let t_value = 2e3 - /*content*/
  ctx[1].length + "";
  let t2;
  return {
    c() {
      div = element("div");
      t2 = text(t_value);
      attr(div, "class", "counter");
      toggle_class(
        div,
        "critical",
        /*content*/
        ctx[1].length + 5 + /*title*/
        ctx[3].length > 1980
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*content*/
      2 && t_value !== (t_value = 2e3 - /*content*/
      ctx2[1].length + ""))
        set_data(t2, t_value);
      if (dirty & /*content, title*/
      10) {
        toggle_class(
          div,
          "critical",
          /*content*/
          ctx2[1].length + 5 + /*title*/
          ctx2[3].length > 1980
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$2W(ctx) {
  let div2;
  let div0;
  let button0;
  let t1;
  let button1;
  let t3;
  let t4;
  let div1;
  let cancel;
  let updating_loading;
  let t5;
  let button2;
  let t6_value = (
    /*loading*/
    ctx[4] ? "Loading..." : (
      /*$replyMessageId*/
      ctx[5] ? "Reply" : "Send"
    )
  );
  let t6;
  let button2_disabled_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*content*/
    ctx[1].length + 5 + /*title*/
    ctx[3].length > 1950 && create_if_block$1d(ctx)
  );
  function cancel_loading_binding(value) {
    ctx[9](value);
  }
  let cancel_props = {};
  if (
    /*loading*/
    ctx[4] !== void 0
  ) {
    cancel_props.loading = /*loading*/
    ctx[4];
  }
  cancel = new Cancel2({ props: cancel_props });
  binding_callbacks.push(() => bind$1(cancel, "loading", cancel_loading_binding));
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "remove_red_eye";
      t1 = space();
      button1 = element("button");
      button1.textContent = "edit";
      t3 = space();
      if (if_block)
        if_block.c();
      t4 = space();
      div1 = element("div");
      create_component(cancel.$$.fragment);
      t5 = space();
      button2 = element("button");
      t6 = text(t6_value);
      attr(button0, "class", "material-icons-round");
      toggle_class(
        button0,
        "selected",
        /*viewing*/
        ctx[0]
      );
      attr(button1, "class", "material-icons-round");
      toggle_class(button1, "selected", !/*viewing*/
      ctx[0]);
      attr(div0, "class", "view-group");
      button2.disabled = button2_disabled_value = !/*content*/
      ctx[1] || /*loading*/
      ctx[4] || !/*title*/
      ctx[3] || !/*target*/
      ctx[2].length;
      attr(div1, "class", "right");
      attr(div2, "class", "editor-send");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, button0);
      append(div0, t1);
      append(div0, button1);
      append(div2, t3);
      if (if_block)
        if_block.m(div2, null);
      append(div2, t4);
      append(div2, div1);
      mount_component(cancel, div1, null);
      append(div1, t5);
      append(div1, button2);
      append(button2, t6);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*viewer*/
            ctx[8]
          ),
          listen(
            button1,
            "click",
            /*editor*/
            ctx[7]
          ),
          listen(
            button2,
            "click",
            /*send*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*viewing*/
      1) {
        toggle_class(
          button0,
          "selected",
          /*viewing*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*viewing*/
      1) {
        toggle_class(button1, "selected", !/*viewing*/
        ctx2[0]);
      }
      if (
        /*content*/
        ctx2[1].length + 5 + /*title*/
        ctx2[3].length > 1950
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1d(ctx2);
          if_block.c();
          if_block.m(div2, t4);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const cancel_changes = {};
      if (!updating_loading && dirty & /*loading*/
      16) {
        updating_loading = true;
        cancel_changes.loading = /*loading*/
        ctx2[4];
        add_flush_callback(() => updating_loading = false);
      }
      cancel.$set(cancel_changes);
      if ((!current || dirty & /*loading, $replyMessageId*/
      48) && t6_value !== (t6_value = /*loading*/
      ctx2[4] ? "Loading..." : (
        /*$replyMessageId*/
        ctx2[5] ? "Reply" : "Send"
      )))
        set_data(t6, t6_value);
      if (!current || dirty & /*content, loading, title, target*/
      30 && button2_disabled_value !== (button2_disabled_value = !/*content*/
      ctx2[1] || /*loading*/
      ctx2[4] || !/*title*/
      ctx2[3] || !/*target*/
      ctx2[2].length)) {
        button2.disabled = button2_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(cancel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cancel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block)
        if_block.d();
      destroy_component(cancel);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2L($$self, $$props, $$invalidate) {
  let $replyMessageId;
  component_subscribe($$self, replyMessageId, ($$value) => $$invalidate(5, $replyMessageId = $$value));
  let { content: content2 } = $$props;
  let { target } = $$props;
  let { viewing } = $$props;
  let { title } = $$props;
  let loading = false;
  async function send() {
    Busy.set(true);
    $$invalidate(4, loading = true);
    const fullBody = `### ${title}
${content2}`;
    if ($replyMessageId)
      await replyToMessage($replyMessageId, target[0], fullBody);
    else {
      await sendMultipleMessages(target, fullBody);
    }
    creatingMessage.set(false);
    messageUpdateTrigger();
    $$invalidate(4, loading = false);
    Busy.set(false);
  }
  function editor() {
    $$invalidate(0, viewing = false);
  }
  function viewer() {
    $$invalidate(0, viewing = true);
  }
  function cancel_loading_binding(value) {
    loading = value;
    $$invalidate(4, loading);
  }
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(1, content2 = $$props2.content);
    if ("target" in $$props2)
      $$invalidate(2, target = $$props2.target);
    if ("viewing" in $$props2)
      $$invalidate(0, viewing = $$props2.viewing);
    if ("title" in $$props2)
      $$invalidate(3, title = $$props2.title);
  };
  return [
    viewing,
    content2,
    target,
    title,
    loading,
    $replyMessageId,
    send,
    editor,
    viewer,
    cancel_loading_binding
  ];
}
let Bottom$1 = class Bottom3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2L, create_fragment$2W, safe_not_equal, {
      content: 1,
      target: 2,
      viewing: 0,
      title: 3
    });
  }
};
function create_fragment$2V(ctx) {
  let div;
  let profilepicture;
  let t0;
  let p2;
  let t1;
  let t2;
  let button;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: {
      src: (
        /*pfp*/
        ctx[1] || ProfilePictures.def
      ),
      height: 18
    }
  });
  return {
    c() {
      div = element("div");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      p2 = element("p");
      t1 = text(
        /*receiver*/
        ctx[0]
      );
      t2 = space();
      button = element("button");
      button.textContent = "close";
      attr(p2, "class", "name");
      attr(button, "class", "material-icons-round remove");
      attr(div, "class", "receiver-pill");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(profilepicture, div, null);
      append(div, t0);
      append(div, p2);
      append(p2, t1);
      append(div, t2);
      append(div, button);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*remove*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      2)
        profilepicture_changes.src = /*pfp*/
        ctx2[1] || ProfilePictures.def;
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*receiver*/
      1)
        set_data(
          t1,
          /*receiver*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(profilepicture);
      mounted = false;
      dispose();
    }
  };
}
function instance$2K($$self, $$props, $$invalidate) {
  let { receiver } = $$props;
  let { receivers } = $$props;
  let pfp;
  onMount(async () => {
    $$invalidate(1, pfp = await getUserPfp(receiver));
  });
  async function remove() {
    if (!receivers.includes(receiver))
      return;
    receivers.splice(receivers.indexOf(receiver), 1);
    const x2 = [...receivers];
    $$invalidate(3, receivers = []);
    await sleep(0);
    $$invalidate(3, receivers = [...x2]);
  }
  $$self.$$set = ($$props2) => {
    if ("receiver" in $$props2)
      $$invalidate(0, receiver = $$props2.receiver);
    if ("receivers" in $$props2)
      $$invalidate(3, receivers = $$props2.receivers);
  };
  return [receiver, pfp, remove, receivers];
}
class Receiver extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2K, create_fragment$2V, safe_not_equal, { receiver: 0, receivers: 3 });
  }
}
function get_each_context$D(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list2[i2][0];
  child_ctx[7] = list2[i2][1];
  return child_ctx;
}
function get_each_context_1$8(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list2[i2];
  return child_ctx;
}
function create_if_block_2$6(ctx) {
  let div;
  let current;
  let each_value_1 = ensure_array_like(
    /*receivers*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$8(get_each_context_1$8(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "current");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*receivers*/
      1) {
        each_value_1 = ensure_array_like(
          /*receivers*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$8(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$8(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1$8(ctx) {
  let receiver_1;
  let updating_receivers;
  let current;
  function receiver_1_receivers_binding(value) {
    ctx[4](value);
  }
  let receiver_1_props = { receiver: (
    /*receiver*/
    ctx[10]
  ) };
  if (
    /*receivers*/
    ctx[0] !== void 0
  ) {
    receiver_1_props.receivers = /*receivers*/
    ctx[0];
  }
  receiver_1 = new Receiver({ props: receiver_1_props });
  binding_callbacks.push(() => bind$1(receiver_1, "receivers", receiver_1_receivers_binding));
  return {
    c() {
      create_component(receiver_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(receiver_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const receiver_1_changes = {};
      if (dirty & /*receivers*/
      1)
        receiver_1_changes.receiver = /*receiver*/
        ctx2[10];
      if (!updating_receivers && dirty & /*receivers*/
      1) {
        updating_receivers = true;
        receiver_1_changes.receivers = /*receivers*/
        ctx2[0];
        add_flush_callback(() => updating_receivers = false);
      }
      receiver_1.$set(receiver_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(receiver_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(receiver_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(receiver_1, detaching);
    }
  };
}
function create_if_block$1c(ctx) {
  let select;
  let option;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*users*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$D(get_each_context$D(ctx, each_value, i2));
  }
  return {
    c() {
      select = element("select");
      option = element("option");
      option.textContent = "Add...";
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      option.__value = "none";
      set_input_value(option, option.__value);
      option.disabled = true;
      option.selected = true;
      attr(select, "class", "adder");
      if (
        /*input*/
        ctx[2] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[5].call(select)
        ));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      append(select, option);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(
        select,
        /*input*/
        ctx[2],
        true
      );
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[5]
          ),
          listen(
            select,
            "change",
            /*add*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*users, receivers*/
      3) {
        each_value = ensure_array_like(
          /*users*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$D(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$D(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*input, users*/
      6) {
        select_option(
          select,
          /*input*/
          ctx2[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$i(ctx) {
  let option;
  let t_value = (
    /*name*/
    ctx[6] + ""
  );
  let t2;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t2 = text(t_value);
      option.__value = option_value_value = /*name*/
      ctx[6];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*users*/
      2 && t_value !== (t_value = /*name*/
      ctx2[6] + ""))
        set_data(t2, t_value);
      if (dirty & /*users*/
      2 && option_value_value !== (option_value_value = /*name*/
      ctx2[6])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block$D(ctx) {
  let show_if = !/*receivers*/
  ctx[0].includes(
    /*name*/
    ctx[6]
  );
  let if_block_anchor;
  let if_block = show_if && create_if_block_1$i(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*receivers, users*/
      3)
        show_if = !/*receivers*/
        ctx2[0].includes(
          /*name*/
          ctx2[6]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$i(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$2U(ctx) {
  let div1;
  let p2;
  let t1;
  let div0;
  let t2;
  let current;
  let if_block0 = (
    /*receivers*/
    ctx[0].length && create_if_block_2$6(ctx)
  );
  let if_block1 = (
    /*users*/
    ctx[1].length !== /*receivers*/
    ctx[0].length && create_if_block$1c(ctx)
  );
  return {
    c() {
      div1 = element("div");
      p2 = element("p");
      p2.textContent = "Recipients";
      t1 = space();
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      attr(p2, "class", "caption");
      attr(div1, "class", "opt receivers");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, p2);
      append(div1, t1);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t2);
      if (if_block1)
        if_block1.m(div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*receivers*/
        ctx2[0].length
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*receivers*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$6(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*users*/
        ctx2[1].length !== /*receivers*/
        ctx2[0].length
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$1c(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance$2J($$self, $$props, $$invalidate) {
  let { users } = $$props;
  let { receivers } = $$props;
  async function add() {
    if (input == "none")
      return;
    receivers.push(input);
    const x2 = [...receivers];
    $$invalidate(0, receivers = []);
    await sleep(0);
    $$invalidate(0, receivers = [...x2]);
    $$invalidate(2, input = "none");
  }
  let input;
  function receiver_1_receivers_binding(value) {
    receivers = value;
    $$invalidate(0, receivers);
  }
  function select_change_handler() {
    input = select_value(this);
    $$invalidate(2, input);
    $$invalidate(1, users);
  }
  $$self.$$set = ($$props2) => {
    if ("users" in $$props2)
      $$invalidate(1, users = $$props2.users);
    if ("receivers" in $$props2)
      $$invalidate(0, receivers = $$props2.receivers);
  };
  return [
    receivers,
    users,
    input,
    add,
    receiver_1_receivers_binding,
    select_change_handler
  ];
}
class Receivers extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2J, create_fragment$2U, safe_not_equal, { users: 1, receivers: 0 });
  }
}
function create_fragment$2T(ctx) {
  let div;
  let p2;
  let t1;
  let form;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      p2 = element("p");
      p2.textContent = "Title";
      t1 = space();
      form = element("form");
      input = element("input");
      attr(p2, "class", "caption");
      attr(input, "type", "text");
      attr(input, "autocomplete", "new-password");
      attr(input, "placeholder", "Something very important...");
      attr(form, "autocomplete", "off");
      attr(div, "class", "opt title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p2);
      append(div, t1);
      append(div, form);
      append(form, input);
      set_input_value(
        input,
        /*title*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[1]
          ),
          listen(form, "submit", submit)
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*title*/
      1 && input.value !== /*title*/
      ctx2[0]) {
        set_input_value(
          input,
          /*title*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function submit(e2) {
  e2.preventDefault();
}
function instance$2I($$self, $$props, $$invalidate) {
  let { title } = $$props;
  function input_input_handler() {
    title = this.value;
    $$invalidate(0, title);
  }
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
  };
  return [title, input_input_handler];
}
class Title extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2I, create_fragment$2T, safe_not_equal, { title: 0 });
  }
}
function create_fragment$2S(ctx) {
  let div;
  let title_1;
  let updating_title;
  let t2;
  let receivers;
  let updating_receivers;
  let current;
  function title_1_title_binding(value) {
    ctx[3](value);
  }
  let title_1_props = {};
  if (
    /*title*/
    ctx[0] !== void 0
  ) {
    title_1_props.title = /*title*/
    ctx[0];
  }
  title_1 = new Title({ props: title_1_props });
  binding_callbacks.push(() => bind$1(title_1, "title", title_1_title_binding));
  function receivers_receivers_binding(value) {
    ctx[4](value);
  }
  let receivers_props = { users: (
    /*users*/
    ctx[2]
  ) };
  if (
    /*target*/
    ctx[1] !== void 0
  ) {
    receivers_props.receivers = /*target*/
    ctx[1];
  }
  receivers = new Receivers({ props: receivers_props });
  binding_callbacks.push(() => bind$1(receivers, "receivers", receivers_receivers_binding));
  return {
    c() {
      div = element("div");
      create_component(title_1.$$.fragment);
      t2 = space();
      create_component(receivers.$$.fragment);
      attr(div, "class", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(title_1, div, null);
      append(div, t2);
      mount_component(receivers, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const title_1_changes = {};
      if (!updating_title && dirty & /*title*/
      1) {
        updating_title = true;
        title_1_changes.title = /*title*/
        ctx2[0];
        add_flush_callback(() => updating_title = false);
      }
      title_1.$set(title_1_changes);
      const receivers_changes = {};
      if (dirty & /*users*/
      4)
        receivers_changes.users = /*users*/
        ctx2[2];
      if (!updating_receivers && dirty & /*target*/
      2) {
        updating_receivers = true;
        receivers_changes.receivers = /*target*/
        ctx2[1];
        add_flush_callback(() => updating_receivers = false);
      }
      receivers.$set(receivers_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(title_1.$$.fragment, local);
      transition_in(receivers.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(title_1.$$.fragment, local);
      transition_out(receivers.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(title_1);
      destroy_component(receivers);
    }
  };
}
function instance$2H($$self, $$props, $$invalidate) {
  let { title } = $$props;
  let { target } = $$props;
  let { users } = $$props;
  function title_1_title_binding(value) {
    title = value;
    $$invalidate(0, title);
  }
  function receivers_receivers_binding(value) {
    target = value;
    $$invalidate(1, target);
  }
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("target" in $$props2)
      $$invalidate(1, target = $$props2.target);
    if ("users" in $$props2)
      $$invalidate(2, users = $$props2.users);
  };
  return [title, target, users, title_1_title_binding, receivers_receivers_binding];
}
let Header$2 = class Header2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2H, create_fragment$2S, safe_not_equal, { title: 0, target: 1, users: 2 });
  }
};
function create_else_block$m(ctx) {
  let div;
  let sveltemarkdown;
  let current;
  sveltemarkdown = new SvelteMarkdown({ props: { source: (
    /*content*/
    ctx[2]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(sveltemarkdown.$$.fragment);
      attr(div, "class", "markdownrenderer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(sveltemarkdown, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const sveltemarkdown_changes = {};
      if (dirty & /*content*/
      4)
        sveltemarkdown_changes.source = /*content*/
        ctx2[2];
      sveltemarkdown.$set(sveltemarkdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sveltemarkdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sveltemarkdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(sveltemarkdown);
    }
  };
}
function create_if_block$1b(ctx) {
  let textarea;
  let textarea_maxlength_value;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "placeholder", "New message");
      attr(textarea, "maxlength", textarea_maxlength_value = 2e3 - 4 - /*title*/
      ctx[3].length);
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      set_input_value(
        textarea,
        /*content*/
        ctx[2]
      );
      if (!mounted) {
        dispose = listen(
          textarea,
          "input",
          /*textarea_input_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*title*/
      8 && textarea_maxlength_value !== (textarea_maxlength_value = 2e3 - 4 - /*title*/
      ctx2[3].length)) {
        attr(textarea, "maxlength", textarea_maxlength_value);
      }
      if (dirty & /*content*/
      4) {
        set_input_value(
          textarea,
          /*content*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(textarea);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2R(ctx) {
  let div;
  let header2;
  let updating_target;
  let updating_title;
  let t0;
  let current_block_type_index;
  let if_block;
  let t1;
  let bottom;
  let updating_viewing;
  let current;
  function header_target_binding(value) {
    ctx[5](value);
  }
  function header_title_binding(value) {
    ctx[6](value);
  }
  let header_props = { users: (
    /*users*/
    ctx[0]
  ) };
  if (
    /*target*/
    ctx[1] !== void 0
  ) {
    header_props.target = /*target*/
    ctx[1];
  }
  if (
    /*title*/
    ctx[3] !== void 0
  ) {
    header_props.title = /*title*/
    ctx[3];
  }
  header2 = new Header$2({ props: header_props });
  binding_callbacks.push(() => bind$1(header2, "target", header_target_binding));
  binding_callbacks.push(() => bind$1(header2, "title", header_title_binding));
  const if_block_creators = [create_if_block$1b, create_else_block$m];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*viewing*/
    ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function bottom_viewing_binding(value) {
    ctx[8](value);
  }
  let bottom_props = {
    target: (
      /*target*/
      ctx[1]
    ),
    content: (
      /*content*/
      ctx[2]
    ),
    title: (
      /*title*/
      ctx[3]
    )
  };
  if (
    /*viewing*/
    ctx[4] !== void 0
  ) {
    bottom_props.viewing = /*viewing*/
    ctx[4];
  }
  bottom = new Bottom$1({ props: bottom_props });
  binding_callbacks.push(() => bind$1(bottom, "viewing", bottom_viewing_binding));
  return {
    c() {
      div = element("div");
      create_component(header2.$$.fragment);
      t0 = space();
      if_block.c();
      t1 = space();
      create_component(bottom.$$.fragment);
      attr(div, "class", "editor");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(header2, div, null);
      insert(target, t0, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t1, anchor);
      mount_component(bottom, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const header_changes = {};
      if (dirty & /*users*/
      1)
        header_changes.users = /*users*/
        ctx2[0];
      if (!updating_target && dirty & /*target*/
      2) {
        updating_target = true;
        header_changes.target = /*target*/
        ctx2[1];
        add_flush_callback(() => updating_target = false);
      }
      if (!updating_title && dirty & /*title*/
      8) {
        updating_title = true;
        header_changes.title = /*title*/
        ctx2[3];
        add_flush_callback(() => updating_title = false);
      }
      header2.$set(header_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t1.parentNode, t1);
      }
      const bottom_changes = {};
      if (dirty & /*target*/
      2)
        bottom_changes.target = /*target*/
        ctx2[1];
      if (dirty & /*content*/
      4)
        bottom_changes.content = /*content*/
        ctx2[2];
      if (dirty & /*title*/
      8)
        bottom_changes.title = /*title*/
        ctx2[3];
      if (!updating_viewing && dirty & /*viewing*/
      16) {
        updating_viewing = true;
        bottom_changes.viewing = /*viewing*/
        ctx2[4];
        add_flush_callback(() => updating_viewing = false);
      }
      bottom.$set(bottom_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(if_block);
      transition_in(bottom.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(if_block);
      transition_out(bottom.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t0);
        detach(t1);
      }
      destroy_component(header2);
      if_blocks[current_block_type_index].d(detaching);
      destroy_component(bottom, detaching);
    }
  };
}
function instance$2G($$self, $$props, $$invalidate) {
  let users = [];
  let target = [];
  let content2 = "";
  let title = "";
  let viewing = false;
  onMount(async () => {
    $$invalidate(0, users = Object.entries(await getUsers()));
  });
  replyMessageId.subscribe(async (v2) => {
    if (!v2)
      return;
    const message = await getMessage(v2);
    if (!message)
      return;
    $$invalidate(1, target = [message.sender]);
  });
  function header_target_binding(value) {
    target = value;
    $$invalidate(1, target);
  }
  function header_title_binding(value) {
    title = value;
    $$invalidate(3, title);
  }
  function textarea_input_handler() {
    content2 = this.value;
    $$invalidate(2, content2);
  }
  function bottom_viewing_binding(value) {
    viewing = value;
    $$invalidate(4, viewing);
  }
  return [
    users,
    target,
    content2,
    title,
    viewing,
    header_target_binding,
    header_title_binding,
    textarea_input_handler,
    bottom_viewing_binding
  ];
}
class Editor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2G, create_fragment$2R, safe_not_equal, {});
  }
}
function create_fragment$2Q(ctx) {
  let div1;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let p0;
  let t2;
  let p1;
  let t4;
  let br;
  let t5;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      p0 = element("p");
      p0.textContent = "No content.";
      t2 = space();
      p1 = element("p");
      p1.textContent = "Please select a message or create a new one.";
      t4 = space();
      br = element("br");
      t5 = space();
      button = element("button");
      button.textContent = "New Message";
      if (!src_url_equal(img.src, img_src_value = MessagingIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "Messaging");
      attr(p0, "class", "header");
      attr(div0, "class", "no-content");
      attr(div1, "class", "no-content-wrapper");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, img);
      append(div0, t0);
      append(div0, p0);
      append(div0, t2);
      append(div0, p1);
      append(div0, t4);
      append(div0, br);
      append(div0, t5);
      append(div0, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*newMessage*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2F($$self, $$props, $$invalidate) {
  let $creatingMessage;
  component_subscribe($$self, creatingMessage, ($$value) => $$invalidate(1, $creatingMessage = $$value));
  function newMessage() {
    set_store_value(creatingMessage, $creatingMessage = true, $creatingMessage);
  }
  return [newMessage];
}
class NoContent extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2F, create_fragment$2Q, safe_not_equal, {});
  }
}
const content = "";
function get_each_context$C(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  return child_ctx;
}
function create_if_block$1a(ctx) {
  let button;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<img src="${ErrorIcon}" alt=""/>`;
      attr(button, "class", "material-icons-round");
      attr(button, "title", "Receiver no longer exists");
    },
    m(target, anchor) {
      insert(target, button, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
    }
  };
}
function create_each_block$C(ctx) {
  let button;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[3](
        /*action*/
        ctx[4]
      )
    );
  }
  return {
    c() {
      button = element("button");
      button.textContent = `${/*action*/
      ctx[4].icon}`;
      attr(button, "class", "material-icons-round");
      attr(
        button,
        "title",
        /*action*/
        ctx[4].name
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2P(ctx) {
  let div2;
  let profilepicture;
  let t0;
  let div0;
  let p0;
  let t1_value = (
    /*message*/
    ctx[0].sender + ""
  );
  let t1;
  let t2;
  let p1;
  let t3_value = (
    /*getTimestamp*/
    ctx[2](
      /*message*/
      ctx[0].timestamp
    ) + ""
  );
  let t3;
  let t4;
  let div1;
  let show_if = (
    /*message*/
    ctx[0].receiver.startsWith("deleted#")
  );
  let t5;
  let current;
  profilepicture = new ProfilePicture({
    props: { height: 32, src: (
      /*userProfile*/
      ctx[1]
    ) }
  });
  let if_block = show_if && create_if_block$1a();
  let each_value = ensure_array_like(messageItemActions);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$C(get_each_context$C(ctx, each_value, i2));
  }
  return {
    c() {
      div2 = element("div");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      div0 = element("div");
      p0 = element("p");
      t1 = text(t1_value);
      t2 = space();
      p1 = element("p");
      t3 = text(t3_value);
      t4 = space();
      div1 = element("div");
      if (if_block)
        if_block.c();
      t5 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(p0, "class", "name");
      attr(p1, "class", "id");
      attr(div0, "class", "context");
      attr(div1, "class", "actions");
      attr(div2, "class", "message-header");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(profilepicture, div2, null);
      append(div2, t0);
      append(div2, div0);
      append(div0, p0);
      append(p0, t1);
      append(div0, t2);
      append(div0, p1);
      append(p1, t3);
      append(div2, t4);
      append(div2, div1);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t5);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*userProfile*/
      2)
        profilepicture_changes.src = /*userProfile*/
        ctx2[1];
      profilepicture.$set(profilepicture_changes);
      if ((!current || dirty & /*message*/
      1) && t1_value !== (t1_value = /*message*/
      ctx2[0].sender + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & /*message*/
      1) && t3_value !== (t3_value = /*getTimestamp*/
      ctx2[2](
        /*message*/
        ctx2[0].timestamp
      ) + ""))
        set_data(t3, t3_value);
      if (dirty & /*message*/
      1)
        show_if = /*message*/
        ctx2[0].receiver.startsWith("deleted#");
      if (show_if) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$1a();
          if_block.c();
          if_block.m(div1, t5);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*message*/
      1) {
        each_value = ensure_array_like(messageItemActions);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$C(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$C(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div1, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(profilepicture);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$2E($$self, $$props, $$invalidate) {
  let { message } = $$props;
  let userProfile = "";
  onMount(async () => {
    $$invalidate(1, userProfile = await getUserPfp(message.sender));
  });
  messageSubscribe(async () => {
    $$invalidate(1, userProfile = await getUserPfp(message.sender));
  });
  function getTimestamp(ts) {
    return dayjs(ts).format("DD MMM, HH:mm");
  }
  const click_handler = (action) => action.action(message);
  $$self.$$set = ($$props2) => {
    if ("message" in $$props2)
      $$invalidate(0, message = $$props2.message);
  };
  return [message, userProfile, getTimestamp, click_handler];
}
let Header$1 = class Header3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2E, create_fragment$2P, safe_not_equal, { message: 0 });
  }
};
async function getPartialTree(id) {
  const server = get_store_value(ConnectedServer);
  if (!server)
    return false;
  const req = await apiCall(
    server,
    "messages/thread",
    { id: toBase64(id) },
    get_store_value(UserToken)
  );
  const message = req.data;
  return message;
}
async function getParentMessage(id) {
  const messages = await getMessages();
  let replier;
  for (let i2 = 0; i2 < messages.length; i2++) {
    if (messages[i2].id == id)
      replier = messages[i2].replyingTo;
  }
  if (!replier)
    return;
  const parent = await getMessage(replier);
  if (parent.replyingTo)
    return await getParentMessage(replier);
  return parent;
}
function create_if_block$19(ctx) {
  let div1;
  let p2;
  let t1;
  let div0;
  let button;
  let t2_value = (
    /*threadLoading*/
    ctx[1] ? "Loading..." : "View Thread"
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      p2 = element("p");
      p2.textContent = "Message is part of a thread.";
      t1 = space();
      div0 = element("div");
      button = element("button");
      t2 = text(t2_value);
      attr(p2, "class", "caption");
      button.disabled = /*threadLoading*/
      ctx[1];
      attr(div0, "class", "right");
      attr(div1, "class", "reply-wrapper");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, p2);
      append(div1, t1);
      append(div1, div0);
      append(div0, button);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*openThread*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*threadLoading*/
      2 && t2_value !== (t2_value = /*threadLoading*/
      ctx2[1] ? "Loading..." : "View Thread"))
        set_data(t2, t2_value);
      if (dirty & /*threadLoading*/
      2) {
        button.disabled = /*threadLoading*/
        ctx2[1];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2O(ctx) {
  let if_block_anchor;
  let if_block = (
    /*message*/
    (ctx[0].replyingTo || /*message*/
    ctx[0].replies.length) && create_if_block$19(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*message*/
        ctx2[0].replyingTo || /*message*/
        ctx2[0].replies.length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$19(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$2D($$self, $$props, $$invalidate) {
  let { message } = $$props;
  let threadLoading = false;
  async function openThread() {
    $$invalidate(1, threadLoading = true);
    const id = message.replies && !message.replyingTo ? message.id : (await getParentMessage(message.id)).id;
    threadMessageId.set(null);
    threadMessageId.set(id);
    showOverlay("thread", "MessagingApp");
    $$invalidate(1, threadLoading = false);
  }
  $$self.$$set = ($$props2) => {
    if ("message" in $$props2)
      $$invalidate(0, message = $$props2.message);
  };
  return [message, threadLoading, openThread];
}
class ThreadNote extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2D, create_fragment$2O, safe_not_equal, { message: 0 });
  }
}
function create_fragment$2N(ctx) {
  let header2;
  let t0;
  let div;
  let sveltemarkdown;
  let t1;
  let threadnote;
  let current;
  header2 = new Header$1({ props: { message: (
    /*message*/
    ctx[0]
  ) } });
  sveltemarkdown = new SvelteMarkdown({
    props: { source: (
      /*message*/
      ctx[0].body
    ) }
  });
  threadnote = new ThreadNote({ props: { message: (
    /*message*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(header2.$$.fragment);
      t0 = space();
      div = element("div");
      create_component(sveltemarkdown.$$.fragment);
      t1 = space();
      create_component(threadnote.$$.fragment);
      attr(div, "class", "markdownrenderer");
    },
    m(target, anchor) {
      mount_component(header2, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      mount_component(sveltemarkdown, div, null);
      insert(target, t1, anchor);
      mount_component(threadnote, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const header_changes = {};
      if (dirty & /*message*/
      1)
        header_changes.message = /*message*/
        ctx2[0];
      header2.$set(header_changes);
      const sveltemarkdown_changes = {};
      if (dirty & /*message*/
      1)
        sveltemarkdown_changes.source = /*message*/
        ctx2[0].body;
      sveltemarkdown.$set(sveltemarkdown_changes);
      const threadnote_changes = {};
      if (dirty & /*message*/
      1)
        threadnote_changes.message = /*message*/
        ctx2[0];
      threadnote.$set(threadnote_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(sveltemarkdown.$$.fragment, local);
      transition_in(threadnote.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(sveltemarkdown.$$.fragment, local);
      transition_out(threadnote.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t1);
      }
      destroy_component(header2, detaching);
      destroy_component(sveltemarkdown);
      destroy_component(threadnote, detaching);
    }
  };
}
function instance$2C($$self, $$props, $$invalidate) {
  let { message } = $$props;
  $$self.$$set = ($$props2) => {
    if ("message" in $$props2)
      $$invalidate(0, message = $$props2.message);
  };
  return [message];
}
class Viewer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2C, create_fragment$2N, safe_not_equal, { message: 0 });
  }
}
function create_else_block$l(ctx) {
  let nocontent;
  let current;
  nocontent = new NoContent({});
  return {
    c() {
      create_component(nocontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nocontent, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(nocontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nocontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nocontent, detaching);
    }
  };
}
function create_if_block_1$h(ctx) {
  let editor;
  let current;
  editor = new Editor({});
  return {
    c() {
      create_component(editor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editor, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(editor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editor, detaching);
    }
  };
}
function create_if_block$18(ctx) {
  let viewer;
  let current;
  viewer = new Viewer({ props: { message: (
    /*message*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(viewer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewer_changes = {};
      if (dirty & /*message*/
      1)
        viewer_changes.message = /*message*/
        ctx2[0];
      viewer.$set(viewer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewer, detaching);
    }
  };
}
function create_fragment$2M(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$18, create_if_block_1$h, create_else_block$l];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*message*/
      ctx2[0] && !/*$creatingMessage*/
      ctx2[1]
    )
      return 0;
    if (
      /*$creatingMessage*/
      ctx2[1]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$2B($$self, $$props, $$invalidate) {
  let $creatingMessage;
  component_subscribe($$self, creatingMessage, ($$value) => $$invalidate(1, $creatingMessage = $$value));
  let message;
  selectedMessageId.subscribe(async (v2) => {
    if (!v2)
      return $$invalidate(0, message = null);
    const msg = await getMessage(v2);
    if (!msg)
      return createOverlayableError(
        {
          title: "Can't open message",
          message: `No message with ID ${v2} could be found on ArcAPI.`,
          buttons: [
            {
              caption: "OK",
              action() {
              },
              suggested: true
            }
          ],
          image: MessagingIcon
        },
        "MessagingApp"
      );
    $$invalidate(0, message = null);
    setTimeout(() => {
      $$invalidate(0, message = msg);
    });
  });
  return [message, $creatingMessage];
}
let Content$2 = class Content3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2B, create_fragment$2M, safe_not_equal, {});
  }
};
function create_if_block$17(ctx) {
  let listbar;
  let t2;
  let content2;
  let current;
  listbar = new ListBar({});
  content2 = new Content$2({});
  return {
    c() {
      create_component(listbar.$$.fragment);
      t2 = space();
      create_component(content2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(listbar, target, anchor);
      insert(target, t2, anchor);
      mount_component(content2, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(listbar.$$.fragment, local);
      transition_in(content2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(listbar.$$.fragment, local);
      transition_out(content2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(listbar, detaching);
      destroy_component(content2, detaching);
    }
  };
}
function create_fragment$2L(ctx) {
  let sidebar;
  let t2;
  let if_block_anchor;
  let current;
  sidebar = new SideBar$1({});
  let if_block = (
    /*$messagingPage*/
    ctx[0] && create_if_block$17()
  );
  return {
    c() {
      create_component(sidebar.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(sidebar, target, anchor);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$messagingPage*/
        ctx2[0]
      ) {
        if (if_block) {
          if (dirty & /*$messagingPage*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$17();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(sidebar, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$2A($$self, $$props, $$invalidate) {
  let $messagingPage;
  component_subscribe($$self, messagingPage, ($$value) => $$invalidate(0, $messagingPage = $$value));
  onMount(() => {
    set_store_value(messagingPage, $messagingPage = MessagingPages["inbox"], $messagingPage);
  });
  return [$messagingPage];
}
let MessagingApp$1 = class MessagingApp extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2A, create_fragment$2L, safe_not_equal, {});
  }
};
const thread = "";
function get_each_context$B(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2];
  return child_ctx;
}
function create_if_block$16(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*items*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$B(get_each_context$B(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*items*/
      1) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$B(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$B(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$B(ctx) {
  let item_1;
  let current;
  item_1 = new Item$2({ props: { item: (
    /*item*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(item_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(item_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const item_1_changes = {};
      if (dirty & /*items*/
      1)
        item_1_changes.item = /*item*/
        ctx2[1];
      item_1.$set(item_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(item_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(item_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(item_1, detaching);
    }
  };
}
function create_fragment$2K(ctx) {
  let div;
  let current;
  let if_block = (
    /*items*/
    ctx[0] && create_if_block$16(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "branch");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*items*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*items*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$16(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$2z($$self, $$props, $$invalidate) {
  let { items = [] } = $$props;
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
  };
  return [items];
}
class Branch extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2z, create_fragment$2K, safe_not_equal, { items: 0 });
  }
}
function create_if_block$15(ctx) {
  let button;
  let profilepicture;
  let t0;
  let div0;
  let p0;
  let t1_value = (
    /*item*/
    ctx[0].sender + ""
  );
  let t1;
  let t2;
  let p1;
  let t3_value = filterPartial(
    /*item*/
    ctx[0].partialBody
  ) + "";
  let t3;
  let t4_value = (
    /*item*/
    ctx[0].partialBody.length > 29 ? "..." : ""
  );
  let t4;
  let t5;
  let div1;
  let t6_value = (
    /*item*/
    ctx[0].id + ""
  );
  let t6;
  let t7;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*pfp*/
      ctx[1]
    ), height: 32 }
  });
  let if_block = (
    /*item*/
    ctx[0].replies && create_if_block_1$g(ctx)
  );
  return {
    c() {
      button = element("button");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      div0 = element("div");
      p0 = element("p");
      t1 = text(t1_value);
      t2 = space();
      p1 = element("p");
      t3 = text(t3_value);
      t4 = text(t4_value);
      t5 = space();
      div1 = element("div");
      t6 = text(t6_value);
      t7 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(p0, "class", "name");
      attr(p1, "class", "partial");
      attr(div0, "class", "context");
      attr(div1, "class", "id");
      attr(button, "class", "item");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(profilepicture, button, null);
      append(button, t0);
      append(button, div0);
      append(div0, p0);
      append(p0, t1);
      append(div0, t2);
      append(div0, p1);
      append(p1, t3);
      append(p1, t4);
      append(button, t5);
      append(button, div1);
      append(div1, t6);
      insert(target, t7, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*openThis*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      2)
        profilepicture_changes.src = /*pfp*/
        ctx2[1];
      profilepicture.$set(profilepicture_changes);
      if ((!current || dirty & /*item*/
      1) && t1_value !== (t1_value = /*item*/
      ctx2[0].sender + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & /*item*/
      1) && t3_value !== (t3_value = filterPartial(
        /*item*/
        ctx2[0].partialBody
      ) + ""))
        set_data(t3, t3_value);
      if ((!current || dirty & /*item*/
      1) && t4_value !== (t4_value = /*item*/
      ctx2[0].partialBody.length > 29 ? "..." : ""))
        set_data(t4, t4_value);
      if ((!current || dirty & /*item*/
      1) && t6_value !== (t6_value = /*item*/
      ctx2[0].id + ""))
        set_data(t6, t6_value);
      if (
        /*item*/
        ctx2[0].replies
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$g(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
        detach(t7);
        detach(if_block_anchor);
      }
      destroy_component(profilepicture);
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$g(ctx) {
  let branch;
  let current;
  branch = new Branch({
    props: { items: (
      /*item*/
      ctx[0].replies
    ) }
  });
  return {
    c() {
      create_component(branch.$$.fragment);
    },
    m(target, anchor) {
      mount_component(branch, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const branch_changes = {};
      if (dirty & /*item*/
      1)
        branch_changes.items = /*item*/
        ctx2[0].replies;
      branch.$set(branch_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(branch.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(branch.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(branch, detaching);
    }
  };
}
function create_fragment$2J(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*item*/
    ctx[0] && create_if_block$15(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*item*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$15(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$2y($$self, $$props, $$invalidate) {
  let $selectedMessageId;
  component_subscribe($$self, selectedMessageId, ($$value) => $$invalidate(3, $selectedMessageId = $$value));
  let { item } = $$props;
  let pfp = "";
  onMount(async () => {
    $$invalidate(1, pfp = await getUserPfp(item.sender));
  });
  async function openThis() {
    set_store_value(selectedMessageId, $selectedMessageId = item.id, $selectedMessageId);
    hideOverlay("thread", "MessagingApp");
    await sleep(1e3);
    threadMessageId.set(null);
  }
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  return [item, pfp, openThis];
}
let Item$2 = class Item extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2y, create_fragment$2J, safe_not_equal, { item: 0 });
  }
};
function create_fragment$2I(ctx) {
  let div1;
  return {
    c() {
      div1 = element("div");
      div1.innerHTML = `<div class="content"><img src="${ErrorIcon}" alt="Error"/> <h3>Unable to load thread</h3> <p class="caption">The thread could not be found. Please make sure the owner exists and try
      again.</p></div>`;
      attr(div1, "class", "notfound");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
    }
  };
}
class NotFound2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$2I, safe_not_equal, {});
  }
}
function create_if_block_1$f(ctx) {
  let notfound;
  let current;
  notfound = new NotFound2({});
  return {
    c() {
      create_component(notfound.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notfound, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(notfound.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notfound.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notfound, detaching);
    }
  };
}
function create_if_block$14(ctx) {
  let h3;
  let t0;
  let t1_value = (
    /*thread*/
    ctx[2].id + ""
  );
  let t1;
  let t2;
  let item;
  let current;
  item = new Item$2({ props: { item: (
    /*thread*/
    ctx[2]
  ) } });
  return {
    c() {
      h3 = element("h3");
      t0 = text("Thread of #");
      t1 = text(t1_value);
      t2 = space();
      create_component(item.$$.fragment);
      attr(h3, "class", "header");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t0);
      append(h3, t1);
      insert(target, t2, anchor);
      mount_component(item, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*thread*/
      4) && t1_value !== (t1_value = /*thread*/
      ctx2[2].id + ""))
        set_data(t1, t1_value);
      const item_changes = {};
      if (dirty & /*thread*/
      4)
        item_changes.item = /*thread*/
        ctx2[2];
      item.$set(item_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(item.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(item.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t2);
      }
      destroy_component(item, detaching);
    }
  };
}
function create_fragment$2H(ctx) {
  let closebutton;
  let t2;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  closebutton = new CloseButton({
    props: { app: (
      /*app*/
      ctx[0]
    ), id: (
      /*id*/
      ctx[1]
    ) }
  });
  const if_block_creators = [create_if_block$14, create_if_block_1$f];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$threadMessageId*/
      ctx2[4] && /*thread*/
      ctx2[2]
    )
      return 0;
    if (!/*loading*/
    ctx2[3])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      create_component(closebutton.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(closebutton, target, anchor);
      insert(target, t2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const closebutton_changes = {};
      if (dirty & /*app*/
      1)
        closebutton_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*id*/
      2)
        closebutton_changes.id = /*id*/
        ctx2[1];
      closebutton.$set(closebutton_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(closebutton.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(closebutton.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(closebutton, detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function instance$2x($$self, $$props, $$invalidate) {
  let $threadMessageId;
  component_subscribe($$self, threadMessageId, ($$value) => $$invalidate(4, $threadMessageId = $$value));
  let thread2;
  let { app } = $$props;
  let { id } = $$props;
  let loading = true;
  threadMessageId.subscribe(async (v2) => {
    if (!v2)
      return;
    $$invalidate(3, loading = true);
    $$invalidate(2, thread2 = null);
    const th = await getPartialTree($threadMessageId);
    $$invalidate(3, loading = false);
    if (!th)
      return;
    $$invalidate(2, thread2 = th);
  });
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
  };
  return [app, id, thread2, loading, $threadMessageId];
}
class Thread extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2x, create_fragment$2H, safe_not_equal, { app: 0, id: 1 });
  }
}
const overlays = {
  thread: {
    info: {
      name: "Thread View",
      author: "ArcOS Team",
      version: "1.0.0"
    },
    size: { w: 550, h: 400 },
    show: false,
    content: Thread
  }
};
const MessagingApp2 = {
  info: {
    name: "Messaging",
    description: "Send messages to other ArcOS users",
    builtin: true,
    version: "1.0.7",
    author: "ArcOS Team",
    icon: MessagingIcon,
    appGroup: "communication"
  },
  size: { w: 700, h: 450 },
  pos: { x: 100, y: 100 },
  minSize: { w: 700, h: 450 },
  maxSize: { w: 1e3, h: 600 },
  controls: { min: true, max: true, cls: true },
  state: {
    headless: false,
    resizable: true,
    windowState: { min: false, max: false, fll: false }
  },
  overlays,
  content: MessagingApp$1,
  glass: true
};
const textview = "";
const chooseTargets = writable({});
function setTargetFile(id, file) {
  const targets = get_store_value(chooseTargets);
  const targetId = targets[id];
  WindowStore.update((ws) => {
    let index = null;
    for (let i2 = 0; i2 < ws.length; i2++) {
      if (ws[i2].id == targetId)
        index = i2;
    }
    if (index == null)
      return ws;
    ws[index].openedFile = file;
    if (ws[index].events && ws[index].events.openFile)
      ws[index].events.openFile(ws[index]);
    delete ws[index].overlays[id];
    return ws;
  });
  delete targets[id];
  chooseTargets.set(targets);
  return true;
}
function getChooserTarget(id) {
  const targets = get_store_value(chooseTargets);
  return targets[id] || false;
}
function assignTarget(id, targetId) {
  const targets = get_store_value(chooseTargets);
  if (targets[id])
    return false;
  targets[id] = targetId;
  chooseTargets.set(targets);
  return true;
}
function create_fragment$2G(ctx) {
  let div1;
  let div0;
  let button0;
  let t1;
  let button1;
  let t2;
  let button1_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "Cancel";
      t1 = space();
      button1 = element("button");
      t2 = text("Open");
      attr(button0, "class", "cancel");
      attr(button1, "class", "confirm");
      button1.disabled = button1_disabled_value = !/*$currentPath*/
      ctx[5] || !/*$selected*/
      ctx[4];
      attr(div0, "class", "buttons");
      attr(div1, "class", "bottompane");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button0);
      append(div0, t1);
      append(div0, button1);
      append(button1, t2);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*dispose*/
            ctx[7]
          ),
          listen(
            button1,
            "click",
            /*open*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$currentPath, $selected*/
      48 && button1_disabled_value !== (button1_disabled_value = !/*$currentPath*/
      ctx2[5] || !/*$selected*/
      ctx2[4])) {
        button1.disabled = button1_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2w($$self, $$props, $$invalidate) {
  let $processing, $$unsubscribe_processing = noop$1, $$subscribe_processing = () => ($$unsubscribe_processing(), $$unsubscribe_processing = subscribe(processing, ($$value) => $$invalidate(9, $processing = $$value)), processing);
  let $currentDir, $$unsubscribe_currentDir = noop$1, $$subscribe_currentDir = () => ($$unsubscribe_currentDir(), $$unsubscribe_currentDir = subscribe(currentDir, ($$value) => $$invalidate(10, $currentDir = $$value)), currentDir);
  let $selected, $$unsubscribe_selected = noop$1, $$subscribe_selected = () => ($$unsubscribe_selected(), $$unsubscribe_selected = subscribe(selected, ($$value) => $$invalidate(4, $selected = $$value)), selected);
  let $currentPath, $$unsubscribe_currentPath = noop$1, $$subscribe_currentPath = () => ($$unsubscribe_currentPath(), $$unsubscribe_currentPath = subscribe(currentPath, ($$value) => $$invalidate(5, $currentPath = $$value)), currentPath);
  $$self.$$.on_destroy.push(() => $$unsubscribe_processing());
  $$self.$$.on_destroy.push(() => $$unsubscribe_currentDir());
  $$self.$$.on_destroy.push(() => $$unsubscribe_selected());
  $$self.$$.on_destroy.push(() => $$unsubscribe_currentPath());
  let { currentDir } = $$props;
  $$subscribe_currentDir();
  let { currentPath } = $$props;
  $$subscribe_currentPath();
  let { selected } = $$props;
  $$subscribe_selected();
  let { processing } = $$props;
  $$subscribe_processing();
  let { overlay } = $$props;
  async function open() {
    set_store_value(processing, $processing = true, $processing);
    let file;
    for (let i2 = 0; i2 < $currentDir.files.length; i2++) {
      if ($currentDir.files[i2].filename == $selected)
        file = $currentDir.files[i2];
    }
    const data = await partialFileToComplete(file);
    hideOverlay(overlay.id, getChooserTarget(overlay.id));
    setTargetFile(overlay.id, data);
    set_store_value(processing, $processing = false, $processing);
  }
  function dispose() {
    const targetId = getChooserTarget(overlay.id);
    const targetWindow = getWindow(targetId);
    hideOverlay(overlay.id, targetId);
    if (!targetWindow)
      return Log("ChooserOverlay: dispose", `Could not get target window ${targetId}`, LogLevel.warn);
    setTargetFile(overlay.id, targetWindow.openedFile);
  }
  $$self.$$set = ($$props2) => {
    if ("currentDir" in $$props2)
      $$subscribe_currentDir($$invalidate(0, currentDir = $$props2.currentDir));
    if ("currentPath" in $$props2)
      $$subscribe_currentPath($$invalidate(1, currentPath = $$props2.currentPath));
    if ("selected" in $$props2)
      $$subscribe_selected($$invalidate(2, selected = $$props2.selected));
    if ("processing" in $$props2)
      $$subscribe_processing($$invalidate(3, processing = $$props2.processing));
    if ("overlay" in $$props2)
      $$invalidate(8, overlay = $$props2.overlay);
  };
  return [
    currentDir,
    currentPath,
    selected,
    processing,
    $selected,
    $currentPath,
    open,
    dispose,
    overlay
  ];
}
let BottomPane$1 = class BottomPane extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2w, create_fragment$2G, safe_not_equal, {
      currentDir: 0,
      currentPath: 1,
      selected: 2,
      processing: 3,
      overlay: 8
    });
  }
};
function create_fragment$2F(ctx) {
  let button;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let div1;
  let t1_value = (
    /*dir*/
    ctx[0].name + ""
  );
  let t1;
  let t2;
  let div2;
  let t4;
  let div3;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      div2.textContent = "Folder";
      t4 = space();
      div3 = element("div");
      div3.textContent = "-";
      if (!src_url_equal(img.src, img_src_value = FolderIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*dir*/
      ctx[0].name);
      attr(div0, "class", "image");
      attr(div1, "class", "name");
      attr(div2, "class", "mime");
      attr(div3, "class", "size");
      attr(button, "class", "item dir");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div0);
      append(div0, img);
      append(button, t0);
      append(button, div1);
      append(div1, t1);
      append(button, t2);
      append(button, div2);
      append(button, t4);
      append(button, div3);
      if (!mounted) {
        dispose = listen(
          button,
          "dblclick",
          /*dblclick_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*dir*/
      1 && img_alt_value !== (img_alt_value = /*dir*/
      ctx2[0].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*dir*/
      1 && t1_value !== (t1_value = /*dir*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2v($$self, $$props, $$invalidate) {
  let { dir } = $$props;
  let { setDir } = $$props;
  const dblclick_handler = () => setDir(dir.scopedPath);
  $$self.$$set = ($$props2) => {
    if ("dir" in $$props2)
      $$invalidate(0, dir = $$props2.dir);
    if ("setDir" in $$props2)
      $$invalidate(1, setDir = $$props2.setDir);
  };
  return [dir, setDir, dblclick_handler];
}
let Dir$1 = class Dir3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2v, create_fragment$2F, safe_not_equal, { dir: 0, setDir: 1 });
  }
};
function create_fragment$2E(ctx) {
  let button;
  let div0;
  let img_1;
  let img_1_src_value;
  let img_1_alt_value;
  let t0;
  let div1;
  let t1_value = (
    /*file*/
    ctx[2].filename + ""
  );
  let t1;
  let t2;
  let div2;
  let t3_value = (
    /*file*/
    ctx[2].mime.split("; ")[0].split("/").join(" - ") + ""
  );
  let t3;
  let t4;
  let div3;
  let t5_value = formatBytes(
    /*file*/
    ctx[2].size
  ) + "";
  let t5;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      div0 = element("div");
      img_1 = element("img");
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      t3 = text(t3_value);
      t4 = space();
      div3 = element("div");
      t5 = text(t5_value);
      if (!src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx[3]))
        attr(img_1, "src", img_1_src_value);
      attr(img_1, "alt", img_1_alt_value = /*file*/
      ctx[2].filename);
      attr(div0, "class", "image");
      attr(div1, "class", "name");
      attr(div2, "class", "mime");
      attr(div3, "class", "size");
      attr(button, "class", "item file");
      toggle_class(
        button,
        "selected",
        /*$selected*/
        ctx[4] == /*file*/
        ctx[2].filename
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div0);
      append(div0, img_1);
      append(button, t0);
      append(button, div1);
      append(div1, t1);
      append(button, t2);
      append(button, div2);
      append(div2, t3);
      append(button, t4);
      append(button, div3);
      append(div3, t5);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "dblclick",
            /*process*/
            ctx[5]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*img*/
      8 && !src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx2[3])) {
        attr(img_1, "src", img_1_src_value);
      }
      if (dirty & /*file*/
      4 && img_1_alt_value !== (img_1_alt_value = /*file*/
      ctx2[2].filename)) {
        attr(img_1, "alt", img_1_alt_value);
      }
      if (dirty & /*file*/
      4 && t1_value !== (t1_value = /*file*/
      ctx2[2].filename + ""))
        set_data(t1, t1_value);
      if (dirty & /*file*/
      4 && t3_value !== (t3_value = /*file*/
      ctx2[2].mime.split("; ")[0].split("/").join(" - ") + ""))
        set_data(t3, t3_value);
      if (dirty & /*file*/
      4 && t5_value !== (t5_value = formatBytes(
        /*file*/
        ctx2[2].size
      ) + ""))
        set_data(t5, t5_value);
      if (dirty & /*$selected, file*/
      20) {
        toggle_class(
          button,
          "selected",
          /*$selected*/
          ctx2[4] == /*file*/
          ctx2[2].filename
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2u($$self, $$props, $$invalidate) {
  let $processing, $$unsubscribe_processing = noop$1, $$subscribe_processing = () => ($$unsubscribe_processing(), $$unsubscribe_processing = subscribe(processing, ($$value) => $$invalidate(8, $processing = $$value)), processing);
  let $selected, $$unsubscribe_selected = noop$1, $$subscribe_selected = () => ($$unsubscribe_selected(), $$unsubscribe_selected = subscribe(selected, ($$value) => $$invalidate(4, $selected = $$value)), selected);
  $$self.$$.on_destroy.push(() => $$unsubscribe_processing());
  $$self.$$.on_destroy.push(() => $$unsubscribe_selected());
  let { overlay } = $$props;
  let { selected } = $$props;
  $$subscribe_selected();
  let { processing } = $$props;
  $$subscribe_processing();
  let img = "";
  onMount(() => {
    $$invalidate(3, img = getMimeIcon(file.filename));
  });
  async function process2() {
    set_store_value(processing, $processing = true, $processing);
    const data = await partialFileToComplete(file);
    setTargetFile(overlay.id, data);
    set_store_value(processing, $processing = false, $processing);
  }
  let { file } = $$props;
  const click_handler = () => set_store_value(selected, $selected = file.filename, $selected);
  $$self.$$set = ($$props2) => {
    if ("overlay" in $$props2)
      $$invalidate(6, overlay = $$props2.overlay);
    if ("selected" in $$props2)
      $$subscribe_selected($$invalidate(0, selected = $$props2.selected));
    if ("processing" in $$props2)
      $$subscribe_processing($$invalidate(1, processing = $$props2.processing));
    if ("file" in $$props2)
      $$invalidate(2, file = $$props2.file);
  };
  return [selected, processing, file, img, $selected, process2, overlay, click_handler];
}
let File$1 = class File5 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2u, create_fragment$2E, safe_not_equal, {
      overlay: 6,
      selected: 0,
      processing: 1,
      file: 2
    });
  }
};
function create_if_block$13(ctx) {
  let button;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(
        /*crumb*/
        ctx[0]
      );
      attr(button, "class", "crumb");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*openThis*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*crumb*/
      1)
        set_data(
          t2,
          /*crumb*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2D(ctx) {
  let if_block_anchor;
  let if_block = (
    /*crumb*/
    ctx[0] && /*crumb*/
    ctx[0] != "." && create_if_block$13(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*crumb*/
        ctx2[0] && /*crumb*/
        ctx2[0] != "."
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$13(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$2t($$self, $$props, $$invalidate) {
  let { crumb } = $$props;
  let { path } = $$props;
  let { setDir } = $$props;
  function openThis() {
    setDir(path);
  }
  $$self.$$set = ($$props2) => {
    if ("crumb" in $$props2)
      $$invalidate(0, crumb = $$props2.crumb);
    if ("path" in $$props2)
      $$invalidate(2, path = $$props2.path);
    if ("setDir" in $$props2)
      $$invalidate(3, setDir = $$props2.setDir);
  };
  return [crumb, openThis, path, setDir];
}
class Crumb2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2t, create_fragment$2D, safe_not_equal, { crumb: 0, path: 2, setDir: 3 });
  }
}
function get_each_context$A(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list2[i2];
  child_ctx[12] = i2;
  return child_ctx;
}
function create_each_block$A(ctx) {
  let crumb_1;
  let current;
  crumb_1 = new Crumb2({
    props: {
      crumb: (
        /*crumb*/
        ctx[10]
      ),
      path: (
        /*generatePath*/
        ctx[6](
          /*crumb*/
          ctx[10],
          /*i*/
          ctx[12]
        )
      ),
      setDir: (
        /*setDir*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(crumb_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(crumb_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const crumb_1_changes = {};
      if (dirty & /*crumbs*/
      16)
        crumb_1_changes.crumb = /*crumb*/
        ctx2[10];
      if (dirty & /*crumbs*/
      16)
        crumb_1_changes.path = /*generatePath*/
        ctx2[6](
          /*crumb*/
          ctx2[10],
          /*i*/
          ctx2[12]
        );
      if (dirty & /*setDir*/
      8)
        crumb_1_changes.setDir = /*setDir*/
        ctx2[3];
      crumb_1.$set(crumb_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(crumb_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(crumb_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(crumb_1, detaching);
    }
  };
}
function create_fragment$2C(ctx) {
  let div2;
  let button0;
  let t0;
  let button0_disabled_value;
  let t1;
  let button1;
  let t3;
  let div0;
  let t4;
  let button2;
  let t6;
  let div1;
  let button3;
  let t7;
  let button3_disabled_value;
  let t8;
  let button4;
  let t9;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*crumbs*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$A(get_each_context$A(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div2 = element("div");
      button0 = element("button");
      t0 = text("arrow_upward");
      t1 = space();
      button1 = element("button");
      button1.textContent = "home";
      t3 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t4 = space();
      button2 = element("button");
      button2.textContent = "refresh";
      t6 = space();
      div1 = element("div");
      button3 = element("button");
      t7 = text("format_list_bulleted");
      t8 = space();
      button4 = element("button");
      t9 = text("grid_view");
      attr(button0, "class", "parentdir material-icons-round");
      button0.disabled = button0_disabled_value = /*crumbs*/
      ctx[4].length == 2 && /*crumbs*/
      ctx[4][0] == "." && !/*crumbs*/
      ctx[4][1];
      attr(button1, "class", "home material-icons-round");
      attr(div0, "class", "addressbar");
      attr(button2, "class", "refresh material-icons-round");
      attr(button3, "class", "material-icons-round");
      button3.disabled = button3_disabled_value = !/*tiled*/
      ctx[0];
      attr(button3, "title", "List view");
      toggle_class(
        button3,
        "selected",
        /*tiled*/
        ctx[0]
      );
      attr(button4, "class", "material-icons-round");
      button4.disabled = /*tiled*/
      ctx[0];
      attr(button4, "title", "Tile view");
      toggle_class(button4, "selected", !/*tiled*/
      ctx[0]);
      attr(div1, "class", "group");
      attr(div2, "class", "topbar");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, button0);
      append(button0, t0);
      append(div2, t1);
      append(div2, button1);
      append(div2, t3);
      append(div2, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div2, t4);
      append(div2, button2);
      append(div2, t6);
      append(div2, div1);
      append(div1, button3);
      append(button3, t7);
      append(div1, t8);
      append(div1, button4);
      append(button4, t9);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*parentdir*/
            ctx[7]
          ),
          listen(
            button1,
            "click",
            /*home*/
            ctx[5]
          ),
          listen(button2, "click", function() {
            if (is_function(
              /*refresh*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          }),
          listen(
            button3,
            "click",
            /*toggle*/
            ctx[8]
          ),
          listen(
            button4,
            "click",
            /*toggle*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (!current || dirty & /*crumbs*/
      16 && button0_disabled_value !== (button0_disabled_value = /*crumbs*/
      ctx[4].length == 2 && /*crumbs*/
      ctx[4][0] == "." && !/*crumbs*/
      ctx[4][1])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*crumbs, generatePath, setDir*/
      88) {
        each_value = ensure_array_like(
          /*crumbs*/
          ctx[4]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$A(ctx, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$A(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*tiled*/
      1 && button3_disabled_value !== (button3_disabled_value = !/*tiled*/
      ctx[0])) {
        button3.disabled = button3_disabled_value;
      }
      if (!current || dirty & /*tiled*/
      1) {
        toggle_class(
          button3,
          "selected",
          /*tiled*/
          ctx[0]
        );
      }
      if (!current || dirty & /*tiled*/
      1) {
        button4.disabled = /*tiled*/
        ctx[0];
      }
      if (!current || dirty & /*tiled*/
      1) {
        toggle_class(button4, "selected", !/*tiled*/
        ctx[0]);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2s($$self, $$props, $$invalidate) {
  let $currentPath, $$unsubscribe_currentPath = noop$1, $$subscribe_currentPath = () => ($$unsubscribe_currentPath(), $$unsubscribe_currentPath = subscribe(currentPath, ($$value) => $$invalidate(9, $currentPath = $$value)), currentPath);
  $$self.$$.on_destroy.push(() => $$unsubscribe_currentPath());
  let { currentPath } = $$props;
  $$subscribe_currentPath();
  let { refresh } = $$props;
  let { setDir } = $$props;
  let crumbs;
  let { tiled } = $$props;
  currentPath.subscribe((v2) => {
    $$invalidate(4, crumbs = v2.split("/"));
    refresh();
    $$invalidate(0, tiled = !!getAppPreference("FileManager", "tiled"));
  });
  function home() {
    currentPath.set("./");
  }
  function generatePath(crumb, I2) {
    let str = "";
    for (let i2 = 0; i2 < I2; i2++) {
      str += `${crumbs[i2]}/`;
    }
    return `${str}${crumb}`;
  }
  function parentdir() {
    setDir(getParentDirectory($currentPath));
  }
  function toggle() {
    $$invalidate(0, tiled = !tiled);
    setAppPreference("FileManager", "tiled", tiled);
  }
  UserData$2.subscribe(() => {
    $$invalidate(0, tiled = !!getAppPreference("FileManager", "tiled"));
  });
  $$self.$$set = ($$props2) => {
    if ("currentPath" in $$props2)
      $$subscribe_currentPath($$invalidate(1, currentPath = $$props2.currentPath));
    if ("refresh" in $$props2)
      $$invalidate(2, refresh = $$props2.refresh);
    if ("setDir" in $$props2)
      $$invalidate(3, setDir = $$props2.setDir);
    if ("tiled" in $$props2)
      $$invalidate(0, tiled = $$props2.tiled);
  };
  return [
    tiled,
    currentPath,
    refresh,
    setDir,
    crumbs,
    home,
    generatePath,
    parentdir,
    toggle
  ];
}
let TopBar$1 = class TopBar3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2s, create_fragment$2C, safe_not_equal, {
      currentPath: 1,
      refresh: 2,
      setDir: 3,
      tiled: 0
    });
  }
};
const chooseroverlay = "";
function create_fragment$2B(ctx) {
  let button;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let p2;
  let t1_value = (
    /*dir*/
    ctx[0].name + ""
  );
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      p2 = element("p");
      t1 = text(t1_value);
      if (!src_url_equal(img.src, img_src_value = FolderIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*dir*/
      ctx[0].name);
      attr(p2, "class", "caption");
      attr(button, "class", "tile dir");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, p2);
      append(p2, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "dblclick",
          /*navigate*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*dir*/
      1 && img_alt_value !== (img_alt_value = /*dir*/
      ctx2[0].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*dir*/
      1 && t1_value !== (t1_value = /*dir*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2r($$self, $$props, $$invalidate) {
  let { dir } = $$props;
  let { setDir } = $$props;
  function navigate() {
    setDir(dir.scopedPath);
  }
  $$self.$$set = ($$props2) => {
    if ("dir" in $$props2)
      $$invalidate(0, dir = $$props2.dir);
    if ("setDir" in $$props2)
      $$invalidate(2, setDir = $$props2.setDir);
  };
  return [dir, navigate, setDir];
}
class Dir4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2r, create_fragment$2B, safe_not_equal, { dir: 0, setDir: 2 });
  }
}
function create_fragment$2A(ctx) {
  let button;
  let div;
  let img_1;
  let img_1_src_value;
  let img_1_alt_value;
  let t0;
  let p2;
  let t1_value = (
    /*file*/
    ctx[2].filename + ""
  );
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      div = element("div");
      img_1 = element("img");
      t0 = space();
      p2 = element("p");
      t1 = text(t1_value);
      if (!src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx[3]))
        attr(img_1, "src", img_1_src_value);
      attr(img_1, "alt", img_1_alt_value = /*file*/
      ctx[2].filename);
      attr(div, "class", "image");
      attr(p2, "class", "name");
      attr(button, "class", "tile file");
      toggle_class(
        button,
        "selected",
        /*$selected*/
        ctx[4] == /*file*/
        ctx[2].filename
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div);
      append(div, img_1);
      append(button, t0);
      append(button, p2);
      append(p2, t1);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "dblclick",
            /*process*/
            ctx[5]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*img*/
      8 && !src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx2[3])) {
        attr(img_1, "src", img_1_src_value);
      }
      if (dirty & /*file*/
      4 && img_1_alt_value !== (img_1_alt_value = /*file*/
      ctx2[2].filename)) {
        attr(img_1, "alt", img_1_alt_value);
      }
      if (dirty & /*file*/
      4 && t1_value !== (t1_value = /*file*/
      ctx2[2].filename + ""))
        set_data(t1, t1_value);
      if (dirty & /*$selected, file*/
      20) {
        toggle_class(
          button,
          "selected",
          /*$selected*/
          ctx2[4] == /*file*/
          ctx2[2].filename
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2q($$self, $$props, $$invalidate) {
  let $processing, $$unsubscribe_processing = noop$1, $$subscribe_processing = () => ($$unsubscribe_processing(), $$unsubscribe_processing = subscribe(processing, ($$value) => $$invalidate(8, $processing = $$value)), processing);
  let $selected, $$unsubscribe_selected = noop$1, $$subscribe_selected = () => ($$unsubscribe_selected(), $$unsubscribe_selected = subscribe(selected, ($$value) => $$invalidate(4, $selected = $$value)), selected);
  $$self.$$.on_destroy.push(() => $$unsubscribe_processing());
  $$self.$$.on_destroy.push(() => $$unsubscribe_selected());
  let { overlay } = $$props;
  let { selected } = $$props;
  $$subscribe_selected();
  let { processing } = $$props;
  $$subscribe_processing();
  let img = "";
  onMount(() => {
    $$invalidate(3, img = getMimeIcon(file.filename));
  });
  async function process2() {
    set_store_value(processing, $processing = true, $processing);
    const data = await partialFileToComplete(file);
    setTargetFile(overlay.id, data);
    set_store_value(processing, $processing = false, $processing);
  }
  let { file } = $$props;
  const click_handler = () => set_store_value(selected, $selected = file.filename, $selected);
  $$self.$$set = ($$props2) => {
    if ("overlay" in $$props2)
      $$invalidate(6, overlay = $$props2.overlay);
    if ("selected" in $$props2)
      $$subscribe_selected($$invalidate(0, selected = $$props2.selected));
    if ("processing" in $$props2)
      $$subscribe_processing($$invalidate(1, processing = $$props2.processing));
    if ("file" in $$props2)
      $$invalidate(2, file = $$props2.file);
  };
  return [selected, processing, file, img, $selected, process2, overlay, click_handler];
}
class File6 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2q, create_fragment$2A, safe_not_equal, {
      overlay: 6,
      selected: 0,
      processing: 1,
      file: 2
    });
  }
}
function get_each_context$z(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2];
  return child_ctx;
}
function get_each_context_1$7(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list2[i2];
  return child_ctx;
}
function create_if_block$12(ctx) {
  let div;
  let current;
  let each_value_1 = ensure_array_like(
    /*data*/
    ctx[3].directories
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$7(get_each_context_1$7(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "dirs");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*data, setDir*/
      24) {
        each_value_1 = ensure_array_like(
          /*data*/
          ctx2[3].directories
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$7(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$7(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1$7(ctx) {
  let dir_1;
  let current;
  dir_1 = new Dir4({
    props: {
      dir: (
        /*dir*/
        ctx[8]
      ),
      setDir: (
        /*setDir*/
        ctx[4]
      )
    }
  });
  return {
    c() {
      create_component(dir_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dir_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dir_1_changes = {};
      if (dirty & /*data*/
      8)
        dir_1_changes.dir = /*dir*/
        ctx2[8];
      if (dirty & /*setDir*/
      16)
        dir_1_changes.setDir = /*setDir*/
        ctx2[4];
      dir_1.$set(dir_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dir_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dir_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dir_1, detaching);
    }
  };
}
function create_each_block$z(ctx) {
  let file_1;
  let current;
  file_1 = new File6({
    props: {
      file: (
        /*file*/
        ctx[5]
      ),
      overlay: (
        /*overlay*/
        ctx[0]
      ),
      selected: (
        /*selected*/
        ctx[1]
      ),
      processing: (
        /*processing*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(file_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(file_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const file_1_changes = {};
      if (dirty & /*data*/
      8)
        file_1_changes.file = /*file*/
        ctx2[5];
      if (dirty & /*overlay*/
      1)
        file_1_changes.overlay = /*overlay*/
        ctx2[0];
      if (dirty & /*selected*/
      2)
        file_1_changes.selected = /*selected*/
        ctx2[1];
      if (dirty & /*processing*/
      4)
        file_1_changes.processing = /*processing*/
        ctx2[2];
      file_1.$set(file_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(file_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(file_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(file_1, detaching);
    }
  };
}
function create_fragment$2z(ctx) {
  let div1;
  let t2;
  let div0;
  let current;
  let if_block = (
    /*data*/
    ctx[3].directories.length && create_if_block$12(ctx)
  );
  let each_value = ensure_array_like(
    /*data*/
    ctx[3].files
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$z(get_each_context$z(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t2 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div0, "class", "files");
      attr(div1, "class", "tiled");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t2);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*data*/
        ctx2[3].directories.length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*data*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & /*data, overlay, selected, processing*/
      15) {
        each_value = ensure_array_like(
          /*data*/
          ctx2[3].files
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$z(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$z(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$2p($$self, $$props, $$invalidate) {
  let { overlay } = $$props;
  let { selected } = $$props;
  let { processing } = $$props;
  let { data } = $$props;
  let { setDir } = $$props;
  $$self.$$set = ($$props2) => {
    if ("overlay" in $$props2)
      $$invalidate(0, overlay = $$props2.overlay);
    if ("selected" in $$props2)
      $$invalidate(1, selected = $$props2.selected);
    if ("processing" in $$props2)
      $$invalidate(2, processing = $$props2.processing);
    if ("data" in $$props2)
      $$invalidate(3, data = $$props2.data);
    if ("setDir" in $$props2)
      $$invalidate(4, setDir = $$props2.setDir);
  };
  return [overlay, selected, processing, data, setDir];
}
class Tiled extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2p, create_fragment$2z, safe_not_equal, {
      overlay: 0,
      selected: 1,
      processing: 2,
      data: 3,
      setDir: 4
    });
  }
}
function create_fragment$2y(ctx) {
  let button;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let p2;
  let t1_value = (
    /*folder*/
    ctx[0].name + ""
  );
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      p2 = element("p");
      t1 = text(t1_value);
      if (!src_url_equal(img.src, img_src_value = FolderIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*folder*/
      ctx[0].name);
      attr(p2, "class", "caption");
      attr(button, "class", "link");
      toggle_class(
        button,
        "selected",
        /*selected*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, p2);
      append(p2, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*doSet*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*folder*/
      1 && img_alt_value !== (img_alt_value = /*folder*/
      ctx2[0].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*folder*/
      1 && t1_value !== (t1_value = /*folder*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*selected*/
      2) {
        toggle_class(
          button,
          "selected",
          /*selected*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2o($$self, $$props, $$invalidate) {
  let { folder } = $$props;
  let { setDir } = $$props;
  let { currentPath } = $$props;
  let selected = false;
  function doSet() {
    setDir(folder.scopedPath);
  }
  currentPath.subscribe((v2) => {
    $$invalidate(1, selected = v2 == folder.scopedPath);
  });
  $$self.$$set = ($$props2) => {
    if ("folder" in $$props2)
      $$invalidate(0, folder = $$props2.folder);
    if ("setDir" in $$props2)
      $$invalidate(3, setDir = $$props2.setDir);
    if ("currentPath" in $$props2)
      $$invalidate(4, currentPath = $$props2.currentPath);
  };
  return [folder, selected, doSet, setDir, currentPath];
}
class Link2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2o, create_fragment$2y, safe_not_equal, { folder: 0, setDir: 3, currentPath: 4 });
  }
}
function get_each_context$y(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  return child_ctx;
}
function create_each_block$y(ctx) {
  let link;
  let current;
  link = new Link2({
    props: {
      setDir: (
        /*setDir*/
        ctx[1]
      ),
      currentPath: (
        /*currentPath*/
        ctx[0]
      ),
      folder: (
        /*folder*/
        ctx[4]
      )
    }
  });
  return {
    c() {
      create_component(link.$$.fragment);
    },
    m(target, anchor) {
      mount_component(link, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const link_changes = {};
      if (dirty & /*setDir*/
      2)
        link_changes.setDir = /*setDir*/
        ctx2[1];
      if (dirty & /*currentPath*/
      1)
        link_changes.currentPath = /*currentPath*/
        ctx2[0];
      if (dirty & /*folders*/
      4)
        link_changes.folder = /*folder*/
        ctx2[4];
      link.$set(link_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(link.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(link.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(link, detaching);
    }
  };
}
function create_fragment$2x(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*folders*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$y(get_each_context$y(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "sidebar");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*setDir, currentPath, folders*/
      7) {
        each_value = ensure_array_like(
          /*folders*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$y(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$y(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$2n($$self, $$props, $$invalidate) {
  let folders = [];
  let { currentDir } = $$props;
  let { currentPath } = $$props;
  let { setDir } = $$props;
  currentDir.subscribe(async (v2) => {
    $$invalidate(2, folders = (await getDirectory("./")).directories);
  });
  $$self.$$set = ($$props2) => {
    if ("currentDir" in $$props2)
      $$invalidate(3, currentDir = $$props2.currentDir);
    if ("currentPath" in $$props2)
      $$invalidate(0, currentPath = $$props2.currentPath);
    if ("setDir" in $$props2)
      $$invalidate(1, setDir = $$props2.setDir);
  };
  return [currentPath, setDir, folders, currentDir];
}
class SideBar4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2n, create_fragment$2x, safe_not_equal, { currentDir: 3, currentPath: 0, setDir: 1 });
  }
}
function get_each_context$x(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list2[i2];
  return child_ctx;
}
function get_each_context_1$6(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list2[i2];
  return child_ctx;
}
function create_if_block$11(ctx) {
  let topbar;
  let updating_tiled;
  let t0;
  let div;
  let sidebar;
  let t1;
  let current_block_type_index;
  let if_block0;
  let t2;
  let t3;
  let bottompane;
  let current;
  function topbar_tiled_binding(value) {
    ctx[11](value);
  }
  let topbar_props = {
    currentPath: (
      /*currentPath*/
      ctx[6]
    ),
    refresh: (
      /*refresh*/
      ctx[10]
    ),
    setDir: (
      /*setDir*/
      ctx[9]
    )
  };
  if (
    /*tiled*/
    ctx[1] !== void 0
  ) {
    topbar_props.tiled = /*tiled*/
    ctx[1];
  }
  topbar = new TopBar$1({ props: topbar_props });
  binding_callbacks.push(() => bind$1(topbar, "tiled", topbar_tiled_binding));
  sidebar = new SideBar4({
    props: {
      currentDir: (
        /*currentDir*/
        ctx[5]
      ),
      setDir: (
        /*setDir*/
        ctx[9]
      ),
      currentPath: (
        /*currentPath*/
        ctx[6]
      )
    }
  });
  const if_block_creators = [create_if_block_2$5, create_else_block$k];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tiled*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*$processing*/
    ctx[3] && create_if_block_1$e(ctx)
  );
  bottompane = new BottomPane$1({
    props: {
      currentDir: (
        /*currentDir*/
        ctx[5]
      ),
      currentPath: (
        /*currentPath*/
        ctx[6]
      ),
      selected: (
        /*selected*/
        ctx[7]
      ),
      overlay: (
        /*overlay*/
        ctx[0]
      ),
      processing: (
        /*processing*/
        ctx[8]
      )
    }
  });
  return {
    c() {
      create_component(topbar.$$.fragment);
      t0 = space();
      div = element("div");
      create_component(sidebar.$$.fragment);
      t1 = space();
      if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      create_component(bottompane.$$.fragment);
      attr(div, "class", "content");
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      mount_component(sidebar, div, null);
      append(div, t1);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      insert(target, t3, anchor);
      mount_component(bottompane, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const topbar_changes = {};
      if (!updating_tiled && dirty & /*tiled*/
      2) {
        updating_tiled = true;
        topbar_changes.tiled = /*tiled*/
        ctx2[1];
        add_flush_callback(() => updating_tiled = false);
      }
      topbar.$set(topbar_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t2);
      }
      if (
        /*$processing*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$processing*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$e(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const bottompane_changes = {};
      if (dirty & /*overlay*/
      1)
        bottompane_changes.overlay = /*overlay*/
        ctx2[0];
      bottompane.$set(bottompane_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      transition_in(sidebar.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(bottompane.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      transition_out(sidebar.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(bottompane.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t3);
      }
      destroy_component(topbar, detaching);
      destroy_component(sidebar);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      destroy_component(bottompane, detaching);
    }
  };
}
function create_else_block$k(ctx) {
  let div;
  let toprow;
  let t0;
  let t1;
  let current;
  toprow = new TopRow({});
  let each_value_1 = ensure_array_like(
    /*$currentDir*/
    ctx[2].directories
  );
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  let each_value = ensure_array_like(
    /*$currentDir*/
    ctx[2].files
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$x(get_each_context$x(ctx, each_value, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      create_component(toprow.$$.fragment);
      t0 = space();
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "list");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(toprow, div, null);
      append(div, t0);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(div, null);
        }
      }
      append(div, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*setDir, $currentDir*/
      516) {
        each_value_1 = ensure_array_like(
          /*$currentDir*/
          ctx2[2].directories
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$6(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_1$6(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(div, t1);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (dirty & /*$currentDir, overlay, selected, processing*/
      389) {
        each_value = ensure_array_like(
          /*$currentDir*/
          ctx2[2].files
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$x(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$x(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(toprow.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(toprow.$$.fragment, local);
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(toprow);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_2$5(ctx) {
  let tiled_1;
  let current;
  tiled_1 = new Tiled({
    props: {
      data: (
        /*$currentDir*/
        ctx[2]
      ),
      setDir: (
        /*setDir*/
        ctx[9]
      ),
      overlay: (
        /*overlay*/
        ctx[0]
      ),
      selected: (
        /*selected*/
        ctx[7]
      ),
      processing: (
        /*processing*/
        ctx[8]
      )
    }
  });
  return {
    c() {
      create_component(tiled_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tiled_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tiled_1_changes = {};
      if (dirty & /*$currentDir*/
      4)
        tiled_1_changes.data = /*$currentDir*/
        ctx2[2];
      if (dirty & /*overlay*/
      1)
        tiled_1_changes.overlay = /*overlay*/
        ctx2[0];
      tiled_1.$set(tiled_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tiled_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tiled_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tiled_1, detaching);
    }
  };
}
function create_each_block_1$6(ctx) {
  let dir_1;
  let current;
  dir_1 = new Dir$1({
    props: {
      setDir: (
        /*setDir*/
        ctx[9]
      ),
      dir: (
        /*dir*/
        ctx[16]
      )
    }
  });
  return {
    c() {
      create_component(dir_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dir_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dir_1_changes = {};
      if (dirty & /*$currentDir*/
      4)
        dir_1_changes.dir = /*dir*/
        ctx2[16];
      dir_1.$set(dir_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dir_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dir_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dir_1, detaching);
    }
  };
}
function create_each_block$x(ctx) {
  let file_1;
  let current;
  file_1 = new File$1({
    props: {
      file: (
        /*file*/
        ctx[13]
      ),
      overlay: (
        /*overlay*/
        ctx[0]
      ),
      selected: (
        /*selected*/
        ctx[7]
      ),
      processing: (
        /*processing*/
        ctx[8]
      )
    }
  });
  return {
    c() {
      create_component(file_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(file_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const file_1_changes = {};
      if (dirty & /*$currentDir*/
      4)
        file_1_changes.file = /*file*/
        ctx2[13];
      if (dirty & /*overlay*/
      1)
        file_1_changes.overlay = /*overlay*/
        ctx2[0];
      file_1.$set(file_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(file_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(file_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(file_1, detaching);
    }
  };
}
function create_if_block_1$e(ctx) {
  let div2;
  let div1;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let p2;
  let t1;
  let t2;
  let t3;
  let t4;
  let spinner2;
  let current;
  spinner2 = new Spinner({ props: { height: 30 } });
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      p2 = element("p");
      t1 = text("Opening ");
      t2 = text(
        /*$selected*/
        ctx[4]
      );
      t3 = text("...");
      t4 = space();
      create_component(spinner2.$$.fragment);
      if (!src_url_equal(img.src, img_src_value = FileIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(p2, "class", "caption");
      attr(div0, "class", "processing");
      attr(div1, "class", "processing-content");
      attr(div2, "class", "processing-overlay");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, img);
      append(div0, t0);
      append(div0, p2);
      append(p2, t1);
      append(p2, t2);
      append(p2, t3);
      append(div0, t4);
      mount_component(spinner2, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*$selected*/
      16)
        set_data(
          t2,
          /*$selected*/
          ctx2[4]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(spinner2);
    }
  };
}
function create_fragment$2w(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*overlay*/
    ctx[0] && /*$currentDir*/
    ctx[2] && create_if_block$11(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*overlay*/
        ctx2[0] && /*$currentDir*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*overlay, $currentDir*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$11(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$2m($$self, $$props, $$invalidate) {
  let $currentPath;
  let $currentDir;
  let $processing;
  let $selected;
  let { overlay } = $$props;
  let tiled = false;
  let currentDir = writable(defaultDirectory);
  component_subscribe($$self, currentDir, (value) => $$invalidate(2, $currentDir = value));
  let currentPath = writable("./");
  component_subscribe($$self, currentPath, (value) => $$invalidate(12, $currentPath = value));
  let selected = writable(null);
  component_subscribe($$self, selected, (value) => $$invalidate(4, $selected = value));
  let processing = writable(false);
  component_subscribe($$self, processing, (value) => $$invalidate(3, $processing = value));
  async function setDir(path) {
    set_store_value(currentPath, $currentPath = path, $currentPath);
    await refresh();
  }
  async function refresh() {
    set_store_value(currentDir, $currentDir = defaultDirectory, $currentDir);
    set_store_value(currentDir, $currentDir = await getDirectory($currentPath) || null, $currentDir);
  }
  function topbar_tiled_binding(value) {
    tiled = value;
    $$invalidate(1, tiled);
  }
  $$self.$$set = ($$props2) => {
    if ("overlay" in $$props2)
      $$invalidate(0, overlay = $$props2.overlay);
  };
  return [
    overlay,
    tiled,
    $currentDir,
    $processing,
    $selected,
    currentDir,
    currentPath,
    selected,
    processing,
    setDir,
    refresh,
    topbar_tiled_binding
  ];
}
class ChooserOverlay extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2m, create_fragment$2w, safe_not_equal, { overlay: 0 });
  }
}
function generateChooserOverlayData(title = "Choose File") {
  return {
    info: {
      name: title,
      author: "ArcOS Generated",
      version: "1"
    },
    size: { w: NaN, h: NaN },
    show: true,
    id: `CHOOSER#${Math.floor(Math.random() * 1e6)}`,
    content: ChooserOverlay
  };
}
function showOpenFileDialog(targetId) {
  WindowStore.update((ws) => {
    let index = null;
    for (let i2 = 0; i2 < ws.length; i2++) {
      if (ws[i2].id == targetId) {
        index = i2;
        break;
      }
    }
    if (index == null)
      return ws;
    const overlay = generateChooserOverlayData();
    assignTarget(overlay.id, targetId);
    if (!ws[index].overlays)
      ws[index].overlays = {};
    ws[index].overlays[overlay.id] = overlay;
    return ws;
  });
}
const TextEditorContent = writable(null);
async function saveTextEditorFile(textContent, openedFile) {
  const data = new Blob([textContent]);
  await writeFile(openedFile.path, data);
}
async function setShortcuts(app, save) {
  registerShortcuts(
    [
      {
        key: "o",
        alt: true,
        action: () => {
          showOpenFileDialog(app.id);
        }
      },
      {
        key: "s",
        alt: true,
        action: save
      }
    ],
    "TextEditor"
  );
}
async function doLoadError(title, message) {
  return createOverlayableError(
    {
      title,
      message,
      buttons: [
        {
          caption: "Close",
          action: () => closeWindow("TextEditor"),
          suggested: true
        }
      ]
    },
    "TextEditor"
  );
}
function tryParse(content2) {
  Log("ts/bugrep.ts: tryParse", `content`);
  try {
    return JSON.parse(content2);
  } catch {
    return false;
  }
}
function create_fragment$2v(ctx) {
  let div;
  let button0;
  let t1;
  let button1;
  let t2;
  let button1_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.textContent = "folder_open";
      t1 = space();
      button1 = element("button");
      t2 = text("save");
      attr(button0, "class", "material-icons-round open");
      attr(button1, "class", "material-icons-round save");
      button1.disabled = button1_disabled_value = !/*app*/
      ctx[0].openedFile;
      attr(div, "class", "actions");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[2]
          ),
          listen(button1, "click", function() {
            if (is_function(
              /*saveFile*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*app*/
      1 && button1_disabled_value !== (button1_disabled_value = !/*app*/
      ctx[0].openedFile)) {
        button1.disabled = button1_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2l($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { saveFile } = $$props;
  const click_handler = () => showOpenFileDialog(app.id);
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("saveFile" in $$props2)
      $$invalidate(1, saveFile = $$props2.saveFile);
  };
  return [app, saveFile, click_handler];
}
let Actions$3 = class Actions2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2l, create_fragment$2v, safe_not_equal, { app: 0, saveFile: 1 });
  }
};
function create_fragment$2u(ctx) {
  let div4;
  let div3;
  let div0;
  let t0;
  let t1_value = formatBytes(
    /*fileContents*/
    ctx[0].length
  ) + "";
  let t1;
  let t2;
  let div1;
  let t3_value = (
    /*app*/
    ctx[1].openedFile.name + ""
  );
  let t3;
  let t4;
  let div2;
  let t5_value = (
    /*app*/
    ctx[1].openedFile.mime.split(";")[0] + ""
  );
  let t5;
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      t0 = text("Size: ");
      t1 = text(t1_value);
      t2 = space();
      div1 = element("div");
      t3 = text(t3_value);
      t4 = space();
      div2 = element("div");
      t5 = text(t5_value);
      attr(div0, "class", "section");
      attr(div1, "class", "section");
      attr(div2, "class", "section");
      attr(div3, "class", "right");
      attr(div4, "class", "bottom");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div0);
      append(div0, t0);
      append(div0, t1);
      append(div3, t2);
      append(div3, div1);
      append(div1, t3);
      append(div3, t4);
      append(div3, div2);
      append(div2, t5);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*fileContents*/
      1 && t1_value !== (t1_value = formatBytes(
        /*fileContents*/
        ctx2[0].length
      ) + ""))
        set_data(t1, t1_value);
      if (dirty & /*app*/
      2 && t3_value !== (t3_value = /*app*/
      ctx2[1].openedFile.name + ""))
        set_data(t3, t3_value);
      if (dirty & /*app*/
      2 && t5_value !== (t5_value = /*app*/
      ctx2[1].openedFile.mime.split(";")[0] + ""))
        set_data(t5, t5_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
    }
  };
}
function instance$2k($$self, $$props, $$invalidate) {
  let { fileContents } = $$props;
  let { app } = $$props;
  $$self.$$set = ($$props2) => {
    if ("fileContents" in $$props2)
      $$invalidate(0, fileContents = $$props2.fileContents);
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
  };
  return [fileContents, app];
}
class Bottom4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2k, create_fragment$2u, safe_not_equal, { fileContents: 0, app: 1 });
  }
}
function create_if_block$10(ctx) {
  let div1;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let p2;
  let t1;
  let t2_value = (
    /*app*/
    ctx[1].openedFile.name + ""
  );
  let t2;
  let t3;
  let t4;
  let spinner2;
  let current;
  spinner2 = new Spinner({ props: { height: 24 } });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      p2 = element("p");
      t1 = text("Saving ");
      t2 = text(t2_value);
      t3 = text("...");
      t4 = space();
      create_component(spinner2.$$.fragment);
      if (!src_url_equal(img.src, img_src_value = SaveIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "Saving");
      attr(p2, "class", "caption");
      attr(div0, "class", "saving-content");
      attr(div1, "class", "saving-wrapper");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, img);
      append(div0, t0);
      append(div0, p2);
      append(p2, t1);
      append(p2, t2);
      append(p2, t3);
      append(div0, t4);
      mount_component(spinner2, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*app*/
      2) && t2_value !== (t2_value = /*app*/
      ctx2[1].openedFile.name + ""))
        set_data(t2, t2_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(spinner2);
    }
  };
}
function create_fragment$2t(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*saving*/
    ctx[0] && /*app*/
    ctx[1].openedFile && create_if_block$10(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*saving*/
        ctx2[0] && /*app*/
        ctx2[1].openedFile
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*saving, app*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$10(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$2j($$self, $$props, $$invalidate) {
  let { saving } = $$props;
  let { app } = $$props;
  $$self.$$set = ($$props2) => {
    if ("saving" in $$props2)
      $$invalidate(0, saving = $$props2.saving);
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
  };
  return [saving, app];
}
class Saving extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2j, create_fragment$2t, safe_not_equal, { saving: 0, app: 1 });
  }
}
function create_fragment$2s(ctx) {
  let textarea;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "spellcheck", false);
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      set_input_value(
        textarea,
        /*fileContents*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[2]
          ),
          listen(textarea, "change", function() {
            if (is_function(
              /*onchange*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          }),
          listen(textarea, "input", function() {
            if (is_function(
              /*onchange*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          }),
          listen(textarea, "keydown", function() {
            if (is_function(
              /*onchange*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*fileContents*/
      1) {
        set_input_value(
          textarea,
          /*fileContents*/
          ctx[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(textarea);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2i($$self, $$props, $$invalidate) {
  let { onchange } = $$props;
  let { fileContents } = $$props;
  function textarea_input_handler() {
    fileContents = this.value;
    $$invalidate(0, fileContents);
  }
  $$self.$$set = ($$props2) => {
    if ("onchange" in $$props2)
      $$invalidate(1, onchange = $$props2.onchange);
    if ("fileContents" in $$props2)
      $$invalidate(0, fileContents = $$props2.fileContents);
  };
  return [fileContents, onchange, textarea_input_handler];
}
class TextArea extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2i, create_fragment$2s, safe_not_equal, { onchange: 1, fileContents: 0 });
  }
}
function create_if_block$$(ctx) {
  let textarea;
  let updating_fileContents;
  let t2;
  let bottom;
  let current;
  function textarea_fileContents_binding(value) {
    ctx[6](value);
  }
  let textarea_props = { onchange: (
    /*onchange*/
    ctx[5]
  ) };
  if (
    /*fileContents*/
    ctx[3] !== void 0
  ) {
    textarea_props.fileContents = /*fileContents*/
    ctx[3];
  }
  textarea = new TextArea({ props: textarea_props });
  binding_callbacks.push(() => bind$1(textarea, "fileContents", textarea_fileContents_binding));
  bottom = new Bottom4({
    props: {
      fileContents: (
        /*fileContents*/
        ctx[3]
      ),
      app: (
        /*app*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(textarea.$$.fragment);
      t2 = space();
      create_component(bottom.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textarea, target, anchor);
      insert(target, t2, anchor);
      mount_component(bottom, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textarea_changes = {};
      if (!updating_fileContents && dirty & /*fileContents*/
      8) {
        updating_fileContents = true;
        textarea_changes.fileContents = /*fileContents*/
        ctx2[3];
        add_flush_callback(() => updating_fileContents = false);
      }
      textarea.$set(textarea_changes);
      const bottom_changes = {};
      if (dirty & /*fileContents*/
      8)
        bottom_changes.fileContents = /*fileContents*/
        ctx2[3];
      if (dirty & /*app*/
      1)
        bottom_changes.app = /*app*/
        ctx2[0];
      bottom.$set(bottom_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textarea.$$.fragment, local);
      transition_in(bottom.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textarea.$$.fragment, local);
      transition_out(bottom.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(textarea, detaching);
      destroy_component(bottom, detaching);
    }
  };
}
function create_fragment$2r(ctx) {
  let actions;
  let t0;
  let div;
  let t1;
  let saving_1;
  let updating_app;
  let current;
  actions = new Actions$3({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      saveFile: (
        /*saveFile*/
        ctx[4]
      )
    }
  });
  let if_block = (
    /*app*/
    ctx[0].openedFile && !/*errored*/
    ctx[1] && create_if_block$$(ctx)
  );
  function saving_1_app_binding(value) {
    ctx[7](value);
  }
  let saving_1_props = { saving: (
    /*saving*/
    ctx[2]
  ) };
  if (
    /*app*/
    ctx[0] !== void 0
  ) {
    saving_1_props.app = /*app*/
    ctx[0];
  }
  saving_1 = new Saving({ props: saving_1_props });
  binding_callbacks.push(() => bind$1(saving_1, "app", saving_1_app_binding));
  return {
    c() {
      create_component(actions.$$.fragment);
      t0 = space();
      div = element("div");
      if (if_block)
        if_block.c();
      t1 = space();
      create_component(saving_1.$$.fragment);
      attr(div, "class", "content");
      toggle_class(div, "nofile", !/*app*/
      ctx[0].openedFile);
    },
    m(target, anchor) {
      mount_component(actions, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      insert(target, t1, anchor);
      mount_component(saving_1, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const actions_changes = {};
      if (dirty & /*app*/
      1)
        actions_changes.app = /*app*/
        ctx2[0];
      actions.$set(actions_changes);
      if (
        /*app*/
        ctx2[0].openedFile && !/*errored*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*app, errored*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$$(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*app*/
      1) {
        toggle_class(div, "nofile", !/*app*/
        ctx2[0].openedFile);
      }
      const saving_1_changes = {};
      if (dirty & /*saving*/
      4)
        saving_1_changes.saving = /*saving*/
        ctx2[2];
      if (!updating_app && dirty & /*app*/
      1) {
        updating_app = true;
        saving_1_changes.app = /*app*/
        ctx2[0];
        add_flush_callback(() => updating_app = false);
      }
      saving_1.$set(saving_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actions.$$.fragment, local);
      transition_in(if_block);
      transition_in(saving_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actions.$$.fragment, local);
      transition_out(if_block);
      transition_out(saving_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t1);
      }
      destroy_component(actions, detaching);
      if (if_block)
        if_block.d();
      destroy_component(saving_1, detaching);
    }
  };
}
function instance$2h($$self, $$props, $$invalidate) {
  let $TextEditorContent;
  component_subscribe($$self, TextEditorContent, ($$value) => $$invalidate(8, $TextEditorContent = $$value));
  let { app } = $$props;
  let errored = false;
  let saving = false;
  let fileContents = "";
  onMount(() => {
    $$invalidate(0, app.events = {}, app);
    $$invalidate(
      0,
      app.events.openFile = (app2) => {
        $$invalidate(1, errored = false);
        if (!app2.openedFile)
          return $$invalidate(3, fileContents = "");
        try {
          const text2 = new TextDecoder().decode(app2.openedFile.data);
          $$invalidate(3, fileContents = text2);
          TextEditorContent.set(fileContents);
          const json = tryParse(fileContents);
          if (!json)
            return;
          if (json.error && json.valid == false) {
            $$invalidate(1, errored = true);
            doLoadError(json.error.title, json.error.message);
          }
        } catch {
          doLoadError("Load Failed", "The file contents could not be decoded.");
        }
      },
      app
    );
    $$invalidate(0, app.events.open = onOpen, app);
    setShortcuts(app, saveFile);
  });
  async function saveFile() {
    if (!app.openedFile.path) {
      showOverlay("saveNewFile", "TextEditor");
      return;
    }
    $$invalidate(2, saving = true);
    await saveTextEditorFile(fileContents, app.openedFile);
    $$invalidate(2, saving = false);
  }
  async function onchange() {
    if ($TextEditorContent != fileContents)
      TextEditorContent.set(fileContents);
  }
  async function onOpen() {
    if (app.openedFile)
      return;
    $$invalidate(
      0,
      app.openedFile = {
        name: "Untitled",
        path: "",
        data: new ArrayBuffer(0),
        mime: "text/plain"
      },
      app
    );
  }
  function textarea_fileContents_binding(value) {
    fileContents = value;
    $$invalidate(3, fileContents);
  }
  function saving_1_app_binding(value) {
    app = value;
    $$invalidate(0, app);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [
    app,
    errored,
    saving,
    fileContents,
    saveFile,
    onchange,
    textarea_fileContents_binding,
    saving_1_app_binding
  ];
}
class TextView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2h, create_fragment$2r, safe_not_equal, { app: 0 });
  }
}
const SaveNewFile_svelte_svelte_type_style_lang = "";
function create_fragment$2q(ctx) {
  let div1;
  let img;
  let img_src_value;
  let t0;
  let div0;
  let p2;
  let t2;
  let input;
  let t3;
  let div3;
  let div2;
  let button0;
  let t4;
  let button0_disabled_value;
  let t5;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      img = element("img");
      t0 = space();
      div0 = element("div");
      p2 = element("p");
      p2.textContent = "Enter a path to save this file to:";
      t2 = space();
      input = element("input");
      t3 = space();
      div3 = element("div");
      div2 = element("div");
      button0 = element("button");
      t4 = text("Save");
      t5 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      if (!src_url_equal(img.src, img_src_value = SaveIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "Save File");
      attr(img, "class", "svelte-demxce");
      attr(p2, "class", "caption svelte-demxce");
      attr(input, "type", "text");
      attr(input, "class", "svelte-demxce");
      attr(div0, "class", "inner");
      attr(div1, "class", "wrapper svelte-demxce");
      button0.disabled = button0_disabled_value = !/*value*/
      ctx[0];
      attr(div2, "class", "inner svelte-demxce");
      attr(div3, "class", "actions svelte-demxce");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, img);
      append(div1, t0);
      append(div1, div0);
      append(div0, p2);
      append(div0, t2);
      append(div0, input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      insert(target, t3, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, button0);
      append(button0, t4);
      append(div2, t5);
      append(div2, button1);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[3]
          ),
          listen(
            button0,
            "click",
            /*save*/
            ctx[2]
          ),
          listen(
            button1,
            "click",
            /*closeThis*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (dirty & /*value*/
      1 && button0_disabled_value !== (button0_disabled_value = !/*value*/
      ctx2[0])) {
        button0.disabled = button0_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t3);
        detach(div3);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2g($$self, $$props, $$invalidate) {
  let value = "";
  function closeThis() {
    hideOverlay("saveNewFile", "TextEditor");
  }
  async function save() {
    await saveTextEditorFile(get_store_value(TextEditorContent), {
      name: null,
      path: value,
      data: null,
      mime: ""
    });
    const split = value.split("/");
    await openUserFile({
      filename: split[split.length - 1],
      mime: "text/plain",
      scopedPath: value,
      dateCreated: 0,
      dateModified: 0
    });
    closeThis();
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  return [value, closeThis, save, input_input_handler];
}
class SaveNewFile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2g, create_fragment$2q, safe_not_equal, {});
  }
}
const TextEditor = {
  info: {
    name: "Text Editor",
    description: "Edit plain text files",
    builtin: true,
    version: "1.0.0",
    author: "Izaak Kuipers",
    hidden: false,
    icon: AppPokerIcon,
    appGroup: "utilities"
  },
  size: { w: 700, h: 550 },
  pos: { x: 30, y: 40, centered: true },
  minSize: { w: 400, h: 300 },
  maxSize: { w: 1e3, h: 800 },
  controls: { min: true, max: true, cls: true },
  state: {
    headless: false,
    resizable: true,
    windowState: { min: false, max: false, fll: false }
  },
  content: TextView,
  glass: true,
  fileMimes: ["text/plain", "inode/x-empty", "application/json", ""],
  overlays: {
    saveNewFile: {
      info: {
        name: "Save file",
        author: "Izaak Kuipers",
        version: "1.0.1"
      },
      size: { w: NaN, h: NaN },
      show: false,
      content: SaveNewFile
    }
  }
};
const _2048 = "";
function create_fragment$2p(ctx) {
  let div1;
  let button;
  let t1;
  let div0;
  let t2;
  let t3_value = (
    /*state*/
    ctx[0].score + ""
  );
  let t3;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      button = element("button");
      button.textContent = "New Game";
      t1 = space();
      div0 = element("div");
      t2 = text("Score: ");
      t3 = text(t3_value);
      attr(button, "class", "reset-game");
      attr(div0, "class", "right");
      attr(div1, "class", "header");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, button);
      append(div1, t1);
      append(div1, div0);
      append(div0, t2);
      append(div0, t3);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*newGame*/
            ctx[1]
          ))
            ctx[1].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*state*/
      1 && t3_value !== (t3_value = /*state*/
      ctx[0].score + ""))
        set_data(t3, t3_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2f($$self, $$props, $$invalidate) {
  let { state } = $$props;
  let { newGame } = $$props;
  $$self.$$set = ($$props2) => {
    if ("state" in $$props2)
      $$invalidate(0, state = $$props2.state);
    if ("newGame" in $$props2)
      $$invalidate(1, newGame = $$props2.newGame);
  };
  return [state, newGame];
}
class Header4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2f, create_fragment$2p, safe_not_equal, { state: 0, newGame: 1 });
  }
}
function cubicOut(t2) {
  const f2 = t2 - 1;
  return f2 * f2 * f2 + 1;
}
function is_date(obj) {
  return Object.prototype.toString.call(obj) === "[object Date]";
}
function get_interpolator(a2, b2) {
  if (a2 === b2 || a2 !== a2)
    return () => a2;
  const type = typeof a2;
  if (type !== typeof b2 || Array.isArray(a2) !== Array.isArray(b2)) {
    throw new Error("Cannot interpolate values of different type");
  }
  if (Array.isArray(a2)) {
    const arr = b2.map((bi, i2) => {
      return get_interpolator(a2[i2], bi);
    });
    return (t2) => arr.map((fn) => fn(t2));
  }
  if (type === "object") {
    if (!a2 || !b2)
      throw new Error("Object cannot be null");
    if (is_date(a2) && is_date(b2)) {
      a2 = a2.getTime();
      b2 = b2.getTime();
      const delta = b2 - a2;
      return (t2) => new Date(a2 + t2 * delta);
    }
    const keys = Object.keys(b2);
    const interpolators = {};
    keys.forEach((key2) => {
      interpolators[key2] = get_interpolator(a2[key2], b2[key2]);
    });
    return (t2) => {
      const result = {};
      keys.forEach((key2) => {
        result[key2] = interpolators[key2](t2);
      });
      return result;
    };
  }
  if (type === "number") {
    const delta = b2 - a2;
    return (t2) => a2 + t2 * delta;
  }
  throw new Error(`Cannot interpolate ${type} values`);
}
function tweened(value, defaults2 = {}) {
  const store = writable(value);
  let task;
  let target_value = value;
  function set(new_value, opts) {
    if (value == null) {
      store.set(value = new_value);
      return Promise.resolve();
    }
    target_value = new_value;
    let previous_task = task;
    let started = false;
    let {
      delay = 0,
      duration = 400,
      easing = identity,
      interpolate = get_interpolator
    } = assign(assign({}, defaults2), opts);
    if (duration === 0) {
      if (previous_task) {
        previous_task.abort();
        previous_task = null;
      }
      store.set(value = target_value);
      return Promise.resolve();
    }
    const start = now() + delay;
    let fn;
    task = loop((now2) => {
      if (now2 < start)
        return true;
      if (!started) {
        fn = interpolate(value, new_value);
        if (typeof duration === "function")
          duration = duration(value, new_value);
        started = true;
      }
      if (previous_task) {
        previous_task.abort();
        previous_task = null;
      }
      const elapsed = now2 - start;
      if (elapsed > /** @type {number} */
      duration) {
        store.set(value = new_value);
        return false;
      }
      store.set(value = fn(easing(elapsed / duration)));
      return true;
    });
    return task.promise;
  }
  return {
    set,
    update: (fn, opts) => set(fn(target_value, value), opts),
    subscribe: store.subscribe
  };
}
const Tile_svelte_svelte_type_style_lang = "";
function create_fragment$2o(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let t1_value = 2 ** /*tile*/
  ctx[0].value + "";
  let t1;
  let div2_class_value;
  let div2_intro;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      attr(div0, "class", "bg svelte-z1j0zj");
      attr(div1, "class", "value svelte-z1j0zj");
      attr(div2, "class", div2_class_value = "tile tile-" + /*tile*/
      ctx[0].value + " svelte-z1j0zj");
      set_style(
        div2,
        "top",
        /*top*/
        ctx[2] + "px"
      );
      set_style(
        div2,
        "left",
        /*left*/
        ctx[1] + "px"
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t0);
      append(div2, div1);
      append(div1, t1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*tile*/
      1 && t1_value !== (t1_value = 2 ** /*tile*/
      ctx2[0].value + ""))
        set_data(t1, t1_value);
      if (dirty & /*tile*/
      1 && div2_class_value !== (div2_class_value = "tile tile-" + /*tile*/
      ctx2[0].value + " svelte-z1j0zj")) {
        attr(div2, "class", div2_class_value);
      }
      if (dirty & /*top*/
      4) {
        set_style(
          div2,
          "top",
          /*top*/
          ctx2[2] + "px"
        );
      }
      if (dirty & /*left*/
      2) {
        set_style(
          div2,
          "left",
          /*left*/
          ctx2[1] + "px"
        );
      }
    },
    i(local) {
      if (local) {
        if (!div2_intro) {
          add_render_callback(() => {
            div2_intro = create_in_transition(
              div2,
              /*scale*/
              ctx[5],
              { duration: 400 }
            );
            div2_intro.start();
          });
        }
      }
    },
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function instance$2e($$self, $$props, $$invalidate) {
  let top;
  let left;
  let $leftTweened;
  let $topTweened;
  let { tile: tile2 } = $$props;
  const topTweened = tweened((tile2.new ? tile2.position.top : tile2.prevPosition.top) / 3, { duration: 200, easing: cubicOut });
  component_subscribe($$self, topTweened, (value) => $$invalidate(7, $topTweened = value));
  const leftTweened = tweened((tile2.new ? tile2.position.left : tile2.prevPosition.left) / 3, { duration: 200, easing: cubicOut });
  component_subscribe($$self, leftTweened, (value) => $$invalidate(6, $leftTweened = value));
  onMount(() => {
    var _a, _b;
    topTweened.set(((_a = tile2.position) == null ? void 0 : _a.top) / 3);
    leftTweened.set(((_b = tile2.position) == null ? void 0 : _b.left) / 3);
  });
  const scale = (node, { duration }) => {
    return {
      duration,
      css: (t2) => {
        const eased = tile2.new ? cubicOut(t2) : 1;
        return `
          transform: scale(${eased});
          `;
      }
    };
  };
  $$self.$$set = ($$props2) => {
    if ("tile" in $$props2)
      $$invalidate(0, tile2 = $$props2.tile);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$topTweened*/
    128) {
      $$invalidate(2, top = $topTweened * 255);
    }
    if ($$self.$$.dirty & /*$leftTweened*/
    64) {
      $$invalidate(1, left = $leftTweened * 255);
    }
  };
  return [tile2, left, top, topTweened, leftTweened, scale, $leftTweened, $topTweened];
}
class Tile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2e, create_fragment$2o, safe_not_equal, { tile: 0 });
  }
}
const Tablet_svelte_svelte_type_style_lang = "";
function get_each_context$w(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2];
  return child_ctx;
}
function get_each_context_1$5(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  return child_ctx;
}
function create_each_block_1$5(ctx) {
  let div;
  let div_class_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = "box box-" + /*box*/
      ctx[4] + " svelte-1e1u1ij");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*tablet*/
      1 && div_class_value !== (div_class_value = "box box-" + /*box*/
      ctx2[4] + " svelte-1e1u1ij")) {
        attr(div, "class", div_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block$_(ctx) {
  let tile_1;
  let current;
  tile_1 = new Tile({ props: { tile: (
    /*tile*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(tile_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tile_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tile_1_changes = {};
      if (dirty & /*tablet*/
      1)
        tile_1_changes.tile = /*tile*/
        ctx2[1];
      tile_1.$set(tile_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tile_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tile_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tile_1, detaching);
    }
  };
}
function create_each_block$w(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*tile*/
    ctx[1].position && create_if_block$_(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*tile*/
        ctx2[1].position
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*tablet*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$_(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$2n(ctx) {
  let div1;
  let t2;
  let div0;
  let current;
  let each_value_1 = ensure_array_like([...Array(
    /*tablet*/
    ctx[0].length ** 2
  ).keys()]);
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i2));
  }
  let each_value = ensure_array_like(
    /*tablet*/
    ctx[0].flatMap(func)
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$w(get_each_context$w(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t2 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div0, "class", "tiles svelte-1e1u1ij");
      attr(div1, "class", "grid wrapper svelte-1e1u1ij");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(div1, null);
        }
      }
      append(div1, t2);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Array, tablet*/
      1) {
        each_value_1 = ensure_array_like([...Array(
          /*tablet*/
          ctx2[0].length ** 2
        ).keys()]);
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$5(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
          } else {
            each_blocks_1[i2] = create_each_block_1$5(child_ctx);
            each_blocks_1[i2].c();
            each_blocks_1[i2].m(div1, t2);
          }
        }
        for (; i2 < each_blocks_1.length; i2 += 1) {
          each_blocks_1[i2].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & /*tablet*/
      1) {
        each_value = ensure_array_like(
          /*tablet*/
          ctx2[0].flatMap(func)
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$w(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$w(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
const func = (row) => row;
function instance$2d($$self, $$props, $$invalidate) {
  let { tablet } = $$props;
  $$self.$$set = ($$props2) => {
    if ("tablet" in $$props2)
      $$invalidate(0, tablet = $$props2.tablet);
  };
  return [tablet];
}
class Tablet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2d, create_fragment$2n, safe_not_equal, { tablet: 0 });
  }
}
function create_if_block$Z(ctx) {
  let header2;
  let t2;
  let tablet;
  let current;
  header2 = new Header4({
    props: {
      state: (
        /*$gameState*/
        ctx[0]
      ),
      newGame: (
        /*newGame*/
        ctx[2]
      )
    }
  });
  tablet = new Tablet({
    props: { tablet: (
      /*$gameState*/
      ctx[0].tablet
    ) }
  });
  return {
    c() {
      create_component(header2.$$.fragment);
      t2 = space();
      create_component(tablet.$$.fragment);
    },
    m(target, anchor) {
      mount_component(header2, target, anchor);
      insert(target, t2, anchor);
      mount_component(tablet, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty & /*$gameState*/
      1)
        header_changes.state = /*$gameState*/
        ctx2[0];
      header2.$set(header_changes);
      const tablet_changes = {};
      if (dirty & /*$gameState*/
      1)
        tablet_changes.tablet = /*$gameState*/
        ctx2[0].tablet;
      tablet.$set(tablet_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header2.$$.fragment, local);
      transition_in(tablet.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header2.$$.fragment, local);
      transition_out(tablet.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(header2, detaching);
      destroy_component(tablet, detaching);
    }
  };
}
function create_fragment$2m(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$gameState*/
    ctx[0] && create_if_block$Z(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          window,
          "keydown",
          /*handleKeydown*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*$gameState*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$gameState*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$Z(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
const dimension = 4;
function instance$2c($$self, $$props, $$invalidate) {
  let $gameState;
  let $focusedWindowId;
  component_subscribe($$self, focusedWindowId, ($$value) => $$invalidate(6, $focusedWindowId = $$value));
  let { runtime } = $$props;
  let { app } = $$props;
  const gameState = writable();
  component_subscribe($$self, gameState, (value) => $$invalidate(0, $gameState = value));
  const newGame = () => {
    gameState.set(runtime.genInitialState(dimension));
  };
  gameState.subscribe((v2) => {
    if (!v2 || !v2.score)
      return;
    setAppPreference(app.id, "state", {
      score: v2.score,
      finished: v2.finished,
      tablet: v2.tablet,
      dimension: v2.dimension
    });
  });
  onMount(() => {
    newGame();
    const saved = getAppPreference(app.id, "state");
    if (typeof saved !== "object")
      return;
    if (!Object.keys(saved).length)
      return;
    set_store_value(gameState, $gameState.score = saved.score, $gameState);
    set_store_value(gameState, $gameState.dimension = saved.dimension, $gameState);
    set_store_value(gameState, $gameState.tablet = saved.tablet, $gameState);
    set_store_value(gameState, $gameState.finished = saved.finished, $gameState);
  });
  const handleKeydown = (event) => {
    if ($focusedWindowId !== app.id || CurrentState.key !== "desktop")
      return;
    if ($gameState.actions[event.key]) {
      set_store_value(gameState, $gameState = $gameState.actions[event.key]($gameState), $gameState);
    }
  };
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(4, runtime = $$props2.runtime);
    if ("app" in $$props2)
      $$invalidate(5, app = $$props2.app);
  };
  return [$gameState, gameState, newGame, handleKeydown, runtime, app];
}
class TwentySvelte extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2c, create_fragment$2m, safe_not_equal, { runtime: 4, app: 5 });
  }
}
class TwentyUtil {
  constructor(app) {
    __publicField(this, "app");
    __publicField(this, "genNewTileValue", () => Math.random() > 0.9 ? 2 : 1);
    __publicField(this, "isEmptyTile", (tile2) => tile2.value === 0);
    __publicField(this, "transpose", (matrix) => {
      return matrix.reduce(
        (prev, next) => next.map((item, i2) => [...prev[i2] || [], next[i2]]),
        []
      );
    });
    __publicField(this, "reverse", (matrix) => matrix.map((row) => row.reverse()));
    this.app = app;
  }
}
class TwentyRuntime extends AppRuntime {
  constructor(app) {
    super(app);
    __publicField(this, "util");
    __publicField(this, "genRow", (dimension2) => [...Array(dimension2).keys()].map(() => ({
      value: 0,
      merged: false,
      new: false,
      swipe: false
    })));
    __publicField(this, "genTablet", (dimension2) => [...Array(dimension2).keys()].map(() => this.genRow(dimension2)));
    __publicField(this, "hasEmptyTiles", (tablet) => tablet.filter(
      (row) => row.filter((tile2) => this.util.isEmptyTile(tile2)).length > 0
    ).length > 0);
    __publicField(this, "populateNewTile", (arr, row, tile2) => {
      return [
        ...arr.slice(0, row),
        [
          ...arr[row].slice(0, tile2),
          {
            ...arr[row][tile2],
            value: this.util.genNewTileValue(),
            new: true,
            position: { top: row, left: tile2 }
          },
          ...arr[row].slice(tile2 + 1, arr[row].length)
        ],
        ...arr.slice(row + 1, arr.length)
      ];
    });
    __publicField(this, "reposition", (tablet) => {
      return tablet.map(
        (row, rowIndex) => row.map((tile2, tileIndex) => ({
          ...tile2,
          new: false,
          ...tile2.position ? { prevPosition: tile2.position } : {},
          ...tile2.value > 0 ? { position: { top: rowIndex, left: tileIndex } } : {}
        }))
      );
    });
    __publicField(this, "genNewTiles", (tablet) => {
      if (!this.hasEmptyTiles(tablet))
        return tablet;
      const randomRow = Math.floor(Math.random() * tablet.length);
      const randomTile = Math.floor(Math.random() * tablet.length);
      return this.util.isEmptyTile(tablet[randomRow][randomTile]) ? this.populateNewTile(tablet, randomRow, randomTile) : this.genNewTiles(tablet);
    });
    __publicField(this, "merge", (row) => {
      const current = row[0];
      const next = row[1];
      const canMerge = Boolean(current) && Boolean(next) && current.value === next.value;
      const newRow = row.slice(canMerge ? 2 : 1);
      return [
        ...canMerge ? [{ ...current, value: current.value + 1, merged: true }] : [...Boolean(current) ? [current] : []],
        ...newRow.length > 1 ? this.merge(newRow) : Boolean(next) && !canMerge ? [next] : newRow
      ];
    });
    __publicField(this, "normalize", (tablet) => {
      return tablet.map((row, rowIndex) => {
        const noZeroTiles = row.filter((tile2) => !this.util.isEmptyTile(tile2));
        const merged = this.merge(noZeroTiles);
        return [...merged, ...this.genRow(tablet.length - merged.length)];
      });
    });
    __publicField(this, "getScore", (tablet) => tablet.reduce(
      (score, row) => row.reduce(
        (rowScore, tile2) => (tile2.value > 0 ? 2 ** tile2.value : 0) + rowScore,
        0
      ) + score,
      0
    ));
    __publicField(this, "nextState", (state, newTablet) => ({
      ...state,
      finished: false,
      score: this.getScore(newTablet),
      tablet: newTablet
    }));
    __publicField(this, "genInitialState", (dimension2) => {
      const state = {
        dimension: dimension2,
        score: 0,
        finished: false,
        tablet: this.genNewTiles(this.genTablet(dimension2)),
        actions: {
          ArrowUp: (state2) => this.nextState(
            state2,
            this.genNewTiles(
              this.reposition(
                this.util.transpose(
                  this.normalize(this.util.transpose(state2.tablet))
                )
              )
            )
          ),
          ArrowDown: (state2) => this.nextState(
            state2,
            this.genNewTiles(
              this.reposition(
                this.util.transpose(
                  this.normalize(this.util.transpose(state2.tablet.reverse()))
                ).reverse()
              )
            )
          ),
          ArrowLeft: (state2) => this.nextState(
            state2,
            this.genNewTiles(this.reposition(this.normalize(state2.tablet)))
          ),
          ArrowRight: (state2) => this.nextState(
            state2,
            this.genNewTiles(
              this.reposition(
                this.util.reverse(
                  this.normalize(this.util.reverse(state2.tablet))
                )
              )
            )
          )
        }
      };
      return state;
    });
    this.util = new TwentyUtil(app);
  }
}
const TwentyFourtyEight = {
  info: {
    name: "2048",
    description: "the 2048-game in ArcOS",
    builtin: true,
    version: "1.0.0",
    author: "GuilhermeBohnstedt (ArcOS port by IzK)",
    icon: TwentyIcon,
    appGroup: "entertainment"
  },
  size: { w: 354, h: NaN },
  pos: { x: 30, y: 40 },
  minSize: { w: 354, h: 436 },
  maxSize: { w: 354, h: 446 },
  controls: { min: true, max: false, cls: true },
  state: {
    headless: false,
    resizable: false,
    windowState: { min: false, max: false, fll: false }
  },
  content: TwentySvelte,
  glass: true,
  runtime: TwentyRuntime
};
const UpdateNotice$2 = "";
let GITHUB_CACHE = null;
async function getLatestRelease() {
  if (GITHUB_CACHE)
    return GITHUB_CACHE;
  try {
    const req = await (await fetch(
      "https://api.github.com/repos/IzK-ArcOS/ArcOS-Frontend/releases/latest",
      { cache: "no-store" }
    )).json();
    GITHUB_CACHE = req;
    return req;
  } catch {
    return null;
  }
}
async function getLatestVersion() {
  const current = parseVersion(ArcOSVersion);
  try {
    const req = await getLatestRelease();
    if (!req)
      return current;
    const version = parseVersion(filterTagName(req.tag_name));
    if (versionBigger(version, current))
      return version;
    return current;
  } catch {
    return current;
  }
}
function parseVersion(verStr) {
  const split = verStr.replaceAll("v", "").split(".");
  return [split[0], split[1], split[2]].map((a2) => {
    try {
      return parseInt(a2);
    } catch {
      return 0;
    }
  });
}
function filterTagName(tn) {
  if (!tn)
    return ArcOSVersion;
  return tn.split("-")[0];
}
function versionBigger(a2, b2) {
  for (let i2 = 0; i2 < a2.length; i2++) {
    if (a2[i2] > b2[i2])
      return true;
  }
  return false;
}
async function checkForUpdates() {
  if (DESKTOP_MODE !== "desktop")
    return;
  const release2 = await getLatestVersion();
  if (versionBigger(release2, parseVersion(ArcOSVersion))) {
    openWindow("UpdateNotice");
  }
}
function create_fragment$2l(ctx) {
  let div4;
  let img;
  let img_src_value;
  let t0;
  let div2;
  let h1;
  let t2;
  let div1;
  let p0;
  let t3;
  let t4;
  let t5;
  let div0;
  let t6;
  let p1;
  let button0;
  let t8;
  let p2;
  let t11;
  let div3;
  let button1;
  let t13;
  let button2;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      img = element("img");
      t0 = space();
      div2 = element("div");
      h1 = element("h1");
      h1.textContent = "Update available!";
      t2 = space();
      div1 = element("div");
      p0 = element("p");
      t3 = text("ArcOS ");
      t4 = text(
        /*version*/
        ctx[0]
      );
      t5 = space();
      div0 = element("div");
      t6 = space();
      p1 = element("p");
      button0 = element("button");
      button0.textContent = "Changelog";
      t8 = space();
      p2 = element("p");
      p2.innerHTML = `Update now to get the latest features,<br/>
    bug fixes and stability improvements.`;
      t11 = space();
      div3 = element("div");
      button1 = element("button");
      button1.textContent = "Download";
      t13 = space();
      button2 = element("button");
      button2.textContent = "Don't show again";
      if (!src_url_equal(img.src, img_src_value = UpdateIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "Update");
      attr(p0, "class", "part");
      attr(div0, "class", "dot");
      attr(button0, "class", "changelog");
      attr(p1, "class", "part");
      attr(div1, "class", "sub");
      attr(div2, "class", "header");
      attr(p2, "class", "context");
      attr(button1, "class", "download");
      attr(button2, "class", "cancel");
      attr(div3, "class", "bottom");
      attr(div4, "class", "updatenotice");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, img);
      append(div4, t0);
      append(div4, div2);
      append(div2, h1);
      append(div2, t2);
      append(div2, div1);
      append(div1, p0);
      append(p0, t3);
      append(p0, t4);
      append(div1, t5);
      append(div1, div0);
      append(div1, t6);
      append(div1, p1);
      append(p1, button0);
      append(div4, t8);
      append(div4, p2);
      append(div4, t11);
      append(div4, div3);
      append(div3, button1);
      append(div3, t13);
      append(div3, button2);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*changeLog*/
            ctx[2]
          ),
          listen(button1, "click", openRelease),
          listen(
            button2,
            "click",
            /*cancel*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*version*/
      1)
        set_data(
          t4,
          /*version*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function openRelease() {
  const RELEASE_URL = "https://github.com/IzK-ArcOS/ArcOS-Frontend/releases/latest";
  window.open(RELEASE_URL, "_blank");
}
function instance$2b($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let version = "";
  onMount(async () => {
    $$invalidate(0, version = parseVersion(filterTagName((await getLatestRelease()).tag_name)).join("."));
  });
  function cancel() {
    disableApp(app.id);
  }
  function changeLog() {
    showOverlay("changeLog", app.id);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(3, app = $$props2.app);
  };
  return [version, cancel, changeLog, app];
}
let UpdateNotice$1 = class UpdateNotice extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2b, create_fragment$2l, safe_not_equal, { app: 3 });
  }
};
let ARCOS_BUILD = "unknown";
async function getBuild() {
  Log(
    "ts/branding/build.ts: getBuild",
    "Attempting to retrieve git hash from /build"
  );
  try {
    const req = await (await fetch("./build")).text();
    const str = req.split("\n")[0].trim();
    ARCOS_BUILD = str.startsWith("<!") ? "unknown" : str;
  } catch {
    ARCOS_BUILD = "unknown";
  }
}
function create_fragment$2k(ctx) {
  let div1;
  let div0;
  let h1;
  let t1;
  let p2;
  let t2;
  let t3_value = (
    /*version*/
    ctx[1].join(".") + ""
  );
  let t3;
  let t4;
  let img;
  let img_src_value;
  let t5;
  let div2;
  let sveltemarkdown;
  let t6;
  let div5;
  let div3;
  let t14;
  let div4;
  let button;
  let current;
  let mounted;
  let dispose;
  sveltemarkdown = new SvelteMarkdown({ props: { source: (
    /*changelog*/
    ctx[0]
  ) } });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      h1 = element("h1");
      h1.textContent = "Update Changelog";
      t1 = space();
      p2 = element("p");
      t2 = text("ArcOS v");
      t3 = text(t3_value);
      t4 = space();
      img = element("img");
      t5 = space();
      div2 = element("div");
      create_component(sveltemarkdown.$$.fragment);
      t6 = space();
      div5 = element("div");
      div3 = element("div");
      div3.textContent = `current: ${ArcOSVersion}-${ARCOS_MODE} (${ARCOS_BUILD || "<build>"})`;
      t14 = space();
      div4 = element("div");
      button = element("button");
      button.textContent = "I see";
      attr(p2, "class", "version");
      attr(div0, "class", "left");
      if (!src_url_equal(img.src, img_src_value = UploadIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(img, "class", "icon");
      attr(div1, "class", "header");
      attr(div2, "class", "markdownrenderer");
      attr(div3, "class", "current");
      attr(div4, "class", "actions");
      attr(div5, "class", "bottom");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, h1);
      append(div0, t1);
      append(div0, p2);
      append(p2, t2);
      append(p2, t3);
      append(div1, t4);
      append(div1, img);
      insert(target, t5, anchor);
      insert(target, div2, anchor);
      mount_component(sveltemarkdown, div2, null);
      insert(target, t6, anchor);
      insert(target, div5, anchor);
      append(div5, div3);
      append(div5, t14);
      append(div5, div4);
      append(div4, button);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*close*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*version*/
      2) && t3_value !== (t3_value = /*version*/
      ctx2[1].join(".") + ""))
        set_data(t3, t3_value);
      const sveltemarkdown_changes = {};
      if (dirty & /*changelog*/
      1)
        sveltemarkdown_changes.source = /*changelog*/
        ctx2[0];
      sveltemarkdown.$set(sveltemarkdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sveltemarkdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sveltemarkdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t5);
        detach(div2);
        detach(t6);
        detach(div5);
      }
      destroy_component(sveltemarkdown);
      mounted = false;
      dispose();
    }
  };
}
function instance$2a($$self, $$props, $$invalidate) {
  let changelog = "";
  let version = [];
  onMount(async () => {
    const release2 = await getLatestRelease();
    $$invalidate(1, version = parseVersion(filterTagName(release2.tag_name)));
    $$invalidate(0, changelog = release2.body || "### Unable to get release\nGitHub API limit may have been reached! Please try again later.");
  });
  function close() {
    hideOverlay("changeLog", "UpdateNotice");
  }
  return [changelog, version, close];
}
class ChangeLog extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2a, create_fragment$2k, safe_not_equal, {});
  }
}
const UpdateNotice2 = {
  info: {
    name: "Update Notice",
    description: "New update available!",
    builtin: true,
    version: ArcOSVersion,
    author: "ArcOS Team",
    icon: UpdateIcon,
    appGroup: "coreApps",
    hidden: true
  },
  size: { w: NaN, h: NaN },
  pos: { x: 0, y: 0 },
  minSize: { w: NaN, h: NaN },
  maxSize: { w: NaN, h: NaN },
  controls: { min: false, max: false, cls: false },
  state: {
    headless: true,
    resizable: false,
    windowState: { min: false, max: false, fll: true }
  },
  content: UpdateNotice$1,
  glass: false,
  events: {},
  overlays: {
    changeLog: {
      info: {
        name: "Changelog",
        author: "ArcOS Team",
        version: ArcOSVersion
      },
      size: { w: 600, h: 400 },
      show: false,
      content: ChangeLog
    }
  }
};
const experiments = "";
function get_each_context$v(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  child_ctx[4] = list2;
  child_ctx[5] = i2;
  return child_ctx;
}
function create_else_block$j(ctx) {
  let t2;
  return {
    c() {
      t2 = text("err");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block$Y(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(Object.entries(
    /*$Experiments*/
    ctx[1]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$v(get_each_context$v(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData, Object, $Experiments*/
      3) {
        each_value = ensure_array_like(Object.entries(
          /*$Experiments*/
          ctx2[1]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$v(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$v(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$v(ctx) {
  let div2;
  let div0;
  let h3;
  let t0_value = (
    /*entry*/
    ctx[3][1].title + ""
  );
  let t0;
  let t1;
  let p2;
  let t2_value = (
    /*entry*/
    ctx[3][1].description + ""
  );
  let t2;
  let t3;
  let div1;
  let input;
  let t4;
  let mounted;
  let dispose;
  function input_change_handler() {
    ctx[2].call(
      input,
      /*entry*/
      ctx[3]
    );
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = space();
      p2 = element("p");
      t2 = text(t2_value);
      t3 = space();
      div1 = element("div");
      input = element("input");
      t4 = space();
      attr(h3, "class", "title");
      attr(p2, "class", "description");
      attr(div0, "class", "info");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
      attr(div1, "class", "right");
      attr(div2, "class", "experiment");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, h3);
      append(h3, t0);
      append(div0, t1);
      append(div0, p2);
      append(p2, t2);
      append(div2, t3);
      append(div2, div1);
      append(div1, input);
      input.checked = /*$UserData*/
      ctx[0].appdata.experiments[
        /*entry*/
        ctx[3][0]
      ];
      append(div2, t4);
      if (!mounted) {
        dispose = listen(input, "change", input_change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$Experiments*/
      2 && t0_value !== (t0_value = /*entry*/
      ctx[3][1].title + ""))
        set_data(t0, t0_value);
      if (dirty & /*$Experiments*/
      2 && t2_value !== (t2_value = /*entry*/
      ctx[3][1].description + ""))
        set_data(t2, t2_value);
      if (dirty & /*$UserData, Object, $Experiments*/
      3) {
        input.checked = /*$UserData*/
        ctx[0].appdata.experiments[
          /*entry*/
          ctx[3][0]
        ];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2j(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*$UserData*/
      ctx2[0].appdata.experiments
    )
      return create_if_block$Y;
    return create_else_block$j;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function instance$29($$self, $$props, $$invalidate) {
  let $UserData;
  let $Experiments;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(0, $UserData = $$value));
  component_subscribe($$self, Experiments, ($$value) => $$invalidate(1, $Experiments = $$value));
  onMount(async () => {
    if (!$UserData.appdata.experiments)
      set_store_value(UserData$2, $UserData.appdata.experiments = {}, $UserData);
  });
  function input_change_handler(entry) {
    $UserData.appdata.experiments[entry[0]] = this.checked;
    UserData$2.set($UserData);
  }
  return [$UserData, $Experiments, input_change_handler];
}
class Experiments_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$29, create_fragment$2j, safe_not_equal, {});
  }
}
function create_fragment$2i(ctx) {
  let p2;
  let t1;
  let div;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "Experiments are used to test potential new features for ArcOS. Because of this\n  these features are all still in the utmost active development. Bugs can and\n  will arise. Please do not use this application without first acknowledging the\n  consequences. You've been warned.";
      t1 = space();
      div = element("div");
      div.innerHTML = `<input type="checkbox" id="c"/> <label for="c">Don&#39;t show this again</label>`;
      attr(div, "class", "check");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
        detach(t1);
        detach(div);
      }
    }
  };
}
class Warning extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$2i, safe_not_equal, {});
  }
}
const ExperimentsApp = {
  info: {
    name: "Experiments",
    description: "Spooky scary experiments",
    builtin: true,
    version: "1.0.0",
    author: "Izaak Kuipers",
    icon: UpdateIcon,
    hidden: true
  },
  size: { w: 500, h: 600 },
  pos: { x: 30, y: 40 },
  minSize: { w: 500, h: 600 },
  maxSize: { w: 500, h: 600 },
  controls: { min: false, max: false, cls: true },
  state: {
    headless: false,
    resizable: false,
    windowState: { min: false, max: false, fll: false }
  },
  content: Experiments_1,
  glass: false,
  events: {
    open(app) {
      createOverlayableError(
        {
          title: "Please use this application with caution.",
          component: Warning,
          buttons: [
            { caption: "I see, I want to proceed", action() {
            } },
            {
              caption: "Sounds like pain, get me out",
              action() {
                closeWindow(app.id);
              },
              suggested: true
            }
          ]
        },
        app.id
      );
    }
  }
};
const SettingsApp$2 = "";
const currentSettingsPage = writable(null);
const currentCollapsibleT = writable(null);
function setSettingsPage(page) {
  Log(
    "apps/SettingsApp",
    `Opening settings page '${page.name}'`,
    LogLevel.info
  );
  currentCollapsibleT.set(null);
  currentSettingsPage.set(page);
  hotSwapAppIcon(page.icon, "SettingsApp");
  setTitleSuffix(` - ${page.name}`, "SettingsApp");
}
function create_if_block$X(ctx) {
  let div;
  let switch_instance;
  let div_class_value;
  let current;
  var switch_value = (
    /*settingsPage*/
    ctx[2].content
  );
  function switch_props(ctx2, dirty) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "class", div_class_value = "inner " + /*cName*/
      ctx[1] + " " + /*settingsPage*/
      (ctx[2].className || ""));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*settingsPage*/
      4 && switch_value !== (switch_value = /*settingsPage*/
      ctx2[2].content)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      }
      if (!current || dirty & /*cName, settingsPage*/
      6 && div_class_value !== (div_class_value = "inner " + /*cName*/
      ctx2[1] + " " + /*settingsPage*/
      (ctx2[2].className || ""))) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_fragment$2h(ctx) {
  let div;
  let current;
  let if_block = (
    /*settingsPage*/
    ctx[2] && create_if_block$X(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "content");
      toggle_class(
        div,
        "collapsed",
        /*appdata*/
        ctx[0].collapsed
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*settingsPage*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*settingsPage*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$X(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*appdata*/
      1) {
        toggle_class(
          div,
          "collapsed",
          /*appdata*/
          ctx2[0].collapsed
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$28($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(4, $UserData = $$value));
  let { appdata } = $$props;
  let cName = "";
  let settingsPage;
  let t2;
  currentSettingsPage.subscribe((v2) => {
    clearTimeout(t2);
    $$invalidate(1, cName = "static");
    if ($UserData && !$UserData.sh.anim && v2)
      return $$invalidate(2, settingsPage = v2);
    if (!v2 || settingsPage && v2.name == settingsPage.name)
      return;
    $$invalidate(1, cName = "slide-out-right");
    t2 = setTimeout(
      () => {
        $$invalidate(2, settingsPage = v2);
        $$invalidate(1, cName = "slide-in-left");
        t2 = setTimeout(
          () => {
            $$invalidate(1, cName = "static");
          },
          301
        );
      },
      500
    );
  });
  $$self.$$set = ($$props2) => {
    if ("appdata" in $$props2)
      $$invalidate(0, appdata = $$props2.appdata);
  };
  return [appdata, cName, settingsPage];
}
let Content$1 = class Content4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$28, create_fragment$2h, safe_not_equal, { appdata: 0 });
  }
};
const about = "";
function create_else_block$i(ctx) {
  let h3;
  let t2;
  return {
    c() {
      h3 = element("h3");
      t2 = text(
        /*header*/
        ctx[2]
      );
      attr(h3, "class", "header");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*header*/
      4)
        set_data(
          t2,
          /*header*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
      }
    }
  };
}
function create_if_block$W(ctx) {
  let div;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t2 = text(
        /*header*/
        ctx[2]
      );
      attr(div, "class", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*collapse*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*header*/
      4)
        set_data(
          t2,
          /*header*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2g(ctx) {
  let div1;
  let t2;
  let div0;
  let current;
  function select_block_type(ctx2, dirty) {
    if (
      /*collapsible*/
      ctx2[1]
    )
      return create_if_block$W;
    return create_else_block$i;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  return {
    c() {
      div1 = element("div");
      if_block.c();
      t2 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "section-content");
      attr(div1, "class", "section");
      toggle_class(
        div1,
        "collapsible",
        /*collapsible*/
        ctx[1]
      );
      toggle_class(
        div1,
        "collapsed",
        /*collapsed*/
        ctx[0]
      );
      toggle_class(
        div1,
        "opt",
        /*opt*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if_block.m(div1, null);
      append(div1, t2);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, t2);
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*collapsible*/
      2) {
        toggle_class(
          div1,
          "collapsible",
          /*collapsible*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*collapsed*/
      1) {
        toggle_class(
          div1,
          "collapsed",
          /*collapsed*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*opt*/
      8) {
        toggle_class(
          div1,
          "opt",
          /*opt*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$27($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { collapsible = false } = $$props;
  let { header: header2 } = $$props;
  let { collapsed = false } = $$props;
  let { opt = false } = $$props;
  currentCollapsibleT.subscribe((v2) => {
    if (!v2 || !collapsible)
      return;
    $$invalidate(0, collapsed = header2 != v2);
  });
  function collapse() {
    $$invalidate(0, collapsed = !collapsed);
    if (!collapsed)
      currentCollapsibleT.set(header2);
  }
  $$self.$$set = ($$props2) => {
    if ("collapsible" in $$props2)
      $$invalidate(1, collapsible = $$props2.collapsible);
    if ("header" in $$props2)
      $$invalidate(2, header2 = $$props2.header);
    if ("collapsed" in $$props2)
      $$invalidate(0, collapsed = $$props2.collapsed);
    if ("opt" in $$props2)
      $$invalidate(3, opt = $$props2.opt);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [collapsed, collapsible, header2, opt, collapse, $$scope, slots];
}
class Section extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$27, create_fragment$2g, safe_not_equal, {
      collapsible: 1,
      header: 2,
      collapsed: 0,
      opt: 3
    });
  }
}
function create_if_block$V(ctx) {
  let section;
  let current;
  section = new Section({
    props: {
      header: "Your System",
      collapsible: true,
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(section.$$.fragment);
    },
    m(target, anchor) {
      mount_component(section, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const section_changes = {};
      if (dirty & /*$$scope, desktopApp, deviceInfo*/
      11) {
        section_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section.$set(section_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(section.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(section.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(section, detaching);
    }
  };
}
function create_default_slot$9(ctx) {
  let div2;
  let div0;
  let t1;
  let div1;
  let t2_value = (
    /*deviceInfo*/
    ctx[0].cpu.cores + ""
  );
  let t2;
  let t3;
  let t4;
  let div5;
  let div3;
  let t6;
  let div4;
  let t7;
  let t8_value = formatBytes(
    /*deviceInfo*/
    ctx[0].mem.kb
  ) + "";
  let t8;
  let t9;
  let button;
  let t11;
  let div8;
  let div6;
  let t13;
  let div7;
  let t14_value = (
    /*deviceInfo*/
    ctx[0].gpu.vendor + ""
  );
  let t14;
  let t15;
  let t16_value = (
    /*deviceInfo*/
    ctx[0].gpu.model + ""
  );
  let t16;
  let t17;
  let div11;
  let div9;
  let t19;
  let div10;
  let t20_value = (
    /*desktopApp*/
    ctx[1] ? "Desktop app" : "Browser"
  );
  let t20;
  let t21;
  let div14;
  let div12;
  let t23;
  let div13;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "Processor";
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = text(" cores");
      t4 = space();
      div5 = element("div");
      div3 = element("div");
      div3.textContent = "Memory";
      t6 = space();
      div4 = element("div");
      t7 = text("~ ");
      t8 = text(t8_value);
      t9 = space();
      button = element("button");
      button.textContent = "help";
      t11 = space();
      div8 = element("div");
      div6 = element("div");
      div6.textContent = "Graphics card";
      t13 = space();
      div7 = element("div");
      t14 = text(t14_value);
      t15 = space();
      t16 = text(t16_value);
      t17 = space();
      div11 = element("div");
      div9 = element("div");
      div9.textContent = "ArcOS Mode";
      t19 = space();
      div10 = element("div");
      t20 = text(t20_value);
      t21 = space();
      div14 = element("div");
      div12 = element("div");
      div12.textContent = "Version";
      t23 = space();
      div13 = element("div");
      div13.textContent = `v${ArcOSVersion}-${ARCOS_MODE} (${ARCOS_BUILD})`;
      attr(div0, "class", "key");
      attr(div1, "class", "value");
      attr(div2, "class", "row");
      attr(div3, "class", "key");
      attr(button, "class", "material-icons-round info");
      attr(div4, "class", "value");
      attr(div5, "class", "row");
      attr(div6, "class", "key");
      attr(div7, "class", "value");
      attr(div8, "class", "row");
      attr(div9, "class", "key");
      attr(div10, "class", "value");
      attr(div11, "class", "row");
      attr(div12, "class", "key");
      attr(div13, "class", "value");
      attr(div14, "class", "row");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      append(div1, t3);
      insert(target, t4, anchor);
      insert(target, div5, anchor);
      append(div5, div3);
      append(div5, t6);
      append(div5, div4);
      append(div4, t7);
      append(div4, t8);
      append(div4, t9);
      append(div4, button);
      insert(target, t11, anchor);
      insert(target, div8, anchor);
      append(div8, div6);
      append(div8, t13);
      append(div8, div7);
      append(div7, t14);
      append(div7, t15);
      append(div7, t16);
      insert(target, t17, anchor);
      insert(target, div11, anchor);
      append(div11, div9);
      append(div11, t19);
      append(div11, div10);
      append(div10, t20);
      insert(target, t21, anchor);
      insert(target, div14, anchor);
      append(div14, div12);
      append(div14, t23);
      append(div14, div13);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*ramInfo*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*deviceInfo*/
      1 && t2_value !== (t2_value = /*deviceInfo*/
      ctx2[0].cpu.cores + ""))
        set_data(t2, t2_value);
      if (dirty & /*deviceInfo*/
      1 && t8_value !== (t8_value = formatBytes(
        /*deviceInfo*/
        ctx2[0].mem.kb
      ) + ""))
        set_data(t8, t8_value);
      if (dirty & /*deviceInfo*/
      1 && t14_value !== (t14_value = /*deviceInfo*/
      ctx2[0].gpu.vendor + ""))
        set_data(t14, t14_value);
      if (dirty & /*deviceInfo*/
      1 && t16_value !== (t16_value = /*deviceInfo*/
      ctx2[0].gpu.model + ""))
        set_data(t16, t16_value);
      if (dirty & /*desktopApp*/
      2 && t20_value !== (t20_value = /*desktopApp*/
      ctx2[1] ? "Desktop app" : "Browser"))
        set_data(t20, t20_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t4);
        detach(div5);
        detach(t11);
        detach(div8);
        detach(t17);
        detach(div11);
        detach(t21);
        detach(div14);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2f(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*deviceInfo*/
    ctx[0] && create_if_block$V(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*deviceInfo*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*deviceInfo*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$V(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$26($$self, $$props, $$invalidate) {
  let deviceInfo;
  let desktopApp = false;
  onMount(async () => {
    $$invalidate(0, deviceInfo = await getDeviceInfo());
    $$invalidate(1, desktopApp = isDesktop());
  });
  function ramInfo() {
    createOverlayableError(
      {
        title: "Information about system memory",
        message: "The memory amount visible to ArcOS may be less than you actually have. This is not a bug, but rather a limitation of the browser you are running. Most browsers can only detect up to 8GB of RAM.",
        buttons: [
          {
            caption: "Understood",
            action() {
            },
            suggested: true
          }
        ]
      },
      "SettingsApp"
    );
  }
  return [deviceInfo, desktopApp, ramInfo];
}
class SystemSection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$26, create_fragment$2f, safe_not_equal, {});
  }
}
function create_default_slot_2$4(ctx) {
  let t0;
  let a2;
  let t2;
  return {
    c() {
      t0 = text("The whole ArcOS project is licensed under GPLv3. More information about the\n    license and the project as a whole can be found in the README file of the\n    ");
      a2 = element("a");
      a2.textContent = "ArcOS project page";
      t2 = text(".");
      attr(a2, "href", "https://github.com/IzK-ArcOS");
      attr(a2, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, a2, anchor);
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(a2);
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$5(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Thanks to all the people who helped expand ArcOS to what it is today.\n    Curious who make ArcOS possible? Go ahead and visit our Frontend GitHub\n    page, we list our contributors there.");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$8(ctx) {
  let t0;
  let br0;
  let br1;
  let t1;
  return {
    c() {
      t0 = text("ArcOS started of as a weekend project, but these days it is a huge project\n    with tons of amazing features. Every version of this project up to this\n    point has been lead by me, Izaak Kuipers.");
      br0 = element("br");
      br1 = element("br");
      t1 = text("Feel free to visit our\n    GitHub for more information about the project, and how you can contribute to\n    it.");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, br0, anchor);
      insert(target, br1, anchor);
      insert(target, t1, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(br0);
        detach(br1);
        detach(t1);
      }
    }
  };
}
function create_fragment$2e(ctx) {
  let div3;
  let div2;
  let div0;
  let t0;
  let div1;
  let h1;
  let t3;
  let systemsection;
  let t4;
  let section0;
  let t5;
  let section1;
  let t6;
  let section2;
  let current;
  systemsection = new SystemSection({});
  section0 = new Section({
    props: {
      header: "License Information",
      collapsible: true,
      collapsed: true,
      $$slots: { default: [create_default_slot_2$4] },
      $$scope: { ctx }
    }
  });
  section1 = new Section({
    props: {
      header: "Credits",
      collapsible: true,
      collapsed: true,
      $$slots: { default: [create_default_slot_1$5] },
      $$scope: { ctx }
    }
  });
  section2 = new Section({
    props: {
      header: "About",
      collapsible: true,
      collapsed: true,
      $$slots: { default: [create_default_slot$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<img src="${Logo()}" alt="ArcOS" class="logo"/>`;
      t0 = space();
      div1 = element("div");
      h1 = element("h1");
      h1.textContent = `ArcOS v${ArcOSVersion}`;
      t3 = space();
      create_component(systemsection.$$.fragment);
      t4 = space();
      create_component(section0.$$.fragment);
      t5 = space();
      create_component(section1.$$.fragment);
      t6 = space();
      create_component(section2.$$.fragment);
      attr(h1, "class", "name");
      attr(div1, "class", "text");
      attr(div2, "class", "product");
      attr(div3, "class", "about-page");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, t0);
      append(div2, div1);
      append(div1, h1);
      append(div3, t3);
      mount_component(systemsection, div3, null);
      append(div3, t4);
      mount_component(section0, div3, null);
      append(div3, t5);
      mount_component(section1, div3, null);
      append(div3, t6);
      mount_component(section2, div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const section0_changes = {};
      if (dirty & /*$$scope*/
      1) {
        section0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section0.$set(section0_changes);
      const section1_changes = {};
      if (dirty & /*$$scope*/
      1) {
        section1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section1.$set(section1_changes);
      const section2_changes = {};
      if (dirty & /*$$scope*/
      1) {
        section2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section2.$set(section2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(systemsection.$$.fragment, local);
      transition_in(section0.$$.fragment, local);
      transition_in(section1.$$.fragment, local);
      transition_in(section2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(systemsection.$$.fragment, local);
      transition_out(section0.$$.fragment, local);
      transition_out(section1.$$.fragment, local);
      transition_out(section2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(systemsection);
      destroy_component(section0);
      destroy_component(section1);
      destroy_component(section2);
    }
  };
}
class About extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$2e, safe_not_equal, {});
  }
}
const account = "";
const OptionSection_svelte_svelte_type_style_lang = "";
function create_fragment$2d(ctx) {
  let div2;
  let div0;
  let h3;
  let t0;
  let t1;
  let p2;
  let t2;
  let t3;
  let div1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      h3 = element("h3");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      p2 = element("p");
      t2 = text(
        /*context*/
        ctx[1]
      );
      t3 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      attr(h3, "class", "header svelte-apc53m");
      toggle_class(
        h3,
        "asterisk",
        /*asterisk*/
        ctx[2]
      );
      attr(p2, "class", "context");
      attr(div1, "class", "opt-sel");
      attr(div2, "class", "section opt");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, h3);
      append(h3, t0);
      append(div0, t1);
      append(div0, p2);
      append(p2, t2);
      append(div2, t3);
      append(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*title*/
      1)
        set_data(
          t0,
          /*title*/
          ctx2[0]
        );
      if (!current || dirty & /*asterisk*/
      4) {
        toggle_class(
          h3,
          "asterisk",
          /*asterisk*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*context*/
      2)
        set_data(
          t2,
          /*context*/
          ctx2[1]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$25($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  let { context } = $$props;
  let { asterisk = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("context" in $$props2)
      $$invalidate(1, context = $$props2.context);
    if ("asterisk" in $$props2)
      $$invalidate(2, asterisk = $$props2.asterisk);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [title, context, asterisk, $$scope, slots];
}
class OptionSection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$25, create_fragment$2d, safe_not_equal, { title: 0, context: 1, asterisk: 2 });
  }
}
function create_default_slot_2$3(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Change...";
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*changeName*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$4(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Change...";
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*changePswd*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$7(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Delete account...";
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*deleteAccount*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2c(ctx) {
  let optionsection0;
  let t0;
  let optionsection1;
  let t1;
  let optionsection2;
  let current;
  optionsection0 = new OptionSection({
    props: {
      title: "Change username",
      context: "Migrate your userdata to another username.",
      $$slots: { default: [create_default_slot_2$3] },
      $$scope: { ctx }
    }
  });
  optionsection1 = new OptionSection({
    props: {
      title: "Change password",
      context: "Change the password you use to log in.",
      $$slots: { default: [create_default_slot_1$4] },
      $$scope: { ctx }
    }
  });
  optionsection2 = new OptionSection({
    props: {
      title: "Delete account",
      context: "Delete your ArcOS account",
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(optionsection0.$$.fragment);
      t0 = space();
      create_component(optionsection1.$$.fragment);
      t1 = space();
      create_component(optionsection2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(optionsection0, target, anchor);
      insert(target, t0, anchor);
      mount_component(optionsection1, target, anchor);
      insert(target, t1, anchor);
      mount_component(optionsection2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const optionsection0_changes = {};
      if (dirty & /*$$scope*/
      8) {
        optionsection0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection0.$set(optionsection0_changes);
      const optionsection1_changes = {};
      if (dirty & /*$$scope*/
      8) {
        optionsection1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection1.$set(optionsection1_changes);
      const optionsection2_changes = {};
      if (dirty & /*$$scope*/
      8) {
        optionsection2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection2.$set(optionsection2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(optionsection0.$$.fragment, local);
      transition_in(optionsection1.$$.fragment, local);
      transition_in(optionsection2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(optionsection0.$$.fragment, local);
      transition_out(optionsection1.$$.fragment, local);
      transition_out(optionsection2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(optionsection0, detaching);
      destroy_component(optionsection1, detaching);
      destroy_component(optionsection2, detaching);
    }
  };
}
function instance$24($$self) {
  function deleteAccount() {
    createOverlayableError(
      {
        title: "Delete ArcOS Account",
        message: "Are you sure you want to delete your ArcOS account? This will delete any and all user data associated with this account. These changes cannot be reverted.",
        image: ErrorIcon,
        buttons: [
          {
            action: () => deleteUser(),
            caption: "Proceed"
          },
          {
            action: () => {
            },
            caption: "Back to safety",
            suggested: true
          }
        ]
      },
      "SettingsApp"
    );
  }
  function changeName() {
    showOverlay("changeUsername", "SettingsApp");
  }
  function changePswd2() {
    showOverlay("changePswd", "SettingsApp");
  }
  return [deleteAccount, changeName, changePswd2];
}
class DangerZone extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$24, create_fragment$2c, safe_not_equal, {});
  }
}
function create_fragment$2b(ctx) {
  let div2;
  let div0;
  let profilepicture;
  let t0;
  let button;
  let t2;
  let div1;
  let p0;
  let t3;
  let t4;
  let p1;
  let apireveal;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*pfp*/
      ctx[0]
    ), height: 52 }
  });
  apireveal = new APIReveal({});
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      button = element("button");
      button.textContent = "edit";
      t2 = space();
      div1 = element("div");
      p0 = element("p");
      t3 = text(
        /*$UserName*/
        ctx[1]
      );
      t4 = space();
      p1 = element("p");
      create_component(apireveal.$$.fragment);
      attr(button, "class", "change material-icons-round");
      attr(p0, "class", "username");
      attr(p1, "class", "host");
      attr(p1, "data-contextmenu", "accountpage-hostname");
      attr(div2, "class", "info");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(profilepicture, div0, null);
      append(div0, t0);
      append(div0, button);
      append(div2, t2);
      append(div2, div1);
      append(div1, p0);
      append(p0, t3);
      append(div1, t4);
      append(div1, p1);
      mount_component(apireveal, p1, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*changePfp*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      1)
        profilepicture_changes.src = /*pfp*/
        ctx2[0];
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*$UserName*/
      2)
        set_data(
          t3,
          /*$UserName*/
          ctx2[1]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      transition_in(apireveal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      transition_out(apireveal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(profilepicture);
      destroy_component(apireveal);
      mounted = false;
      dispose();
    }
  };
}
function instance$23($$self, $$props, $$invalidate) {
  let $UserName;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(1, $UserName = $$value));
  let pfp = "";
  UserData$2.subscribe((v2) => {
    $$invalidate(0, pfp = getProfilePicture(v2.acc.profilePicture));
  });
  function changePfp() {
    showOverlay("pfpSel", "SettingsApp");
  }
  return [pfp, $UserName, changePfp];
}
class Profile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$23, create_fragment$2b, safe_not_equal, {});
  }
}
function create_fragment$2a(ctx) {
  let div;
  let profile;
  let t2;
  let dangerzone;
  let current;
  profile = new Profile({});
  dangerzone = new DangerZone({});
  return {
    c() {
      div = element("div");
      create_component(profile.$$.fragment);
      t2 = space();
      create_component(dangerzone.$$.fragment);
      attr(div, "class", "settingspage-account");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(profile, div, null);
      append(div, t2);
      mount_component(dangerzone, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(profile.$$.fragment, local);
      transition_in(dangerzone.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profile.$$.fragment, local);
      transition_out(dangerzone.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(profile);
      destroy_component(dangerzone);
    }
  };
}
class Account extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$2a, safe_not_equal, {});
  }
}
const apps = "";
function create_fragment$29(ctx) {
  let button;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let div;
  let p0;
  let t1_value = (
    /*app*/
    ctx[0].info.name + ""
  );
  let t1;
  let t2;
  let p1;
  let t3_value = (
    /*app*/
    ctx[0].info.description + ""
  );
  let t3;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      div = element("div");
      p0 = element("p");
      t1 = text(t1_value);
      t2 = space();
      p1 = element("p");
      t3 = text(t3_value);
      if (!src_url_equal(img.src, img_src_value = getOriginalIcon(
        /*app*/
        ctx[0].id
      ) || getAppIcon(
        /*app*/
        ctx[0]
      )))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*app*/
      ctx[0].info.name);
      attr(img, "class", "icon");
      attr(p0, "class", "title");
      attr(p1, "class", "description");
      attr(div, "class", "info");
      attr(button, "class", "appbutton");
      toggle_class(
        button,
        "disabled",
        /*app*/
        ctx[0].disabled
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, div);
      append(div, p0);
      append(p0, t1);
      append(div, t2);
      append(div, p1);
      append(p1, t3);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*manage*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*app*/
      1 && !src_url_equal(img.src, img_src_value = getOriginalIcon(
        /*app*/
        ctx2[0].id
      ) || getAppIcon(
        /*app*/
        ctx2[0]
      ))) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*app*/
      1 && img_alt_value !== (img_alt_value = /*app*/
      ctx2[0].info.name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*app*/
      1 && t1_value !== (t1_value = /*app*/
      ctx2[0].info.name + ""))
        set_data(t1, t1_value);
      if (dirty & /*app*/
      1 && t3_value !== (t3_value = /*app*/
      ctx2[0].info.description + ""))
        set_data(t3, t3_value);
      if (dirty & /*app*/
      1) {
        toggle_class(
          button,
          "disabled",
          /*app*/
          ctx2[0].disabled
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$22($$self, $$props, $$invalidate) {
  let { app } = $$props;
  function manage() {
    closeWindow("AppInfo");
    setTimeout(
      () => {
        AppInfoId.set(app.id);
        openWindow("AppInfo");
      },
      300
    );
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [app, manage];
}
let AppButton$1 = class AppButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$22, create_fragment$29, safe_not_equal, { app: 0 });
  }
};
function get_each_context$u(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2];
  return child_ctx;
}
function create_if_block$U(ctx) {
  let appbutton;
  let current;
  appbutton = new AppButton$1({ props: { app: (
    /*app*/
    ctx[5]
  ) } });
  return {
    c() {
      create_component(appbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(appbutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const appbutton_changes = {};
      if (dirty & /*apps*/
      1)
        appbutton_changes.app = /*app*/
        ctx2[5];
      appbutton.$set(appbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(appbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(appbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(appbutton, detaching);
    }
  };
}
function create_each_block$u(ctx) {
  let show_if = isPopulatable(
    /*app*/
    ctx[5]
  ) || /*$UserData*/
  ctx[2].sh.showHiddenApps;
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block$U(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*apps, $UserData*/
      5)
        show_if = isPopulatable(
          /*app*/
          ctx2[5]
        ) || /*$UserData*/
        ctx2[2].sh.showHiddenApps;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*apps, $UserData*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$U(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$28(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let p0;
  let t1_value = (
    /*$WindowStore*/
    ctx[1].length + ""
  );
  let t1;
  let t2;
  let t3;
  let span;
  let p1;
  let t5;
  let input;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*apps*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$u(get_each_context$u(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      div1 = element("div");
      p0 = element("p");
      t1 = text(t1_value);
      t2 = text(" applications");
      t3 = space();
      span = element("span");
      p1 = element("p");
      p1.textContent = "Show hidden apps";
      t5 = space();
      input = element("input");
      attr(div0, "class", "apps");
      attr(p1, "class", "label");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
      attr(span, "class", "right");
      attr(div1, "class", "bottom");
      attr(div2, "class", "page-apps");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div2, t0);
      append(div2, div1);
      append(div1, p0);
      append(p0, t1);
      append(p0, t2);
      append(div1, t3);
      append(div1, span);
      append(span, p1);
      append(span, t5);
      append(span, input);
      input.checked = /*$UserData*/
      ctx[2].sh.showHiddenApps;
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[4]
          ),
          listen(
            input,
            "click",
            /*update*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*apps, $UserData*/
      5) {
        each_value = ensure_array_like(
          /*apps*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$u(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$u(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if ((!current || dirty & /*$WindowStore*/
      2) && t1_value !== (t1_value = /*$WindowStore*/
      ctx2[1].length + ""))
        set_data(t1, t1_value);
      if (dirty & /*$UserData*/
      4) {
        input.checked = /*$UserData*/
        ctx2[2].sh.showHiddenApps;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$21($$self, $$props, $$invalidate) {
  let $WindowStore;
  let $UserData;
  component_subscribe($$self, WindowStore, ($$value) => $$invalidate(1, $WindowStore = $$value));
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(2, $UserData = $$value));
  let apps2 = [];
  WindowStore.subscribe((v2) => $$invalidate(0, apps2 = [...v2].sort((a2, b2) => a2.info.name > b2.info.name ? 0 : -1)));
  function update2() {
    WindowStore.set($WindowStore);
  }
  function input_change_handler() {
    $UserData.sh.showHiddenApps = this.checked;
    UserData$2.set($UserData);
  }
  return [apps2, $WindowStore, $UserData, update2, input_change_handler];
}
class Apps extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$21, create_fragment$28, safe_not_equal, {});
  }
}
const desktop$1 = "";
async function directSingleUpload(path, accept) {
  Log(
    "ts/api/upload.ts: directSingleUpload",
    `${path}: (${accept || "no accept"})`,
    LogLevel.info
  );
  if (path.endsWith("/"))
    path.slice(0, -1);
  const uploader = document.createElement("input");
  uploader.type = "file";
  uploader.accept = accept;
  const target = writable();
  uploader.onchange = async () => {
    const files = uploader.files;
    if (!files.length)
      target.set("");
    const file = uploader.files[0];
    target.set(await fileUpload(file, path));
  };
  uploader.click();
  return new Promise((resolve) => {
    target.subscribe((v2) => {
      if (!v2)
        return;
      resolve(v2);
    });
  });
}
async function fileUpload(file, dir) {
  Log(
    "ts/api/upload.ts: fileUpload",
    `Uploading ${file.name} to ${dir}`,
    LogLevel.info
  );
  const content2 = arrayToBlob(await file.arrayBuffer());
  const path = `${dir}/${file.name}`.split("//").join("/");
  const data = await fileToArcFile(file, path);
  fbState.update((v2) => {
    v2.uploadFile = data;
    return v2;
  });
  const valid = await writeFile(path, content2);
  fbClass.refresh();
  if (!valid)
    return "";
  return path;
}
const getters = [
  [
    "@local:",
    async (id) => await wallpaperFromFS(fromBase64(id.replace("@local:", "")))
  ],
  ["img", (id) => Wallpapers[id] || Wallpapers["img04"]]
];
async function getWallpaper(id, override) {
  if (!id)
    return Wallpapers["img04"];
  if (id.startsWith("http"))
    return { author: "The Web", name: id, url: id };
  for (let i2 = 0; i2 < getters.length; i2++) {
    if (id.startsWith(getters[i2][0]))
      return await getters[i2][1](id);
  }
  return Wallpapers[override || "img04"];
}
async function wallpaperFromFS(path) {
  Log(
    "wallpapers.ts: wallpaperFromFS",
    `Reading wallpaper from path "${path}"...`,
    LogLevel.info
  );
  const file = await readFile(path);
  if (!file) {
    Log(
      "wallpapers.ts: wallpaperFromFS",
      `Unable to get wallpaper "${path}"`,
      LogLevel.error
    );
    return Wallpapers["img04"];
  }
  const url = URL.createObjectURL(arrayToBlob(file, "image/jpeg"));
  return { url, author: get_store_value(UserName), name: url, source: "" };
}
function create_fragment$27(ctx) {
  let div4;
  let div0;
  let t0;
  let div3;
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      t0 = space();
      div3 = element("div");
      div3.innerHTML = `<div class="fake-titlebar">Window Title</div> <div class="fake-body">Window body</div>`;
      attr(div0, "class", "fake-taskbar shell-colored");
      toggle_class(
        div0,
        "colored",
        /*$UserData*/
        ctx[1].sh.taskbar.colored
      );
      toggle_class(
        div0,
        "docked",
        /*$UserData*/
        ctx[1].sh.taskbar.docked
      );
      attr(div3, "class", "fake-window");
      attr(div4, "class", "current");
      set_style(div4, "background-image", "url(" + /*url*/
      ctx[0] + ")");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div4, t0);
      append(div4, div3);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$UserData*/
      2) {
        toggle_class(
          div0,
          "colored",
          /*$UserData*/
          ctx2[1].sh.taskbar.colored
        );
      }
      if (dirty & /*$UserData*/
      2) {
        toggle_class(
          div0,
          "docked",
          /*$UserData*/
          ctx2[1].sh.taskbar.docked
        );
      }
      if (dirty & /*url*/
      1) {
        set_style(div4, "background-image", "url(" + /*url*/
        ctx2[0] + ")");
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
    }
  };
}
function instance$20($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(1, $UserData = $$value));
  let url = "";
  UserData$2.subscribe(async () => {
    $$invalidate(0, url = (await getWallpaper($UserData.sh.desktop.wallpaper)).url);
  });
  return [url, $UserData];
}
let Current$1 = class Current extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$20, create_fragment$27, safe_not_equal, {});
  }
};
function create_if_block$T(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "block";
      attr(span, "class", "material-icons-round none");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$26(ctx) {
  let div;
  let div_title_value;
  let mounted;
  let dispose;
  let if_block = (
    /*wallpaper*/
    ctx[0][0] == "img0" && create_if_block$T()
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "wallpaper");
      set_style(div, "background-image", "url(" + /*wallpaper*/
      ctx[0][1].url + ")");
      attr(div, "title", div_title_value = /*wallpaper*/
      ctx[0][0] == "img0" ? "(none)" : `${/*wallpaper*/
      ctx[0][1].name} from ${/*wallpaper*/
      ctx[0][1].author}`);
      toggle_class(
        div,
        "selected",
        /*$UserData*/
        ctx[1].sh.desktop.wallpaper == /*wallpaper*/
        ctx[0][0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*change*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*wallpaper*/
        ctx2[0][0] == "img0"
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$T();
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*wallpaper*/
      1) {
        set_style(div, "background-image", "url(" + /*wallpaper*/
        ctx2[0][1].url + ")");
      }
      if (dirty & /*wallpaper*/
      1 && div_title_value !== (div_title_value = /*wallpaper*/
      ctx2[0][0] == "img0" ? "(none)" : `${/*wallpaper*/
      ctx2[0][1].name} from ${/*wallpaper*/
      ctx2[0][1].author}`)) {
        attr(div, "title", div_title_value);
      }
      if (dirty & /*$UserData, wallpaper*/
      3) {
        toggle_class(
          div,
          "selected",
          /*$UserData*/
          ctx2[1].sh.desktop.wallpaper == /*wallpaper*/
          ctx2[0][0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$1$($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(1, $UserData = $$value));
  let { wallpaper } = $$props;
  function change() {
    set_store_value(UserData$2, $UserData.sh.desktop.wallpaper = wallpaper[0], $UserData);
  }
  $$self.$$set = ($$props2) => {
    if ("wallpaper" in $$props2)
      $$invalidate(0, wallpaper = $$props2.wallpaper);
  };
  return [wallpaper, $UserData, change];
}
let ImageSelector$1 = class ImageSelector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1$, create_fragment$26, safe_not_equal, { wallpaper: 0 });
  }
};
function get_each_context$t(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2];
  return child_ctx;
}
function create_each_block$t(ctx) {
  let imageselector;
  let current;
  imageselector = new ImageSelector$1({
    props: { wallpaper: (
      /*wallpaper*/
      ctx[2]
    ) }
  });
  return {
    c() {
      create_component(imageselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(imageselector, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(imageselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(imageselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(imageselector, detaching);
    }
  };
}
function create_fragment$25(ctx) {
  let div3;
  let current;
  let t0;
  let div2;
  let t1;
  let div0;
  let t3;
  let div1;
  let current$1;
  let mounted;
  let dispose;
  current = new Current$1({});
  let each_value = ensure_array_like(Object.entries(Wallpapers));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$t(get_each_context$t(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div3 = element("div");
      create_component(current.$$.fragment);
      t0 = space();
      div2 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      div0 = element("div");
      div0.textContent = "upload";
      t3 = space();
      div1 = element("div");
      div1.textContent = "travel_explore";
      attr(div0, "class", "wallpaper nobg customwp material-icons-round");
      attr(div0, "title", "Upload wallpaper");
      attr(div1, "class", "wallpaper nobg customwp material-icons-round");
      attr(div1, "title", "Wallpaper from URL");
      attr(div2, "class", "wallpapers");
      attr(div3, "class", "desktop-page");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      mount_component(current, div3, null);
      append(div3, t0);
      append(div3, div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div2, null);
        }
      }
      append(div2, t1);
      append(div2, div0);
      append(div2, t3);
      append(div2, div1);
      current$1 = true;
      if (!mounted) {
        dispose = [
          listen(
            div0,
            "click",
            /*upload*/
            ctx[1]
          ),
          listen(
            div1,
            "click",
            /*custom*/
            ctx[0]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Object*/
      0) {
        each_value = ensure_array_like(Object.entries(Wallpapers));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$t(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$t(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div2, t1);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current$1)
        return;
      transition_in(current.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current$1 = true;
    },
    o(local) {
      transition_out(current.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current$1 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(current);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1_($$self) {
  function custom() {
    showOverlay("customWallpaper", "SettingsApp");
  }
  async function upload() {
    await createDirectory("./Wallpapers");
    const path = await directSingleUpload("./Wallpapers", "image/png, image/jpeg, image/gif, image/svg+xml");
    UserData$2.update((udata) => {
      udata.sh.desktop.wallpaper = `@local:${toBase64(path)}`;
      return udata;
    });
  }
  return [custom, upload];
}
let Desktop$1 = class Desktop extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1_, create_fragment$25, safe_not_equal, {});
  }
};
function create_fragment$24(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "current");
      set_style(div, "background-image", "url(" + /*url*/
      ctx[0] + ")");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*url*/
      1) {
        set_style(div, "background-image", "url(" + /*url*/
        ctx2[0] + ")");
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$1Z($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(1, $UserData = $$value));
  let url = "";
  UserData$2.subscribe(async () => {
    $$invalidate(0, url = (await getWallpaper($UserData.acc.loginBackground || "img15")).url);
  });
  return [url];
}
class Current2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1Z, create_fragment$24, safe_not_equal, {});
  }
}
function create_if_block$S(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "block";
      attr(span, "class", "material-icons-round none");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$23(ctx) {
  let div;
  let div_title_value;
  let mounted;
  let dispose;
  let if_block = (
    /*wallpaper*/
    ctx[0][0] == "img0" && create_if_block$S()
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "wallpaper");
      set_style(div, "background-image", "url(" + /*wallpaper*/
      ctx[0][1].url + ")");
      attr(div, "title", div_title_value = /*wallpaper*/
      ctx[0][0] == "img0" ? "(none)" : `${/*wallpaper*/
      ctx[0][1].name} from ${/*wallpaper*/
      ctx[0][1].author}`);
      toggle_class(
        div,
        "selected",
        /*$UserData*/
        ctx[1].acc.loginBackground == /*wallpaper*/
        ctx[0][0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*change*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*wallpaper*/
        ctx2[0][0] == "img0"
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$S();
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*wallpaper*/
      1) {
        set_style(div, "background-image", "url(" + /*wallpaper*/
        ctx2[0][1].url + ")");
      }
      if (dirty & /*wallpaper*/
      1 && div_title_value !== (div_title_value = /*wallpaper*/
      ctx2[0][0] == "img0" ? "(none)" : `${/*wallpaper*/
      ctx2[0][1].name} from ${/*wallpaper*/
      ctx2[0][1].author}`)) {
        attr(div, "title", div_title_value);
      }
      if (dirty & /*$UserData, wallpaper*/
      3) {
        toggle_class(
          div,
          "selected",
          /*$UserData*/
          ctx2[1].acc.loginBackground == /*wallpaper*/
          ctx2[0][0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$1Y($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(1, $UserData = $$value));
  let { wallpaper } = $$props;
  function change() {
    set_store_value(UserData$2, $UserData.acc.loginBackground = wallpaper[0], $UserData);
  }
  $$self.$$set = ($$props2) => {
    if ("wallpaper" in $$props2)
      $$invalidate(0, wallpaper = $$props2.wallpaper);
  };
  return [wallpaper, $UserData, change];
}
class ImageSelector2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1Y, create_fragment$23, safe_not_equal, { wallpaper: 0 });
  }
}
function get_each_context$s(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2];
  return child_ctx;
}
function create_each_block$s(ctx) {
  let imageselector;
  let current;
  imageselector = new ImageSelector2({
    props: { wallpaper: (
      /*wallpaper*/
      ctx[1]
    ) }
  });
  return {
    c() {
      create_component(imageselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(imageselector, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(imageselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(imageselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(imageselector, detaching);
    }
  };
}
function create_fragment$22(ctx) {
  let div2;
  let current;
  let t0;
  let div1;
  let t1;
  let div0;
  let current$1;
  let mounted;
  let dispose;
  current = new Current2({});
  let each_value = ensure_array_like(Object.entries(Wallpapers));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$s(get_each_context$s(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div2 = element("div");
      create_component(current.$$.fragment);
      t0 = space();
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      div0 = element("div");
      div0.textContent = "travel_explore";
      attr(div0, "class", "wallpaper nobg customwp material-icons-round");
      attr(div0, "title", "Wallpaper from URL");
      attr(div1, "class", "wallpapers");
      attr(div2, "class", "desktop-page");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(current, div2, null);
      append(div2, t0);
      append(div2, div1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      append(div1, t1);
      append(div1, div0);
      current$1 = true;
      if (!mounted) {
        dispose = listen(
          div0,
          "click",
          /*custom*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Object*/
      0) {
        each_value = ensure_array_like(Object.entries(Wallpapers));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$s(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$s(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, t1);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current$1)
        return;
      transition_in(current.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current$1 = true;
    },
    o(local) {
      transition_out(current.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current$1 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(current);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$1X($$self) {
  function custom() {
    showOverlay("customLoginWallpaper", "SettingsApp");
  }
  return [custom];
}
class LockScreen extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1X, create_fragment$22, safe_not_equal, {});
  }
}
const Asterisk_svelte_svelte_type_style_lang = "";
function create_fragment$21(ctx) {
  let div;
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      span = element("span");
      if (default_slot)
        default_slot.c();
      attr(span, "class", "svelte-4j4q5o");
      attr(div, "class", "asterisk svelte-4j4q5o");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$1W($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Asterisk extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1W, create_fragment$21, safe_not_equal, {});
  }
}
const TaskBarPosition_svelte_svelte_type_style_lang = "";
function get_each_context$r(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  return child_ctx;
}
function create_if_block$R(ctx) {
  let div;
  let each_value = ensure_array_like(Object.entries(
    /*options*/
    ctx[2]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$r(get_each_context$r(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "taskbarpos svelte-g58n0c");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, options, disabled, $U*/
      7) {
        each_value = ensure_array_like(Object.entries(
          /*options*/
          ctx2[2]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$r(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$r(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$r(ctx) {
  let button;
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[3](
        /*opt*/
        ctx[4]
      )
    );
  }
  return {
    c() {
      button = element("button");
      t2 = text("vertical_align_bottom\n      ");
      attr(button, "class", "pos " + /*opt*/
      ctx[4][1] + " material-icons-round svelte-g58n0c");
      button.disabled = /*disabled*/
      ctx[0];
      toggle_class(
        button,
        "selected",
        /*$U*/
        ctx[1].sh.taskbar.pos == /*opt*/
        ctx[4][0]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*disabled*/
      1) {
        button.disabled = /*disabled*/
        ctx[0];
      }
      if (dirty & /*$U, Object, options*/
      6) {
        toggle_class(
          button,
          "selected",
          /*$U*/
          ctx[1].sh.taskbar.pos == /*opt*/
          ctx[4][0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$20(ctx) {
  let if_block_anchor;
  let if_block = (
    /*$U*/
    ctx[1] && create_if_block$R(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*$U*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$R(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1V($$self, $$props, $$invalidate) {
  let $U;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(1, $U = $$value));
  let { disabled = false } = $$props;
  const options = {
    vertical: "left",
    "": "bottom",
    "vertical-right": "right",
    top: "top"
  };
  const click_handler = (opt) => set_store_value(UserData$2, $U.sh.taskbar.pos = opt[0], $U);
  $$self.$$set = ($$props2) => {
    if ("disabled" in $$props2)
      $$invalidate(0, disabled = $$props2.disabled);
  };
  return [disabled, $U, options, click_handler];
}
class TaskBarPosition extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1V, create_fragment$20, safe_not_equal, { disabled: 0 });
  }
}
function create_default_slot_9(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "id", "a");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserData*/
      ctx[0].sh.taskbar.isLauncher;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1) {
        input.checked = /*$UserData*/
        ctx2[0].sh.taskbar.isLauncher;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_8(ctx) {
  let input;
  let input_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "id", "a");
      attr(input, "class", "switch");
      input.disabled = input_disabled_value = /*$UserData*/
      ctx[0].sh.taskbar.isLauncher;
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserData*/
      ctx[0].sh.taskbar.centered;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_1*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1 && input_disabled_value !== (input_disabled_value = /*$UserData*/
      ctx2[0].sh.taskbar.isLauncher)) {
        input.disabled = input_disabled_value;
      }
      if (dirty & /*$UserData*/
      1) {
        input.checked = /*$UserData*/
        ctx2[0].sh.taskbar.centered;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_7(ctx) {
  let input;
  let input_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "id", "a");
      attr(input, "class", "switch");
      input.disabled = input_disabled_value = /*$UserData*/
      ctx[0].sh.taskbar.pos.includes("vertical") || /*$UserData*/
      ctx[0].sh.taskbar.isLauncher;
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserData*/
      ctx[0].sh.taskbar.labels;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_2*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1 && input_disabled_value !== (input_disabled_value = /*$UserData*/
      ctx2[0].sh.taskbar.pos.includes("vertical") || /*$UserData*/
      ctx2[0].sh.taskbar.isLauncher)) {
        input.disabled = input_disabled_value;
      }
      if (dirty & /*$UserData*/
      1) {
        input.checked = /*$UserData*/
        ctx2[0].sh.taskbar.labels;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_6(ctx) {
  let taskbarposition;
  let current;
  taskbarposition = new TaskBarPosition({
    props: {
      disabled: (
        /*$UserData*/
        ctx[0].sh.taskbar.isLauncher
      )
    }
  });
  return {
    c() {
      create_component(taskbarposition.$$.fragment);
    },
    m(target, anchor) {
      mount_component(taskbarposition, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const taskbarposition_changes = {};
      if (dirty & /*$UserData*/
      1)
        taskbarposition_changes.disabled = /*$UserData*/
        ctx2[0].sh.taskbar.isLauncher;
      taskbarposition.$set(taskbarposition_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(taskbarposition.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taskbarposition.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(taskbarposition, detaching);
    }
  };
}
function create_default_slot_5$1(ctx) {
  let input;
  let input_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "id", "a");
      attr(input, "class", "switch");
      input.disabled = input_disabled_value = /*$UserData*/
      ctx[0].sh.taskbar.isLauncher;
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserData*/
      ctx[0].sh.taskbar.accentedStart;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_3*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1 && input_disabled_value !== (input_disabled_value = /*$UserData*/
      ctx2[0].sh.taskbar.isLauncher)) {
        input.disabled = input_disabled_value;
      }
      if (dirty & /*$UserData*/
      1) {
        input.checked = /*$UserData*/
        ctx2[0].sh.taskbar.accentedStart;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_4$2(ctx) {
  let input;
  let input_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "id", "a");
      attr(input, "class", "switch");
      input.disabled = input_disabled_value = /*$UserData*/
      ctx[0].sh.taskbar.isLauncher;
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserData*/
      ctx[0].sh.start.small;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_4*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1 && input_disabled_value !== (input_disabled_value = /*$UserData*/
      ctx2[0].sh.taskbar.isLauncher)) {
        input.disabled = input_disabled_value;
      }
      if (dirty & /*$UserData*/
      1) {
        input.checked = /*$UserData*/
        ctx2[0].sh.start.small;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_3$2(ctx) {
  let t2;
  return {
    c() {
      t2 = text("These settings require Launcher Mode to be turned off.");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_2$2(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "id", "a");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserData*/
      ctx[0].sh.taskbar.docked;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_5*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1) {
        input.checked = /*$UserData*/
        ctx2[0].sh.taskbar.docked;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$3(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "id", "a");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserData*/
      ctx[0].sh.taskbar.colored;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_6*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1) {
        input.checked = /*$UserData*/
        ctx2[0].sh.taskbar.colored;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$6(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserData*/
      ctx[0].sh.compactContext;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_7*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1) {
        input.checked = /*$UserData*/
        ctx2[0].sh.compactContext;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1$(ctx) {
  let h1;
  let t1;
  let optionsection0;
  let t2;
  let optionsection1;
  let t3;
  let optionsection2;
  let t4;
  let optionsection3;
  let t5;
  let optionsection4;
  let t6;
  let hr;
  let t7;
  let optionsection5;
  let t8;
  let asterisk;
  let t9;
  let optionsection6;
  let t10;
  let optionsection7;
  let t11;
  let optionsection8;
  let current;
  optionsection0 = new OptionSection({
    props: {
      title: "Launcher Mode",
      context: "Use a GNOME-style launcher instead of the taskbar",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  optionsection1 = new OptionSection({
    props: {
      title: "Center taskbar buttons",
      context: "Centers the taskbar app buttons",
      asterisk: true,
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  optionsection2 = new OptionSection({
    props: {
      title: "Taskbar app labels",
      context: "Display app names on the taskbar",
      asterisk: true,
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  optionsection3 = new OptionSection({
    props: {
      title: "Taskbar position",
      context: "Where do you want the taskbar?",
      asterisk: true,
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  optionsection4 = new OptionSection({
    props: {
      title: "Accented Start Button",
      context: "Match the Start logo to the accent color",
      asterisk: true,
      $$slots: { default: [create_default_slot_5$1] },
      $$scope: { ctx }
    }
  });
  optionsection5 = new OptionSection({
    props: {
      title: "Small start menu",
      context: "Make the start menu smaller",
      asterisk: true,
      $$slots: { default: [create_default_slot_4$2] },
      $$scope: { ctx }
    }
  });
  asterisk = new Asterisk({
    props: {
      $$slots: { default: [create_default_slot_3$2] },
      $$scope: { ctx }
    }
  });
  optionsection6 = new OptionSection({
    props: {
      title: "Dock shell",
      context: "Dock the taskbar and action center",
      $$slots: { default: [create_default_slot_2$2] },
      $$scope: { ctx }
    }
  });
  optionsection7 = new OptionSection({
    props: {
      title: "Colored shell",
      context: "Apply the accent color to the shell",
      $$slots: { default: [create_default_slot_1$3] },
      $$scope: { ctx }
    }
  });
  optionsection8 = new OptionSection({
    props: {
      title: "Compact context menu",
      context: "Make the context menu more compact",
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Shell";
      t1 = space();
      create_component(optionsection0.$$.fragment);
      t2 = space();
      create_component(optionsection1.$$.fragment);
      t3 = space();
      create_component(optionsection2.$$.fragment);
      t4 = space();
      create_component(optionsection3.$$.fragment);
      t5 = space();
      create_component(optionsection4.$$.fragment);
      t6 = space();
      hr = element("hr");
      t7 = space();
      create_component(optionsection5.$$.fragment);
      t8 = space();
      create_component(asterisk.$$.fragment);
      t9 = space();
      create_component(optionsection6.$$.fragment);
      t10 = space();
      create_component(optionsection7.$$.fragment);
      t11 = space();
      create_component(optionsection8.$$.fragment);
      attr(h1, "class", "page-title");
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      insert(target, t1, anchor);
      mount_component(optionsection0, target, anchor);
      insert(target, t2, anchor);
      mount_component(optionsection1, target, anchor);
      insert(target, t3, anchor);
      mount_component(optionsection2, target, anchor);
      insert(target, t4, anchor);
      mount_component(optionsection3, target, anchor);
      insert(target, t5, anchor);
      mount_component(optionsection4, target, anchor);
      insert(target, t6, anchor);
      insert(target, hr, anchor);
      insert(target, t7, anchor);
      mount_component(optionsection5, target, anchor);
      insert(target, t8, anchor);
      mount_component(asterisk, target, anchor);
      insert(target, t9, anchor);
      mount_component(optionsection6, target, anchor);
      insert(target, t10, anchor);
      mount_component(optionsection7, target, anchor);
      insert(target, t11, anchor);
      mount_component(optionsection8, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const optionsection0_changes = {};
      if (dirty & /*$$scope, $UserData*/
      513) {
        optionsection0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection0.$set(optionsection0_changes);
      const optionsection1_changes = {};
      if (dirty & /*$$scope, $UserData*/
      513) {
        optionsection1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection1.$set(optionsection1_changes);
      const optionsection2_changes = {};
      if (dirty & /*$$scope, $UserData*/
      513) {
        optionsection2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection2.$set(optionsection2_changes);
      const optionsection3_changes = {};
      if (dirty & /*$$scope, $UserData*/
      513) {
        optionsection3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection3.$set(optionsection3_changes);
      const optionsection4_changes = {};
      if (dirty & /*$$scope, $UserData*/
      513) {
        optionsection4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection4.$set(optionsection4_changes);
      const optionsection5_changes = {};
      if (dirty & /*$$scope, $UserData*/
      513) {
        optionsection5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection5.$set(optionsection5_changes);
      const asterisk_changes = {};
      if (dirty & /*$$scope*/
      512) {
        asterisk_changes.$$scope = { dirty, ctx: ctx2 };
      }
      asterisk.$set(asterisk_changes);
      const optionsection6_changes = {};
      if (dirty & /*$$scope, $UserData*/
      513) {
        optionsection6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection6.$set(optionsection6_changes);
      const optionsection7_changes = {};
      if (dirty & /*$$scope, $UserData*/
      513) {
        optionsection7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection7.$set(optionsection7_changes);
      const optionsection8_changes = {};
      if (dirty & /*$$scope, $UserData*/
      513) {
        optionsection8_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection8.$set(optionsection8_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(optionsection0.$$.fragment, local);
      transition_in(optionsection1.$$.fragment, local);
      transition_in(optionsection2.$$.fragment, local);
      transition_in(optionsection3.$$.fragment, local);
      transition_in(optionsection4.$$.fragment, local);
      transition_in(optionsection5.$$.fragment, local);
      transition_in(asterisk.$$.fragment, local);
      transition_in(optionsection6.$$.fragment, local);
      transition_in(optionsection7.$$.fragment, local);
      transition_in(optionsection8.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(optionsection0.$$.fragment, local);
      transition_out(optionsection1.$$.fragment, local);
      transition_out(optionsection2.$$.fragment, local);
      transition_out(optionsection3.$$.fragment, local);
      transition_out(optionsection4.$$.fragment, local);
      transition_out(optionsection5.$$.fragment, local);
      transition_out(asterisk.$$.fragment, local);
      transition_out(optionsection6.$$.fragment, local);
      transition_out(optionsection7.$$.fragment, local);
      transition_out(optionsection8.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h1);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(hr);
        detach(t7);
        detach(t8);
        detach(t9);
        detach(t10);
        detach(t11);
      }
      destroy_component(optionsection0, detaching);
      destroy_component(optionsection1, detaching);
      destroy_component(optionsection2, detaching);
      destroy_component(optionsection3, detaching);
      destroy_component(optionsection4, detaching);
      destroy_component(optionsection5, detaching);
      destroy_component(asterisk, detaching);
      destroy_component(optionsection6, detaching);
      destroy_component(optionsection7, detaching);
      destroy_component(optionsection8, detaching);
    }
  };
}
function instance$1U($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(0, $UserData = $$value));
  function input_change_handler() {
    $UserData.sh.taskbar.isLauncher = this.checked;
    UserData$2.set($UserData);
  }
  function input_change_handler_1() {
    $UserData.sh.taskbar.centered = this.checked;
    UserData$2.set($UserData);
  }
  function input_change_handler_2() {
    $UserData.sh.taskbar.labels = this.checked;
    UserData$2.set($UserData);
  }
  function input_change_handler_3() {
    $UserData.sh.taskbar.accentedStart = this.checked;
    UserData$2.set($UserData);
  }
  function input_change_handler_4() {
    $UserData.sh.start.small = this.checked;
    UserData$2.set($UserData);
  }
  function input_change_handler_5() {
    $UserData.sh.taskbar.docked = this.checked;
    UserData$2.set($UserData);
  }
  function input_change_handler_6() {
    $UserData.sh.taskbar.colored = this.checked;
    UserData$2.set($UserData);
  }
  function input_change_handler_7() {
    $UserData.sh.compactContext = this.checked;
    UserData$2.set($UserData);
  }
  return [
    $UserData,
    input_change_handler,
    input_change_handler_1,
    input_change_handler_2,
    input_change_handler_3,
    input_change_handler_4,
    input_change_handler_5,
    input_change_handler_6,
    input_change_handler_7
  ];
}
let Shell$1 = class Shell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1U, create_fragment$1$, safe_not_equal, {});
  }
};
const DefaultThemes = {
  arcDark: {
    author: "ArcOS Team",
    version: "1.0.0",
    name: "ArcOS Dark",
    anim: true,
    noGlass: false,
    sharp: false,
    theme: "dark",
    wallpaper: "img04",
    taskbarCentered: false,
    taskbarLabels: false,
    taskbarPosition: "",
    docked: false,
    accent: "70D6FF",
    smallStart: true,
    titleButtons: "default",
    titlebarLarge: false,
    titlebarLeft: false,
    taskbarColored: false,
    titlebarCentered: false,
    isLauncher: false
  },
  arcLight: {
    author: "ArcOS Team",
    version: "1.0.0",
    name: "ArcOS Light",
    anim: true,
    noGlass: false,
    sharp: false,
    theme: "light",
    wallpaper: "img05",
    taskbarCentered: false,
    taskbarLabels: false,
    taskbarPosition: "",
    docked: false,
    accent: "70D6FF",
    smallStart: true,
    titleButtons: "default",
    titlebarLarge: false,
    titlebarLeft: false,
    taskbarColored: false,
    titlebarCentered: false,
    isLauncher: false
  },
  theHague: {
    author: "Aron Wagener",
    version: "1.0.0",
    name: "The Hague",
    anim: true,
    noGlass: false,
    sharp: false,
    theme: "dark",
    wallpaper: "img13",
    taskbarCentered: false,
    taskbarLabels: true,
    taskbarPosition: "",
    docked: true,
    accent: "0A0",
    smallStart: false,
    titleButtons: "default",
    titlebarLarge: true,
    titlebarLeft: false,
    taskbarColored: false,
    titlebarCentered: false,
    isLauncher: false
  },
  wacky: {
    author: "Izaak Kuipers",
    version: "1.0.0",
    name: "Wacky",
    anim: true,
    noGlass: false,
    sharp: false,
    theme: "dark",
    wallpaper: "img03",
    taskbarCentered: true,
    taskbarLabels: true,
    taskbarPosition: "vertical",
    docked: false,
    accent: "fa0",
    smallStart: true,
    titleButtons: "og",
    titlebarLarge: true,
    titlebarLeft: true,
    taskbarColored: false,
    titlebarCentered: false,
    isLauncher: false
  },
  performance: {
    author: "ArcOS Team",
    version: "1.0.0",
    name: "Optimal Performance",
    anim: false,
    noGlass: true,
    sharp: true,
    theme: "dark",
    wallpaper: "img0",
    taskbarCentered: false,
    taskbarLabels: false,
    taskbarPosition: "",
    docked: true,
    accent: "FFF",
    smallStart: true,
    titleButtons: "default",
    titlebarLarge: false,
    titlebarLeft: false,
    taskbarColored: false,
    titlebarCentered: false,
    isLauncher: false
  },
  wandelbos: {
    version: "1.0.0",
    name: "Wandelbos",
    author: "Izaak",
    anim: true,
    noGlass: false,
    sharp: false,
    theme: "dark",
    wallpaper: "img08",
    accent: "91F5AD",
    docked: true,
    taskbarCentered: false,
    taskbarLabels: false,
    taskbarPosition: "",
    smallStart: true,
    titleButtons: "default",
    titlebarLarge: false,
    titlebarLeft: false,
    taskbarColored: true,
    titlebarCentered: false,
    isLauncher: false
  },
  scheveningen: {
    version: "1.0.0",
    name: "Scheveningen",
    author: "Izaak & keesvv",
    anim: true,
    noGlass: false,
    sharp: false,
    theme: "dark",
    wallpaper: "img14",
    accent: "264653",
    docked: true,
    taskbarCentered: false,
    taskbarLabels: false,
    taskbarPosition: "",
    smallStart: true,
    titleButtons: "default",
    titlebarLarge: false,
    titlebarLeft: false,
    taskbarColored: true,
    titlebarCentered: false,
    isLauncher: false
  }
};
function create_fragment$1_(ctx) {
  let button;
  let div1;
  let div0;
  let div1_class_value;
  let button_title_value;
  let button_data_id_value;
  let button_data_contextmenu_value;
  let button_data_name_value;
  let button_data_json_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "accent");
      set_style(
        div0,
        "color",
        /*theme*/
        ctx[0][1].accent
      );
      attr(div1, "class", div1_class_value = "mockup-window theme-" + /*theme*/
      ctx[0][1].theme);
      attr(button, "class", "themerenderer");
      attr(button, "title", button_title_value = /*theme*/
      ctx[0][1].name + " by " + /*theme*/
      ctx[0][1].author);
      set_style(button, "background-image", "url(" + /*url*/
      ctx[2] + ")");
      set_style(button, "--accent", "#" + /*theme*/
      ctx[0][1].accent);
      attr(button, "data-id", button_data_id_value = /*theme*/
      ctx[0][0]);
      attr(button, "data-contextmenu", button_data_contextmenu_value = "themerenderer-" + /*user*/
      (ctx[1] ? "user" : "system"));
      attr(button, "data-name", button_data_name_value = /*theme*/
      ctx[0][1].name);
      attr(button, "data-json", button_data_json_value = JSON.stringify(
        /*theme*/
        ctx[0][1]
      ));
      toggle_class(
        button,
        "sharp",
        /*theme*/
        ctx[0][1].sharp
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div1);
      append(div1, div0);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*apply*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1) {
        set_style(
          div0,
          "color",
          /*theme*/
          ctx2[0][1].accent
        );
      }
      if (dirty & /*theme*/
      1 && div1_class_value !== (div1_class_value = "mockup-window theme-" + /*theme*/
      ctx2[0][1].theme)) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & /*theme*/
      1 && button_title_value !== (button_title_value = /*theme*/
      ctx2[0][1].name + " by " + /*theme*/
      ctx2[0][1].author)) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*url*/
      4) {
        set_style(button, "background-image", "url(" + /*url*/
        ctx2[2] + ")");
      }
      if (dirty & /*theme*/
      1) {
        set_style(button, "--accent", "#" + /*theme*/
        ctx2[0][1].accent);
      }
      if (dirty & /*theme*/
      1 && button_data_id_value !== (button_data_id_value = /*theme*/
      ctx2[0][0])) {
        attr(button, "data-id", button_data_id_value);
      }
      if (dirty & /*user*/
      2 && button_data_contextmenu_value !== (button_data_contextmenu_value = "themerenderer-" + /*user*/
      (ctx2[1] ? "user" : "system"))) {
        attr(button, "data-contextmenu", button_data_contextmenu_value);
      }
      if (dirty & /*theme*/
      1 && button_data_name_value !== (button_data_name_value = /*theme*/
      ctx2[0][1].name)) {
        attr(button, "data-name", button_data_name_value);
      }
      if (dirty & /*theme*/
      1 && button_data_json_value !== (button_data_json_value = JSON.stringify(
        /*theme*/
        ctx2[0][1]
      ))) {
        attr(button, "data-json", button_data_json_value);
      }
      if (dirty & /*theme*/
      1) {
        toggle_class(
          button,
          "sharp",
          /*theme*/
          ctx2[0][1].sharp
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$1T($$self, $$props, $$invalidate) {
  let { theme } = $$props;
  let { user = false } = $$props;
  let url = "";
  function apply() {
    loadTheme(theme[1]);
  }
  onMount(async () => {
    $$invalidate(2, url = (await getWallpaper(theme[1].wallpaper)).url);
  });
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("user" in $$props2)
      $$invalidate(1, user = $$props2.user);
  };
  return [theme, user, url, apply];
}
class ThemeRenderer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1T, create_fragment$1_, safe_not_equal, { theme: 0, user: 1 });
  }
}
function get_each_context$q(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  return child_ctx;
}
function get_each_context_1$4(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  return child_ctx;
}
function create_each_block_1$4(ctx) {
  let themerenderer;
  let current;
  themerenderer = new ThemeRenderer({ props: { theme: (
    /*theme*/
    ctx[4]
  ) } });
  return {
    c() {
      create_component(themerenderer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(themerenderer, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(themerenderer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(themerenderer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(themerenderer, detaching);
    }
  };
}
function create_if_block$Q(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(Object.entries(
    /*$UserData*/
    ctx[1].sh.userThemes
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$q(get_each_context$q(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, $UserData*/
      2) {
        each_value = ensure_array_like(Object.entries(
          /*$UserData*/
          ctx2[1].sh.userThemes
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$q(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$q(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$q(ctx) {
  let themerenderer;
  let current;
  themerenderer = new ThemeRenderer({
    props: { theme: (
      /*theme*/
      ctx[4]
    ), user: true }
  });
  return {
    c() {
      create_component(themerenderer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(themerenderer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const themerenderer_changes = {};
      if (dirty & /*$UserData*/
      2)
        themerenderer_changes.theme = /*theme*/
        ctx2[4];
      themerenderer.$set(themerenderer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(themerenderer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(themerenderer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(themerenderer, detaching);
    }
  };
}
function create_fragment$1Z(ctx) {
  let div;
  let t0;
  let t1;
  let button;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like(Object.entries(DefaultThemes));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = !/*reload*/
  ctx[0] && /*$UserData*/
  ctx[1].sh.userThemes && create_if_block$Q(ctx);
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      button = element("button");
      button.textContent = "save";
      attr(button, "class", "themerenderer save material-icons-round");
      attr(button, "title", "Save current theme");
      attr(div, "class", "themes");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      append(div, t0);
      if (if_block)
        if_block.m(div, null);
      append(div, t1);
      append(div, button);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Object*/
      0) {
        each_value_1 = ensure_array_like(Object.entries(DefaultThemes));
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$4(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$4(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, t0);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!/*reload*/
      ctx2[0] && /*$UserData*/
      ctx2[1].sh.userThemes) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*reload, $UserData*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$Q(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$1S($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(1, $UserData = $$value));
  let oldlength = 0;
  let reload = false;
  UserData$2.subscribe((v2) => {
    const freshEntries = Object.entries(v2.sh.userThemes);
    if (oldlength == freshEntries.length)
      return;
    oldlength = freshEntries.length;
    $$invalidate(0, reload = true);
    setTimeout(() => {
      $$invalidate(0, reload = false);
    });
  });
  const click_handler = () => showOverlay("saveTheme", "SettingsApp");
  return [reload, $UserData, click_handler];
}
class Themes extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1S, create_fragment$1Z, safe_not_equal, {});
  }
}
function create_fragment$1Y(ctx) {
  let div1;
  let div0;
  let current;
  let t2;
  let themes;
  let current$1;
  current = new Current$1({});
  themes = new Themes({});
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(current.$$.fragment);
      t2 = space();
      create_component(themes.$$.fragment);
      attr(div0, "class", "desktop-page");
      attr(div1, "class", "settingspage-themes");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(current, div0, null);
      append(div1, t2);
      mount_component(themes, div1, null);
      current$1 = true;
    },
    p: noop$1,
    i(local) {
      if (current$1)
        return;
      transition_in(current.$$.fragment, local);
      transition_in(themes.$$.fragment, local);
      current$1 = true;
    },
    o(local) {
      transition_out(current.$$.fragment, local);
      transition_out(themes.$$.fragment, local);
      current$1 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(current);
      destroy_component(themes);
    }
  };
}
class Themes_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1Y, safe_not_equal, {});
  }
}
const accentcolor = "";
const accentColors = [
  "D62828",
  "F3722C",
  "F49E4C",
  "F8961E",
  "F9C74F",
  "E2C044",
  "E9FF70",
  "C2E812",
  "90BE6D",
  "F1FAEE",
  "61E786",
  "91F5AD",
  "43AA8B",
  "A8DADC",
  "70D6FF",
  "264653",
  "457B9D",
  "577590",
  "1D3557",
  "AFCBFF",
  "03045E",
  "A09BE7",
  "7209B7",
  "F72585",
  "F61067",
  "FF70A6",
  "E63946",
  "F94144"
];
function create_fragment$1X(ctx) {
  let button;
  let button_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      attr(button, "class", "color ol reset");
      set_style(button, "background", "#" + /*color*/
      ctx[0]);
      attr(button, "data-contextmenu", "appearance-accentselector");
      attr(
        button,
        "data-hex",
        /*color*/
        ctx[0]
      );
      attr(button, "title", button_title_value = "#" + /*color*/
      ctx[0].toUpperCase());
      toggle_class(
        button,
        "selected",
        /*color*/
        ctx[0] == /*$UserData*/
        ctx[1].sh.desktop.accent
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*change*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*color*/
      1) {
        set_style(button, "background", "#" + /*color*/
        ctx2[0]);
      }
      if (dirty & /*color*/
      1) {
        attr(
          button,
          "data-hex",
          /*color*/
          ctx2[0]
        );
      }
      if (dirty & /*color*/
      1 && button_title_value !== (button_title_value = "#" + /*color*/
      ctx2[0].toUpperCase())) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*color, $UserData*/
      3) {
        toggle_class(
          button,
          "selected",
          /*color*/
          ctx2[0] == /*$UserData*/
          ctx2[1].sh.desktop.accent
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$1R($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(1, $UserData = $$value));
  let { color } = $$props;
  function change() {
    set_store_value(UserData$2, $UserData.sh.desktop.accent = color, $UserData);
  }
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
  };
  return [color, $UserData, change];
}
class Color extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1R, create_fragment$1X, safe_not_equal, { color: 0 });
  }
}
function get_each_context$p(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2];
  return child_ctx;
}
function create_each_block$p(ctx) {
  let color_1;
  let current;
  color_1 = new Color({ props: { color: (
    /*color*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(color_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(color_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(color_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(color_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(color_1, detaching);
    }
  };
}
function create_fragment$1W(ctx) {
  let optionsection;
  let t0;
  let div;
  let t1;
  let button;
  let current;
  let mounted;
  let dispose;
  optionsection = new OptionSection({
    props: {
      title: "Accent Color",
      context: "Choose an accent color for ArcOS"
    }
  });
  let each_value = ensure_array_like(accentColors);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$p(get_each_context$p(ctx, each_value, i2));
  }
  return {
    c() {
      create_component(optionsection.$$.fragment);
      t0 = space();
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      button = element("button");
      button.textContent = "edit";
      attr(button, "class", "color ol reset material-icons-round");
      attr(div, "class", "accentcolor-wrapper");
    },
    m(target, anchor) {
      mount_component(optionsection, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      append(div, t1);
      append(div, button);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*custom*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(optionsection.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(optionsection.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
      }
      destroy_component(optionsection, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$1Q($$self) {
  function custom() {
    showOverlay("customAccentColor", "SettingsApp");
  }
  return [custom];
}
class AccentColor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1Q, create_fragment$1W, safe_not_equal, {});
  }
}
function create_default_slot_5(ctx) {
  let select;
  let option0;
  let option1;
  let option2;
  let option3;
  let option4;
  let option5;
  let mounted;
  let dispose;
  return {
    c() {
      select = element("select");
      option0 = element("option");
      option0.textContent = "Darkmode";
      option1 = element("option");
      option1.textContent = "Lightmode";
      option2 = element("option");
      option2.textContent = "Amoled";
      option3 = element("option");
      option3.textContent = "Amber Monochrome";
      option4 = element("option");
      option4.textContent = "Science Fiction";
      option5 = element("option");
      option5.textContent = "High contrast";
      option0.__value = "dark";
      set_input_value(option0, option0.__value);
      option1.__value = "light";
      set_input_value(option1, option1.__value);
      option2.__value = "amoled";
      set_input_value(option2, option2.__value);
      option3.__value = "amber";
      set_input_value(option3, option3.__value);
      option4.__value = "scifi";
      set_input_value(option4, option4.__value);
      option5.__value = "hc";
      set_input_value(option5, option5.__value);
      attr(select, "name", "aa");
      attr(select, "id", "bb");
      if (
        /*$UserData*/
        ctx[0].sh.desktop.theme === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[1].call(select)
        ));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      append(select, option0);
      append(select, option1);
      append(select, option2);
      append(select, option3);
      append(select, option4);
      append(select, option5);
      select_option(
        select,
        /*$UserData*/
        ctx[0].sh.desktop.theme,
        true
      );
      if (!mounted) {
        dispose = listen(
          select,
          "change",
          /*select_change_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1) {
        select_option(
          select,
          /*$UserData*/
          ctx2[0].sh.desktop.theme
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_4$1(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserData*/
      ctx[0].sh.anim;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1) {
        input.checked = /*$UserData*/
        ctx2[0].sh.anim;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_3$1(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserData*/
      ctx[0].sh.noGlass;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_1*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1) {
        input.checked = /*$UserData*/
        ctx2[0].sh.noGlass;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$1(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserData*/
      ctx[0].sh.desktop.sharp;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_2*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1) {
        input.checked = /*$UserData*/
        ctx2[0].sh.desktop.sharp;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$2(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserData*/
      ctx[0].sh.desktop.noCustomCursor;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_3*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1) {
        input.checked = /*$UserData*/
        ctx2[0].sh.desktop.noCustomCursor;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$5(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Custom cursors might not always scale with the underlying Operating System.");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$1V(ctx) {
  let h1;
  let t1;
  let optionsection0;
  let t2;
  let hr0;
  let t3;
  let optionsection1;
  let t4;
  let optionsection2;
  let t5;
  let optionsection3;
  let t6;
  let optionsection4;
  let t7;
  let asterisk;
  let t8;
  let hr1;
  let t9;
  let accentcolor2;
  let current;
  optionsection0 = new OptionSection({
    props: {
      title: "Style",
      context: "Change the style of the UI",
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  optionsection1 = new OptionSection({
    props: {
      title: "Animations",
      context: "Display animations in ArcOS",
      $$slots: { default: [create_default_slot_4$1] },
      $$scope: { ctx }
    }
  });
  optionsection2 = new OptionSection({
    props: {
      title: "No glass",
      context: "Disable glass effects in ArcOS",
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx }
    }
  });
  optionsection3 = new OptionSection({
    props: {
      title: "Sharp corners",
      context: "Disable rounding in all of ArcOS",
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  optionsection4 = new OptionSection({
    props: {
      title: "No Custom Cursors",
      context: "Disable the ArcOS custom cursors",
      asterisk: true,
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  asterisk = new Asterisk({
    props: {
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx }
    }
  });
  accentcolor2 = new AccentColor({});
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Appearance";
      t1 = space();
      create_component(optionsection0.$$.fragment);
      t2 = space();
      hr0 = element("hr");
      t3 = space();
      create_component(optionsection1.$$.fragment);
      t4 = space();
      create_component(optionsection2.$$.fragment);
      t5 = space();
      create_component(optionsection3.$$.fragment);
      t6 = space();
      create_component(optionsection4.$$.fragment);
      t7 = space();
      create_component(asterisk.$$.fragment);
      t8 = space();
      hr1 = element("hr");
      t9 = space();
      create_component(accentcolor2.$$.fragment);
      attr(h1, "class", "page-title");
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      insert(target, t1, anchor);
      mount_component(optionsection0, target, anchor);
      insert(target, t2, anchor);
      insert(target, hr0, anchor);
      insert(target, t3, anchor);
      mount_component(optionsection1, target, anchor);
      insert(target, t4, anchor);
      mount_component(optionsection2, target, anchor);
      insert(target, t5, anchor);
      mount_component(optionsection3, target, anchor);
      insert(target, t6, anchor);
      mount_component(optionsection4, target, anchor);
      insert(target, t7, anchor);
      mount_component(asterisk, target, anchor);
      insert(target, t8, anchor);
      insert(target, hr1, anchor);
      insert(target, t9, anchor);
      mount_component(accentcolor2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const optionsection0_changes = {};
      if (dirty & /*$$scope, $UserData*/
      65) {
        optionsection0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection0.$set(optionsection0_changes);
      const optionsection1_changes = {};
      if (dirty & /*$$scope, $UserData*/
      65) {
        optionsection1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection1.$set(optionsection1_changes);
      const optionsection2_changes = {};
      if (dirty & /*$$scope, $UserData*/
      65) {
        optionsection2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection2.$set(optionsection2_changes);
      const optionsection3_changes = {};
      if (dirty & /*$$scope, $UserData*/
      65) {
        optionsection3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection3.$set(optionsection3_changes);
      const optionsection4_changes = {};
      if (dirty & /*$$scope, $UserData*/
      65) {
        optionsection4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection4.$set(optionsection4_changes);
      const asterisk_changes = {};
      if (dirty & /*$$scope*/
      64) {
        asterisk_changes.$$scope = { dirty, ctx: ctx2 };
      }
      asterisk.$set(asterisk_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(optionsection0.$$.fragment, local);
      transition_in(optionsection1.$$.fragment, local);
      transition_in(optionsection2.$$.fragment, local);
      transition_in(optionsection3.$$.fragment, local);
      transition_in(optionsection4.$$.fragment, local);
      transition_in(asterisk.$$.fragment, local);
      transition_in(accentcolor2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(optionsection0.$$.fragment, local);
      transition_out(optionsection1.$$.fragment, local);
      transition_out(optionsection2.$$.fragment, local);
      transition_out(optionsection3.$$.fragment, local);
      transition_out(optionsection4.$$.fragment, local);
      transition_out(asterisk.$$.fragment, local);
      transition_out(accentcolor2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h1);
        detach(t1);
        detach(t2);
        detach(hr0);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(t8);
        detach(hr1);
        detach(t9);
      }
      destroy_component(optionsection0, detaching);
      destroy_component(optionsection1, detaching);
      destroy_component(optionsection2, detaching);
      destroy_component(optionsection3, detaching);
      destroy_component(optionsection4, detaching);
      destroy_component(asterisk, detaching);
      destroy_component(accentcolor2, detaching);
    }
  };
}
function instance$1P($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(0, $UserData = $$value));
  function select_change_handler() {
    $UserData.sh.desktop.theme = select_value(this);
    UserData$2.set($UserData);
  }
  function input_change_handler() {
    $UserData.sh.anim = this.checked;
    UserData$2.set($UserData);
  }
  function input_change_handler_1() {
    $UserData.sh.noGlass = this.checked;
    UserData$2.set($UserData);
  }
  function input_change_handler_2() {
    $UserData.sh.desktop.sharp = this.checked;
    UserData$2.set($UserData);
  }
  function input_change_handler_3() {
    $UserData.sh.desktop.noCustomCursor = this.checked;
    UserData$2.set($UserData);
  }
  return [
    $UserData,
    select_change_handler,
    input_change_handler,
    input_change_handler_1,
    input_change_handler_2,
    input_change_handler_3
  ];
}
class Visuals extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1P, create_fragment$1V, safe_not_equal, {});
  }
}
function create_default_slot_4(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserData*/
      ctx[0].sh.window.bigtb;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1) {
        input.checked = /*$UserData*/
        ctx2[0].sh.window.bigtb;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_3(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserData*/
      ctx[0].sh.window.lefttb;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_1*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1) {
        input.checked = /*$UserData*/
        ctx2[0].sh.window.lefttb;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "switch");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*$UserData*/
      ctx[0].sh.window.centertb;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_2*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      1) {
        input.checked = /*$UserData*/
        ctx2[0].sh.window.centertb;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$1(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Change...";
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$4(ctx) {
  let t2;
  return {
    c() {
      t2 = text("These settings won't affect the Settings app itself.");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$1U(ctx) {
  let h1;
  let t1;
  let optionsection0;
  let t2;
  let optionsection1;
  let t3;
  let optionsection2;
  let t4;
  let optionsection3;
  let t5;
  let asterisk;
  let current;
  optionsection0 = new OptionSection({
    props: {
      title: "Large titlebar",
      context: "Make the titlebars larger",
      asterisk: true,
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  optionsection1 = new OptionSection({
    props: {
      title: "Left titlebar buttons",
      context: "Swap the title and window controls",
      asterisk: true,
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  optionsection2 = new OptionSection({
    props: {
      title: "Center window title",
      context: "Put the window title in the center of the titlebar.",
      asterisk: true,
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  optionsection3 = new OptionSection({
    props: {
      title: "Titlebar Buttons",
      context: "Change the titlebar controls",
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  asterisk = new Asterisk({
    props: {
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Windows";
      t1 = space();
      create_component(optionsection0.$$.fragment);
      t2 = space();
      create_component(optionsection1.$$.fragment);
      t3 = space();
      create_component(optionsection2.$$.fragment);
      t4 = space();
      create_component(optionsection3.$$.fragment);
      t5 = space();
      create_component(asterisk.$$.fragment);
      attr(h1, "class", "page-title");
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      insert(target, t1, anchor);
      mount_component(optionsection0, target, anchor);
      insert(target, t2, anchor);
      mount_component(optionsection1, target, anchor);
      insert(target, t3, anchor);
      mount_component(optionsection2, target, anchor);
      insert(target, t4, anchor);
      mount_component(optionsection3, target, anchor);
      insert(target, t5, anchor);
      mount_component(asterisk, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const optionsection0_changes = {};
      if (dirty & /*$$scope, $UserData*/
      33) {
        optionsection0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection0.$set(optionsection0_changes);
      const optionsection1_changes = {};
      if (dirty & /*$$scope, $UserData*/
      33) {
        optionsection1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection1.$set(optionsection1_changes);
      const optionsection2_changes = {};
      if (dirty & /*$$scope, $UserData*/
      33) {
        optionsection2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection2.$set(optionsection2_changes);
      const optionsection3_changes = {};
      if (dirty & /*$$scope*/
      32) {
        optionsection3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      optionsection3.$set(optionsection3_changes);
      const asterisk_changes = {};
      if (dirty & /*$$scope*/
      32) {
        asterisk_changes.$$scope = { dirty, ctx: ctx2 };
      }
      asterisk.$set(asterisk_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(optionsection0.$$.fragment, local);
      transition_in(optionsection1.$$.fragment, local);
      transition_in(optionsection2.$$.fragment, local);
      transition_in(optionsection3.$$.fragment, local);
      transition_in(asterisk.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(optionsection0.$$.fragment, local);
      transition_out(optionsection1.$$.fragment, local);
      transition_out(optionsection2.$$.fragment, local);
      transition_out(optionsection3.$$.fragment, local);
      transition_out(asterisk.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h1);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
      }
      destroy_component(optionsection0, detaching);
      destroy_component(optionsection1, detaching);
      destroy_component(optionsection2, detaching);
      destroy_component(optionsection3, detaching);
      destroy_component(asterisk, detaching);
    }
  };
}
function instance$1O($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(0, $UserData = $$value));
  function input_change_handler() {
    $UserData.sh.window.bigtb = this.checked;
    UserData$2.set($UserData);
  }
  function input_change_handler_1() {
    $UserData.sh.window.lefttb = this.checked;
    UserData$2.set($UserData);
  }
  function input_change_handler_2() {
    $UserData.sh.window.centertb = this.checked;
    UserData$2.set($UserData);
  }
  const click_handler = () => showOverlay("changeTitleButtons", "SettingsApp");
  return [
    $UserData,
    input_change_handler,
    input_change_handler_1,
    input_change_handler_2,
    click_handler
  ];
}
class Windows extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1O, create_fragment$1U, safe_not_equal, {});
  }
}
const SettingsPages = [
  {
    name: "Account",
    icon: AccountIcon,
    content: Account,
    sep: true
  },
  {
    name: "Themes",
    icon: ThemesIcon,
    content: Themes_1
  },
  {
    name: "Wallpaper",
    icon: DesktopIcon$1,
    content: Desktop$1
  },
  {
    name: "Login",
    icon: LockIcon,
    content: LockScreen
  },
  {
    name: "Visuals",
    icon: PersonalizationIcon,
    content: Visuals,
    sep: true
  },
  {
    name: "Shell",
    icon: TaskBarIcon,
    content: Shell$1
  },
  {
    name: "Windows",
    icon: WindowSettingsIcon,
    content: Windows
  },
  {
    name: "Apps",
    icon: AppsIcon,
    content: Apps,
    sep: true
  },
  {
    name: "About",
    icon: Logo(),
    content: About,
    className: "inner-about"
  }
];
function getSettingsPage(key2) {
  for (let i2 = 0; i2 < SettingsPages.length; i2++) {
    if (SettingsPages[i2].name == key2) {
      return SettingsPages[i2];
    }
  }
  return null;
}
function openByKey(key2) {
  const page = getSettingsPage(key2);
  if (!page)
    return;
  openWindow("SettingsApp");
  setTimeout(() => {
    currentSettingsPage.set(page);
  }, 10);
}
function create_if_block_1$d(ctx) {
  let button;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let span;
  let t1_value = (
    /*page*/
    ctx[0].name + ""
  );
  let t1;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      if (!src_url_equal(img.src, img_src_value = /*page*/
      ctx[0].icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*page*/
      ctx[0].name);
      attr(img, "class", "icon");
      attr(span, "class", "caption");
      attr(button, "class", "page");
      button.disabled = button_disabled_value = /*page*/
      ctx[0].disabled;
      toggle_class(
        button,
        "selected",
        /*$currentSettingsPage*/
        ctx[1] && /*page*/
        ctx[0].name == /*$currentSettingsPage*/
        ctx[1].name
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, span);
      append(span, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*page*/
      1 && !src_url_equal(img.src, img_src_value = /*page*/
      ctx2[0].icon)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*page*/
      1 && img_alt_value !== (img_alt_value = /*page*/
      ctx2[0].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*page*/
      1 && t1_value !== (t1_value = /*page*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*page*/
      1 && button_disabled_value !== (button_disabled_value = /*page*/
      ctx2[0].disabled)) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*$currentSettingsPage, page*/
      3) {
        toggle_class(
          button,
          "selected",
          /*$currentSettingsPage*/
          ctx2[1] && /*page*/
          ctx2[0].name == /*$currentSettingsPage*/
          ctx2[1].name
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$P(ctx) {
  let hr;
  return {
    c() {
      hr = element("hr");
    },
    m(target, anchor) {
      insert(target, hr, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(hr);
      }
    }
  };
}
function create_fragment$1T(ctx) {
  let t2;
  let if_block1_anchor;
  let if_block0 = !/*page*/
  ctx[0].hidden && create_if_block_1$d(ctx);
  let if_block1 = (
    /*page*/
    ctx[0].sep && create_if_block$P()
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (!/*page*/
      ctx2[0].hidden) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$d(ctx2);
          if_block0.c();
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*page*/
        ctx2[0].sep
      ) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block$P();
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function instance$1N($$self, $$props, $$invalidate) {
  let $currentSettingsPage;
  component_subscribe($$self, currentSettingsPage, ($$value) => $$invalidate(1, $currentSettingsPage = $$value));
  let { page } = $$props;
  const click_handler = () => setSettingsPage(page);
  $$self.$$set = ($$props2) => {
    if ("page" in $$props2)
      $$invalidate(0, page = $$props2.page);
  };
  return [page, $currentSettingsPage, click_handler];
}
class Page2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1N, create_fragment$1T, safe_not_equal, { page: 0 });
  }
}
function create_fragment$1S(ctx) {
  let div1;
  let span;
  let profilepicture;
  let t0;
  let div0;
  let p0;
  let t1;
  let t2;
  let p1;
  let apireveal;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*pfp*/
      ctx[0]
    ), height: 36 }
  });
  apireveal = new APIReveal({});
  return {
    c() {
      div1 = element("div");
      span = element("span");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      div0 = element("div");
      p0 = element("p");
      t1 = text(
        /*$UserName*/
        ctx[1]
      );
      t2 = space();
      p1 = element("p");
      create_component(apireveal.$$.fragment);
      attr(p0, "class", "name");
      attr(p1, "class", "hostname");
      attr(div0, "class", "username");
      attr(div1, "class", "userprofile");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, span);
      mount_component(profilepicture, span, null);
      append(div1, t0);
      append(div1, div0);
      append(div0, p0);
      append(p0, t1);
      append(div0, t2);
      append(div0, p1);
      mount_component(apireveal, p1, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          span,
          "click",
          /*showPfp*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      1)
        profilepicture_changes.src = /*pfp*/
        ctx2[0];
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*$UserName*/
      2)
        set_data(
          t1,
          /*$UserName*/
          ctx2[1]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      transition_in(apireveal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      transition_out(apireveal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(profilepicture);
      destroy_component(apireveal);
      mounted = false;
      dispose();
    }
  };
}
function instance$1M($$self, $$props, $$invalidate) {
  let $UserData;
  let $UserName;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(3, $UserData = $$value));
  component_subscribe($$self, UserName, ($$value) => $$invalidate(1, $UserName = $$value));
  let pfp = "";
  UserData$2.subscribe(() => {
    $$invalidate(0, pfp = getProfilePicture($UserData.acc.profilePicture));
  });
  function showPfp() {
    if (typeof $UserData.acc.profilePicture == "string")
      showOverlay("largePfp", "SettingsApp");
  }
  return [pfp, $UserName, showPfp];
}
class UserProfile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1M, create_fragment$1S, safe_not_equal, {});
  }
}
function get_each_context$o(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  return child_ctx;
}
function create_if_block$O(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<span class="material-icons-round">menu</span>`;
      attr(button, "class", "page menu");
      toggle_class(
        button,
        "active",
        /*appdata*/
        ctx[0].collapsed
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggleCollapsed*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*appdata*/
      1) {
        toggle_class(
          button,
          "active",
          /*appdata*/
          ctx2[0].collapsed
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$o(ctx) {
  let page_1;
  let current;
  page_1 = new Page2({ props: { page: (
    /*page*/
    ctx[4]
  ) } });
  return {
    c() {
      create_component(page_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(page_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(page_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(page_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(page_1, detaching);
    }
  };
}
function create_fragment$1R(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let userprofile;
  let current;
  let if_block = (
    /*appdata*/
    ctx[0] && create_if_block$O(ctx)
  );
  let each_value = ensure_array_like(SettingsPages);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$o(get_each_context$o(ctx, each_value, i2));
  }
  userprofile = new UserProfile({});
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      create_component(userprofile.$$.fragment);
      attr(div0, "class", "pages");
      attr(div1, "class", "sidebar");
      toggle_class(
        div1,
        "collapsed",
        /*appdata*/
        ctx[0].collapsed
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div0, t0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div1, t1);
      mount_component(userprofile, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*appdata*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$O(ctx2);
          if_block.c();
          if_block.m(div0, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*appdata*/
      1) {
        toggle_class(
          div1,
          "collapsed",
          /*appdata*/
          ctx2[0].collapsed
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(userprofile.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(userprofile.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      destroy_component(userprofile);
    }
  };
}
function instance$1L($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(3, $UserData = $$value));
  let { appdata } = $$props;
  let { app } = $$props;
  function toggleCollapsed() {
    $$invalidate(0, appdata.collapsed = !appdata.collapsed, appdata);
    set_store_value(UserData$2, $UserData.appdata[app.id] = appdata, $UserData);
  }
  $$self.$$set = ($$props2) => {
    if ("appdata" in $$props2)
      $$invalidate(0, appdata = $$props2.appdata);
    if ("app" in $$props2)
      $$invalidate(2, app = $$props2.app);
  };
  return [appdata, toggleCollapsed, app];
}
class Sidebar2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1L, create_fragment$1R, safe_not_equal, { appdata: 0, app: 2 });
  }
}
function create_fragment$1Q(ctx) {
  let sidebar;
  let updating_appdata;
  let t2;
  let content2;
  let current;
  function sidebar_appdata_binding(value) {
    ctx[2](value);
  }
  let sidebar_props = { app: (
    /*app*/
    ctx[1]
  ) };
  if (
    /*appdata*/
    ctx[0] !== void 0
  ) {
    sidebar_props.appdata = /*appdata*/
    ctx[0];
  }
  sidebar = new Sidebar2({ props: sidebar_props });
  binding_callbacks.push(() => bind$1(sidebar, "appdata", sidebar_appdata_binding));
  content2 = new Content$1({ props: { appdata: (
    /*appdata*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(sidebar.$$.fragment);
      t2 = space();
      create_component(content2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sidebar, target, anchor);
      insert(target, t2, anchor);
      mount_component(content2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const sidebar_changes = {};
      if (dirty & /*app*/
      2)
        sidebar_changes.app = /*app*/
        ctx2[1];
      if (!updating_appdata && dirty & /*appdata*/
      1) {
        updating_appdata = true;
        sidebar_changes.appdata = /*appdata*/
        ctx2[0];
        add_flush_callback(() => updating_appdata = false);
      }
      sidebar.$set(sidebar_changes);
      const content_changes = {};
      if (dirty & /*appdata*/
      1)
        content_changes.appdata = /*appdata*/
        ctx2[0];
      content2.$set(content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      transition_in(content2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      transition_out(content2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(sidebar, detaching);
      destroy_component(content2, detaching);
    }
  };
}
function instance$1K($$self, $$props, $$invalidate) {
  let { appdata } = $$props;
  let { app } = $$props;
  function sidebar_appdata_binding(value) {
    appdata = value;
    $$invalidate(0, appdata);
  }
  $$self.$$set = ($$props2) => {
    if ("appdata" in $$props2)
      $$invalidate(0, appdata = $$props2.appdata);
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
  };
  return [appdata, app, sidebar_appdata_binding];
}
let SettingsApp$1 = class SettingsApp extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1K, create_fragment$1Q, safe_not_equal, { appdata: 0, app: 1 });
  }
};
const saveToFS = {
  caption: "Save to ArcFS",
  action: async (_2, data) => {
    const blob = new Blob([JSON.stringify(JSON.parse(data.json), null, 2)], {
      type: "application/json"
    });
    await createDirectory("./Themes");
    const filename = `${data.name}.arctheme`;
    const path = `./Themes/${filename}`;
    await writeFile(path, blob);
    openWindow("FileManager");
    await fbClass.goToDirectory("./Themes");
    setTimeout(() => {
      fbState.update((v2) => {
        v2.selectedFilename = filename;
        return v2;
      });
    });
  },
  icon: "save"
};
const SettingsAppContext = {
  "themerenderer-user": [
    {
      caption: "Delete",
      action: (_2, data) => {
        createOverlayableError(
          {
            title: "Delete theme?",
            message: "Are you sure you want to delete this theme?",
            image: ThemesIcon,
            buttons: [
              {
                caption: "Delete",
                action() {
                  deleteCustomTheme(data["id"]);
                },
                suggested: true
              },
              { caption: "Cancel", action() {
              } }
            ]
          },
          "SettingsApp"
        );
      },
      icon: "delete"
    },
    saveToFS
  ],
  "themerenderer-system": [saveToFS],
  "accountpage-hostname": [
    {
      caption: "View user data",
      action: () => {
        showOverlay("udataExplorer", "SettingsApp");
      },
      icon: "account_tree"
    },
    {
      caption: "Copy server",
      action: () => {
        navigator.clipboard.writeText(getServer() || "localhost");
      },
      icon: "copy"
    }
  ],
  "appearance-accentselector": [
    {
      caption: "Copy color code",
      action: (_2, data) => {
        navigator.clipboard.writeText(`#${data["hex"]}`);
      },
      icon: "copy"
    }
  ]
};
const changePswd = "";
async function changeUsername(old, newName) {
  Log(
    "ts/api/cred.ts: changeUsername",
    `Attempting to change the username for user ${old}`,
    LogLevel.info
  );
  if (get_store_value(UserName) != old) {
    Log(
      "ts/api/cred.ts: changeUsername",
      `Username change failed: the old username does not match the current user`,
      LogLevel.error
    );
    return false;
  }
  const req = await apiCall(
    get_store_value(ConnectedServer),
    "user/rename",
    { newname: toBase64(newName) },
    get_store_value(UserToken)
  );
  const isValid = req.statusCode == 200;
  UserName.set(newName);
  if (!isValid) {
    Log(
      "ts/api/cred.ts: changeUsername",
      `Username change failed: the API did not permit the username change`,
      LogLevel.error
    );
    return false;
  }
  const remembed = localStorage.getItem("arcos-remembered-token");
  if (!remembed) {
    Log(
      "ts/api/cred.ts: changeUsername",
      `Could not update remembered token: it doesn't exist`,
      LogLevel.warn
    );
    return false;
  }
  const rememberedUsername = fromBase64(remembed).split(":")[0];
  if (rememberedUsername != old) {
    Log(
      "ts/api/cred.ts: changeUsername",
      `Could not update remembered token: the token's `,
      LogLevel.warn
    );
    return false;
  }
  localStorage.setItem(
    "arcos-remembered-token",
    toBase64(`${newName}:${fromBase64(remembed).split(":")[1]}`)
  );
  return isValid;
}
async function changePassword(username, old, newPswd, confirmPswd) {
  Log(
    "ts/api/cred.ts: changePassword",
    `Attempting to change password for user ${username}`,
    LogLevel.info
  );
  if (newPswd != confirmPswd)
    return false;
  const req = await apiCall(
    get_store_value(ConnectedServer),
    "user/changepswd",
    { new: toBase64(newPswd) },
    null,
    { username, password: old }
  );
  const isValid = req.statusCode == 200;
  const remembed = localStorage.getItem("arcos-remembered-token");
  if (!remembed || !isValid) {
    Log(
      "ts/api/cred.ts: changePassword",
      `Password change failed: not valid or no remembered token`,
      LogLevel.error
    );
    return isValid;
  }
  const rememberedUsername = fromBase64(remembed).split(":")[0];
  if (rememberedUsername != username) {
    Log(
      "ts/api/cred.ts: changePassword",
      `Password change failed: the username does not match the current user`,
      LogLevel.error
    );
    return isValid;
  }
  localStorage.setItem(
    "arcos-remembered-token",
    toBase64(`${username}:${newPswd}`)
  );
  return isValid;
}
function create_fragment$1P(ctx) {
  let div4;
  let div0;
  let profilepicture;
  let t0;
  let div3;
  let p2;
  let t2;
  let input0;
  let t3;
  let input1;
  let t4;
  let input2;
  let t5;
  let div2;
  let div1;
  let button0;
  let t7;
  let button1;
  let t8;
  let button1_disabled_value;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*img*/
      ctx[0]
    ), height: 50 }
  });
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      div3 = element("div");
      p2 = element("p");
      p2.textContent = "Fill out this form to change your password:";
      t2 = space();
      input0 = element("input");
      t3 = space();
      input1 = element("input");
      t4 = space();
      input2 = element("input");
      t5 = space();
      div2 = element("div");
      div1 = element("div");
      button0 = element("button");
      button0.textContent = "Cancel";
      t7 = space();
      button1 = element("button");
      t8 = text("Change");
      attr(input0, "type", "password");
      attr(input0, "name", "current");
      attr(input0, "placeholder", "Current password");
      attr(input1, "type", "password");
      attr(input1, "name", "current");
      attr(input1, "placeholder", "New password");
      attr(input2, "type", "password");
      attr(input2, "name", "current");
      attr(input2, "placeholder", "Confirm new password");
      button1.disabled = button1_disabled_value = /*newPswd*/
      ctx[2] != /*confirm*/
      ctx[3] || !/*newPswd*/
      ctx[2] || !/*confirm*/
      ctx[3];
      attr(button1, "type", "button");
      attr(div2, "class", "apply");
      attr(div3, "class", "field");
      attr(div4, "class", "changepswd-wrapper");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      mount_component(profilepicture, div0, null);
      append(div4, t0);
      append(div4, div3);
      append(div3, p2);
      append(div3, t2);
      append(div3, input0);
      set_input_value(
        input0,
        /*oldPswd*/
        ctx[1]
      );
      append(div3, t3);
      append(div3, input1);
      set_input_value(
        input1,
        /*newPswd*/
        ctx[2]
      );
      append(div3, t4);
      append(div3, input2);
      set_input_value(
        input2,
        /*confirm*/
        ctx[3]
      );
      append(div3, t5);
      append(div3, div2);
      append(div2, div1);
      append(div1, button0);
      append(div1, t7);
      append(div1, button1);
      append(button1, t8);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[8]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[9]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[10]
          ),
          listen(
            button0,
            "click",
            /*cancel*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*apply*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*img*/
      1)
        profilepicture_changes.src = /*img*/
        ctx2[0];
      profilepicture.$set(profilepicture_changes);
      if (dirty & /*oldPswd*/
      2 && input0.value !== /*oldPswd*/
      ctx2[1]) {
        set_input_value(
          input0,
          /*oldPswd*/
          ctx2[1]
        );
      }
      if (dirty & /*newPswd*/
      4 && input1.value !== /*newPswd*/
      ctx2[2]) {
        set_input_value(
          input1,
          /*newPswd*/
          ctx2[2]
        );
      }
      if (dirty & /*confirm*/
      8 && input2.value !== /*confirm*/
      ctx2[3]) {
        set_input_value(
          input2,
          /*confirm*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*newPswd, confirm*/
      12 && button1_disabled_value !== (button1_disabled_value = /*newPswd*/
      ctx2[2] != /*confirm*/
      ctx2[3] || !/*newPswd*/
      ctx2[2] || !/*confirm*/
      ctx2[3])) {
        button1.disabled = button1_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      destroy_component(profilepicture);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1J($$self, $$props, $$invalidate) {
  let $UserName;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(11, $UserName = $$value));
  let img = "";
  let { id } = $$props;
  let { app } = $$props;
  let oldPswd = "";
  let newPswd = "";
  let confirm = "";
  UserData$2.subscribe((v2) => {
    $$invalidate(0, img = getProfilePicture(v2.acc.profilePicture));
  });
  function cancel() {
    hideOverlay(id, app.id);
  }
  function closeThis() {
    reset();
    cancel();
  }
  async function apply() {
    const valid = await changePassword($UserName, oldPswd, newPswd, confirm);
    if (!valid)
      return createOverlayableError(
        {
          title: "Couldn't change password",
          message: "An error occured while changing your password. Please make sure the entered information is correct, and then try again.",
          buttons: [
            {
              caption: "OK",
              action: reset,
              suggested: true
            }
          ],
          image: PasswordIcon
        },
        app.id
      );
    createOverlayableError(
      {
        title: "Password changed.",
        message: "Your password has been updated successfully.",
        buttons: [
          {
            caption: "OK",
            action: closeThis,
            suggested: true
          }
        ],
        image: PasswordIcon
      },
      app.id
    );
  }
  function reset() {
    $$invalidate(1, oldPswd = "");
    $$invalidate(2, newPswd = "");
    $$invalidate(3, confirm = "");
  }
  function input0_input_handler() {
    oldPswd = this.value;
    $$invalidate(1, oldPswd);
  }
  function input1_input_handler() {
    newPswd = this.value;
    $$invalidate(2, newPswd);
  }
  function input2_input_handler() {
    confirm = this.value;
    $$invalidate(3, confirm);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(6, id = $$props2.id);
    if ("app" in $$props2)
      $$invalidate(7, app = $$props2.app);
  };
  return [
    img,
    oldPswd,
    newPswd,
    confirm,
    cancel,
    apply,
    id,
    app,
    input0_input_handler,
    input1_input_handler,
    input2_input_handler
  ];
}
class ChangePassword extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1J, create_fragment$1P, safe_not_equal, { id: 6, app: 7 });
  }
}
const changeUname = "";
function create_fragment$1O(ctx) {
  let div4;
  let div0;
  let profilepicture;
  let t0;
  let div3;
  let p0;
  let t1;
  let t2;
  let p1;
  let t4;
  let input;
  let t5;
  let div2;
  let div1;
  let button0;
  let t7;
  let button1;
  let t8;
  let button1_disabled_value;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*img*/
      ctx[0]
    ), height: 50 }
  });
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      div3 = element("div");
      p0 = element("p");
      t1 = text(
        /*$UserName*/
        ctx[2]
      );
      t2 = space();
      p1 = element("p");
      p1.textContent = "Enter a new username";
      t4 = space();
      input = element("input");
      t5 = space();
      div2 = element("div");
      div1 = element("div");
      button0 = element("button");
      button0.textContent = "Cancel";
      t7 = space();
      button1 = element("button");
      t8 = text("Change");
      attr(p0, "class", "username");
      attr(input, "type", "text");
      attr(input, "name", "current");
      attr(input, "placeholder", "New username");
      button1.disabled = button1_disabled_value = !/*newName*/
      ctx[1];
      attr(button1, "type", "button");
      attr(div2, "class", "apply");
      attr(div3, "class", "field");
      attr(div4, "class", "changename-wrapper");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      mount_component(profilepicture, div0, null);
      append(div4, t0);
      append(div4, div3);
      append(div3, p0);
      append(p0, t1);
      append(div3, t2);
      append(div3, p1);
      append(div3, t4);
      append(div3, input);
      set_input_value(
        input,
        /*newName*/
        ctx[1]
      );
      append(div3, t5);
      append(div3, div2);
      append(div2, div1);
      append(div1, button0);
      append(div1, t7);
      append(div1, button1);
      append(button1, t8);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[7]
          ),
          listen(
            button0,
            "click",
            /*cancel*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*confirmChange*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*img*/
      1)
        profilepicture_changes.src = /*img*/
        ctx2[0];
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*$UserName*/
      4)
        set_data(
          t1,
          /*$UserName*/
          ctx2[2]
        );
      if (dirty & /*newName*/
      2 && input.value !== /*newName*/
      ctx2[1]) {
        set_input_value(
          input,
          /*newName*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*newName*/
      2 && button1_disabled_value !== (button1_disabled_value = !/*newName*/
      ctx2[1])) {
        button1.disabled = button1_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      destroy_component(profilepicture);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1I($$self, $$props, $$invalidate) {
  let $UserName;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(2, $UserName = $$value));
  let img = "";
  let { id } = $$props;
  let { app } = $$props;
  let newName = "";
  UserData$2.subscribe((v2) => {
    $$invalidate(0, img = getProfilePicture(v2.acc.profilePicture));
  });
  function confirmChange() {
    createOverlayableError(
      {
        title: "Please be aware",
        message: "Changing your username will only update the credentials on this ArcOS instance on this device. You'll have to log in again on all other devices. Proceed?",
        buttons: [
          {
            caption: "Change it",
            action: change,
            suggested: true
          },
          {
            caption: "Cancel",
            action() {
            }
          }
        ],
        image: AccountIcon
      },
      "SettingsApp"
    );
  }
  async function change() {
    const valid = await changeUsername($UserName, newName);
    if (!valid)
      return createOverlayableError(
        {
          title: "Can't rename user",
          message: "An error occured while trying to rename your account. Please make sure the information is correct, and then try again.",
          buttons: [
            {
              caption: "OK",
              action: reset,
              suggested: true
            }
          ],
          image: AccountIcon
        },
        "SettingsApp"
      );
    createOverlayableError(
      {
        title: "Username changed.",
        message: "Your username has been updated successfully.",
        buttons: [
          {
            caption: "OK",
            action: closeThis,
            suggested: true
          }
        ],
        image: AccountIcon
      },
      "SettingsApp"
    );
  }
  function cancel() {
    hideOverlay(id, app.id);
  }
  function reset() {
    $$invalidate(1, newName = "");
  }
  function closeThis() {
    reset();
    cancel();
  }
  function input_input_handler() {
    newName = this.value;
    $$invalidate(1, newName);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(5, id = $$props2.id);
    if ("app" in $$props2)
      $$invalidate(6, app = $$props2.app);
  };
  return [img, newName, $UserName, confirmChange, cancel, id, app, input_input_handler];
}
class ChangeUsername extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1I, create_fragment$1O, safe_not_equal, { id: 5, app: 6 });
  }
}
const AccountPageOverlays = {
  udataExplorer: {
    info: {
      name: "User Data Explorer",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: UserDataExplorer,
    size: { w: 550, h: 400 },
    show: false
  },
  changePswd: {
    info: {
      name: "Change Password",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: ChangePassword,
    size: { w: 370, h: 195 },
    show: false
  },
  changeUsername: {
    info: {
      name: "Change Username",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: ChangeUsername,
    size: { w: 370, h: 155 },
    show: false
  }
};
const changetitlebuttons = "";
const Accented_svelte_svelte_type_style_lang = "";
function create_fragment$1N(ctx) {
  let button0;
  let t0;
  let button0_disabled_value;
  let t1;
  let button1;
  let t2;
  let button1_disabled_value;
  let t3;
  let button2;
  let t4;
  let button2_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      t0 = text("minimize");
      t1 = space();
      button1 = element("button");
      t2 = text("crop_square");
      t3 = space();
      button2 = element("button");
      t4 = text("close");
      attr(button0, "class", "material-icons-round reset svelte-1u1lj");
      button0.disabled = button0_disabled_value = !/*app*/
      ctx[0].controls.min || /*isBoot*/
      ctx[1];
      attr(button1, "class", "material-icons-round reset svelte-1u1lj");
      button1.disabled = button1_disabled_value = !/*app*/
      ctx[0].controls.max || /*isBoot*/
      ctx[1];
      attr(button2, "class", "material-icons-round reset close svelte-1u1lj");
      button2.disabled = button2_disabled_value = !/*app*/
      ctx[0].controls.cls || /*isBoot*/
      ctx[1];
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      append(button0, t0);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      append(button1, t2);
      insert(target, t3, anchor);
      insert(target, button2, anchor);
      append(button2, t4);
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(
              /*min*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(
              /*max*/
              ctx[3]
            ))
              ctx[3].apply(this, arguments);
          }),
          listen(button2, "click", function() {
            if (is_function(
              /*cls*/
              ctx[4]
            ))
              ctx[4].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*app, isBoot*/
      3 && button0_disabled_value !== (button0_disabled_value = !/*app*/
      ctx[0].controls.min || /*isBoot*/
      ctx[1])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*app, isBoot*/
      3 && button1_disabled_value !== (button1_disabled_value = !/*app*/
      ctx[0].controls.max || /*isBoot*/
      ctx[1])) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*app, isBoot*/
      3 && button2_disabled_value !== (button2_disabled_value = !/*app*/
      ctx[0].controls.cls || /*isBoot*/
      ctx[1])) {
        button2.disabled = button2_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t1);
        detach(button1);
        detach(t3);
        detach(button2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1H($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { isBoot } = $$props;
  let { min } = $$props;
  let { max } = $$props;
  let { cls } = $$props;
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("isBoot" in $$props2)
      $$invalidate(1, isBoot = $$props2.isBoot);
    if ("min" in $$props2)
      $$invalidate(2, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(3, max = $$props2.max);
    if ("cls" in $$props2)
      $$invalidate(4, cls = $$props2.cls);
  };
  return [app, isBoot, min, max, cls];
}
class Accented extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1H, create_fragment$1N, safe_not_equal, {
      app: 0,
      isBoot: 1,
      min: 2,
      max: 3,
      cls: 4
    });
  }
}
const Default_svelte_svelte_type_style_lang = "";
function create_fragment$1M(ctx) {
  let button0;
  let t0;
  let button0_disabled_value;
  let t1;
  let button1;
  let t2;
  let button1_disabled_value;
  let t3;
  let button2;
  let t4;
  let button2_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      t0 = text("minimize");
      t1 = space();
      button1 = element("button");
      t2 = text("crop_square");
      t3 = space();
      button2 = element("button");
      t4 = text("close");
      attr(button0, "class", "material-icons-round reset svelte-b39q7j");
      button0.disabled = button0_disabled_value = !/*app*/
      ctx[0].controls.min || /*isBoot*/
      ctx[1];
      attr(button1, "class", "material-icons-round reset svelte-b39q7j");
      button1.disabled = button1_disabled_value = !/*app*/
      ctx[0].controls.max || /*isBoot*/
      ctx[1];
      attr(button2, "class", "material-icons-round reset svelte-b39q7j");
      button2.disabled = button2_disabled_value = !/*app*/
      ctx[0].controls.cls || /*isBoot*/
      ctx[1];
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      append(button0, t0);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      append(button1, t2);
      insert(target, t3, anchor);
      insert(target, button2, anchor);
      append(button2, t4);
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(
              /*min*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(
              /*max*/
              ctx[3]
            ))
              ctx[3].apply(this, arguments);
          }),
          listen(button2, "click", function() {
            if (is_function(
              /*cls*/
              ctx[4]
            ))
              ctx[4].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*app, isBoot*/
      3 && button0_disabled_value !== (button0_disabled_value = !/*app*/
      ctx[0].controls.min || /*isBoot*/
      ctx[1])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*app, isBoot*/
      3 && button1_disabled_value !== (button1_disabled_value = !/*app*/
      ctx[0].controls.max || /*isBoot*/
      ctx[1])) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*app, isBoot*/
      3 && button2_disabled_value !== (button2_disabled_value = !/*app*/
      ctx[0].controls.cls || /*isBoot*/
      ctx[1])) {
        button2.disabled = button2_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t1);
        detach(button1);
        detach(t3);
        detach(button2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1G($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { isBoot } = $$props;
  let { min } = $$props;
  let { max } = $$props;
  let { cls } = $$props;
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("isBoot" in $$props2)
      $$invalidate(1, isBoot = $$props2.isBoot);
    if ("min" in $$props2)
      $$invalidate(2, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(3, max = $$props2.max);
    if ("cls" in $$props2)
      $$invalidate(4, cls = $$props2.cls);
  };
  return [app, isBoot, min, max, cls];
}
class Default extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1G, create_fragment$1M, safe_not_equal, {
      app: 0,
      isBoot: 1,
      min: 2,
      max: 3,
      cls: 4
    });
  }
}
const OG_svelte_svelte_type_style_lang = "";
function create_fragment$1L(ctx) {
  let button0;
  let t0;
  let button0_disabled_value;
  let t1;
  let button1;
  let t2;
  let button1_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      t0 = text("🗕");
      t1 = space();
      button1 = element("button");
      t2 = text("✖");
      attr(button0, "class", "reset svelte-1f14mwt");
      button0.disabled = button0_disabled_value = /*isBoot*/
      ctx[1] || !/*app*/
      ctx[0].controls.min;
      attr(button1, "class", "reset close svelte-1f14mwt");
      button1.disabled = button1_disabled_value = /*isBoot*/
      ctx[1] || !/*app*/
      ctx[0].controls.cls;
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      append(button0, t0);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      append(button1, t2);
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(
              /*min*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(
              /*cls*/
              ctx[3]
            ))
              ctx[3].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*isBoot, app*/
      3 && button0_disabled_value !== (button0_disabled_value = /*isBoot*/
      ctx[1] || !/*app*/
      ctx[0].controls.min)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*isBoot, app*/
      3 && button1_disabled_value !== (button1_disabled_value = /*isBoot*/
      ctx[1] || !/*app*/
      ctx[0].controls.cls)) {
        button1.disabled = button1_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t1);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1F($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { isBoot } = $$props;
  let { min } = $$props;
  let { cls } = $$props;
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("isBoot" in $$props2)
      $$invalidate(1, isBoot = $$props2.isBoot);
    if ("min" in $$props2)
      $$invalidate(2, min = $$props2.min);
    if ("cls" in $$props2)
      $$invalidate(3, cls = $$props2.cls);
  };
  return [app, isBoot, min, cls];
}
class OG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1F, create_fragment$1L, safe_not_equal, { app: 0, isBoot: 1, min: 2, cls: 3 });
  }
}
const Traffic_svelte_svelte_type_style_lang = "";
function create_fragment$1K(ctx) {
  let button0;
  let button0_disabled_value;
  let t0;
  let button1;
  let button1_disabled_value;
  let t1;
  let button2;
  let button2_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      t0 = space();
      button1 = element("button");
      t1 = space();
      button2 = element("button");
      attr(button0, "class", "traffic-cls reset svelte-gqwqqi");
      button0.disabled = button0_disabled_value = !/*app*/
      ctx[0].controls.cls || /*isBoot*/
      ctx[1];
      attr(button1, "class", "traffic-min reset svelte-gqwqqi");
      button1.disabled = button1_disabled_value = !/*app*/
      ctx[0].controls.min || /*isBoot*/
      ctx[1];
      attr(button2, "class", "traffic-max reset svelte-gqwqqi");
      button2.disabled = button2_disabled_value = !/*app*/
      ctx[0].controls.max || /*isBoot*/
      ctx[1];
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      insert(target, t0, anchor);
      insert(target, button1, anchor);
      insert(target, t1, anchor);
      insert(target, button2, anchor);
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(
              /*cls*/
              ctx[4]
            ))
              ctx[4].apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(
              /*min*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          }),
          listen(button2, "click", function() {
            if (is_function(
              /*max*/
              ctx[3]
            ))
              ctx[3].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*app, isBoot*/
      3 && button0_disabled_value !== (button0_disabled_value = !/*app*/
      ctx[0].controls.cls || /*isBoot*/
      ctx[1])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*app, isBoot*/
      3 && button1_disabled_value !== (button1_disabled_value = !/*app*/
      ctx[0].controls.min || /*isBoot*/
      ctx[1])) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*app, isBoot*/
      3 && button2_disabled_value !== (button2_disabled_value = !/*app*/
      ctx[0].controls.max || /*isBoot*/
      ctx[1])) {
        button2.disabled = button2_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t0);
        detach(button1);
        detach(t1);
        detach(button2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1E($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { isBoot } = $$props;
  let { min } = $$props;
  let { max } = $$props;
  let { cls } = $$props;
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("isBoot" in $$props2)
      $$invalidate(1, isBoot = $$props2.isBoot);
    if ("min" in $$props2)
      $$invalidate(2, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(3, max = $$props2.max);
    if ("cls" in $$props2)
      $$invalidate(4, cls = $$props2.cls);
  };
  return [app, isBoot, min, max, cls];
}
class Traffic extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1E, create_fragment$1K, safe_not_equal, {
      app: 0,
      isBoot: 1,
      min: 2,
      max: 3,
      cls: 4
    });
  }
}
const titlebarButtons = {
  default: {
    caption: "Default",
    author: "ArcOS Team",
    content: Default
  },
  traffic: {
    caption: "Traffic Lights",
    author: "Apple",
    content: Traffic
  },
  og: {
    caption: "O.G.",
    author: "WebOSv3 Team",
    content: OG
  },
  accented: {
    caption: "Accented",
    author: "ArcOS Team",
    content: Accented
  }
};
const DummyApp = {
  info: {
    name: "Dummy",
    description: "I'm a dummy!",
    builtin: true,
    version: "1.0.0",
    author: "Robots",
    icon: DefaultIcon
  },
  pos: { x: 0, y: 0 },
  minSize: { w: 0, h: 0 },
  maxSize: { w: 0, h: 0 },
  size: { w: 0, h: 0 },
  controls: { min: true, max: true, cls: true },
  state: {
    headless: false,
    resizable: true,
    windowState: {
      fll: false,
      max: false,
      min: false
    }
  },
  glass: false,
  content: null
};
function create_fragment$1J(ctx) {
  let div3;
  let div1;
  let div0;
  let switch_instance;
  let t0;
  let div2;
  let p0;
  let t1_value = (
    /*data*/
    ctx[0].caption + ""
  );
  let t1;
  let t2;
  let p1;
  let t3;
  let t4_value = (
    /*data*/
    ctx[0].author + ""
  );
  let t4;
  let t5;
  let button;
  let t6_value = (
    /*$UserData*/
    ctx[2].sh.window.buttons == /*id*/
    ctx[1] ? "Applied" : "Apply"
  );
  let t6;
  let button_disabled_value;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*data*/
    ctx[0].content
  );
  function switch_props(ctx2, dirty) {
    return { props: { app: DummyApp } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t0 = space();
      div2 = element("div");
      p0 = element("p");
      t1 = text(t1_value);
      t2 = space();
      p1 = element("p");
      t3 = text("By: ");
      t4 = text(t4_value);
      t5 = space();
      button = element("button");
      t6 = text(t6_value);
      attr(div0, "class", "tb");
      attr(div1, "class", "preview");
      attr(p0, "class", "title");
      attr(p1, "class", "author");
      attr(div2, "class", "details");
      attr(button, "class", "apply");
      button.disabled = button_disabled_value = /*$UserData*/
      ctx[2].sh.window.buttons == /*id*/
      ctx[1];
      attr(div3, "class", "item");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      if (switch_instance)
        mount_component(switch_instance, div0, null);
      append(div3, t0);
      append(div3, div2);
      append(div2, p0);
      append(p0, t1);
      append(div2, t2);
      append(div2, p1);
      append(p1, t3);
      append(p1, t4);
      append(div3, t5);
      append(div3, button);
      append(button, t6);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*apply*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*data*/
      1 && switch_value !== (switch_value = /*data*/
      ctx2[0].content)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div0, null);
        } else {
          switch_instance = null;
        }
      }
      if ((!current || dirty & /*data*/
      1) && t1_value !== (t1_value = /*data*/
      ctx2[0].caption + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & /*data*/
      1) && t4_value !== (t4_value = /*data*/
      ctx2[0].author + ""))
        set_data(t4, t4_value);
      if ((!current || dirty & /*$UserData, id*/
      6) && t6_value !== (t6_value = /*$UserData*/
      ctx2[2].sh.window.buttons == /*id*/
      ctx2[1] ? "Applied" : "Apply"))
        set_data(t6, t6_value);
      if (!current || dirty & /*$UserData, id*/
      6 && button_disabled_value !== (button_disabled_value = /*$UserData*/
      ctx2[2].sh.window.buttons == /*id*/
      ctx2[1])) {
        button.disabled = button_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      dispose();
    }
  };
}
function instance$1D($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(2, $UserData = $$value));
  let { data } = $$props;
  let { id } = $$props;
  function apply() {
    set_store_value(UserData$2, $UserData.sh.window.buttons = id, $UserData);
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
  };
  return [data, id, $UserData, apply];
}
let Item$1 = class Item2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1D, create_fragment$1J, safe_not_equal, { data: 0, id: 1 });
  }
};
function get_each_context$n(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2];
  return child_ctx;
}
function create_each_block$n(ctx) {
  let item;
  let current;
  item = new Item$1({
    props: {
      id: (
        /*entry*/
        ctx[2][0]
      ),
      data: (
        /*entry*/
        ctx[2][1]
      )
    }
  });
  return {
    c() {
      create_component(item.$$.fragment);
    },
    m(target, anchor) {
      mount_component(item, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(item.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(item.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(item, detaching);
    }
  };
}
function create_fragment$1I(ctx) {
  let closebutton;
  let t0;
  let h3;
  let t2;
  let p2;
  let t4;
  let each_1_anchor;
  let current;
  closebutton = new CloseButton({
    props: { app: (
      /*app*/
      ctx[0]
    ), id: (
      /*id*/
      ctx[1]
    ) }
  });
  let each_value = ensure_array_like(Object.entries(titlebarButtons));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$n(get_each_context$n(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      create_component(closebutton.$$.fragment);
      t0 = space();
      h3 = element("h3");
      h3.textContent = "Titlebar buttons";
      t2 = space();
      p2 = element("p");
      p2.textContent = "Choose one of the titlebar button styles:";
      t4 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(h3, "class", "header");
      attr(p2, "class", "subheader");
    },
    m(target, anchor) {
      mount_component(closebutton, target, anchor);
      insert(target, t0, anchor);
      insert(target, h3, anchor);
      insert(target, t2, anchor);
      insert(target, p2, anchor);
      insert(target, t4, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const closebutton_changes = {};
      if (dirty & /*app*/
      1)
        closebutton_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*id*/
      2)
        closebutton_changes.id = /*id*/
        ctx2[1];
      closebutton.$set(closebutton_changes);
      if (dirty & /*Object*/
      0) {
        each_value = ensure_array_like(Object.entries(titlebarButtons));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$n(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$n(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(closebutton.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(closebutton.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(h3);
        detach(t2);
        detach(p2);
        detach(t4);
        detach(each_1_anchor);
      }
      destroy_component(closebutton, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$1C($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { id } = $$props;
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
  };
  return [app, id];
}
class ChangeTitleButtons extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1C, create_fragment$1I, safe_not_equal, { app: 0, id: 1 });
  }
}
const customWallpaper = "";
function create_fragment$1H(ctx) {
  let div4;
  let div0;
  let t0;
  let div3;
  let p2;
  let t2;
  let input;
  let t3;
  let div2;
  let div1;
  let button0;
  let t5;
  let button1;
  let t6;
  let button1_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      div0.innerHTML = `<img src="${DesktopIcon$1}" alt=""/>`;
      t0 = space();
      div3 = element("div");
      p2 = element("p");
      p2.textContent = "Enter the URL to a custom wallpaper:";
      t2 = space();
      input = element("input");
      t3 = space();
      div2 = element("div");
      div1 = element("div");
      button0 = element("button");
      button0.textContent = "Cancel";
      t5 = space();
      button1 = element("button");
      t6 = text("Apply");
      attr(input, "type", "url");
      attr(input, "placeholder", "https://example.com/image.png");
      button1.disabled = button1_disabled_value = !/*url*/
      ctx[1] || !/*valid*/
      ctx[0];
      attr(button1, "class", "suggested");
      attr(div2, "class", "apply");
      attr(div3, "class", "field");
      attr(div4, "class", "customwallpaper-wrapper");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div4, t0);
      append(div4, div3);
      append(div3, p2);
      append(div3, t2);
      append(div3, input);
      set_input_value(
        input,
        /*url*/
        ctx[1]
      );
      append(div3, t3);
      append(div3, div2);
      append(div2, div1);
      append(div1, button0);
      append(div1, t5);
      append(div1, button1);
      append(button1, t6);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[5]
          ),
          listen(
            input,
            "input",
            /*check*/
            ctx[3]
          ),
          listen(
            button0,
            "click",
            /*cancel*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*load*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*url*/
      2 && input.value !== /*url*/
      ctx2[1]) {
        set_input_value(
          input,
          /*url*/
          ctx2[1]
        );
      }
      if (dirty & /*url, valid*/
      3 && button1_disabled_value !== (button1_disabled_value = !/*url*/
      ctx2[1] || !/*valid*/
      ctx2[0])) {
        button1.disabled = button1_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
async function checkImage$2(url) {
  if (!url)
    return;
  const img = new Image();
  img.src = url;
  return new Promise((resolve) => {
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
  });
}
function instance$1B($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(6, $UserData = $$value));
  let valid = false;
  let url;
  function load() {
    set_store_value(UserData$2, $UserData.sh.desktop.wallpaper = url, $UserData);
    cancel();
  }
  onMount(() => {
    if ($UserData.sh.desktop.wallpaper.startsWith("http")) {
      $$invalidate(1, url = $UserData.sh.desktop.wallpaper);
    }
  });
  async function check() {
    const v2 = await checkImage$2(url);
    $$invalidate(0, valid = v2);
  }
  function cancel() {
    hideOverlay("customWallpaper", "SettingsApp");
  }
  UserData$2.subscribe((v2) => {
    if (typeof v2.sh.desktop.wallpaper == "string" && v2.sh.desktop.wallpaper.startsWith("http"))
      $$invalidate(1, url = v2.sh.desktop.wallpaper);
    check();
  });
  function input_input_handler() {
    url = this.value;
    $$invalidate(1, url);
  }
  return [valid, url, load, check, cancel, input_input_handler];
}
class CustomWallpaper extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1B, create_fragment$1H, safe_not_equal, {});
  }
}
const DesktopOverlays = {
  customWallpaper: {
    info: {
      name: "Custom Wallpaper",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: CustomWallpaper,
    size: { w: 370, h: 126 },
    show: false
  },
  changeTitleButtons: {
    info: {
      name: "Change Titlebar Buttons",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: ChangeTitleButtons,
    size: { w: 400, h: 300 },
    show: false
  }
};
function create_fragment$1G(ctx) {
  let div4;
  let div0;
  let t0;
  let div3;
  let p2;
  let t2;
  let input;
  let t3;
  let div2;
  let div1;
  let button0;
  let t5;
  let button1;
  let t6;
  let button1_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      div0.innerHTML = `<img src="${LockIcon}" alt=""/>`;
      t0 = space();
      div3 = element("div");
      p2 = element("p");
      p2.textContent = "Enter the URL to a custom login wallpaper:";
      t2 = space();
      input = element("input");
      t3 = space();
      div2 = element("div");
      div1 = element("div");
      button0 = element("button");
      button0.textContent = "Cancel";
      t5 = space();
      button1 = element("button");
      t6 = text("Apply");
      attr(input, "type", "url");
      attr(input, "placeholder", "https://example.com/image.png");
      button1.disabled = button1_disabled_value = !/*url*/
      ctx[1] || !/*valid*/
      ctx[0];
      attr(button1, "class", "suggested");
      attr(div2, "class", "apply");
      attr(div3, "class", "field");
      attr(div4, "class", "customwallpaper-wrapper");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div4, t0);
      append(div4, div3);
      append(div3, p2);
      append(div3, t2);
      append(div3, input);
      set_input_value(
        input,
        /*url*/
        ctx[1]
      );
      append(div3, t3);
      append(div3, div2);
      append(div2, div1);
      append(div1, button0);
      append(div1, t5);
      append(div1, button1);
      append(button1, t6);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[5]
          ),
          listen(
            input,
            "input",
            /*check*/
            ctx[3]
          ),
          listen(
            button0,
            "click",
            /*cancel*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*load*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*url*/
      2 && input.value !== /*url*/
      ctx2[1]) {
        set_input_value(
          input,
          /*url*/
          ctx2[1]
        );
      }
      if (dirty & /*url, valid*/
      3 && button1_disabled_value !== (button1_disabled_value = !/*url*/
      ctx2[1] || !/*valid*/
      ctx2[0])) {
        button1.disabled = button1_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
async function checkImage$1(url) {
  if (!url)
    return;
  const img = new Image();
  img.src = url;
  return new Promise((resolve) => {
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
  });
}
function instance$1A($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(6, $UserData = $$value));
  let valid = false;
  let url;
  function load() {
    set_store_value(UserData$2, $UserData.acc.loginBackground = url, $UserData);
    cancel();
  }
  onMount(() => {
    if ($UserData.acc.loginBackground && $UserData.acc.loginBackground.startsWith("http")) {
      $$invalidate(1, url = $UserData.acc.loginBackground);
    }
  });
  async function check() {
    const v2 = await checkImage$1(url);
    $$invalidate(0, valid = v2);
  }
  function cancel() {
    hideOverlay("customLoginWallpaper", "SettingsApp");
  }
  UserData$2.subscribe((v2) => {
    if (v2.acc.loginBackground && typeof v2.acc.loginBackground == "string" && v2.acc.loginBackground.startsWith("http"))
      $$invalidate(1, url = v2.acc.loginBackground);
    check();
  });
  function input_input_handler() {
    url = this.value;
    $$invalidate(1, url);
  }
  return [valid, url, load, check, cancel, input_input_handler];
}
class CustomLoginWallpaper extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1A, create_fragment$1G, safe_not_equal, {});
  }
}
const LockScreenOverlays = {
  customLoginWallpaper: {
    info: {
      name: "Custom Login Wallpaper",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: CustomLoginWallpaper,
    size: { w: 370, h: 126 },
    show: false
  }
};
const customPfp = "";
function create_fragment$1F(ctx) {
  let div4;
  let div0;
  let profilepicture;
  let t0;
  let div3;
  let p2;
  let t2;
  let input;
  let t3;
  let div2;
  let div1;
  let button0;
  let t5;
  let button1;
  let t6;
  let button1_disabled_value;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: {
      src: (
        /*valid*/
        ctx[1] ? (
          /*img*/
          ctx[0]
        ) : ProfilePictures.def
      ),
      height: 50
    }
  });
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      div3 = element("div");
      p2 = element("p");
      p2.textContent = "Enter the URL to a custom profile picture:";
      t2 = space();
      input = element("input");
      t3 = space();
      div2 = element("div");
      div1 = element("div");
      button0 = element("button");
      button0.textContent = "Cancel";
      t5 = space();
      button1 = element("button");
      t6 = text("Apply");
      attr(input, "type", "url");
      attr(input, "placeholder", "https://example.com/image.png");
      button1.disabled = button1_disabled_value = !/*img*/
      ctx[0] || !/*valid*/
      ctx[1];
      attr(div2, "class", "apply");
      attr(div3, "class", "field");
      attr(div4, "class", "custompfp-wrapper");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      mount_component(profilepicture, div0, null);
      append(div4, t0);
      append(div4, div3);
      append(div3, p2);
      append(div3, t2);
      append(div3, input);
      set_input_value(
        input,
        /*img*/
        ctx[0]
      );
      append(div3, t3);
      append(div3, div2);
      append(div2, div1);
      append(div1, button0);
      append(div1, t5);
      append(div1, button1);
      append(button1, t6);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[5]
          ),
          listen(
            input,
            "input",
            /*check*/
            ctx[2]
          ),
          listen(
            button0,
            "click",
            /*cancel*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*apply*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*valid, img*/
      3)
        profilepicture_changes.src = /*valid*/
        ctx2[1] ? (
          /*img*/
          ctx2[0]
        ) : ProfilePictures.def;
      profilepicture.$set(profilepicture_changes);
      if (dirty & /*img*/
      1 && input.value !== /*img*/
      ctx2[0]) {
        set_input_value(
          input,
          /*img*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*img, valid*/
      3 && button1_disabled_value !== (button1_disabled_value = !/*img*/
      ctx2[0] || !/*valid*/
      ctx2[1])) {
        button1.disabled = button1_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      destroy_component(profilepicture);
      mounted = false;
      run_all(dispose);
    }
  };
}
async function checkImage(url) {
  const img = new Image();
  img.src = url;
  return new Promise((resolve) => {
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
  });
}
function instance$1z($$self, $$props, $$invalidate) {
  let img = "";
  let valid = false;
  async function check() {
    const v2 = await checkImage(img);
    $$invalidate(1, valid = v2);
  }
  function apply() {
    applyCustomPfp(img);
    hideOverlay("customPfp", "SettingsApp");
    hideOverlay("pfpSel", "SettingsApp");
  }
  function cancel() {
    hideOverlay("customPfp", "SettingsApp");
  }
  UserData$2.subscribe((v2) => {
    if (typeof v2.acc.profilePicture == "string")
      $$invalidate(0, img = v2.acc.profilePicture);
    check();
  });
  function input_input_handler() {
    img = this.value;
    $$invalidate(0, img);
  }
  return [img, valid, check, apply, cancel, input_input_handler];
}
class CustomProfilePicture extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1z, create_fragment$1F, safe_not_equal, {});
  }
}
const ProfilePictureView_svelte_svelte_type_style_lang = "";
function create_fragment$1E(ctx) {
  let closebutton;
  let t0;
  let div1;
  let div0;
  let profilepicture;
  let t1;
  let h1;
  let t2;
  let t3;
  let p2;
  let apireveal;
  let current;
  closebutton = new CloseButton({
    props: { id: (
      /*id*/
      ctx[0]
    ), app: (
      /*app*/
      ctx[1]
    ) }
  });
  profilepicture = new ProfilePicture({
    props: {
      src: (
        /*$UserData*/
        ctx[2].acc.profilePicture.toString()
      ),
      height: 150
    }
  });
  apireveal = new APIReveal({});
  return {
    c() {
      create_component(closebutton.$$.fragment);
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      create_component(profilepicture.$$.fragment);
      t1 = space();
      h1 = element("h1");
      t2 = text(
        /*$UserName*/
        ctx[3]
      );
      t3 = space();
      p2 = element("p");
      create_component(apireveal.$$.fragment);
      attr(h1, "class", "svelte-1hdmb0y");
      attr(p2, "class", "hostname svelte-1hdmb0y");
      attr(div0, "class", "flex-stop");
      attr(div1, "class", "center-flex text-center");
    },
    m(target, anchor) {
      mount_component(closebutton, target, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(profilepicture, div0, null);
      append(div0, t1);
      append(div0, h1);
      append(h1, t2);
      append(div0, t3);
      append(div0, p2);
      mount_component(apireveal, p2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const closebutton_changes = {};
      if (dirty & /*id*/
      1)
        closebutton_changes.id = /*id*/
        ctx2[0];
      if (dirty & /*app*/
      2)
        closebutton_changes.app = /*app*/
        ctx2[1];
      closebutton.$set(closebutton_changes);
      const profilepicture_changes = {};
      if (dirty & /*$UserData*/
      4)
        profilepicture_changes.src = /*$UserData*/
        ctx2[2].acc.profilePicture.toString();
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*$UserName*/
      8)
        set_data(
          t2,
          /*$UserName*/
          ctx2[3]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(closebutton.$$.fragment, local);
      transition_in(profilepicture.$$.fragment, local);
      transition_in(apireveal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(closebutton.$$.fragment, local);
      transition_out(profilepicture.$$.fragment, local);
      transition_out(apireveal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div1);
      }
      destroy_component(closebutton, detaching);
      destroy_component(profilepicture);
      destroy_component(apireveal);
    }
  };
}
function instance$1y($$self, $$props, $$invalidate) {
  let $UserData;
  let $UserName;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(2, $UserData = $$value));
  component_subscribe($$self, UserName, ($$value) => $$invalidate(3, $UserName = $$value));
  let { id } = $$props;
  let { app } = $$props;
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
  };
  return [id, app, $UserData, $UserName];
}
class ProfilePictureView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1y, create_fragment$1E, safe_not_equal, { id: 0, app: 1 });
  }
}
const ProfilePictureOverlays = {
  pfpSel: {
    info: {
      name: "Profile Picture Selector",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: ProfilePicture,
    size: { w: 382, h: 410 },
    show: false
  },
  customPfp: {
    info: {
      name: "Custom Profile Picture",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: CustomProfilePicture,
    size: { w: 350, h: 125 },
    show: false
  },
  largePfp: {
    info: {
      name: "View Profile Picture",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: ProfilePictureView,
    size: { w: 320, h: 360 },
    show: false
  }
};
const savetheme = "";
function create_fragment$1D(ctx) {
  let div1;
  let h3;
  let t1;
  let p2;
  let t3;
  let input;
  let t4;
  let div0;
  let button0;
  let t5;
  let button0_disabled_value;
  let t6;
  let button1;
  let t8;
  let div2;
  let current;
  let current$1;
  let mounted;
  let dispose;
  current = new Current$1({});
  return {
    c() {
      div1 = element("div");
      h3 = element("h3");
      h3.textContent = "Save theme";
      t1 = space();
      p2 = element("p");
      p2.textContent = "Choose a name for your theme:";
      t3 = space();
      input = element("input");
      t4 = space();
      div0 = element("div");
      button0 = element("button");
      t5 = text("Save");
      t6 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      t8 = space();
      div2 = element("div");
      create_component(current.$$.fragment);
      attr(h3, "class", "header");
      attr(input, "type", "text");
      button0.disabled = button0_disabled_value = !/*name*/
      ctx[0];
      attr(div0, "class", "actions");
      attr(div1, "class", "form");
      attr(div2, "class", "desktop-page");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, h3);
      append(div1, t1);
      append(div1, p2);
      append(div1, t3);
      append(div1, input);
      set_input_value(
        input,
        /*name*/
        ctx[0]
      );
      append(div1, t4);
      append(div1, div0);
      append(div0, button0);
      append(button0, t5);
      append(div0, t6);
      append(div0, button1);
      insert(target, t8, anchor);
      insert(target, div2, anchor);
      mount_component(current, div2, null);
      current$1 = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[3]
          ),
          listen(
            button0,
            "click",
            /*save*/
            ctx[2]
          ),
          listen(
            button1,
            "click",
            /*closeThis*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*name*/
      1 && input.value !== /*name*/
      ctx2[0]) {
        set_input_value(
          input,
          /*name*/
          ctx2[0]
        );
      }
      if (!current$1 || dirty & /*name*/
      1 && button0_disabled_value !== (button0_disabled_value = !/*name*/
      ctx2[0])) {
        button0.disabled = button0_disabled_value;
      }
    },
    i(local) {
      if (current$1)
        return;
      transition_in(current.$$.fragment, local);
      current$1 = true;
    },
    o(local) {
      transition_out(current.$$.fragment, local);
      current$1 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t8);
        detach(div2);
      }
      destroy_component(current);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1x($$self, $$props, $$invalidate) {
  let name;
  function closeThis() {
    hideOverlay("saveTheme", "SettingsApp");
  }
  function save() {
    saveCurrentTheme(name);
    closeThis();
  }
  function input_input_handler() {
    name = this.value;
    $$invalidate(0, name);
  }
  return [name, closeThis, save, input_input_handler];
}
class SaveTheme extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1x, create_fragment$1D, safe_not_equal, {});
  }
}
const ThemeOverlays = {
  saveTheme: {
    info: {
      name: "Save Theme",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: SaveTheme,
    size: { w: 450, h: 170 },
    show: false
  }
};
const CustomAccentColor_svelte_svelte_type_style_lang = "";
function create_fragment$1C(ctx) {
  let div4;
  let div0;
  let t0;
  let div3;
  let p2;
  let t2;
  let div1;
  let span;
  let t4;
  let input0;
  let t5;
  let button0;
  let t6;
  let input1;
  let input1_value_value;
  let t7;
  let div2;
  let button1;
  let t9;
  let button2;
  let t10;
  let button2_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      div0.innerHTML = `<img src="${PersonalizationIcon}" alt="" class="svelte-6v0hq5"/>`;
      t0 = space();
      div3 = element("div");
      p2 = element("p");
      p2.textContent = "Enter a custom accent color:";
      t2 = space();
      div1 = element("div");
      span = element("span");
      span.textContent = "#";
      t4 = space();
      input0 = element("input");
      t5 = space();
      button0 = element("button");
      t6 = space();
      input1 = element("input");
      t7 = space();
      div2 = element("div");
      button1 = element("button");
      button1.textContent = "Cancel";
      t9 = space();
      button2 = element("button");
      t10 = text("Apply");
      attr(div0, "class", "left svelte-6v0hq5");
      attr(p2, "class", "svelte-6v0hq5");
      attr(span, "class", "svelte-6v0hq5");
      attr(input0, "type", "text");
      attr(input0, "class", "field svelte-6v0hq5");
      attr(input0, "maxlength", "6");
      attr(input0, "minlength", "3");
      attr(button0, "class", "color svelte-6v0hq5");
      set_style(button0, "background-color", "#" + /*hex*/
      ctx[0]);
      attr(input1, "type", "color");
      attr(input1, "class", "picker svelte-6v0hq5");
      input1.value = input1_value_value = "#" + /*hex*/
      ctx[0];
      attr(div1, "class", "hex-wrapper svelte-6v0hq5");
      attr(button1, "class", "svelte-6v0hq5");
      attr(button2, "class", "suggested svelte-6v0hq5");
      button2.disabled = button2_disabled_value = /*hex*/
      ctx[0].length !== 6;
      attr(div2, "class", "buttons svelte-6v0hq5");
      attr(div3, "class", "right svelte-6v0hq5");
      attr(div4, "class", "wrapper svelte-6v0hq5");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div4, t0);
      append(div4, div3);
      append(div3, p2);
      append(div3, t2);
      append(div3, div1);
      append(div1, span);
      append(div1, t4);
      append(div1, input0);
      set_input_value(
        input0,
        /*hex*/
        ctx[0]
      );
      append(div1, t5);
      append(div1, button0);
      append(div1, t6);
      append(div1, input1);
      ctx[7](input1);
      append(div3, t7);
      append(div3, div2);
      append(div2, button1);
      append(div2, t9);
      append(div2, button2);
      append(button2, t10);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[6]
          ),
          listen(
            button0,
            "click",
            /*openPicker*/
            ctx[4]
          ),
          listen(
            input1,
            "input",
            /*pickerInput*/
            ctx[5]
          ),
          listen(
            button1,
            "click",
            /*cancel*/
            ctx[2]
          ),
          listen(
            button2,
            "click",
            /*apply*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*hex*/
      1 && input0.value !== /*hex*/
      ctx2[0]) {
        set_input_value(
          input0,
          /*hex*/
          ctx2[0]
        );
      }
      if (dirty & /*hex*/
      1) {
        set_style(button0, "background-color", "#" + /*hex*/
        ctx2[0]);
      }
      if (dirty & /*hex*/
      1 && input1_value_value !== (input1_value_value = "#" + /*hex*/
      ctx2[0])) {
        input1.value = input1_value_value;
      }
      if (dirty & /*hex*/
      1 && button2_disabled_value !== (button2_disabled_value = /*hex*/
      ctx2[0].length !== 6)) {
        button2.disabled = button2_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1w($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(8, $UserData = $$value));
  let hex = "70D6FF";
  let picker;
  function cancel() {
    hideOverlay("customAccentColor", "SettingsApp");
  }
  function apply() {
    set_store_value(UserData$2, $UserData.sh.desktop.accent = hex, $UserData);
    cancel();
  }
  function openPicker() {
    picker.click();
  }
  UserData$2.subscribe((v2) => {
    if (v2.sh.desktop.accent !== hex)
      $$invalidate(0, hex = v2.sh.desktop.accent);
  });
  function pickerInput() {
    $$invalidate(0, hex = picker.value.replace("#", "").toUpperCase());
  }
  function input0_input_handler() {
    hex = this.value;
    $$invalidate(0, hex);
  }
  function input1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      picker = $$value;
      $$invalidate(1, picker);
    });
  }
  return [
    hex,
    picker,
    cancel,
    apply,
    openPicker,
    pickerInput,
    input0_input_handler,
    input1_binding
  ];
}
class CustomAccentColor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1w, create_fragment$1C, safe_not_equal, {});
  }
}
const VisualsOverlays = {
  customAccentColor: {
    info: {
      name: "Custom Accent Color",
      version: "1.0.0",
      author: "ArcOS Team"
    },
    content: CustomAccentColor,
    size: { w: 450, h: 170 },
    show: false
  }
};
const SettingsApp2 = {
  info: {
    name: "System Settings",
    description: "Change the way ArcOS works",
    builtin: true,
    version: "4.0.0",
    author: "ArcOS Team",
    icon: SettingsIcon,
    appGroup: "systemTools"
  },
  size: { w: 730, h: 500 },
  pos: { x: 30, y: 40 },
  minSize: { w: 730, h: 500 },
  maxSize: { w: 1100, h: 600 },
  controls: { min: true, max: true, cls: true },
  state: {
    headless: false,
    resizable: true,
    windowState: { min: false, max: false, fll: false }
  },
  content: SettingsApp$1,
  glass: true,
  overlays: {
    ...AccountPageOverlays,
    ...VisualsOverlays,
    ...DesktopOverlays,
    ...LockScreenOverlays,
    ...ProfilePictureOverlays,
    ...ThemeOverlays
  },
  events: {
    close() {
      currentSettingsPage.set(SettingsPages[0]);
    },
    open() {
      currentSettingsPage.set(SettingsPages[0]);
    }
  },
  contextMenu: SettingsAppContext
};
const actioncenter = "";
function get_each_context$m(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function create_else_block$h(ctx) {
  let span;
  let t_value = (
    /*notification*/
    ctx[0][1].icon + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "material-icons-round");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*notification*/
      1 && t_value !== (t_value = /*notification*/
      ctx2[0][1].icon + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block$N(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*notification*/
      ctx[0][1].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*notification*/
      ctx[0][1].title);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*notification*/
      1 && !src_url_equal(img.src, img_src_value = /*notification*/
      ctx2[0][1].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*notification*/
      1 && img_alt_value !== (img_alt_value = /*notification*/
      ctx2[0][1].title)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_each_block$m(ctx) {
  let button_1;
  let t_value = (
    /*button*/
    ctx[3].caption + ""
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button_1 = element("button");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, button_1, anchor);
      append(button_1, t2);
      if (!mounted) {
        dispose = listen(button_1, "click", function() {
          if (is_function(
            /*buttonEvent*/
            ctx[2](
              /*button*/
              ctx[3].action
            )
          ))
            ctx[2](
              /*button*/
              ctx[3].action
            ).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*notification*/
      1 && t_value !== (t_value = /*button*/
      ctx[3].caption + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(button_1);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1B(ctx) {
  let div2;
  let p0;
  let t0;
  let t1_value = (
    /*notification*/
    ctx[0][1].title + ""
  );
  let t1;
  let t2;
  let button_1;
  let t4;
  let p1;
  let raw_value = (
    /*notification*/
    ctx[0][1].message + ""
  );
  let t5;
  let div1;
  let div0;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*notification*/
      ctx2[0][1].image
    )
      return create_if_block$N;
    return create_else_block$h;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  let each_value = ensure_array_like(
    /*notification*/
    ctx[0][1].buttons
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$m(get_each_context$m(ctx, each_value, i2));
  }
  return {
    c() {
      div2 = element("div");
      p0 = element("p");
      if_block.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      button_1 = element("button");
      button_1.textContent = "close";
      t4 = space();
      p1 = element("p");
      t5 = space();
      div1 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(button_1, "class", "close material-icons-round");
      attr(p0, "class", "title");
      attr(p1, "class", "content");
      attr(div0, "class", "inner");
      attr(div1, "class", "buttons");
      attr(div2, "class", "notification ac");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, p0);
      if_block.m(p0, null);
      append(p0, t0);
      append(p0, t1);
      append(p0, t2);
      append(p0, button_1);
      append(div2, t4);
      append(div2, p1);
      p1.innerHTML = raw_value;
      append(div2, t5);
      append(div2, div1);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      if (!mounted) {
        dispose = listen(
          button_1,
          "click",
          /*close*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(p0, t0);
        }
      }
      if (dirty & /*notification*/
      1 && t1_value !== (t1_value = /*notification*/
      ctx2[0][1].title + ""))
        set_data(t1, t1_value);
      if (dirty & /*notification*/
      1 && raw_value !== (raw_value = /*notification*/
      ctx2[0][1].message + ""))
        p1.innerHTML = raw_value;
      if (dirty & /*buttonEvent, notification*/
      5) {
        each_value = ensure_array_like(
          /*notification*/
          ctx2[0][1].buttons
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$m(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$m(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div0, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$1v($$self, $$props, $$invalidate) {
  let { notification: notification2 } = $$props;
  function close() {
    deleteNotification(notification2[0]);
    CurrentNotification.set(null);
  }
  function buttonEvent(e2) {
    return () => {
      e2();
      close();
      ActionCenterOpened.set(false);
    };
  }
  $$self.$$set = ($$props2) => {
    if ("notification" in $$props2)
      $$invalidate(0, notification2 = $$props2.notification);
  };
  return [notification2, close, buttonEvent];
}
class Notification extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1v, create_fragment$1B, safe_not_equal, { notification: 0 });
  }
}
function get_each_context$l(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2];
  return child_ctx;
}
function create_each_block$l(ctx) {
  let notification_1;
  let current;
  notification_1 = new Notification({
    props: { notification: (
      /*notification*/
      ctx[1]
    ) }
  });
  return {
    c() {
      create_component(notification_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notification_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notification_1_changes = {};
      if (dirty & /*$NotificationStore*/
      1)
        notification_1_changes.notification = /*notification*/
        ctx2[1];
      notification_1.$set(notification_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(notification_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notification_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notification_1, detaching);
    }
  };
}
function create_if_block$M(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "You have no notifications";
      attr(p2, "class", "none");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_fragment$1A(ctx) {
  let div;
  let t2;
  let show_if = Object.entries(
    /*$NotificationStore*/
    ctx[0]
  ).length == 0;
  let current;
  let each_value = ensure_array_like(Object.entries(
    /*$NotificationStore*/
    ctx[0]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$l(get_each_context$l(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = show_if && create_if_block$M();
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "notifications");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      append(div, t2);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Object, $NotificationStore*/
      1) {
        each_value = ensure_array_like(Object.entries(
          /*$NotificationStore*/
          ctx2[0]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$l(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$l(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, t2);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (dirty & /*$NotificationStore*/
      1)
        show_if = Object.entries(
          /*$NotificationStore*/
          ctx2[0]
        ).length == 0;
      if (show_if) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$M();
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$1u($$self, $$props, $$invalidate) {
  let $NotificationStore;
  component_subscribe($$self, NotificationStore, ($$value) => $$invalidate(0, $NotificationStore = $$value));
  return [$NotificationStore];
}
class Notifications extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1u, create_fragment$1A, safe_not_equal, {});
  }
}
const QuickSettings = [
  {
    icon: "motion_photos_on",
    iconOff: "motion_photos_off",
    getter(udata) {
      return udata.sh.anim;
    },
    setter(udata) {
      udata.sh.anim = !udata.sh.anim;
      UserData$2.set(udata);
      return udata.sh.anim;
    },
    caption: "Animations"
  },
  {
    icon: "blur_on",
    iconOff: "blur_off",
    getter(udata) {
      return !udata.sh.noGlass;
    },
    setter(udata) {
      udata.sh.noGlass = !udata.sh.noGlass;
      UserData$2.set(udata);
      return !udata.sh.noGlass;
    },
    caption: "Transparency"
  },
  {
    icon: "call_to_action",
    iconOff: "call_to_action",
    getter(udata) {
      return udata.sh.taskbar.docked;
    },
    setter(udata) {
      udata.sh.taskbar.docked = !udata.sh.taskbar.docked;
      UserData$2.set(udata);
      return udata.sh.taskbar.docked;
    },
    caption: "Dock Taskbar"
  },
  {
    icon: "dark_mode",
    iconOff: "light_mode",
    getter(udata) {
      return udata.sh.desktop.theme == "dark";
    },
    setter(udata) {
      const current = udata.sh.desktop.theme;
      udata.sh.desktop.theme = current == "dark" ? "light" : "dark";
      UserData$2.set(udata);
      return udata.sh.desktop.theme == "dark";
    },
    caption: "Dark mode"
  },
  {
    icon: "invert_colors",
    iconOff: "invert_colors_off",
    getter(udata) {
      return udata.sh.taskbar.colored;
    },
    setter(udata) {
      udata.sh.taskbar.colored = !udata.sh.taskbar.colored;
      UserData$2.set(udata);
      return udata.sh.taskbar.colored;
    },
    caption: "Colored Shell"
  },
  {
    icon: "settings",
    iconOff: "settings",
    getter() {
      return false;
    },
    setter() {
      openWindow("SettingsApp");
      ActionCenterOpened.set(false);
      return false;
    },
    caption: "Settings"
  },
  {
    icon: "rocket_launch",
    iconOff: "rocket",
    getter(udata) {
      return udata.sh.taskbar.isLauncher;
    },
    setter(udata) {
      udata.sh.taskbar.isLauncher = !udata.sh.taskbar.isLauncher;
      UserData$2.set(udata);
      return udata.sh.taskbar.isLauncher;
    },
    caption: "Launcher"
  },
  {
    icon: "search",
    iconOff: "search",
    getter() {
      return false;
    },
    setter() {
      showArcFind.set(true);
      return false;
    },
    caption: "Search"
  },
  {
    icon: "logout",
    iconOff: "logout",
    getter() {
      return false;
    },
    setter() {
      openWindow("Exit");
      return false;
    },
    caption: "Exit"
  }
];
function create_fragment$1z(ctx) {
  let button;
  let span;
  let t0_value = (
    /*active*/
    (ctx[1] ? (
      /*setting*/
      ctx[0].icon
    ) : (
      /*setting*/
      ctx[0].iconOff
    )) + ""
  );
  let t0;
  let t1;
  let p2;
  let t2_value = (
    /*setting*/
    ctx[0].caption + ""
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      p2 = element("p");
      t2 = text(t2_value);
      attr(span, "class", "material-icons-round");
      attr(p2, "class", "caption");
      attr(button, "class", "setting");
      toggle_class(
        button,
        "active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      append(span, t0);
      append(button, t1);
      append(button, p2);
      append(p2, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*active, setting*/
      3 && t0_value !== (t0_value = /*active*/
      (ctx2[1] ? (
        /*setting*/
        ctx2[0].icon
      ) : (
        /*setting*/
        ctx2[0].iconOff
      )) + ""))
        set_data(t0, t0_value);
      if (dirty & /*setting*/
      1 && t2_value !== (t2_value = /*setting*/
      ctx2[0].caption + ""))
        set_data(t2, t2_value);
      if (dirty & /*active*/
      2) {
        toggle_class(
          button,
          "active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$1t($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(3, $UserData = $$value));
  let active2 = false;
  let { setting } = $$props;
  function click2() {
    setting.setter($UserData);
    $$invalidate(1, active2 = setting.getter($UserData));
  }
  onMount(() => {
    $$invalidate(1, active2 = setting.getter($UserData));
  });
  UserData$2.subscribe((v2) => {
    $$invalidate(1, active2 = setting.getter(v2));
  });
  $$self.$$set = ($$props2) => {
    if ("setting" in $$props2)
      $$invalidate(0, setting = $$props2.setting);
  };
  return [setting, active2, click2];
}
class Setting extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1t, create_fragment$1z, safe_not_equal, { setting: 0 });
  }
}
function get_each_context$k(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list2[i2];
  return child_ctx;
}
function create_each_block$k(ctx) {
  let setting_1;
  let current;
  setting_1 = new Setting({ props: { setting: (
    /*setting*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(setting_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(setting_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(setting_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(setting_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(setting_1, detaching);
    }
  };
}
function create_fragment$1y(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(QuickSettings);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$k(get_each_context$k(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "quicksettings");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
class QuickSettings_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1y, safe_not_equal, {});
  }
}
function create_fragment$1x(ctx) {
  let div;
  let button;
  let t_value = (
    /*$UserData*/
    ctx[0].sh.noQuickSettings ? "Expand" : "Collapse"
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      t2 = text(t_value);
      attr(button, "class", "toggle");
      attr(div, "class", "quicksettings-toggle");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggleQuicks*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$UserData*/
      1 && t_value !== (t_value = /*$UserData*/
      ctx2[0].sh.noQuickSettings ? "Expand" : "Collapse"))
        set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$1s($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(0, $UserData = $$value));
  function toggleQuicks() {
    set_store_value(UserData$2, $UserData.sh.noQuickSettings = !$UserData.sh.noQuickSettings, $UserData);
  }
  return [$UserData, toggleQuicks];
}
class QuickSettingsToggle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1s, create_fragment$1x, safe_not_equal, {});
  }
}
function create_fragment$1w(ctx) {
  let div;
  let h3;
  let t0;
  let button;
  let t1;
  let button_disabled_value;
  let t2;
  let notifications;
  let t3;
  let quicksettingstoggle;
  let t4;
  let quicksettings;
  let current;
  let mounted;
  let dispose;
  notifications = new Notifications({});
  quicksettingstoggle = new QuickSettingsToggle({});
  quicksettings = new QuickSettings_1({});
  return {
    c() {
      div = element("div");
      h3 = element("h3");
      t0 = text("Notifications ");
      button = element("button");
      t1 = text("Clear");
      t2 = space();
      create_component(notifications.$$.fragment);
      t3 = space();
      create_component(quicksettingstoggle.$$.fragment);
      t4 = space();
      create_component(quicksettings.$$.fragment);
      attr(button, "class", "clear");
      button.disabled = button_disabled_value = !Object.entries(
        /*$NotificationStore*/
        ctx[3]
      ).length;
      attr(h3, "class", "title");
      attr(div, "class", "actioncenter shell-colored");
      set_style(
        div,
        "z-index",
        /*$maxZIndex*/
        ctx[2] + 4
      );
      toggle_class(
        div,
        "docked",
        /*$UserData*/
        ctx[1].sh.taskbar.docked
      );
      toggle_class(
        div,
        "launcher",
        /*$UserData*/
        ctx[1].sh.taskbar.isLauncher
      );
      toggle_class(
        div,
        "opened",
        /*opened*/
        ctx[0]
      );
      toggle_class(
        div,
        "noquick",
        /*$UserData*/
        ctx[1].sh.noQuickSettings
      );
      toggle_class(
        div,
        "colored",
        /*$UserData*/
        ctx[1].sh.taskbar.colored
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h3);
      append(h3, t0);
      append(h3, button);
      append(button, t1);
      append(div, t2);
      mount_component(notifications, div, null);
      append(div, t3);
      mount_component(quicksettingstoggle, div, null);
      append(div, t4);
      mount_component(quicksettings, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*clear*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$NotificationStore*/
      8 && button_disabled_value !== (button_disabled_value = !Object.entries(
        /*$NotificationStore*/
        ctx2[3]
      ).length)) {
        button.disabled = button_disabled_value;
      }
      if (!current || dirty & /*$maxZIndex*/
      4) {
        set_style(
          div,
          "z-index",
          /*$maxZIndex*/
          ctx2[2] + 4
        );
      }
      if (!current || dirty & /*$UserData*/
      2) {
        toggle_class(
          div,
          "docked",
          /*$UserData*/
          ctx2[1].sh.taskbar.docked
        );
      }
      if (!current || dirty & /*$UserData*/
      2) {
        toggle_class(
          div,
          "launcher",
          /*$UserData*/
          ctx2[1].sh.taskbar.isLauncher
        );
      }
      if (!current || dirty & /*opened*/
      1) {
        toggle_class(
          div,
          "opened",
          /*opened*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$UserData*/
      2) {
        toggle_class(
          div,
          "noquick",
          /*$UserData*/
          ctx2[1].sh.noQuickSettings
        );
      }
      if (!current || dirty & /*$UserData*/
      2) {
        toggle_class(
          div,
          "colored",
          /*$UserData*/
          ctx2[1].sh.taskbar.colored
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(notifications.$$.fragment, local);
      transition_in(quicksettingstoggle.$$.fragment, local);
      transition_in(quicksettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notifications.$$.fragment, local);
      transition_out(quicksettingstoggle.$$.fragment, local);
      transition_out(quicksettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(notifications);
      destroy_component(quicksettingstoggle);
      destroy_component(quicksettings);
      mounted = false;
      dispose();
    }
  };
}
function instance$1r($$self, $$props, $$invalidate) {
  let $UserData;
  let $maxZIndex;
  let $NotificationStore;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(1, $UserData = $$value));
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(2, $maxZIndex = $$value));
  component_subscribe($$self, NotificationStore, ($$value) => $$invalidate(3, $NotificationStore = $$value));
  let opened = false;
  ActionCenterOpened.subscribe((v2) => $$invalidate(0, opened = v2));
  function clear2() {
    NotificationStore.set({});
    CurrentNotification.set(null);
  }
  return [opened, $UserData, $maxZIndex, $NotificationStore, clear2];
}
class ActionCenter extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1r, create_fragment$1w, safe_not_equal, {});
  }
}
function get_each_context$j(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list2[i2];
  return child_ctx;
}
function create_if_block$L(ctx) {
  let p0;
  let t0;
  let t1_value = (
    /*data*/
    ctx[0].title + ""
  );
  let t1;
  let t2;
  let button;
  let t4;
  let p1;
  let raw_value = (
    /*data*/
    ctx[0].message + ""
  );
  let t5;
  let div;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*data*/
      ctx2[0].image
    )
      return create_if_block_1$c;
    return create_else_block$g;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  let each_value = ensure_array_like(
    /*data*/
    ctx[0].buttons
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$j(get_each_context$j(ctx, each_value, i2));
  }
  return {
    c() {
      p0 = element("p");
      if_block.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      button = element("button");
      button.textContent = "close";
      t4 = space();
      p1 = element("p");
      t5 = space();
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(button, "class", "close material-icons-round");
      attr(p0, "class", "title");
      attr(p1, "class", "message");
      attr(div, "class", "buttons");
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      if_block.m(p0, null);
      append(p0, t0);
      append(p0, t1);
      append(p0, t2);
      append(p0, button);
      insert(target, t4, anchor);
      insert(target, p1, anchor);
      p1.innerHTML = raw_value;
      insert(target, t5, anchor);
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*close*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(p0, t0);
        }
      }
      if (dirty & /*data*/
      1 && t1_value !== (t1_value = /*data*/
      ctx2[0].title + ""))
        set_data(t1, t1_value);
      if (dirty & /*data*/
      1 && raw_value !== (raw_value = /*data*/
      ctx2[0].message + ""))
        p1.innerHTML = raw_value;
      if (dirty & /*buttonEvent, data*/
      33) {
        each_value = ensure_array_like(
          /*data*/
          ctx2[0].buttons
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$j(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$j(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(p0);
        detach(t4);
        detach(p1);
        detach(t5);
        detach(div);
      }
      if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$g(ctx) {
  let span;
  let t_value = (
    /*data*/
    ctx[0].icon + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "material-icons-round");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && t_value !== (t_value = /*data*/
      ctx2[0].icon + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1$c(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*data*/
      ctx[0].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*data*/
      ctx[0].title);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && !src_url_equal(img.src, img_src_value = /*data*/
      ctx2[0].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*data*/
      1 && img_alt_value !== (img_alt_value = /*data*/
      ctx2[0].title)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_each_block$j(ctx) {
  let button;
  let t_value = (
    /*btn*/
    ctx[8].caption + ""
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*buttonEvent*/
            ctx[5](
              /*btn*/
              ctx[8].action
            )
          ))
            ctx[5](
              /*btn*/
              ctx[8].action
            ).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*data*/
      1 && t_value !== (t_value = /*btn*/
      ctx[8].caption + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1v(ctx) {
  let div;
  let if_block = (
    /*data*/
    ctx[0] && create_if_block$L(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "notification shell-colored");
      set_style(
        div,
        "z-index",
        /*$maxZIndex*/
        ctx[3] + 4
      );
      toggle_class(div, "hidden", !/*data*/
      ctx[0] || /*hide*/
      ctx[1]);
      toggle_class(
        div,
        "colored",
        /*$UserData*/
        ctx[2].sh.taskbar.colored
      );
      toggle_class(
        div,
        "nobutt",
        /*data*/
        ctx[0] && !/*data*/
        ctx[0].buttons.length
      );
      toggle_class(
        div,
        "launcher",
        /*$UserData*/
        ctx[2].sh.taskbar.isLauncher
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (
        /*data*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$L(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*$maxZIndex*/
      8) {
        set_style(
          div,
          "z-index",
          /*$maxZIndex*/
          ctx2[3] + 4
        );
      }
      if (dirty & /*data, hide*/
      3) {
        toggle_class(div, "hidden", !/*data*/
        ctx2[0] || /*hide*/
        ctx2[1]);
      }
      if (dirty & /*$UserData*/
      4) {
        toggle_class(
          div,
          "colored",
          /*$UserData*/
          ctx2[2].sh.taskbar.colored
        );
      }
      if (dirty & /*data*/
      1) {
        toggle_class(
          div,
          "nobutt",
          /*data*/
          ctx2[0] && !/*data*/
          ctx2[0].buttons.length
        );
      }
      if (dirty & /*$UserData*/
      4) {
        toggle_class(
          div,
          "launcher",
          /*$UserData*/
          ctx2[2].sh.taskbar.isLauncher
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$1q($$self, $$props, $$invalidate) {
  let $NotificationStore;
  let $UserData;
  let $maxZIndex;
  component_subscribe($$self, NotificationStore, ($$value) => $$invalidate(7, $NotificationStore = $$value));
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(2, $UserData = $$value));
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(3, $maxZIndex = $$value));
  let data = null;
  let hide = false;
  let id;
  CurrentNotification.subscribe((v2) => {
    if (v2) {
      $$invalidate(1, hide = true);
      $$invalidate(0, data = null);
      id = v2;
      setTimeout(
        () => {
          ArcSoundBus.playSound("arcos.notification");
          $$invalidate(1, hide = false);
          $$invalidate(0, data = $NotificationStore[v2]);
        },
        250
      );
      return;
    }
    $$invalidate(1, hide = true);
    setTimeout(
      () => {
        $$invalidate(0, data = null);
      },
      300
    );
  });
  function close() {
    closeNotification();
  }
  function buttonEvent(e2) {
    return () => {
      e2();
      close();
      deleteNotification(id);
    };
  }
  return [data, hide, $UserData, $maxZIndex, close, buttonEvent];
}
class PushNotification extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1q, create_fragment$1v, safe_not_equal, {});
  }
}
function getWindowElement(app) {
  const el = document.querySelector(`window#${app.id}`);
  return el;
}
function getWindowElementByEvent(e2) {
  const path = e2.composedPath();
  for (let i2 = 0; i2 < path.length; i2++) {
    const tagName = path[i2].tagName;
    if (!tagName)
      continue;
    if (tagName.toLowerCase() == "window")
      return path[i2];
  }
}
function create_if_block$K(ctx) {
  let span;
  let t_value = (
    /*app*/
    ctx[0].info.name + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*app*/
      1 && t_value !== (t_value = /*app*/
      ctx2[0].info.name + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$1u(ctx) {
  let button;
  let img;
  let img_src_value;
  let img_alt_value;
  let t2;
  let mounted;
  let dispose;
  let if_block = (
    /*showLabel*/
    ctx[1] && create_if_block$K(ctx)
  );
  return {
    c() {
      button = element("button");
      img = element("img");
      t2 = space();
      if (if_block)
        if_block.c();
      if (!src_url_equal(img.src, img_src_value = getOriginalIcon(
        /*app*/
        ctx[0].id
      ) || getAppIcon(
        /*app*/
        ctx[0]
      )))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*app*/
      ctx[0].info.name);
      attr(img, "class", "icon");
      attr(button, "class", "appbutton");
      toggle_class(
        button,
        "minimized",
        /*minimized*/
        ctx[2]
      );
      toggle_class(
        button,
        "attention",
        /*$attentionId*/
        ctx[4] == /*app*/
        ctx[0].id
      );
      toggle_class(
        button,
        "activated",
        /*app*/
        ctx[0].id == /*$focusedWindowId*/
        ctx[3]
      );
      toggle_class(
        button,
        "labels",
        /*showLabel*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t2);
      if (if_block)
        if_block.m(button, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*e*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*app*/
      1 && !src_url_equal(img.src, img_src_value = getOriginalIcon(
        /*app*/
        ctx2[0].id
      ) || getAppIcon(
        /*app*/
        ctx2[0]
      ))) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*app*/
      1 && img_alt_value !== (img_alt_value = /*app*/
      ctx2[0].info.name)) {
        attr(img, "alt", img_alt_value);
      }
      if (
        /*showLabel*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$K(ctx2);
          if_block.c();
          if_block.m(button, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*minimized*/
      4) {
        toggle_class(
          button,
          "minimized",
          /*minimized*/
          ctx2[2]
        );
      }
      if (dirty & /*$attentionId, app*/
      17) {
        toggle_class(
          button,
          "attention",
          /*$attentionId*/
          ctx2[4] == /*app*/
          ctx2[0].id
        );
      }
      if (dirty & /*app, $focusedWindowId*/
      9) {
        toggle_class(
          button,
          "activated",
          /*app*/
          ctx2[0].id == /*$focusedWindowId*/
          ctx2[3]
        );
      }
      if (dirty & /*showLabel*/
      2) {
        toggle_class(
          button,
          "labels",
          /*showLabel*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$1p($$self, $$props, $$invalidate) {
  let $maxZIndex;
  let $focusedWindowId;
  let $ActionCenterOpened;
  let $startOpened;
  let $attentionId;
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(6, $maxZIndex = $$value));
  component_subscribe($$self, focusedWindowId, ($$value) => $$invalidate(3, $focusedWindowId = $$value));
  component_subscribe($$self, ActionCenterOpened, ($$value) => $$invalidate(7, $ActionCenterOpened = $$value));
  component_subscribe($$self, startOpened, ($$value) => $$invalidate(8, $startOpened = $$value));
  component_subscribe($$self, attentionId, ($$value) => $$invalidate(4, $attentionId = $$value));
  let { app } = $$props;
  let showLabel = false;
  let minimized = false;
  UserData$2.subscribe((v2) => {
    $$invalidate(1, showLabel = v2.sh.taskbar.labels);
  });
  focusedWindowId.subscribe((v2) => {
    if ($attentionId == v2 && app.id == $attentionId)
      set_store_value(attentionId, $attentionId = null, $attentionId);
  });
  WindowStore.subscribe(() => {
    $$invalidate(2, minimized = isMinimized(app.id));
  });
  function e2() {
    set_store_value(startOpened, $startOpened = false, $startOpened);
    set_store_value(ActionCenterOpened, $ActionCenterOpened = false, $ActionCenterOpened);
    if ($focusedWindowId == app.id)
      $$invalidate(0, app.state.windowState.min = !app.state.windowState.min, app);
    else
      $$invalidate(0, app.state.windowState.min = false, app);
    updateStores();
    set_store_value(maxZIndex, $maxZIndex++, $maxZIndex);
    set_store_value(focusedWindowId, $focusedWindowId = app.id, $focusedWindowId);
    const window2 = getWindowElement(app);
    window2.style.zIndex = $maxZIndex.toString();
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [app, showLabel, minimized, $focusedWindowId, $attentionId, e2];
}
class TaskbarButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1p, create_fragment$1u, safe_not_equal, { app: 0 });
  }
}
function create_fragment$1t(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "notifications";
      attr(button, "class", "material-icons-round ac-open");
      toggle_class(
        button,
        "opened",
        /*$ActionCenterOpened*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", toggleActionCenter);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$ActionCenterOpened*/
      1) {
        toggle_class(
          button,
          "opened",
          /*$ActionCenterOpened*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$1o($$self, $$props, $$invalidate) {
  let $ActionCenterOpened;
  component_subscribe($$self, ActionCenterOpened, ($$value) => $$invalidate(0, $ActionCenterOpened = $$value));
  return [$ActionCenterOpened];
}
class ActionCenterbutton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1o, create_fragment$1t, safe_not_equal, {});
  }
}
function create_if_block$J(ctx) {
  let div;
  let t2;
  return {
    c() {
      div = element("div");
      t2 = text(
        /*text*/
        ctx[1]
      );
      attr(div, "class", "clock");
      attr(div, "data-contextmenu", "clockcontext");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*text*/
      2)
        set_data(
          t2,
          /*text*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$1s(ctx) {
  let if_block_anchor;
  let if_block = (
    /*hasClock*/
    ctx[0] && create_if_block$J(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*hasClock*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$J(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1n($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(2, $UserData = $$value));
  let { hasClock } = $$props;
  let text2 = "";
  onMount(() => {
    setInterval(
      () => {
        const tb = $UserData.sh.taskbar;
        const secs = tb.clockSecs && !tb.pos ? ":ss" : "";
        const date = tb.clockDate && !tb.pos ? "MMM D, " : "";
        const time = tb.clock12hr && !tb.pos ? `hh:mm${secs} A` : `HH:mm${secs}`;
        $$invalidate(1, text2 = dayjs().format(`${date}${time}`));
      },
      500
    );
  });
  $$self.$$set = ($$props2) => {
    if ("hasClock" in $$props2)
      $$invalidate(0, hasClock = $$props2.hasClock);
  };
  return [hasClock, text2];
}
let Clock$2 = class Clock extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1n, create_fragment$1s, safe_not_equal, { hasClock: 0 });
  }
};
function create_fragment$1r(ctx) {
  let button;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<img src="${UploadIcon}" alt="Committing"/>`;
      attr(button, "class", "icon committer");
      toggle_class(button, "inactive", !/*$committingUserData*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$committingUserData*/
      1) {
        toggle_class(button, "inactive", !/*$committingUserData*/
        ctx2[0]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
    }
  };
}
function instance$1m($$self, $$props, $$invalidate) {
  let $committingUserData;
  component_subscribe($$self, committingUserData, ($$value) => $$invalidate(0, $committingUserData = $$value));
  return [$committingUserData];
}
class Committer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1m, create_fragment$1r, safe_not_equal, {});
  }
}
function get_each_context$i(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2];
  return child_ctx;
}
function create_else_block$f(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*icon*/
      ctx[2].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*icon*/
      ctx[2].identifier);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$trayIcons*/
      1 && !src_url_equal(img.src, img_src_value = /*icon*/
      ctx2[2].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*$trayIcons*/
      1 && img_alt_value !== (img_alt_value = /*icon*/
      ctx2[2].identifier)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_if_block$I(ctx) {
  let span;
  let t_value = (
    /*icon*/
    ctx[2].icon + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "material-icons-round");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$trayIcons*/
      1 && t_value !== (t_value = /*icon*/
      ctx2[2].icon + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block$i(ctx) {
  let button;
  let t2;
  let button_title_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*icon*/
      ctx2[2].icon
    )
      return create_if_block$I;
    return create_else_block$f;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  function click_handler() {
    return (
      /*click_handler*/
      ctx[1](
        /*icon*/
        ctx[2]
      )
    );
  }
  return {
    c() {
      button = element("button");
      if_block.c();
      t2 = space();
      attr(button, "class", "icon");
      attr(button, "title", button_title_value = /*icon*/
      ctx[2].title || "");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_block.m(button, null);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(button, t2);
        }
      }
      if (dirty & /*$trayIcons*/
      1 && button_title_value !== (button_title_value = /*icon*/
      ctx[2].title || "")) {
        attr(button, "title", button_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1q(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*$trayIcons*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$i(get_each_context$i(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$trayIcons*/
      1) {
        each_value = ensure_array_like(
          /*$trayIcons*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$i(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$i(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$1l($$self, $$props, $$invalidate) {
  let $trayIcons;
  component_subscribe($$self, trayIcons, ($$value) => $$invalidate(0, $trayIcons = $$value));
  const click_handler = (icon2) => icon2.onOpen(icon2);
  return [$trayIcons, click_handler];
}
class Icons extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1l, create_fragment$1q, safe_not_equal, {});
  }
}
function create_fragment$1p(ctx) {
  let div;
  let icons;
  let t0;
  let committer;
  let t1;
  let clock;
  let t2;
  let actioncenterbutton;
  let t3;
  let current;
  icons = new Icons({});
  committer = new Committer({});
  clock = new Clock$2({ props: { hasClock: (
    /*hasClock*/
    ctx[0]
  ) } });
  actioncenterbutton = new ActionCenterbutton({});
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div = element("div");
      create_component(icons.$$.fragment);
      t0 = space();
      create_component(committer.$$.fragment);
      t1 = space();
      create_component(clock.$$.fragment);
      t2 = space();
      create_component(actioncenterbutton.$$.fragment);
      t3 = space();
      if (default_slot)
        default_slot.c();
      attr(div, "class", "tray");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(icons, div, null);
      append(div, t0);
      mount_component(committer, div, null);
      append(div, t1);
      mount_component(clock, div, null);
      append(div, t2);
      mount_component(actioncenterbutton, div, null);
      append(div, t3);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const clock_changes = {};
      if (dirty & /*hasClock*/
      1)
        clock_changes.hasClock = /*hasClock*/
        ctx2[0];
      clock.$set(clock_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icons.$$.fragment, local);
      transition_in(committer.$$.fragment, local);
      transition_in(clock.$$.fragment, local);
      transition_in(actioncenterbutton.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icons.$$.fragment, local);
      transition_out(committer.$$.fragment, local);
      transition_out(clock.$$.fragment, local);
      transition_out(actioncenterbutton.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(icons);
      destroy_component(committer);
      destroy_component(clock);
      destroy_component(actioncenterbutton);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$1k($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { hasClock = true } = $$props;
  $$self.$$set = ($$props2) => {
    if ("hasClock" in $$props2)
      $$invalidate(0, hasClock = $$props2.hasClock);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [hasClock, $$scope, slots];
}
class Tray extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1k, create_fragment$1p, safe_not_equal, { hasClock: 0 });
  }
}
const TaskbarContent_svelte_svelte_type_style_lang = "";
function get_each_context$h(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2];
  return child_ctx;
}
function create_if_block_1$b(ctx) {
  let taskbarbutton;
  let current;
  taskbarbutton = new TaskbarButton({ props: { app: (
    /*app*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(taskbarbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(taskbarbutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const taskbarbutton_changes = {};
      if (dirty & /*oa*/
      2)
        taskbarbutton_changes.app = /*app*/
        ctx2[2];
      taskbarbutton.$set(taskbarbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(taskbarbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taskbarbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(taskbarbutton, detaching);
    }
  };
}
function create_each_block$h(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*app*/
  ctx[2].disabled && create_if_block_1$b(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*app*/
      ctx2[2].disabled) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*oa*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$b(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_else_block$e(ctx) {
  let div;
  let spinner2;
  let current;
  spinner2 = new Spinner({ props: { height: 24 } });
  return {
    c() {
      div = element("div");
      create_component(spinner2.$$.fragment);
      attr(div, "class", "tray svelte-1vsr6ui");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(spinner2, div, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(spinner2);
    }
  };
}
function create_if_block$H(ctx) {
  let tray;
  let current;
  tray = new Tray({});
  return {
    c() {
      create_component(tray.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tray, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(tray.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tray.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tray, detaching);
    }
  };
}
function create_fragment$1o(ctx) {
  let div;
  let t2;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  let each_value = ensure_array_like(
    /*oa*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$h(get_each_context$h(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  const if_block_creators = [create_if_block$H, create_else_block$e];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*show*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if_block.c();
      if_block_anchor = empty();
      attr(div, "class", "buttons");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      insert(target, t2, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*oa*/
      2) {
        each_value = ensure_array_like(
          /*oa*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$h(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$h(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_each(each_blocks, detaching);
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$1j($$self, $$props, $$invalidate) {
  let show = false;
  let oa2 = [];
  WindowStore.subscribe(() => {
    $$invalidate(1, oa2 = getOpenedStore());
  });
  onMount(() => {
    $$invalidate(0, show = false);
    setTimeout(
      () => {
        $$invalidate(0, show = true);
      },
      3e3
    );
  });
  return [show, oa2];
}
class TaskbarContent extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1j, create_fragment$1o, safe_not_equal, {});
  }
}
function create_fragment$1n(ctx) {
  let div;
  let t2;
  let taskbarcontent;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  taskbarcontent = new TaskbarContent({});
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t2 = space();
      create_component(taskbarcontent.$$.fragment);
      attr(div, "class", "taskbar-h newtb shell-colored");
      set_style(
        div,
        "z-index",
        /*$maxZIndex*/
        ctx[0] + 5
      );
      attr(div, "data-contextmenu", "shell-taskbar");
      toggle_class(
        div,
        "docked",
        /*$UserData*/
        ctx[1].sh.taskbar.docked
      );
      toggle_class(
        div,
        "centered",
        /*$UserData*/
        ctx[1].sh.taskbar.centered
      );
      toggle_class(
        div,
        "colored",
        /*$UserData*/
        ctx[1].sh.taskbar.colored
      );
      toggle_class(
        div,
        "visible",
        /*$UserData*/
        (ctx[1].sh.taskbar.pos == "" || /*$UserData*/
        ctx[1].sh.taskbar.pos == "top") && !/*$isFullscreenWindow*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append(div, t2);
      mount_component(taskbarcontent, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$maxZIndex*/
      1) {
        set_style(
          div,
          "z-index",
          /*$maxZIndex*/
          ctx2[0] + 5
        );
      }
      if (!current || dirty & /*$UserData*/
      2) {
        toggle_class(
          div,
          "docked",
          /*$UserData*/
          ctx2[1].sh.taskbar.docked
        );
      }
      if (!current || dirty & /*$UserData*/
      2) {
        toggle_class(
          div,
          "centered",
          /*$UserData*/
          ctx2[1].sh.taskbar.centered
        );
      }
      if (!current || dirty & /*$UserData*/
      2) {
        toggle_class(
          div,
          "colored",
          /*$UserData*/
          ctx2[1].sh.taskbar.colored
        );
      }
      if (!current || dirty & /*$UserData, $isFullscreenWindow*/
      6) {
        toggle_class(
          div,
          "visible",
          /*$UserData*/
          (ctx2[1].sh.taskbar.pos == "" || /*$UserData*/
          ctx2[1].sh.taskbar.pos == "top") && !/*$isFullscreenWindow*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(taskbarcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(taskbarcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(taskbarcontent);
    }
  };
}
function instance$1i($$self, $$props, $$invalidate) {
  let $maxZIndex;
  let $UserData;
  let $isFullscreenWindow;
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(0, $maxZIndex = $$value));
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(1, $UserData = $$value));
  component_subscribe($$self, isFullscreenWindow, ($$value) => $$invalidate(2, $isFullscreenWindow = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [$maxZIndex, $UserData, $isFullscreenWindow, $$scope, slots];
}
class HorizontalTaskbar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1i, create_fragment$1n, safe_not_equal, {});
  }
}
function create_fragment$1m(ctx) {
  let button;
  let img;
  let img_src_value;
  let img_alt_value;
  let button_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = getOriginalIcon(
        /*app*/
        ctx[0].id
      ) || /*app*/
      ctx[0].info.icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*app*/
      ctx[0].info.name);
      attr(button, "title", button_title_value = /*app*/
      ctx[0].info.name);
      toggle_class(
        button,
        "minimized",
        /*minimized*/
        ctx[1]
      );
      toggle_class(
        button,
        "activated",
        /*app*/
        ctx[0].id == /*$focusedWindowId*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*e*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*app*/
      1 && !src_url_equal(img.src, img_src_value = getOriginalIcon(
        /*app*/
        ctx2[0].id
      ) || /*app*/
      ctx2[0].info.icon)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*app*/
      1 && img_alt_value !== (img_alt_value = /*app*/
      ctx2[0].info.name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*app*/
      1 && button_title_value !== (button_title_value = /*app*/
      ctx2[0].info.name)) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*minimized*/
      2) {
        toggle_class(
          button,
          "minimized",
          /*minimized*/
          ctx2[1]
        );
      }
      if (dirty & /*app, $focusedWindowId*/
      5) {
        toggle_class(
          button,
          "activated",
          /*app*/
          ctx2[0].id == /*$focusedWindowId*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$1h($$self, $$props, $$invalidate) {
  let $maxZIndex;
  let $focusedWindowId;
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(4, $maxZIndex = $$value));
  component_subscribe($$self, focusedWindowId, ($$value) => $$invalidate(2, $focusedWindowId = $$value));
  let { app } = $$props;
  let minimized = false;
  WindowStore.subscribe(() => {
    $$invalidate(1, minimized = isMinimized(app.id));
  });
  function e2() {
    if ($focusedWindowId == app.id)
      $$invalidate(0, app.state.windowState.min = !app.state.windowState.min, app);
    else
      $$invalidate(0, app.state.windowState.min = false, app);
    updateStores();
    set_store_value(maxZIndex, $maxZIndex++, $maxZIndex);
    set_store_value(focusedWindowId, $focusedWindowId = app.id, $focusedWindowId);
    const window2 = getWindowElement(app);
    window2.style.zIndex = $maxZIndex.toString();
    showArcFind.set(false);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [app, minimized, $focusedWindowId, e2];
}
class AppButton2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1h, create_fragment$1m, safe_not_equal, { app: 0 });
  }
}
function create_fragment$1l(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "launcher-bar-trigger");
      set_style(
        div,
        "z-index",
        /*$maxZIndex*/
        ctx[0] + 32
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          listen(
            div,
            "mouseenter",
            /*mouseenter*/
            ctx[1]
          ),
          listen(
            div,
            "mouseleave",
            /*mouseleave*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$maxZIndex*/
      1) {
        set_style(
          div,
          "z-index",
          /*$maxZIndex*/
          ctx2[0] + 32
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1g($$self, $$props, $$invalidate) {
  let $maxZIndex;
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(0, $maxZIndex = $$value));
  let { visible = false } = $$props;
  let { dockfocused } = $$props;
  let { interval: interval2 } = $$props;
  function mouseenter() {
    $$invalidate(3, visible = true);
  }
  function mouseleave() {
    clearTimeout(interval2);
    if (dockfocused)
      return;
    $$invalidate(4, interval2 = setTimeout(
      () => {
        $$invalidate(3, visible = false);
      },
      1e3
    ));
  }
  $$self.$$set = ($$props2) => {
    if ("visible" in $$props2)
      $$invalidate(3, visible = $$props2.visible);
    if ("dockfocused" in $$props2)
      $$invalidate(5, dockfocused = $$props2.dockfocused);
    if ("interval" in $$props2)
      $$invalidate(4, interval2 = $$props2.interval);
  };
  return [$maxZIndex, mouseenter, mouseleave, visible, interval2, dockfocused];
}
class Trigger extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1g, create_fragment$1l, safe_not_equal, { visible: 3, dockfocused: 5, interval: 4 });
  }
}
function get_each_context$g(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list2[i2];
  return child_ctx;
}
function create_if_block$G(ctx) {
  let appbutton;
  let current;
  appbutton = new AppButton2({ props: { app: (
    /*app*/
    ctx[12]
  ) } });
  return {
    c() {
      create_component(appbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(appbutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const appbutton_changes = {};
      if (dirty & /*oa*/
      1)
        appbutton_changes.app = /*app*/
        ctx2[12];
      appbutton.$set(appbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(appbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(appbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(appbutton, detaching);
    }
  };
}
function create_each_block$g(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*app*/
  ctx[12].info.hidden && create_if_block$G(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*app*/
      ctx2[12].info.hidden) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*oa*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$G(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$1k(ctx) {
  let div1;
  let button;
  let t0;
  let div0;
  let t1;
  let trigger;
  let updating_visible;
  let updating_interval;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*oa*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$g(get_each_context$g(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  function trigger_visible_binding(value) {
    ctx[9](value);
  }
  function trigger_interval_binding(value) {
    ctx[10](value);
  }
  let trigger_props = { dockfocused: (
    /*dockfocused*/
    ctx[2]
  ) };
  if (
    /*visible*/
    ctx[1] !== void 0
  ) {
    trigger_props.visible = /*visible*/
    ctx[1];
  }
  if (
    /*interval*/
    ctx[3] !== void 0
  ) {
    trigger_props.interval = /*interval*/
    ctx[3];
  }
  trigger = new Trigger({ props: trigger_props });
  binding_callbacks.push(() => bind$1(trigger, "visible", trigger_visible_binding));
  binding_callbacks.push(() => bind$1(trigger, "interval", trigger_interval_binding));
  return {
    c() {
      div1 = element("div");
      button = element("button");
      button.innerHTML = `<img src="${Logo()}" alt="ArcOS"/>`;
      t0 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      create_component(trigger.$$.fragment);
      attr(button, "class", "apps");
      attr(div0, "class", "opened-apps");
      attr(div1, "class", "launcher-bar shell-colored");
      set_style(
        div1,
        "z-index",
        /*$maxZIndex*/
        ctx[5] + 31
      );
      toggle_class(
        div1,
        "colored",
        /*$UserData*/
        ctx[4].sh.taskbar.colored
      );
      toggle_class(
        div1,
        "visible",
        /*visible*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, button);
      append(div1, t0);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      insert(target, t1, anchor);
      mount_component(trigger, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*toggleLauncher*/
            ctx[8]
          ),
          listen(
            div1,
            "mouseenter",
            /*mouseenter*/
            ctx[6]
          ),
          listen(
            div1,
            "mouseleave",
            /*mouseleave*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*oa*/
      1) {
        each_value = ensure_array_like(
          /*oa*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$g(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$g(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*$maxZIndex*/
      32) {
        set_style(
          div1,
          "z-index",
          /*$maxZIndex*/
          ctx2[5] + 31
        );
      }
      if (!current || dirty & /*$UserData*/
      16) {
        toggle_class(
          div1,
          "colored",
          /*$UserData*/
          ctx2[4].sh.taskbar.colored
        );
      }
      if (!current || dirty & /*visible*/
      2) {
        toggle_class(
          div1,
          "visible",
          /*visible*/
          ctx2[1]
        );
      }
      const trigger_changes = {};
      if (dirty & /*dockfocused*/
      4)
        trigger_changes.dockfocused = /*dockfocused*/
        ctx2[2];
      if (!updating_visible && dirty & /*visible*/
      2) {
        updating_visible = true;
        trigger_changes.visible = /*visible*/
        ctx2[1];
        add_flush_callback(() => updating_visible = false);
      }
      if (!updating_interval && dirty & /*interval*/
      8) {
        updating_interval = true;
        trigger_changes.interval = /*interval*/
        ctx2[3];
        add_flush_callback(() => updating_interval = false);
      }
      trigger.$set(trigger_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(trigger.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(trigger.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t1);
      }
      destroy_each(each_blocks, detaching);
      destroy_component(trigger, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1f($$self, $$props, $$invalidate) {
  let $showArcFind;
  let $UserData;
  let $maxZIndex;
  component_subscribe($$self, showArcFind, ($$value) => $$invalidate(11, $showArcFind = $$value));
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(4, $UserData = $$value));
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(5, $maxZIndex = $$value));
  let oa2 = [];
  let visible = false;
  let dockfocused = false;
  let interval2;
  WindowStore.subscribe(() => {
    $$invalidate(0, oa2 = getOpenedStore());
  });
  function mouseenter() {
    $$invalidate(2, dockfocused = true);
    clearTimeout(interval2);
  }
  function mouseleave() {
    $$invalidate(2, dockfocused = false);
    $$invalidate(3, interval2 = setTimeout(
      () => {
        $$invalidate(1, visible = false);
      },
      1e3
    ));
  }
  function toggleLauncher() {
    set_store_value(showArcFind, $showArcFind = !$showArcFind, $showArcFind);
  }
  function trigger_visible_binding(value) {
    visible = value;
    $$invalidate(1, visible);
  }
  function trigger_interval_binding(value) {
    interval2 = value;
    $$invalidate(3, interval2);
  }
  return [
    oa2,
    visible,
    dockfocused,
    interval2,
    $UserData,
    $maxZIndex,
    mouseenter,
    mouseleave,
    toggleLauncher,
    trigger_visible_binding,
    trigger_interval_binding
  ];
}
class Bar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1f, create_fragment$1k, safe_not_equal, {});
  }
}
function create_fragment$1j(ctx) {
  let div;
  let t2;
  return {
    c() {
      div = element("div");
      t2 = text(
        /*text*/
        ctx[0]
      );
      attr(div, "class", "clock");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*text*/
      1)
        set_data(
          t2,
          /*text*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$1e($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(1, $UserData = $$value));
  let text2 = "";
  onMount(() => {
    setInterval(
      () => {
        const tb = $UserData.sh.taskbar;
        const secs = tb.clockSecs && !tb.pos ? ":ss" : "";
        const date = tb.clockDate && !tb.pos ? "MMM D, " : "";
        const time = tb.clock12hr && !tb.pos ? `hh:mm${secs} A` : `HH:mm${secs}`;
        $$invalidate(0, text2 = dayjs().format(`${date}${time}`));
      },
      500
    );
  });
  return [text2];
}
let Clock$1 = class Clock2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1e, create_fragment$1j, safe_not_equal, {});
  }
};
function create_else_block$d(ctx) {
  let img;
  let img_src_value;
  let t0;
  let span;
  return {
    c() {
      img = element("img");
      t0 = space();
      span = element("span");
      span.textContent = "ArcOS Desktop";
      if (!src_url_equal(img.src, img_src_value = DefaultIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
    },
    m(target, anchor) {
      insert(target, img, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
        detach(t0);
        detach(span);
      }
    }
  };
}
function create_if_block$F(ctx) {
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1_value = (
    /*app*/
    ctx[0].info.name + ""
  );
  let t1;
  return {
    c() {
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      if (!src_url_equal(img.src, img_src_value = getOriginalIcon(
        /*app*/
        ctx[0].id
      )))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
    },
    m(target, anchor) {
      insert(target, img, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*app*/
      1 && !src_url_equal(img.src, img_src_value = getOriginalIcon(
        /*app*/
        ctx2[0].id
      ))) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*app*/
      1 && t1_value !== (t1_value = /*app*/
      ctx2[0].info.name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(img);
        detach(t0);
        detach(span);
      }
    }
  };
}
function create_fragment$1i(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (
      /*$focusedWindowId*/
      ctx2[1] && /*app*/
      ctx2[0] && (!/*app*/
      ctx2[0].info.custom || !/*app*/
      ctx2[0].core || /*$UserData*/
      ctx2[2].sh.showHiddenApps)
    )
      return create_if_block$F;
    return create_else_block$d;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "current-app");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_block.d();
    }
  };
}
function instance$1d($$self, $$props, $$invalidate) {
  let $focusedWindowId;
  let $UserData;
  component_subscribe($$self, focusedWindowId, ($$value) => $$invalidate(1, $focusedWindowId = $$value));
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(2, $UserData = $$value));
  let app;
  focusedWindowId.subscribe((v2) => {
    if (!v2)
      return;
    $$invalidate(0, app = getWindow(v2));
  });
  return [app, $focusedWindowId, $UserData];
}
class CurrentApp extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1d, create_fragment$1i, safe_not_equal, {});
  }
}
function create_fragment$1h(ctx) {
  let button0;
  let t0;
  let button1;
  let t1;
  let button2;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      button0.innerHTML = `<img src="${ShutdownIcon}" alt=""/>`;
      t0 = space();
      button1 = element("button");
      button1.innerHTML = `<img src="${LogoutIcon}" alt=""/>`;
      t1 = space();
      button2 = element("button");
      button2.innerHTML = `<img src="${RestartIcon}" alt=""/>`;
      attr(button0, "class", "icon");
      attr(button1, "class", "icon");
      attr(button2, "class", "icon");
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      insert(target, t0, anchor);
      insert(target, button1, anchor);
      insert(target, t1, anchor);
      insert(target, button2, anchor);
      if (!mounted) {
        dispose = [
          listen(button0, "click", shutdown),
          listen(
            button1,
            "click",
            /*click_handler*/
            ctx[0]
          ),
          listen(
            button2,
            "click",
            /*click_handler_1*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t0);
        detach(button1);
        detach(t1);
        detach(button2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1c($$self) {
  const click_handler = () => restart(true);
  const click_handler_1 = () => restart(false);
  return [click_handler, click_handler_1];
}
class Power extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1c, create_fragment$1h, safe_not_equal, {});
  }
}
function create_default_slot$3(ctx) {
  let power2;
  let t0;
  let span;
  let t1;
  let current;
  power2 = new Power({});
  return {
    c() {
      create_component(power2.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(
        /*$UserName*/
        ctx[3]
      );
    },
    m(target, anchor) {
      mount_component(power2, target, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, t1);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*$UserName*/
      8)
        set_data(
          t1,
          /*$UserName*/
          ctx2[3]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(power2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(power2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
      }
      destroy_component(power2, detaching);
    }
  };
}
function create_fragment$1g(ctx) {
  let div;
  let currentapp;
  let t0;
  let clock;
  let t1;
  let tray;
  let current;
  currentapp = new CurrentApp({});
  clock = new Clock$1({});
  tray = new Tray({
    props: {
      hasClock: false,
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(currentapp.$$.fragment);
      t0 = space();
      create_component(clock.$$.fragment);
      t1 = space();
      create_component(tray.$$.fragment);
      attr(div, "class", "launcher-topbar shell-colored");
      attr(div, "data-contextmenu", "clockcontext");
      set_style(
        div,
        "z-index",
        /*$maxZIndex*/
        ctx[2] + 5
      );
      toggle_class(
        div,
        "docked",
        /*$UserData*/
        ctx[0].sh.taskbar.docked
      );
      toggle_class(
        div,
        "colored",
        /*$UserData*/
        ctx[0].sh.taskbar.colored
      );
      toggle_class(div, "visible", !/*$isFullscreenWindow*/
      ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(currentapp, div, null);
      append(div, t0);
      mount_component(clock, div, null);
      append(div, t1);
      mount_component(tray, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tray_changes = {};
      if (dirty & /*$$scope, $UserName*/
      24) {
        tray_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tray.$set(tray_changes);
      if (!current || dirty & /*$maxZIndex*/
      4) {
        set_style(
          div,
          "z-index",
          /*$maxZIndex*/
          ctx2[2] + 5
        );
      }
      if (!current || dirty & /*$UserData*/
      1) {
        toggle_class(
          div,
          "docked",
          /*$UserData*/
          ctx2[0].sh.taskbar.docked
        );
      }
      if (!current || dirty & /*$UserData*/
      1) {
        toggle_class(
          div,
          "colored",
          /*$UserData*/
          ctx2[0].sh.taskbar.colored
        );
      }
      if (!current || dirty & /*$isFullscreenWindow*/
      2) {
        toggle_class(div, "visible", !/*$isFullscreenWindow*/
        ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(currentapp.$$.fragment, local);
      transition_in(clock.$$.fragment, local);
      transition_in(tray.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(currentapp.$$.fragment, local);
      transition_out(clock.$$.fragment, local);
      transition_out(tray.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(currentapp);
      destroy_component(clock);
      destroy_component(tray);
    }
  };
}
function instance$1b($$self, $$props, $$invalidate) {
  let $UserData;
  let $isFullscreenWindow;
  let $maxZIndex;
  let $UserName;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(0, $UserData = $$value));
  component_subscribe($$self, isFullscreenWindow, ($$value) => $$invalidate(1, $isFullscreenWindow = $$value));
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(2, $maxZIndex = $$value));
  component_subscribe($$self, UserName, ($$value) => $$invalidate(3, $UserName = $$value));
  return [$UserData, $isFullscreenWindow, $maxZIndex, $UserName];
}
class TopBar4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1b, create_fragment$1g, safe_not_equal, {});
  }
}
function create_fragment$1f(ctx) {
  let bar;
  let t2;
  let topbar;
  let current;
  bar = new Bar({});
  topbar = new TopBar4({});
  return {
    c() {
      create_component(bar.$$.fragment);
      t2 = space();
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(bar, target, anchor);
      insert(target, t2, anchor);
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(bar.$$.fragment, local);
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bar.$$.fragment, local);
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(bar, detaching);
      destroy_component(topbar, detaching);
    }
  };
}
class Launcher extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1f, safe_not_equal, {});
  }
}
const shade = "";
function create_fragment$1e(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "shellshade");
      set_style(
        div,
        "z-index",
        /*$maxZIndex*/
        ctx[1] + 3
      );
      toggle_class(
        div,
        "visible",
        /*$showShellShade*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*closeAll*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$maxZIndex*/
      2) {
        set_style(
          div,
          "z-index",
          /*$maxZIndex*/
          ctx2[1] + 3
        );
      }
      if (dirty & /*$showShellShade*/
      1) {
        toggle_class(
          div,
          "visible",
          /*$showShellShade*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$1a($$self, $$props, $$invalidate) {
  let $ActionCenterOpened;
  let $startOpened;
  let $showShellShade;
  let $maxZIndex;
  component_subscribe($$self, ActionCenterOpened, ($$value) => $$invalidate(3, $ActionCenterOpened = $$value));
  component_subscribe($$self, startOpened, ($$value) => $$invalidate(4, $startOpened = $$value));
  component_subscribe($$self, showShellShade, ($$value) => $$invalidate(0, $showShellShade = $$value));
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(1, $maxZIndex = $$value));
  ActionCenterOpened.subscribe(update2);
  startOpened.subscribe(update2);
  function update2() {
    set_store_value(showShellShade, $showShellShade = $startOpened || $ActionCenterOpened, $showShellShade);
  }
  function closeAll() {
    startOpened.set(false);
    ActionCenterOpened.set(false);
  }
  return [$showShellShade, $maxZIndex, closeAll];
}
class Shade extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1a, create_fragment$1e, safe_not_equal, {});
  }
}
function create_fragment$1d(ctx) {
  let div;
  let t2;
  let taskbarcontent;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  taskbarcontent = new TaskbarContent({});
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t2 = space();
      create_component(taskbarcontent.$$.fragment);
      attr(div, "class", "taskbar-v newtb shell-colored");
      set_style(
        div,
        "z-index",
        /*$maxZIndex*/
        ctx[0] + 5
      );
      attr(div, "data-contextmenu", "shell-taskbar");
      toggle_class(
        div,
        "docked",
        /*$UserData*/
        ctx[1].sh.taskbar.docked
      );
      toggle_class(
        div,
        "centered",
        /*$UserData*/
        ctx[1].sh.taskbar.centered
      );
      toggle_class(
        div,
        "colored",
        /*$UserData*/
        ctx[1].sh.taskbar.colored
      );
      toggle_class(
        div,
        "visible",
        /*$UserData*/
        ctx[1].sh.taskbar.pos != "" && /*$UserData*/
        ctx[1].sh.taskbar.pos != "top" && !/*$isFullscreenWindow*/
        ctx[2]
      );
      toggle_class(
        div,
        "right",
        /*$UserData*/
        ctx[1].sh.taskbar.pos == "vertical-right"
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append(div, t2);
      mount_component(taskbarcontent, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$maxZIndex*/
      1) {
        set_style(
          div,
          "z-index",
          /*$maxZIndex*/
          ctx2[0] + 5
        );
      }
      if (!current || dirty & /*$UserData*/
      2) {
        toggle_class(
          div,
          "docked",
          /*$UserData*/
          ctx2[1].sh.taskbar.docked
        );
      }
      if (!current || dirty & /*$UserData*/
      2) {
        toggle_class(
          div,
          "centered",
          /*$UserData*/
          ctx2[1].sh.taskbar.centered
        );
      }
      if (!current || dirty & /*$UserData*/
      2) {
        toggle_class(
          div,
          "colored",
          /*$UserData*/
          ctx2[1].sh.taskbar.colored
        );
      }
      if (!current || dirty & /*$UserData, $isFullscreenWindow*/
      6) {
        toggle_class(
          div,
          "visible",
          /*$UserData*/
          ctx2[1].sh.taskbar.pos != "" && /*$UserData*/
          ctx2[1].sh.taskbar.pos != "top" && !/*$isFullscreenWindow*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$UserData*/
      2) {
        toggle_class(
          div,
          "right",
          /*$UserData*/
          ctx2[1].sh.taskbar.pos == "vertical-right"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(taskbarcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(taskbarcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(taskbarcontent);
    }
  };
}
function instance$19($$self, $$props, $$invalidate) {
  let $maxZIndex;
  let $UserData;
  let $isFullscreenWindow;
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(0, $maxZIndex = $$value));
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(1, $UserData = $$value));
  component_subscribe($$self, isFullscreenWindow, ($$value) => $$invalidate(2, $isFullscreenWindow = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [$maxZIndex, $UserData, $isFullscreenWindow, $$scope, slots];
}
class VerticalTaskbar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$19, create_fragment$1d, safe_not_equal, {});
  }
}
function create_fragment$1c(ctx) {
  let div2;
  let h1;
  let profilepicture;
  let t0;
  let t1;
  let t2;
  let div1;
  let button0;
  let t4;
  let button1;
  let t6;
  let div0;
  let t7;
  let button2;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*pfp*/
      ctx[0]
    ), height: 21 }
  });
  return {
    c() {
      div2 = element("div");
      h1 = element("h1");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      t1 = text(
        /*$UserName*/
        ctx[1]
      );
      t2 = space();
      div1 = element("div");
      button0 = element("button");
      button0.textContent = "search";
      t4 = space();
      button1 = element("button");
      button1.textContent = "settings";
      t6 = space();
      div0 = element("div");
      t7 = space();
      button2 = element("button");
      button2.textContent = "power_settings_new";
      attr(h1, "class", "username");
      attr(button0, "class", "material-icons-round");
      attr(button0, "title", "Search (Alt+Shift+S)");
      attr(button1, "class", "material-icons-round");
      attr(div0, "class", "sep");
      attr(button2, "class", "material-icons-round");
      attr(div1, "class", "options");
      attr(div2, "class", "bottom");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, h1);
      mount_component(profilepicture, h1, null);
      append(h1, t0);
      append(h1, t1);
      append(div2, t2);
      append(div2, div1);
      append(div1, button0);
      append(div1, t4);
      append(div1, button1);
      append(div1, t6);
      append(div1, div0);
      append(div1, t7);
      append(div1, button2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*search*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*settings*/
            ctx[3]
          ),
          listen(
            button2,
            "click",
            /*exit*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      1)
        profilepicture_changes.src = /*pfp*/
        ctx2[0];
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*$UserName*/
      2)
        set_data(
          t1,
          /*$UserName*/
          ctx2[1]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(profilepicture);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$18($$self, $$props, $$invalidate) {
  let $UserData;
  let $UserName;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(5, $UserData = $$value));
  component_subscribe($$self, UserName, ($$value) => $$invalidate(1, $UserName = $$value));
  let pfp;
  function exit2() {
    openWindow("Exit");
    startOpened.set(false);
  }
  function settings() {
    openWindow("SettingsApp");
    startOpened.set(false);
  }
  function search2() {
    showArcFind.set(true);
    startOpened.set(false);
  }
  UserData$2.subscribe(() => {
    $$invalidate(0, pfp = getProfilePicture($UserData.acc.profilePicture));
  });
  return [pfp, $UserName, exit2, settings, search2];
}
class BottomPane2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$18, create_fragment$1c, safe_not_equal, {});
  }
}
const appGroups = {
  communication: {
    name: "Communication",
    id: "communication"
  },
  coreApps: {
    name: "Core Apps",
    id: "coreApps"
  },
  entertainment: {
    name: "Entertainment",
    id: "entertainment"
  },
  utilities: {
    name: "Utilities",
    id: "utilities"
  },
  support: {
    name: "Help and Support",
    id: "support"
  },
  systemTools: {
    name: "System Tools",
    id: "systemTools"
  }
};
function getAppGroups() {
  const ws = get_store_value(WindowStore);
  let result = {};
  const grouped = [];
  let rest = [];
  for (let i2 = 0; i2 < ws.length; i2++) {
    rest.push(ws[i2].id);
    const group = ws[i2].info.appGroup;
    if (!appGroups[group])
      continue;
    if (!isPopulatable(ws[i2])) {
      grouped.push(ws[i2].id);
      continue;
    }
    grouped.push(ws[i2].id);
    if (!result[group]) {
      result[group] = { ...appGroups[group], apps: [ws[i2].id] };
      continue;
    }
    result[group].apps.push(ws[i2].id);
  }
  rest = rest.filter((a2) => !grouped.includes(a2));
  result = Object.fromEntries(
    Object.entries(result).map((g2) => {
      g2[1].apps = g2[1].apps.sort((a2, b2) => {
        const appA = getWindow(a2);
        const appB = getWindow(b2);
        return appA.info.name > appB.info.name ? 1 : -1;
      });
      return g2;
    })
  );
  return { groups: result, rest };
}
function create_fragment$1b(ctx) {
  let button;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let t1_value = (
    /*app*/
    ctx[0].info.name + ""
  );
  let t1;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      t1 = text(t1_value);
      if (!src_url_equal(img.src, img_src_value = getOriginalIcon(
        /*app*/
        ctx[0].id
      ) || getAppIcon(
        /*app*/
        ctx[0]
      )))
        attr(img, "src", img_src_value);
      attr(img, "class", "icon");
      attr(img, "alt", img_alt_value = /*app*/
      ctx[0].info.name);
      attr(button, "class", "item");
      button.disabled = button_disabled_value = /*app*/
      ctx[0].opened;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*open*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*app*/
      1 && !src_url_equal(img.src, img_src_value = getOriginalIcon(
        /*app*/
        ctx2[0].id
      ) || getAppIcon(
        /*app*/
        ctx2[0]
      ))) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*app*/
      1 && img_alt_value !== (img_alt_value = /*app*/
      ctx2[0].info.name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*app*/
      1 && t1_value !== (t1_value = /*app*/
      ctx2[0].info.name + ""))
        set_data(t1, t1_value);
      if (dirty & /*app*/
      1 && button_disabled_value !== (button_disabled_value = /*app*/
      ctx2[0].opened)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$17($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { onopen = () => {
  } } = $$props;
  function open() {
    openWindow(app.id);
    updateStores();
    startOpened.set(false);
    onopen();
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("onopen" in $$props2)
      $$invalidate(2, onopen = $$props2.onopen);
  };
  return [app, open, onopen];
}
class AppListItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$17, create_fragment$1b, safe_not_equal, { app: 0, onopen: 2 });
  }
}
function get_each_context$f(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function create_if_block$E(ctx) {
  let div1;
  let button;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1_value = (
    /*group*/
    ctx[0].name + ""
  );
  let t1;
  let t2;
  let div0;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*group*/
    ctx[0].apps
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$f(get_each_context$f(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div1 = element("div");
      button = element("button");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (!src_url_equal(img.src, img_src_value = FolderIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(span, "class", "capt");
      attr(button, "class", "expander");
      attr(div0, "class", "apps");
      attr(div1, "class", "group");
      toggle_class(
        div1,
        "expand",
        /*expand*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, button);
      append(button, img);
      append(button, t0);
      append(button, span);
      append(span, t1);
      append(div1, t2);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggle*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*group*/
      1) && t1_value !== (t1_value = /*group*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*group*/
      1) {
        each_value = ensure_array_like(
          /*group*/
          ctx2[0].apps
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$f(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$f(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*expand*/
      2) {
        toggle_class(
          div1,
          "expand",
          /*expand*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$a(ctx) {
  let applistitem;
  let current;
  applistitem = new AppListItem({ props: { app: getWindow(
    /*id*/
    ctx[3]
  ) } });
  return {
    c() {
      create_component(applistitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applistitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applistitem_changes = {};
      if (dirty & /*group*/
      1)
        applistitem_changes.app = getWindow(
          /*id*/
          ctx2[3]
        );
      applistitem.$set(applistitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applistitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applistitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applistitem, detaching);
    }
  };
}
function create_each_block$f(ctx) {
  let show_if = isPopulatable(getWindow(
    /*id*/
    ctx[3]
  ));
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_1$a(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*group*/
      1)
        show_if = isPopulatable(getWindow(
          /*id*/
          ctx2[3]
        ));
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*group*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$a(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$1a(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*group*/
    ctx[0] && create_if_block$E(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*group*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*group*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$E(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$16($$self, $$props, $$invalidate) {
  let { group } = $$props;
  let expand = false;
  const toggle = () => $$invalidate(1, expand = !expand);
  $$self.$$set = ($$props2) => {
    if ("group" in $$props2)
      $$invalidate(0, group = $$props2.group);
  };
  return [group, expand, toggle];
}
class Group extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$16, create_fragment$1a, safe_not_equal, { group: 0 });
  }
}
function get_each_context_2(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2];
  return child_ctx;
}
function get_each_context$e(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2];
  return child_ctx;
}
function get_each_context_1$3(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list2[i2];
  return child_ctx;
}
function create_else_block$c(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ensure_array_like(
    /*$WindowStore*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2(get_each_context_2(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$WindowStore*/
      8) {
        each_value_2 = ensure_array_like(
          /*$WindowStore*/
          ctx2[3]
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block$D(ctx) {
  let t2;
  let each1_anchor;
  let current;
  let each_value_1 = ensure_array_like(Object.values(
    /*$groups*/
    ctx[1]
  ));
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  let each_value = ensure_array_like(
    /*rest*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$e(get_each_context$e(ctx, each_value, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, $groups*/
      2) {
        each_value_1 = ensure_array_like(Object.values(
          /*$groups*/
          ctx2[1]
        ));
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$3(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_1$3(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(t2.parentNode, t2);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (dirty & /*rest*/
      1) {
        each_value = ensure_array_like(
          /*rest*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$e(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$e(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each1_anchor.parentNode, each1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(each1_anchor);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_2$4(ctx) {
  let applistitem;
  let current;
  applistitem = new AppListItem({ props: { app: (
    /*window*/
    ctx[5]
  ) } });
  return {
    c() {
      create_component(applistitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applistitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applistitem_changes = {};
      if (dirty & /*$WindowStore*/
      8)
        applistitem_changes.app = /*window*/
        ctx2[5];
      applistitem.$set(applistitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applistitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applistitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applistitem, detaching);
    }
  };
}
function create_each_block_2(ctx) {
  let show_if = isPopulatable(
    /*window*/
    ctx[5]
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_2$4(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$WindowStore*/
      8)
        show_if = isPopulatable(
          /*window*/
          ctx2[5]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$WindowStore*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_each_block_1$3(ctx) {
  let group;
  let current;
  group = new Group({ props: { group: (
    /*entry*/
    ctx[8]
  ) } });
  return {
    c() {
      create_component(group.$$.fragment);
    },
    m(target, anchor) {
      mount_component(group, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const group_changes = {};
      if (dirty & /*$groups*/
      2)
        group_changes.group = /*entry*/
        ctx2[8];
      group.$set(group_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(group.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(group.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(group, detaching);
    }
  };
}
function create_if_block_1$9(ctx) {
  let applistitem;
  let current;
  applistitem = new AppListItem({
    props: { app: getWindow(
      /*window*/
      ctx[5]
    ) }
  });
  return {
    c() {
      create_component(applistitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applistitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applistitem_changes = {};
      if (dirty & /*rest*/
      1)
        applistitem_changes.app = getWindow(
          /*window*/
          ctx2[5]
        );
      applistitem.$set(applistitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applistitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applistitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applistitem, detaching);
    }
  };
}
function create_each_block$e(ctx) {
  let show_if = isPopulatable(getWindow(
    /*window*/
    ctx[5]
  ));
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_1$9(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*rest*/
      1)
        show_if = isPopulatable(getWindow(
          /*window*/
          ctx2[5]
        ));
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*rest*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$19(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$D, create_else_block$c];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*$UserData*/
    ctx2[2].sh.start.noGroups)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "left");
      attr(div, "data-contextmenu", "startmenu-applist");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$15($$self, $$props, $$invalidate) {
  let $groups;
  let $UserData;
  let $WindowStore;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(2, $UserData = $$value));
  component_subscribe($$self, WindowStore, ($$value) => $$invalidate(3, $WindowStore = $$value));
  let groups = writable({});
  component_subscribe($$self, groups, (value) => $$invalidate(1, $groups = value));
  let rest = [];
  WindowStore.subscribe(async () => {
    set_store_value(groups, $groups = {}, $groups);
    await sleep(0);
    const getter = getAppGroups();
    set_store_value(groups, $groups = getter.groups, $groups);
    $$invalidate(0, rest = getter.rest);
  });
  return [rest, $groups, $UserData, $WindowStore, groups];
}
class LeftPane extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$15, create_fragment$19, safe_not_equal, {});
  }
}
function create_fragment$18(ctx) {
  let button;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let div1;
  let t1_value = (
    /*dir*/
    ctx[0].name + ""
  );
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      if (!src_url_equal(img.src, img_src_value = FolderIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*dir*/
      ctx[0].name);
      attr(div0, "class", "image");
      attr(div1, "class", "caption");
      attr(button, "class", "link dir");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div0);
      append(div0, img);
      append(button, t0);
      append(button, div1);
      append(div1, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*open*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*dir*/
      1 && img_alt_value !== (img_alt_value = /*dir*/
      ctx2[0].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*dir*/
      1 && t1_value !== (t1_value = /*dir*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$14($$self, $$props, $$invalidate) {
  let { dir } = $$props;
  function open() {
    startOpened.set(false);
    openWindow("FileManager");
    setTimeout(
      () => {
        fbClass.goToDirectory(dir.scopedPath);
      },
      50
    );
  }
  $$self.$$set = ($$props2) => {
    if ("dir" in $$props2)
      $$invalidate(0, dir = $$props2.dir);
  };
  return [dir, open];
}
class DirLink extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$14, create_fragment$18, safe_not_equal, { dir: 0 });
  }
}
function get_each_context$d(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2];
  return child_ctx;
}
function create_each_block$d(ctx) {
  let dirlink;
  let current;
  dirlink = new DirLink({ props: { dir: (
    /*dir*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(dirlink.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dirlink, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dirlink_changes = {};
      if (dirty & /*dirs*/
      1)
        dirlink_changes.dir = /*dir*/
        ctx2[1];
      dirlink.$set(dirlink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dirlink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dirlink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dirlink, detaching);
    }
  };
}
function create_if_block$C(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "No folders!";
      attr(p2, "class", "none");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_fragment$17(ctx) {
  let div;
  let t2;
  let current;
  let each_value = ensure_array_like(
    /*dirs*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$d(get_each_context$d(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = !/*dirs*/
  ctx[0].length && create_if_block$C();
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "right");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      append(div, t2);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*dirs*/
      1) {
        each_value = ensure_array_like(
          /*dirs*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$d(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$d(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, t2);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!/*dirs*/
      ctx2[0].length) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$C();
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$13($$self, $$props, $$invalidate) {
  let dirs = [];
  fbState.subscribe(async () => {
    $$invalidate(0, dirs = sortDirectories((await getDirectory("./")).directories));
  });
  return [dirs];
}
class RightPane extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$13, create_fragment$17, safe_not_equal, {});
  }
}
function create_if_block$B(ctx) {
  let div;
  let leftpane;
  let t0;
  let rightpane;
  let t1;
  let bottompane;
  let current;
  leftpane = new LeftPane({});
  rightpane = new RightPane({});
  bottompane = new BottomPane2({});
  return {
    c() {
      div = element("div");
      create_component(leftpane.$$.fragment);
      t0 = space();
      create_component(rightpane.$$.fragment);
      t1 = space();
      create_component(bottompane.$$.fragment);
      attr(div, "class", "startmenu shell-colored");
      set_style(
        div,
        "z-index",
        /*$maxZIndex*/
        ctx[1] + 4
      );
      toggle_class(
        div,
        "open",
        /*$startOpened*/
        ctx[2]
      );
      toggle_class(
        div,
        "small",
        /*$UserData*/
        ctx[0].sh.start.small
      );
      toggle_class(
        div,
        "colored",
        /*$UserData*/
        ctx[0].sh.taskbar.colored
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(leftpane, div, null);
      append(div, t0);
      mount_component(rightpane, div, null);
      append(div, t1);
      mount_component(bottompane, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*$maxZIndex*/
      2) {
        set_style(
          div,
          "z-index",
          /*$maxZIndex*/
          ctx2[1] + 4
        );
      }
      if (!current || dirty & /*$startOpened*/
      4) {
        toggle_class(
          div,
          "open",
          /*$startOpened*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$UserData*/
      1) {
        toggle_class(
          div,
          "small",
          /*$UserData*/
          ctx2[0].sh.start.small
        );
      }
      if (!current || dirty & /*$UserData*/
      1) {
        toggle_class(
          div,
          "colored",
          /*$UserData*/
          ctx2[0].sh.taskbar.colored
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leftpane.$$.fragment, local);
      transition_in(rightpane.$$.fragment, local);
      transition_in(bottompane.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(leftpane.$$.fragment, local);
      transition_out(rightpane.$$.fragment, local);
      transition_out(bottompane.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(leftpane);
      destroy_component(rightpane);
      destroy_component(bottompane);
    }
  };
}
function create_fragment$16(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$UserData*/
    ctx[0] && create_if_block$B(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$UserData*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$UserData*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$B(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$12($$self, $$props, $$invalidate) {
  let $UserData;
  let $maxZIndex;
  let $startOpened;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(0, $UserData = $$value));
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(1, $maxZIndex = $$value));
  component_subscribe($$self, startOpened, ($$value) => $$invalidate(2, $startOpened = $$value));
  return [$UserData, $maxZIndex, $startOpened];
}
class StartMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$12, create_fragment$16, safe_not_equal, {});
  }
}
const AccentedLogo_svelte_svelte_type_style_lang = "";
function create_fragment$15(ctx) {
  let svg;
  let g2;
  let path0;
  let path1;
  let path2;
  let defs;
  let clipPath;
  let rect;
  return {
    c() {
      svg = svg_element("svg");
      g2 = svg_element("g");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      defs = svg_element("defs");
      clipPath = svg_element("clipPath");
      rect = svg_element("rect");
      attr(path0, "d", "M258.424 72.16L259.472 72.272L260.512 72.432L261.544 72.632L262.552 72.872L263.552 73.16L264.536 73.48L265.496 73.848L266.44 74.248L267.368 74.688L268.28 75.168L269.168 75.68L270.032 76.232L270.88 76.808L271.704 77.424L272.496 78.072L273.272 78.752L274.024 79.464L274.744 80.208L275.44 80.976L276.104 81.768L276.288 82.008L276.44 82.184L276.616 82.4L276.776 82.632L276.84 82.72L277.352 83.44L277.936 84.32L278.48 85.216L279 86.136L279.48 87.08L279.912 88.016L421.504 333.264L421.648 333.512L421.768 333.768L421.888 334.024L421.992 334.28L422.08 334.544L422.168 334.808L422.232 335.072L422.296 335.336L422.344 335.6L422.384 335.872L422.408 336.136L422.432 336.408V336.672V336.936L422.416 337.208L422.392 337.472L422.36 337.736L422.32 338L422.264 338.256L422.2 338.512L422.128 338.768L422.04 339.024L421.952 339.272L421.848 339.52L421.736 339.76L421.616 339.992L421.48 340.232L421.344 340.456L421.192 340.68L421.032 340.896L420.872 341.112L420.696 341.32L420.512 341.52L420.312 341.712L420.112 341.896L419.904 342.08L419.68 342.248L419.456 342.416L419.216 342.568L418.976 342.712L377.76 366.512L377.512 366.648L377.256 366.776L377 366.888L376.744 366.992L376.48 367.088L376.216 367.168L375.952 367.24L375.688 367.296L375.424 367.352L375.16 367.384L374.888 367.416L374.624 367.432L374.352 367.44L374.088 367.432L373.816 367.424L373.552 367.4L373.288 367.368L373.032 367.32L372.768 367.264L372.512 367.2L372.256 367.128L372 367.048L371.752 366.952L371.512 366.848L371.264 366.736L371.032 366.616L370.792 366.488L370.568 366.344L370.344 366.2L370.128 366.04L369.912 365.872L369.704 365.696L369.504 365.512L369.312 365.32L369.128 365.12L368.952 364.904L368.776 364.688L368.616 364.456L368.456 364.224L368.312 363.976L256.2 169.8L144.088 363.976L143.944 364.224L143.784 364.456L143.624 364.688L143.448 364.904L143.272 365.12L143.088 365.32L142.896 365.512L142.696 365.696L142.488 365.872L142.272 366.04L142.056 366.2L141.832 366.344L141.608 366.488L141.368 366.616L141.136 366.736L140.888 366.848L140.648 366.952L140.4 367.048L140.144 367.128L139.888 367.2L139.632 367.264L139.368 367.32L139.112 367.368L138.848 367.4L138.584 367.424L138.312 367.432L138.048 367.44L137.776 367.432L137.512 367.416L137.24 367.384L136.976 367.352L136.712 367.296L136.448 367.24L136.184 367.168L135.92 367.088L135.656 366.992L135.4 366.888L135.144 366.776L134.888 366.648L134.64 366.512L93.424 342.712L93.184 342.568L92.944 342.416L92.72 342.248L92.496 342.08L92.288 341.896L92.088 341.712L91.888 341.52L91.704 341.32L91.528 341.112L91.368 340.896L91.208 340.68L91.056 340.456L90.92 340.232L90.784 339.992L90.664 339.76L90.552 339.52L90.448 339.272L90.36 339.024L90.272 338.768L90.2 338.512L90.136 338.256L90.08 338L90.04 337.736L90.008 337.472L89.984 337.208L89.968 336.936V336.672V336.408L89.992 336.136L90.016 335.872L90.056 335.6L90.104 335.336L90.168 335.072L90.232 334.808L90.32 334.544L90.408 334.28L90.512 334.024L90.632 333.768L90.752 333.512L90.896 333.264L233.544 86.192L233.568 86.136L234.08 85.216L234.472 84.576L235.32 83.112L235.464 82.864L235.624 82.632L235.784 82.4L235.96 82.184L236.136 81.976L236.32 81.768L236.52 81.576L236.72 81.392L236.912 81.232L237.128 80.976L237.824 80.208L238.544 79.464L239.288 78.752L240.064 78.072L240.864 77.424L241.688 76.808L242.528 76.232L243.4 75.68L244.288 75.168L245.192 74.688L246.12 74.248L247.064 73.848L248.032 73.48L249.016 73.16L250.008 72.872L251.024 72.632L252.048 72.432L253.088 72.272L254.144 72.16L255.208 72.088L256.28 72.064L257.36 72.088L258.424 72.16Z");
      attr(path0, "fill", "white");
      attr(path0, "fill-opacity", "0.25");
      attr(path0, "class", "part svelte-tolmqv");
      attr(path1, "d", "M259.224 97.76L260.272 97.872L261.312 98.032L262.344 98.232L263.352 98.472L264.352 98.76L265.336 99.08L266.296 99.448L267.24 99.848L268.168 100.288L269.08 100.768L269.968 101.28L270.832 101.832L271.68 102.408L272.504 103.024L273.296 103.672L274.072 104.352L274.824 105.064L275.544 105.808L276.24 106.576L276.904 107.368L277.088 107.608L277.24 107.784L277.416 108L277.576 108.232L277.64 108.32L278.152 109.04L278.736 109.92L279.28 110.816L279.8 111.736L280.28 112.68L280.712 113.616L422.304 358.864L422.448 359.112L422.568 359.368L422.688 359.624L422.792 359.88L422.88 360.144L422.968 360.408L423.032 360.672L423.096 360.936L423.144 361.2L423.184 361.472L423.208 361.736L423.232 362.008V362.272V362.536L423.216 362.808L423.192 363.072L423.16 363.336L423.12 363.6L423.064 363.856L423 364.112L422.928 364.368L422.84 364.624L422.752 364.872L422.648 365.12L422.536 365.36L422.416 365.592L422.28 365.832L422.144 366.056L421.992 366.28L421.832 366.496L421.672 366.712L421.496 366.92L421.312 367.12L421.112 367.312L420.912 367.496L420.704 367.68L420.48 367.848L420.256 368.016L420.016 368.168L419.776 368.312L378.56 392.112L378.312 392.248L378.056 392.376L377.8 392.488L377.544 392.592L377.28 392.688L377.016 392.768L376.752 392.84L376.488 392.896L376.224 392.952L375.96 392.984L375.688 393.016L375.424 393.032L375.152 393.04L374.888 393.032L374.616 393.024L374.352 393L374.088 392.968L373.832 392.92L373.568 392.864L373.312 392.8L373.056 392.728L372.8 392.648L372.552 392.552L372.312 392.448L372.064 392.336L371.832 392.216L371.592 392.088L371.368 391.944L371.144 391.8L370.928 391.64L370.712 391.472L370.504 391.296L370.304 391.112L370.112 390.92L369.928 390.72L369.752 390.504L369.576 390.288L369.416 390.056L369.256 389.824L369.112 389.576L257 195.4L144.888 389.576L144.744 389.824L144.584 390.056L144.424 390.288L144.248 390.504L144.072 390.72L143.888 390.92L143.696 391.112L143.496 391.296L143.288 391.472L143.072 391.64L142.856 391.8L142.632 391.944L142.408 392.088L142.168 392.216L141.936 392.336L141.688 392.448L141.448 392.552L141.2 392.648L140.944 392.728L140.688 392.8L140.432 392.864L140.168 392.92L139.912 392.968L139.648 393L139.384 393.024L139.112 393.032L138.848 393.04L138.576 393.032L138.312 393.016L138.04 392.984L137.776 392.952L137.512 392.896L137.248 392.84L136.984 392.768L136.72 392.688L136.456 392.592L136.2 392.488L135.944 392.376L135.688 392.248L135.44 392.112L94.224 368.312L93.984 368.168L93.744 368.016L93.52 367.848L93.296 367.68L93.088 367.496L92.888 367.312L92.688 367.12L92.504 366.92L92.328 366.712L92.168 366.496L92.008 366.28L91.856 366.056L91.72 365.832L91.584 365.592L91.464 365.36L91.352 365.12L91.248 364.872L91.16 364.624L91.072 364.368L91 364.112L90.936 363.856L90.88 363.6L90.84 363.336L90.808 363.072L90.784 362.808L90.768 362.536V362.272V362.008L90.792 361.736L90.816 361.472L90.856 361.2L90.904 360.936L90.968 360.672L91.032 360.408L91.12 360.144L91.208 359.88L91.312 359.624L91.432 359.368L91.552 359.112L91.696 358.864L234.344 111.792L234.368 111.736L234.88 110.816L235.272 110.176L236.12 108.712L236.264 108.464L236.424 108.232L236.584 108L236.76 107.784L236.936 107.576L237.12 107.368L237.32 107.176L237.52 106.992L237.712 106.832L237.928 106.576L238.624 105.808L239.344 105.064L240.088 104.352L240.864 103.672L241.664 103.024L242.488 102.408L243.328 101.832L244.2 101.28L245.088 100.768L245.992 100.288L246.92 99.848L247.864 99.448L248.832 99.08L249.816 98.76L250.808 98.472L251.824 98.232L252.848 98.032L253.888 97.872L254.944 97.76L256.008 97.688L257.08 97.664L258.16 97.688L259.224 97.76Z");
      attr(path1, "fill", "white");
      attr(path1, "fill-opacity", "0.5");
      attr(path1, "class", "part svelte-tolmqv");
      attr(path2, "d", "M259.224 126.472L260.272 126.584L261.312 126.744L262.344 126.944L263.352 127.184L264.352 127.472L265.336 127.8L266.296 128.16L267.24 128.56L268.168 129.008L269.08 129.48L269.968 129.992L270.832 130.544L271.68 131.128L272.504 131.744L273.296 132.392L274.072 133.072L274.824 133.776L275.544 134.52L276.24 135.288L276.904 136.088L277.088 136.32L277.24 136.496L277.416 136.72L277.576 136.944L277.64 137.04L278.152 137.76L278.736 138.632L279.28 139.528L279.8 140.456L280.28 141.4L280.712 142.328L422.304 387.576L422.448 387.832L422.568 388.08L422.688 388.336L422.792 388.6L422.88 388.856L422.968 389.12L423.032 389.384L423.096 389.648L423.144 389.912L423.184 390.184L423.208 390.448L423.232 390.72V390.984V391.256L423.216 391.52L423.192 391.784L423.16 392.048L423.12 392.312L423.064 392.568L423 392.832L422.928 393.088L422.84 393.336L422.752 393.584L422.648 393.832L422.536 394.072L422.416 394.312L422.28 394.544L422.144 394.768L421.992 394.992L421.832 395.216L421.672 395.424L421.496 395.632L421.312 395.832L421.112 396.024L420.912 396.208L420.704 396.392L420.48 396.56L420.256 396.728L420.016 396.88L419.776 397.032L378.56 420.824L378.312 420.96L378.056 421.088L377.8 421.208L377.544 421.312L377.28 421.4L377.016 421.48L376.752 421.552L376.488 421.616L376.224 421.664L375.96 421.704L375.688 421.728L375.424 421.744L375.152 421.752H374.888L374.616 421.736L374.352 421.712L374.088 421.68L373.832 421.632L373.568 421.584L373.312 421.52L373.056 421.44L372.8 421.36L372.552 421.264L372.312 421.168L372.064 421.056L371.832 420.928L371.592 420.8L371.368 420.664L371.144 420.512L370.928 420.352L370.712 420.184L370.504 420.008L370.304 419.824L370.112 419.632L369.928 419.432L369.752 419.216L369.576 419L369.416 418.776L369.256 418.536L369.112 418.296L257 224.112L144.888 418.296L144.744 418.536L144.584 418.776L144.424 419L144.248 419.216L144.072 419.432L143.888 419.632L143.696 419.824L143.496 420.008L143.288 420.184L143.072 420.352L142.856 420.512L142.632 420.664L142.408 420.8L142.168 420.928L141.936 421.056L141.688 421.168L141.448 421.264L141.2 421.36L140.944 421.44L140.688 421.52L140.432 421.584L140.168 421.632L139.912 421.68L139.648 421.712L139.384 421.736L139.112 421.752H138.848L138.576 421.744L138.312 421.728L138.04 421.704L137.776 421.664L137.512 421.616L137.248 421.552L136.984 421.48L136.72 421.4L136.456 421.312L136.2 421.208L135.944 421.088L135.688 420.96L135.44 420.824L94.224 397.032L93.984 396.88L93.744 396.728L93.52 396.56L93.296 396.392L93.088 396.208L92.888 396.024L92.688 395.832L92.504 395.632L92.328 395.424L92.168 395.216L92.008 394.992L91.856 394.768L91.72 394.544L91.584 394.312L91.464 394.072L91.352 393.832L91.248 393.584L91.16 393.336L91.072 393.088L91 392.832L90.936 392.568L90.88 392.312L90.84 392.048L90.808 391.784L90.784 391.52L90.768 391.256V390.984V390.72L90.792 390.448L90.816 390.184L90.856 389.912L90.904 389.648L90.968 389.384L91.032 389.12L91.12 388.856L91.208 388.6L91.312 388.336L91.432 388.08L91.552 387.832L91.696 387.576L234.344 140.504L234.368 140.456L234.88 139.528L235.272 138.888L236.12 137.424L236.264 137.184L236.424 136.944L236.584 136.72L236.76 136.496L236.936 136.288L237.12 136.088L237.32 135.896L237.52 135.704L237.712 135.544L237.928 135.288L238.624 134.52L239.344 133.776L240.088 133.072L240.864 132.392L241.664 131.744L242.488 131.128L243.328 130.544L244.2 129.992L245.088 129.48L245.992 129.008L246.92 128.56L247.864 128.16L248.832 127.8L249.816 127.472L250.808 127.184L251.824 126.944L252.848 126.744L253.888 126.584L254.944 126.472L256.008 126.4L257.08 126.376L258.16 126.4L259.224 126.472Z");
      attr(path2, "fill", "white");
      attr(path2, "class", "part svelte-tolmqv");
      attr(g2, "clip-path", "url(#clip0_202_2)");
      attr(rect, "width", "512");
      attr(rect, "height", "512");
      attr(rect, "fill", "white");
      attr(clipPath, "id", "clip0_202_2");
      attr(
        svg,
        "width",
        /*width*/
        ctx[0]
      );
      attr(
        svg,
        "height",
        /*height*/
        ctx[1]
      );
      attr(svg, "viewBox", "0 0 512 512");
      attr(svg, "fill", "none");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "class", "accented-logo svelte-tolmqv");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g2);
      append(g2, path0);
      append(g2, path1);
      append(g2, path2);
      append(svg, defs);
      append(defs, clipPath);
      append(clipPath, rect);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*width*/
      1) {
        attr(
          svg,
          "width",
          /*width*/
          ctx2[0]
        );
      }
      if (dirty & /*height*/
      2) {
        attr(
          svg,
          "height",
          /*height*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function instance$11($$self, $$props, $$invalidate) {
  let { width = 512 } = $$props;
  let { height = 512 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
  };
  return [width, height];
}
class AccentedLogo extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$11, create_fragment$15, safe_not_equal, { width: 0, height: 1 });
  }
}
function create_else_block$b(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = Logo()))
        attr(img, "src", img_src_value);
      attr(img, "alt", "ArcOS Logo");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_if_block$A(ctx) {
  let accentedlogo;
  let current;
  accentedlogo = new AccentedLogo({ props: { width: 30, height: 30 } });
  return {
    c() {
      create_component(accentedlogo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(accentedlogo, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(accentedlogo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accentedlogo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accentedlogo, detaching);
    }
  };
}
function create_fragment$14(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$A, create_else_block$b];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$UserData*/
      ctx2[1].sh.taskbar.accentedStart
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "class", "start");
      toggle_class(
        button,
        "open",
        /*$startOpened*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggle*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
      if (!current || dirty & /*$startOpened*/
      1) {
        toggle_class(
          button,
          "open",
          /*$startOpened*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function instance$10($$self, $$props, $$invalidate) {
  let $startOpened;
  let $UserData;
  component_subscribe($$self, startOpened, ($$value) => $$invalidate(0, $startOpened = $$value));
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(1, $UserData = $$value));
  function toggle() {
    set_store_value(startOpened, $startOpened = !$startOpened, $startOpened);
  }
  return [$startOpened, $UserData, toggle];
}
class StartButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$10, create_fragment$14, safe_not_equal, {});
  }
}
function create_else_block$a(ctx) {
  let launcher;
  let current;
  launcher = new Launcher({});
  return {
    c() {
      create_component(launcher.$$.fragment);
    },
    m(target, anchor) {
      mount_component(launcher, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(launcher.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(launcher.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(launcher, detaching);
    }
  };
}
function create_if_block$z(ctx) {
  let horizontaltaskbar;
  let t2;
  let verticaltaskbar;
  let current;
  horizontaltaskbar = new HorizontalTaskbar({
    props: {
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  verticaltaskbar = new VerticalTaskbar({
    props: {
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(horizontaltaskbar.$$.fragment);
      t2 = space();
      create_component(verticaltaskbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(horizontaltaskbar, target, anchor);
      insert(target, t2, anchor);
      mount_component(verticaltaskbar, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(horizontaltaskbar.$$.fragment, local);
      transition_in(verticaltaskbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontaltaskbar.$$.fragment, local);
      transition_out(verticaltaskbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(horizontaltaskbar, detaching);
      destroy_component(verticaltaskbar, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let startbutton;
  let current;
  startbutton = new StartButton({});
  return {
    c() {
      create_component(startbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(startbutton, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(startbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(startbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(startbutton, detaching);
    }
  };
}
function create_default_slot$2(ctx) {
  let startbutton;
  let current;
  startbutton = new StartButton({});
  return {
    c() {
      create_component(startbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(startbutton, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(startbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(startbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(startbutton, detaching);
    }
  };
}
function create_fragment$13(ctx) {
  let shade2;
  let t0;
  let startmenu2;
  let t1;
  let current_block_type_index;
  let if_block;
  let t2;
  let actioncenter2;
  let t3;
  let pushnotification;
  let current;
  shade2 = new Shade({});
  startmenu2 = new StartMenu({});
  const if_block_creators = [create_if_block$z, create_else_block$a];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*$UserData*/
    ctx2[0].sh.taskbar.isLauncher)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  actioncenter2 = new ActionCenter({});
  pushnotification = new PushNotification({});
  return {
    c() {
      create_component(shade2.$$.fragment);
      t0 = space();
      create_component(startmenu2.$$.fragment);
      t1 = space();
      if_block.c();
      t2 = space();
      create_component(actioncenter2.$$.fragment);
      t3 = space();
      create_component(pushnotification.$$.fragment);
    },
    m(target, anchor) {
      mount_component(shade2, target, anchor);
      insert(target, t0, anchor);
      mount_component(startmenu2, target, anchor);
      insert(target, t1, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t2, anchor);
      mount_component(actioncenter2, target, anchor);
      insert(target, t3, anchor);
      mount_component(pushnotification, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(t2.parentNode, t2);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(shade2.$$.fragment, local);
      transition_in(startmenu2.$$.fragment, local);
      transition_in(if_block);
      transition_in(actioncenter2.$$.fragment, local);
      transition_in(pushnotification.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(shade2.$$.fragment, local);
      transition_out(startmenu2.$$.fragment, local);
      transition_out(if_block);
      transition_out(actioncenter2.$$.fragment, local);
      transition_out(pushnotification.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
      }
      destroy_component(shade2, detaching);
      destroy_component(startmenu2, detaching);
      if_blocks[current_block_type_index].d(detaching);
      destroy_component(actioncenter2, detaching);
      destroy_component(pushnotification, detaching);
    }
  };
}
function instance$$($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(0, $UserData = $$value));
  return [$UserData];
}
class Shell2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$$, create_fragment$13, safe_not_equal, {});
  }
}
const ArcShell = {
  info: {
    name: "ArcShell",
    description: "The ArcOS Shell",
    builtin: true,
    version: ArcOSVersion,
    author: "ArcOS Team",
    icon: Logo(),
    custom: true,
    appGroup: "coreApps"
  },
  size: { w: NaN, h: NaN },
  pos: { x: 0, y: 0 },
  minSize: { w: NaN, h: NaN },
  maxSize: { w: NaN, h: NaN },
  controls: { min: false, max: false, cls: false },
  state: {
    headless: true,
    resizable: false,
    windowState: { min: false, max: false, fll: true }
  },
  content: Shell2,
  glass: false,
  events: {},
  contextMenu: {
    clockcontext: [
      {
        caption: "Show Seconds",
        action: () => {
          UserData$2.update((udata) => {
            udata.sh.taskbar.clockSecs = !udata.sh.taskbar.clockSecs;
            return udata;
          });
        },
        isActive: () => get_store_value(UserData$2).sh.taskbar.clockSecs,
        icon: "av_timer"
      },
      {
        caption: "Show Date",
        action: () => {
          UserData$2.update((udata) => {
            udata.sh.taskbar.clockDate = !udata.sh.taskbar.clockDate;
            return udata;
          });
        },
        isActive: () => get_store_value(UserData$2).sh.taskbar.clockDate,
        icon: "calendar_month"
      },
      {
        caption: "12-hour clock",
        action: () => {
          UserData$2.update((udata) => {
            udata.sh.taskbar.clock12hr = !udata.sh.taskbar.clock12hr;
            return udata;
          });
        },
        isActive: () => get_store_value(UserData$2).sh.taskbar.clock12hr
      },
      SEP_ITEM,
      {
        image: AppManIcon,
        caption: "Application Manager",
        action: () => {
          openWindow("AppMan");
        }
      },
      SEP_ITEM,
      {
        icon: "settings",
        caption: "Shell settings",
        action: () => {
          openWindow("SettingsApp");
          setTimeout(() => {
            openByKey("Shell");
          });
        }
      }
    ],
    "shell-taskbar": [
      {
        image: AppManIcon,
        caption: "Application Manager",
        action: () => {
          openWindow("AppMan");
        }
      },
      SEP_ITEM,
      {
        icon: "settings",
        caption: "Shell settings",
        action: () => {
          openWindow("SettingsApp");
          setTimeout(() => {
            openByKey("Shell");
          });
        }
      }
    ],
    "startmenu-applist": [
      {
        image: AppsIcon,
        caption: "Group apps",
        isActive: () => !get_store_value(UserData$2).sh.start.noGroups,
        action() {
          UserData$2.update((udata) => {
            udata.sh.start.noGroups = !udata.sh.start.noGroups;
            return udata;
          });
        }
      }
    ]
  },
  core: true
};
const showShellShade = writable(false);
const desktopicons = "";
let LOCKED = false;
async function alignDesktopIcons(overrideLock = false) {
  Log(
    "desktop/icons.ts: alignDesktopIcons",
    `Automatically positioning desktop icons (OVERRIDE=${overrideLock}, LOCKED=${LOCKED})`
  );
  const udata = get_store_value(UserData$2);
  if (LOCKED && !overrideLock)
    return;
  if (!overrideLock)
    LOCKED = true;
  if (!udata.appdata.ArcShell)
    udata.appdata.ArcShell = {};
  await sleep(100);
  const apps2 = [...get_store_value(WindowStore)].sort((a2) => a2.info.hidden ? 1 : -1);
  const GRIDX = 80;
  const GRIDY = 85;
  const MAXX = 4;
  let offsetX = 0;
  let offsetY = 0;
  for (let i2 = 0; i2 < apps2.length; i2++) {
    const app = apps2[i2];
    if (app.core || app.id == "ExperimentsApp")
      continue;
    Log(
      "desktop/icons.ts: alignDesktopIcons",
      `Automatically positioning desktop icon for ${app.id}`
    );
    udata.appdata.ArcShell[`icon$${app.id}`] = {
      x: offsetX * GRIDX,
      y: offsetY * GRIDY
    };
    await sleep(1);
    offsetX++;
    if (offsetX >= MAXX) {
      offsetX = 0;
      offsetY++;
    }
  }
  UserData$2.set(udata);
}
async function checkDesktopIconLength() {
  const udata = get_store_value(UserData$2);
  const shell = udata.appdata["ArcShell"];
  if (!shell)
    return;
  Object.keys(shell).map((i2) => i2.startsWith("icon$")).length;
  get_store_value(WindowStore).length;
}
var e$1 = { dragStart: true }, t$1 = (e2, t2, n2) => Math.min(Math.max(e2, t2), n2), n$1 = (e2) => "string" == typeof e2, r$1 = ([e2, t2], n2, r2) => {
  const o2 = (e3, t3) => 0 === t3 ? 0 : Math.ceil(e3 / t3) * t3;
  return [o2(n2, e2), o2(r2, t2)];
};
var o$1 = (e2, t2) => e2.some((e3) => t2.some((t3) => e3.contains(t3)));
function i$1(e2, t2) {
  if (void 0 === e2)
    return;
  if (s$1(e2))
    return e2.getBoundingClientRect();
  if ("object" == typeof e2) {
    const { top: t3 = 0, left: n3 = 0, right: r2 = 0, bottom: o2 = 0 } = e2;
    return { top: t3, right: window.innerWidth - r2, bottom: window.innerHeight - o2, left: n3 };
  }
  if ("parent" === e2)
    return t2.parentNode.getBoundingClientRect();
  const n2 = document.querySelector(e2);
  if (null === n2)
    throw new Error("The selector provided for bound doesn't exists in the document.");
  return n2.getBoundingClientRect();
}
var a$1 = (e2, t2, n2) => e2.style.setProperty(t2, n2), s$1 = (e2) => e2 instanceof HTMLElement, d$1 = (d3, l2 = {}) => {
  let c2, u3, { bounds: f2, axis: g2 = "both", gpuAcceleration: h2 = true, legacyTranslate: p2 = true, transform: m3, applyUserSelectHack: w2 = true, disabled: y2 = false, ignoreMultitouch: b2 = false, recomputeBounds: v2 = e$1, grid: x2, position: E2, cancel: S2, handle: A2, defaultClass: C2 = "neodrag", defaultClassDragging: N2 = "neodrag-dragging", defaultClassDragged: D2 = "neodrag-dragged", defaultPosition: M2 = { x: 0, y: 0 }, onDragStart: B2, onDrag: $2, onDragEnd: R2 } = l2, H2 = false, L2 = 0, T2 = 0, X2 = 0, Y2 = 0, q2 = 0, P2 = 0, { x: k2, y: z2 } = E2 ? { x: (E2 == null ? void 0 : E2.x) ?? 0, y: (E2 == null ? void 0 : E2.y) ?? 0 } : M2;
  V2(k2, z2);
  let I2, U2, W2, j2, F2, G2 = "", J2 = !!E2;
  v2 = { ...e$1, ...v2 };
  let K2 = /* @__PURE__ */ new Set();
  const O2 = document.body.style, Q2 = d3.classList;
  function V2(e2 = L2, t2 = T2) {
    if (!m3) {
      if (p2) {
        let n2 = `${+e2}px, ${+t2}px`;
        return a$1(d3, "transform", h2 ? `translate3d(${n2}, 0)` : `translate(${n2})`);
      }
      return a$1(d3, "translate", `${+e2}px ${+t2}px ${h2 ? "1px" : ""}`);
    }
    const r2 = m3({ offsetX: e2, offsetY: t2, rootNode: d3 });
    n$1(r2) && a$1(d3, "transform", r2);
  }
  const Z2 = (e2, t2) => {
    const n2 = { offsetX: L2, offsetY: T2, rootNode: d3, currentNode: F2 };
    d3.dispatchEvent(new CustomEvent(e2, { detail: n2 })), t2 == null ? void 0 : t2(n2);
  };
  const _2 = addEventListener;
  _2("pointerdown", te, false), _2("pointerup", ne, false), _2("pointermove", re, false), a$1(d3, "touch-action", "none");
  const ee = () => {
    let e2 = d3.offsetWidth / U2.width;
    return isNaN(e2) && (e2 = 1), e2;
  };
  function te(e2) {
    if (y2)
      return;
    if (2 === e2.button)
      return;
    if (K2.add(e2.pointerId), b2 && K2.size > 1)
      return e2.preventDefault();
    if (v2.dragStart && (I2 = i$1(f2, d3)), n$1(A2) && n$1(S2) && A2 === S2)
      throw new Error("`handle` selector can't be same as `cancel` selector");
    if (Q2.add(C2), W2 = function(e3, t3) {
      if (!e3)
        return [t3];
      if (s$1(e3))
        return [e3];
      if (Array.isArray(e3))
        return e3;
      const n2 = t3.querySelectorAll(e3);
      if (null === n2)
        throw new Error("Selector passed for `handle` option should be child of the element on which the action is applied");
      return Array.from(n2.values());
    }(A2, d3), j2 = function(e3, t3) {
      if (!e3)
        return [];
      if (s$1(e3))
        return [e3];
      if (Array.isArray(e3))
        return e3;
      const n2 = t3.querySelectorAll(e3);
      if (null === n2)
        throw new Error("Selector passed for `cancel` option should be child of the element on which the action is applied");
      return Array.from(n2.values());
    }(S2, d3), c2 = /(both|x)/.test(g2), u3 = /(both|y)/.test(g2), o$1(j2, W2))
      throw new Error("Element being dragged can't be a child of the element on which `cancel` is applied");
    const t2 = e2.composedPath()[0];
    if (!W2.some((e3) => {
      var _a;
      return e3.contains(t2) || ((_a = e3.shadowRoot) == null ? void 0 : _a.contains(t2));
    }) || o$1(j2, [t2]))
      return;
    F2 = 1 === W2.length ? d3 : W2.find((e3) => e3.contains(t2)), H2 = true, U2 = d3.getBoundingClientRect(), w2 && (G2 = O2.userSelect, O2.userSelect = "none"), Z2("neodrag:start", B2);
    const { clientX: r2, clientY: a2 } = e2, l3 = ee();
    c2 && (X2 = r2 - k2 / l3), u3 && (Y2 = a2 - z2 / l3), I2 && (q2 = r2 - U2.left, P2 = a2 - U2.top);
  }
  function ne(e2) {
    K2.delete(e2.pointerId), H2 && (v2.dragEnd && (I2 = i$1(f2, d3)), Q2.remove(N2), Q2.add(D2), w2 && (O2.userSelect = G2), Z2("neodrag:end", R2), c2 && (X2 = L2), u3 && (Y2 = T2), H2 = false);
  }
  function re(e2) {
    if (!H2 || b2 && K2.size > 1)
      return;
    v2.drag && (I2 = i$1(f2, d3)), Q2.add(N2), e2.preventDefault(), U2 = d3.getBoundingClientRect();
    let n2 = e2.clientX, o2 = e2.clientY;
    const a2 = ee();
    if (I2) {
      const e3 = { left: I2.left + q2, top: I2.top + P2, right: I2.right + q2 - U2.width, bottom: I2.bottom + P2 - U2.height };
      n2 = t$1(n2, e3.left, e3.right), o2 = t$1(o2, e3.top, e3.bottom);
    }
    if (Array.isArray(x2)) {
      let [e3, t2] = x2;
      if (isNaN(+e3) || e3 < 0)
        throw new Error("1st argument of `grid` must be a valid positive number");
      if (isNaN(+t2) || t2 < 0)
        throw new Error("2nd argument of `grid` must be a valid positive number");
      let i2 = n2 - X2, s2 = o2 - Y2;
      [i2, s2] = r$1([e3 / a2, t2 / a2], i2, s2), n2 = X2 + i2, o2 = Y2 + s2;
    }
    c2 && (L2 = Math.round((n2 - X2) * a2)), u3 && (T2 = Math.round((o2 - Y2) * a2)), k2 = L2, z2 = T2, Z2("neodrag", $2), V2();
  }
  return { destroy: () => {
    const e2 = removeEventListener;
    e2("pointerdown", te, false), e2("pointerup", ne, false), e2("pointermove", re, false);
  }, update: (t2) => {
    var _a, _b;
    g2 = t2.axis || "both", y2 = t2.disabled ?? false, b2 = t2.ignoreMultitouch ?? false, A2 = t2.handle, f2 = t2.bounds, v2 = t2.recomputeBounds ?? e$1, S2 = t2.cancel, w2 = t2.applyUserSelectHack ?? true, x2 = t2.grid, h2 = t2.gpuAcceleration ?? true, p2 = t2.legacyTranslate ?? true, m3 = t2.transform;
    const n2 = Q2.contains(D2);
    Q2.remove(C2, D2), C2 = t2.defaultClass ?? "neodrag", N2 = t2.defaultClassDragging ?? "neodrag-dragging", D2 = t2.defaultClassDragged ?? "neodrag-dragged", Q2.add(C2), n2 && Q2.add(D2), J2 && (k2 = L2 = ((_a = t2.position) == null ? void 0 : _a.x) ?? L2, z2 = T2 = ((_b = t2.position) == null ? void 0 : _b.y) ?? T2, V2());
  } };
};
function create_fragment$12(ctx) {
  let button;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let p2;
  let t1_value = (
    /*app*/
    ctx[0].info.name + ""
  );
  let t1;
  let button_data_id_value;
  let draggable_action;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      p2 = element("p");
      t1 = text(t1_value);
      attr(img, "draggable", false);
      if (!src_url_equal(img.src, img_src_value = getOriginalIcon(
        /*app*/
        ctx[0].id
      ) || /*app*/
      ctx[0].info.icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*app*/
      ctx[0].info.name);
      attr(p2, "class", "name");
      attr(button, "class", "desktopIcon");
      attr(button, "data-contextmenu", "desktopicon-app");
      attr(button, "data-id", button_data_id_value = /*app*/
      ctx[0].id);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, p2);
      append(p2, t1);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "dblclick",
            /*open*/
            ctx[3]
          ),
          action_destroyer(draggable_action = d$1.call(null, button, {
            grid: (
              /*$UserData*/
              ctx[2].sh.desktop.noIconGrid ? null : [40, 42.5]
            ),
            bounds: (
              /*$UserData*/
              ctx[2].sh.desktop.noIconGrid ? { bottom: 80, left: 10, right: 10, top: 10 } : { bottom: 110, left: 0, right: 80, top: 0 }
            ),
            position: (
              /*position*/
              ctx[1]
            ),
            disabled: (
              /*$UserData*/
              ctx[2].sh.desktop.lockIcons
            )
          })),
          listen(
            button,
            "neodrag:start",
            /*startDrag*/
            ctx[5]
          ),
          listen(
            button,
            "neodrag:end",
            /*endDrag*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*app*/
      1 && !src_url_equal(img.src, img_src_value = getOriginalIcon(
        /*app*/
        ctx2[0].id
      ) || /*app*/
      ctx2[0].info.icon)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*app*/
      1 && img_alt_value !== (img_alt_value = /*app*/
      ctx2[0].info.name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*app*/
      1 && t1_value !== (t1_value = /*app*/
      ctx2[0].info.name + ""))
        set_data(t1, t1_value);
      if (dirty & /*app*/
      1 && button_data_id_value !== (button_data_id_value = /*app*/
      ctx2[0].id)) {
        attr(button, "data-id", button_data_id_value);
      }
      if (draggable_action && is_function(draggable_action.update) && dirty & /*$UserData, position*/
      6)
        draggable_action.update.call(null, {
          grid: (
            /*$UserData*/
            ctx2[2].sh.desktop.noIconGrid ? null : [40, 42.5]
          ),
          bounds: (
            /*$UserData*/
            ctx2[2].sh.desktop.noIconGrid ? { bottom: 80, left: 10, right: 10, top: 10 } : { bottom: 110, left: 0, right: 80, top: 0 }
          ),
          position: (
            /*position*/
            ctx2[1]
          ),
          disabled: (
            /*$UserData*/
            ctx2[2].sh.desktop.lockIcons
          )
        });
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$_($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(2, $UserData = $$value));
  let { app } = $$props;
  let position = { x: 0, y: 0 };
  function open() {
    openWindow(app.id);
  }
  function updatePos() {
    const pos = getAppPreference("ArcShell", `icon$${app.id}`);
    $$invalidate(1, position = pos || { x: 0, y: 0 });
  }
  onMount(updatePos);
  UserData$2.subscribe(updatePos);
  function endDrag(e2) {
    const { offsetX, offsetY } = e2.detail;
    setAppPreference("ArcShell", `icon$${app.id}`, { x: offsetX, y: offsetY });
  }
  function startDrag(e2) {
    ({ x: e2.detail.offsetX, y: e2.detail.offsetY });
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [app, position, $UserData, open, endDrag, startDrag];
}
class DesktopIcon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$_, create_fragment$12, safe_not_equal, { app: 0 });
  }
}
function get_each_context$c(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2];
  return child_ctx;
}
function create_if_block$y(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*store*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$c(get_each_context$c(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "desktopIcons");
      toggle_class(
        div,
        "launcher",
        /*$UserData*/
        ctx[2].sh.taskbar.isLauncher
      );
      toggle_class(
        div,
        "undocked-launcher",
        /*$UserData*/
        ctx[2].sh.taskbar.isLauncher && !/*$UserData*/
        ctx[2].sh.taskbar.docked
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*store*/
      1) {
        each_value = ensure_array_like(
          /*store*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$c(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$c(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*$UserData*/
      4) {
        toggle_class(
          div,
          "launcher",
          /*$UserData*/
          ctx2[2].sh.taskbar.isLauncher
        );
      }
      if (!current || dirty & /*$UserData*/
      4) {
        toggle_class(
          div,
          "undocked-launcher",
          /*$UserData*/
          ctx2[2].sh.taskbar.isLauncher && !/*$UserData*/
          ctx2[2].sh.taskbar.docked
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$c(ctx) {
  let desktopicon;
  let current;
  desktopicon = new DesktopIcon({ props: { app: (
    /*app*/
    ctx[5]
  ) } });
  return {
    c() {
      create_component(desktopicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(desktopicon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const desktopicon_changes = {};
      if (dirty & /*store*/
      1)
        desktopicon_changes.app = /*app*/
        ctx2[5];
      desktopicon.$set(desktopicon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(desktopicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(desktopicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(desktopicon, detaching);
    }
  };
}
function create_fragment$11(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*loading*/
  ctx[1] && /*$UserData*/
  ctx[2].sh.desktop.icons && create_if_block$y(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*loading*/
      ctx2[1] && /*$UserData*/
      ctx2[2].sh.desktop.icons) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*loading, $UserData*/
          6) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$y(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$Z($$self, $$props, $$invalidate) {
  let $WindowStore;
  let $UserData;
  component_subscribe($$self, WindowStore, ($$value) => $$invalidate(3, $WindowStore = $$value));
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(2, $UserData = $$value));
  let store = [];
  let loading = false;
  async function update2() {
    if (!$UserData.appdata["ArcShell"] || !Object.keys($UserData.appdata["ArcShell"]).join(",").includes("icon$")) {
      $$invalidate(1, loading = true);
      await alignDesktopIcons();
      setTimeout(
        () => {
          $$invalidate(1, loading = false);
        },
        100
      );
    }
    await checkDesktopIconLength();
    const len = store.length;
    const newStore = $WindowStore.filter((a2) => isPopulatable(a2));
    if (newStore.length !== len) {
      $$invalidate(1, loading = true);
      $$invalidate(0, store = newStore);
      setTimeout(() => {
        $$invalidate(1, loading = false);
      });
    }
  }
  onMount(update2);
  WindowStore.subscribe(update2);
  UserData$2.subscribe(update2);
  return [store, loading, $UserData];
}
class DesktopIcons extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Z, create_fragment$11, safe_not_equal, {});
  }
}
const snapzones = "";
function create_fragment$10(ctx) {
  let div;
  let desktopicons2;
  let current;
  desktopicons2 = new DesktopIcons({});
  return {
    c() {
      div = element("div");
      create_component(desktopicons2.$$.fragment);
      attr(div, "class", "wallpaper fullscreen");
      set_style(div, "background-image", "url(" + /*url*/
      ctx[0] + ")");
      attr(div, "data-contextmenu", "shell-wallpaper");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(desktopicons2, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*url*/
      1) {
        set_style(div, "background-image", "url(" + /*url*/
        ctx2[0] + ")");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(desktopicons2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(desktopicons2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(desktopicons2);
    }
  };
}
function instance$Y($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(2, $UserData = $$value));
  let url = "";
  let previous = "";
  UserData$2.subscribe(async () => {
    const wallpaper = $UserData.sh.desktop.wallpaper;
    if (previous == wallpaper)
      return;
    previous = wallpaper;
    const u3 = (await getWallpaper(wallpaper)).url;
    if (u3 != url)
      $$invalidate(0, url = u3);
  });
  return [url];
}
class Wallpaper extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Y, create_fragment$10, safe_not_equal, {});
  }
}
const WallpaperContext = {
  "shell-wallpaper": [
    {
      caption: "Show desktop icons",
      action: () => {
        UserData$2.update((udata) => {
          udata.sh.desktop.icons = !udata.sh.desktop.icons;
          return udata;
        });
      },
      icon: "apps",
      isActive: () => get_store_value(UserData$2).sh.desktop.icons
    },
    {
      caption: "Align icons to grid",
      action: () => {
        UserData$2.update((udata) => {
          udata.sh.desktop.noIconGrid = !udata.sh.desktop.noIconGrid;
          return udata;
        });
      },
      icon: "grid_4x4",
      isActive: () => !get_store_value(UserData$2).sh.desktop.noIconGrid
    },
    {
      caption: "Lock desktop icons",
      action: () => {
        UserData$2.update((udata) => {
          udata.sh.desktop.lockIcons = !udata.sh.desktop.lockIcons;
          return udata;
        });
      },
      icon: "lock",
      isActive: () => get_store_value(UserData$2).sh.desktop.lockIcons
    },
    {
      caption: "Reset icon alignment",
      action: () => {
        errorMessage(
          "Reset icon alignment?",
          "This will arrange the desktop icons back to their default positions. Do you want to continue?",
          DesktopIcon$1,
          null,
          {
            caption: "Reset",
            action() {
              alignDesktopIcons(true);
            },
            suggested: true
          },
          { caption: "Cancel", action() {
          } }
        );
      },
      icon: "undo"
    },
    SEP_ITEM,
    {
      caption: "File Manager",
      action: () => {
        openWindow("FileManager");
      },
      image: FileManagerIcon
    },
    {
      caption: "Application Manager",
      action: () => {
        openWindow("AppMan");
      },
      image: AppManIcon
    },
    {
      caption: "App settings",
      action: () => {
        openByKey("Apps");
      },
      image: AppsIcon
    },
    SEP_ITEM,
    {
      caption: "Shut down",
      action: shutdown,
      image: ShutdownIcon
    },
    {
      caption: "Restart",
      action: () => restart(false),
      image: RestartIcon
    },
    SEP_ITEM,
    {
      caption: "Themes",
      action: () => {
        openByKey("Themes");
      },
      image: ThemesIcon
    },
    {
      caption: "Wallpaper",
      action: () => {
        openByKey("Wallpaper");
      },
      image: DesktopIcon$1
    },
    {
      caption: "Visuals",
      action: () => {
        openByKey("Visuals");
      },
      image: PersonalizationIcon
    }
  ],
  "desktopicon-app": [
    {
      caption: "Open",
      action(window2, data, scope) {
        openWindow(data.id);
      },
      icon: "launch"
    },
    {
      image: ShutdownIcon,
      caption: "Kill",
      action(window2, data, scope) {
        closeWindow(data.id);
      }
    },
    SEP_ITEM,
    {
      image: TrashIcon,
      caption: "Disable",
      action(window2, data, scope) {
        disableApp(data.id);
      }
    },
    SEP_ITEM,
    {
      image: TestAppIcon,
      caption: "App Info",
      action(window2, data, scope) {
        AppInfoId.set(data.id);
        openWindow("AppInfo");
      }
    }
  ]
};
const DesktopWallpaper = {
  info: {
    name: "Wallpaper",
    description: "The ArcOS wallpaper",
    builtin: true,
    version: ArcOSVersion,
    author: "ArcOS Team",
    icon: DesktopIcon$1,
    custom: true,
    appGroup: "coreApps"
  },
  size: { w: NaN, h: NaN },
  pos: { x: 0, y: 0 },
  minSize: { w: NaN, h: NaN },
  maxSize: { w: NaN, h: NaN },
  controls: { min: false, max: false, cls: false },
  state: {
    headless: true,
    resizable: false,
    windowState: { min: false, max: false, fll: true }
  },
  content: Wallpaper,
  glass: false,
  events: {},
  contextMenu: WallpaperContext,
  core: true
};
const DefaultApps = {
  ErrCre: ErrorCreator2,
  /** Visible Applications */
  FileManager: FileBrowserApp,
  TextEditor,
  CalculatorApp,
  MessagingApp: MessagingApp2,
  SettingsApp: SettingsApp2,
  AppMan: AppManager2,
  LoggerApp,
  ArcTerm: ArcTerm$1,
  DonutApp,
  LightsOff: LightsOff2,
  ArcShell,
  /** Hidden applications */
  Exit: Exit2,
  AppInfo: AppInfo$1,
  ImageViewer,
  OpenWithApp,
  MarkDownViewer: MarkDownViewer2,
  MediaPlayerApp,
  DesktopWallpaper,
  BugReports: BugReports2,
  ExperimentsApp,
  UpdateNotice: UpdateNotice2,
  TwentyFourtyEight,
  IconLibrary: IconLibrary2
};
const SystemApps = [
  "AppMan",
  "Exit",
  "SettingsApp",
  "PfpSelector",
  "AppInfo",
  "LoggerApp",
  "FileManager",
  "ArcShell",
  "DesktopWallpaper"
];
function disableApp(id) {
  Log("enabling.ts: disableApp", `Disabling app ${id}`);
  if (SystemApps.includes(id)) {
    return errorMessage(
      "Can't disable application",
      `App "${id}" is a system application. System applications are core to ArcOS and cannot be disabled without breaking certain functionality.`,
      null,
      "AppLogic",
      { caption: "Okay", action: () => {
      }, suggested: true }
    );
  }
  UserData$2.update((udata) => {
    if (!udata.disabledApps.includes(id))
      udata.disabledApps.push(id);
    return udata;
  });
  WindowStore.update((ws) => {
    for (let i2 = 0; i2 < ws.length; i2++) {
      if (ws[i2].id == id)
        ws[i2].disabled = true;
    }
    return ws;
  });
  updateStores();
}
function enableApp(id) {
  Log("enabling.ts: enableApp", `Enabling app ${id}`);
  UserData$2.update((udata) => {
    for (let i2 = 0; i2 < udata.disabledApps.length; i2++) {
      if (udata.disabledApps[i2] == id)
        udata.disabledApps.splice(i2, 1);
    }
    return udata;
  });
  WindowStore.update((ws) => {
    for (let i2 = 0; i2 < ws.length; i2++) {
      if (ws[i2].id == id)
        ws[i2].disabled = false;
    }
    return ws;
  });
  updateStores();
}
function findAppToOpen(mime) {
  Log(
    `fs/open.ts: findAppToOpen`,
    `Compiling a list of file handlers that can open mimtype "${mime}"...`,
    LogLevel.info
  );
  const ids = [];
  const ws = get_store_value(WindowStore);
  for (let i2 = 0; i2 < ws.length; i2++) {
    const window2 = ws[i2];
    if (!window2.fileMimes)
      continue;
    const mimes2 = window2.fileMimes.join("||").toLowerCase();
    if (mimes2.includes(mime))
      ids.push(ws[i2].id);
  }
  return ids;
}
function findAppToOpenByExt(filename) {
  const ids = [];
  const ws = get_store_value(WindowStore);
  for (let i2 = 0; i2 < ws.length; i2++) {
    const window2 = ws[i2];
    if (!window2.fileExts)
      continue;
    for (let j2 = 0; j2 < window2.fileExts.length; j2++) {
      if (filename.endsWith(window2.fileExts[j2]))
        ids.push(window2.id);
    }
  }
  return ids;
}
function findLoaderToOpen(filename) {
  let result = [];
  const loaders = Object.entries(FileLoaders);
  for (let i2 = 0; i2 < loaders.length; i2++) {
    const loader = loaders[i2];
    const data = loader[1];
    for (let j2 = 0; j2 < data.extensions.length; j2++) {
      if (filename.endsWith(data.extensions[j2]))
        result.push(data);
    }
    if (!data.extensions.length)
      result.push(data);
  }
  return result;
}
function getAllFileHandlers() {
  Log(
    `fs/open.ts: getAllFileHandlers`,
    `Compiling a list of file handler IDs...`,
    LogLevel.info
  );
  const ids = [];
  const ws = get_store_value(WindowStore);
  for (let i2 = 0; i2 < ws.length; i2++) {
    if (ws[i2].fileMimes)
      ids.push(ws[i2].id);
  }
  return ids;
}
async function openWithDialog(file) {
  if (isDisabled("OpenWithApp")) {
    return errorMessage(
      "Can't open file",
      `The OpenWithApp application is disabled, so you can't choose an app to open ${file.name}.`,
      null,
      null,
      { caption: "Okay", action() {
      }, suggested: true },
      {
        caption: "Enable OpenWithApp",
        async action() {
          enableApp("OpenWithApp");
          OpenWithFile.set(file);
          await sleep(10);
          openWindow("OpenWithApp");
        }
      }
    );
  }
  Log(
    `fs/open.ts: openWithDialog`,
    `Opening ArcOS.OpenWith for "${file.name}"`,
    LogLevel.info
  );
  OpenWithFile.set(file);
  await sleep(10);
  openWindow("OpenWithApp");
}
function openWith(appId, data, openany) {
  Log(
    `fs/open.ts: openWith`,
    `Opening ${data.name} with ArcOS.${appId}`,
    LogLevel.info
  );
  const ws = get_store_value(WindowStore);
  for (let i2 = 0; i2 < ws.length; i2++) {
    const window2 = ws[i2];
    if (!window2.fileMimes || !window2.fileMimes.includes(data.mime) && !openany || appId != window2.id)
      continue;
    window2.openedFile = data;
    openWindow(appId);
    focusedWindowId.set(appId);
    setTimeout(() => {
      if (window2.events && window2.events.openFile)
        window2.events.openFile(window2);
    }, 10);
    return true;
  }
  return false;
}
async function openUserFile(file) {
  Log(
    `fs/open.ts: openUserFile`,
    `Converting "${file.filename}": UserFile -> ArcFile: to make openable`,
    LogLevel.info
  );
  let data = await partialFileToComplete(file);
  const apps2 = [
    ...findAppToOpenByExt(file.filename),
    ...findAppToOpen(file.mime)
  ];
  const loaders = findLoaderToOpen(file.filename);
  if (!(apps2.length > 0) && !(loaders.length > 1))
    return data;
  if (loaders.length == 2) {
    loaders[0].loader(data);
    return true;
  }
  if (apps2.length > 0)
    return openWith(apps2[0], data) || data;
  return true;
}
function DirectoryNotFound(path) {
  createOverlayableError(
    {
      title: "Directory not found",
      message: `ArcOS was unable to open <code>${path}</code>: the directory doesn't exist.`,
      buttons: [
        {
          caption: "Go Home",
          action() {
            fbClass.goToDirectory("./");
          },
          suggested: true
        }
      ],
      image: ErrorIcon
    },
    "FileManager"
  );
}
function DeleteFailed() {
  createOverlayableError(
    {
      title: "Unable to delete item",
      message: "ArcAPI was not able to delete the item from the file system. A permission error may have occured. Please try again later.",
      buttons: [{ caption: "OK", action() {
      }, suggested: true }],
      image: TrashIcon
    },
    "FileManager"
  );
}
function FileOpenFailed(file, x2) {
  createOverlayableError(
    {
      title: `Unable to open ${file.filename}`,
      message: "You don't have an app or handler that can open this type of file.",
      buttons: [
        {
          caption: "Close",
          action: () => {
          },
          suggested: true
        },
        {
          caption: "Open With...",
          action: () => this.openWithAny(x2)
        }
      ],
      image: FileIcon
    },
    "FileManager"
  );
}
function OpenCancelled() {
  createOverlayableError(
    {
      title: "Open cancelled",
      message: "The opening procedure was cancelled by the user.",
      buttons: [{ caption: "OK", action() {
      }, suggested: true }],
      image: ErrorIcon
    },
    "FileManager"
  );
}
const fbState = writable({
  currentDir: "./",
  dirContents: defaultDirectory,
  selectedFilename: null,
  openingFile: null,
  deletingFilename: null,
  uploadFile: null,
  openCancelled: false,
  refreshing: false,
  uploadProgress: 0,
  cuttingFilename: null,
  copyingFilename: null,
  home: false,
  populating: false
});
fbState.subscribe((v2) => {
  if (!v2 || !v2.openCancelled)
    return;
  OpenCancelled();
  fbState.update((v22) => {
    v22.openCancelled = false;
    return v22;
  });
});
class FileBrowserClass {
  async refresh(clearFirst = true) {
    Log(
      "FileBrowser: refresh",
      "Refreshing current directory contents",
      LogLevel.info
    );
    const state = get_store_value(fbState);
    state.refreshing = true;
    fbState.set(state);
    if (clearFirst) {
      state.dirContents = defaultDirectory;
      state.selectedFilename = null;
      fbState.set(state);
    }
    const cd = get_store_value(fbState).currentDir;
    const req = await getDirectory(cd);
    if (!req) {
      DirectoryNotFound(cd);
    }
    state.dirContents = req || { ...defaultDirectory, scopedPath: cd };
    state.refreshing = false;
    fbState.set(state);
  }
  async goToDirectory(path, disableHome = true) {
    Log("FileBrowser: goToDirectory", `Navigating to "${path}"`);
    fbState.update((state) => {
      state.selectedFilename;
      state.currentDir = path;
      ArcSoundBus.playSound("arcos.click");
      if (disableHome)
        state.home = false;
      return state;
    });
    await this.refresh();
  }
  async deleteItem(name, path) {
    fbState.update((v2) => {
      v2.deletingFilename = name;
      return v2;
    });
    showOverlay("deletingItem", "FileManager");
    const valid = await deleteItem(path);
    if (!valid)
      DeleteFailed();
    fbState.update((v2) => {
      v2.selectedFilename = null;
      return v2;
    });
    fbClass.refresh();
    setTimeout(() => {
      hideOverlay("deletingItem", "FileManager");
    }, 100);
  }
  setOpeningFile(file) {
    fbState.update((v2) => {
      v2.openingFile = file;
      return v2;
    });
  }
  async openFile(file) {
    this.setOpeningFile(file);
    showOverlay("openingFile", "FileManager");
    let openResult = await openUserFile(file);
    hideOverlay("openingFile", "FileManager");
    this.setOpeningFile(null);
    if (openResult != true) {
      const x2 = openResult;
      FileOpenFailed(file, x2);
    }
    openResult = null;
  }
  openWithAny(arc) {
    openWithDialog({ ...arc, anymime: true });
  }
  async openWith(file) {
    this.setOpeningFile(file);
    showOverlay("openingFile", "FileManager");
    const data = await partialFileToComplete(file);
    this.openWithAny(data);
    hideOverlay("openingFile", "FileManager");
    this.setOpeningFile(null);
  }
}
const fbClass = new FileBrowserClass();
const abortFileReader = writable(false);
async function readFile(path) {
  Log(
    "fs/file.ts: readFile",
    `Requesting file contents of "${path}" from ArcAPI`,
    LogLevel.info
  );
  const server = get_store_value(ConnectedServer);
  const authCode = getAuthcode(getServer());
  if (!server)
    return false;
  const init2 = {
    headers: {
      Authorization: `Bearer ${get_store_value(UserToken)}`
    }
  };
  const controller = new AbortController();
  const params = generateParamStr({ ac: authCode, path: toBase64(path) });
  try {
    let req = await fetch(`${server}/fs/file/get${params}`, {
      ...init2,
      signal: controller.signal
    });
    abortFileReader.set(false);
    abortFileReader.subscribe((v2) => {
      if (!v2)
        return;
      Log(
        "fs/file.ts: readFile",
        `Aborting readFile for "${path}" as requested by the user...`,
        LogLevel.error
      );
      controller.abort();
      fbState.update((v22) => {
        v22.openCancelled = true;
        return v22;
      });
      abortFileReader.set(false);
    });
    if (req.status != 200)
      return false;
    const x2 = await req.blob();
    req = null;
    return await x2.arrayBuffer();
  } catch {
    return false;
  }
}
async function writeFile(path, data) {
  Log("fs/directory.ts: writeFile", `Creating ${path}`);
  const server = get_store_value(ConnectedServer);
  const authCode = getAuthcode(getServer());
  if (!server)
    return false;
  const params = generateParamStr({ path: toBase64(path), ac: authCode });
  const req = await axios$1.post(`${server}/fs/file/write${params}`, data, {
    headers: {
      Authorization: `Bearer ${get_store_value(UserToken)}`
    },
    onUploadProgress(progress) {
      const perc = progress.loaded / progress.total * 100;
      fbState.update((v2) => {
        v2.uploadProgress = perc;
        return v2;
      });
    }
  });
  return req.status == 200;
}
async function getPartialFile(path) {
  const parent = getParentDirectory(path);
  const dir = await getDirectory(parent);
  if (!dir)
    return false;
  return dir.files.filter((f2) => f2.scopedPath == path)[0];
}
function sortFiles(dir) {
  if (!dir)
    return [];
  return dir.sort(
    (a2, b2) => a2.filename.toLowerCase() > b2.filename.toLowerCase() ? 1 : -1
  );
}
class ArcTermConfig {
  constructor(e2, t2) {
    __publicField(this, "env");
    __publicField(this, "term");
    __publicField(this, "configPath", "./arcterm.conf");
    __publicField(this, "configKeys", [
      "prompt",
      "greeting",
      "logo",
      "promptColor",
      "gooseBumps"
    ]);
    Log(
      `ArcTerm ${t2.referenceId}`,
      `Creating new ArcTermConfig`,
      LogLevel.info
    );
    this.env = e2;
    this.term = t2;
    this.loadConfigFile();
  }
  getConfig() {
    const obj = {};
    for (let i2 = 0; i2 < this.configKeys.length; i2++) {
      const k2 = this.configKeys[i2];
      obj[k2] = this.env[k2];
    }
    return obj;
  }
  loadConfig(json) {
    for (let i2 = 0; i2 < this.configKeys.length; i2++) {
      const k2 = this.configKeys[i2];
      const exists = this.env[k2] != null && json;
      const isType = typeof this.env[k2] == typeof json[k2];
      if (exists && isType)
        this.env[k2] = json[k2];
    }
  }
  async loadConfigFile() {
    Log(
      `ArcTerm ${this.term.referenceId}`,
      `config.loadConfigFile: Getting ${this.configPath}`
    );
    if (!get_store_value(UserData$2))
      return;
    const file = await readFile(this.configPath);
    if (!file)
      return this.writeConfig();
    const d3 = arrayToText(file);
    let json;
    try {
      json = JSON.parse(d3);
    } catch {
      json = {};
    }
    this.loadConfig(json);
  }
  async writeConfig() {
    Log(
      `ArcTerm ${this.term.referenceId}`,
      `config.writeConfig: Writing ${this.configPath}`
    );
    const data = {};
    for (let i2 = 0; i2 < this.configKeys.length; i2++) {
      const k2 = this.configKeys[i2];
      if (k2 != "gooseBumps" || typeof this.env[k2] === "boolean" && this.env[k2] == true)
        data[k2] = this.env[k2];
    }
    const blob = new Blob([JSON.stringify(data, null, 2)], {
      type: "application/json"
    });
    await writeFile(this.configPath, blob);
  }
}
class ArcTermEnv {
  constructor(term) {
    __publicField(this, "config");
    __publicField(this, "prompt", "[$username]: [~/$pwd] $ ");
    __publicField(this, "promptColor", "green");
    __publicField(this, "greeting", `ArcTerm & ArcOS v${ArcOSVersion}

Licensed under GPLv3. Created by the ArcOS team.`);
    __publicField(this, "logo", true);
    __publicField(this, "gooseBumps", false);
    Log(
      `ArcTerm ${term.referenceId}`,
      `Creating new ArcTermEnv`,
      LogLevel.info
    );
    this.config = new ArcTermConfig(this, term);
  }
}
function initError(id) {
  createOverlayableError(
    {
      title: "Can't initialize terminal",
      message: "The terminal instance is missing a valid target element. Please restart and try again.",
      buttons: [
        {
          caption: "Close",
          action() {
            closeWindow(id);
          },
          suggested: true
        }
      ],
      image: ArcTermIcon
    },
    id
  );
}
class ArcTermInput {
  constructor(T2) {
    __publicField(this, "lockInput", false);
    __publicField(this, "target");
    __publicField(this, "env");
    __publicField(this, "term");
    __publicField(this, "current");
    Log(`ArcTerm ${T2.referenceId}`, `Creating new ArcTermInput`);
    this.target = T2.target;
    this.env = T2.env;
    this.term = T2;
    this.commandLoop();
  }
  commandLoop() {
    Log(
      `ArcTerm ${this.term.referenceId}`,
      `input.commandLoop: Starting command loop`
    );
    setInterval(() => {
      if (this.lockInput)
        return;
      this.lock();
      const prompt = this.createPrompt();
      if (!prompt)
        return;
      this.target.append(prompt);
    });
  }
  lock() {
    this.lockInput = true;
  }
  unlock() {
    this.lockInput = false;
  }
  getPrompt() {
    return this.term.vars.replace(this.env.prompt);
  }
  createPrompt() {
    Log(`ArcTerm ${this.term.referenceId}`, `input.createPrompt`);
    if (this.current)
      this.current.disabled = true;
    if (!this.term.std)
      return;
    const wrap = document.createElement("div");
    const inner = document.createElement("div");
    const input = document.createElement("input");
    wrap.className = "prompt";
    if (this.term.std.verbose)
      this.term.std.writeColor(
        this.getPrompt(),
        this.env.promptColor,
        "white",
        true,
        wrap
      );
    input.id = `input#${Math.floor(Math.random() * 1e9)}`;
    input.spellcheck = false;
    input.addEventListener("keydown", (e2) => this.processInputEvent(e2, input));
    this.current = input;
    inner.className = "inner";
    inner.append(input);
    wrap.append(inner);
    setTimeout(() => {
      if (this.term.app && get_store_value(focusedWindowId) == this.term.app.id)
        input.focus();
    });
    return wrap;
  }
  async processInputEvent(e2, input) {
    if (!e2 || !input)
      return;
    const split = input.value.split("&&");
    const key2 = e2.key.toLowerCase();
    switch (key2) {
      case "enter":
        this.processCommands(split);
        break;
      case "f2":
        this.restorePreviousCommand();
        break;
    }
  }
  restorePreviousCommand() {
    Log(`ArcTerm ${this.term.referenceId}`, `input.restorePreviousCommand`);
    const hist = this.term.commandHandler.history;
    const latest = hist[hist.length - 1];
    if (!this.current || !latest)
      return;
    this.current.value = latest;
  }
  async processCommands(split, file = "") {
    await sleep(0);
    for (let i2 = 0; i2 < split.length; i2++) {
      const str = this.term.vars.replace(split[i2].trim());
      const args = str.split(" ");
      const cmd = args[0];
      if (cmd.trim() == "exit" && file)
        return false;
      if (cmd.startsWith("#") || !cmd)
        continue;
      args.shift();
      const success = await this.term.commandHandler.evaluate(
        cmd,
        args,
        !!file
      );
      if (!success) {
        return false;
      }
      this.lock();
      await sleep(0);
    }
    this.unlock();
    return true;
  }
}
class ArcTermScripts {
  constructor(term) {
    __publicField(this, "term");
    Log(`ArcTerm ${term.referenceId}`, `Creating new ArcTermScripts`);
    this.term = term;
  }
  async detectScript(directory, cmd) {
    Log(
      `ArcTerm ${this.term.referenceId}`,
      `scripts.detectScript: Detecting ${cmd} in ${directory}`
    );
    const dir = await getDirectory(directory);
    if (!dir)
      return null;
    const files = dir.files;
    for (let i2 = 0; i2 < files.length; i2++) {
      const name = files[i2].filename;
      const path = files[i2].scopedPath;
      if (name.startsWith(cmd) && await this.isScriptFile(path))
        return path;
    }
  }
  async isScriptFile(path) {
    const file = await readFile(path);
    if (!file)
      return false;
    const d3 = arrayToText(file);
    const split = d3.split("\n");
    return split[0].startsWith("#!arcterm");
  }
  async runScriptFile(path) {
    Log(
      `ArcTerm ${this.term.referenceId}`,
      `scripts.runScriptFile: running ${path}`
    );
    const contents = await readFile(path);
    if (!contents)
      return Log(
        `ArcTerm ${this.term.referenceId}`,
        `scripts.runScriptFile: Error reading file ${path}`,
        LogLevel.error
      );
    const d3 = this.term.sect.parse(arrayToText(contents));
    const parts = d3.split("\n").filter((l2) => !!l2);
    await this.term.input.processCommands(parts, path);
  }
}
class ArcTermSections {
  constructor(term) {
    __publicField(this, "term");
    __publicField(this, "_sections", {});
    Log(`ArcTerm ${term.referenceId}`, `Creating new ArcTermSections`);
    this.term = term;
  }
  parse(text2) {
    Log(
      `ArcTerm ${this.term.referenceId}`,
      `sect.parse: Parsing sections from ${text2.length} bytes`
    );
    const input = `${text2}`;
    const regex = /sect \((?<name>\w+)\) {\n(?<cmds>.*?)\n}/gs;
    let match;
    while ((match = regex.exec(input)) !== null) {
      const group = match.groups;
      if (!group)
        continue;
      if (this._sections[group.name])
        Log(
          `ArcTerm ${this.term.referenceId}`,
          `sect.parse: Overwriting ${group.name}`,
          LogLevel.warn
        );
      const commands = group.cmds.split("\n").map((a2) => a2.trim());
      text2 = text2.replace(match[0], "");
      this._sections[group.name] = commands;
    }
    return text2;
  }
  get(name) {
    return this._sections[name] || false;
  }
}
class ArcTermStdSelect {
  constructor(std, color) {
    __publicField(this, "std");
    __publicField(this, "_sent", writable(false));
    __publicField(this, "_options", []);
    __publicField(this, "_index", 0);
    __publicField(this, "_elements", []);
    __publicField(this, "_color");
    Log(
      `ArcTerm ${std.term.referenceId}`,
      `Creating new ArcTermStdSelect`,
      LogLevel.info
    );
    this._color = color || "blue";
    this.std = std;
  }
  getStr(index, string) {
    const current = index == this._index;
    const sent = get_store_value(this._sent) && current;
    const prefix = current ? "> [" : "  ";
    const suffix = `${current ? "]" : ""}${sent ? " <" : ""}`;
    return `${prefix}${index + 1}. ${string}${suffix}`;
  }
  draw() {
    for (let i2 = 0; i2 < this._elements.length; i2++) {
      const element2 = this._elements[i2];
      this.std.updateColor(
        element2,
        this.getStr(i2, this._options[i2]),
        this._color,
        "gray"
      );
    }
  }
  keyDown(e2) {
    const app = this.std.term.app;
    if (!e2.key || get_store_value(this._sent) || app && get_store_value(focusedWindowId) !== app.id)
      return;
    const key2 = e2.key.toLowerCase();
    const min = 0;
    const max = this._options.length - 1;
    switch (key2) {
      case "arrowup":
        this._index--;
        if (this._index < min)
          this._index = min;
        break;
      case "arrowdown":
        this._index++;
        if (this._index > max)
          this._index = max;
        break;
      case "escape":
        this._index = min;
      case "enter":
        document.removeEventListener("keydown", this.keyDown);
        this._sent.set(true);
    }
    this.draw();
  }
  async create(options) {
    if (get_store_value(this._sent))
      return 0;
    await sleep(10);
    this._index = 0;
    this._options = options;
    for (let i2 = 0; i2 < options.length; i2++) {
      const str = this.getStr(i2, this._options[i2]);
      const element2 = this.std.writeColor(str, this._color, "gray");
      this._elements.push(element2);
    }
    document.addEventListener("keydown", (e2) => this.keyDown(e2));
    return new Promise((resolve) => {
      this._sent.subscribe((v2) => v2 && resolve(this._index));
    });
  }
}
class ArcTermStd {
  constructor(parent) {
    __publicField(this, "target");
    __publicField(this, "app");
    __publicField(this, "term");
    __publicField(this, "env");
    __publicField(this, "verbose", true);
    Log(
      `ArcTerm ${parent.referenceId}`,
      `Creating new ArcTermStd`,
      LogLevel.info
    );
    this.target = parent.target;
    this.app = parent.app;
    this.term = parent;
    this.env = parent.env;
  }
  write(str, target = this.target) {
    const el = this.writeLine(str, true, target);
    return el;
  }
  writeLine(str, inline2 = false, target = this.target) {
    const el = document.createElement("div");
    el.className = "part";
    if (inline2)
      el.className += " inline";
    el.innerText = str;
    target.appendChild(el);
    return el;
  }
  writeSeparator(length) {
    this.writeLine(``.padEnd(length, "-"));
  }
  writeColor(str, pri, sec = "white", inline2 = false, target = this.target) {
    const x2 = str.split(/(\[[^\]]*\])/);
    const out = document.createElement("div");
    out.className = `part `;
    if (inline2)
      out.className += " inline";
    for (let i2 = 0; i2 < x2.length; i2++) {
      const part = document.createElement("span");
      const isPart = x2[i2].startsWith("[") && x2[i2].endsWith("]");
      const content2 = x2[i2].replaceAll("[", "").replaceAll("]", "");
      part.className = `clr-${isPart ? pri : sec}`;
      part.innerText = content2;
      out.append(part);
    }
    target.append(out);
    return out;
  }
  writeImage(src, height) {
    const el = document.createElement("img");
    el.className = "image";
    el.style.height = `${height}em`;
    el.src = src;
    this.target.append(el);
  }
  update(el, str) {
    if (!el)
      return false;
    el.innerText = "";
    this.write(str, this.target);
  }
  updateColor(el, str, pri, sec = "white") {
    if (!el)
      return false;
    el.innerText = "";
    this.writeColor(str, pri, sec, false, el);
  }
  Error(context) {
    Log(
      `ArcTerm ${this.term.referenceId}`,
      `std.Error: ${context.replaceAll("\n", "\\n")}`,
      LogLevel.error
    );
    if (!this.verbose)
      return;
    this.writeColor(`[Error]: ${context}`, "red");
  }
  Warning(context) {
    Log(
      `ArcTerm ${this.term.referenceId}`,
      `std.Warning: ${context.replaceAll("\n", "\\n")}`,
      LogLevel.warn
    );
    if (!this.verbose)
      return;
    this.writeColor(`[Warning]: ${context}`, "orange");
  }
  Info(context) {
    Log(
      `std.ArcTerm ${this.term.referenceId}`,
      `Info: ${context.replaceAll("\n", "\\n")}`,
      LogLevel.info
    );
    if (!this.verbose)
      return;
    this.writeColor(`[Info]: ${context}`, "blue");
  }
  async read(prefix, suffix, max, pswd = false, value = "") {
    if (!this.target)
      return "asdf";
    Log(
      `ArcTerm ${this.term.referenceId}`,
      `std.read: ${prefix}${suffix}`,
      LogLevel.info
    );
    const current = this.term.input.current;
    const commit = writable(false);
    const wrapper = document.createElement("div");
    const input = document.createElement("input");
    if (pswd)
      input.type = "password";
    input.style.width = `${max * 8.41}px`;
    input.maxLength = max;
    input.value = value;
    wrapper.className = "userinput";
    wrapper.append(prefix, input, suffix);
    this.target.append(wrapper);
    this.term.input.current = input;
    input.addEventListener("keydown", (e2) => {
      if (!e2.key)
        return;
      const key2 = e2.key.toLowerCase();
      if (key2 != "enter")
        return;
      input.disabled = true;
      commit.set(true);
    });
    return new Promise((resolve) => {
      commit.subscribe((v2) => {
        if (!v2)
          return;
        this.term.input.current = current;
        resolve(input.value);
      });
    });
  }
  clear() {
    this.target.innerText = "";
  }
  async select(options, color) {
    const select = new ArcTermStdSelect(this, color);
    return await select.create(options);
  }
}
function ArcTermIntro(term) {
  if (!term.env.logo)
    return;
  const x2 = [
    "   [_]         _____            ",
    "  [/_\\]  _ _ _|_   _|__ _ _ _ __ ",
    " [/ _ \\]| '_/ _|| |/ -_) '_| '  \\",
    "[/_/ \\_\\]_| \\__||_|\\___|_| |_|_|_|"
  ];
  for (let i2 = 0; i2 < x2.length; i2++) {
    term.std.writeColor(x2[i2], "blue");
  }
  term.std.writeLine("\n");
}
class ArcTermUtil {
  constructor(t2) {
    __publicField(this, "term");
    __publicField(this, "reference", "");
    this.setReference();
    Log(`ArcTerm ${this.reference}`, `Creating new ArcTermUtil`);
    this.term = t2;
  }
  getReference() {
    Log(`ArcTerm ${this.reference}`, this.reference);
    return this.reference;
  }
  setReference() {
    const rnd = () => Math.floor(Math.random() * 1e6);
    this.reference = `${rnd()}-${rnd()}-${rnd()}-${rnd()}`;
  }
  flushAccent() {
    if (this.term.app)
      return;
    this.term.target.setAttribute(
      "style",
      `--terminal-accent: var(--clr-${this.term.env.promptColor}-fg);`
    );
  }
  intro() {
    if (!this.term || !this.term.std)
      return;
    ArcTermIntro(this.term);
    const username = get_store_value(UserName);
    const server = getServer();
    const path = (this.term.path || "./").replace("./", "");
    const out = this.term.env.greeting.replace("&u", username).replace("&s", server).replace("&p", path);
    this.term.std.writeColor(`${out}

`, this.term.env.promptColor);
  }
}
function getArcTermStore(term) {
  Log(
    `ArcTerm ${term.referenceId}`,
    "Creating new ArcTermVariableStore",
    LogLevel.info
  );
  return {
    prompt: {
      get: () => term.env.prompt,
      set: async (v2) => {
        term.env.prompt = v2;
        await term.env.config.writeConfig();
      },
      canDelete: false,
      readOnly: false
    },
    server: {
      get: () => getServer(),
      readOnly: true,
      canDelete: false
    },
    username: {
      get: () => get_store_value(UserName),
      readOnly: true,
      canDelete: false
    },
    version: {
      get: () => ArcOSVersion,
      readOnly: true,
      canDelete: false
    },
    pwd: {
      get: () => (term.path || "./").replace("./", ""),
      set: async (v2) => {
        const dir = await getDirectory(v2);
        if (!dir)
          return term.std.Error(`pwd: Directory doesn't exist, falling back.`);
        term.path = v2;
      },
      canDelete: false,
      readOnly: false
    },
    color: {
      get: () => term.env.promptColor,
      set: async (v2) => {
        if (!colors.includes(v2))
          return term.std.Error("color is invalid, falling back.");
        term.env.promptColor = v2;
        await term.env.config.writeConfig();
        term.util.flushAccent();
      },
      canDelete: false,
      readOnly: false
    },
    ref: {
      get: () => term.referenceId,
      readOnly: true,
      canDelete: false
    }
  };
}
class ArcTermVariables {
  constructor(t2) {
    __publicField(this, "term");
    __publicField(this, "store", {});
    Log(
      `ArcTerm ${t2.referenceId}`,
      "Creating new ArcTermVariables",
      LogLevel.info
    );
    this.term = t2;
    this.store = getArcTermStore(this.term);
  }
  async getAll() {
    const result = {};
    const entries = Object.entries(this.store);
    for (let i2 = 0; i2 < entries.length; i2++) {
      const key2 = entries[i2][0];
      const value = this.get(key2);
      const ro = entries[i2][1].readOnly;
      result[key2] = { value, readOnly: ro };
    }
    return result;
  }
  get(key2) {
    Log(`ArcTerm ${this.term.referenceId}`, `var.get: getting "${key2}"`);
    if (!this.store[key2])
      return key2;
    return this.store[key2].get();
  }
  async set(key2, value) {
    Log(
      `ArcTerm ${this.term.referenceId}`,
      `var.set: setting "${key2}" to "${value}"`
    );
    if (!this.store[key2]) {
      const variable2 = {
        get: () => variable2.value,
        set: (v2) => variable2.value = v2,
        readOnly: false,
        canDelete: true,
        value
      };
      this.store[key2] = variable2;
      return true;
    }
    if (this.store[key2].readOnly)
      return false;
    const variable = this.store[key2];
    if (!variable)
      return false;
    await variable.set(value);
    return true;
  }
  async delete(key2) {
    Log(`ArcTerm ${this.term.referenceId}`, `var.delete: deleting "${key2}"`);
    if (!this.store[key2] || this.store[key2].readOnly)
      return false;
    await this.set(key2, "");
    return true;
  }
  replace(str) {
    const variables = this.parseInlineNames(str);
    if (!variables.length)
      return str;
    for (let i2 = 0; i2 < variables.length; i2++) {
      const part = `$${variables[i2]}`;
      const value = this.get(variables[i2]);
      str = str.replace(part, value == variables[i2] && part ? part : value);
    }
    return str;
  }
  parseInlineNames(str) {
    const regex = /\$([a-zA-Z_][a-zA-Z0-9_]*)/g;
    const matches = [];
    let match;
    while (match = regex.exec(str)) {
      matches.push(match[1]);
    }
    return matches;
  }
}
class ArcTerm {
  constructor(t2, cS, a2, cb) {
    __publicField(this, "target");
    __publicField(this, "commands");
    __publicField(this, "app");
    __publicField(this, "std");
    __publicField(this, "util");
    __publicField(this, "env");
    __publicField(this, "vars");
    __publicField(this, "input");
    __publicField(this, "path");
    __publicField(this, "scripts");
    __publicField(this, "sect");
    __publicField(this, "commandHandler");
    __publicField(this, "referenceId");
    __publicField(this, "onload");
    this.target = t2;
    this.commands = cS;
    this.app = a2;
    this.onload = cb;
    this.initialize();
  }
  async initialize() {
    this.util = new ArcTermUtil(this);
    this.referenceId = this.util.getReference();
    Log(
      `ArcTerm ${this.referenceId}`,
      `Initializing new ArcTerm`,
      LogLevel.info
    );
    if (!this.target)
      return initError(this.app.id);
    this.target.innerText = `Starting ArcTerm v${ArcOSVersion}...`;
    this.target.removeAttribute("style");
    this.path = ".";
    this.commandHandler = new ArcTermCommandHandler(this);
    this.env = new ArcTermEnv(this);
    this.vars = new ArcTermVariables(this);
    this.scripts = new ArcTermScripts(this);
    this.sect = new ArcTermSections(this);
    setTimeout(async () => {
      this.std = new ArcTermStd(this);
      this.input = new ArcTermInput(this);
      this.input.lock();
      if (this.onload)
        await this.onload(this);
      await sleep(100);
      this.input.unlock();
      this.util.intro();
      this.util.flushAccent();
      if (this.env.gooseBumps)
        this.std.Warning("GooseBumps 👀\n\n");
    }, 1e3);
  }
  dispose() {
    Log(`ArcTerm ${this.referenceId}`, "Disposing", LogLevel.info);
    if (!this.target)
      return;
    this.std.clear();
    this.std = null;
    this.env = null;
    this.input.lock();
    this.input = null;
  }
  reload() {
    Log(`ArcTerm ${this.referenceId}`, "Reloading", LogLevel.info);
    this.dispose();
    setTimeout(async () => {
      await this.initialize();
    });
  }
}
async function authPrompt(term, usr = "", keep = false) {
  const udata = get_store_value(UserName);
  if (udata)
    return true;
  let api2 = getServer();
  if (!api2)
    api2 = await serverConnect(term);
  await rememberedLogin();
  await sleep(250);
  if (get_store_value(UserName)) {
    await term.env.config.loadConfigFile();
    return true;
  }
  if (!keep) {
    term.std.clear();
    term.std.writeLine(`ArcTerm ${ArcOSVersion} ${ARCOS_MODE} ${api2} atm1

`);
  }
  const { username, password } = await authPromptFields(term, api2, usr);
  const token = generateCredToken({ username, password });
  localStorage.setItem("arcos-remembered-token", token);
  await rememberedLogin();
  if (!get_store_value(UserName)) {
    term.std.writeLine("\nLogin incorrect");
    localStorage.removeItem("arcos-remembered-token");
    return await authPrompt(term, usr, true);
  }
  await term.env.config.loadConfigFile();
  return true;
}
async function authPromptFields(term, api2, usr) {
  const username = await term.std.read(`${api2} login: `, "", 100, false, usr);
  if (!username) {
    term.std.writeLine("\nLogin incorrect");
    return await authPromptFields(term, api2, usr);
  }
  const password = await term.std.read("Password: ", "", 100, true);
  return { username, password };
}
async function serverConnect(term) {
  term.std.clear();
  term.std.writeLine(`ArcTerm ${ArcOSVersion} - Connect to server

`);
  const server = await term.std.read("Server: ", "", 50);
  const authCode = await term.std.read("Code (optional): ", "", 64, true);
  term.std.writeLine(`Connecting to ${server}...`);
  if (!await testConnection(server, authCode))
    return await serverConnect(term);
  addServer(server);
  setAuthcode(server, authCode);
  return server;
}
async function arcTermModeIntro(a2) {
  Log(`ArcTerm ${a2.referenceId}`, "Viewing ArcTermMode intro", LogLevel.info);
  if (!await authPrompt(a2))
    return;
  UserCache.clear();
  const server = getServer();
  const user = get_store_value(UserName);
  const quota = await getFSQuota();
  const used = formatBytes(quota.used);
  const max = formatBytes(quota.max);
  const percentage = (100 / quota.max * quota.used).toFixed(2);
  const connect = await apiCall(get_store_value(ConnectedServer), "connect", {});
  const platform2 = connect.platform;
  disclaimer(a2);
  auth(a2, user, platform2);
  api(a2, server);
  usage(a2, used, max, percentage);
}
function disclaimer(term) {
  term.std.clear();
  term.std.writeColor(
    `[█] You are currently in [ArcTerm mode].
[█] Commands that require the ArcOS desktop have been disabled.

`,
    "orange"
  );
  term.std.writeColor(`ArcTerm reference ID: [${term.referenceId}]`, "blue");
}
function auth(term, user, platform2) {
  term.std.writeColor(
    `
Authenticated as [${user}] at [${platform2}]`,
    "aqua",
    "white",
    true
  );
}
function api(term, server) {
  term.std.writeColor(` [(${server})]`, "gray", "white", true);
}
function usage(term, used, max, percent) {
  term.std.writeColor(
    `
[ArcFS]: You are using [${used}] of [${max}] total (${percent}%)
`,
    "yellow"
  );
}
function create_fragment$$(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.textContent = "authenticating with ArcAPI...";
      attr(div, "id", "target");
      attr(div, "class", "terminal-renderer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[2](div);
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*focus*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[2](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$X($$self, $$props, $$invalidate) {
  let arcterm2;
  let target;
  onMount(async () => {
    arcterm2 = new ArcTerm(target, arcCommands, null, arcTermModeIntro);
  });
  function focus() {
    if (!arcterm2 || !arcterm2.input || !arcterm2.input.current)
      return;
    arcterm2.input.current.focus();
    if (!target)
      return;
    target.scrollTo(0, target.scrollHeight);
  }
  setInterval(focus, 10);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      target = $$value;
      $$invalidate(0, target);
    });
  }
  return [target, focus, div_binding];
}
class ArcTerm_12 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$X, create_fragment$$, safe_not_equal, {});
  }
}
const Blank_svelte_svelte_type_style_lang = "";
function create_fragment$_(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "fullscreen svelte-1b10uke");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
class Blank extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$_, safe_not_equal, {});
  }
}
const boot = "";
function BootFail(host) {
  BugReportData.set([
    true,
    {
      title: "Boot failed",
      icon: "warning",
      message: "ArcOS can't connect to the remote server. Please ensure<br>the server is online, or try again at a later date.",
      button: {
        caption: "Retry",
        action: () => location.reload()
      },
      source: "Boot",
      details: `Can't connect to server ${host}: none of the modes match`
    }
  ]);
}
function create_if_block$x(ctx) {
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  return {
    c() {
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      attr(div0, "class", "line dark");
      attr(div1, "class", "subline dark inc");
      attr(div2, "class", "subline dark dec");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      insert(target, t1, anchor);
      insert(target, div2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div1);
        detach(t1);
        detach(div2);
      }
    }
  };
}
function create_fragment$Z(ctx) {
  let div4;
  let div0;
  let t0;
  let t1;
  let t2;
  let apireveal;
  let t3;
  let div1;
  let t4_value = (
    /*targetState*/
    ctx[2] == "serverselect" ? "Please wait..." : "Press F8 to select server"
  );
  let t4;
  let t5;
  let div3;
  let img;
  let img_src_value;
  let t6;
  let div2;
  let t7;
  let p2;
  let div4_class_value;
  let current;
  let mounted;
  let dispose;
  apireveal = new APIReveal({});
  let if_block = (
    /*progress*/
    ctx[3] && create_if_block$x()
  );
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      t0 = text("v");
      t1 = text(ArcOSVersion);
      t2 = text(" - ");
      create_component(apireveal.$$.fragment);
      t3 = space();
      div1 = element("div");
      t4 = text(t4_value);
      t5 = space();
      div3 = element("div");
      img = element("img");
      t6 = space();
      div2 = element("div");
      if (if_block)
        if_block.c();
      t7 = space();
      p2 = element("p");
      attr(div0, "class", "arcterm-load visible");
      attr(div1, "class", "ssnotice visible");
      attr(img, "alt", "Logo");
      attr(img, "class", "logo");
      if (!src_url_equal(img.src, img_src_value = Logo()))
        attr(img, "src", img_src_value);
      attr(div2, "class", "slider userdefined");
      attr(p2, "class", "status");
      attr(div3, "class", "center");
      attr(div4, "class", div4_class_value = /*bootClass*/
      ctx[1] + " boot fullscreen");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div0, t0);
      append(div0, t1);
      append(div0, t2);
      mount_component(apireveal, div0, null);
      append(div4, t3);
      append(div4, div1);
      append(div1, t4);
      append(div4, t5);
      append(div4, div3);
      append(div3, img);
      append(div3, t6);
      append(div3, div2);
      if (if_block)
        if_block.m(div2, null);
      append(div3, t7);
      append(div3, p2);
      p2.innerHTML = /*status*/
      ctx[0];
      current = true;
      if (!mounted) {
        dispose = listen(
          div1,
          "click",
          /*click_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*targetState*/
      4) && t4_value !== (t4_value = /*targetState*/
      ctx2[2] == "serverselect" ? "Please wait..." : "Press F8 to select server"))
        set_data(t4, t4_value);
      if (
        /*progress*/
        ctx2[3]
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$x();
          if_block.c();
          if_block.m(div2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*status*/
      1)
        p2.innerHTML = /*status*/
        ctx2[0];
      if (!current || dirty & /*bootClass*/
      2 && div4_class_value !== (div4_class_value = /*bootClass*/
      ctx2[1] + " boot fullscreen")) {
        attr(div4, "class", div4_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(apireveal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(apireveal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      destroy_component(apireveal);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$W($$self, $$props, $$invalidate) {
  let status = "";
  let bootClass = "";
  let targetState = "login";
  let progress = false;
  let running = false;
  onMount(async () => {
    if (isDesktop()) {
      await sleep(500);
      $$invalidate(1, bootClass = "fadein");
      return startBooting();
    }
    $$invalidate(0, status = "Press a key or click to start");
    document.addEventListener("click", startBooting, { once: true });
    document.addEventListener("keydown", startBooting, { once: true });
    document.addEventListener("keydown", arcTermShortcut);
    await sleep(500);
    $$invalidate(1, bootClass = "fadein");
  });
  async function startBooting() {
    if (running)
      return;
    running = true;
    $$invalidate(0, status = "&nbsp;");
    $$invalidate(3, progress = true);
    Busy.set(true);
    if (targetState == "serverselect")
      return await redirect();
    if (!await checkServer() && !getAllServers())
      $$invalidate(0, status = "Preparing ArcOS");
    await redirect();
  }
  function arcTermShortcut(e2) {
    if (!e2.key)
      return;
    const key2 = e2.key.toLowerCase();
    if (key2 == "f8" || targetState == "serverselect")
      return $$invalidate(2, targetState = "serverselect");
    if (!e2.altKey || key2 != "a")
      return;
    $$invalidate(2, targetState = "arcterm");
    $$invalidate(0, status = "Loading ArcTerm");
  }
  async function checkServer() {
    const serverHost = getServer();
    const authCode = getAuthcode(serverHost);
    if (!serverHost)
      return;
    if (authCode)
      $$invalidate(0, status = "Connecting Securely");
    const connected = await testConnection(serverHost, authCode);
    if (!connected) {
      $$invalidate(1, bootClass = "fadeout");
      return targetState == "serverselect" ? false : BootFail(serverHost);
    }
    return connected;
  }
  async function redirect() {
    Log("Boot.svelte", "Redirecting");
    await sleep(2e3);
    $$invalidate(1, bootClass = "fadeout");
    await sleep(750);
    applyState(targetState);
    Busy.set(false);
  }
  const click_handler = () => $$invalidate(2, targetState = "serverselect");
  return [status, bootClass, targetState, progress, click_handler];
}
class Boot extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$W, create_fragment$Z, safe_not_equal, {});
  }
}
const Crash_svelte_svelte_type_style_lang = "";
function create_if_block$w(ctx) {
  let textarea;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      textarea.readOnly = true;
      attr(textarea, "class", "svelte-i3bi2f");
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      set_input_value(
        textarea,
        /*log*/
        ctx[1]
      );
      if (!mounted) {
        dispose = listen(
          textarea,
          "input",
          /*textarea_input_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*log*/
      2) {
        set_input_value(
          textarea,
          /*log*/
          ctx2[1]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(textarea);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$Y(ctx) {
  let if_block_anchor;
  let if_block = (
    /*show*/
    ctx[0] && create_if_block$w(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*show*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$w(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$V($$self, $$props, $$invalidate) {
  let $CrashReport;
  component_subscribe($$self, CrashReport, ($$value) => $$invalidate(3, $CrashReport = $$value));
  let show = false;
  const prefix = `---! [ ArcOS crashed ] !---

Below you'll find the log, which may contain information about the crash.
A bug report has been sent to the Reports server informing it of the crash.

`;
  let log = "";
  onMount(async () => {
    await sleep(1e3);
    $$invalidate(0, show = true);
  });
  LogStore.subscribe(() => {
    const Log2 = `
--- LOG ---

${compileStringLog().join("\n")}`;
    const crashRep = $CrashReport;
    const reportStr = crashRep ? `${crashRep.title}

${crashRep.body}
` : "";
    const extra = "";
    $$invalidate(1, log = `${prefix}${extra}${reportStr}${Log2}`);
  });
  function textarea_input_handler() {
    log = this.value;
    $$invalidate(1, log);
  }
  return [show, log, textarea_input_handler];
}
class Crash extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$V, create_fragment$Y, safe_not_equal, {});
  }
}
const desktop = "";
const titleBarContextMenu = [
  {
    caption: "Maximize",
    async isActive(window2) {
      return window2.state.windowState.max && window2.controls.max;
    },
    action(window2) {
      window2.controls.max && maximizeWindow(window2);
    },
    icon: "crop_square"
  },
  {
    caption: "Minimize",
    async isActive(window2) {
      return window2.state.windowState.min && window2.controls.min;
    },
    action(window2) {
      window2.controls.min && minimizeWindow(window2);
    },
    icon: "minimize"
  },
  SEP_ITEM,
  {
    caption: "App Info",
    action(window2) {
      closeWindow("AppInfo");
      setTimeout(() => {
        AppInfoId.set(window2.id);
        openWindow("AppInfo");
      }, 300);
    },
    icon: "info"
  },
  SEP_ITEM,
  {
    caption: "Application Manager",
    action() {
      openWindow("AppMan");
    },
    image: AppManIcon
  }
];
function centerWindow(id) {
  Log(`applogic/center.ts: centerWindow`, `Centering ${id}`);
  WindowStore.update((ws) => {
    for (let i2 = 0; i2 < ws.length; i2++) {
      if (ws[i2].id == id) {
        ws[i2].pos = calculatePos(ws[i2]);
      }
    }
    return ws;
  });
}
function calculatePos(app) {
  Log(`applogic/center.ts: calculatePos`, `Calculating position for ${app.id}`);
  const el = getWindowElement(app);
  if (!el)
    return { x: 0, y: 0, centered: false };
  const windowWidth = el.offsetWidth;
  const windowHeight = el.offsetHeight;
  const screenWidth = document.body.offsetWidth;
  const screenHeight = document.body.offsetHeight;
  const x2 = (screenWidth - windowWidth) / 2;
  const y2 = (screenHeight - windowHeight) / 2;
  el.style.left = `${x2}px`;
  el.style.top = `${y2}px`;
  return { x: x2, y: y2, centered: true };
}
function loadWindow(id, app) {
  const data = { ...app, id };
  const children2 = getChildren(app, id);
  const userdata = get_store_value(UserData$2);
  const disabledList = userdata ? userdata.disabledApps : [];
  if (isLoaded(id))
    return Log(
      "AppLogic: loadWindow",
      `Window ${id} already exists in WindowStore.`,
      LogLevel.error
    );
  WindowStore.update((ws) => {
    ws.push(data);
    for (let i2 = 0; i2 < children2.length; i2++) {
      ws.push(children2[i2]);
    }
    return ws;
  });
  data.contextMenu = {
    ...data.contextMenu,
    "window-titlebar": titleBarContextMenu
  };
  if (userdata && !userdata.disabledApps) {
    userdata.disabledApps = [];
    UserData$2.set(userdata);
  }
  if (disabledList.includes(id) && !SystemApps.includes(id))
    data.disabled = true;
  registerAppShortcuts(id, app);
  if (app.disabledWarning && disabledList.includes(id)) {
    makeNotification({
      ...app.disabledWarning,
      buttons: [],
      image: app.info.icon,
      timeout: 6e3
    });
  }
  setTimeout(() => {
    if (app.pos.centered)
      centerWindow(id);
  }, 300);
  Log("AppLogic: loadWindow", `Loaded ${id} into WindowStore.`);
}
function getChildren(app, id) {
  const entries = Object.entries(app.children || {});
  const children2 = [];
  for (let i2 = 0; i2 < entries.length; i2++) {
    children2.push({
      ...entries[i2][1],
      id: entries[i2][0],
      parentId: id,
      opened: false,
      info: { ...entries[i2][1].info, hidden: true }
    });
  }
  return children2;
}
async function importDefault(open = false) {
  Log(
    "imports.ts: importDefault",
    `Importing default applications`,
    LogLevel.info
  );
  const entries = Object.entries(DefaultApps);
  for (let i2 = 0; i2 < entries.length; i2++) {
    Log(
      `imports.ts: importDefault`,
      `Importing default application "${entries[i2][0]}"...`,
      LogLevel.info
    );
    await loadWindow(entries[i2][0], entries[i2][1]);
    if (open)
      openWindow(entries[i2][0]);
  }
  updateStores();
}
const banned = ["tab", "pagedown", "pageup"];
function startKeyListener() {
  Log(
    "keyboard/listener.ts: startKeyListener",
    "Starting key listener",
    LogLevel.info
  );
  document.addEventListener("keydown", processEvent);
}
function processEvent(e2) {
  if (!e2.key)
    return;
  if (banned.includes(e2.key.toLowerCase())) {
    e2.preventDefault();
    return false;
  }
  unfocusActiveElement();
  if (CurrentState.key != "desktop")
    return;
  for (let i2 = 0; i2 < appShortcuts.length; i2++) {
    const entry = appShortcuts[i2];
    const combos = entry[1];
    for (let j2 = 0; j2 < combos.length; j2++) {
      const alt = combos[j2].alt ? e2.altKey : true;
      const ctrl = combos[j2].ctrl ? e2.ctrlKey : true;
      const shift = combos[j2].shift ? e2.shiftKey : true;
      const modifiers = alt && ctrl && shift;
      const pK = e2.key.toLowerCase().trim();
      const key2 = combos[j2].key.trim().toLowerCase();
      const isFocused = get_store_value(focusedWindowId) == entry[0] || combos[j2].global;
      if (!modifiers || key2 != pK && key2 || !isFocused)
        continue;
      const app = combos[j2].global ? null : getWindow(entry[0]);
      combos[j2].action(app);
    }
  }
}
function unfocusActiveElement() {
  const el = document.activeElement;
  if (!el || el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement)
    return;
  el.blur();
}
async function checkReleaseCandidate() {
  if (CurrentState.key != "desktop" || ARCOS_MODE != "rc")
    return;
  await sleep(1e3);
  makeNotification({
    title: "Release Candidate",
    message: `You're currently running a release candidate build of ArcOS. This build can and will have unwanted behaviour and bugs. Any critical errors will be reported automatically.<br><br>ArcOS version ${ArcOSVersion}-rc`,
    buttons: [],
    image: Logo(),
    timeout: 3e3
  });
}
function checkFirefox() {
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
  if (!isFirefox)
    return;
  makeNotification({
    image: FireFoxIcon,
    title: "Firefox unsupported",
    message: "We don't officially support Firefox due to lacking CSS compatibility. Some visual elements of ArcOS have been disabled. We recommend using a chromium-based browser for running ArcOS.",
    buttons: []
  });
}
let interval;
const pollBlockList = [];
function startMessageCheckInterval() {
  interval = setInterval(tick, 1e3 * 60);
  tick();
}
async function tick() {
  if (!get_store_value(UserName) || CurrentState.name != "Desktop")
    return stopMessageCheckInterval();
  messageUpdateTrigger();
  const unreads = (await getUnreadMessages()).sort((a2, b2) => {
    return b2.timestamp - a2.timestamp;
  });
  if (!unreads.length)
    return;
  const message = unreads[0];
  if (!message || pollBlockList.includes(message.id))
    return;
  pollBlockList.push(message.id);
  requestUserAttention("MessagingApp");
  makeNotification({
    title: `New message from ${message.sender}`,
    message: `${message.partialBody}`,
    image: await getUserPfp(message.sender),
    buttons: [
      {
        caption: "Open Messages",
        action: () => {
          messageUpdateTrigger();
          openWindow("MessagingApp");
        }
      }
    ]
  });
}
function stopMessageCheckInterval() {
  clearInterval(interval);
}
const arcfind = "";
function create_fragment$X(ctx) {
  let div;
  let spinner2;
  let span;
  let current;
  spinner2 = new Spinner({ props: { height: 30 } });
  return {
    c() {
      div = element("div");
      create_component(spinner2.$$.fragment);
      span = element("span");
      span.textContent = "Searching...";
      attr(span, "class", "caption");
      attr(div, "class", "loading");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(spinner2, div, null);
      append(div, span);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(spinner2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(spinner2);
    }
  };
}
let Loading$1 = class Loading2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$X, safe_not_equal, {});
  }
};
function create_fragment$W(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "No items matched your search.";
      attr(div, "class", "no-results");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
class NoResults extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$W, safe_not_equal, {});
  }
}
function create_if_block$v(ctx) {
  let p2;
  let t_value = (
    /*result*/
    ctx[0].description + ""
  );
  let t2;
  return {
    c() {
      p2 = element("p");
      t2 = text(t_value);
      attr(p2, "class", "description");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      append(p2, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*result*/
      1 && t_value !== (t_value = /*result*/
      ctx2[0].description + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_fragment$V(ctx) {
  let button;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let div1;
  let p2;
  let t1_value = (
    /*result*/
    ctx[0].caption + ""
  );
  let t1;
  let t2;
  let mounted;
  let dispose;
  let if_block = (
    /*result*/
    ctx[0].description && create_if_block$v(ctx)
  );
  return {
    c() {
      button = element("button");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div1 = element("div");
      p2 = element("p");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      if (!src_url_equal(img.src, img_src_value = /*result*/
      ctx[0].image || searchIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*result*/
      ctx[0].caption);
      attr(div0, "class", "image");
      attr(p2, "class", "title");
      attr(div1, "class", "context");
      attr(button, "class", "result");
      toggle_class(
        button,
        "selected",
        /*index*/
        ctx[1] == /*resultIndex*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div0);
      append(div0, img);
      append(button, t0);
      append(button, div1);
      append(div1, p2);
      append(p2, t1);
      append(div1, t2);
      if (if_block)
        if_block.m(div1, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*trigger*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*result*/
      1 && !src_url_equal(img.src, img_src_value = /*result*/
      ctx2[0].image || searchIcon)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*result*/
      1 && img_alt_value !== (img_alt_value = /*result*/
      ctx2[0].caption)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*result*/
      1 && t1_value !== (t1_value = /*result*/
      ctx2[0].caption + ""))
        set_data(t1, t1_value);
      if (
        /*result*/
        ctx2[0].description
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$v(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*index, resultIndex*/
      6) {
        toggle_class(
          button,
          "selected",
          /*index*/
          ctx2[1] == /*resultIndex*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$U($$self, $$props, $$invalidate) {
  let { result } = $$props;
  let { index } = $$props;
  let { resultIndex } = $$props;
  function trigger() {
    result.action(result);
    showArcFind.set(false);
  }
  $$self.$$set = ($$props2) => {
    if ("result" in $$props2)
      $$invalidate(0, result = $$props2.result);
    if ("index" in $$props2)
      $$invalidate(1, index = $$props2.index);
    if ("resultIndex" in $$props2)
      $$invalidate(2, resultIndex = $$props2.resultIndex);
  };
  return [result, index, resultIndex, trigger];
}
class Result extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$U, create_fragment$V, safe_not_equal, { result: 0, index: 1, resultIndex: 2 });
  }
}
function get_each_context$b(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list2[i2];
  return child_ctx;
}
function get_each_context_1$2(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list2[i2];
  child_ctx[23] = i2;
  return child_ctx;
}
function create_if_block_5(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "placeholder", "Search ArcOS");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*$arcFindValue*/
        ctx[6]
      );
      ctx[15](input);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[14]
          ),
          listen(
            input,
            "input",
            /*search*/
            ctx[10]
          ),
          listen(
            input,
            "keydown",
            /*mutateIndex*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$arcFindValue*/
      64 && input.value !== /*$arcFindValue*/
      ctx2[6]) {
        set_input_value(
          input,
          /*$arcFindValue*/
          ctx2[6]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      ctx[15](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$3(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_3$1, create_if_block_4, create_else_block$9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*results*/
      ctx2[5].length
    )
      return 0;
    if (
      /*loading*/
      ctx2[2]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "results");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_else_block$9(ctx) {
  let noresults;
  let current;
  noresults = new NoResults({});
  return {
    c() {
      create_component(noresults.$$.fragment);
    },
    m(target, anchor) {
      mount_component(noresults, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(noresults.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(noresults.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(noresults, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  let loading_1;
  let current;
  loading_1 = new Loading$1({});
  return {
    c() {
      create_component(loading_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loading_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading_1, detaching);
    }
  };
}
function create_if_block_3$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*results*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*index, results*/
      34) {
        each_value_1 = ensure_array_like(
          /*results*/
          ctx2[5]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1$2(ctx) {
  let result_1;
  let current;
  result_1 = new Result({
    props: {
      index: (
        /*index*/
        ctx[1]
      ),
      result: (
        /*result*/
        ctx[21]
      ),
      resultIndex: (
        /*i*/
        ctx[23]
      )
    }
  });
  return {
    c() {
      create_component(result_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(result_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const result_1_changes = {};
      if (dirty & /*index*/
      2)
        result_1_changes.index = /*index*/
        ctx2[1];
      if (dirty & /*results*/
      32)
        result_1_changes.result = /*result*/
        ctx2[21];
      result_1.$set(result_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(result_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(result_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(result_1, detaching);
    }
  };
}
function create_if_block_1$8(ctx) {
  let applistitem;
  let current;
  applistitem = new AppListItem({
    props: {
      app: (
        /*app*/
        ctx[18]
      ),
      onopen: (
        /*func*/
        ctx[16]
      )
    }
  });
  return {
    c() {
      create_component(applistitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applistitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applistitem_changes = {};
      if (dirty & /*$WindowStore*/
      512)
        applistitem_changes.app = /*app*/
        ctx2[18];
      if (dirty & /*$showArcFind*/
      256)
        applistitem_changes.onopen = /*func*/
        ctx2[16];
      applistitem.$set(applistitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applistitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applistitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applistitem, detaching);
    }
  };
}
function create_each_block$b(ctx) {
  let show_if = isPopulatable(
    /*app*/
    ctx[18]
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_1$8(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$WindowStore*/
      512)
        show_if = isPopulatable(
          /*app*/
          ctx2[18]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$WindowStore*/
          512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block$u(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "close";
      attr(button, "class", "material-icons-round close");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*closeThis*/
          ctx[12]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$U(ctx) {
  let div2;
  let div0;
  let form;
  let t0;
  let button;
  let t2;
  let t3;
  let div1;
  let t4;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$showArcFind*/
    ctx[8] && create_if_block_5(ctx)
  );
  let if_block1 = (
    /*initial*/
    ctx[3] && create_if_block_2$3(ctx)
  );
  let each_value = ensure_array_like(
    /*$WindowStore*/
    ctx[9]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$b(get_each_context$b(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block2 = !/*inlined*/
  ctx[0] && create_if_block$u(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      form = element("form");
      if (if_block0)
        if_block0.c();
      t0 = space();
      button = element("button");
      button.textContent = "search";
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t4 = space();
      if (if_block2)
        if_block2.c();
      attr(button, "class", "material-icons-round");
      attr(div0, "class", "arcfind");
      attr(div1, "class", "apps");
      toggle_class(div1, "hide", !!/*$arcFindValue*/
      ctx[6]);
      attr(div2, "class", "arcfind-wrapper");
      set_style(
        div2,
        "z-index",
        /*$maxZIndex*/
        ctx[7] + 30
      );
      toggle_class(
        div2,
        "inlined",
        /*inlined*/
        ctx[0]
      );
      toggle_class(
        div2,
        "show",
        /*$showArcFind*/
        ctx[8] || /*inlined*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, form);
      if (if_block0)
        if_block0.m(form, null);
      append(div0, t0);
      append(div0, button);
      append(div2, t2);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t3);
      append(div2, div1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      append(div2, t4);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          form,
          "submit",
          /*submit*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*$showArcFind*/
        ctx2[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          if_block0.m(form, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*initial*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*initial*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty & /*$WindowStore, $showArcFind*/
      768) {
        each_value = ensure_array_like(
          /*$WindowStore*/
          ctx2[9]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$b(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$b(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*$arcFindValue*/
      64) {
        toggle_class(div1, "hide", !!/*$arcFindValue*/
        ctx2[6]);
      }
      if (!/*inlined*/
      ctx2[0]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$u(ctx2);
          if_block2.c();
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty & /*$maxZIndex*/
      128) {
        set_style(
          div2,
          "z-index",
          /*$maxZIndex*/
          ctx2[7] + 30
        );
      }
      if (!current || dirty & /*inlined*/
      1) {
        toggle_class(
          div2,
          "inlined",
          /*inlined*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$showArcFind, inlined*/
      257) {
        toggle_class(
          div2,
          "show",
          /*$showArcFind*/
          ctx2[8] || /*inlined*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_each(each_blocks, detaching);
      if (if_block2)
        if_block2.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$T($$self, $$props, $$invalidate) {
  let $arcFindValue;
  let $maxZIndex;
  let $showArcFind;
  let $WindowStore;
  component_subscribe($$self, arcFindValue, ($$value) => $$invalidate(6, $arcFindValue = $$value));
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(7, $maxZIndex = $$value));
  component_subscribe($$self, showArcFind, ($$value) => $$invalidate(8, $showArcFind = $$value));
  component_subscribe($$self, WindowStore, ($$value) => $$invalidate(9, $WindowStore = $$value));
  let { inlined = false } = $$props;
  let index = 0;
  let loading = false;
  let initial = false;
  let searchBox;
  let results = [];
  async function search2() {
    if (!$arcFindValue)
      return $$invalidate(3, initial = false);
    $$invalidate(3, initial = true);
    $$invalidate(2, loading = true);
    Busy.set(true);
    const items = [];
    const fuseResults = await Search($arcFindValue);
    for (let i2 = 0; i2 < fuseResults.length; i2++) {
      items.push(fuseResults[i2].item);
    }
    $$invalidate(1, index = -1);
    $$invalidate(5, results = items.slice(0, 6));
    $$invalidate(2, loading = false);
    Busy.set(false);
  }
  function submit2(e2) {
    e2.preventDefault();
    if (!results.length)
      return;
    set_store_value(arcFindValue, $arcFindValue = "", $arcFindValue);
    if (index != -1) {
      results[index].action(results[index]);
      reset();
      showArcFind.set(false);
      return;
    }
    results[0].action(results[0]);
    reset();
    showArcFind.set(false);
  }
  function reset() {
    $$invalidate(5, results = []);
    set_store_value(arcFindValue, $arcFindValue = "", $arcFindValue);
    $$invalidate(1, index = -1);
    $$invalidate(3, initial = false);
  }
  function closeThis() {
    reset();
    showArcFind.set(false);
  }
  showArcFind.subscribe(async (v2) => {
    reset();
    if (!v2 || !searchBox)
      return;
    await sleep(500);
    searchBox.focus();
    await sleep(200);
    searchBox.focus();
  });
  function mutateIndex(e2) {
    const key2 = e2.key.toLowerCase();
    if (key2 == "escape") {
      reset();
      showArcFind.set(false);
      return;
    }
    if (!results.length)
      return $$invalidate(1, index = -1);
    let length = results.length - 1;
    switch (key2) {
      case "arrowup":
        $$invalidate(1, index--, index);
        if (index < 0)
          $$invalidate(1, index = length);
        break;
      case "arrowdown":
        $$invalidate(1, index++, index);
        if (index > length)
          $$invalidate(1, index = 0);
        break;
    }
  }
  function input_input_handler() {
    $arcFindValue = this.value;
    arcFindValue.set($arcFindValue);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      searchBox = $$value;
      $$invalidate(4, searchBox);
    });
  }
  const func2 = () => set_store_value(showArcFind, $showArcFind = false, $showArcFind);
  $$self.$$set = ($$props2) => {
    if ("inlined" in $$props2)
      $$invalidate(0, inlined = $$props2.inlined);
  };
  return [
    inlined,
    index,
    loading,
    initial,
    searchBox,
    results,
    $arcFindValue,
    $maxZIndex,
    $showArcFind,
    $WindowStore,
    search2,
    submit2,
    closeThis,
    mutateIndex,
    input_input_handler,
    input_binding,
    func2
  ];
}
class ArcFind extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$T, create_fragment$U, safe_not_equal, { inlined: 0 });
  }
}
const contextmenu = "";
function create_else_block$8(ctx) {
  let button;
  let div;
  let t0;
  let t1_value = (
    /*data*/
    ctx[0].caption + ""
  );
  let t1;
  let mounted;
  let dispose;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*data*/
      ctx2[0].icon
    )
      return create_if_block_1$7;
    if (
      /*data*/
      ctx2[0].image
    )
      return create_if_block_2$2;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      button = element("button");
      div = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      t1 = text(t1_value);
      attr(div, "class", "icon");
      attr(button, "class", "contextmenu-item");
      toggle_class(
        button,
        "active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div);
      if (if_block)
        if_block.m(div, null);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*trigger*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
      if (dirty & /*data*/
      1 && t1_value !== (t1_value = /*data*/
      ctx2[0].caption + ""))
        set_data(t1, t1_value);
      if (dirty & /*active*/
      2) {
        toggle_class(
          button,
          "active",
          /*active*/
          ctx2[1]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block) {
        if_block.d();
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$t(ctx) {
  let hr;
  return {
    c() {
      hr = element("hr");
    },
    m(target, anchor) {
      insert(target, hr, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(hr);
      }
    }
  };
}
function create_if_block_2$2(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*data*/
      ctx[0].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*data*/
      ctx[0].caption);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && !src_url_equal(img.src, img_src_value = /*data*/
      ctx2[0].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*data*/
      1 && img_alt_value !== (img_alt_value = /*data*/
      ctx2[0].caption)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_if_block_1$7(ctx) {
  let span;
  let t_value = (
    /*data*/
    ctx[0].icon + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "material-icons-round");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && t_value !== (t_value = /*data*/
      ctx2[0].icon + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$T(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*data*/
      ctx2[0].sep
    )
      return create_if_block$t;
    return create_else_block$8;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function instance$S($$self, $$props, $$invalidate) {
  let { data } = $$props;
  let { scope } = $$props;
  let { scopeMap } = $$props;
  let { window: window2 } = $$props;
  let { show } = $$props;
  let active2 = false;
  function trigger() {
    if (data.action)
      data.action(window2, scopeMap, scope);
    $$invalidate(3, show = false);
    update2();
  }
  onMount(update2);
  async function update2() {
    if (!data.isActive)
      return $$invalidate(1, active2 = false);
    $$invalidate(1, active2 = await data.isActive(window2, scopeMap, scope));
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("scope" in $$props2)
      $$invalidate(4, scope = $$props2.scope);
    if ("scopeMap" in $$props2)
      $$invalidate(5, scopeMap = $$props2.scopeMap);
    if ("window" in $$props2)
      $$invalidate(6, window2 = $$props2.window);
    if ("show" in $$props2)
      $$invalidate(3, show = $$props2.show);
  };
  return [data, active2, trigger, show, scope, scopeMap, window2];
}
class Item3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$S, create_fragment$T, safe_not_equal, {
      data: 0,
      scope: 4,
      scopeMap: 5,
      window: 6,
      show: 3
    });
  }
}
function get_each_context$a(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list2[i2];
  return child_ctx;
}
function create_each_block$a(ctx) {
  let item_1;
  let updating_show;
  let current;
  function item_1_show_binding(value) {
    ctx[10](value);
  }
  let item_1_props = {
    window: (
      /*window*/
      ctx[4]
    ),
    scope: (
      /*scope*/
      ctx[5]
    ),
    scopeMap: (
      /*scopeMap*/
      ctx[6]
    ),
    data: (
      /*item*/
      ctx[13]
    )
  };
  if (
    /*show*/
    ctx[2] !== void 0
  ) {
    item_1_props.show = /*show*/
    ctx[2];
  }
  item_1 = new Item3({ props: item_1_props });
  binding_callbacks.push(() => bind$1(item_1, "show", item_1_show_binding));
  return {
    c() {
      create_component(item_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(item_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const item_1_changes = {};
      if (dirty & /*window*/
      16)
        item_1_changes.window = /*window*/
        ctx2[4];
      if (dirty & /*scope*/
      32)
        item_1_changes.scope = /*scope*/
        ctx2[5];
      if (dirty & /*scopeMap*/
      64)
        item_1_changes.scopeMap = /*scopeMap*/
        ctx2[6];
      if (dirty & /*items*/
      8)
        item_1_changes.data = /*item*/
        ctx2[13];
      if (!updating_show && dirty & /*show*/
      4) {
        updating_show = true;
        item_1_changes.show = /*show*/
        ctx2[2];
        add_flush_callback(() => updating_show = false);
      }
      item_1.$set(item_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(item_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(item_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(item_1, detaching);
    }
  };
}
function create_fragment$S(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*items*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$a(get_each_context$a(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "contextmenu shell-colored");
      set_style(
        div,
        "top",
        /*y*/
        ctx[1] + "px"
      );
      set_style(
        div,
        "left",
        /*x*/
        ctx[0] + "px"
      );
      set_style(
        div,
        "z-index",
        /*$maxZIndex*/
        ctx[9] + 10
      );
      toggle_class(
        div,
        "show",
        /*show*/
        ctx[2]
      );
      toggle_class(
        div,
        "compact",
        /*$UserData*/
        ctx[8].sh.compactContext
      );
      toggle_class(
        div,
        "colored",
        /*$UserData*/
        ctx[8].sh.taskbar.colored
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      ctx[11](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*window, scope, scopeMap, items, show*/
      124) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[3]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$a(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$a(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*y*/
      2) {
        set_style(
          div,
          "top",
          /*y*/
          ctx2[1] + "px"
        );
      }
      if (!current || dirty & /*x*/
      1) {
        set_style(
          div,
          "left",
          /*x*/
          ctx2[0] + "px"
        );
      }
      if (!current || dirty & /*$maxZIndex*/
      512) {
        set_style(
          div,
          "z-index",
          /*$maxZIndex*/
          ctx2[9] + 10
        );
      }
      if (!current || dirty & /*show*/
      4) {
        toggle_class(
          div,
          "show",
          /*show*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$UserData*/
      256) {
        toggle_class(
          div,
          "compact",
          /*$UserData*/
          ctx2[8].sh.compactContext
        );
      }
      if (!current || dirty & /*$UserData*/
      256) {
        toggle_class(
          div,
          "colored",
          /*$UserData*/
          ctx2[8].sh.taskbar.colored
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      ctx[11](null);
    }
  };
}
function instance$R($$self, $$props, $$invalidate) {
  let $UserData;
  let $maxZIndex;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(8, $UserData = $$value));
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(9, $maxZIndex = $$value));
  let x2 = 0;
  let y2 = 0;
  let show = false;
  let items = [];
  let window2;
  let scope;
  let scopeMap;
  let menuElement;
  onMount(() => {
    document.addEventListener("contextmenu", handleEvent);
    document.addEventListener("mousedown", (e2) => {
      if (e2.button != 0 || e2.composedPath().includes(menuElement))
        return;
      $$invalidate(2, show = false);
    });
  });
  function handleEvent(e2) {
    $$invalidate(2, show = false);
    e2.preventDefault();
    const windowElement = getWindowElementByEvent(e2);
    if (!windowElement)
      return;
    const windowData = getWindow(windowElement.id);
    const el = getContexMenuScope(e2);
    if (!el)
      return;
    const contextmenu2 = el == null ? void 0 : el.dataset.contextmenu;
    setTimeout(async () => {
      const newItems = getContextEntry(windowElement.id, contextmenu2) || [];
      if (!newItems.length)
        return;
      $$invalidate(3, items = []);
      await sleep(0);
      $$invalidate(3, items = newItems);
      $$invalidate(5, scope = contextmenu2);
      $$invalidate(4, window2 = windowData);
      $$invalidate(6, scopeMap = el.dataset);
      $$invalidate(2, show = true);
      setTimeout(() => {
        const mW = menuElement.offsetWidth;
        const mH = menuElement.offsetHeight;
        $$invalidate(0, [x2, y2] = composePosition(e2, mW, mH), x2, $$invalidate(1, y2));
      });
    });
  }
  function item_1_show_binding(value) {
    show = value;
    $$invalidate(2, show);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menuElement = $$value;
      $$invalidate(7, menuElement);
    });
  }
  return [
    x2,
    y2,
    show,
    items,
    window2,
    scope,
    scopeMap,
    menuElement,
    $UserData,
    $maxZIndex,
    item_1_show_binding,
    div_binding
  ];
}
class ContextMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$R, create_fragment$S, safe_not_equal, {});
  }
}
function create_fragment$R(ctx) {
  let button_1;
  let t_value = (
    /*button*/
    ctx[0].caption + ""
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button_1 = element("button");
      t2 = text(t_value);
      toggle_class(
        button_1,
        "suggested",
        /*button*/
        ctx[0].suggested
      );
    },
    m(target, anchor) {
      insert(target, button_1, anchor);
      append(button_1, t2);
      if (!mounted) {
        dispose = listen(
          button_1,
          "click",
          /*act*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*button*/
      1 && t_value !== (t_value = /*button*/
      ctx2[0].caption + ""))
        set_data(t2, t_value);
      if (dirty & /*button*/
      1) {
        toggle_class(
          button_1,
          "suggested",
          /*button*/
          ctx2[0].suggested
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button_1);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$Q($$self, $$props, $$invalidate) {
  let { button } = $$props;
  let { msg } = $$props;
  function act() {
    button.action();
    close();
  }
  function close() {
    closeError(msg.id);
  }
  $$self.$$set = ($$props2) => {
    if ("button" in $$props2)
      $$invalidate(0, button = $$props2.button);
    if ("msg" in $$props2)
      $$invalidate(2, msg = $$props2.msg);
  };
  return [button, act, msg];
}
class Button extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Q, create_fragment$R, safe_not_equal, { button: 0, msg: 2 });
  }
}
function get_each_context$9(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list2[i2];
  return child_ctx;
}
function create_if_block$s(ctx) {
  let div;
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      div = element("div");
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*msg*/
      ctx[0].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*msg*/
      ctx[0].title);
      attr(div, "class", "errimg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
    },
    p(ctx2, dirty) {
      if (dirty & /*msg*/
      1 && !src_url_equal(img.src, img_src_value = /*msg*/
      ctx2[0].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*msg*/
      1 && img_alt_value !== (img_alt_value = /*msg*/
      ctx2[0].title)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block$9(ctx) {
  let button_1;
  let current;
  button_1 = new Button({
    props: {
      button: (
        /*button*/
        ctx[1]
      ),
      msg: (
        /*msg*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(button_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_1_changes = {};
      if (dirty & /*msg*/
      1)
        button_1_changes.button = /*button*/
        ctx2[1];
      if (dirty & /*msg*/
      1)
        button_1_changes.msg = /*msg*/
        ctx2[0];
      button_1.$set(button_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button_1, detaching);
    }
  };
}
function create_fragment$Q(ctx) {
  let div1;
  let t0;
  let div0;
  let h3;
  let t1_value = (
    /*msg*/
    ctx[0].title + ""
  );
  let t1;
  let t2;
  let p2;
  let raw_value = (
    /*msg*/
    (ctx[0].message || "$error.message") + ""
  );
  let t3;
  let div3;
  let div2;
  let current;
  let if_block = (
    /*msg*/
    ctx[0].image && create_if_block$s(ctx)
  );
  let each_value = ensure_array_like(
    /*msg*/
    ctx[0].buttons
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$9(get_each_context$9(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div0 = element("div");
      h3 = element("h3");
      t1 = text(t1_value);
      t2 = space();
      p2 = element("p");
      t3 = space();
      div3 = element("div");
      div2 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(h3, "class", "error-title");
      attr(p2, "class", "error-message");
      attr(div0, "class", "error-content");
      attr(div1, "class", "error-dialog");
      attr(div2, "class", "inner");
      attr(div3, "class", "error-buttons");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div0, h3);
      append(h3, t1);
      append(div0, t2);
      append(div0, p2);
      p2.innerHTML = raw_value;
      insert(target, t3, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div2, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*msg*/
        ctx2[0].image
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$s(ctx2);
          if_block.c();
          if_block.m(div1, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if ((!current || dirty & /*msg*/
      1) && t1_value !== (t1_value = /*msg*/
      ctx2[0].title + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & /*msg*/
      1) && raw_value !== (raw_value = /*msg*/
      (ctx2[0].message || "$error.message") + ""))
        p2.innerHTML = raw_value;
      if (dirty & /*msg*/
      1) {
        each_value = ensure_array_like(
          /*msg*/
          ctx2[0].buttons
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$9(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$9(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div2, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t3);
        detach(div3);
      }
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$P($$self, $$props, $$invalidate) {
  let { msg } = $$props;
  $$self.$$set = ($$props2) => {
    if ("msg" in $$props2)
      $$invalidate(0, msg = $$props2.msg);
  };
  return [msg];
}
class ErrorDialog extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$P, create_fragment$Q, safe_not_equal, { msg: 0 });
  }
}
function generateCSS(app) {
  let cssString = "";
  cssString += `min-width: ${app.minSize.w}px;`;
  cssString += `min-height: ${app.minSize.h}px;`;
  cssString += `max-width: ${app.maxSize.w}px;`;
  cssString += `max-height: ${app.maxSize.h}px;`;
  cssString += `width: ${app.size.w}px;`;
  cssString += `height: ${app.size.h}px;`;
  return cssString;
}
function generateOverlayCSS(app) {
  let cssString = "";
  cssString += `min-width: ${app.size.w}px;`;
  cssString += `min-height: ${app.size.h}px;`;
  cssString += `max-width: ${app.size.w}px;`;
  cssString += `max-height: ${app.size.h}px;`;
  cssString += `width: ${app.size.w}px;`;
  cssString += `height: ${app.size.h}px;`;
  return cssString;
}
const error = "";
function get_each_context$8(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list2[i2];
  return child_ctx;
}
function create_if_block_1$6(ctx) {
  let div;
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      div = element("div");
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*error*/
      ctx[0].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*error*/
      ctx[0].title);
      attr(div, "class", "errimg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
    },
    p(ctx2, dirty) {
      if (dirty & /*error*/
      1 && !src_url_equal(img.src, img_src_value = /*error*/
      ctx2[0].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*error*/
      1 && img_alt_value !== (img_alt_value = /*error*/
      ctx2[0].title)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_else_block$7(ctx) {
  let html_tag;
  let raw_value = (
    /*error*/
    (ctx[0].message || "$error.message") + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*error*/
      1 && raw_value !== (raw_value = /*error*/
      (ctx2[0].message || "$error.message") + ""))
        html_tag.p(raw_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_if_block$r(ctx) {
  let div;
  let switch_instance;
  let current;
  var switch_value = (
    /*error*/
    ctx[0].component
  );
  function switch_props(ctx2, dirty) {
    return { props: { error: (
      /*error*/
      ctx2[0]
    ) } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "class", "component");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*error*/
      1 && switch_value !== (switch_value = /*error*/
      ctx2[0].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*error*/
        1)
          switch_instance_changes.error = /*error*/
          ctx2[0];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_each_block$8(ctx) {
  let button_1;
  let t_value = (
    /*button*/
    ctx[6].caption + ""
  );
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[4](
        /*button*/
        ctx[6]
      )
    );
  }
  return {
    c() {
      button_1 = element("button");
      t2 = text(t_value);
      toggle_class(
        button_1,
        "suggested",
        /*button*/
        ctx[6].suggested
      );
    },
    m(target, anchor) {
      insert(target, button_1, anchor);
      append(button_1, t2);
      if (!mounted) {
        dispose = listen(button_1, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*error*/
      1 && t_value !== (t_value = /*button*/
      ctx[6].caption + ""))
        set_data(t2, t_value);
      if (dirty & /*error*/
      1) {
        toggle_class(
          button_1,
          "suggested",
          /*button*/
          ctx[6].suggested
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button_1);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$P(ctx) {
  let div5;
  let window2;
  let div4;
  let div1;
  let t0;
  let div0;
  let h3;
  let t1_value = (
    /*error*/
    ctx[0].title + ""
  );
  let t1;
  let t2;
  let p2;
  let current_block_type_index;
  let if_block1;
  let t3;
  let div3;
  let div2;
  let current;
  let if_block0 = (
    /*error*/
    ctx[0].image && create_if_block_1$6(ctx)
  );
  const if_block_creators = [create_if_block$r, create_else_block$7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*error*/
      ctx2[0].component
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let each_value = ensure_array_like(
    /*error*/
    ctx[0].buttons
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$8(get_each_context$8(ctx, each_value, i2));
  }
  return {
    c() {
      div5 = element("div");
      window2 = element("window");
      div4 = element("div");
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      h3 = element("h3");
      t1 = text(t1_value);
      t2 = space();
      p2 = element("p");
      if_block1.c();
      t3 = space();
      div3 = element("div");
      div2 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(h3, "class", "error-title");
      attr(p2, "class", "error-message");
      attr(div0, "class", "error-content");
      attr(div1, "class", "error-overlay");
      attr(div2, "class", "inner");
      attr(div3, "class", "error-overlay-buttons");
      attr(div4, "class", "body overlay");
      attr(window2, "class", "window headless overlay overlayable-error");
      toggle_class(
        window2,
        "visible",
        /*show*/
        ctx[1]
      );
      attr(div5, "class", "overlay-wrapper");
      toggle_class(
        div5,
        "show",
        /*show*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, window2);
      append(window2, div4);
      append(div4, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div0, h3);
      append(h3, t1);
      append(div0, t2);
      append(div0, p2);
      if_blocks[current_block_type_index].m(p2, null);
      append(div4, t3);
      append(div4, div3);
      append(div3, div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div2, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*error*/
        ctx2[0].image
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$6(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((!current || dirty & /*error*/
      1) && t1_value !== (t1_value = /*error*/
      ctx2[0].title + ""))
        set_data(t1, t1_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(p2, null);
      }
      if (dirty & /*error, e*/
      5) {
        each_value = ensure_array_like(
          /*error*/
          ctx2[0].buttons
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$8(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$8(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div2, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & /*show*/
      2) {
        toggle_class(
          window2,
          "visible",
          /*show*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*show*/
      2) {
        toggle_class(
          div5,
          "show",
          /*show*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$O($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { error: error2 } = $$props;
  let show = false;
  function closeThis() {
    $$invalidate(1, show = false);
    setTimeout(
      () => {
        destroyOverlayableError(error2.id, app.id);
      },
      100
    );
  }
  onMount(() => {
    setTimeout(
      () => {
        $$invalidate(1, show = true);
      },
      100
    );
  });
  function e2(cb) {
    cb();
    closeThis();
  }
  const click_handler = (button) => e2(button.action);
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(3, app = $$props2.app);
    if ("error" in $$props2)
      $$invalidate(0, error2 = $$props2.error);
  };
  return [error2, show, e2, app, click_handler];
}
class OverlayableErrorWindow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$O, create_fragment$P, safe_not_equal, { app: 3, error: 0 });
  }
}
function create_if_block$q(ctx) {
  let div1;
  let window2;
  let div0;
  let switch_instance;
  let current;
  var switch_value = (
    /*overlay*/
    ctx[0].content
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        overlay: (
          /*overlay*/
          ctx2[0]
        ),
        app: (
          /*app*/
          ctx2[1]
        ),
        id: (
          /*id*/
          ctx2[2]
        ),
        runtime: (
          /*runtime*/
          ctx2[3]
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      div1 = element("div");
      window2 = element("window");
      div0 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div0, "class", "body overlay");
      attr(window2, "class", "window headless overlay");
      attr(
        window2,
        "style",
        /*css*/
        ctx[5]
      );
      attr(
        window2,
        "id",
        /*id*/
        ctx[2]
      );
      toggle_class(
        window2,
        "visible",
        /*show*/
        ctx[4]
      );
      attr(div1, "class", "overlay-wrapper");
      toggle_class(
        div1,
        "show",
        /*show*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, window2);
      append(window2, div0);
      if (switch_instance)
        mount_component(switch_instance, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*overlay*/
      1 && switch_value !== (switch_value = /*overlay*/
      ctx2[0].content)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div0, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*overlay*/
        1)
          switch_instance_changes.overlay = /*overlay*/
          ctx2[0];
        if (dirty & /*app*/
        2)
          switch_instance_changes.app = /*app*/
          ctx2[1];
        if (dirty & /*id*/
        4)
          switch_instance_changes.id = /*id*/
          ctx2[2];
        if (dirty & /*runtime*/
        8)
          switch_instance_changes.runtime = /*runtime*/
          ctx2[3];
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty & /*css*/
      32) {
        attr(
          window2,
          "style",
          /*css*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*id*/
      4) {
        attr(
          window2,
          "id",
          /*id*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*show*/
      16) {
        toggle_class(
          window2,
          "visible",
          /*show*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*show*/
      16) {
        toggle_class(
          div1,
          "show",
          /*show*/
          ctx2[4]
        );
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_fragment$O(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*overlay*/
    ctx[0] && /*app*/
    ctx[1] && create_if_block$q(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*overlay*/
        ctx2[0] && /*app*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*overlay, app*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$q(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$N($$self, $$props, $$invalidate) {
  let { overlay } = $$props;
  let { app } = $$props;
  let { id } = $$props;
  let { runtime } = $$props;
  let show = false;
  let css = "";
  onMount(() => {
    $$invalidate(5, css = generateOverlayCSS(overlay));
  });
  WindowStore.subscribe(() => {
    $$invalidate(5, css = generateOverlayCSS(overlay));
    $$invalidate(4, show = app.overlays[id] ? app.overlays[id].show : false);
  });
  $$self.$$set = ($$props2) => {
    if ("overlay" in $$props2)
      $$invalidate(0, overlay = $$props2.overlay);
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
    if ("id" in $$props2)
      $$invalidate(2, id = $$props2.id);
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [overlay, app, id, runtime, show, css];
}
class OverlayableWindow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$N, create_fragment$O, safe_not_equal, { overlay: 0, app: 1, id: 2, runtime: 3 });
  }
}
function create_fragment$N(ctx) {
  let div;
  let switch_instance;
  let t2;
  let current;
  var switch_value = (
    /*app*/
    ctx[0].content
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        app: (
          /*app*/
          ctx2[0]
        ),
        runtime: (
          /*runtime*/
          ctx2[1]
        ),
        appdata: (
          /*$UserData*/
          ctx2[2] ? (
            /*$UserData*/
            ctx2[2].appdata[
              /*app*/
              ctx2[0].id
            ] || {}
          ) : {}
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t2 = space();
      if (default_slot)
        default_slot.c();
      attr(div, "class", "body");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      append(div, t2);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*app*/
      1 && switch_value !== (switch_value = /*app*/
      ctx2[0].content)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, t2);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*app*/
        1)
          switch_instance_changes.app = /*app*/
          ctx2[0];
        if (dirty & /*runtime*/
        2)
          switch_instance_changes.runtime = /*runtime*/
          ctx2[1];
        if (dirty & /*$UserData, app*/
        5)
          switch_instance_changes.appdata = /*$UserData*/
          ctx2[2] ? (
            /*$UserData*/
            ctx2[2].appdata[
              /*app*/
              ctx2[0].id
            ] || {}
          ) : {};
        switch_instance.$set(switch_instance_changes);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (switch_instance)
        destroy_component(switch_instance);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$M($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(2, $UserData = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { app } = $$props;
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [app, runtime, $UserData, $$scope, slots];
}
class Content5 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$M, create_fragment$N, safe_not_equal, { app: 0, runtime: 1 });
  }
}
function create_else_block$6(ctx) {
  let default_1;
  let current;
  default_1 = new Default({
    props: {
      app: (
        /*app*/
        ctx[1]
      ),
      cls: (
        /*cls*/
        ctx[6]
      ),
      min: (
        /*min*/
        ctx[4]
      ),
      max: (
        /*max*/
        ctx[5]
      ),
      isBoot: (
        /*isBoot*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(default_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(default_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const default_1_changes = {};
      if (dirty & /*app*/
      2)
        default_1_changes.app = /*app*/
        ctx2[1];
      if (dirty & /*isBoot*/
      4)
        default_1_changes.isBoot = /*isBoot*/
        ctx2[2];
      default_1.$set(default_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(default_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(default_1, detaching);
    }
  };
}
function create_if_block$p(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = titlebarButtons[
    /*$UserData*/
    ctx[3].sh.window.buttons
  ].content;
  function switch_props(ctx2, dirty) {
    return {
      props: {
        cls: (
          /*cls*/
          ctx2[6]
        ),
        min: (
          /*min*/
          ctx2[4]
        ),
        max: (
          /*max*/
          ctx2[5]
        ),
        app: (
          /*app*/
          ctx2[1]
        ),
        isBoot: (
          /*isBoot*/
          ctx2[2]
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$UserData*/
      8 && switch_value !== (switch_value = titlebarButtons[
        /*$UserData*/
        ctx2[3].sh.window.buttons
      ].content)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*app*/
        2)
          switch_instance_changes.app = /*app*/
          ctx2[1];
        if (dirty & /*isBoot*/
        4)
          switch_instance_changes.isBoot = /*isBoot*/
          ctx2[2];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$M(ctx) {
  let div2;
  let div0;
  let t0_value = (
    /*app*/
    ctx[1].info.name + ""
  );
  let t0;
  let t1_value = (
    /*app*/
    (ctx[1].info.titleSuffix || "") + ""
  );
  let t1;
  let t2;
  let p2;
  let img;
  let img_src_value;
  let img_alt_value;
  let t3;
  let span;
  let t4_value = (
    /*app*/
    ctx[1].info.name + ""
  );
  let t4;
  let t5_value = (
    /*app*/
    (ctx[1].info.titleSuffix || "") + ""
  );
  let t5;
  let t6;
  let div1;
  let current_block_type_index;
  let if_block;
  let div2_data_appid_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$p, create_else_block$6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$UserData*/
      ctx2[3] && /*$UserData*/
      ctx2[3].sh.window.buttons
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = text(t1_value);
      t2 = space();
      p2 = element("p");
      img = element("img");
      t3 = space();
      span = element("span");
      t4 = text(t4_value);
      t5 = text(t5_value);
      t6 = space();
      div1 = element("div");
      if_block.c();
      attr(div0, "class", "centeredtitle");
      attr(img, "class", "icon");
      if (!src_url_equal(img.src, img_src_value = getAppIcon(
        /*app*/
        ctx[1]
      )))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*app*/
      ctx[1].info.name);
      attr(p2, "class", "title");
      attr(div1, "class", "controls");
      attr(div2, "class", "titlebar");
      attr(div2, "data-contextmenu", "window-titlebar");
      attr(div2, "data-appid", div2_data_appid_value = /*app*/
      ctx[1].id);
      toggle_class(
        div2,
        "centered",
        /*$UserData*/
        ctx[3] && /*$UserData*/
        ctx[3].sh.window.centertb
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div0, t1);
      append(div2, t2);
      append(div2, p2);
      append(p2, img);
      append(p2, t3);
      append(p2, span);
      append(span, t4);
      append(span, t5);
      append(div2, t6);
      append(div2, div1);
      if_blocks[current_block_type_index].m(div1, null);
      ctx[8](div2);
      current = true;
      if (!mounted) {
        dispose = listen(
          div2,
          "dblclick",
          /*max*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*app*/
      2) && t0_value !== (t0_value = /*app*/
      ctx2[1].info.name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & /*app*/
      2) && t1_value !== (t1_value = /*app*/
      (ctx2[1].info.titleSuffix || "") + ""))
        set_data(t1, t1_value);
      if (!current || dirty & /*app*/
      2 && !src_url_equal(img.src, img_src_value = getAppIcon(
        /*app*/
        ctx2[1]
      ))) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*app*/
      2 && img_alt_value !== (img_alt_value = /*app*/
      ctx2[1].info.name)) {
        attr(img, "alt", img_alt_value);
      }
      if ((!current || dirty & /*app*/
      2) && t4_value !== (t4_value = /*app*/
      ctx2[1].info.name + ""))
        set_data(t4, t4_value);
      if ((!current || dirty & /*app*/
      2) && t5_value !== (t5_value = /*app*/
      (ctx2[1].info.titleSuffix || "") + ""))
        set_data(t5, t5_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, null);
      }
      if (!current || dirty & /*app*/
      2 && div2_data_appid_value !== (div2_data_appid_value = /*app*/
      ctx2[1].id)) {
        attr(div2, "data-appid", div2_data_appid_value);
      }
      if (!current || dirty & /*$UserData*/
      8) {
        toggle_class(
          div2,
          "centered",
          /*$UserData*/
          ctx2[3] && /*$UserData*/
          ctx2[3].sh.window.centertb
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if_blocks[current_block_type_index].d();
      ctx[8](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$L($$self, $$props, $$invalidate) {
  let $UserData;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(3, $UserData = $$value));
  let { exttransition = false } = $$props;
  let { titlebar } = $$props;
  let { app } = $$props;
  let { isBoot = false } = $$props;
  function min() {
    $$invalidate(1, app.state.windowState.min = !app.state.windowState.min, app);
    updateStores();
  }
  function max() {
    if (!app.controls.max)
      return;
    $$invalidate(1, app.state.windowState.max = !app.state.windowState.max, app);
    if (app.state.windowState.max)
      $$invalidate(7, exttransition = true);
    else {
      setTimeout(
        () => {
          $$invalidate(7, exttransition = false);
        },
        200
      );
    }
    updateStores();
  }
  function cls() {
    const id = app.id;
    const errorId = id.startsWith("error_") ? parseInt(id.replace("error_", "")) : -1;
    if (errorId > 0)
      closeError(errorId);
    else
      closeWindow(app.id);
    if (isBoot)
      $$invalidate(1, app.opened = false, app);
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      titlebar = $$value;
      $$invalidate(0, titlebar);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("exttransition" in $$props2)
      $$invalidate(7, exttransition = $$props2.exttransition);
    if ("titlebar" in $$props2)
      $$invalidate(0, titlebar = $$props2.titlebar);
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
    if ("isBoot" in $$props2)
      $$invalidate(2, isBoot = $$props2.isBoot);
  };
  return [titlebar, app, isBoot, $UserData, min, max, cls, exttransition, div2_binding];
}
class Titlebar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$L, create_fragment$M, safe_not_equal, {
      exttransition: 7,
      titlebar: 0,
      app: 1,
      isBoot: 2
    });
  }
}
function get_each_context$7(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list2[i2];
  return child_ctx;
}
function get_each_context_1$1(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list2[i2];
  return child_ctx;
}
function create_if_block$o(ctx) {
  let window_12;
  let div;
  let t0;
  let titlebar_1;
  let updating_exttransition;
  let updating_titlebar;
  let t1;
  let show_if = (!/*app*/
  ctx[1].runtime ? true : (
    /*runtime*/
    ctx[7]
  )) && /*app*/
  (ctx[1].opened || /*app*/
  ctx[1].core || /*app*/
  ctx[1].info.preloaded) || /*app*/
  ctx[1] && /*app*/
  ctx[1].id.startsWith("error_");
  let t2;
  let t3;
  let window_1_id_value;
  let draggable_action;
  let current;
  let mounted;
  let dispose;
  function titlebar_1_exttransition_binding(value) {
    ctx[15](value);
  }
  function titlebar_1_titlebar_binding(value) {
    ctx[16](value);
  }
  let titlebar_1_props = {
    app: (
      /*app*/
      ctx[1]
    ),
    isBoot: (
      /*isBoot*/
      ctx[4]
    )
  };
  if (
    /*exttransition*/
    ctx[0] !== void 0
  ) {
    titlebar_1_props.exttransition = /*exttransition*/
    ctx[0];
  }
  if (
    /*titlebar*/
    ctx[6] !== void 0
  ) {
    titlebar_1_props.titlebar = /*titlebar*/
    ctx[6];
  }
  titlebar_1 = new Titlebar({ props: titlebar_1_props });
  binding_callbacks.push(() => bind$1(titlebar_1, "exttransition", titlebar_1_exttransition_binding));
  binding_callbacks.push(() => bind$1(titlebar_1, "titlebar", titlebar_1_titlebar_binding));
  let if_block0 = show_if && create_if_block_3(ctx);
  let if_block1 = (
    /*app*/
    ctx[1] && /*app*/
    ctx[1].overlays && (!/*app*/
    ctx[1].runtime ? true : (
      /*runtime*/
      ctx[7]
    )) && create_if_block_2$1(ctx)
  );
  let if_block2 = (
    /*app*/
    ctx[1] && /*app*/
    ctx[1].errorOverlays && create_if_block_1$5(ctx)
  );
  return {
    c() {
      window_12 = element("window");
      div = element("div");
      t0 = space();
      create_component(titlebar_1.$$.fragment);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      attr(div, "class", "accent");
      attr(window_12, "class", "shell-colored");
      attr(
        window_12,
        "style",
        /*cssString*/
        ctx[5]
      );
      attr(window_12, "id", window_1_id_value = /*app*/
      ctx[1].id);
      toggle_class(window_12, "window", !/*app*/
      ctx[1].info.custom);
      toggle_class(
        window_12,
        "focused",
        /*app*/
        ctx[1].id == /*$focusedWindowId*/
        ctx[9]
      );
      toggle_class(
        window_12,
        "headless",
        /*app*/
        ctx[1].state.headless || /*app*/
        ctx[1].state.windowState.fll
      );
      toggle_class(
        window_12,
        "resizable",
        /*app*/
        ctx[1].state.resizable
      );
      toggle_class(
        window_12,
        "min",
        /*app*/
        ctx[1].state.windowState.min
      );
      toggle_class(
        window_12,
        "max",
        /*app*/
        ctx[1].state.windowState.max || /*max*/
        ctx[3]
      );
      toggle_class(
        window_12,
        "visible",
        /*app*/
        ctx[1].opened || /*visible*/
        ctx[2]
      );
      toggle_class(
        window_12,
        "exttransition",
        /*exttransition*/
        ctx[0]
      );
      toggle_class(
        window_12,
        "fullscreen",
        /*app*/
        ctx[1].state.windowState.fll || /*app*/
        ctx[1].info.custom
      );
      toggle_class(
        window_12,
        "glass",
        /*app*/
        ctx[1].glass
      );
      toggle_class(
        window_12,
        "lefttb",
        /*$UserData*/
        ctx[10] && /*$UserData*/
        ctx[10].sh.window.lefttb
      );
      toggle_class(
        window_12,
        "custom",
        /*app*/
        ctx[1].info.custom
      );
      toggle_class(window_12, "child", !!/*app*/
      ctx[1].parentId);
      toggle_class(
        window_12,
        "colored",
        /*$UserData*/
        ctx[10] && /*$UserData*/
        ctx[10].sh.taskbar.colored && /*$focusedWindowId*/
        ctx[9] == /*app*/
        ctx[1].id
      );
    },
    m(target, anchor) {
      insert(target, window_12, anchor);
      append(window_12, div);
      append(window_12, t0);
      mount_component(titlebar_1, window_12, null);
      append(window_12, t1);
      if (if_block0)
        if_block0.m(window_12, null);
      append(window_12, t2);
      if (if_block1)
        if_block1.m(window_12, null);
      append(window_12, t3);
      if (if_block2)
        if_block2.m(window_12, null);
      ctx[17](window_12);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            window_12,
            "mousedown",
            /*handleMouse*/
            ctx[11]
          ),
          action_destroyer(draggable_action = d$1.call(null, window_12, {
            disabled: (
              /*app*/
              ctx[1].state.windowState.max || /*max*/
              ctx[3] || /*app*/
              ctx[1].core || /*app*/
              ctx[1].info.custom || /*app*/
              ctx[1].state.windowState.min || !/*app*/
              (ctx[1].opened || /*visible*/
              ctx[2])
            ),
            handle: ".titlebar",
            bounds: { top: 0, left: 0, right: 0, bottom: -1e3 },
            defaultPosition: {
              x: (
                /*app*/
                ctx[1].pos.x
              ),
              y: (
                /*app*/
                ctx[1].pos.y
              )
            }
          })),
          listen(
            window_12,
            "neodrag:start",
            /*handleDragStart*/
            ctx[12]
          ),
          listen(
            window_12,
            "neodrag:end",
            /*handleDragEnd*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const titlebar_1_changes = {};
      if (dirty & /*app*/
      2)
        titlebar_1_changes.app = /*app*/
        ctx2[1];
      if (dirty & /*isBoot*/
      16)
        titlebar_1_changes.isBoot = /*isBoot*/
        ctx2[4];
      if (!updating_exttransition && dirty & /*exttransition*/
      1) {
        updating_exttransition = true;
        titlebar_1_changes.exttransition = /*exttransition*/
        ctx2[0];
        add_flush_callback(() => updating_exttransition = false);
      }
      if (!updating_titlebar && dirty & /*titlebar*/
      64) {
        updating_titlebar = true;
        titlebar_1_changes.titlebar = /*titlebar*/
        ctx2[6];
        add_flush_callback(() => updating_titlebar = false);
      }
      titlebar_1.$set(titlebar_1_changes);
      if (dirty & /*app, runtime*/
      130)
        show_if = (!/*app*/
        ctx2[1].runtime ? true : (
          /*runtime*/
          ctx2[7]
        )) && /*app*/
        (ctx2[1].opened || /*app*/
        ctx2[1].core || /*app*/
        ctx2[1].info.preloaded) || /*app*/
        ctx2[1] && /*app*/
        ctx2[1].id.startsWith("error_");
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*app, runtime*/
          130) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(window_12, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*app*/
        ctx2[1] && /*app*/
        ctx2[1].overlays && (!/*app*/
        ctx2[1].runtime ? true : (
          /*runtime*/
          ctx2[7]
        ))
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*app, runtime*/
          130) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(window_12, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*app*/
        ctx2[1] && /*app*/
        ctx2[1].errorOverlays
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*app*/
          2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$5(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(window_12, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*cssString*/
      32) {
        attr(
          window_12,
          "style",
          /*cssString*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*app*/
      2 && window_1_id_value !== (window_1_id_value = /*app*/
      ctx2[1].id)) {
        attr(window_12, "id", window_1_id_value);
      }
      if (draggable_action && is_function(draggable_action.update) && dirty & /*app, max, visible*/
      14)
        draggable_action.update.call(null, {
          disabled: (
            /*app*/
            ctx2[1].state.windowState.max || /*max*/
            ctx2[3] || /*app*/
            ctx2[1].core || /*app*/
            ctx2[1].info.custom || /*app*/
            ctx2[1].state.windowState.min || !/*app*/
            (ctx2[1].opened || /*visible*/
            ctx2[2])
          ),
          handle: ".titlebar",
          bounds: { top: 0, left: 0, right: 0, bottom: -1e3 },
          defaultPosition: {
            x: (
              /*app*/
              ctx2[1].pos.x
            ),
            y: (
              /*app*/
              ctx2[1].pos.y
            )
          }
        });
      if (!current || dirty & /*app*/
      2) {
        toggle_class(window_12, "window", !/*app*/
        ctx2[1].info.custom);
      }
      if (!current || dirty & /*app, $focusedWindowId*/
      514) {
        toggle_class(
          window_12,
          "focused",
          /*app*/
          ctx2[1].id == /*$focusedWindowId*/
          ctx2[9]
        );
      }
      if (!current || dirty & /*app*/
      2) {
        toggle_class(
          window_12,
          "headless",
          /*app*/
          ctx2[1].state.headless || /*app*/
          ctx2[1].state.windowState.fll
        );
      }
      if (!current || dirty & /*app*/
      2) {
        toggle_class(
          window_12,
          "resizable",
          /*app*/
          ctx2[1].state.resizable
        );
      }
      if (!current || dirty & /*app*/
      2) {
        toggle_class(
          window_12,
          "min",
          /*app*/
          ctx2[1].state.windowState.min
        );
      }
      if (!current || dirty & /*app, max*/
      10) {
        toggle_class(
          window_12,
          "max",
          /*app*/
          ctx2[1].state.windowState.max || /*max*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*app, visible*/
      6) {
        toggle_class(
          window_12,
          "visible",
          /*app*/
          ctx2[1].opened || /*visible*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*exttransition*/
      1) {
        toggle_class(
          window_12,
          "exttransition",
          /*exttransition*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*app*/
      2) {
        toggle_class(
          window_12,
          "fullscreen",
          /*app*/
          ctx2[1].state.windowState.fll || /*app*/
          ctx2[1].info.custom
        );
      }
      if (!current || dirty & /*app*/
      2) {
        toggle_class(
          window_12,
          "glass",
          /*app*/
          ctx2[1].glass
        );
      }
      if (!current || dirty & /*$UserData*/
      1024) {
        toggle_class(
          window_12,
          "lefttb",
          /*$UserData*/
          ctx2[10] && /*$UserData*/
          ctx2[10].sh.window.lefttb
        );
      }
      if (!current || dirty & /*app*/
      2) {
        toggle_class(
          window_12,
          "custom",
          /*app*/
          ctx2[1].info.custom
        );
      }
      if (!current || dirty & /*app*/
      2) {
        toggle_class(window_12, "child", !!/*app*/
        ctx2[1].parentId);
      }
      if (!current || dirty & /*$UserData, $focusedWindowId, app*/
      1538) {
        toggle_class(
          window_12,
          "colored",
          /*$UserData*/
          ctx2[10] && /*$UserData*/
          ctx2[10].sh.taskbar.colored && /*$focusedWindowId*/
          ctx2[9] == /*app*/
          ctx2[1].id
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(titlebar_1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(titlebar_1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(window_12);
      }
      destroy_component(titlebar_1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      ctx[17](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_3(ctx) {
  let content2;
  let current;
  content2 = new Content5({
    props: {
      app: (
        /*app*/
        ctx[1]
      ),
      runtime: (
        /*runtime*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(content2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(content2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const content_changes = {};
      if (dirty & /*app*/
      2)
        content_changes.app = /*app*/
        ctx2[1];
      if (dirty & /*runtime*/
      128)
        content_changes.runtime = /*runtime*/
        ctx2[7];
      if (dirty & /*$$scope*/
      262144) {
        content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      content2.$set(content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(content2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(content2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(content2, detaching);
    }
  };
}
function create_default_slot$1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block_2$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(Object.entries(
    /*app*/
    ctx[1].overlays
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*runtime, app, Object*/
      130) {
        each_value_1 = ensure_array_like(Object.entries(
          /*app*/
          ctx2[1].overlays
        ));
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1$1(ctx) {
  let overlayablewindow;
  let current;
  overlayablewindow = new OverlayableWindow({
    props: {
      runtime: (
        /*runtime*/
        ctx[7]
      ),
      app: (
        /*app*/
        ctx[1]
      ),
      overlay: (
        /*overlay*/
        ctx[23][1]
      ),
      id: (
        /*overlay*/
        ctx[23][0]
      )
    }
  });
  return {
    c() {
      create_component(overlayablewindow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overlayablewindow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const overlayablewindow_changes = {};
      if (dirty & /*runtime*/
      128)
        overlayablewindow_changes.runtime = /*runtime*/
        ctx2[7];
      if (dirty & /*app*/
      2)
        overlayablewindow_changes.app = /*app*/
        ctx2[1];
      if (dirty & /*app*/
      2)
        overlayablewindow_changes.overlay = /*overlay*/
        ctx2[23][1];
      if (dirty & /*app*/
      2)
        overlayablewindow_changes.id = /*overlay*/
        ctx2[23][0];
      overlayablewindow.$set(overlayablewindow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(overlayablewindow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overlayablewindow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overlayablewindow, detaching);
    }
  };
}
function create_if_block_1$5(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*app*/
    ctx[1].errorOverlays
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$7(get_each_context$7(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*app*/
      2) {
        each_value = ensure_array_like(
          /*app*/
          ctx2[1].errorOverlays
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$7(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$7(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$7(ctx) {
  let overlayableerrorwindow;
  let current;
  overlayableerrorwindow = new OverlayableErrorWindow({
    props: {
      error: (
        /*error*/
        ctx[20]
      ),
      app: (
        /*app*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(overlayableerrorwindow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overlayableerrorwindow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const overlayableerrorwindow_changes = {};
      if (dirty & /*app*/
      2)
        overlayableerrorwindow_changes.error = /*error*/
        ctx2[20];
      if (dirty & /*app*/
      2)
        overlayableerrorwindow_changes.app = /*app*/
        ctx2[1];
      overlayableerrorwindow.$set(overlayableerrorwindow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(overlayableerrorwindow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overlayableerrorwindow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overlayableerrorwindow, detaching);
    }
  };
}
function create_fragment$L(ctx) {
  let show_if = (
    /*app*/
    ctx[1] && !isDisabled(
      /*app*/
      ctx[1].id
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block$o(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*app*/
      2)
        show_if = /*app*/
        ctx2[1] && !isDisabled(
          /*app*/
          ctx2[1].id
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*app*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$o(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$K($$self, $$props, $$invalidate) {
  let $focusedWindowId;
  let $UserData;
  component_subscribe($$self, focusedWindowId, ($$value) => $$invalidate(9, $focusedWindowId = $$value));
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(10, $UserData = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { app = null } = $$props;
  let { visible = false } = $$props;
  let { max = false } = $$props;
  let { isBoot = false } = $$props;
  let cssString = "";
  let titlebar;
  let runtime;
  let window2;
  let { exttransition = false } = $$props;
  onMount(() => {
    focusedWindowId.set(app.id);
    update2();
    if (app.id.startsWith("error_"))
      ArcSoundBus.playSound("arcos.dialog.info");
  });
  function update2() {
    if (app.minSize.w > app.size.w || app.minSize.h > app.size.h)
      return;
    if (app.maxSize.w < app.minSize.w || app.maxSize.h < app.minSize.h)
      return;
    $$invalidate(5, cssString = generateCSS(app));
  }
  WindowStore.subscribe(() => {
    update2();
  });
  function handleMouse() {
    set_store_value(focusedWindowId, $focusedWindowId = app.id, $focusedWindowId);
  }
  focusedWindowId.subscribe((v2) => {
    if (!app || !app.events)
      return;
    if (v2 == app.id && app.events.focus)
      app.events.focus(app);
    if (v2 != app.id && app.events.blur)
      app.events.blur(app);
  });
  onMount(() => {
    if (app.runtime)
      $$invalidate(7, runtime = new app.runtime(app));
  });
  function handleDragStart() {
    window2.querySelectorAll("iframe").forEach((i2) => {
      i2.style.pointerEvents = "none";
    });
  }
  function handleDragEnd(e2) {
    window2.querySelectorAll("iframe").forEach((i2) => {
      i2.style.pointerEvents = "";
    });
  }
  function titlebar_1_exttransition_binding(value) {
    exttransition = value;
    $$invalidate(0, exttransition);
  }
  function titlebar_1_titlebar_binding(value) {
    titlebar = value;
    $$invalidate(6, titlebar);
  }
  function window_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      window2 = $$value;
      $$invalidate(8, window2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
    if ("visible" in $$props2)
      $$invalidate(2, visible = $$props2.visible);
    if ("max" in $$props2)
      $$invalidate(3, max = $$props2.max);
    if ("isBoot" in $$props2)
      $$invalidate(4, isBoot = $$props2.isBoot);
    if ("exttransition" in $$props2)
      $$invalidate(0, exttransition = $$props2.exttransition);
    if ("$$scope" in $$props2)
      $$invalidate(18, $$scope = $$props2.$$scope);
  };
  return [
    exttransition,
    app,
    visible,
    max,
    isBoot,
    cssString,
    titlebar,
    runtime,
    window2,
    $focusedWindowId,
    $UserData,
    handleMouse,
    handleDragStart,
    handleDragEnd,
    slots,
    titlebar_1_exttransition_binding,
    titlebar_1_titlebar_binding,
    window_1_binding,
    $$scope
  ];
}
class Window extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$K, create_fragment$L, safe_not_equal, {
      app: 1,
      visible: 2,
      max: 3,
      isBoot: 4,
      exttransition: 0
    });
  }
}
function get_each_context$6(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2];
  return child_ctx;
}
function get_each_context_1(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2];
  return child_ctx;
}
function create_if_block$n(ctx) {
  let errordialog;
  let current;
  errordialog = new ErrorDialog({ props: { msg: (
    /*msg*/
    ctx[5]
  ) } });
  return {
    c() {
      create_component(errordialog.$$.fragment);
    },
    m(target, anchor) {
      mount_component(errordialog, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const errordialog_changes = {};
      if (dirty & /*$ErrorMessages*/
      2)
        errordialog_changes.msg = /*msg*/
        ctx2[5];
      errordialog.$set(errordialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(errordialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(errordialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(errordialog, detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let if_block_anchor;
  let current;
  let if_block = `error_${/*msg*/
  ctx[5].id}` == /*app*/
  ctx[2].id && create_if_block$n(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (`error_${/*msg*/
      ctx2[5].id}` == /*app*/
      ctx2[2].id) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$ErrorMessages, $ErrorWindowStore*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$n(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_default_slot(ctx) {
  let t2;
  let current;
  let each_value_1 = ensure_array_like(
    /*$ErrorMessages*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$ErrorMessages, $ErrorWindowStore*/
      3) {
        each_value_1 = ensure_array_like(
          /*$ErrorMessages*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t2.parentNode, t2);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$6(ctx) {
  let window2;
  let current;
  window2 = new Window({
    props: {
      app: (
        /*app*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(window2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(window2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const window_changes = {};
      if (dirty & /*$ErrorWindowStore*/
      1)
        window_changes.app = /*app*/
        ctx2[2];
      if (dirty & /*$$scope, $ErrorMessages, $ErrorWindowStore*/
      259) {
        window_changes.$$scope = { dirty, ctx: ctx2 };
      }
      window2.$set(window_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(window2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(window2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(window2, detaching);
    }
  };
}
function create_fragment$K(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*$ErrorWindowStore*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$6(get_each_context$6(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "winstore");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$ErrorWindowStore, $ErrorMessages*/
      3) {
        each_value = ensure_array_like(
          /*$ErrorWindowStore*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$6(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$6(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$J($$self, $$props, $$invalidate) {
  let $ErrorWindowStore;
  let $ErrorMessages;
  component_subscribe($$self, ErrorWindowStore, ($$value) => $$invalidate(0, $ErrorWindowStore = $$value));
  component_subscribe($$self, ErrorMessages, ($$value) => $$invalidate(1, $ErrorMessages = $$value));
  return [$ErrorWindowStore, $ErrorMessages];
}
class ErrorDialogStore extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$J, create_fragment$K, safe_not_equal, {});
  }
}
function get_each_context$5(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2];
  return child_ctx;
}
function create_if_block$m(ctx) {
  let window2;
  let current;
  window2 = new Window({ props: { app: (
    /*app*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(window2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(window2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const window_changes = {};
      if (dirty & /*oa*/
      1)
        window_changes.app = /*app*/
        ctx2[2];
      window2.$set(window_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(window2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(window2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(window2, detaching);
    }
  };
}
function create_each_block$5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*app*/
    ctx[2] && create_if_block$m(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*app*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*oa*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$m(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$J(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*oa*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$5(get_each_context$5(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "winstore");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*oa*/
      1) {
        each_value = ensure_array_like(
          /*oa*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$I($$self, $$props, $$invalidate) {
  let $maxZIndex;
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(1, $maxZIndex = $$value));
  let oa2 = [];
  WindowStore.subscribe((v2) => {
    $$invalidate(0, oa2 = []);
    if (v2)
      $$invalidate(0, oa2 = v2);
    const openedStore = getOpenedStore();
    for (let i2 = 0; i2 < openedStore.length; i2++) {
      if (openedStore[i2].state.windowState.fll)
        return isFullscreenWindow.set(true);
    }
    isFullscreenWindow.set(false);
  });
  focusedWindowId.subscribe((v2) => {
    var _a;
    if ((_a = getWindow(v2)) == null ? void 0 : _a.info.custom)
      return;
    set_store_value(maxZIndex, $maxZIndex++, $maxZIndex);
    if (!v2 || v2.startsWith("error_")) {
      if (!v2)
        return;
      const el = document.querySelector(`#${v2}`);
      if (!el)
        return;
      el.style.zIndex = `${$maxZIndex}`;
      return;
    }
    const appData = getWindow(v2);
    if (!appData)
      return;
    const element2 = getWindowElement(appData);
    if (!element2)
      return;
    element2.style.zIndex = `${$maxZIndex}`;
  });
  return [oa2];
}
class WindowStore_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$I, create_fragment$J, safe_not_equal, {});
  }
}
function t(t2, r2, n2, e2) {
  var o2, i2 = arguments.length, a2 = i2 < 3 ? r2 : null === e2 ? e2 = Object.getOwnPropertyDescriptor(r2, n2) : e2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    a2 = Reflect.decorate(t2, r2, n2, e2);
  else
    for (var u3 = t2.length - 1; u3 >= 0; u3--)
      (o2 = t2[u3]) && (a2 = (i2 < 3 ? o2(a2) : i2 > 3 ? o2(r2, n2, a2) : o2(r2, n2)) || a2);
  return i2 > 3 && a2 && Object.defineProperty(r2, n2, a2), a2;
}
function r(t2, r2, n2) {
  if (n2 || 2 === arguments.length)
    for (var e2, o2 = 0, i2 = r2.length; o2 < i2; o2++)
      !e2 && o2 in r2 || (e2 || (e2 = Array.prototype.slice.call(r2, 0, o2)), e2[o2] = r2[o2]);
  return t2.concat(e2 || Array.prototype.slice.call(r2));
}
var n = function(t2, r2, n2) {
  return [t2, r2, n2].map(function(t3) {
    return (t3 /= 255) > 0.04045 ? Math.pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92;
  });
}, e = function(t2, r2, n2) {
  return [t2, r2, n2].map(function(t3) {
    return 255 * (t3 <= 304e-5 ? 12.92 * t3 : 1.055 * Math.pow(t3, 1 / 2.4) - 0.055);
  });
}, o = function(t2, r2, n2) {
  return Math.min(Math.max(t2, r2), n2);
}, i = function(t2, r2) {
  return Math.round((t2 + Number.EPSILON) * Math.pow(10, r2)) / Math.pow(10, r2);
}, a = function(t2, r2) {
  return Math.floor(Math.random() * (r2 - t2 + 1) - t2);
}, u2 = function(t2, r2, n2, e2) {
  for (var i2, a2 = [t2, r2, n2], u3 = "#", h2 = 0; h2 < a2.length; h2++)
    u3 += (i2 = a2[h2], Math.round(o(i2, 0, 255)).toString(16).padStart(2, "0"));
  return null != e2 && (u3 += Math.round(o(e2, 0, 100) / 100 * 255).toString(16).padStart(2, "0")), u3;
}, h = function(t2) {
  var n2 = t2.length, e2 = (t2 = function(t3) {
    var r2 = (t3 = /^#/.test(t3) ? t3.slice(1) : t3).length;
    if (![3, 4, 6, 8].includes(r2))
      return "000000";
    if (6 === r2 || 8 === r2)
      return t3;
    if (3 === r2 || 4 === r2) {
      for (var n3 = "", e3 = 0; e3 < r2; e3++) {
        var o3 = t3[e3];
        n3 += "" + o3 + o3;
      }
      return n3;
    }
    return "000000";
  }(t2).padEnd(8, "ff")).match(/.{2}/g);
  if (!e2)
    return [0, 0, 0, 1];
  var o2 = [0, 0, 0], i2 = false;
  return e2.forEach(function(t3, r2) {
    r2 < 3 ? o2[r2] = parseInt(t3, 16) : i2 = 100 * parseInt(t3, 16) / 255;
  }), false === i2 || n2 < 8 ? o2 : r(r([], o2, true), [i2], false);
}, c = function(t2, r2, n2) {
  var e2;
  e2 = [t2, r2, n2].map(function(t3) {
    return t3 / 255;
  }), t2 = e2[0], r2 = e2[1], n2 = e2[2];
  var o2 = 1 - Math.max(t2, r2, n2), i2 = o2 < 1 ? 1 / (1 - o2) : 0;
  return [(1 - t2 - o2) * i2 * 100, (1 - r2 - o2) * i2 * 100, (1 - n2 - o2) * i2 * 100, 100 * o2];
}, l = function(t2, r2, n2, e2) {
  return 100 === e2 ? [0, 0, 0] : (e2 /= 100, [t2, r2, n2].map(function(t3) {
    return (t3 /= 100) >= 1 ? 0 : 255 * (1 - t3) * (1 - e2);
  }));
};
function p(t2, r2, n2, e2) {
  var o2;
  void 0 === e2 && (e2 = "l"), o2 = [t2, r2, n2].map(function(t3) {
    return t3 / 255;
  }), t2 = o2[0], r2 = o2[1], n2 = o2[2];
  var i2 = Math.max(t2, r2, n2), a2 = Math.min(t2, r2, n2), u3 = function(t3, r3, n3, e3) {
    var o3;
    void 0 === e3 && (e3 = false), o3 = [t3, r3, n3].map(function(t4) {
      return t4 / 255;
    }), t3 = o3[0], r3 = o3[1], n3 = o3[2];
    var i3 = Math.max(t3, r3, n3), a3 = Math.min(t3, r3, n3), u4 = 0;
    if (i3 !== a3)
      if (e3)
        u4 = (t3 - r3 + (t3 - n3)) / 2, u4 /= Math.sqrt((t3 - r3) * (t3 - r3) + (t3 - n3) * (r3 - n3)), u4 = Math.acos(u4), n3 > r3 && (u4 = 2 * Math.PI - u4), u4 /= 2 * Math.PI;
      else {
        var h3 = i3 - a3;
        u4 = i3 === t3 ? (r3 - n3) / h3 + (r3 < n3 ? 6 : 0) : i3 === r3 ? (n3 - t3) / h3 + 2 : (t3 - r3) / h3 + 4, u4 /= 6;
      }
    else
      u4 = NaN;
    return 360 * u4;
  }(t2, r2, n2, "i" === e2), h2 = 0, c2 = (i2 + a2) / 2, l2 = i2 - a2, p2 = i2, f2 = (t2 + r2 + n2) / 3;
  return "v" === e2 && (h2 = 0 === i2 ? 0 : l2 / i2), i2 !== a2 && "l" === e2 && (h2 = c2 > 0.5 ? l2 / (2 - i2 - a2) : l2 / (i2 + a2)), "i" === e2 && (h2 = f2 > 0 ? 1 - a2 / f2 : 0), h2 *= 100, c2 *= 100, f2 *= 100, "l" === e2 ? [u3, h2, c2] : "v" === e2 ? [u3, h2, p2 *= 100] : [u3, h2, f2];
}
var f = function(t2, r2, n2) {
  return p(t2, r2, n2, "l");
}, s = function(t2, r2, n2) {
  var e2, i2, a2 = function(t3) {
    return 6 * (t3 = t3 < 0 ? t3 + 1 : t3 > 1 ? t3 - 1 : t3) < 1 ? e2 + (i2 - e2) * t3 * 6 : 2 * t3 < 1 ? i2 : 3 * t3 < 2 ? e2 + (i2 - e2) * (2 / 3 - t3) * 6 : e2;
  };
  return t2 = t2 % 360 / 360, r2 = o(r2 / 100, 0, 1), n2 = o(n2 / 100, 0, 1), e2 = 2 * n2 - (i2 = n2 <= 0.5 ? n2 * (r2 + 1) : n2 + r2 - n2 * r2), [255 * a2(t2 + 1 / 3), 255 * a2(t2), 255 * a2(t2 - 1 / 3)];
}, v = function(t2, r2, n2) {
  return p(t2, r2, n2, "v");
}, b = function(t2, r2, n2) {
  var e2, o2, i2 = [n2 /= 100, n2 * (1 - (r2 /= 100)), n2 * (1 - (o2 = (t2 = t2 % 360 / 360 * 360) / 60 - (e2 = Math.floor(t2 / 60 % 6))) * r2), n2 * (1 - (1 - o2) * r2)], a2 = [[0, 3, 1], [2, 0, 1], [1, 0, 3], [1, 2, 0], [3, 1, 0], [0, 1, 2]];
  return [255 * i2[a2[e2][0]], 255 * i2[a2[e2][1]], 255 * i2[a2[e2][2]]];
}, y = function(t2, r2, n2) {
  return p(t2, r2, n2, "i");
}, d2 = function(t2, r2, n2) {
  var e2, i2, a2, u3;
  r2 /= 100, n2 /= 100, isNaN(t2) && (t2 = 0), isNaN(r2) && (r2 = 0);
  var h2 = function(t3) {
    return (1 + r2 * Math.cos(2 * Math.PI * t3) / Math.cos(Math.PI / 3 - 2 * Math.PI * t3)) / 3;
  };
  return (t2 = (360 + t2) % 360 / 360) < 1 / 3 ? a2 = 1 - ((u3 = (1 - r2) / 3) + (i2 = h2(t2))) : t2 < 2 / 3 ? u3 = 1 - ((i2 = (1 - r2) / 3) + (a2 = h2(t2 -= 1 / 3))) : i2 = 1 - ((a2 = (1 - r2) / 3) + (u3 = h2(t2 -= 2 / 3))), e2 = [i2, a2, u3].map(function(t3) {
    return 255 * o(n2 * t3 * 3, 0, 1);
  }), [i2 = e2[0], a2 = e2[1], u3 = e2[2]];
}, g = function(t2, r2, n2) {
  return [f(t2, r2, n2)[0], 100 * (Math.min(t2, r2, n2) / 255), 100 * (1 - Math.max(t2, r2, n2) / 255)];
};
function w(t2, r2, n2) {
  return r2 /= 100, n2 /= 100, s(t2, 100, 50).map(function(t3) {
    return 255 * (t3 / 255 * (1 - r2 - n2) + r2);
  });
}
var m2 = { x: [0.4124564, 0.3575761, 0.1804375], y: [0.2126729, 0.7151522, 0.072175], z: [0.0193339, 0.119192, 0.9503041] }, M = { r: [3.2404542, -1.5371385, -0.4985314], g: [-0.969266, 1.8760108, 0.041556], b: [0.0556434, -0.2040259, 1.0572252] }, x = 0.95047, _ = 1, C = 1.08883, I = 0.206896552, k = 8856452e-9, E = 24389 / 27, z = function(t2, r2, e2) {
  var o2 = n(t2, r2, e2);
  return [100 * m2.x.reduce(function(t3, r3, n2) {
    return t3 + r3 * o2[n2];
  }, 0), 100 * m2.y.reduce(function(t3, r3, n2) {
    return t3 + r3 * o2[n2];
  }, 0), 100 * m2.z.reduce(function(t3, r3, n2) {
    return t3 + r3 * o2[n2];
  }, 0)];
}, N = function(t2, r2, n2) {
  var o2 = [t2, r2, n2], i2 = M.r.reduce(function(t3, r3, n3) {
    return t3 + r3 * o2[n3];
  }, 0) / 100, a2 = M.g.reduce(function(t3, r3, n3) {
    return t3 + r3 * o2[n3];
  }, 0) / 100, u3 = M.b.reduce(function(t3, r3, n3) {
    return t3 + r3 * o2[n3];
  }, 0) / 100;
  return e(i2, a2, u3);
}, O = function(t2, r2, n2) {
  var e2;
  return e2 = [t2 = t2 / x / 100, r2 = r2 / _ / 100, n2 = n2 / C / 100].map(function(t3) {
    return t3 > k ? Math.pow(t3, 1 / 3) : (E * t3 + 16) / 116;
  }), t2 = e2[0], r2 = e2[1], n2 = e2[2], [Math.max(0, 116 * r2 - 16), 500 * (t2 - r2), 200 * (r2 - n2)];
}, P = function(t2, r2, n2) {
  var e2, o2 = (t2 + 16) / 116, i2 = isNaN(r2) ? o2 : o2 + r2 / 500, a2 = isNaN(n2) ? o2 : o2 - n2 / 200;
  return e2 = [i2, o2, a2].map(function(t3) {
    return t3 > I ? Math.pow(t3, 3) : (116 * t3 - 16) / E;
  }), i2 = e2[0], o2 = e2[1], a2 = e2[2], [i2 * x * 100, o2 * _ * 100, a2 * C * 100];
}, j = function(t2, r2, n2) {
  return N.apply(void 0, P(t2, r2, n2));
}, S = function(t2, r2, n2) {
  r2 = o(r2, -100, 100), n2 = o(n2, -100, 100);
  var e2 = Math.sqrt(r2 * r2 + n2 * n2), i2 = (180 * Math.atan2(n2, r2) / Math.PI + 360) % 360;
  return 0 === Math.round(1e4 * e2) && (i2 = Number.NaN), [t2, e2, i2];
}, A = function(t2, r2, n2) {
  return isNaN(n2) && (n2 = 0), n2 *= Math.PI / 180, [t2, Math.cos(n2) * r2, Math.sin(n2) * r2];
}, L = function(t2, r2, n2) {
  return P.apply(void 0, A(t2, r2, n2));
}, H = function(t2, r2, n2) {
  var e2 = t2 + r2 + n2, o2 = 0, i2 = 0;
  return e2 > 0 && (o2 = t2 / e2, i2 = r2 / e2), [o2, i2, r2];
}, Y = Object.freeze({ __proto__: null, linear2rgb: e, rgb2linear: n, rgb2hex: u2, hex2rgb: h, rgb2cmyk: c, cmyk2rgb: l, rgb2hsl: f, hsl2rgb: s, rgb2hsv: v, hsv2rgb: b, rgb2hsi: y, hsi2rgb: d2, rgb2hwb: g, hwb2rgb: w, rgb2xyz: z, xyz2rgb: N, xyz2lab: O, lab2xyz: P, rgb2lab: function(t2, r2, n2) {
  return O.apply(void 0, z(t2, r2, n2));
}, lab2rgb: j, lch2lab: A, lab2lch: S, xyz2lch: function(t2, r2, n2) {
  return S.apply(void 0, O(t2, r2, n2));
}, lch2xyz: L, xyY2xyz: function(t2, r2, n2) {
  return 0 === r2 ? [0, 0, 0] : [t2 * (n2 / r2), n2, n2 / r2 * (1 - t2 - r2)];
}, xyz2xyY: H });
function R(t2, n2) {
  return void 0 === n2 && (n2 = false), function(e2, o2, i2) {
    var a2 = i2.value;
    i2.value = function() {
      for (var e3 = [], o3 = 0; o3 < arguments.length; o3++)
        e3[o3] = arguments[o3];
      if (e3.length > 0 && n2) {
        var i3 = JSON.stringify(e3);
        t2 += i3;
      }
      if (this.cache.has(t2))
        return this.cache.get(t2);
      var u3 = a2.call.apply(a2, r([this], e3, false));
      return this.cache.set(t2, u3), u3;
    };
  };
}
function q(t2, n2, e2, o2) {
  return void 0 === t2 && (t2 = [0, 2, 2]), void 0 === n2 && (n2 = 0), void 0 === e2 && (e2 = true), void 0 === o2 && (o2 = 0), function(a2, u3, h2) {
    var c2 = h2.value;
    h2.value = function() {
      for (var a3 = [], u4 = 0; u4 < arguments.length; u4++)
        a3[u4] = arguments[u4];
      var h3 = void 0 === a3[o2] ? e2 : a3[o2], l2 = c2.call.apply(c2, r([this], a3, false));
      if (false === h3)
        return l2;
      var p2 = "number" == typeof h3 ? Math.round(h3) : 0, f2 = "number" == typeof t2 ? new Array(l2.length).fill(t2) : t2, s2 = f2.map(function(t3) {
        return 1 === n2 ? "number" == typeof h3 ? p2 : t3 : t3 + p2;
      });
      return l2.map(function(t3, r2) {
        return i(t3, s2[r2]);
      });
    };
  };
}
var D = function(t2, r2, n2) {
  var e2 = t2 instanceof ft ? t2 : new ft(t2), i2 = r2 instanceof ft ? r2 : new ft(r2), a2 = o(n2, 0, 100) / 100, u3 = 2 * a2 - 1, h2 = e2.alpha() - i2.alpha(), c2 = ((u3 * h2 == -1 ? u3 : (u3 + h2) / (1 + u3 * h2)) + 1) / 2, l2 = 1 - c2, p2 = [Math.round(o(e2.red() * c2 + i2.red() * l2, 0, 255)), Math.round(o(e2.green() * c2 + i2.green() * l2, 0, 255)), Math.round(o(e2.blue() * c2 + i2.blue() * l2, 0, 255))], f2 = e2.alpha() * a2 + i2.alpha() * (1 - a2);
  return new ft(p2, f2);
}, F = Math.sqrt, U = Math.pow, $ = Math.cos, J = Math.abs, Z = Math.sin, B = Math.exp, G = Math.atan2, K = Math.PI, Q = function(t2) {
  return K * t2 / 180;
}, T = function(t2, r2, n2) {
  void 0 === n2 && (n2 = true);
  var e2 = G(r2, t2);
  return n2 && (e2 = (e2 = (e2 = 180 * e2 / K) > 0 ? e2 : e2 + 360) > 360 ? e2 - 360 : e2), e2;
}, V = function(t2, r2) {
  void 0 === r2 && (r2 = true);
  var n2 = t2.lab(false), e2 = n2[0], o2 = n2[1], i2 = n2[2];
  return [e2, F(U(o2, 2) + U(i2, 2)), T(o2, i2, r2), o2, i2];
}, W = ["CMC", "CIE", "CIE2000", "CIE1994", "CIE1976"], X = "CMC", tt = "CIE2000", rt = "CIE1994", nt = "CIE1976", et = function(t2, r2, n2, e2) {
  void 0 === n2 && (n2 = "CIE");
  var o2 = function(t3) {
    var r3 = t3.toUpperCase();
    return W.includes(r3) && "CIE" !== r3 ? r3 : tt;
  }(n2);
  if (e2 = e2 || {}, o2 === X) {
    var i2 = Object.assign({}, { l: 1, c: 1 }, e2);
    return function(t3, r3, n3, e3) {
      void 0 === n3 && (n3 = 1), void 0 === e3 && (e3 = 1);
      var o3 = V(t3, true), i3 = o3[0], a3 = o3[1], u4 = o3[2], h3 = o3[3], c3 = o3[4], l2 = V(r3), p2 = l2[0], f2 = l2[1], s2 = l2[3], v2 = a3 - f2, b2 = i3 - p2, y2 = c3 - l2[4], d3 = F(U(h3 - s2, 2) + U(y2, 2) - U(v2, 2)), g2 = i3 < 16 ? 0.511 : 0.040975 * i3 / (1 + 0.01765 * i3), w2 = 0.0638 * a3 / (1 + 0.0131 * a3) + 0.638, m3 = 164 <= u4 && u4 <= 345 ? 0.56 + J(0.2 * $(Q(u4 + 168))) : 0.36 + J(0.4 * $(Q(u4 + 35))), M2 = F(U(a3, 4) / (U(a3, 4) + 1900)), x2 = w2 * (M2 * m3 + 1 - M2);
      return F(U(b2 / (n3 * g2), 2) + U(v2 / (e3 * w2), 2) + U(d3 / x2, 2));
    }(t2, r2, i2.l, i2.c);
  }
  if (o2 === rt) {
    var a2 = { kL: 1, kC: 1, kH: 1, cate: "graphic" }, u3 = Object.assign({}, a2, e2);
    return function(t3, r3, n3, e3, o3, i3) {
      void 0 === n3 && (n3 = 1), void 0 === e3 && (e3 = 1), void 0 === o3 && (o3 = 1), void 0 === i3 && (i3 = "graphic");
      var a3 = "textiles" === i3 ? 0.048 : 0.045, u4 = "textiles" === i3 ? 0.014 : 0.015;
      n3 = "textiles" === i3 ? 2 : n3;
      var h3 = V(t3), c3 = h3[0], l2 = h3[1], p2 = h3[3], f2 = h3[4], s2 = V(r3), v2 = s2[0], b2 = s2[1], y2 = s2[3], d3 = c3 - v2, g2 = l2 - b2, w2 = f2 - s2[4], m3 = 1 + a3 * l2, M2 = 1 + u4 * l2, x2 = F(U(p2 - y2, 2) + U(w2, 2) - U(g2, 2));
      return F(U(d3 / (1 * n3), 2) + U(g2 / (e3 * m3), 2) + U(x2 / (o3 * M2), 2));
    }(t2, r2, u3.kL, u3.kC, u3.kH, u3.cate);
  }
  if (o2 === nt)
    return function(t3, r3) {
      var n3 = t3.lab(false), e3 = n3[0], o3 = n3[1], i3 = n3[2], a3 = r3.lab(false), u4 = a3[0], h3 = a3[1], c3 = a3[2];
      return F(U(e3 - u4, 2) + U(o3 - h3, 2) + U(i3 - c3, 2));
    }(t2, r2);
  var h2 = { kL: 1, kC: 1, kH: 1 }, c2 = Object.assign({}, h2, e2);
  return function(t3, r3, n3, e3, o3) {
    void 0 === n3 && (n3 = 1), void 0 === e3 && (e3 = 1), void 0 === o3 && (o3 = 1);
    var i3 = V(t3), a3 = i3[0], u4 = i3[1], h3 = i3[3], c3 = i3[4], l2 = V(r3), p2 = l2[0], f2 = l2[1], s2 = l2[3], v2 = l2[4], b2 = (a3 + p2) / 2, y2 = (u4 + f2) / 2, d3 = (1 - F(U(y2, 7) / (U(y2, 7) + U(25, 7)))) / 2, g2 = h3 * (1 + d3), w2 = s2 * (1 + d3), m3 = F(U(g2, 2) + U(c3, 2)), M2 = F(U(w2, 2) + U(v2, 2)), x2 = T(g2, c3, true), _2 = T(w2, v2, true), C2 = (m3 + M2) / 2, I2 = J(x2 - _2) > 180 ? (x2 + _2 + 360) / 2 : (x2 + _2) / 2, k2 = 1 - 0.17 * $(Q(I2 - 30)) + 0.24 * $(Q(2 * I2)) + 0.32 * $(Q(3 * I2 + 6)) - 0.2 * $(Q(4 * I2 - 63)), E2 = J(_2 - x2) <= 180 ? _2 - x2 : J(_2 - x2) > 180 && _2 <= x2 ? _2 - x2 + 360 : _2 - x2 - 360, z2 = p2 - a3, N2 = f2 - u4, O2 = 2 * F(m3 * M2) * Z(Q(E2) / 2), P2 = 1 + 0.015 * U(b2 - 50, 2) / F(20 + U(b2 - 50, 2)), j2 = 1 + 0.045 * C2, S2 = 1 + 0.015 * C2 * k2, A2 = 30 * B(-U((I2 - 275) / 25, 2)), L2 = -2 * F(U(C2, 7) / (U(C2, 7) + U(25, 7))) * Z(2 * Q(A2));
    return F(U(z2 / (n3 * P2), 2) + U(N2 / (e3 * j2), 2) + U(O2 / (o3 * S2), 2) + L2 * (N2 / (e3 * j2)) * (O2 / (o3 * S2)));
  }(t2, r2, c2.kL, c2.kC, c2.kH);
}, ot = function(t2, r2, n2) {
  var e2 = Math.abs, o2 = Math.max, i2 = Math.min, a2 = t2 instanceof ft ? t2 : new ft(t2), u3 = r2 instanceof ft ? r2 : new ft(r2), h2 = Object.assign({}, { b: 125, c: 500 }, n2);
  return !(e2(255 * a2.brightness() / 100 - 255 * u3.brightness() / 100) <= h2.b) && !(o2(a2.red(), u3.red()) - i2(a2.red(), u3.red()) + (o2(a2.green(), u3.green()) - i2(a2.green(), u3.green())) + (o2(a2.blue(), u3.blue()) - i2(a2.blue(), u3.blue())) <= h2.c);
}, it = function(t2, r2, n2) {
  var e2, i2 = function(t3) {
    return o(t3, 0, 100);
  }, a2 = function(t3) {
    return o(t3, 0, 255);
  }, u3 = { h: [0, function(t3) {
    return t3 % 360;
  }], s: [1, i2], l: [2, i2], r: [0, a2], g: [1, a2], b: [2, a2] }, h2 = u3[r2][0];
  if (["h", "s", "l"].includes(r2)) {
    var c2 = t2.hsl();
    if (void 0 === n2)
      return c2[h2];
    n2 = u3[r2][1](n2), c2[h2] = n2, e2 = s.apply(void 0, c2);
  } else {
    if (e2 = t2.rgb(), void 0 === n2)
      return e2[h2];
    n2 = u3[r2][1](n2), e2[h2] = n2;
  }
  return new ft(e2, t2.alpha());
}, at = {}, ut = /* @__PURE__ */ new Set(["rgb", "rgba", "cmyk", "lab", "hsl", "hsla", "hsv", "hsva", "hsi", "hsia", "xyz", "lch", "hwb", "hwba"]), ht = /^([a-zA-Z]+)\(([\s\S]+)\)$/, ct = function(t2) {
  return "string" == typeof t2 ? -1 === t2.indexOf("%") ? ct(Number(t2.trim())) : (t2 = t2.split("%")[0], (t2 = Number(t2.trim())) || 0) : Math.abs(t2) < 1 ? 100 * t2 : t2;
}, lt = function(t2, r2) {
  void 0 === r2 && (r2 = /* @__PURE__ */ new Set());
  var n2 = "string" == typeof t2 ? t2 : t2.join(",");
  if (r2.has(n2))
    throw new Error("Invalid Color");
  r2.add(n2);
  var e2 = "rgb", o2 = [0, 0, 0], i2 = 100;
  if (Array.isArray(t2)) {
    if (t2.length < 3)
      throw new Error("Invalid Color");
    for (var a2 = 0; a2 < t2.length; a2++)
      if (a2 < 3)
        o2[a2] = t2[a2];
      else {
        if (3 !== a2 || void 0 === t2[3])
          break;
        i2 = t2[3];
      }
  } else {
    var u3 = false, c2 = t2.trim().match(ht);
    if (c2 || (u3 = true), c2) {
      var l2 = c2[1].toLocaleLowerCase();
      if (e2 = l2, ut.has(l2) || (u3 = true), c2[2] && !u3) {
        var p2 = c2[2], f2 = -1 !== p2.indexOf(",") ? "," : " ", s2 = p2.split(f2);
        for (a2 = 0; a2 < 3; a2++)
          void 0 !== s2[a2] && (["lch", "lab"].includes(e2) && 0 === a2 || ["hsl", "hsla", "hsv", "hsva", "hwb", "hwba", "hsi", "hsia"].includes(e2) && a2 > 0 ? o2[a2] = ct(s2[a2]) : o2[a2] = Number(s2[a2].trim()));
        ["rgba", "hsla", "hsva", "hwba", "hsia"].includes(e2) ? (e2 = e2.slice(0, -1), void 0 !== s2[3] && (i2 = ct(s2[3]))) : "cmyk" === e2 && o2.push(void 0 !== s2[3] ? ct(s2[3]) : 0);
      }
    }
    if (u3) {
      if (!/^#(([a-fA-F\d]{3}){1,2}|[a-fA-F\d]{8})$/.test(t2))
        try {
          return t2 = function(t3, r3) {
            if (void 0 === r3 && (r3 = false), t3 = t3.toLowerCase(), void 0 === at[t3]) {
              if (r3)
                throw new Error("Unknown color name: ".concat(t3, ")"));
              return t3;
            }
            return at[t3];
          }(t2, true), lt(t2, r2);
        } catch (t3) {
          throw new Error("Invalid Color");
        }
      o2 = h(t2);
    }
  }
  return [e2, o2, i2];
}, pt = { thowParseError: false }, ft = function() {
  function n2(t2, r2, n3) {
    this.cache = /* @__PURE__ */ new Map(), this._rgb = [0, 0, 0], this._alpha = 100;
    var e2 = { thowParseError: pt.thowParseError }, i2 = Object.assign({}, e2, null != n3 ? n3 : {});
    try {
      var a2 = function(t3) {
        var r3, n4 = { lab2rgb: j, hsl2rgb: s, hsv2rgb: b, xyz2rgb: N, hwb2rgb: w, hsi2rgb: d2 }, e3 = lt(t3), i3 = e3[0], a3 = e3[1], u4 = e3[2];
        if ("rgb" === i3)
          return [a3, u4];
        "lch" === i3 && (i3 = (r3 = ["xyz", L(a3[0], a3[1], a3[2])])[0], a3 = r3[1]);
        var h3 = a3[0], c2 = a3[1], p2 = a3[2], f2 = a3[3];
        if ("cmyk" === i3)
          return [l(h3, c2, p2, f2).map(function(t4) {
            return o(t4, 0, 255);
          }), u4];
        var v2 = "".concat(i3, "2rgb");
        if ("function" == typeof n4[v2])
          return [n4[v2](h3, c2, p2).map(function(t4) {
            return o(t4, 0, 255);
          }), u4];
        throw new Error("Invalid color");
      }(t2), u3 = a2[0], h2 = a2[1];
      this._alpha = h2, this._rgb = u3;
    } catch (t3) {
      if (i2.thowParseError)
        throw t3;
    }
    void 0 !== r2 && (this._alpha = o(r2, 0, 100));
  }
  return n2.prototype.red = function(t2) {
    return it(this, "r", t2);
  }, n2.prototype.green = function(t2) {
    return it(this, "g", t2);
  }, n2.prototype.blue = function(t2) {
    return it(this, "b", t2);
  }, n2.prototype.alpha = function(t2) {
    return void 0 === t2 ? this._alpha : (t2 = o(t2, 0, 100), new n2(this.rgb(), t2));
  }, n2.prototype.fadeIn = function(t2, r2) {
    return void 0 === t2 && (t2 = 10), t2 = r2 && "relative" === r2 ? this._alpha * t2 / 100 : t2, new n2(this.rgb(), o(this._alpha + t2, 0, 100));
  }, n2.prototype.fadeOut = function(t2, r2) {
    return void 0 === t2 && (t2 = 10), t2 = r2 && "relative" === r2 ? this._alpha * t2 / 100 : t2, new n2(this.rgb(), o(this._alpha - t2, 0, 100));
  }, n2.prototype.opacify = function(t2, r2) {
    return void 0 === t2 && (t2 = 10), this.fadeIn(t2, r2);
  }, n2.prototype.transparentize = function(t2, r2) {
    return void 0 === t2 && (t2 = 10), this.fadeOut(t2, r2);
  }, n2.prototype.hue = function(t2) {
    return it(this, "h", t2);
  }, n2.prototype.saturation = function(t2) {
    return it(this, "s", t2);
  }, n2.prototype.lightness = function(t2) {
    return it(this, "l", t2);
  }, n2.prototype.rgb = function(t2) {
    return r([], this._rgb, true);
  }, n2.prototype.rgba = function(t2) {
    return r(r([], this.rgb(false), true), [this._alpha], false);
  }, n2.prototype.cmyk = function(t2) {
    return c.apply(void 0, this._rgb);
  }, n2.prototype.hsl = function(t2) {
    return f.apply(void 0, this._rgb);
  }, n2.prototype.hsla = function(t2) {
    return r(r([], this.hsl(false), true), [this._alpha], false);
  }, n2.prototype.hsv = function(t2) {
    return v.apply(void 0, this._rgb);
  }, n2.prototype.hsi = function(t2) {
    return y.apply(void 0, this._rgb);
  }, n2.prototype.hwb = function(t2) {
    return g.apply(void 0, this._rgb);
  }, n2.prototype.xyz = function(t2) {
    return z.apply(void 0, this._rgb);
  }, n2.prototype.lab = function(t2) {
    return O.apply(void 0, this.xyz(false));
  }, n2.prototype.lch = function(t2) {
    return S.apply(void 0, this.lab(false));
  }, n2.prototype.xyY = function(t2) {
    return H.apply(void 0, this.xyz(false));
  }, n2.prototype.hex = function(t2) {
    void 0 === t2 && (t2 = 2);
    var n3 = 0 === t2 ? void 0 : 1 === t2 ? this._alpha : 100 === this._alpha ? void 0 : this._alpha, e2 = "color:hex:param_".concat(t2);
    if (this.cache.has(e2))
      return this.cache.get(e2);
    var o2 = u2.apply(void 0, r(r([], this._rgb, false), [n3], false));
    return this.cache.set(e2, o2), o2;
  }, n2.prototype.lighten = function(t2, r2) {
    void 0 === t2 && (t2 = 5);
    var e2 = this.hsl(false), i2 = e2[0], a2 = e2[1], u3 = e2[2];
    return u3 = o(u3 += void 0 !== r2 && "relative" === r2 ? u3 * (t2 / 100) : t2, 0, 100), new n2(s(i2, a2, u3), this._alpha);
  }, n2.prototype.darken = function(t2, r2) {
    return void 0 === t2 && (t2 = 5), this.lighten(-t2, r2);
  }, n2.prototype.saturate = function(t2, r2) {
    void 0 === t2 && (t2 = 5);
    var e2 = this.hsl(false), i2 = e2[0], a2 = e2[1], u3 = e2[2];
    return a2 = o(a2 += void 0 !== r2 && "relative" === r2 ? a2 * (t2 / 100) : t2, 0, 100), new n2(s(i2, a2, u3), this._alpha);
  }, n2.prototype.desaturate = function(t2, r2) {
    return void 0 === t2 && (t2 = 5), this.saturate(-t2, r2);
  }, n2.prototype.spin = function(t2) {
    var r2 = this.hsl(false), e2 = r2[0], o2 = r2[1], i2 = r2[2];
    return new n2(s(e2 = (e2 + t2 % 360 + 360) % 360, o2, i2), this._alpha);
  }, n2.prototype.adjustHue = function(t2) {
    return this.spin(t2);
  }, n2.prototype.complement = function() {
    return this.spin(180);
  }, n2.prototype.invert = function() {
    var t2 = this._rgb.map(function(t3) {
      return 255 - t3;
    });
    return new n2([t2[0], t2[1], t2[2]], this._alpha);
  }, n2.prototype.mix = function(t2, r2) {
    return void 0 === r2 && (r2 = 50), D(this, t2, 100 - o(r2, 0, 100));
  }, n2.prototype.luma = function() {
    var t2 = this._rgb.map(function(t3) {
      return (t3 /= 255) <= 0.03928 ? t3 / 12.92 : Math.pow((t3 + 0.055) / 1.055, 2.4);
    });
    return 0.2126 * t2[0] + 0.7152 * t2[1] + 0.0722 * t2[2];
  }, n2.prototype.brightness = function() {
    var t2 = this._rgb;
    return function(t3, r2, n3) {
      return (299 * t3 + 587 * r2 + 114 * n3) / 1e3 / 255 * 100;
    }(t2[0], t2[1], t2[2]);
  }, n2.prototype.deltaE = function(t2, r2, n3) {
    return void 0 === r2 && (r2 = "CMC"), et(this, t2, r2, n3);
  }, n2.prototype.visibility = function(t2, r2) {
    return ot(this, t2, r2);
  }, t([q(0, 1, true, 0), R("color:rgb")], n2.prototype, "rgb", null), t([q(0, 1, true, 0)], n2.prototype, "rgba", null), t([q(0, 1, true, 0), R("color:cmyk")], n2.prototype, "cmyk", null), t([q(0, 1, true, 0), R("color:hsl")], n2.prototype, "hsl", null), t([q(0, 1, true, 0)], n2.prototype, "hsla", null), t([q(0, 1, true, 0), R("color:hsv")], n2.prototype, "hsv", null), t([q(0, 1, true, 0), R("color:hsi")], n2.prototype, "hsi", null), t([q(0, 1, true, 0), R("color: hwb")], n2.prototype, "hwb", null), t([q(2, 1, true, 0), R("color:xyz")], n2.prototype, "xyz", null), t([q(2, 1, true, 0), R("color:lab")], n2.prototype, "lab", null), t([q(2, 1, true, 0), R("color:lch")], n2.prototype, "lch", null), t([q(2, 1, true, 0), R("color:xyY")], n2.prototype, "xyY", null), t([R("color:luma")], n2.prototype, "luma", null), n2;
}(), st = function(t2, r2, n2, e2) {
  return new ft([t2, r2, n2], e2);
}, vt = function(t2, r2, n2, e2) {
  return new ft(s(t2, r2, n2), e2);
}, bt = function(t2, r2, n2, e2) {
  return new ft(b(t2, r2, n2), e2);
}, yt = function(t2, r2, n2, e2) {
  return new ft(d2(t2, r2, n2), e2);
}, dt = function(t2, r2, n2, e2) {
  return new ft(w(t2, r2, n2), e2);
}, gt = function(t2, r2, n2, e2) {
  return new ft(N(t2, r2, n2), e2);
}, wt = function(t2, r2, n2, e2) {
  return new ft(j(t2, r2, n2), e2);
}, mt = function(t2, r2, n2, e2) {
  return new ft(N.apply(void 0, L(t2, r2, n2)), e2);
};
function Mt(t2, r2, n2) {
  return new ft(t2, r2, n2);
}
Mt.config = function(t2) {
  Object.assign(pt, t2);
}, Mt.random = function() {
  var t2 = a(0, 255), r2 = a(0, 255), n2 = a(0, 255);
  return new ft([t2, r2, n2]);
}, Mt.convertor = Y, Mt.Color = ft, Mt.rgb = st, Mt.hsl = vt, Mt.hsv = bt, Mt.hsi = yt, Mt.hwb = dt, Mt.xyz = gt, Mt.lab = wt, Mt.lch = mt, Mt.mix = D, Mt.deltaE = et, Mt.utils = { roundDecimal: i, randomRange: a }, Mt.useNames = function(t2, r2) {
  return function(t3, r3) {
    if (void 0 !== r3 && "function" == typeof r3) {
      var n2 = {};
      for (var e2 in t3) {
        var o2 = r3(e2, t3[e2]), i2 = o2[0], a2 = o2[1];
        n2[i2] = a2;
      }
      Object.assign(at, n2);
    } else
      Object.assign(at, t3);
  }(t2, r2), Mt;
};
function lightenColor(color, modifier = 0.35) {
  if (!color)
    color = "70D6FF";
  color = color.toString();
  const hex = color.replace("#", "");
  const RGB = [
    parseInt(hex.substring(0, 2), 16),
    parseInt(hex.substring(2, 4), 16),
    parseInt(hex.substring(4, 6), 16)
  ];
  let result = "#";
  RGB.forEach((color2) => {
    result += Math.round(
      (255 - color2) * (1 - Math.pow(Math.E, -modifier)) + color2
    ).toString(16);
  });
  return result;
}
function darkenColor(color, modifier = 5) {
  return Mt(`#${color}`).darken(modifier, "relative").hex();
}
function invertColor(hex) {
  hex = hex.replace("#", "");
  if (hex.length !== 6)
    return hex;
  return `#${(Number(`0x1${hex}`) ^ 16777215).toString(16).substring(1).toUpperCase()}`;
}
function create_if_block$l(ctx) {
  let div;
  let windowstore;
  let t0;
  let errordialogstore;
  let t1;
  let contextmenu2;
  let t2;
  let arcfind2;
  let div_class_value;
  let current;
  windowstore = new WindowStore_1({});
  errordialogstore = new ErrorDialogStore({});
  contextmenu2 = new ContextMenu({});
  arcfind2 = new ArcFind({});
  return {
    c() {
      div = element("div");
      create_component(windowstore.$$.fragment);
      t0 = space();
      create_component(errordialogstore.$$.fragment);
      t1 = space();
      create_component(contextmenu2.$$.fragment);
      t2 = space();
      create_component(arcfind2.$$.fragment);
      attr(div, "class", div_class_value = "desktop fullscreen " + /*classes*/
      ctx[0] + " theme-" + /*$UserData*/
      ctx[3].sh.desktop.theme + " tb-" + /*$UserData*/
      ctx[3].sh.taskbar.pos + " cursor-" + /*$UserData*/
      (ctx[3].sh.desktop.noCustomCursor ? "" : "custom"));
      attr(
        div,
        "style",
        /*style*/
        ctx[2]
      );
      toggle_class(
        div,
        "show",
        /*$showDesktop*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(windowstore, div, null);
      append(div, t0);
      mount_component(errordialogstore, div, null);
      append(div, t1);
      mount_component(contextmenu2, div, null);
      append(div, t2);
      mount_component(arcfind2, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*classes, $UserData*/
      9 && div_class_value !== (div_class_value = "desktop fullscreen " + /*classes*/
      ctx2[0] + " theme-" + /*$UserData*/
      ctx2[3].sh.desktop.theme + " tb-" + /*$UserData*/
      ctx2[3].sh.taskbar.pos + " cursor-" + /*$UserData*/
      (ctx2[3].sh.desktop.noCustomCursor ? "" : "custom"))) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*style*/
      4) {
        attr(
          div,
          "style",
          /*style*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*classes, $UserData, $showDesktop*/
      41) {
        toggle_class(
          div,
          "show",
          /*$showDesktop*/
          ctx2[5]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(windowstore.$$.fragment, local);
      transition_in(errordialogstore.$$.fragment, local);
      transition_in(contextmenu2.$$.fragment, local);
      transition_in(arcfind2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(windowstore.$$.fragment, local);
      transition_out(errordialogstore.$$.fragment, local);
      transition_out(contextmenu2.$$.fragment, local);
      transition_out(arcfind2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(windowstore);
      destroy_component(errordialogstore);
      destroy_component(contextmenu2);
      destroy_component(arcfind2);
    }
  };
}
function create_fragment$I(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$UserData*/
    ctx[3] && /*$UserName*/
    ctx[4] && /*accent*/
    ctx[1] && create_if_block$l(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$UserData*/
        ctx2[3] && /*$UserName*/
        ctx2[4] && /*accent*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$UserData, $UserName, accent*/
          26) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$l(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$H($$self, $$props, $$invalidate) {
  let $UserData;
  let $previouslyLoaded;
  let $UserName;
  let $showDesktop;
  component_subscribe($$self, UserData$2, ($$value) => $$invalidate(3, $UserData = $$value));
  component_subscribe($$self, previouslyLoaded, ($$value) => $$invalidate(6, $previouslyLoaded = $$value));
  component_subscribe($$self, UserName, ($$value) => $$invalidate(4, $UserName = $$value));
  component_subscribe($$self, showDesktop, ($$value) => $$invalidate(5, $showDesktop = $$value));
  let classes = "";
  let accent = "";
  let style = "";
  desktopClassNames.subscribe((v2) => $$invalidate(0, classes = v2));
  onMount(async () => {
    ArcSoundBus.playSound("arcos.system.logon");
    if ($previouslyLoaded) {
      restart(false);
      return;
    }
    set_store_value(previouslyLoaded, $previouslyLoaded = true, $previouslyLoaded);
    await getUsers();
    await getExperiments();
    await sleep(0);
    assignDesktopListeners();
    importDefault();
    resetDesktopState();
    startKeyListener();
    startMessageCheckInterval();
    checkDesktopFile();
    checkFirefox();
    await checkForUpdates();
    await checkReleaseCandidate();
    await sleep(100);
    showDesktop.set(true);
  });
  UserData$2.subscribe((v2) => {
    if (!v2)
      return;
    $$invalidate(1, accent = $UserData.sh.desktop.accent || "70D6FF");
    $$invalidate(2, style = `
    --accent: #${accent} !important;
    --accent-light: ${lightenColor(accent)} !important;
    --accent-lighter: ${lightenColor(accent, 0.65)} !important;
    --accent-dark: ${darkenColor(accent, 75)} !important;
    --accent-darkest: ${darkenColor(accent, 90)} !important;
    --accent-light-transparent: ${lightenColor(accent)}77 !important;
    --accent-light-invert: ${invertColor(lightenColor(accent))} !important;`);
  });
  function resetDesktopState() {
    WindowStore.set([]);
    isFullscreenWindow.set(false);
    updateStores();
    startOpened.set(false);
    ErrorMessages.set([]);
  }
  return [classes, accent, style, $UserData, $UserName, $showDesktop];
}
class Desktop2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$H, create_fragment$I, safe_not_equal, {});
  }
}
const fts = "";
const connecttocloud = "";
function create_else_block_1$2(ctx) {
  let p2;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "ArcOS didn't hear anything when calling the server you provided, please\n    check the info and try connecting again?";
      t1 = space();
      button = element("button");
      button.textContent = "Try Again";
      attr(p2, "class", "fullwidth centered justified");
      attr(button, "class", "fullwidth option centered");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      insert(target, t1, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*noError*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
        detach(t1);
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$k(ctx) {
  let form;
  let input0;
  let t0;
  let input1;
  let t1;
  let button;
  let button_disabled_value;
  let mounted;
  let dispose;
  function select_block_type_1(ctx2, dirty) {
    if (!/*connecting*/
    ctx2[4])
      return create_if_block_1$4;
    return create_else_block$5;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      form = element("form");
      input0 = element("input");
      t0 = space();
      input1 = element("input");
      t1 = space();
      button = element("button");
      if_block.c();
      attr(input0, "autocomplete", "off");
      attr(input0, "class", "fullwidth centered");
      attr(input0, "placeholder", "Server name");
      attr(input1, "autocomplete", "new-password");
      attr(input1, "type", "password");
      attr(input1, "class", "fullwidth centered");
      attr(input1, "placeholder", "Server authentication code (optional)");
      attr(button, "type", "submit");
      attr(button, "class", "fullwidth option centered");
      button.disabled = button_disabled_value = !/*server*/
      ctx[0] || /*connecting*/
      ctx[4];
      attr(form, "autocomplete", "off");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      append(form, input0);
      set_input_value(
        input0,
        /*server*/
        ctx[0]
      );
      append(form, t0);
      append(form, input1);
      set_input_value(
        input1,
        /*authCode*/
        ctx[1]
      );
      append(form, t1);
      append(form, button);
      if_block.m(button, null);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[7]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[8]
          ),
          listen(button, "click", function() {
            if (is_function(
              /*connect*/
              ctx[3]
            ))
              ctx[3].apply(this, arguments);
          }),
          listen(
            form,
            "submit",
            /*submit*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*server*/
      1 && input0.value !== /*server*/
      ctx[0]) {
        set_input_value(
          input0,
          /*server*/
          ctx[0]
        );
      }
      if (dirty & /*authCode*/
      2 && input1.value !== /*authCode*/
      ctx[1]) {
        set_input_value(
          input1,
          /*authCode*/
          ctx[1]
        );
      }
      if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty & /*server, connecting*/
      17 && button_disabled_value !== (button_disabled_value = !/*server*/
      ctx[0] || /*connecting*/
      ctx[4])) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(form);
      }
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block$5(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Connecting...");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$4(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Connect to server");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$H(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (!/*connectionError*/
    ctx2[2])
      return create_if_block$k;
    return create_else_block_1$2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function instance$G($$self, $$props, $$invalidate) {
  let { server } = $$props;
  let { authCode } = $$props;
  let { connect } = $$props;
  let { connecting } = $$props;
  let { connectionError } = $$props;
  function noError() {
    $$invalidate(2, connectionError = false);
  }
  function submit2(e2) {
    e2.preventDefault();
    connect();
  }
  function input0_input_handler() {
    server = this.value;
    $$invalidate(0, server);
  }
  function input1_input_handler() {
    authCode = this.value;
    $$invalidate(1, authCode);
  }
  $$self.$$set = ($$props2) => {
    if ("server" in $$props2)
      $$invalidate(0, server = $$props2.server);
    if ("authCode" in $$props2)
      $$invalidate(1, authCode = $$props2.authCode);
    if ("connect" in $$props2)
      $$invalidate(3, connect = $$props2.connect);
    if ("connecting" in $$props2)
      $$invalidate(4, connecting = $$props2.connecting);
    if ("connectionError" in $$props2)
      $$invalidate(2, connectionError = $$props2.connectionError);
  };
  return [
    server,
    authCode,
    connectionError,
    connect,
    connecting,
    noError,
    submit2,
    input0_input_handler,
    input1_input_handler
  ];
}
class Custom extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$G, create_fragment$H, safe_not_equal, {
      server: 0,
      authCode: 1,
      connect: 3,
      connecting: 4,
      connectionError: 2
    });
  }
}
function create_fragment$G(ctx) {
  let button;
  let t_value = (
    /*foreign*/
    ctx[0] ? "Use Community API" : "Use custom API"
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "class", "centered flat");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggleForeign*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*foreign*/
      1 && t_value !== (t_value = /*foreign*/
      ctx2[0] ? "Use Community API" : "Use custom API"))
        set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$F($$self, $$props, $$invalidate) {
  let { foreign = false } = $$props;
  let { connectionError = false } = $$props;
  const toggleForeign = () => {
    $$invalidate(0, foreign = !foreign);
    $$invalidate(2, connectionError = false);
  };
  $$self.$$set = ($$props2) => {
    if ("foreign" in $$props2)
      $$invalidate(0, foreign = $$props2.foreign);
    if ("connectionError" in $$props2)
      $$invalidate(2, connectionError = $$props2.connectionError);
  };
  return [foreign, toggleForeign, connectionError];
}
class Toggle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$F, create_fragment$G, safe_not_equal, { foreign: 0, connectionError: 2 });
  }
}
function create_else_block$4(ctx) {
  let button;
  let t_value = (
    /*connecting*/
    ctx[1] ? "Hang on..." : "Continue using Community API"
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "class", "fullwidth centered option");
      button.disabled = /*connecting*/
      ctx[1];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*connect*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*connecting*/
      2 && t_value !== (t_value = /*connecting*/
      ctx2[1] ? "Hang on..." : "Continue using Community API"))
        set_data(t2, t_value);
      if (dirty & /*connecting*/
      2) {
        button.disabled = /*connecting*/
        ctx2[1];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$j(ctx) {
  let custom;
  let updating_server;
  let updating_authCode;
  let updating_connecting;
  let updating_connectionError;
  let current;
  function custom_server_binding(value) {
    ctx[6](value);
  }
  function custom_authCode_binding(value) {
    ctx[7](value);
  }
  function custom_connecting_binding(value) {
    ctx[8](value);
  }
  function custom_connectionError_binding(value) {
    ctx[9](value);
  }
  let custom_props = { connect: (
    /*connect*/
    ctx[5]
  ) };
  if (
    /*server*/
    ctx[0] !== void 0
  ) {
    custom_props.server = /*server*/
    ctx[0];
  }
  if (
    /*authCode*/
    ctx[3] !== void 0
  ) {
    custom_props.authCode = /*authCode*/
    ctx[3];
  }
  if (
    /*connecting*/
    ctx[1] !== void 0
  ) {
    custom_props.connecting = /*connecting*/
    ctx[1];
  }
  if (
    /*connectionError*/
    ctx[2] !== void 0
  ) {
    custom_props.connectionError = /*connectionError*/
    ctx[2];
  }
  custom = new Custom({ props: custom_props });
  binding_callbacks.push(() => bind$1(custom, "server", custom_server_binding));
  binding_callbacks.push(() => bind$1(custom, "authCode", custom_authCode_binding));
  binding_callbacks.push(() => bind$1(custom, "connecting", custom_connecting_binding));
  binding_callbacks.push(() => bind$1(custom, "connectionError", custom_connectionError_binding));
  return {
    c() {
      create_component(custom.$$.fragment);
    },
    m(target, anchor) {
      mount_component(custom, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const custom_changes = {};
      if (!updating_server && dirty & /*server*/
      1) {
        updating_server = true;
        custom_changes.server = /*server*/
        ctx2[0];
        add_flush_callback(() => updating_server = false);
      }
      if (!updating_authCode && dirty & /*authCode*/
      8) {
        updating_authCode = true;
        custom_changes.authCode = /*authCode*/
        ctx2[3];
        add_flush_callback(() => updating_authCode = false);
      }
      if (!updating_connecting && dirty & /*connecting*/
      2) {
        updating_connecting = true;
        custom_changes.connecting = /*connecting*/
        ctx2[1];
        add_flush_callback(() => updating_connecting = false);
      }
      if (!updating_connectionError && dirty & /*connectionError*/
      4) {
        updating_connectionError = true;
        custom_changes.connectionError = /*connectionError*/
        ctx2[2];
        add_flush_callback(() => updating_connectionError = false);
      }
      custom.$set(custom_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(custom.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(custom.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(custom, detaching);
    }
  };
}
function create_fragment$F(ctx) {
  let div;
  let t4;
  let current_block_type_index;
  let if_block;
  let t5;
  let toggle;
  let updating_foreign;
  let updating_connectionError;
  let current;
  const if_block_creators = [create_if_block$j, create_else_block$4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*foreign*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function toggle_foreign_binding(value) {
    ctx[10](value);
  }
  function toggle_connectionError_binding(value) {
    ctx[11](value);
  }
  let toggle_props = {};
  if (
    /*foreign*/
    ctx[4] !== void 0
  ) {
    toggle_props.foreign = /*foreign*/
    ctx[4];
  }
  if (
    /*connectionError*/
    ctx[2] !== void 0
  ) {
    toggle_props.connectionError = /*connectionError*/
    ctx[2];
  }
  toggle = new Toggle({ props: toggle_props });
  binding_callbacks.push(() => bind$1(toggle, "foreign", toggle_foreign_binding));
  binding_callbacks.push(() => bind$1(toggle, "connectionError", toggle_connectionError_binding));
  return {
    c() {
      div = element("div");
      div.innerHTML = `<img src="${ConnectIcon}" alt="Mode"/> <h1>Time to get connected</h1> <p class="subtitle">Where does your account live?</p>`;
      t4 = space();
      if_block.c();
      t5 = space();
      create_component(toggle.$$.fragment);
      attr(div, "class", "header centered");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t4, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t5, anchor);
      mount_component(toggle, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t5.parentNode, t5);
      }
      const toggle_changes = {};
      if (!updating_foreign && dirty & /*foreign*/
      16) {
        updating_foreign = true;
        toggle_changes.foreign = /*foreign*/
        ctx2[4];
        add_flush_callback(() => updating_foreign = false);
      }
      if (!updating_connectionError && dirty & /*connectionError*/
      4) {
        updating_connectionError = true;
        toggle_changes.connectionError = /*connectionError*/
        ctx2[2];
        add_flush_callback(() => updating_connectionError = false);
      }
      toggle.$set(toggle_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(toggle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(toggle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t4);
        detach(t5);
      }
      if_blocks[current_block_type_index].d(detaching);
      destroy_component(toggle, detaching);
    }
  };
}
function instance$E($$self, $$props, $$invalidate) {
  let server = "";
  let connecting = false;
  let connectionError = false;
  let authCode = "";
  let foreign = false;
  async function connect() {
    $$invalidate(1, connecting = true);
    $$invalidate(2, connectionError = false);
    const api2 = foreign ? server.trim() : "community.arcapi.nl";
    const testSuccess = await testConnection(api2.trim(), authCode.trim());
    if (testSuccess) {
      addServer(api2);
      setAuthcode(api2, authCode.trim());
      applyFTSState("finish");
    } else {
      ArcSoundBus.playSound("arcos.dialog.error");
      $$invalidate(2, connectionError = true);
    }
    $$invalidate(1, connecting = false);
  }
  function custom_server_binding(value) {
    server = value;
    $$invalidate(0, server);
  }
  function custom_authCode_binding(value) {
    authCode = value;
    $$invalidate(3, authCode);
  }
  function custom_connecting_binding(value) {
    connecting = value;
    $$invalidate(1, connecting);
  }
  function custom_connectionError_binding(value) {
    connectionError = value;
    $$invalidate(2, connectionError);
  }
  function toggle_foreign_binding(value) {
    foreign = value;
    $$invalidate(4, foreign);
  }
  function toggle_connectionError_binding(value) {
    connectionError = value;
    $$invalidate(2, connectionError);
  }
  return [
    server,
    connecting,
    connectionError,
    authCode,
    foreign,
    connect,
    custom_server_binding,
    custom_authCode_binding,
    custom_connecting_binding,
    custom_connectionError_binding,
    toggle_foreign_binding,
    toggle_connectionError_binding
  ];
}
class ConnectToCloud extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$E, create_fragment$F, safe_not_equal, {});
  }
}
function create_fragment$E(ctx) {
  let div;
  let t4;
  let p1;
  let t6;
  let br;
  let t7;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<img src="${FlagIcon}" alt="Mode"/> <h1>Thank you!</h1> <p class="subtitle">We greatly appreciate it.</p>`;
      t4 = space();
      p1 = element("p");
      p1.textContent = "Thank you for checking out ArcOS! We hope you'll enjoy it as much as we love\n  making it. Please restart ArcOS to use your ArcOS instance.";
      t6 = space();
      br = element("br");
      t7 = space();
      button = element("button");
      button.textContent = "Restart";
      attr(div, "class", "header centered");
      attr(p1, "class", "fullwidth centered justified");
      attr(button, "class", "fullwidth option centered");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t4, anchor);
      insert(target, p1, anchor);
      insert(target, t6, anchor);
      insert(target, br, anchor);
      insert(target, t7, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*restart*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t4);
        detach(p1);
        detach(t6);
        detach(br);
        detach(t7);
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$D($$self) {
  async function restart2() {
    ArcSoundBus.playSound("arcos.system.logoff");
    await sleep(1e3);
    location.reload();
  }
  return [restart2];
}
class Finish extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$D, create_fragment$E, safe_not_equal, {});
  }
}
const license = "";
function create_fragment$D(ctx) {
  let div1;
  let t4;
  let textarea;
  let t5;
  let div4;
  let div2;
  let t9;
  let div3;
  let button0;
  let t11;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div1.innerHTML = `<div class="text"><h1>License Agreement</h1> <p>By using ArcOS, you agree to the GPLv3 License.</p></div> <img src="${SecureIcon}" alt="License" class="license"/>`;
      t4 = space();
      textarea = element("textarea");
      t5 = space();
      div4 = element("div");
      div2 = element("div");
      div2.textContent = `${ArcOSVersion}-${ARCOS_MODE}`;
      t9 = space();
      div3 = element("div");
      button0 = element("button");
      button0.textContent = "Decline";
      t11 = space();
      button1 = element("button");
      button1.textContent = "Accept";
      attr(div1, "class", "header");
      attr(textarea, "class", "license");
      textarea.readOnly = true;
      attr(div2, "class", "version");
      attr(button0, "class", "decline");
      attr(button1, "class", "accept");
      attr(div3, "class", "actions");
      attr(div4, "class", "bottom");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      insert(target, t4, anchor);
      insert(target, textarea, anchor);
      set_input_value(
        textarea,
        /*license*/
        ctx[0]
      );
      insert(target, t5, anchor);
      insert(target, div4, anchor);
      append(div4, div2);
      append(div4, t9);
      append(div4, div3);
      append(div3, button0);
      append(div3, t11);
      append(div3, button1);
      if (!mounted) {
        dispose = [
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[3]
          ),
          listen(
            button0,
            "click",
            /*decline*/
            ctx[1]
          ),
          listen(
            button1,
            "click",
            /*accept*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*license*/
      1) {
        set_input_value(
          textarea,
          /*license*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t4);
        detach(textarea);
        detach(t5);
        detach(div4);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$C($$self, $$props, $$invalidate) {
  let license2 = "";
  onMount(async () => {
    try {
      const req = await (await fetch("./LICENSE")).text();
      $$invalidate(0, license2 = req);
    } catch {
      Log("FTS: License.svelte", "Could not get the LICENSE file.", LogLevel.warn);
      $$invalidate(0, license2 = "Could not GET ./LICENSE");
    }
  });
  function decline() {
    applyFTSState("welcome");
  }
  function accept() {
    applyFTSState("connecttocloud");
  }
  function textarea_input_handler() {
    license2 = this.value;
    $$invalidate(0, license2);
  }
  return [license2, decline, accept, textarea_input_handler];
}
class License extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$C, create_fragment$D, safe_not_equal, {});
  }
}
function create_else_block$3(ctx) {
  let div;
  let img;
  let img_src_value;
  let t0;
  let h1;
  let t2;
  let p2;
  let t3;
  let t4_value = (
    /*release*/
    ctx[1].join(".") + ""
  );
  let t4;
  let t5;
  let t6;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      img = element("img");
      t0 = space();
      h1 = element("h1");
      h1.textContent = "Update available";
      t2 = space();
      p2 = element("p");
      t3 = text("ArcOS version ");
      t4 = text(t4_value);
      t5 = text(" is available.");
      t6 = space();
      button = element("button");
      button.textContent = "Download";
      if (!src_url_equal(img.src, img_src_value = icon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "ArcOS");
      attr(img, "class", "logo");
      attr(h1, "class", "center-header");
      attr(p2, "class", "center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
      append(div, t0);
      append(div, h1);
      append(div, t2);
      append(div, p2);
      append(p2, t3);
      append(p2, t4);
      append(p2, t5);
      append(div, t6);
      append(div, button);
      if (!mounted) {
        dispose = listen(button, "click", update);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*release*/
      2 && t4_value !== (t4_value = /*release*/
      ctx2[1].join(".") + ""))
        set_data(t4, t4_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$i(ctx) {
  let div;
  let spinner2;
  let t0;
  let p2;
  let current;
  spinner2 = new Spinner({ props: { height: 40 } });
  return {
    c() {
      div = element("div");
      create_component(spinner2.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.textContent = "Checking for updates...";
      attr(p2, "class", "center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(spinner2, div, null);
      append(div, t0);
      append(div, p2);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(spinner2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(spinner2);
    }
  };
}
function create_fragment$C(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$i, create_else_block$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*checking*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "center-flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function update() {
  const RELEASE_URL = "https://github.com/IzK-ArcOS/ArcOS-Frontend/releases/latest";
  window.open(RELEASE_URL, "_blank");
}
function instance$B($$self, $$props, $$invalidate) {
  let checking = true;
  let release2 = [0, 0, 0];
  onMount(async () => {
    if (!DESKTOP_MODE)
      return applyFTSState("license");
    $$invalidate(1, release2 = await getLatestVersion());
    const version = parseVersion(ArcOSVersion);
    if (!versionBigger(release2, version)) {
      return applyFTSState("license");
    }
    $$invalidate(0, checking = false);
  });
  return [checking, release2];
}
class Updates extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$B, create_fragment$C, safe_not_equal, {});
  }
}
const welcome = "";
function create_fragment$B(ctx) {
  let div1;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let h1;
  let t2;
  let p2;
  let t4;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      h1 = element("h1");
      h1.textContent = "Welcome";
      t2 = space();
      p2 = element("p");
      p2.textContent = "Time to set-up ArcOS.";
      t4 = space();
      button = element("button");
      button.textContent = "Let's begin";
      if (!src_url_equal(img.src, img_src_value = Logo()))
        attr(img, "src", img_src_value);
      attr(img, "alt", "ArcOS");
      attr(img, "class", "logo");
      attr(h1, "class", "center-header");
      attr(p2, "class", "center");
      attr(div1, "class", "center-flex");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, img);
      append(div0, t0);
      append(div0, h1);
      append(div0, t2);
      append(div0, p2);
      append(div0, t4);
      append(div0, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$A($$self) {
  const click_handler = () => applyFTSState("updates");
  return [click_handler];
}
class Welcome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$A, create_fragment$B, safe_not_equal, {});
  }
}
const FTSStates = /* @__PURE__ */ new Map([
  [
    "welcome",
    {
      name: "Welcome",
      content: Welcome,
      attribs: {},
      key: "welcome",
      image: WaveIcon
    }
  ],
  [
    "updates",
    {
      name: "Check for Updates",
      content: Updates,
      attribs: {},
      key: "updates",
      image: UpdateIcon
    }
  ],
  [
    "license",
    {
      name: "License",
      content: License,
      attribs: {},
      key: "license",
      image: SecureIcon
    }
  ],
  [
    "connecttocloud",
    {
      name: "Connect to ArcOS",
      content: ConnectToCloud,
      attribs: {},
      key: "connecttocloud",
      image: ConnectIcon
    }
  ],
  /* 
  [
    "authmode",
    {
      name: "User Mode",
      content: AuthMode,
      attribs: {},
      key: "authmode",
      image: mode,
    },
  ],
  [
    "auth-existing",
    {
      name: "Existing User",
      content: ExistingAuth,
      attribs: {},
      key: "auth-existing",
      image: account,
    },
  ],
  [
    "auth-new",
    {
      name: "Create Account",
      content: NewAuth,
      attribs: {},
      key: "auth-new",
      image: account,
    },
  ], */
  [
    "finish",
    {
      name: "Finish",
      content: Finish,
      attribs: {},
      key: "finish",
      image: FlagIcon
    }
  ]
]);
const CurrentFTSState = writable();
function applyFTSState(stateKey) {
  if (FTSStates.has(stateKey)) {
    Log("applyFTSState", `Applying state ${stateKey}`);
    const state = FTSStates.get(stateKey);
    CurrentFTSState.set(state);
    return;
  }
  InvalidStateBugrep("FirstTimeSetup", stateKey);
}
function get_each_context$4(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i2][0];
  child_ctx[3] = list2[i2][1];
  return child_ctx;
}
function create_each_block$4(ctx) {
  let div;
  let img;
  let img_src_value;
  let t0;
  let t1_value = (
    /*value*/
    ctx[3].name + ""
  );
  let t1;
  return {
    c() {
      div = element("div");
      img = element("img");
      t0 = space();
      t1 = text(t1_value);
      if (!src_url_equal(img.src, img_src_value = /*value*/
      ctx[3].image))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*value*/
        ctx[3].name
      );
      attr(div, "class", "state");
      toggle_class(
        div,
        "activated",
        /*$CurrentFTSState*/
        ctx[0] && /*$CurrentFTSState*/
        ctx[0].key == /*key*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
      append(div, t0);
      append(div, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$CurrentFTSState*/
      1) {
        toggle_class(
          div,
          "activated",
          /*$CurrentFTSState*/
          ctx2[0] && /*$CurrentFTSState*/
          ctx2[0].key == /*key*/
          ctx2[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$A(ctx) {
  let div;
  let t0;
  let button;
  let mounted;
  let dispose;
  let each_value = ensure_array_like([...FTSStates]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$4(get_each_context$4(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      button = element("button");
      button.innerHTML = `<img src="${ArcTermIcon}" alt="ArcTerm"/> <span>Launch ArcTerm</span>`;
      attr(button, "class", "arcterm");
      attr(div, "class", "left");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      append(div, t0);
      append(div, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*arcterm*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$CurrentFTSState*/
      1) {
        each_value = ensure_array_like([...FTSStates]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$4(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, t0);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$z($$self, $$props, $$invalidate) {
  let $CurrentFTSState;
  component_subscribe($$self, CurrentFTSState, ($$value) => $$invalidate(0, $CurrentFTSState = $$value));
  function arcterm2() {
    applyState("arcterm");
  }
  return [$CurrentFTSState, arcterm2];
}
class Left extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$z, create_fragment$A, safe_not_equal, {});
  }
}
function create_else_block$2(ctx) {
  let div;
  let spinner2;
  let current;
  spinner2 = new Spinner({ props: { height: 60 } });
  return {
    c() {
      div = element("div");
      create_component(spinner2.$$.fragment);
      attr(div, "class", "loading centertext");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(spinner2, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(spinner2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(spinner2);
    }
  };
}
function create_if_block$h(ctx) {
  let div;
  let switch_instance;
  let div_class_value;
  let current;
  var switch_value = (
    /*$CurrentFTSState*/
    ctx[1].content
  );
  function switch_props(ctx2, dirty) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "class", div_class_value = "page " + /*pageCName*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$CurrentFTSState*/
      2 && switch_value !== (switch_value = /*$CurrentFTSState*/
      ctx2[1].content)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      }
      if (!current || dirty & /*pageCName*/
      1 && div_class_value !== (div_class_value = "page " + /*pageCName*/
      ctx2[0])) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_fragment$z(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block$h, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$CurrentFTSState*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", div_class_value = "right " + /*$CurrentFTSState*/
      (ctx[1] ? (
        /*$CurrentFTSState*/
        ctx[1].key
      ) : ""));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*$CurrentFTSState*/
      2 && div_class_value !== (div_class_value = "right " + /*$CurrentFTSState*/
      (ctx2[1] ? (
        /*$CurrentFTSState*/
        ctx2[1].key
      ) : ""))) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$y($$self, $$props, $$invalidate) {
  let $CurrentFTSState;
  component_subscribe($$self, CurrentFTSState, ($$value) => $$invalidate(1, $CurrentFTSState = $$value));
  let pageCName = "";
  let keys = [];
  CurrentFTSState.subscribe((v2) => {
    if (v2) {
      $$invalidate(0, pageCName = v2.name.split(" ")[0].toLowerCase());
    }
  });
  onMount(() => {
    keys = [];
    for (const entry of FTSStates) {
      keys.push(entry[0]);
    }
  });
  return [pageCName, $CurrentFTSState];
}
let Right$1 = class Right extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$y, create_fragment$z, safe_not_equal, {});
  }
};
function create_fragment$y(ctx) {
  let div1;
  let div0;
  let left;
  let t2;
  let right;
  let current;
  left = new Left({});
  right = new Right$1({});
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(left.$$.fragment);
      t2 = space();
      create_component(right.$$.fragment);
      attr(div0, "class", "fts-content");
      attr(div1, "class", "fts fullscreen");
      toggle_class(
        div1,
        "show",
        /*show*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(left, div0, null);
      append(div0, t2);
      mount_component(right, div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*show*/
      1) {
        toggle_class(
          div1,
          "show",
          /*show*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(left.$$.fragment, local);
      transition_in(right.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(left.$$.fragment, local);
      transition_out(right.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(left);
      destroy_component(right);
    }
  };
}
function instance$x($$self, $$props, $$invalidate) {
  let show = false;
  onMount(async () => {
    await sleep(500);
    $$invalidate(0, show = true);
    ArcSoundBus.playSound("arcos.system.logon");
    await sleep(500);
    applyFTSState("welcome");
  });
  return [show];
}
class FirstTimeSetup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$x, create_fragment$y, safe_not_equal, {});
  }
}
const login = "";
function create_if_block$g(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "background fullscreen");
      toggle_class(
        div,
        "zoom",
        /*$CurrentLoginState*/
        ctx[0].attribs.darken
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$CurrentLoginState*/
      1) {
        toggle_class(
          div,
          "zoom",
          /*$CurrentLoginState*/
          ctx2[0].attribs.darken
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$x(ctx) {
  let if_block_anchor;
  let if_block = (
    /*$CurrentLoginState*/
    ctx[0] && create_if_block$g(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*$CurrentLoginState*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$g(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$w($$self, $$props, $$invalidate) {
  let $CurrentLoginState;
  component_subscribe($$self, CurrentLoginState, ($$value) => $$invalidate(0, $CurrentLoginState = $$value));
  return [$CurrentLoginState];
}
let Background$1 = class Background extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$w, create_fragment$x, safe_not_equal, {});
  }
};
function create_if_block$f(ctx) {
  let div;
  let switch_instance;
  let current;
  var switch_value = (
    /*$CurrentLoginState*/
    ctx[0].content
  );
  function switch_props(ctx2, dirty) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "class", "center-absolute");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$CurrentLoginState*/
      1 && switch_value !== (switch_value = /*$CurrentLoginState*/
      ctx2[0].content)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_fragment$w(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$CurrentLoginState*/
    ctx[0] && create_if_block$f(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$CurrentLoginState*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$CurrentLoginState*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$f(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$v($$self, $$props, $$invalidate) {
  let $CurrentLoginState;
  component_subscribe($$self, CurrentLoginState, ($$value) => $$invalidate(0, $CurrentLoginState = $$value));
  return [$CurrentLoginState];
}
class Center extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$v, create_fragment$w, safe_not_equal, {});
  }
}
function create_if_block$e(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "fullscreen darken");
      toggle_class(
        div,
        "show",
        /*$CurrentLoginState*/
        ctx[0].attribs.darken
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$CurrentLoginState*/
      1) {
        toggle_class(
          div,
          "show",
          /*$CurrentLoginState*/
          ctx2[0].attribs.darken
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$v(ctx) {
  let if_block_anchor;
  let if_block = (
    /*$CurrentLoginState*/
    ctx[0] && create_if_block$e(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*$CurrentLoginState*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$e(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$u($$self, $$props, $$invalidate) {
  let $CurrentLoginState;
  component_subscribe($$self, CurrentLoginState, ($$value) => $$invalidate(0, $CurrentLoginState = $$value));
  return [$CurrentLoginState];
}
let Darken$1 = class Darken extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$u, create_fragment$v, safe_not_equal, {});
  }
};
function get_each_context$3(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list2[i2];
  return child_ctx;
}
function create_if_block$d(ctx) {
  let div2;
  let select;
  let option;
  let t1;
  let div0;
  let t2;
  let t3;
  let div1;
  let button0;
  let t5;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*servers*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$3(get_each_context$3(ctx, each_value, i2));
  }
  return {
    c() {
      div2 = element("div");
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      option = element("option");
      option.textContent = "Add Server...";
      t1 = space();
      div0 = element("div");
      t2 = text(
        /*time*/
        ctx[0]
      );
      t3 = space();
      div1 = element("div");
      button0 = element("button");
      button0.innerHTML = `<span class="material-icons-round">power_settings_new</span>`;
      t5 = space();
      button1 = element("button");
      button1.innerHTML = `<span class="material-icons-round">restart_alt</span>`;
      option.__value = "$new";
      set_input_value(option, option.__value);
      attr(select, "class", "host");
      if (
        /*selectedServer*/
        ctx[1] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[8].call(select)
        ));
      attr(div0, "class", "clock");
      attr(button0, "class", "nopad");
      attr(button1, "class", "nopad");
      attr(div1, "class", "right");
      attr(div2, "class", "topbar");
      toggle_class(
        div2,
        "show",
        /*$CurrentLoginState*/
        (ctx[4].attribs.topbar || false) && /*show*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, select);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      append(select, option);
      select_option(
        select,
        /*selectedServer*/
        ctx[1],
        true
      );
      append(div2, t1);
      append(div2, div0);
      append(div0, t2);
      append(div2, t3);
      append(div2, div1);
      append(div1, button0);
      append(div1, t5);
      append(div1, button1);
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*changeServer*/
            ctx[7]
          ),
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[8]
          ),
          listen(
            button0,
            "click",
            /*shutdown*/
            ctx[5]
          ),
          listen(
            button1,
            "click",
            /*restart*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*servers*/
      8) {
        each_value = ensure_array_like(
          /*servers*/
          ctx2[3]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$3(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, option);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*selectedServer, servers*/
      10) {
        select_option(
          select,
          /*selectedServer*/
          ctx2[1]
        );
      }
      if (dirty & /*time*/
      1)
        set_data(
          t2,
          /*time*/
          ctx2[0]
        );
      if (dirty & /*$CurrentLoginState, show*/
      20) {
        toggle_class(
          div2,
          "show",
          /*$CurrentLoginState*/
          (ctx2[4].attribs.topbar || false) && /*show*/
          ctx2[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block$3(ctx) {
  let option;
  let t_value = (
    /*server*/
    ctx[9] + ""
  );
  let t2;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t2 = text(t_value);
      option.__value = option_value_value = /*server*/
      ctx[9];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*servers*/
      8 && t_value !== (t_value = /*server*/
      ctx2[9] + ""))
        set_data(t2, t_value);
      if (dirty & /*servers*/
      8 && option_value_value !== (option_value_value = /*server*/
      ctx2[9])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_fragment$u(ctx) {
  let if_block_anchor;
  let if_block = (
    /*$CurrentLoginState*/
    ctx[4] && create_if_block$d(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*$CurrentLoginState*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$d(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  let $CurrentLoginState;
  component_subscribe($$self, CurrentLoginState, ($$value) => $$invalidate(4, $CurrentLoginState = $$value));
  let time = "";
  let selectedServer = getServer();
  let show = false;
  let servers = [];
  onMount(() => {
    setInterval(() => $$invalidate(0, time = dayjs().format("MMM D, HH:mm")), 500);
    setTimeout(() => $$invalidate(2, show = true), 750);
    $$invalidate(3, servers = getAllServers());
  });
  function shutdown2() {
    loginUsername.set("ArcOS");
    applyLoginState("shutdown");
  }
  function restart2() {
    loginUsername.set("ArcOS");
    applyLoginState("restart");
  }
  function changeServer() {
    setTimeout(() => {
      if (selectedServer == "$new")
        return applyState("fts");
      setServer(selectedServer);
      restart2();
    });
  }
  function select_change_handler() {
    selectedServer = select_value(this);
    $$invalidate(1, selectedServer);
    $$invalidate(3, servers);
  }
  return [
    time,
    selectedServer,
    show,
    servers,
    $CurrentLoginState,
    shutdown2,
    restart2,
    changeServer,
    select_change_handler
  ];
}
let Topbar$1 = class Topbar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$t, create_fragment$u, safe_not_equal, {});
  }
};
function create_fragment$t(ctx) {
  let div;
  let background;
  let t0;
  let darken;
  let t1;
  let topbar;
  let t2;
  let center;
  let current;
  background = new Background$1({});
  darken = new Darken$1({});
  topbar = new Topbar$1({});
  center = new Center({});
  return {
    c() {
      div = element("div");
      create_component(background.$$.fragment);
      t0 = space();
      create_component(darken.$$.fragment);
      t1 = space();
      create_component(topbar.$$.fragment);
      t2 = space();
      create_component(center.$$.fragment);
      attr(div, "class", "login fullscreen");
      toggle_class(
        div,
        "show",
        /*show*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(background, div, null);
      append(div, t0);
      mount_component(darken, div, null);
      append(div, t1);
      mount_component(topbar, div, null);
      append(div, t2);
      mount_component(center, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*show*/
      1) {
        toggle_class(
          div,
          "show",
          /*show*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(background.$$.fragment, local);
      transition_in(darken.$$.fragment, local);
      transition_in(topbar.$$.fragment, local);
      transition_in(center.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(background.$$.fragment, local);
      transition_out(darken.$$.fragment, local);
      transition_out(topbar.$$.fragment, local);
      transition_out(center.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(background);
      destroy_component(darken);
      destroy_component(topbar);
      destroy_component(center);
    }
  };
}
function instance$s($$self, $$props, $$invalidate) {
  let show = false;
  onMount(async () => {
    $$invalidate(0, show = false);
    await loginOnMount();
    $$invalidate(0, show = true);
  });
  return [show];
}
let Login$1 = class Login extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$s, create_fragment$t, safe_not_equal, {});
  }
};
const newlogin = "";
class Login2 {
  constructor(states, initialState, doOnMount = true) {
    __publicField(this, "CurrentState", writable());
    __publicField(this, "UserName", writable());
    __publicField(this, "UserCache", writable());
    __publicField(this, "userBackground", writable("img15"));
    __publicField(this, "_defaultState");
    __publicField(this, "_states");
    Log("newlogin/main.ts: Login.constructor", `Creating new login class`);
    this._states = states;
    this._defaultState = initialState;
    this.UserCache.subscribe(() => this.updateLoginBackground());
    this.UserName.subscribe(() => this.updateLoginBackground());
    if (doOnMount)
      this.onMount();
  }
  updateLoginBackground(v2) {
    v2 = v2 || get_store_value(this.UserCache);
    if (!v2)
      return this.userBackground.set("img15");
    const username = get_store_value(this.UserName);
    const user = v2[username];
    console.log("Updating UserLoginBackground", username, user);
    if (!user || !user.acc || !user.acc.loginBackground)
      return this.userBackground.set("img15");
    this.userBackground.set(user.acc.loginBackground);
  }
  navigate(state, fromInit = false) {
    if (!this._states.has(state) && !fromInit) {
      if (!fromInit)
        return this.navigate(this._defaultState);
      return Log(
        "newlogin/main.ts: Login.navigate",
        `Can't use non-existent initial state ${this._defaultState}!`,
        LogLevel.critical
      );
    }
    Log("newlogin/main.ts: Login.navigate", `Navigating to ${state}`);
    this.CurrentState.set(this._states.get(state));
  }
  async onMount() {
    const allUsers = await getUsers();
    const remembered = localStorage.getItem("arcos-remembered-token");
    const loginState = get_store_value(this.CurrentState);
    const currentApi = get_store_value(ConnectedServer);
    const isFreshApi = !Object.keys(allUsers).length && !remembered;
    const stateIsIncoming = loginState ? loginState.key != "shutdown" && loginState.key != "restart" : true;
    Log(
      "newlogin/main.ts: Login.onMount",
      `isFreshApi=${isFreshApi} StateIsIncoming=${stateIsIncoming}`
    );
    if (isFreshApi) {
      if (!currentApi)
        return applyState("fts");
      return this.navigate("newuserauth");
    }
    if (!loginState)
      this.navigate(remembered ? "autologin" : "selector");
    if (!remembered || !stateIsIncoming)
      return;
    const username = fromBase64(remembered).split(":")[0];
    this.setUser(username);
    const userdata = await loginUsingCreds(remembered);
    if (!userdata) {
      applyLoginState("selector");
      localStorage.removeItem("arcos-remembered-token");
      return;
    }
    this.proceed(userdata, username);
  }
  async Authenticate(username, password) {
    const token = toBase64(`${username}:${password}`);
    const userdata = await loginUsingCreds(token);
    if (!userdata)
      return false;
    localStorage.setItem("arcos-remembered-token", token);
    UserData$2.set(userdata);
    this.setUser(username);
    return userdata;
  }
  setUser(username) {
    this.UserName.set(username);
  }
  async proceed(userdata, username, delay = 1500) {
    Log(
      "newlogin/main.ts: Login.proceed",
      `Proceeding to desktop after ${delay / 1e3} seconds`
    );
    this.UserName.set(username);
    this.setUser(username);
    UserData$2.set(userdata);
    await sleep(delay);
    applyState("desktop");
  }
}
function create_fragment$s(ctx) {
  let profilepicture;
  let t0;
  let h1;
  let t1;
  let current;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*pfp*/
      ctx[0]
    ), height: 151 }
  });
  return {
    c() {
      create_component(profilepicture.$$.fragment);
      t0 = space();
      h1 = element("h1");
      t1 = text(
        /*username*/
        ctx[1]
      );
    },
    m(target, anchor) {
      mount_component(profilepicture, target, anchor);
      insert(target, t0, anchor);
      insert(target, h1, anchor);
      append(h1, t1);
      current = true;
    },
    p(ctx2, [dirty]) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      1)
        profilepicture_changes.src = /*pfp*/
        ctx2[0];
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*username*/
      2)
        set_data(
          t1,
          /*username*/
          ctx2[1]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(h1);
      }
      destroy_component(profilepicture, detaching);
    }
  };
}
function instance$r($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let pfp = "";
  let username = "ArcOS";
  onMount(() => runtime.UserName.subscribe(async (v2) => {
    if (!v2)
      return;
    $$invalidate(1, username = v2);
    $$invalidate(0, pfp = await getUserPfp(v2));
  }));
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [pfp, username, runtime];
}
class UserHeader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$r, create_fragment$s, safe_not_equal, { runtime: 2 });
  }
}
function create_fragment$r(ctx) {
  let h3;
  let spinner2;
  let span;
  let t2;
  let current;
  spinner2 = new Spinner({ props: { height: 25 } });
  return {
    c() {
      h3 = element("h3");
      create_component(spinner2.$$.fragment);
      span = element("span");
      t2 = text(
        /*caption*/
        ctx[0]
      );
      attr(h3, "class", "welcome-spinner");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      mount_component(spinner2, h3, null);
      append(h3, span);
      append(span, t2);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*caption*/
      1)
        set_data(
          t2,
          /*caption*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
      }
      destroy_component(spinner2);
    }
  };
}
function instance$q($$self, $$props, $$invalidate) {
  let { caption = "Welcome" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("caption" in $$props2)
      $$invalidate(0, caption = $$props2.caption);
  };
  return [caption];
}
class WelcomeSpinner extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$q, create_fragment$r, safe_not_equal, { caption: 0 });
  }
}
function create_fragment$q(ctx) {
  let div;
  let userheader;
  let t2;
  let welcomespinner;
  let current;
  userheader = new UserHeader({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  welcomespinner = new WelcomeSpinner({ props: { caption: (
    /*caption*/
    ctx[1]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(userheader.$$.fragment);
      t2 = space();
      create_component(welcomespinner.$$.fragment);
      attr(div, "class", "login-loading");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(userheader, div, null);
      append(div, t2);
      mount_component(welcomespinner, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const userheader_changes = {};
      if (dirty & /*runtime*/
      1)
        userheader_changes.runtime = /*runtime*/
        ctx2[0];
      userheader.$set(userheader_changes);
      const welcomespinner_changes = {};
      if (dirty & /*caption*/
      2)
        welcomespinner_changes.caption = /*caption*/
        ctx2[1];
      welcomespinner.$set(welcomespinner_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(userheader.$$.fragment, local);
      transition_in(welcomespinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(userheader.$$.fragment, local);
      transition_out(welcomespinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(userheader);
      destroy_component(welcomespinner);
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { caption } = $$props;
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("caption" in $$props2)
      $$invalidate(1, caption = $$props2.caption);
  };
  return [runtime, caption];
}
class Loading3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$p, create_fragment$q, safe_not_equal, { runtime: 0, caption: 1 });
  }
}
function create_fragment$p(ctx) {
  let loading;
  let current;
  loading = new Loading3({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      caption: (
        /*CAPTIONS*/
        ctx[2][
          /*key*/
          ctx[1] || "autologin"
        ]
      )
    }
  });
  return {
    c() {
      create_component(loading.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const loading_changes = {};
      if (dirty & /*runtime*/
      1)
        loading_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*key*/
      2)
        loading_changes.caption = /*CAPTIONS*/
        ctx2[2][
          /*key*/
          ctx2[1] || "autologin"
        ];
      loading.$set(loading_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading, detaching);
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { key: key2 = "" } = $$props;
  const CAPTIONS = {
    logoff: "Goodbye!",
    restart: "Restarting",
    shutdown: "Shutting down",
    autologin: "Welcome"
  };
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("key" in $$props2)
      $$invalidate(1, key2 = $$props2.key);
  };
  return [runtime, key2, CAPTIONS];
}
class AutoLogin2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$o, create_fragment$p, safe_not_equal, { runtime: 0, key: 1 });
  }
}
function create_fragment$o(ctx) {
  let p2;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "The password is incorrect. Try again.";
      t1 = space();
      button = element("button");
      button.textContent = "Okay";
      attr(p2, "class", "incorrect");
      attr(button, "class", "normal switchuser");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      insert(target, t1, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
        detach(t1);
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let { errored } = $$props;
  const click_handler = () => $$invalidate(0, errored = false);
  $$self.$$set = ($$props2) => {
    if ("errored" in $$props2)
      $$invalidate(0, errored = $$props2.errored);
  };
  return [errored, click_handler];
}
let Incorrect$1 = class Incorrect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$n, create_fragment$o, safe_not_equal, { errored: 0 });
  }
};
function create_fragment$n(ctx) {
  let button0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      button0.textContent = "Switch User";
      t1 = space();
      button1 = element("button");
      button1.textContent = "I have no account";
      attr(button0, "class", "normal switchuser");
      attr(button1, "class", "normal link createaccount");
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*switchUser*/
            ctx[1]
          ),
          listen(
            button1,
            "click",
            /*register*/
            ctx[0]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t1);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$m($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  async function register2() {
    runtime.setUser(null);
    await sleep(0);
    runtime.navigate("newuserauth");
  }
  async function switchUser() {
    runtime.setUser(null);
    await sleep(0);
    runtime.navigate("selector");
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [register2, switchUser, runtime];
}
let Actions$2 = class Actions3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$n, safe_not_equal, { runtime: 2 });
  }
};
function create_else_block_1$1(ctx) {
  let welcomespinner;
  let current;
  welcomespinner = new WelcomeSpinner({});
  return {
    c() {
      create_component(welcomespinner.$$.fragment);
    },
    m(target, anchor) {
      mount_component(welcomespinner, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(welcomespinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(welcomespinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(welcomespinner, detaching);
    }
  };
}
function create_if_block$c(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$3, create_else_block$1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (!/*errored*/
    ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$1(ctx) {
  let incorrect;
  let updating_errored;
  let current;
  function incorrect_errored_binding(value) {
    ctx[7](value);
  }
  let incorrect_props = {};
  if (
    /*errored*/
    ctx[2] !== void 0
  ) {
    incorrect_props.errored = /*errored*/
    ctx[2];
  }
  incorrect = new Incorrect$1({ props: incorrect_props });
  binding_callbacks.push(() => bind$1(incorrect, "errored", incorrect_errored_binding));
  return {
    c() {
      create_component(incorrect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(incorrect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const incorrect_changes = {};
      if (!updating_errored && dirty & /*errored*/
      4) {
        updating_errored = true;
        incorrect_changes.errored = /*errored*/
        ctx2[2];
        add_flush_callback(() => updating_errored = false);
      }
      incorrect.$set(incorrect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(incorrect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(incorrect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(incorrect, detaching);
    }
  };
}
function create_if_block_1$3(ctx) {
  let div;
  let input;
  let t0;
  let button;
  let t1;
  let button_disabled_value;
  let t2;
  let actions;
  let current;
  let mounted;
  let dispose;
  actions = new Actions$2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      button = element("button");
      t1 = text("arrow_forward_ios");
      t2 = space();
      create_component(actions.$$.fragment);
      attr(input, "type", "password");
      input.disabled = /*loading*/
      ctx[1];
      attr(button, "class", "material-icons-round continue");
      button.disabled = button_disabled_value = !/*password*/
      ctx[3];
      attr(div, "class", "password-wrapper");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(
        input,
        /*password*/
        ctx[3]
      );
      append(div, t0);
      append(div, button);
      append(button, t1);
      insert(target, t2, anchor);
      mount_component(actions, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[6]
          ),
          listen(
            input,
            "keydown",
            /*keydown*/
            ctx[5]
          ),
          listen(
            button,
            "click",
            /*login*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*loading*/
      2) {
        input.disabled = /*loading*/
        ctx2[1];
      }
      if (dirty & /*password*/
      8 && input.value !== /*password*/
      ctx2[3]) {
        set_input_value(
          input,
          /*password*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*password*/
      8 && button_disabled_value !== (button_disabled_value = !/*password*/
      ctx2[3])) {
        button.disabled = button_disabled_value;
      }
      const actions_changes = {};
      if (dirty & /*runtime*/
      1)
        actions_changes.runtime = /*runtime*/
        ctx2[0];
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t2);
      }
      destroy_component(actions, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$m(ctx) {
  let div;
  let userheader;
  let t2;
  let current_block_type_index;
  let if_block;
  let current;
  userheader = new UserHeader({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  const if_block_creators = [create_if_block$c, create_else_block_1$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*loading*/
    ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      create_component(userheader.$$.fragment);
      t2 = space();
      if_block.c();
      attr(div, "class", "login-loading");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(userheader, div, null);
      append(div, t2);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const userheader_changes = {};
      if (dirty & /*runtime*/
      1)
        userheader_changes.runtime = /*runtime*/
        ctx2[0];
      userheader.$set(userheader_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(userheader.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(userheader.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(userheader);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let loading = false;
  let errored = false;
  let password = "";
  async function login2() {
    $$invalidate(1, loading = true);
    const username = get_store_value(runtime.UserName);
    const userdata = await runtime.Authenticate(username, password);
    if (!userdata) {
      $$invalidate(1, loading = false);
      $$invalidate(2, errored = true);
      return;
    }
    await runtime.proceed(userdata, username);
  }
  function keydown(e2) {
    if (e2.key == "Enter")
      login2();
  }
  function input_input_handler() {
    password = this.value;
    $$invalidate(3, password);
  }
  function incorrect_errored_binding(value) {
    errored = value;
    $$invalidate(2, errored);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [
    runtime,
    loading,
    errored,
    password,
    login2,
    keydown,
    input_input_handler,
    incorrect_errored_binding
  ];
}
class ExistingUser extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$m, safe_not_equal, { runtime: 0 });
  }
}
function create_fragment$l(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "I have an account";
      attr(button, "class", "normal link createaccount");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*existing*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  async function existing() {
    runtime.setUser(null);
    await sleep(0);
    runtime.navigate("selector");
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [existing, runtime];
}
let Actions$1 = class Actions4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$l, safe_not_equal, { runtime: 1 });
  }
};
function create_fragment$k(ctx) {
  let div;
  let input;
  let t0;
  let button;
  let t1;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      button = element("button");
      t1 = text("arrow_forward_ios");
      attr(input, "type", "password");
      attr(input, "placeholder", "Confirm Password");
      input.disabled = /*loading*/
      ctx[0];
      attr(button, "class", "material-icons-round continue");
      button.disabled = button_disabled_value = /*loading*/
      ctx[0] || !/*username*/
      ctx[1] || !/*password*/
      ctx[2] || !/*confirm*/
      ctx[3] || /*password*/
      ctx[2] !== /*confirm*/
      ctx[3];
      attr(div, "class", "password-wrapper");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(
        input,
        /*confirm*/
        ctx[3]
      );
      append(div, t0);
      append(div, button);
      append(button, t1);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[8]
          ),
          listen(
            input,
            "keydown",
            /*keydown*/
            ctx[5]
          ),
          listen(
            button,
            "click",
            /*createAccount*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*loading*/
      1) {
        input.disabled = /*loading*/
        ctx2[0];
      }
      if (dirty & /*confirm*/
      8 && input.value !== /*confirm*/
      ctx2[3]) {
        set_input_value(
          input,
          /*confirm*/
          ctx2[3]
        );
      }
      if (dirty & /*loading, username, password, confirm*/
      15 && button_disabled_value !== (button_disabled_value = /*loading*/
      ctx2[0] || !/*username*/
      ctx2[1] || !/*password*/
      ctx2[2] || !/*confirm*/
      ctx2[3] || /*password*/
      ctx2[2] !== /*confirm*/
      ctx2[3])) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let { username } = $$props;
  let { password } = $$props;
  let { loading } = $$props;
  let { errored } = $$props;
  let { runtime } = $$props;
  let confirm = "";
  async function createAccount() {
    $$invalidate(0, loading = true);
    const userdata = await createUser(username, password);
    if (!userdata) {
      $$invalidate(6, errored = true);
      $$invalidate(0, loading = false);
      return false;
    }
    runtime.proceed(userdata, username);
    return false;
  }
  function keydown(e2) {
    if (e2.key == "Enter")
      createAccount();
  }
  function input_input_handler() {
    confirm = this.value;
    $$invalidate(3, confirm);
  }
  $$self.$$set = ($$props2) => {
    if ("username" in $$props2)
      $$invalidate(1, username = $$props2.username);
    if ("password" in $$props2)
      $$invalidate(2, password = $$props2.password);
    if ("loading" in $$props2)
      $$invalidate(0, loading = $$props2.loading);
    if ("errored" in $$props2)
      $$invalidate(6, errored = $$props2.errored);
    if ("runtime" in $$props2)
      $$invalidate(7, runtime = $$props2.runtime);
  };
  return [
    loading,
    username,
    password,
    confirm,
    createAccount,
    keydown,
    errored,
    runtime,
    input_input_handler
  ];
}
class Confirm extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$k, safe_not_equal, {
      username: 1,
      password: 2,
      loading: 0,
      errored: 6,
      runtime: 7
    });
  }
}
function create_fragment$j(ctx) {
  let p2;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "The user already exists.";
      t1 = space();
      button = element("button");
      button.textContent = "Okay";
      attr(p2, "class", "incorrect");
      attr(button, "class", "normal switchuser");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      insert(target, t1, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
        detach(t1);
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let { errored } = $$props;
  const click_handler = () => $$invalidate(0, errored = false);
  $$self.$$set = ($$props2) => {
    if ("errored" in $$props2)
      $$invalidate(0, errored = $$props2.errored);
  };
  return [errored, click_handler];
}
class Incorrect2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$j, safe_not_equal, { errored: 0 });
  }
}
function create_fragment$i(ctx) {
  let input0;
  let t2;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      input0 = element("input");
      t2 = space();
      input1 = element("input");
      attr(input0, "type", "text");
      attr(input0, "placeholder", "Username");
      attr(input0, "class", "field");
      attr(input1, "type", "password");
      attr(input1, "placeholder", "Password");
      attr(input1, "class", "field");
      input1.disabled = /*loading*/
      ctx[2];
    },
    m(target, anchor) {
      insert(target, input0, anchor);
      set_input_value(
        input0,
        /*username*/
        ctx[0]
      );
      insert(target, t2, anchor);
      insert(target, input1, anchor);
      set_input_value(
        input1,
        /*password*/
        ctx[1]
      );
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[3]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*username*/
      1 && input0.value !== /*username*/
      ctx2[0]) {
        set_input_value(
          input0,
          /*username*/
          ctx2[0]
        );
      }
      if (dirty & /*loading*/
      4) {
        input1.disabled = /*loading*/
        ctx2[2];
      }
      if (dirty & /*password*/
      2 && input1.value !== /*password*/
      ctx2[1]) {
        set_input_value(
          input1,
          /*password*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(input0);
        detach(t2);
        detach(input1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let { username = "" } = $$props;
  let { password = "" } = $$props;
  let { loading } = $$props;
  function input0_input_handler() {
    username = this.value;
    $$invalidate(0, username);
  }
  function input1_input_handler() {
    password = this.value;
    $$invalidate(1, password);
  }
  $$self.$$set = ($$props2) => {
    if ("username" in $$props2)
      $$invalidate(0, username = $$props2.username);
    if ("password" in $$props2)
      $$invalidate(1, password = $$props2.password);
    if ("loading" in $$props2)
      $$invalidate(2, loading = $$props2.loading);
  };
  return [username, password, loading, input0_input_handler, input1_input_handler];
}
class UserPassword extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$h, create_fragment$i, safe_not_equal, { username: 0, password: 1, loading: 2 });
  }
}
function create_else_block_1(ctx) {
  let welcomespinner;
  let current;
  welcomespinner = new WelcomeSpinner({});
  return {
    c() {
      create_component(welcomespinner.$$.fragment);
    },
    m(target, anchor) {
      mount_component(welcomespinner, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(welcomespinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(welcomespinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(welcomespinner, detaching);
    }
  };
}
function create_if_block$b(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$2, create_else_block];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (!/*errored*/
    ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block(ctx) {
  let incorrect;
  let updating_errored;
  let current;
  function incorrect_errored_binding(value) {
    ctx[10](value);
  }
  let incorrect_props = {};
  if (
    /*errored*/
    ctx[2] !== void 0
  ) {
    incorrect_props.errored = /*errored*/
    ctx[2];
  }
  incorrect = new Incorrect2({ props: incorrect_props });
  binding_callbacks.push(() => bind$1(incorrect, "errored", incorrect_errored_binding));
  return {
    c() {
      create_component(incorrect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(incorrect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const incorrect_changes = {};
      if (!updating_errored && dirty & /*errored*/
      4) {
        updating_errored = true;
        incorrect_changes.errored = /*errored*/
        ctx2[2];
        add_flush_callback(() => updating_errored = false);
      }
      incorrect.$set(incorrect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(incorrect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(incorrect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(incorrect, detaching);
    }
  };
}
function create_if_block_1$2(ctx) {
  let userpassword;
  let updating_username;
  let updating_password;
  let t0;
  let confirm;
  let updating_loading;
  let updating_errored;
  let t1;
  let actions;
  let current;
  function userpassword_username_binding(value) {
    ctx[6](value);
  }
  function userpassword_password_binding(value) {
    ctx[7](value);
  }
  let userpassword_props = { loading: (
    /*loading*/
    ctx[1]
  ) };
  if (
    /*$username*/
    ctx[4] !== void 0
  ) {
    userpassword_props.username = /*$username*/
    ctx[4];
  }
  if (
    /*password*/
    ctx[3] !== void 0
  ) {
    userpassword_props.password = /*password*/
    ctx[3];
  }
  userpassword = new UserPassword({ props: userpassword_props });
  binding_callbacks.push(() => bind$1(userpassword, "username", userpassword_username_binding));
  binding_callbacks.push(() => bind$1(userpassword, "password", userpassword_password_binding));
  function confirm_loading_binding(value) {
    ctx[8](value);
  }
  function confirm_errored_binding(value) {
    ctx[9](value);
  }
  let confirm_props = {
    username: (
      /*$username*/
      ctx[4]
    ),
    password: (
      /*password*/
      ctx[3]
    ),
    runtime: (
      /*runtime*/
      ctx[0]
    )
  };
  if (
    /*loading*/
    ctx[1] !== void 0
  ) {
    confirm_props.loading = /*loading*/
    ctx[1];
  }
  if (
    /*errored*/
    ctx[2] !== void 0
  ) {
    confirm_props.errored = /*errored*/
    ctx[2];
  }
  confirm = new Confirm({ props: confirm_props });
  binding_callbacks.push(() => bind$1(confirm, "loading", confirm_loading_binding));
  binding_callbacks.push(() => bind$1(confirm, "errored", confirm_errored_binding));
  actions = new Actions$1({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(userpassword.$$.fragment);
      t0 = space();
      create_component(confirm.$$.fragment);
      t1 = space();
      create_component(actions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(userpassword, target, anchor);
      insert(target, t0, anchor);
      mount_component(confirm, target, anchor);
      insert(target, t1, anchor);
      mount_component(actions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const userpassword_changes = {};
      if (dirty & /*loading*/
      2)
        userpassword_changes.loading = /*loading*/
        ctx2[1];
      if (!updating_username && dirty & /*$username*/
      16) {
        updating_username = true;
        userpassword_changes.username = /*$username*/
        ctx2[4];
        add_flush_callback(() => updating_username = false);
      }
      if (!updating_password && dirty & /*password*/
      8) {
        updating_password = true;
        userpassword_changes.password = /*password*/
        ctx2[3];
        add_flush_callback(() => updating_password = false);
      }
      userpassword.$set(userpassword_changes);
      const confirm_changes = {};
      if (dirty & /*$username*/
      16)
        confirm_changes.username = /*$username*/
        ctx2[4];
      if (dirty & /*password*/
      8)
        confirm_changes.password = /*password*/
        ctx2[3];
      if (dirty & /*runtime*/
      1)
        confirm_changes.runtime = /*runtime*/
        ctx2[0];
      if (!updating_loading && dirty & /*loading*/
      2) {
        updating_loading = true;
        confirm_changes.loading = /*loading*/
        ctx2[1];
        add_flush_callback(() => updating_loading = false);
      }
      if (!updating_errored && dirty & /*errored*/
      4) {
        updating_errored = true;
        confirm_changes.errored = /*errored*/
        ctx2[2];
        add_flush_callback(() => updating_errored = false);
      }
      confirm.$set(confirm_changes);
      const actions_changes = {};
      if (dirty & /*runtime*/
      1)
        actions_changes.runtime = /*runtime*/
        ctx2[0];
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(userpassword.$$.fragment, local);
      transition_in(confirm.$$.fragment, local);
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(userpassword.$$.fragment, local);
      transition_out(confirm.$$.fragment, local);
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(userpassword, detaching);
      destroy_component(confirm, detaching);
      destroy_component(actions, detaching);
    }
  };
}
function create_fragment$h(ctx) {
  let div;
  let userheader;
  let t2;
  let current_block_type_index;
  let if_block;
  let current;
  userheader = new UserHeader({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  const if_block_creators = [create_if_block$b, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*loading*/
    ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      create_component(userheader.$$.fragment);
      t2 = space();
      if_block.c();
      attr(div, "class", "login-loading");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(userheader, div, null);
      append(div, t2);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const userheader_changes = {};
      if (dirty & /*runtime*/
      1)
        userheader_changes.runtime = /*runtime*/
        ctx2[0];
      userheader.$set(userheader_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(userheader.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(userheader.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(userheader);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let $username;
  let { runtime } = $$props;
  let loading = false;
  let errored = false;
  let username = writable("");
  component_subscribe($$self, username, (value) => $$invalidate(4, $username = value));
  let password = "";
  username.subscribe((v2) => v2 && runtime.setUser(v2));
  function userpassword_username_binding(value) {
    $username = value;
    username.set($username);
  }
  function userpassword_password_binding(value) {
    password = value;
    $$invalidate(3, password);
  }
  function confirm_loading_binding(value) {
    loading = value;
    $$invalidate(1, loading);
  }
  function confirm_errored_binding(value) {
    errored = value;
    $$invalidate(2, errored);
  }
  function incorrect_errored_binding(value) {
    errored = value;
    $$invalidate(2, errored);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [
    runtime,
    loading,
    errored,
    password,
    $username,
    username,
    userpassword_username_binding,
    userpassword_password_binding,
    confirm_loading_binding,
    confirm_errored_binding,
    incorrect_errored_binding
  ];
}
class NewUser extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$h, safe_not_equal, { runtime: 0 });
  }
}
function create_if_block$a(ctx) {
  let button;
  let profilepicture;
  let t0;
  let p2;
  let t1;
  let current;
  let mounted;
  let dispose;
  profilepicture = new ProfilePicture({
    props: { src: (
      /*pfp*/
      ctx[2]
    ), height: 76 }
  });
  return {
    c() {
      button = element("button");
      create_component(profilepicture.$$.fragment);
      t0 = space();
      p2 = element("p");
      t1 = text(
        /*name*/
        ctx[1]
      );
      attr(p2, "class", "username");
      attr(button, "class", "user");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(profilepicture, button, null);
      append(button, t0);
      append(button, p2);
      append(p2, t1);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*go*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const profilepicture_changes = {};
      if (dirty & /*pfp*/
      4)
        profilepicture_changes.src = /*pfp*/
        ctx2[2];
      profilepicture.$set(profilepicture_changes);
      if (!current || dirty & /*name*/
      2)
        set_data(
          t1,
          /*name*/
          ctx2[1]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(profilepicture.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profilepicture.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(profilepicture);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$g(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*data*/
    ctx[0].acc.enabled && create_if_block$a(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*data*/
        ctx2[0].acc.enabled
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*data*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$a(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let pfp = "";
  let { runtime } = $$props;
  let { data } = $$props;
  let { name } = $$props;
  async function go() {
    runtime.setUser(name);
    runtime.navigate("existinguserauth");
  }
  onMount(() => {
    $$invalidate(2, pfp = getProfilePicture(data.acc.profilePicture));
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(4, runtime = $$props2.runtime);
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("name" in $$props2)
      $$invalidate(1, name = $$props2.name);
  };
  return [data, name, pfp, go, runtime];
}
class User2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$g, safe_not_equal, { runtime: 4, data: 0, name: 1 });
  }
}
function get_each_context$2(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list2[i2];
  return child_ctx;
}
function create_if_block$9(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(Object.keys(
    /*users*/
    ctx[1]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$2(get_each_context$2(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*runtime, users, Object*/
      3) {
        each_value = ensure_array_like(Object.keys(
          /*users*/
          ctx2[1]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$2(ctx) {
  let user;
  let current;
  user = new User2({
    props: {
      runtime: (
        /*runtime*/
        ctx[0]
      ),
      data: (
        /*users*/
        ctx[1][
          /*username*/
          ctx[3]
        ]
      ),
      name: (
        /*username*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(user.$$.fragment);
    },
    m(target, anchor) {
      mount_component(user, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const user_changes = {};
      if (dirty & /*runtime*/
      1)
        user_changes.runtime = /*runtime*/
        ctx2[0];
      if (dirty & /*users*/
      2)
        user_changes.data = /*users*/
        ctx2[1][
          /*username*/
          ctx2[3]
        ];
      if (dirty & /*users*/
      2)
        user_changes.name = /*username*/
        ctx2[3];
      user.$set(user_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(user.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(user.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(user, detaching);
    }
  };
}
function create_fragment$f(ctx) {
  let div1;
  let div0;
  let t0;
  let button;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*users*/
    ctx[1] && create_if_block$9(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      button = element("button");
      button.textContent = "Create Account";
      attr(div0, "class", "users");
      attr(button, "class", "register normal");
      attr(div1, "class", "login-selector");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div1, t0);
      append(div1, button);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*register*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*users*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*users*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let users;
  onMount(async () => {
    runtime.UserCache.subscribe((v2) => v2 && $$invalidate(1, users = v2));
    runtime.UserCache.set(await getUsers());
  });
  async function register2() {
    runtime.setUser(null);
    await sleep(0);
    runtime.navigate("newuserauth");
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
  };
  return [runtime, users, register2];
}
let Selector$1 = class Selector2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$f, safe_not_equal, { runtime: 0 });
  }
};
const NewLoginStates = /* @__PURE__ */ new Map([
  [
    "autologin",
    {
      name: "Auto Login",
      content: AutoLogin2,
      attribs: {
        topbar: false,
        darken: true,
        className: "center-flex"
      },
      key: "autologin"
    }
  ],
  [
    "existinguserauth",
    {
      name: "Existing User Login",
      content: ExistingUser,
      attribs: {
        topbar: false,
        darken: true,
        className: "center-flex"
      },
      key: "existinguserauth"
    }
  ],
  [
    "newuserauth",
    {
      name: "New User",
      content: NewUser,
      attribs: {
        topbar: false,
        darken: true,
        className: "center-flex"
      },
      key: "newuserauth"
    }
  ],
  [
    "selector",
    {
      name: "Selector",
      content: Selector$1,
      attribs: {
        topbar: true,
        darken: false,
        className: "center-flex"
      },
      key: "selector"
    }
  ],
  [
    "shutdown",
    {
      name: "Shutdown",
      content: AutoLogin2,
      attribs: {
        topbar: false,
        darken: true,
        className: "center-flex"
      },
      key: "shutdown",
      onload() {
        setTimeout(() => {
          applyState("turnedoff");
        }, 2e3);
      }
    }
  ],
  [
    "restart",
    {
      name: "Restart",
      content: AutoLogin2,
      attribs: {
        topbar: false,
        darken: true,
        className: "center-flex"
      },
      key: "restart",
      onload() {
        setTimeout(() => {
          location.reload();
        }, 2e3);
      }
    }
  ],
  [
    "logoff",
    {
      name: "Logoff",
      content: AutoLogin2,
      attribs: {
        topbar: false,
        darken: true,
        className: "center-flex"
      },
      key: "logoff",
      onload() {
        setTimeout(() => {
          flush();
          location.reload();
        }, 2e3);
      }
    }
  ]
]);
function create_if_block$8(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "background fullscreen");
      attr(
        div,
        "style",
        /*style*/
        ctx[1]
      );
      toggle_class(
        div,
        "zoom",
        /*state*/
        ctx[0].attribs.darken
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*style*/
      2) {
        attr(
          div,
          "style",
          /*style*/
          ctx2[1]
        );
      }
      if (dirty & /*state*/
      1) {
        toggle_class(
          div,
          "zoom",
          /*state*/
          ctx2[0].attribs.darken
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$e(ctx) {
  let if_block_anchor;
  let if_block = (
    /*state*/
    ctx[0] && create_if_block$8(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*state*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$8(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let { state } = $$props;
  let { runtime } = $$props;
  let style = "img15";
  onMount(() => runtime.userBackground.subscribe(async (v2) => {
    const wallpaper = await getWallpaper(v2 || "img15", "img15");
    $$invalidate(1, style = `--bg: url(${wallpaper.url});`);
  }));
  $$self.$$set = ($$props2) => {
    if ("state" in $$props2)
      $$invalidate(0, state = $$props2.state);
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*style*/
    2)
      ;
  };
  return [state, style, runtime];
}
class Background2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$e, safe_not_equal, { state: 0, runtime: 2 });
  }
}
function create_if_block$7(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "fullscreen darken");
      toggle_class(
        div,
        "show",
        /*state*/
        ctx[0].attribs.darken
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*state*/
      1) {
        toggle_class(
          div,
          "show",
          /*state*/
          ctx2[0].attribs.darken
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$d(ctx) {
  let if_block_anchor;
  let if_block = (
    /*state*/
    ctx[0] && create_if_block$7(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*state*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$7(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  let { state } = $$props;
  $$self.$$set = ($$props2) => {
    if ("state" in $$props2)
      $$invalidate(0, state = $$props2.state);
  };
  return [state];
}
class Darken2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$d, safe_not_equal, { state: 0 });
  }
}
function create_if_block$6(ctx) {
  let div;
  let switch_instance;
  let div_class_value;
  let current;
  var switch_value = (
    /*state*/
    ctx[0].content
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        runtime: (
          /*runtime*/
          ctx2[1]
        ),
        key: (
          /*state*/
          ctx2[0].key
        ),
        loginState: (
          /*state*/
          ctx2[0]
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "class", div_class_value = "login-page fullscreen page-" + /*state*/
      ctx[0].key + " " + /*state*/
      (ctx[0].attribs.className || ""));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*state*/
      1 && switch_value !== (switch_value = /*state*/
      ctx2[0].content)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*runtime*/
        2)
          switch_instance_changes.runtime = /*runtime*/
          ctx2[1];
        if (dirty & /*state*/
        1)
          switch_instance_changes.key = /*state*/
          ctx2[0].key;
        if (dirty & /*state*/
        1)
          switch_instance_changes.loginState = /*state*/
          ctx2[0];
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty & /*state*/
      1 && div_class_value !== (div_class_value = "login-page fullscreen page-" + /*state*/
      ctx2[0].key + " " + /*state*/
      (ctx2[0].attribs.className || ""))) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_fragment$c(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*state*/
    ctx[0] && create_if_block$6(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*state*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*state*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let { state } = $$props;
  let { runtime } = $$props;
  $$self.$$set = ($$props2) => {
    if ("state" in $$props2)
      $$invalidate(0, state = $$props2.state);
    if ("runtime" in $$props2)
      $$invalidate(1, runtime = $$props2.runtime);
  };
  return [state, runtime];
}
class Paging extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$c, safe_not_equal, { state: 0, runtime: 1 });
  }
}
function create_fragment$b(ctx) {
  let div;
  let t2;
  return {
    c() {
      div = element("div");
      t2 = text(
        /*time*/
        ctx[0]
      );
      attr(div, "class", "clock");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*time*/
      1)
        set_data(
          t2,
          /*time*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let time = "";
  setInterval(() => $$invalidate(0, time = dayjs().format("MMM D, HH:mm")), 500);
  return [time];
}
class Clock3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$b, safe_not_equal, {});
  }
}
function get_each_context$1(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list2[i2];
  return child_ctx;
}
function create_each_block$1(ctx) {
  let option;
  let t_value = (
    /*server*/
    ctx[5] + ""
  );
  let t2;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t2 = text(t_value);
      option.__value = option_value_value = /*server*/
      ctx[5];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*servers*/
      2 && t_value !== (t_value = /*server*/
      ctx2[5] + ""))
        set_data(t2, t_value);
      if (dirty & /*servers*/
      2 && option_value_value !== (option_value_value = /*server*/
      ctx2[5])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_fragment$a(ctx) {
  let select;
  let option;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*servers*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1(get_each_context$1(ctx, each_value, i2));
  }
  return {
    c() {
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      option = element("option");
      option.textContent = "Add Server...";
      option.__value = "$new";
      set_input_value(option, option.__value);
      attr(select, "class", "host");
      if (
        /*selectedServer*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[4].call(select)
        ));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      append(select, option);
      select_option(
        select,
        /*selectedServer*/
        ctx[0],
        true
      );
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*changeServer*/
            ctx[2]
          ),
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*servers*/
      2) {
        each_value = ensure_array_like(
          /*servers*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, option);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*selectedServer, servers*/
      3) {
        select_option(
          select,
          /*selectedServer*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let selectedServer = getServer();
  let servers = [];
  onMount(() => {
    $$invalidate(1, servers = getAllServers());
  });
  async function changeServer() {
    await sleep(0);
    if (selectedServer == "$new")
      return applyState("fts");
    setServer(selectedServer);
    runtime.UserName.set("ArcOS");
    runtime.navigate("restart");
  }
  function select_change_handler() {
    selectedServer = select_value(this);
    $$invalidate(0, selectedServer);
    $$invalidate(1, servers);
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(3, runtime = $$props2.runtime);
  };
  return [selectedServer, servers, changeServer, runtime, select_change_handler];
}
class HostSelector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$a, safe_not_equal, { runtime: 3 });
  }
}
function create_fragment$9(ctx) {
  let div;
  let button0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.innerHTML = `<span class="material-icons-round">power_settings_new</span>`;
      t1 = space();
      button1 = element("button");
      button1.innerHTML = `<span class="material-icons-round">restart_alt</span>`;
      attr(button0, "class", "nopad");
      attr(button1, "class", "nopad");
      attr(div, "class", "right");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, t1);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*shutdown*/
            ctx[0]
          ),
          listen(
            button1,
            "click",
            /*restart*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  function shutdown2() {
    runtime.UserName.set("ArcOS");
    runtime.navigate("shutdown");
  }
  function restart2() {
    runtime.UserName.set("ArcOS");
    runtime.navigate("restart");
  }
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(2, runtime = $$props2.runtime);
  };
  return [shutdown2, restart2, runtime];
}
class Right2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$9, safe_not_equal, { runtime: 2 });
  }
}
function create_if_block$5(ctx) {
  let div;
  let hostselector;
  let t0;
  let clock;
  let t1;
  let right;
  let current;
  hostselector = new HostSelector({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  clock = new Clock3({});
  right = new Right2({ props: { runtime: (
    /*runtime*/
    ctx[0]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(hostselector.$$.fragment);
      t0 = space();
      create_component(clock.$$.fragment);
      t1 = space();
      create_component(right.$$.fragment);
      attr(div, "class", "topbar");
      toggle_class(
        div,
        "show",
        /*state*/
        (ctx[1].attribs.topbar || false) && /*show*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(hostselector, div, null);
      append(div, t0);
      mount_component(clock, div, null);
      append(div, t1);
      mount_component(right, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const hostselector_changes = {};
      if (dirty & /*runtime*/
      1)
        hostselector_changes.runtime = /*runtime*/
        ctx2[0];
      hostselector.$set(hostselector_changes);
      const right_changes = {};
      if (dirty & /*runtime*/
      1)
        right_changes.runtime = /*runtime*/
        ctx2[0];
      right.$set(right_changes);
      if (!current || dirty & /*state, show*/
      6) {
        toggle_class(
          div,
          "show",
          /*state*/
          (ctx2[1].attribs.topbar || false) && /*show*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(hostselector.$$.fragment, local);
      transition_in(clock.$$.fragment, local);
      transition_in(right.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hostselector.$$.fragment, local);
      transition_out(clock.$$.fragment, local);
      transition_out(right.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(hostselector);
      destroy_component(clock);
      destroy_component(right);
    }
  };
}
function create_fragment$8(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*state*/
    ctx[1] && create_if_block$5(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*state*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*state*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let { runtime } = $$props;
  let { state } = $$props;
  let show = false;
  onMount(() => {
    setTimeout(() => $$invalidate(2, show = true), 750);
  });
  $$self.$$set = ($$props2) => {
    if ("runtime" in $$props2)
      $$invalidate(0, runtime = $$props2.runtime);
    if ("state" in $$props2)
      $$invalidate(1, state = $$props2.state);
  };
  return [runtime, state, show];
}
class Topbar2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$8, safe_not_equal, { runtime: 0, state: 1 });
  }
}
function create_if_block$4(ctx) {
  let div;
  let background;
  let t0;
  let darken;
  let t1;
  let topbar;
  let t2;
  let paging;
  let current;
  background = new Background2({
    props: {
      state: (
        /*state*/
        ctx[1]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  darken = new Darken2({ props: { state: (
    /*state*/
    ctx[1]
  ) } });
  topbar = new Topbar2({
    props: {
      state: (
        /*state*/
        ctx[1]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  paging = new Paging({
    props: {
      state: (
        /*state*/
        ctx[1]
      ),
      runtime: (
        /*runtime*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(background.$$.fragment);
      t0 = space();
      create_component(darken.$$.fragment);
      t1 = space();
      create_component(topbar.$$.fragment);
      t2 = space();
      create_component(paging.$$.fragment);
      attr(div, "class", "newlogin fullscreen");
      toggle_class(
        div,
        "show",
        /*show*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(background, div, null);
      append(div, t0);
      mount_component(darken, div, null);
      append(div, t1);
      mount_component(topbar, div, null);
      append(div, t2);
      mount_component(paging, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const background_changes = {};
      if (dirty & /*state*/
      2)
        background_changes.state = /*state*/
        ctx2[1];
      if (dirty & /*runtime*/
      1)
        background_changes.runtime = /*runtime*/
        ctx2[0];
      background.$set(background_changes);
      const darken_changes = {};
      if (dirty & /*state*/
      2)
        darken_changes.state = /*state*/
        ctx2[1];
      darken.$set(darken_changes);
      const topbar_changes = {};
      if (dirty & /*state*/
      2)
        topbar_changes.state = /*state*/
        ctx2[1];
      if (dirty & /*runtime*/
      1)
        topbar_changes.runtime = /*runtime*/
        ctx2[0];
      topbar.$set(topbar_changes);
      const paging_changes = {};
      if (dirty & /*state*/
      2)
        paging_changes.state = /*state*/
        ctx2[1];
      if (dirty & /*runtime*/
      1)
        paging_changes.runtime = /*runtime*/
        ctx2[0];
      paging.$set(paging_changes);
      if (!current || dirty & /*show*/
      4) {
        toggle_class(
          div,
          "show",
          /*show*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(background.$$.fragment, local);
      transition_in(darken.$$.fragment, local);
      transition_in(topbar.$$.fragment, local);
      transition_in(paging.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(background.$$.fragment, local);
      transition_out(darken.$$.fragment, local);
      transition_out(topbar.$$.fragment, local);
      transition_out(paging.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(background);
      destroy_component(darken);
      destroy_component(topbar);
      destroy_component(paging);
    }
  };
}
function create_fragment$7(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*runtime*/
    ctx[0] && create_if_block$4(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*runtime*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*runtime*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let $UserName;
  component_subscribe($$self, UserName, ($$value) => $$invalidate(4, $UserName = $$value));
  let { thisState } = $$props;
  let runtime;
  let state;
  let show = false;
  onMount(async () => {
    $$invalidate(0, runtime = new Login2(NewLoginStates, "autologin", !thisState.attribs.continuation));
    if (thisState.attribs.continuation) {
      runtime.setUser($UserName);
      runtime.navigate(thisState.attribs.continuation);
    }
    runtime.UserCache.set(await getUsers());
    await sleep(500);
    $$invalidate(2, show = true);
    runtime.CurrentState.subscribe((v2) => {
      if (!v2)
        return;
      $$invalidate(1, state = v2);
      if (state.onload)
        state.onload();
    });
  });
  $$self.$$set = ($$props2) => {
    if ("thisState" in $$props2)
      $$invalidate(3, thisState = $$props2.thisState);
  };
  return [runtime, state, show, thisState];
}
class NewLogin extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$7, safe_not_equal, { thisState: 3 });
  }
}
const serverselect = "";
function create_if_block$3(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "lock";
      attr(span, "class", "material-icons-round");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$6(ctx) {
  let button1;
  let img;
  let img_src_value;
  let t0;
  let p2;
  let t1_value = (
    /*server*/
    ctx[1].hostname + ""
  );
  let t1;
  let t2;
  let div;
  let button0;
  let t4;
  let mounted;
  let dispose;
  let if_block = (
    /*server*/
    ctx[1].private && create_if_block$3()
  );
  return {
    c() {
      button1 = element("button");
      img = element("img");
      t0 = space();
      p2 = element("p");
      t1 = text(t1_value);
      t2 = space();
      div = element("div");
      button0 = element("button");
      button0.textContent = "delete";
      t4 = space();
      if (if_block)
        if_block.c();
      if (!src_url_equal(img.src, img_src_value = ConnectIcon))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(img, "class", "icon");
      attr(p2, "class", "caption");
      attr(button0, "class", "delete material-icons-round");
      attr(div, "class", "right");
      attr(button1, "class", "option");
      toggle_class(
        button1,
        "selected",
        /*selected*/
        ctx[0] == /*server*/
        ctx[1].hostname
      );
    },
    m(target, anchor) {
      insert(target, button1, anchor);
      append(button1, img);
      append(button1, t0);
      append(button1, p2);
      append(p2, t1);
      append(button1, t2);
      append(button1, div);
      append(div, button0);
      append(div, t4);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*remove*/
            ctx[3]
          ),
          listen(
            button1,
            "click",
            /*select*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*server*/
      2 && t1_value !== (t1_value = /*server*/
      ctx2[1].hostname + ""))
        set_data(t1, t1_value);
      if (
        /*server*/
        ctx2[1].private
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$3();
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*selected, server*/
      3) {
        toggle_class(
          button1,
          "selected",
          /*selected*/
          ctx2[0] == /*server*/
          ctx2[1].hostname
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button1);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let { server } = $$props;
  let { selected } = $$props;
  let { update: update2 } = $$props;
  function select() {
    $$invalidate(0, selected = server.hostname);
  }
  function remove() {
    removeServer(server.hostname);
    const servers = getAllServers();
    if (!servers.length)
      return applyState("fts");
    $$invalidate(0, selected = servers[0]);
    update2();
  }
  $$self.$$set = ($$props2) => {
    if ("server" in $$props2)
      $$invalidate(1, server = $$props2.server);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("update" in $$props2)
      $$invalidate(4, update2 = $$props2.update);
  };
  return [selected, server, select, remove, update2];
}
class Option2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$6, safe_not_equal, { server: 1, selected: 0, update: 4 });
  }
}
function create_if_block$2(ctx) {
  let div;
  let button0;
  let t3;
  let button1;
  let t7;
  let button2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.innerHTML = `<span>Add Server</span> <span class="material-icons-round">add</span>`;
      t3 = space();
      button1 = element("button");
      button1.innerHTML = `<span>Restart</span> <span class="material-icons-round">sync</span>`;
      t7 = space();
      button2 = element("button");
      button2.innerHTML = `<span>Continue</span> <span class="material-icons-round">arrow_forward_ios</span>`;
      attr(button2, "class", "clr-blue");
      attr(div, "class", "actions");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, t3);
      append(div, button1);
      append(div, t7);
      append(div, button2);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*fts*/
            ctx[1]
          ),
          listen(button1, "click", restart$1),
          listen(
            button2,
            "click",
            /*apply*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$5(ctx) {
  let if_block_anchor;
  let if_block = (
    /*servers*/
    ctx[0] && /*servers*/
    ctx[0].length && create_if_block$2(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*servers*/
        ctx2[0] && /*servers*/
        ctx2[0].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function restart$1() {
  location.reload();
}
function instance$4($$self, $$props, $$invalidate) {
  let { servers = [] } = $$props;
  let { selected = "" } = $$props;
  function fts2() {
    applyState("fts");
  }
  function apply() {
    setServer(selected);
    restart$1();
  }
  $$self.$$set = ($$props2) => {
    if ("servers" in $$props2)
      $$invalidate(0, servers = $$props2.servers);
    if ("selected" in $$props2)
      $$invalidate(3, selected = $$props2.selected);
  };
  return [servers, fts2, apply, selected];
}
class Actions5 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$5, safe_not_equal, { servers: 0, selected: 3 });
  }
}
function get_each_context(ctx, list2, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i2];
  return child_ctx;
}
function create_each_block(ctx) {
  let option;
  let updating_selected;
  let current;
  function option_selected_binding(value) {
    ctx[3](value);
  }
  let option_props = {
    server: (
      /*server*/
      ctx[4]
    ),
    update: (
      /*update*/
      ctx[2]
    )
  };
  if (
    /*selected*/
    ctx[0] !== void 0
  ) {
    option_props.selected = /*selected*/
    ctx[0];
  }
  option = new Option2({ props: option_props });
  binding_callbacks.push(() => bind$1(option, "selected", option_selected_binding));
  return {
    c() {
      create_component(option.$$.fragment);
    },
    m(target, anchor) {
      mount_component(option, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const option_changes = {};
      if (dirty & /*servers*/
      2)
        option_changes.server = /*server*/
        ctx2[4];
      if (!updating_selected && dirty & /*selected*/
      1) {
        updating_selected = true;
        option_changes.selected = /*selected*/
        ctx2[0];
        add_flush_callback(() => updating_selected = false);
      }
      option.$set(option_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(option.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(option.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(option, detaching);
    }
  };
}
function create_fragment$4(ctx) {
  let div1;
  let div0;
  let t2;
  let actions;
  let current;
  let each_value = ensure_array_like(
    /*servers*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  actions = new Actions5({
    props: {
      selected: (
        /*selected*/
        ctx[0]
      ),
      servers: (
        /*servers*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      create_component(actions.$$.fragment);
      attr(div0, "class", "options");
      attr(div1, "class", "selector");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div1, t2);
      mount_component(actions, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*servers, update, selected*/
      7) {
        each_value = ensure_array_like(
          /*servers*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const actions_changes = {};
      if (dirty & /*selected*/
      1)
        actions_changes.selected = /*selected*/
        ctx2[0];
      if (dirty & /*servers*/
      2)
        actions_changes.servers = /*servers*/
        ctx2[1];
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      destroy_component(actions);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let { selected = "" } = $$props;
  let { servers = [] } = $$props;
  async function update2() {
    $$invalidate(1, servers = []);
    const list2 = getAllServers().sort();
    for (let i2 = 0; i2 < list2.length; i2++) {
      const ac = getAuthcode(list2[i2]);
      servers.push({
        hostname: list2[i2],
        private: !!ac,
        authCode: ac
      });
    }
  }
  onMount(update2);
  function option_selected_binding(value) {
    selected = value;
    $$invalidate(0, selected);
  }
  $$self.$$set = ($$props2) => {
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("servers" in $$props2)
      $$invalidate(1, servers = $$props2.servers);
  };
  return [selected, servers, update2, option_selected_binding];
}
class Selector3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$4, safe_not_equal, { selected: 0, servers: 1 });
  }
}
function create_fragment$3(ctx) {
  let div2;
  let div1;
  let div0;
  let t2;
  let selector;
  let updating_selected;
  let updating_servers;
  let current;
  function selector_selected_binding(value) {
    ctx[3](value);
  }
  function selector_servers_binding(value) {
    ctx[4](value);
  }
  let selector_props = {};
  if (
    /*selected*/
    ctx[0] !== void 0
  ) {
    selector_props.selected = /*selected*/
    ctx[0];
  }
  if (
    /*servers*/
    ctx[1] !== void 0
  ) {
    selector_props.servers = /*servers*/
    ctx[1];
  }
  selector = new Selector3({ props: selector_props });
  binding_callbacks.push(() => bind$1(selector, "selected", selector_selected_binding));
  binding_callbacks.push(() => bind$1(selector, "servers", selector_servers_binding));
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      div0.innerHTML = `<img src="${ConnectIcon}" alt="" class="logo"/> <h1 class="header">Select Server</h1>`;
      t2 = space();
      create_component(selector.$$.fragment);
      attr(div0, "class", "left");
      attr(div1, "class", "ss-inner");
      attr(div2, "class", "serverselect theme-amoled");
      toggle_class(
        div2,
        "show",
        /*show*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div1, t2);
      mount_component(selector, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const selector_changes = {};
      if (!updating_selected && dirty & /*selected*/
      1) {
        updating_selected = true;
        selector_changes.selected = /*selected*/
        ctx2[0];
        add_flush_callback(() => updating_selected = false);
      }
      if (!updating_servers && dirty & /*servers*/
      2) {
        updating_servers = true;
        selector_changes.servers = /*servers*/
        ctx2[1];
        add_flush_callback(() => updating_servers = false);
      }
      selector.$set(selector_changes);
      if (!current || dirty & /*show*/
      4) {
        toggle_class(
          div2,
          "show",
          /*show*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(selector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(selector);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let selected = "";
  let servers = [];
  let show = false;
  onMount(async () => {
    if (!getAllServers().length) {
      applyState("fts");
      return;
    }
    $$invalidate(0, selected = getServer());
    await sleep(500);
    $$invalidate(2, show = true);
  });
  function selector_selected_binding(value) {
    selected = value;
    $$invalidate(0, selected);
  }
  function selector_servers_binding(value) {
    servers = value;
    $$invalidate(1, servers);
  }
  return [selected, servers, show, selector_selected_binding, selector_servers_binding];
}
class ServerSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$3, safe_not_equal, {});
  }
}
const safetoturnoff = "" + new URL("safetoturnoff-1aac1218.png", import.meta.url).href;
const TurnedOff_svelte_svelte_type_style_lang = "";
function create_fragment$2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<img src="${safetoturnoff}" alt="It&#39;s now safe to turn off your computer." class="svelte-1kzg8gn"/>`;
      attr(div, "class", "svelte-1kzg8gn");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
class TurnedOff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$2, safe_not_equal, {});
  }
}
const States = /* @__PURE__ */ new Map([
  [
    "boot",
    {
      name: "Booting...",
      content: Boot,
      attribs: {},
      key: "boot"
    }
  ],
  [
    "serverselect",
    {
      name: "Server Select",
      content: ServerSelect,
      attribs: {},
      key: "serverselect"
    }
  ],
  [
    "oldlogin",
    { name: "Old Login", content: Login$1, attribs: {}, key: "oldlogin" }
  ],
  [
    "login",
    {
      name: "Login",
      content: NewLogin,
      attribs: {},
      key: "login"
    }
  ],
  [
    "fts",
    {
      name: "First Time Setup",
      content: FirstTimeSetup,
      attribs: {},
      key: "fts"
    }
  ],
  [
    "desktop",
    {
      name: "Desktop",
      content: Desktop2,
      attribs: {},
      key: "desktop"
    }
  ],
  [
    "logoff",
    {
      name: "Logoff",
      content: NewLogin,
      attribs: {
        continuation: "logoff"
      },
      key: "logoff",
      onload() {
        ArcSoundBus.playSound("arcos.system.logoff");
      }
    }
  ],
  [
    "restart",
    {
      name: "Restart",
      content: NewLogin,
      attribs: {
        continuation: "restart"
      },
      key: "restart",
      onload() {
        ArcSoundBus.playSound("arcos.system.logoff");
      }
    }
  ],
  [
    "shutdown",
    {
      name: "Shutdown",
      content: NewLogin,
      attribs: {
        continuation: "shutdown"
      },
      key: "shutdown",
      onload() {
        ArcSoundBus.playSound("arcos.system.logoff");
      }
    }
  ],
  [
    "arcterm",
    {
      name: "ArcTerm",
      content: ArcTerm_12,
      attribs: {},
      key: "arcterm"
    }
  ],
  [
    "crash",
    {
      name: "Aw, snap!",
      content: Crash,
      attribs: {},
      key: "crash"
    }
  ],
  [
    "blank",
    {
      name: "",
      content: Blank,
      attribs: {},
      key: "blank"
    }
  ],
  [
    "turnedoff",
    {
      name: "Turned off",
      content: TurnedOff,
      attribs: {},
      key: "turnedoff",
      onload() {
        window.close();
      }
    }
  ]
]);
const WATCHERS = [];
function onStateChange(event) {
  Log("state/watch.ts: onStateChange", `Adding watcher: ${event.toString()}`);
  WATCHERS.push(event);
  event(CurrentState);
}
async function stateChangeTrigger(state) {
  for (let i2 = 0; i2 < WATCHERS.length; i2++) {
    Log(
      "state/watch.ts: stateChangeTrigger",
      `Triggering watcher at index ${i2}: state changing to ${state.key}`
    );
    await WATCHERS[i2](state);
  }
}
let CurrentState = States[0];
function applyState(stateKey, discontinue = true) {
  if (States.has(stateKey)) {
    Log(
      "state/main.ts: applyState",
      `Applying state ${stateKey}`,
      LogLevel.info
    );
    const state = States.get(stateKey);
    if (state.onload)
      state.onload();
    CurrentState = state;
    UserCache.clear();
    const t2 = `ArcOS | ${state.name}`;
    document.title = t2;
    stateChangeTrigger(CurrentState);
    if (stateKey != "desktop" && discontinue && get_store_value(UserToken))
      logoffToken();
    return;
  }
  InvalidStateBugrep("ArcOS State Switcher", stateKey);
}
const CRASHING = writable(false);
const CRASH_BLACKLIST = [
  "NotAllowedError",
  "NotSupportedError",
  "AbortError",
  "AxiosError",
  "ClientResponseError"
];
const CrashReport = writable();
function isBlackListed(test2) {
  for (let i2 = 0; i2 < CRASH_BLACKLIST.length; i2++) {
    if (test2.includes(CRASH_BLACKLIST[i2]))
      return true;
  }
  return false;
}
function handleWindowError(e2) {
  var _a;
  if (get_store_value(CRASHING))
    return Log(
      "reporting/crash.ts: handleWindowError",
      "Crash prevented because another crash is already in progress!",
      LogLevel.warn
    );
  const error2 = e2;
  const rejection = e2;
  if (rejection && rejection.reason && isBlackListed(rejection.reason.name))
    return Log(
      "reporting/crash.ts: handleWindowError",
      `Not making a report for ${rejection.reason.name}`,
      LogLevel.warn
    );
  CRASHING.set(true);
  Log("ArcOS", `------(#! [ SYSTEM IS CRASHING ] !#)------`, LogLevel.error);
  const filename = error2.filename || rejection.reason.name;
  const position = error2.lineno ? `(${error2.lineno}:${error2.colno})` : "";
  const message = error2.message || rejection.reason.message;
  const stack = ((_a = error2.error) == null ? void 0 : _a.stack) || rejection.reason.stack;
  const options = {
    includeUserData: false,
    includeApi: true,
    title: "Svelte:Window auto-generated error",
    body: `File: ${filename} ${position}

${message}

${stack || "  at ArcOS (no stack)"}`
  };
  const report = createReport(options);
  CrashReport.set(report);
  Log(`Error: ${filename}`, message, LogLevel.error);
  setTimeout(() => {
    applyState("crash");
  }, 2e3);
  sendReport(options);
}
function manualCrash(source2, reason, stack) {
  Log("ArcOS", `------(#! [ SYSTEM IS CRASHING ] !#)------`, LogLevel.error);
  const options = {
    includeUserData: false,
    includeApi: true,
    title: reason,
    body: `Source: ${source2}

${stack || "  at ArcOS (no stack)"}`
  };
  const report = createReport(options);
  CrashReport.set(report);
  Log(`Error: ${source2}`, reason, LogLevel.error);
  setTimeout(() => {
    applyState("crash");
  }, 2e3);
  sendReport(options);
}
const ConnectedServer = writable(null);
const ServerAuthCode = writable(null);
async function apiCall(host, path, params, tokenAuth, credAuth, body, noBody) {
  const credToken = generateCredToken(credAuth);
  const init2 = {
    headers: {
      Authorization: tokenAuth ? `Bearer ${tokenAuth}` : `Basic ${credToken}`
    },
    body,
    method: body ? "post" : "get"
  };
  const noAuth = !credAuth && !tokenAuth;
  const paramStr = generateParamStr({ ...params, ac: get_store_value(ServerAuthCode) });
  let req;
  try {
    req = await fetch(
      `${host}/${path}${paramStr}`,
      noAuth ? { body } : init2
    );
  } catch {
    return {};
  }
  const statusCode = req.status;
  const txt = await req.text();
  if (statusCode == 500) {
    manualCrash(
      "ts/api/main.ts",
      `Server returned status code 500! Please contact BDT`,
      `  at apiCall`
    );
    return { statusCode, valid: false };
  }
  if (!req.ok && (tokenAuth || credAuth) && !`200|304`.includes(`${req.status}`)) {
    return { statusCode, valid: false };
  }
  if (!noBody) {
    try {
      return { ...JSON.parse(txt), statusCode };
    } catch {
      return { statusCode };
    }
  }
  return { statusCode };
}
function generateCredToken(cred) {
  if (!cred)
    return "";
  try {
    return toBase64(`${cred.username}:${cred.password}`);
  } catch {
    return "";
  }
}
async function logoffToken() {
  Log(
    "ts/api/cred.ts: logoffToken",
    `Discontinuing token if present`,
    LogLevel.info
  );
  const token = get_store_value(UserToken);
  const server = get_store_value(ConnectedServer);
  if (!token || !server)
    return;
  UserToken.set(null);
  return await apiCall(server, "logoff", {}, token);
}
async function closeAllProgressively() {
  Log("applogic/close.ts: closeAllProgressively", `Closing entire WindowStore`);
  const ws = get_store_value(WindowStore);
  for (let i2 = 0; i2 < ws.length; i2++) {
    const opened = isOpened(ws[i2].id);
    closeWindow(ws[i2].id);
    await sleep(opened ? 50 : 0);
  }
}
async function shutdown() {
  await closeAllProgressively();
  showDesktop.set(false);
  await sleep(300);
  logoffToken();
  applyState("shutdown");
}
async function restart(eraseToken = false) {
  await closeAllProgressively();
  showDesktop.set(false);
  await sleep(300);
  if (eraseToken) {
    localStorage.removeItem("arcos-remembered-token");
    logoffToken();
  }
  applyState(eraseToken ? "logoff" : "restart");
}
function compileSearchableApps() {
  const result = [];
  const ws = get_store_value(WindowStore);
  for (let i2 = 0; i2 < ws.length; i2++) {
    if (!isPopulatable(ws[i2]))
      continue;
    result.push({
      caption: ws[i2].info.name,
      description: ws[i2].info.description,
      image: ws[i2].info.icon,
      action: () => {
        openWindow(ws[i2].id);
      }
    });
  }
  return result;
}
let FILE_CACHE = [];
let FILES_FAILED = false;
async function compileSearchableFiles() {
  if (FILE_CACHE.length && FILE_CACHE[0])
    return FILE_CACHE;
  const server = get_store_value(ConnectedServer);
  if (!server)
    return [];
  const result = [];
  const req = FILES_FAILED ? { data: [] } : await apiCall(server, "fs/tree", {}, get_store_value(UserToken));
  const files = req.data ? req.data : [];
  if (!files.length)
    FILES_FAILED = true;
  for (let i2 = 0; i2 < files.length; i2++) {
    result.push({
      caption: files[i2].filename,
      action: async () => {
        const notif = makeNotification({
          title: "Loading file",
          message: `Loading file ${files[i2].scopedPath} from the ArcAPI. This can take a while, depending on your internet connection and the size of the file.`,
          buttons: [],
          image: searchIcon
        });
        const scope = files[i2].scopedPath;
        if (scope.startsWith("./"))
          files[i2].scopedPath = scope.replace("./", "");
        const file = await openUserFile(files[i2]);
        deleteNotification(notif);
        WindowStore.set(get_store_value(WindowStore));
        if (file == true)
          return;
        openWithDialog({ ...file, anymime: true });
      },
      description: files[i2].scopedPath.replace(`/${files[i2].filename}`, ""),
      image: fileIcon
    });
  }
  FILE_CACHE = result;
  return result;
}
fbState.subscribe(() => {
  FILE_CACHE = [];
});
function compileSearchableSettingsPages() {
  const result = [];
  const pages = SettingsPages;
  for (let i2 = 0; i2 < pages.length; i2++) {
    const page = pages[i2];
    result.push({
      image: page.icon,
      caption: page.name,
      action: () => {
        openWindow("SettingsApp");
        setTimeout(() => {
          currentSettingsPage.set(page);
        });
      }
    });
  }
  return result;
}
const searchProviders = [
  compileSearchableApps,
  compileSearchableSettingsPages,
  compileSearchableFiles
];
const powerOptions = [
  {
    caption: "Shutdown",
    description: "Leave the desktop and turn off ArcOS",
    action: shutdown,
    image: ShutdownIcon
  },
  {
    caption: "Restart",
    description: "Leave the desktop and reload ArcOS",
    action: () => restart(false),
    image: ShutdownIcon
  }
];
async function getSearchItems() {
  let result = [...powerOptions];
  for (let i2 = 0; i2 < searchProviders.length; i2++) {
    result.push(...await searchProviders[i2]());
  }
  return result;
}
const showArcFind = writable(false);
const arcFindValue = writable("");
async function Search(query) {
  const items = await getSearchItems();
  const options = {
    includeScore: true,
    keys: ["caption", "description"]
  };
  const fuse = new Fuse(items, options);
  const result = fuse.search(query);
  return result;
}
function registerDesktopShortcuts() {
  registerShortcuts([
    {
      key: "q",
      alt: true,
      action() {
        const id = get_store_value(focusedWindowId);
        if (id && id.startsWith("error_"))
          return closeError(parseInt(id.replace("error_", "")));
        if (!getOpenedStore().length) {
          openWindow("Exit");
        } else {
          const window2 = getWindow(get_store_value(focusedWindowId));
          if (window2.state.windowState.fll)
            isFullscreenWindow.set(false);
          closeWindow(get_store_value(focusedWindowId));
        }
        startOpened.set(false);
        ActionCenterOpened.set(false);
        CurrentNotification.set(null);
        focusedWindowId.set(null);
      },
      global: true
    },
    {
      key: "s",
      shift: true,
      alt: true,
      global: true,
      action: () => {
        showArcFind.set(!get_store_value(showArcFind));
      }
    },
    {
      key: "n",
      alt: true,
      global: true,
      action: () => {
        ActionCenterOpened.set(!get_store_value(ActionCenterOpened));
      }
    },
    {
      key: "z",
      alt: true,
      shift: true,
      global: true,
      action: () => {
        openWindow("AppMan");
      }
    }
  ]);
}
const previouslyLoaded = writable(false);
const startOpened = writable(false);
const attentionId = writable("");
const showDesktop = writable(false);
const desktopClassNames = writable("");
function assignDesktopListeners() {
  setDesktopClassNameListener();
  registerDesktopShortcuts();
}
function openWindow(id, openChild = false) {
  Log("events.ts: openWindow", `Opening ${id}`);
  if (isDisabled(id))
    return;
  const window2 = getWindow(id);
  if (window2 && window2.core)
    return;
  const el = getWindowElement(window2);
  if (!el)
    return;
  if (!isLoaded(id) || isOpened(id)) {
    maxZIndex.set(get_store_value(maxZIndex) + 1);
    el.style.zIndex = `${get_store_value(maxZIndex)}`;
    unminimizeWindow(window2);
    return;
  }
  if (window2.parentId && !isOpened(window2.parentId)) {
    if (!openChild) {
      Log(
        "events.ts: openWindow",
        `The parent "${window2.parentId}" of child window "${window2.id}" must be opened before the child can be opened.`,
        LogLevel.error
      );
      return false;
    }
    openWindow(window2.parentId);
  }
  WindowStore.update((ws) => {
    for (let i2 = 0; i2 < ws.length; i2++) {
      if (ws[i2].id == id)
        ws[i2].opened = true;
    }
    return ws;
  });
  setTimeout(() => {
    maxZIndex.set(get_store_value(maxZIndex) + 1);
    el.style.zIndex = `${get_store_value(maxZIndex)}`;
    focusedWindowId.set(id);
    if (window2.events && window2.events.open)
      window2.events.open(window2);
    checkFileRequirement(id);
  }, 10);
  startOpened.set(false);
  ActionCenterOpened.set(false);
  updateStores();
  focusedWindowId.set(id);
  return true;
}
function closeChildWindow(parent, childId) {
  const ws = get_store_value(WindowStore);
  for (let i2 = 0; i2 < ws.length; i2++) {
    if (ws[i2].parentId == parent.id && ws[i2].id == childId) {
      closeWindow(childId);
      return true;
    }
  }
  return false;
}
function closeWindow(id) {
  Log("events.ts: closeWindow", `Closing ${id}`);
  if (!isOpened(id)) {
    return false;
  }
  WindowStore.update((ws) => {
    for (let i2 = 0; i2 < ws.length; i2++) {
      if (ws[i2] && ws[i2].id == id) {
        ws[i2].opened = false;
        ws[i2].openedFile = null;
        break;
      }
    }
    return ws;
  });
  const window2 = getWindow(id);
  if (window2 && window2.core)
    return;
  if (window2.children) {
    const entries = Object.entries(window2.children);
    for (let i2 = 0; i2 < entries.length; i2++) {
      closeChildWindow(window2, entries[i2][0]);
    }
  }
  if (window2.errorOverlays) {
    for (let i2 = 0; i2 < window2.errorOverlays.length; i2++) {
      destroyOverlayableError(window2.errorOverlays[i2].id, window2.id);
    }
  }
  if (window2.overlays) {
    const entries = Object.entries(window2.overlays);
    for (let i2 = 0; i2 < entries.length; i2++) {
      hideOverlay(entries[i2][0], id);
    }
  }
  window2.snapped = false;
  if (window2.events && window2.events.close)
    window2.events.close(window2);
  return true;
}
function maximizeWindow(app) {
  Log(
    "events.ts: maximizeWindow",
    `Switching maximized state of ${app.id}`,
    LogLevel.info
  );
  if (app.core)
    return;
  app.state.windowState.max = !app.state.windowState.max;
  focusedWindowId.set(app.id);
  if (app.events && app.events.maximize)
    app.events.maximize(app);
  updateStores();
}
function minimizeWindow(app) {
  Log(
    "events.ts: minimizeWindow",
    `Switching minimized state of ${app.id}`,
    LogLevel.info
  );
  if (app.core)
    return;
  app.state.windowState.min = !app.state.windowState.min;
  focusedWindowId.set(null);
  if (app.state.windowState.min) {
    const el = getWindowElement(app);
    el.style.zIndex = "0";
  }
  if (app.events && app.events.minimize)
    app.events.minimize(app);
  updateStores();
}
function unminimizeWindow(app) {
  Log(
    "events.ts: unminimizeWindow",
    `Disabling minimized state of ${app.id}`,
    LogLevel.info
  );
  if (app.core)
    return;
  WindowStore.update((ws) => {
    for (let i2 = 0; i2 < ws.length; i2++) {
      if (ws[i2].id == app.id)
        ws[i2].state.windowState.min = false;
    }
    return ws;
  });
  focusedWindowId.set(app.id);
}
function fullscreenToggle(id) {
  Log(
    "events.ts: fullscreenToggle",
    `Switching fullscreen state of ${id}`,
    LogLevel.info
  );
  WindowStore.update((ws) => {
    for (let i2 = 0; i2 < ws.length; i2++) {
      if (ws[i2].id != id)
        continue;
      if (ws[i2].core)
        continue;
      ws[i2].state.windowState.fll = !ws[i2].state.windowState.fll;
    }
    return ws;
  });
}
function requestUserAttention(id) {
  Log(
    "events.ts: requestUserAttention",
    `Requesting user attention for App ${id}`
  );
  if (!getWindow(id) || !isLoaded(id) || isDisabled(id))
    return;
  attentionId.set(id);
}
const defaultReportOptions = {
  includeApi: true,
  includeUserData: false,
  title: "Auto-generated report",
  body: "No user-input was provided when generating this report."
};
function removeApiSensitive(str) {
  const api2 = getServer();
  const ac = getAuthcode(api2);
  str = str.replaceAll(api2, "<api>");
  if (ac && ac.length)
    str = str.replaceAll(ac, "<ac>");
  return str;
}
const pb = new O$1("https://pb.arcapi.nl/");
async function sendReport(options = defaultReportOptions) {
  const report = createReport(options);
  const id = (await pb.collection("bugrep").create(report, { br: "true" })).id;
  if (report.author)
    saveToUser(id);
  return id;
}
function saveToUser(id) {
  const reports = getAppPreference("Reporting", "reports") || [];
  reports.push({ id, timestamp: (/* @__PURE__ */ new Date()).getTime() });
  setAppPreference("Reporting", "reports", reports);
  const trayId = `br$${id}`;
  const title = `Bug Report ${id} sent to ArcOS`;
  createTrayIcon({
    onOpen() {
      openWindow("BugReports");
      disposeTrayIcon(trayId);
    },
    identifier: trayId,
    image: BugRepIcon,
    title
  });
}
function createReport(options = defaultReportOptions) {
  const rnd = () => Math.floor(Math.random() * 1e6);
  const x2 = {
    author: get_store_value(UserName),
    title: options.title,
    body: options.body || "No body",
    version: ArcOSVersion,
    log: removeApiSensitive(compileStringLog().join("\n")),
    userdata: options.includeUserData ? get_store_value(UserData$2) : null,
    api: options.includeApi ? getServer() : null,
    issueid: `${rnd()}-${rnd()}-${rnd()}-${rnd()}`,
    resolved: false,
    closed: false,
    desktop: isDesktop(),
    mode_file: ARCOS_MODE,
    useragent: navigator.userAgent,
    frontend: isDesktop() ? "<desktop>" : location.host,
    location,
    metaenv: { "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false }
  };
  return x2;
}
async function getReport(id) {
  if (!id)
    return null;
  try {
    return await pb.collection("bugrep").getOne(id, { $autoCancel: false, br: "true" });
  } catch {
    return null;
  }
}
async function reportExists(id) {
  return !!await getReport(id);
}
const LogStore = writable([]);
function Log(source2, msg, level = LogLevel.info) {
  const data = { source: source2, msg, level };
  data.timestamp = (/* @__PURE__ */ new Date()).getTime();
  const levelCaption = LogLevelData[LogLevel[data.level]].capt;
  const timestamp = dayjs(data.timestamp || 0).format("HH:mm:ss.mmm");
  LogStore.update((currentLog) => {
    currentLog.push(data);
    return currentLog;
  });
  if (data.level == LogLevel.critical)
    sendReport({
      includeUserData: false,
      includeApi: true,
      title: `Critical state`,
      body: `A log item with state CRITICAL was sent:
${source2}: ${msg}

TS: ${timestamp}`
    });
  console.log(
    `ArcOS: ${timestamp} [${levelCaption}] ${data.source}: ${data.msg}`
  );
}
const OpenedStore = writable([]);
const WindowStore = writable([]);
const isFullscreenWindow = writable(false);
const maxZIndex = writable(1e9);
const focusedWindowId = writable(null);
function getWindow(id) {
  const ws = get_store_value(WindowStore);
  for (let i2 = 0; i2 < ws.length; i2++) {
    if (ws[i2] && ws[i2].id == id)
      return ws[i2];
  }
  return null;
}
function getOpenedStore() {
  const ws = get_store_value(WindowStore);
  const x2 = [];
  for (let i2 = 0; i2 < ws.length; i2++) {
    if (ws[i2].opened)
      x2.push(ws[i2]);
  }
  return x2;
}
function updateStores() {
  Log("store.ts: updateStores", `Flushing all stores`);
  const oa2 = getOpenedStore();
  isFullscreenWindow.set(false);
  WindowStore.update((ws) => {
    for (let i2 = 0; i2 < oa2.length; i2++) {
      const windowData = getWindow(oa2[i2].id);
      if (windowData)
        oa2[i2] = windowData;
      if (oa2[i2] && oa2[i2].state.windowState.fll && !oa2[i2].state.windowState.min) {
        isFullscreenWindow.set(true);
      }
    }
    return ws;
  });
}
WindowStore.subscribe(() => {
  OpenedStore.set(getOpenedStore());
});
function create_if_block$1(ctx) {
  let div3;
  let div1;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let h3;
  let span;
  let t1_value = (
    /*data*/
    ctx[1].icon + ""
  );
  let t1;
  let t2_value = (
    /*data*/
    ctx[1].title + ""
  );
  let t2;
  let t3;
  let p2;
  let raw_value = (
    /*data*/
    ctx[1].message + ""
  );
  let t4;
  let t5;
  let div2;
  let if_block0 = (
    /*data*/
    ctx[1].button && create_if_block_2(ctx)
  );
  let if_block1 = (
    /*data*/
    ctx[1].details && create_if_block_1$1(ctx)
  );
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      h3 = element("h3");
      span = element("span");
      t1 = text(t1_value);
      t2 = text(t2_value);
      t3 = space();
      p2 = element("p");
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      div2 = element("div");
      if (if_block1)
        if_block1.c();
      attr(img, "class", "logo");
      if (!src_url_equal(img.src, img_src_value = Logo()))
        attr(img, "src", img_src_value);
      attr(img, "alt", "ArcOS");
      attr(span, "class", "material-icons-round");
      attr(div1, "class", "content");
      attr(div2, "class", "details");
      attr(div3, "class", "bugrep fullscreen");
      set_style(
        div3,
        "z-index",
        /*$maxZIndex*/
        ctx[2] * 10
      );
      toggle_class(
        div3,
        "show",
        /*show*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      append(div0, img);
      append(div0, t0);
      append(div0, h3);
      append(h3, span);
      append(span, t1);
      append(h3, t2);
      append(div0, t3);
      append(div0, p2);
      p2.innerHTML = raw_value;
      append(div3, t4);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, t5);
      append(div3, div2);
      if (if_block1)
        if_block1.m(div2, null);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      2 && t1_value !== (t1_value = /*data*/
      ctx2[1].icon + ""))
        set_data(t1, t1_value);
      if (dirty & /*data*/
      2 && t2_value !== (t2_value = /*data*/
      ctx2[1].title + ""))
        set_data(t2, t2_value);
      if (dirty & /*data*/
      2 && raw_value !== (raw_value = /*data*/
      ctx2[1].message + ""))
        p2.innerHTML = raw_value;
      if (
        /*data*/
        ctx2[1].button
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          if_block0.m(div3, t5);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*data*/
        ctx2[1].details
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$1(ctx2);
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*$maxZIndex*/
      4) {
        set_style(
          div3,
          "z-index",
          /*$maxZIndex*/
          ctx2[2] * 10
        );
      }
      if (dirty & /*show*/
      1) {
        toggle_class(
          div3,
          "show",
          /*show*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_2(ctx) {
  let button;
  let t_value = (
    /*data*/
    ctx[1].button.caption + ""
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*buttonEvent*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      2 && t_value !== (t_value = /*data*/
      ctx2[1].button.caption + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$1(ctx) {
  let p0;
  let span0;
  let t1;
  let t2_value = (
    /*data*/
    (ctx[1].source || "<anonymous>") + ""
  );
  let t2;
  let t3;
  let p1;
  let span1;
  let t5;
  let code;
  let t6_value = (
    /*data*/
    (ctx[1].details || "<anonymous>") + ""
  );
  let t6;
  return {
    c() {
      p0 = element("p");
      span0 = element("span");
      span0.textContent = "Source :";
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      p1 = element("p");
      span1 = element("span");
      span1.textContent = "Details:";
      t5 = space();
      code = element("code");
      t6 = text(t6_value);
      attr(span0, "class", "title");
      attr(span1, "class", "title");
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      append(p0, span0);
      append(p0, t1);
      append(p0, t2);
      insert(target, t3, anchor);
      insert(target, p1, anchor);
      append(p1, span1);
      append(p1, t5);
      append(p1, code);
      append(code, t6);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      2 && t2_value !== (t2_value = /*data*/
      (ctx2[1].source || "<anonymous>") + ""))
        set_data(t2, t2_value);
      if (dirty & /*data*/
      2 && t6_value !== (t6_value = /*data*/
      (ctx2[1].details || "<anonymous>") + ""))
        set_data(t6, t6_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p0);
        detach(t3);
        detach(p1);
      }
    }
  };
}
function create_fragment$1(ctx) {
  let if_block_anchor;
  let if_block = (
    /*show*/
    ctx[0] && create_if_block$1(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*show*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $maxZIndex;
  component_subscribe($$self, maxZIndex, ($$value) => $$invalidate(2, $maxZIndex = $$value));
  let show = false;
  let data;
  function buttonEvent() {
    data.button.action();
    BugReportData.set([false, null]);
  }
  BugReportData.subscribe((v2) => {
    if (v2) {
      $$invalidate(0, show = v2[0]);
      $$invalidate(1, data = v2[1]);
    }
  });
  return [show, data, $maxZIndex, buttonEvent];
}
class BugReport extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, {});
  }
}
const { window: window_1 } = globals;
function create_if_block(ctx) {
  let div;
  let t2;
  let bugreport;
  let current;
  let if_block = (
    /*state*/
    ctx[0] && create_if_block_1(ctx)
  );
  bugreport = new BugReport({});
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t2 = space();
      create_component(bugreport.$$.fragment);
      attr(div, "class", "app fullscreen theme-dark");
      toggle_class(div, "noglass", navigator.userAgent.toLowerCase().includes("firefox"));
      toggle_class(div, "noani", navigator.userAgent.toLowerCase().includes("firefox"));
      toggle_class(
        div,
        "cursor-busy",
        /*$committingUserData*/
        ctx[3] || /*$Busy*/
        ctx[4]
      );
      toggle_class(div, "rotate", ARCOS_MODE == "siege");
      toggle_class(
        div,
        "gray",
        /*$CRASHING*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t2);
      mount_component(bugreport, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*state*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*state*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*navigator*/
      0) {
        toggle_class(div, "noglass", navigator.userAgent.toLowerCase().includes("firefox"));
      }
      if (!current || dirty & /*navigator*/
      0) {
        toggle_class(div, "noani", navigator.userAgent.toLowerCase().includes("firefox"));
      }
      if (!current || dirty & /*$committingUserData, $Busy*/
      24) {
        toggle_class(
          div,
          "cursor-busy",
          /*$committingUserData*/
          ctx2[3] || /*$Busy*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*$CRASHING*/
      32) {
        toggle_class(
          div,
          "gray",
          /*$CRASHING*/
          ctx2[5]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(bugreport.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(bugreport.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      destroy_component(bugreport);
    }
  };
}
function create_if_block_1(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*state*/
    ctx[0].content
  );
  function switch_props(ctx2, dirty) {
    return { props: { thisState: (
      /*state*/
      ctx2[0]
    ) } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*state*/
      1 && switch_value !== (switch_value = /*state*/
      ctx2[0].content)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*state*/
        1)
          switch_instance_changes.thisState = /*state*/
          ctx2[0];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment(ctx) {
  let link;
  let t2;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*run*/
    ctx[1] && create_if_block(ctx)
  );
  return {
    c() {
      link = element("link");
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(link, "rel", "icon");
      attr(
        link,
        "href",
        /*logo*/
        ctx[2]
      );
    },
    m(target, anchor) {
      append(document.head, link);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          window_1,
          "error",
          /*error_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*logo*/
      4) {
        attr(
          link,
          "href",
          /*logo*/
          ctx2[2]
        );
      }
      if (
        /*run*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*run*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      detach(link);
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $committingUserData;
  let $Busy;
  let $CRASHING;
  component_subscribe($$self, committingUserData, ($$value) => $$invalidate(3, $committingUserData = $$value));
  component_subscribe($$self, Busy, ($$value) => $$invalidate(4, $Busy = $$value));
  component_subscribe($$self, CRASHING, ($$value) => $$invalidate(5, $CRASHING = $$value));
  let run2 = false;
  let logo = "";
  let state = CurrentState;
  onMount(async () => {
    await getMode();
    await getDesktopMode();
    await getBuild();
    onStateChange((s2) => {
      if (!s2)
        return;
      $$invalidate(0, state = s2);
    });
    Log("ArcOS", `ARCOS_VERSION = ${ArcOSVersion} | ARCOS_MODE = ${ARCOS_MODE} | ARCOS_BUILD = ${ARCOS_BUILD} | DESKTOP_MODE = ${DESKTOP_MODE} `, LogLevel.warn);
    applyState("boot");
    window.addEventListener("beforeunload", logoffToken);
    $$invalidate(2, logo = Logo());
    $$invalidate(1, run2 = true);
    window.onunhandledrejection = (e2) => {
      handleWindowError(e2);
    };
    window.onbeforeunload = () => {
      const state2 = CurrentState.key;
      if (DESKTOP_MODE !== "desktop" && (state2 == "desktop" || state2 == "arcterm"))
        return false;
    };
  });
  const error_handler = (e2) => handleWindowError(e2);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*state*/
    1)
      ;
  };
  return [state, run2, logo, $committingUserData, $Busy, $CRASHING, error_handler];
}
class App2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
}
const observer = new MutationObserver(mutationCallback);
function attachDisableAnchorRedirection() {
  const anchors = document.querySelectorAll("a");
  for (let i2 = 0; i2 < anchors.length; i2++) {
    anchors[i2].addEventListener("click", (e2) => e2.preventDefault());
  }
}
function mutationCallback(mutationsList) {
  for (let i2 = 0; i2 < mutationsList.length; i2++) {
    const mutation = mutationsList[i2];
    if (mutation.type !== "childList")
      continue;
    attachDisableAnchorRedirection();
  }
}
function preventAnchorRedirects() {
  observer.observe(document.body, { childList: true, subtree: true });
}
migrateToMulti();
preventAnchorRedirects();
document.addEventListener("contextmenu", (e2) => e2.preventDefault());
console.warn = (content2, ...a2) => !content2.includes("expected prop") || !content2.includes("unknown prop") && Log("Console", content2 + a2.join(" "), LogLevel.warn);
console.error = (content2, ...a2) => Log("Console", content2 + a2.join(" "), LogLevel.error);
new App2({
  target: document.getElementById("app")
});
